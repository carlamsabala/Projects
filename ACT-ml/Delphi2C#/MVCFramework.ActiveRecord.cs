
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Reflection;
using System.Threading;

namespace MVCFramework.ActiveRecord
{
    #region Exceptions

    public class MVCActiveRecordException : Exception
    {
        public int HttpStatusCode { get; protected set; }

        public MVCActiveRecordException(string message)
            : base(message)
        {
            HttpStatusCode = 400;
        }

        public MVCActiveRecordException(string message, Exception innerException)
            : base(message, innerException)
        {
            HttpStatusCode = 400;
        }
    }

    public class MVCActiveRecordNotFoundException : MVCActiveRecordException
    {
        public MVCActiveRecordNotFoundException(string message)
            : base(message)
        {
            HttpStatusCode = 404;
        }
    }

    public class MVCActiveRecordValidationErrorException : MVCActiveRecordException
    {
        public string PropertyName { get; private set; }

        public MVCActiveRecordValidationErrorException(string propertyName, string validationError)
            : base(validationError)
        {
            PropertyName = propertyName;
            HttpStatusCode = 400;
        }
    }

    public class MVCActiveRecordTransactionContextException : MVCActiveRecordException
    {
        public MVCActiveRecordTransactionContextException(string message)
            : base(message)
        { }
    }

    #endregion

    #region Enumerations and Attributes

    [Flags]
    public enum MVCActiveRecordFieldOption
    {
        None = 0,
        PrimaryKey = 1,
        AutoGenerated = 2,
        ReadOnly = 4,
        Version = 8,
        DoNotSelect = 16,
        DoNotInsert = 32,
        DoNotUpdate = 64
    }

    [Flags]
    public enum MVCEntityAction
    {
        Create = 1,
        Retrieve = 2,
        Update = 4,
        Delete = 8
    }

    [Flags]
    public enum MVCActiveRecordLoadOption
    {
        None = 0,
        IgnoreNotExistentFields = 1
    }

    
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class MVCTableAttribute : Attribute
    {
        public string Name { get; }
        public string RQLFilter { get; }

        public MVCTableAttribute(string name) : this(name, string.Empty) { }

        public MVCTableAttribute(string name, string rqlFilter)
        {
            Name = name;
            RQLFilter = rqlFilter;
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class MVCPartitionAttribute : Attribute
    {
        public string PartitionClause { get; }
        public MVCPartitionAttribute(string partitionClause)
        {
            PartitionClause = partitionClause;
        }
    }

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
    public class MVCTableFieldAttribute : Attribute
    {
        public string FieldName { get; }
        public MVCActiveRecordFieldOption FieldOptions { get; }
        public string SequenceName { get; }
        public string DataTypeName { get; }

        public MVCTableFieldAttribute(string fieldName, MVCActiveRecordFieldOption fieldOptions, string sequenceName = "", string dataTypeName = "")
        {
            FieldName = fieldName;
            FieldOptions = fieldOptions;
            SequenceName = sequenceName;
            DataTypeName = dataTypeName;
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class MVCNamedSQLQueryAttribute : Attribute
    {
        public string Name { get; }
        public string SQLQuery { get; }
        public string Backend { get; }

        public MVCNamedSQLQueryAttribute(string name, string sqlQuery)
            : this(name, sqlQuery, string.Empty)
        { }

        public MVCNamedSQLQueryAttribute(string name, string sqlQuery, string backend)
        {
            Name = name;
            SQLQuery = sqlQuery;
            Backend = backend;
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class MVCNamedRQLQueryAttribute : Attribute
    {
        public string Name { get; }
        public string RQLQuery { get; }
        public MVCNamedRQLQueryAttribute(string name, string rqlQuery)
        {
            Name = name;
            RQLQuery = rqlQuery;
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class MVCEntityActionsAttribute : Attribute
    {
        public MVCEntityAction EntityAllowedActions { get; }
        public MVCEntityActionsAttribute(MVCEntityAction entityAllowedActions)
        {
            EntityAllowedActions = entityAllowedActions;
        }
    }

    #endregion

    #region Field Mapping Classes


    public class FieldInfo
    {
        public string FieldName { get; set; }
        public MVCActiveRecordFieldOption FieldOptions { get; set; }
        public string DataTypeName { get; set; }
        public bool Selectable { get; set; }
        public bool Insertable { get; set; }
        public bool Updatable { get; set; }
        public bool IsVersion { get; set; }

        public void EndUpdates()
        {
            
            if (string.IsNullOrWhiteSpace(FieldName))
            {
                Selectable = false;
                Insertable = false;
                Updatable = false;
            }
            else
            {
                Selectable = !FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotSelect);
                Insertable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotInsert) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));
                Updatable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotUpdate) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));

                if (FieldOptions.HasFlag(MVCActiveRecordFieldOption.ReadOnly))
                {
                    Insertable = false;
                    Updatable = false;
                    Selectable = true;
                }
            }
        }
    }

    
    public class FieldsMap : Dictionary<MemberInfo, FieldInfo>
    {
        public int WritableFieldsCount { get; private set; }
        public int ReadableFieldsCount { get; private set; }

        public FieldsMap() : base(new MemberInfoComparer())
        {
            WritableFieldsCount = -1;
            ReadableFieldsCount = -1;
        }

        public void EndUpdates()
        {
            WritableFieldsCount = 0;
            ReadableFieldsCount = 0;
            foreach (var pair in this)
            {
                pair.Value.EndUpdates();
                if (pair.Value.Insertable || pair.Value.Updatable)
                    WritableFieldsCount++;
                if (pair.Value.Selectable)
                    ReadableFieldsCount++;
            }
        }

        public FieldInfo GetInfoByFieldName(string fieldName)
        {
            foreach (var pair in this)
            {
                if (string.Equals(pair.Value.FieldName, fieldName, StringComparison.OrdinalIgnoreCase))
                    return pair.Value;
            }
            throw new MVCActiveRecordException($"FieldName [{fieldName}] not found in table mapping.");
        }
    }

    
    public class MemberInfoComparer : IEqualityComparer<MemberInfo>
    {
        public bool Equals(MemberInfo x, MemberInfo y)
        {
            return x.Name.Equals(y.Name, StringComparison.OrdinalIgnoreCase);
        }

        public int GetHashCode(MemberInfo obj)
        {
            return obj.Name.ToLowerInvariant().GetHashCode();
        }
    }

    #endregion

    #region Base ActiveRecord Classes

    
    public abstract class MVCActiveRecord
    {
        
        protected DbConnection Connection { get; private set; }

        protected FieldsMap FieldMapping { get; set; }

        public virtual string TableName { get; protected set; }

        public virtual string PrimaryKeyName { get; protected set; }

        public virtual bool PrimaryKeyIsAutogenerated { get; set; }

        protected abstract MVCSQLGenerator CreateSQLGenerator();

        protected MVCSQLGenerator SQLGenerator { get; private set; }

        protected MVCActiveRecord()
        {
            Connection = MVCActiveRecordConnectionRegistry.CurrentConnection;
            InitializeMapping();
            SQLGenerator = CreateSQLGenerator();
        }

        protected virtual void InitializeMapping()
        {
            var type = this.GetType();
            var tableAttr = type.GetCustomAttribute<MVCTableAttribute>();
            if (tableAttr != null)
            {
                TableName = tableAttr.Name;
            }
            else
            {
                TableName = type.Name;
            }
            FieldMapping = new FieldsMap();
        }

        
        public virtual void OnValidation(MVCEntityAction action)
        {
            // Do nothing by default.
        }

        
        public void Store()
        {
            if (IsPrimaryKeyNull())
            {
                Insert();
            }
            else
            {
                Update();
            }
        }

        
        public virtual void Insert()
        {
            OnValidation(MVCEntityAction.Create);
            if (!PrimaryKeyIsAutogenerated)
            {
                // â€¦ code to fill primary key from sequence, if needed.
            }
            string sql = SQLGenerator.CreateInsertSQL(TableName, FieldMapping, this);
            ExecuteNonQuery(sql);
            
            OnAfterInsert();
        }

        
        public virtual void Update()
        {
            OnValidation(MVCEntityAction.Update);
            string sql = SQLGenerator.CreateUpdateSQL(TableName, FieldMapping, this);
            int affected = ExecuteNonQuery(sql);
            if (affected == 0)
            {
                throw new MVCActiveRecordNotFoundException($"No record updated for primary key [{PrimaryKeyName}] in table [{TableName}].");
            }
            OnAfterUpdate();
        }

        
        public virtual void Delete()
        {
            OnValidation(MVCEntityAction.Delete);
            string sql = SQLGenerator.CreateDeleteSQL(TableName, PrimaryKeyName, this);
            int affected = ExecuteNonQuery(sql);
            if (affected == 0)
            {
                throw new MVCActiveRecordNotFoundException($"No record deleted for primary key [{PrimaryKeyName}] in table [{TableName}].");
            }
            OnAfterDelete();
        }

        
        public virtual void Refresh()
        {
            if (IsPrimaryKeyNull())
            {
                throw new MVCActiveRecordException("Cannot refresh an object with an empty primary key.");
            }
            string sql = SQLGenerator.CreateSelectByPKSQL(TableName, FieldMapping, PrimaryKeyName);
            DataSet ds = ExecuteQuery(sql, new object[] { GetPrimaryKeyValue() });
            if (ds.Tables[0].Rows.Count == 0)
            {
                throw new MVCActiveRecordNotFoundException("Record not found.");
            }
            MapDataRowToObject(ds.Tables[0].Rows[0]);
        }

        
        protected virtual int ExecuteNonQuery(string sql)
        {
            
            Console.WriteLine("ExecuteNonQuery: " + sql);
            return 1;
        }

        protected virtual DataSet ExecuteQuery(string sql, object[] parameters)
        {
            
            Console.WriteLine("ExecuteQuery: " + sql);
            return new DataSet();
        }

        
        protected virtual void MapDataRowToObject(DataRow row)
        {
            // Use reflection or a mapping framework to assign values from row to properties.
        }

        
        public virtual object GetPrimaryKeyValue()
        {
            
            return null;
        }

        
        public virtual bool IsPrimaryKeyNull()
        {
            var pk = GetPrimaryKeyValue();
            return pk == null || string.IsNullOrEmpty(pk.ToString());
        }

        
        protected virtual void OnAfterInsert() { }
        protected virtual void OnAfterUpdate() { }
        protected virtual void OnAfterDelete() { }

        
    }

    #endregion

    #region SQL Generator (Skeleton)

    
    public abstract class MVCSQLGenerator
    {
        protected FieldsMap Mapping { get; }
        protected string DefaultRQLFilter { get; }
        

        public MVCSQLGenerator(FieldsMap mapping, string defaultRQLFilter)
        {
            Mapping = mapping;
            DefaultRQLFilter = defaultRQLFilter;
        }

        public abstract string CreateInsertSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);
        public abstract string CreateUpdateSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);
        public abstract string CreateDeleteSQL(string tableName, string primaryKeyName, MVCActiveRecord ar);
        public abstract string CreateSelectByPKSQL(string tableName, FieldsMap mapping, string primaryKeyName);
    }

    
    public class MVCSQLGeneratorRegistry
    {
        private static readonly Dictionary<string, Type> sqlGenerators = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        private static readonly object lockObj = new object();

        public static void RegisterSQLGenerator(string backend, Type sqlGeneratorType)
        {
            lock (lockObj)
            {
                sqlGenerators[backend] = sqlGeneratorType;
            }
        }

        public static MVCSQLGenerator GetSQLGenerator(string backend, FieldsMap mapping, string defaultRQLFilter)
        {
            lock (lockObj)
            {
                if (!sqlGenerators.TryGetValue(backend, out Type generatorType))
                {
                    throw new MVCActiveRecordException($"SQLGenerator not found for backend \"{backend}\".");
                }
                return (MVCSQLGenerator)Activator.CreateInstance(generatorType, mapping, defaultRQLFilter);
            }
        }
    }

    #endregion

    #region Connection Registry

    
    public static class MVCActiveRecordConnectionRegistry
    {
        
        public static DbConnection CurrentConnection { get; set; }

        static MVCActiveRecordConnectionRegistry()
        {
            
            // CurrentConnection = new YourDbConnection(...);
        }
    }

    #endregion

    #region MVCActiveRecord Helper (Static methods)

    public static class MVCActiveRecordHelper
    {
        
        public static T GetByPK<T>(this T ar, object primaryKey, bool raiseExceptionIfNotFound = true)
            where T : MVCActiveRecord, new()
        {
            T recordInstance = new T();
            throw new NotImplementedException("GetByPK is not implemented");
        }

        public static List<T> Select<T>(string sql, object[] parameters) where T : MVCActiveRecord, new()
        {
            T instance = new T();
            throw new NotImplementedException("Select is not implemented");
        }

        
    }

    #endregion

    #region Interfaces

    
    public interface IMVCEntityProcessor
    {
        void GetEntities(object context, object renderer, string entityName, ref bool handled);
        void GetEntity(object context, object renderer, string entityName, int id, ref bool handled);
        void CreateEntity(object context, object renderer, string entityName, ref bool handled);
        void UpdateEntity(object context, object renderer, string entityName, int id, ref bool handled);
        void DeleteEntity(object context, object renderer, string entityName, int id, ref bool handled);
    }

    #endregion

    #region (Optional) Unit Of Work and MultiExecutor Interfaces

    

    public interface IMVCUnitOfWork<T> where T : MVCActiveRecord
    {
        void RegisterInsert(T value);
        void RegisterUpdate(T value);
        void RegisterDelete(T value);
        void UnregisterInsert(T value);
        void UnregisterUpdate(T value);
        void UnregisterDelete(T value);
    }

    public interface IMVCMultiExecutor<T> where T : MVCActiveRecord
    {
        void Apply(Action<T, MVCEntityAction, ref bool> itemApplyAction = null);
    }

    #endregion

    #region (Optional) Table Map and Registry Classes

    

    public class MVCTableMap
    {
        public string TableName { get; set; }
        public string PrimaryKeyFieldName { get; set; }
        public bool IsVersioned { get; set; }
        public string VersionFieldName { get; set; }
        public FieldsMap Map { get; set; }
        public string DefaultRQLFilter { get; set; }

        public MVCTableMap()
        {
            Map = new FieldsMap();
        }

       
        public long VersionValueAsInt64For(MVCActiveRecord ar)
        {
            
            return 1;
        }
    }

    #endregion

    #region (Optional) Entities Registry and Connections Repository

    

    public interface IMVCEntitiesRegistry
    {
        void AddEntity(string urlSegment, Type activeRecordClass);
        void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor);
        bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass);
        bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor);
        string[] GetEntities();
        KeyValuePair<string, Type>[] GetURLSegmentWithEntities();
    }

    public class MVCEntitiesRegistry : IMVCEntitiesRegistry
    {
        private readonly Dictionary<string, Type> entitiesDict = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, IMVCEntityProcessor> processorsDict = new Dictionary<string, IMVCEntityProcessor>(StringComparer.OrdinalIgnoreCase);

        public void AddEntity(string urlSegment, Type activeRecordClass)
        {
            entitiesDict[urlSegment.ToLower()] = activeRecordClass;
        }

        public void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor)
        {
            processorsDict[urlSegment.ToLower()] = entityProcessor;
        }

        public bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass)
        {
            return entitiesDict.TryGetValue(urlSegment.ToLower(), out activeRecordClass);
        }

        public bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor)
        {
            return processorsDict.TryGetValue(urlSegment.ToLower(), out entityProcessor);
        }

        public string[] GetEntities()
        {
            var keys = new List<string>(entitiesDict.Keys);
            return keys.ToArray();
        }

        public KeyValuePair<string, Type>[] GetURLSegmentWithEntities()
        {
            var list = new List<KeyValuePair<string, Type>>(entitiesDict);
            return list.ToArray();
        }
    }

    #endregion

    
}

