{"input": "unit uBase.Controller;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.Serializer.Commons, JsonDataObjects,\n  uServices;\n\ntype\n\n  [MVCPath('/')]\n  TBaseController = class(TMVCController)\n  protected\n    PageData: TJsonObject;\n    procedure OnBeforeAction(AContext: TWebContext; const AActionName: string; var AHandled: Boolean); override;\n    procedure OnAfterAction(AContext: TWebContext; const AActionName: string); override;\n  private\n    FGenreService: TGenreService;\n    FMovieService: TMovieService;\n  strict protected\n    function GetGenreService: TGenreService;\n    function GetMovieService: TMovieService;\n  public\n    destructor Destroy; override;\n  public\n    [MVCPath(''), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    function Index: String;\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\ndestructor TBaseController.Destroy;\nbegin\n  if FGenreService <> nil then\n    FGenreService.Free;\n  if FMovieService <> nil then\n    FMovieService.Free;\n\n  inherited;\nend;\n\nfunction TBaseController.GetMovieService: TMovieService;\nbegin\n  if FMovieService = nil then\n    FMovieService := TMovieService.Create;\n  Result := FMovieService;\nend;\n\nfunction TBaseController.GetGenreService: TGenreService;\nbegin\n  if FGenreService = nil then\n    FGenreService := TGenreService.Create;\n  Result := FGenreService;\nend;\n\nfunction TBaseController.Index: String;\nbegin\n  Result := RenderViews(['header', 'index', 'footer']);\nend;\n\nprocedure TBaseController.OnAfterAction(AContext: TWebContext; const AActionName: string);\nbegin\n  PageData.Free;\n  inherited;\nend;\n\nprocedure TBaseController.OnBeforeAction(AContext: TWebContext; const AActionName: string; var AHandled: Boolean);\nbegin\n  inherited;\n  PageData := TJsonObject.Create;\n  ViewData['page'] := PageData;\n  PageData.S['copyright'] := Format('Copyright %s', [FormatDateTime('yyyy', Now)]);\n  PageData.S['version'] := Format('Version %d', [GetFileVersion(ParamStr(0))]);\nend;\n\nend.", "output": "using System;\nusing System.Globalization;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Commons;\nusing JsonDataObjects;\nusing uServices;\n\nnamespace uBase.Controller\n{\n    [MVCPath(\"/\")]\n    public class BaseController : MVCController\n    {\n        protected JsonObject PageData;\n        private TGenreService _genreService;\n        private TMovieService _movieService;\n\n        protected override void OnBeforeAction(TWebContext context, string actionName, ref bool handled)\n        {\n            base.OnBeforeAction(context, actionName, ref handled);\n            PageData = new JsonObject();\n            ViewData[\"page\"] = PageData;\n            PageData[\"copyright\"] = string.Format(\"Copyright {0}\", DateTime.Now.ToString(\"yyyy\", CultureInfo.InvariantCulture));\n            PageData[\"version\"] = string.Format(\"Version {0}\", GetFileVersion(ParamStr(0)));\n        }\n\n        protected override void OnAfterAction(TWebContext context, string actionName)\n        {\n            PageData.Dispose();\n            base.OnAfterAction(context, actionName);\n        }\n\n        public override void Dispose()\n        {\n            if (_genreService != null)\n            {\n                _genreService.Dispose();\n                _genreService = null;\n            }\n            if (_movieService != null)\n            {\n                _movieService.Dispose();\n                _movieService = null;\n            }\n            base.Dispose();\n        }\n\n        protected TMovieService GetMovieService()\n        {\n            if (_movieService == null)\n                _movieService = new TMovieService();\n            return _movieService;\n        }\n\n        protected TGenreService GetGenreService()\n        {\n            if (_genreService == null)\n                _genreService = new TGenreService();\n            return _genreService;\n        }\n\n        [MVCPath(\"\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public string Index()\n        {\n            return RenderViews(new string[] { \"header\", \"index\", \"footer\" });\n        }\n\n        private int GetFileVersion(string fileName)\n        {\n            return 1;\n        }\n\n        private string ParamStr(int index)\n        {\n            return AppDomain.CurrentDomain.FriendlyName;\n        }\n    }\n}"}
{"input": "unit Horse.Rtti;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils, RTTI,\n{$ELSE}\n  System.SysUtils,\n  System.Rtti,\n{$ENDIF}\n  Horse.Commons;\n\ntype\n  THorseRtti = class\n  private\n    class var FHorseRtti: THorseRtti;\n    FContext: TRttiContext;\n  protected\n    class function GetDefaultHorseRtti: THorseRtti;\n  public\n    function GetType(const AClass: TClass): TRttiType;\n    constructor Create; virtual;\n    class destructor UnInitialize; {$IFNDEF FPC}virtual;{$ENDIF}\n    class function GetInstance: THorseRtti;\n  end;\n\nimplementation\n\nconstructor THorseRtti.Create;\nbegin\n  if FHorseRtti <> nil then\n    raise Exception.Create('The Horse Rtti instance has already been created');\n  FContext := TRttiContext.Create;\n  FHorseRtti := Self;\nend;\n\nclass function THorseRtti.GetDefaultHorseRtti: THorseRtti;\nbegin\n  if FHorseRtti = nil then\n    FHorseRtti := THorseRtti.Create;\n  Result := FHorseRtti;\nend;\n\nclass function THorseRtti.GetInstance: THorseRtti;\nbegin\n  Result := GetDefaultHorseRtti;\nend;\n\nfunction THorseRtti.GetType(const AClass: TClass): TRttiType;\nbegin\n  Result := FContext.GetType(AClass);\nend;\n\nclass destructor THorseRtti.UnInitialize;\nbegin\n  if FHorseRtti <> nil then\n    FreeAndNil(FHorseRtti);\nend;\n\nend.", "output": "using System;\nusing System.Reflection;\n\nnamespace Horse.Rtti\n{\n    public class HorseRtti\n    {\n        private static HorseRtti _instance;\n\n        \n        private HorseRtti()\n        {\n            if (_instance != null)\n                throw new Exception(\"The Horse Rtti instance has already been created\");\n            _instance = this;\n        }\n        \n        \n        public Type GetType(Type aClass)\n        {\n            \n            return aClass;\n        }\n        \n        \n        public static HorseRtti GetInstance()\n        {\n            if (_instance == null)\n                _instance = new HorseRtti();\n            return _instance;\n        }\n        \n        \n        public static void UnInitialize()\n        {\n            _instance = null;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit WaitingFormU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls;\n\ntype\n  TWaitingForm = class(TForm)\n    lblMessage: TLabel;\n    Shape1: TShape;\n    lblRunningRequests: TLabel;\n    TimerWaiting: TTimer;\n    procedure TimerWaitingTimer(Sender: TObject);\n    procedure FormDestroy(Sender: TObject);\n  private\n    FWaitingCount: Integer;\n    fPoints: Integer;\n    procedure SetWaitingCount(const Value: Integer);\n    { Private declarations }\n  public\n    property WaitingCount: Integer read FWaitingCount write SetWaitingCount;\n    procedure IncreaseWaitingCount;\n    procedure DecreaseWaitingCount;\n\n  end;\n\nimplementation\n\nuses\n  System.Math, System.StrUtils;\n\n{$R *.dfm}\n{ TWaitingForm }\n\nprocedure TWaitingForm.DecreaseWaitingCount;\nbegin\n  WaitingCount := WaitingCount - 1;\nend;\n\nprocedure TWaitingForm.FormDestroy(Sender: TObject);\nbegin\n  Screen.Cursor := crDefault;\nend;\n\nprocedure TWaitingForm.IncreaseWaitingCount;\nbegin\n  WaitingCount := WaitingCount + 1;\nend;\n\nprocedure TWaitingForm.SetWaitingCount(const Value: Integer);\nbegin\n  FWaitingCount := Max(0, Value);\n  if FWaitingCount = 0 then\n  begin\n    TimerWaiting.Enabled := False;\n    Hide;\n    Screen.Cursor := crDefault;\n  end\n  else\n  begin\n    if not Visible then\n    begin\n      Screen.Cursor := crHourGlass;\n      fPoints := 0;\n      TimerWaiting.Enabled := True;\n      Show;\n    end;\n    lblRunningRequests.Caption := FWaitingCount.ToString + ' running request' + ifthen(FWaitingCount > 1, 's');\n    lblRunningRequests.Update;\n  end;\nend;\n\nprocedure TWaitingForm.TimerWaitingTimer(Sender: TObject);\nbegin\n  if fPoints = 3 then\n  begin\n    fPoints := 0;\n  end\n  else\n  begin\n    Inc(fPoints);\n  end;\n  lblMessage.Caption := 'Please wait' + StringOfChar('.', fPoints);\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace YourNamespace\n{\n    public class WaitingForm : Form\n    {\n        private Label lblMessage;\n        private Label lblRunningRequests;\n        private Timer TimerWaiting;\n        private Panel Shape1;\n        private int FWaitingCount;\n        private int fPoints;\n\n        public int WaitingCount\n        {\n            get { return FWaitingCount; }\n            set { SetWaitingCount(value); }\n        }\n\n        public WaitingForm()\n        {\n            lblMessage = new Label();\n            lblRunningRequests = new Label();\n            TimerWaiting = new Timer();\n            Shape1 = new Panel();\n            TimerWaiting.Interval = 1000;\n            TimerWaiting.Tick += TimerWaiting_Tick;\n            this.FormClosed += WaitingForm_FormClosed;\n            lblMessage.AutoSize = true;\n            lblMessage.Location = new Point(10, 10);\n            lblRunningRequests.AutoSize = true;\n            lblRunningRequests.Location = new Point(10, 40);\n            Shape1.Size = new Size(100, 10);\n            Shape1.Location = new Point(10, 70);\n            Shape1.BackColor = Color.Black;\n            this.Controls.Add(lblMessage);\n            this.Controls.Add(lblRunningRequests);\n            this.Controls.Add(Shape1);\n        }\n\n        private void SetWaitingCount(int value)\n        {\n            FWaitingCount = Math.Max(0, value);\n            if (FWaitingCount == 0)\n            {\n                TimerWaiting.Enabled = false;\n                this.Hide();\n                Cursor = Cursors.Default;\n            }\n            else\n            {\n                if (!this.Visible)\n                {\n                    Cursor = Cursors.WaitCursor;\n                    fPoints = 0;\n                    TimerWaiting.Enabled = true;\n                    this.Show();\n                }\n                lblRunningRequests.Text = FWaitingCount.ToString() + \" running request\" + (FWaitingCount > 1 ? \"s\" : \"\");\n                lblRunningRequests.Refresh();\n            }\n        }\n\n        public void IncreaseWaitingCount()\n        {\n            WaitingCount = WaitingCount + 1;\n        }\n\n        public void DecreaseWaitingCount()\n        {\n            WaitingCount = WaitingCount - 1;\n        }\n\n        private void TimerWaiting_Tick(object sender, EventArgs e)\n        {\n            if (fPoints == 3)\n                fPoints = 0;\n            else\n                fPoints++;\n            lblMessage.Text = \"Please wait\" + new string('.', fPoints);\n        }\n\n        private void WaitingForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            Cursor = Cursors.Default;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.Proxy;\n\ninterface\n\nuses Classes, System.SysUtils, LoggerPro;\n\ntype\n  ILogAppenderProxy=interface\n    ['{34816F83-9FBF-461E-8913-F10F9460D712}']\n    function GetInternalAppender: ILogAppender;\n    property InternalAppender: ILogAppender read GetInternalAppender;\n  end;\n\n  TLoggerProFilter = class abstract\n    class function Build(Appender: ILogAppender; Filter: TFunc<TLogItem, boolean>): ILogAppender;\n  end;\n\n  TLogWriterPredicate = reference to function (const aType: TLogType; const aMessage, aTag: string): Boolean;\n\n  TLogWriterDecorator = class(TInterfacedObject, ILogWriter)\n  private\n    fDecoratedLogWriter: ILogWriter;\n    fFilter: TLogWriterPredicate;\n  protected\n    { ILogWriter }\n    procedure Debug(const aMessage: string; const aTag: string); overload;\n    procedure Debug(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Info(const aMessage: string; const aTag: string); overload;\n    procedure Info(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Warn(const aMessage: string; const aTag: string); overload;\n    procedure Warn(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Error(const aMessage: string; const aTag: string); overload;\n    procedure Error(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Fatal(const aMessage: string; const aTag: string); overload;\n    procedure Fatal(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Log(const aType: TLogType; const aMessage: string; const aTag: string); overload;\n    procedure Log(const aType: TLogType; const aMessage: string; const aParams: array of const; const aTag: string); overload;\n\n    { ICustomLogWriter}\n    function GetAppendersClassNames: TArray<string>;\n    function GetAppenders(const aIndex: Integer): ILogAppender;\n    property Appenders[const aIndex: Integer]: ILogAppender read GetAppenders;\n    procedure AddAppender(const aAppender: ILogAppender);\n    procedure DelAppender(const aAppender: ILogAppender);\n    function AppendersCount(): Integer;\n\n\n    ///\n    constructor Create(LogWriter: ILogWriter; Filter: TLogWriterPredicate);\n  public\n    class function Build(LogWriter: ILogWriter; Filter: TLogWriterPredicate): ILogWriter;\n  end;\n\n\nimplementation\n\ntype\n  TLoggerProAppenderFilterImpl = class(TLoggerProAppenderBase, ILogAppender, ILogAppenderProxy)\n  private\n    FAppender: ILogAppender;\n    FFilter: TFunc<TLogItem, boolean>;\n    function GetInternalAppender: ILogAppender;\n  public\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    property InternalAppender: ILogAppender read GetInternalAppender;\n    constructor Create(Appender: ILogAppender; Filter: TFunc<TLogItem, boolean>);  reintroduce;\n  end;\n\n{ TLoggerProAppenderFilterImpl }\n\nconstructor TLoggerProAppenderFilterImpl.Create(Appender: ILogAppender;\n  Filter: TFunc<TLogItem, boolean>);\nbegin\n  inherited Create;\n  self.FFilter := Filter;\n  self.FAppender := Appender;\nend;\n\nfunction TLoggerProAppenderFilterImpl.GetInternalAppender: ILogAppender;\nbegin\n  result := FAppender;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.Setup;\nbegin\n  FAppender.Setup;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.TearDown;\nbegin\n  FAppender.TearDown;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.WriteLog(const aLogItem: TLogItem);\nbegin\n  if FFilter(aLogItem) then\n    FAppender.WriteLog(aLogItem);\nend;\n\n\nclass function TLoggerProFilter.Build(Appender: ILogAppender;\n  Filter: TFunc<TLogItem, boolean>): ILogAppender;\nbegin\n  Result := TLoggerProAppenderFilterImpl.Create(Appender, Filter);\nend;\n\n\n{ TLogWriterDecorator }\n\nclass function TLogWriterDecorator.Build(LogWriter: ILogWriter;\n  Filter: TLogWriterPredicate): ILogWriter;\nbegin\n  Result := TLogWriterDecorator.Create(LogWriter, Filter);\nend;\n\nconstructor TLogWriterDecorator.Create(LogWriter: ILogWriter; Filter: TLogWriterPredicate);\nbegin\n  inherited Create;\n  fDecoratedLogWriter := LogWriter;\n  fFilter := Filter;\nend;\n\nprocedure TLogWriterDecorator.AddAppender(const aAppender: ILogAppender);\nbegin\n  fDecoratedLogWriter.AddAppender(aAppender);\nend;\n\nfunction TLogWriterDecorator.AppendersCount: Integer;\nbegin\n  Result := fDecoratedLogWriter.AppendersCount;\nend;\n\nfunction TLogWriterDecorator.GetAppenders(const aIndex: Integer): ILogAppender;\nbegin\n  Result := fDecoratedLogWriter.GetAppenders(aIndex);\nend;\n\nfunction TLogWriterDecorator.GetAppendersClassNames: TArray<string>;\nbegin\n  Result := fDecoratedLogWriter.GetAppendersClassNames;\nend;\n\n// ILogWriter\n\nprocedure TLogWriterDecorator.Debug(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Debug, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Debug(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Debug, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.DelAppender(const aAppender: ILogAppender);\nbegin\n  fDecoratedLogWriter.DelAppender(aAppender);\nend;\n\nprocedure TLogWriterDecorator.Error(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Error, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Error(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Error, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Fatal(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Fatal, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Fatal(const aMessage: string;\n  const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Fatal, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Info(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Info, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Info(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Info, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Log(const aType: TLogType; const aMessage, aTag: string);\nbegin\n  if fFilter(aType, aMessage, aTag) then\n  begin\n    fDecoratedLogWriter.Log(aType, aMessage, aTag);\n  end;\nend;\n\nprocedure TLogWriterDecorator.Log(const aType: TLogType; const aMessage: string; const aParams: array of const; const aTag: string);\nbegin\n  Log(aType, Format(aMessage, aParams), aTag);\nend;\n\nprocedure TLogWriterDecorator.Warn(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Warning, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Warn(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Warning, aMessage, aParams, aTag);\nend;\n\n\nend.", "output": "using System;\nusing LoggerPro; \n\nnamespace LoggerPro.Proxy\n{\n    \n    public interface ILogAppenderProxy\n    {\n        ILogAppender InternalAppender { get; }\n    }\n\n    \n    public static class LoggerProFilter\n    {\n        \n        public static ILogAppender Build(ILogAppender appender, Func<LogItem, bool> filter)\n        {\n            return new LoggerProAppenderFilterImpl(appender, filter);\n        }\n    }\n\n    \n    public delegate bool LogWriterPredicate(LogType logType, string message, string tag);\n\n    \n    public class LogWriterDecorator : ILogWriter\n    {\n        private readonly ILogWriter _decoratedLogWriter;\n        private readonly LogWriterPredicate _filter;\n\n        \n        protected LogWriterDecorator(ILogWriter logWriter, LogWriterPredicate filter)\n        {\n            _decoratedLogWriter = logWriter;\n            _filter = filter;\n        }\n\n        \n        public static ILogWriter Build(ILogWriter logWriter, LogWriterPredicate filter)\n        {\n            return new LogWriterDecorator(logWriter, filter);\n        }\n\n        \n        public void Debug(string message, string tag)\n        {\n            Log(LogType.Debug, message, tag);\n        }\n\n        public void Debug(string message, object[] args, string tag)\n        {\n            Log(LogType.Debug, string.Format(message, args), tag);\n        }\n\n        public void Info(string message, string tag)\n        {\n            Log(LogType.Info, message, tag);\n        }\n\n        public void Info(string message, object[] args, string tag)\n        {\n            Log(LogType.Info, string.Format(message, args), tag);\n        }\n\n        public void Warn(string message, string tag)\n        {\n            Log(LogType.Warning, message, tag);\n        }\n\n        public void Warn(string message, object[] args, string tag)\n        {\n            Log(LogType.Warning, string.Format(message, args), tag);\n        }\n\n        public void Error(string message, string tag)\n        {\n            Log(LogType.Error, message, tag);\n        }\n\n        public void Error(string message, object[] args, string tag)\n        {\n            Log(LogType.Error, string.Format(message, args), tag);\n        }\n\n        public void Fatal(string message, string tag)\n        {\n            Log(LogType.Fatal, message, tag);\n        }\n\n        public void Fatal(string message, object[] args, string tag)\n        {\n            Log(LogType.Fatal, string.Format(message, args), tag);\n        }\n\n        public void Log(LogType type, string message, string tag)\n        {\n            if (_filter(type, message, tag))\n            {\n                _decoratedLogWriter.Log(type, message, tag);\n            }\n        }\n\n        public void Log(LogType type, string message, object[] args, string tag)\n        {\n            Log(type, string.Format(message, args), tag);\n        }\n\n        \n        public string[] GetAppendersClassNames() => _decoratedLogWriter.GetAppendersClassNames();\n\n        public ILogAppender GetAppender(int index) => _decoratedLogWriter.GetAppender(index);\n\n        public void AddAppender(ILogAppender appender) => _decoratedLogWriter.AddAppender(appender);\n\n        public void DelAppender(ILogAppender appender) => _decoratedLogWriter.DelAppender(appender);\n\n        public int AppendersCount() => _decoratedLogWriter.AppendersCount();\n    }\n\n    \n    internal class LoggerProAppenderFilterImpl : LoggerProAppenderBase, ILogAppender, ILogAppenderProxy\n    {\n        private readonly ILogAppender _internalAppender;\n        private readonly Func<LogItem, bool> _filter;\n\n        public LoggerProAppenderFilterImpl(ILogAppender appender, Func<LogItem, bool> filter)\n        {\n            _filter = filter;\n            _internalAppender = appender;\n        }\n\n        public ILogAppender InternalAppender => _internalAppender;\n\n        public override void Setup()\n        {\n            _internalAppender.Setup();\n        }\n\n        public override void TearDown()\n        {\n            _internalAppender.TearDown();\n        }\n\n        public override void WriteLog(LogItem logItem)\n        {\n            if (_filter(logItem))\n            {\n                _internalAppender.WriteLog(logItem);\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerPrivateU;\n\ninterface\n\nuses\n  MVCFramework;\n\ntype\n\n  [MVCPath('/privatecustom')]\n  TTestPrivateServerControllerCustomAuth = class(TMVCController)\n  public\n    [MVCPath('/role1')]\n    procedure OnlyRole1;\n    [MVCPath('/role2')]\n    procedure OnlyRole2;\n  end;\n\nimplementation\n\n\n{ TTestPrivateServerControllerCustomAuth }\n\nprocedure TTestPrivateServerControllerCustomAuth.OnlyRole1;\nbegin\n  Render('Here''s Action1 from the private controller');\nend;\n\nprocedure TTestPrivateServerControllerCustomAuth.OnlyRole2;\nbegin\n  Render('Here''s Action2 from the private controller');\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\n\nnamespace TestServer.Controllers\n{\n    [Route(\"privatecustom\")]\n    [ApiController]\n    public class TestPrivateServerControllerCustomAuth : ControllerBase\n    {\n        [HttpGet(\"role1\")]\n        public IActionResult OnlyRole1()\n        {\n            return Ok(\"Here's Action1 from the private controller\");\n        }\n\n        [HttpGet(\"role2\")]\n        public IActionResult OnlyRole2()\n        {\n            return Ok(\"Here's Action2 from the private controller\");\n        }\n    }\n}"}
{"input": "(*****************************************************************************\nThe MIT License (MIT)\n\nCopyright (c) 2015-2016 Andreas Hausladen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*****************************************************************************)\n\n{$A8,B-,C+,E-,F-,G+,H+,I+,J-,K-,M-,N-,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Z1}\n{$WARN WIDECHAR_REDUCED OFF} // All sets only use ASCII chars (<=#127) and the compiler generates the >=#128 check itself\n{$STRINGCHECKS OFF} // It only slows down Delphi strings, doesn't help C++Builder migration and is finally gone in XE+\n{$WARN SYMBOL_DEPRECATED OFF} // for StrLen/StrLComp\n{$POINTERMATH ON}\n\nunit JsonDataObjects;\n\n{$IFDEF VER200}\n  // Delphi 2009's ErrorInsight parser uses the CompilerVersion's memory address instead of 20.0, failing all the\n  // IF CompilerVersion compiler directives\n  {$DEFINE CPUX86}\n{$ELSE}\n  {$IF CompilerVersion >= 24.0} // XE3 or newer\n    {$LEGACYIFEND ON}\n    {$IF CompilerVersion >= 35.0} // 11.0 or newer\n      {$DEFINE STREAM_USES_NATIVEINT}\n    {$IFEND}\n  {$IFEND}\n  {$IF CompilerVersion >= 23.0}\n    {$DEFINE HAS_UNIT_SCOPE}\n    {$DEFINE HAS_RETURN_ADDRESS}\n  {$IFEND}\n  {$IF CompilerVersion <= 22.0} // XE or older\n    {$DEFINE CPUX86}\n  {$IFEND}\n{$ENDIF VER200}\n\n{$IFDEF NEXTGEN}\n  {$IF CompilerVersion >= 31.0} // 10.1 Berlin or newer\n    {$DEFINE SUPPORTS_UTF8STRING} // Delphi 10.1 Berlin supports UTF8String for mobile compilers\n  {$IFEND}\n{$ELSE}\n  {$DEFINE SUPPORTS_UTF8STRING}\n{$ENDIF}\n\n{$IFDEF CPUX64}\n  {$IFNDEF LINUX64} // Linux 64 compiler doesn't support ASM for x64 code => LLVM\n    {$DEFINE ASMSUPPORT}\n  {$ENDIF ~LINUX64}\n{$ENDIF CPUX64}\n{$IFDEF CPUX86}\n  {$DEFINE ASMSUPPORT}\n{$ENDIF CPUX86}\n{$IFDEF EXTERNALLINKER} // implicates LLVM\n  {$UNDEF ASMSUPPORT}\n{$ENDIF EXTERNALLINKER}\n\n// Sanity checks all array index accesses and raise an EListError exception.\n{$DEFINE CHECK_ARRAY_INDEX}\n\n// JSON allows the slash to be escaped. This is only necessary if you plan to put the JSON string\n// into a <script>-Tag because then \"</\" can't be used and must be escaped to \"<\\/\". This switch\n// enables the special handling for \"</\" but makes the parser slightly slower.\n{.$DEFINE ESCAPE_SLASH_AFTER_LESSTHAN}\n\n// When parsing a JSON string the pair names are interned to reduce the memory foot print. This\n// slightly slows down the parser but saves a lot of memory if the JSON string contains repeating\n// pair names. The interning uses a hashset to store the strings.\n{$DEFINE USE_STRINGINTERN_FOR_NAMES}\n\n// Use an optimized NewInstance implementation. It skips the initialization of the interface table.\n// and seals the TJsonArray and TJsonObject classes because it isn't safe to derive from them.\n{$DEFINE USE_FAST_NEWINSTANCE}\n\n//{$IF CompilerVersion < 28.0} // XE6 or older\n  // The XE7 compiler is broken. It doesn't collapse duplicate string literals anymore. (RSP-10015)\n  // But if the string literals are used in loops this optimization still helps.\n\n  // Optimizes the following pattern:\n  //   O['Name'][MyPropStr]\n  //   O['Name']['MyProp'].\n  // where the second O['Name'] is handled very fast by caching the pointer to the 'Name' string literal.\n  {$DEFINE USE_LAST_NAME_STRING_LITERAL_CACHE}\n//{$IFEND}\n\n// When parsing the JSON string, the UStrAsg calls are skipped for internal strings what eliminates\n// the CPU locks for those string assignments.\n{$DEFINE USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n\n{$IFDEF AUTOREFCOUNT}\n  // Delphi's ARC is slow (RSP-9712). This switch enables a faster ARC handling and even skips memory\n  // barrier were possible.\n  {$DEFINE USE_FAST_AUTOREFCOUNT}\n{$ENDIF AUTOREFCOUNT}\n\n{$IFDEF MSWINDOWS}\n  // When adding JSON object properties with string literals, the string literals are stored directly\n  // in the \"Name\" field instead of using UStrAsg that creates a new heap string. This improves the\n  // performance as no string is copied and it slighly reduces the memory usage.\n  // The string literals are only used if they are in the main instance or the DLL that contains the\n  // JsonDataObjects unit. Other string literals are copied using UStrAsg because unloading the DLL\n  // that holds them would cause access violations.\n  // This has no effect when parsing JSON strings because then there are no string literals.\n  {$DEFINE USE_NAME_STRING_LITERAL}\n\n  // Reading a large file >64 MB from a network drive in Windows 2003 Server or older can lead to\n  // an INSUFFICIENT RESOURCES error. By enabling this switch, large files are read in 20 MB blocks.\n  {$DEFINE WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\n\n  // If defined, the TzSpecificLocalTimeToSystemTime is imported with GetProcAddress and if it is\n  // not available (Windows 2000) an alternative implementation is used.\n  {$DEFINE SUPPORT_WINDOWS2000}\n\n{$ENDIF MSWINDOWS}\n\ninterface\n\nuses\n  {$IFDEF HAS_UNIT_SCOPE}\n  System.SysUtils, System.Classes;\n  {$ELSE}\n  SysUtils, Classes;\n  {$ENDIF HAS_UNIT_SCOPE}\n\n{$HPPEMIT '#pragma link \"Jsondataobjects\"'}\n\ntype\n  TJsonBaseObject = class;\n  TJsonObject = class;\n  TJsonArray = class;\n\n  {$IFDEF NEXTGEN}\n  // Mobile compilers have PAnsiChar but it is hidden and then published under a new name. This alias\n  // allows us to remove some IFDEFs.\n  PAnsiChar = MarshaledAString;\n  {$ENDIF NEXTGEN}\n\n  EJsonException = class(Exception);\n  EJsonCastException = class(EJsonException);\n  EJsonPathException = class(EJsonException);\n\n  EJsonParserException = class(EJsonException)\n  private\n    FColumn: NativeInt;\n    FPosition: NativeInt;\n    FLineNum: NativeInt;\n  public\n    constructor CreateResFmt(ResStringRec: PResStringRec; const Args: array of const; ALineNum, AColumn, APosition: NativeInt);\n    constructor CreateRes(ResStringRec: PResStringRec; ALineNum, AColumn, APosition: NativeInt);\n\n    property LineNum: NativeInt read FLineNum;   // base 1\n    property Column: NativeInt read FColumn;     // base 1\n    property Position: NativeInt read FPosition; // base 0  Utf8Char/WideChar index\n  end;\n\n  TJsonSerializationConfig = record\n  public\n    // LineBreak specifies what characters are used for line breaks in \"Compact=False\" mode.\n    // Default: #10\n    LineBreak: string;\n    // IndentChar specifies what characters are used to indent lines in \"Compact=False\" mode.\n    // Default: #9\n    IndentChar: string;\n    // If UseUtcTime is True, all TDateTime values will written in UTC timezone converted from the\n    // local timezone in the JSON string. Otherwise the timezone offset to the local timezone will\n    // be included.\n    // Default: True\n    UseUtcTime: Boolean;\n    // If EscapeAllNonASCIIChars is True, all characters >=#128 will be escaped when generating\n    // the JSON string.\n    // Default: False\n    EscapeAllNonASCIIChars: Boolean;\n\n    procedure InitDefaults;\n    class function Default: TJsonSerializationConfig; static;\n  public\n    // If NullConvertsToValueTypes is True and an object is nil/null, a convertion to String, Int,\n    // Long, Float, DateTime, Boolean will return ''/0/False\n    // Default: False\n    NullConvertsToValueTypes: Boolean; // Isn't use for serialization. Should default to True and be deprecated.\n  end;\n\n  TJsonReaderProgressProc = procedure(Data: Pointer; Percentage: Integer; Position, Size: NativeInt);\n\n  PJsonReaderProgressRec = ^TJsonReaderProgressRec;\n  TJsonReaderProgressRec = record\n    Data: Pointer;        // used for the first Progress() parameter\n    Threshold: NativeInt; // 0: Call only if percentage changed; greater than 0: call after n processed bytes\n    Progress: TJsonReaderProgressProc;\n\n    function Init(AProgress: TJsonReaderProgressProc; AData: Pointer = nil; AThreshold: NativeInt = 0): PJsonReaderProgressRec;\n  end;\n\n  // TJsonOutputWriter is used to write the JSON data to a string, stream or TStrings in a compact\n  // or human readable format.\n  PJsonOutputWriter = ^TJsonOutputWriter;\n  TJsonOutputWriter = record\n  private type\n    TLastType = (ltInitial, ltIndent, ltUnindent, ltIntro, ltValue, ltSeparator);\n\n    PJsonStringArray = ^TJsonStringArray;\n    TJsonStringArray = array[0..MaxInt div SizeOf(string) - 1] of string;\n\n    PJsonStringBuilder = ^TJsonStringBuilder;\n    TJsonStringBuilder = record\n    private\n      FData: PChar;\n      FCapacity: Integer;\n      FLen: Integer;\n      procedure Grow(MinLen: Integer);\n    public\n      procedure Init;\n      procedure Done;\n      procedure DoneConvertToString(var S: string);\n      function FlushToBytes(var Bytes: PByte; var Size: NativeInt; Encoding: TEncoding): NativeInt;\n      procedure FlushToMemoryStream(Stream: TMemoryStream; Encoding: TEncoding);\n      procedure FlushToStringBuffer(var Buffer: TJsonStringBuilder);\n      procedure FlushToString(var S: string);\n\n      function Append(const S: string): PJsonStringBuilder; overload;\n      procedure Append(P: PChar; Len: Integer); overload;\n      function Append2(const S1: string; S2: PChar; S2Len: Integer): PJsonStringBuilder; overload;\n      procedure Append2(Ch1: Char; Ch2: Char); overload;\n      procedure Append3(Ch1: Char; const S2, S3: string); overload;\n      procedure Append3(Ch1: Char; const S2: string; Ch3: Char); overload; inline;\n      procedure Append3(Ch1: Char; const P2: PChar; P2Len: Integer; Ch3: Char); overload;\n\n      property Len: Integer read FLen;\n      property Data: PChar read FData;\n    end;\n  private\n    FLastType: TLastType;\n    FCompact: Boolean;\n    FStringBuffer: TJsonStringBuilder;\n    FLines: TStrings;\n    FLastLine: TJsonStringBuilder;\n    FConfig: TJsonSerializationConfig;\n\n    FStreamEncodingBuffer: PByte;\n    FStreamEncodingBufferLen: NativeInt;\n    FStream: TStream;                // used when writing to a stream\n    FEncoding: TEncoding;            // used when writing to a stream\n\n    FIndents: PJsonStringArray;      // buffer for line indention strings\n    FIndentsLen: Integer;\n    FIndent: Integer;                // current indention level\n\n    procedure StreamFlushPossible; inline; // checks if StreamFlush must be called\n    procedure StreamFlush;                 // writes the buffer to the stream\n    procedure ExpandIndents;\n    procedure AppendLine(AppendOn: TLastType; const S: string); overload; inline;\n    procedure AppendLine(AppendOn: TLastType; P: PChar; Len: Integer); overload; inline;\n    procedure FlushLastLine;\n  private // unit private\n    procedure Init(ACompact: Boolean; AStream: TStream; AEncoding: TEncoding; ALines: TStrings;\n      const Config: TJsonSerializationConfig);\n    function Done: string;\n    procedure StreamDone;\n    procedure LinesDone;\n\n    procedure Indent(const S: string);\n    procedure Unindent(const S: string);\n    procedure AppendIntro(P: PChar; Len: Integer);\n    procedure AppendValue(const S: string); overload;\n    procedure AppendValue(P: PChar; Len: Integer); overload;\n    procedure AppendStrValue(P: PChar; Len: Integer);\n    procedure AppendSeparator(const S: string);\n    procedure FreeIndents;\n  end;\n\n  TJsonDataType = (\n    jdtNone, jdtString, jdtInt, jdtLong, jdtULong, jdtFloat, jdtDateTime, jdtUtcDateTime, jdtBool, jdtArray, jdtObject\n  );\n\n  // TJsonDataValue holds the actual value\n  PJsonDataValue = ^TJsonDataValue;\n  TJsonDataValue = packed record\n  private type\n    TJsonDataValueRec = record\n      case TJsonDataType of\n        jdtNone: (P: PChar);     // helps when debugging\n        jdtString: (S: Pointer); // We manage the string ourself. Delphi doesn't allow \"string\" in a\n                                 // variant record and if we have no string, we don't need to clean\n                                 // it up, anyway.\n        jdtInt: (I: Integer);\n        jdtLong: (L: Int64);\n        jdtULong: (U: UInt64);\n        jdtFloat: (F: Double);\n        jdtDateTime, jdtUtcDateTime: (D: TDateTime);\n        jdtBool: (B: Boolean);\n        jdtArray: (A: Pointer);  // owned by TJsonDataValue\n        jdtObject: (O: Pointer); // owned by TJsonDataValue\n    end;\n  private\n    FValue: TJsonDataValueRec;\n    FTyp: TJsonDataType;\n    function GetValue: string;\n    function GetIntValue: Integer;\n    function GetLongValue: Int64;\n    function GetULongValue: UInt64;\n    function GetFloatValue: Double;\n    function GetDateTimeValue: TDateTime;\n    function GetUtcDateTimeValue: TDateTime;\n    function GetBoolValue: Boolean;\n    function GetArrayValue: TJsonArray;\n    function GetObjectValue: TJsonObject;\n    function GetVariantValue: Variant;\n\n    procedure SetValue(const AValue: string);\n    procedure SetIntValue(const AValue: Integer);\n    procedure SetLongValue(const AValue: Int64);\n    procedure SetULongValue(const AValue: UInt64);\n    procedure SetFloatValue(const AValue: Double);\n    procedure SetDateTimeValue(const AValue: TDateTime);\n    procedure SetUtcDateTimeValue(const AValue: TDateTime);\n    procedure SetBoolValue(const AValue: Boolean);\n    procedure SetArrayValue(const AValue: TJsonArray);\n    procedure SetObjectValue(const AValue: TJsonObject);\n    procedure SetVariantValue(const AValue: Variant);\n\n    procedure InternToJSON(var Writer: TJsonOutputWriter);\n    procedure InternSetValue(const AValue: string); // skips the call to Clear()\n    procedure InternSetValueTransfer(var AValue: string); // skips the call to Clear() and transfers the string without going through UStrAsg+UStrClr\n    procedure InternSetArrayValue(const AValue: TJsonArray);\n    procedure InternSetObjectValue(const AValue: TJsonObject);\n    procedure Clear;\n    procedure TypeCastError(ExpectedType: TJsonDataType);\n  public\n    function IsNull: Boolean;\n\n    property Typ: TJsonDataType read FTyp;\n    property Value: string read GetValue write SetValue;\n    property IntValue: Integer read GetIntValue write SetIntValue;\n    property LongValue: Int64 read GetLongValue write SetLongValue;\n    property ULongValue: UInt64 read GetULongValue write SetULongValue;\n    property FloatValue: Double read GetFloatValue write SetFloatValue;\n    property DateTimeValue: TDateTime read GetDateTimeValue write SetDateTimeValue;\n    property UtcDateTimeValue: TDateTime read GetUtcDateTimeValue write SetUtcDateTimeValue;\n    property BoolValue: Boolean read GetBoolValue write SetBoolValue;\n    property ArrayValue: TJsonArray read GetArrayValue write SetArrayValue;\n    property ObjectValue: TJsonObject read GetObjectValue write SetObjectValue;\n    property VariantValue: Variant read GetVariantValue write SetVariantValue;\n  end;\n\n  // TJsonDataValueHelper is used to implement the \"easy access\" functionality. It is\n  // slightly slower than using the direct indexed properties.\n  TJsonDataValueHelper = record\n  private\n    function GetValue: string; inline;\n    function GetIntValue: Integer; inline;\n    function GetLongValue: Int64; inline;\n    function GetULongValue: UInt64; //inline;  no implicit operator due to conflict with Int64\n    function GetFloatValue: Double; inline;\n    function GetDateTimeValue: TDateTime; inline;\n    function GetUtcDateTimeValue: TDateTime;\n    function GetBoolValue: Boolean; inline;\n    function GetArrayValue: TJsonArray; inline;\n    function GetObjectValue: TJsonObject; inline;\n    function GetVariantValue: Variant; inline;\n\n    procedure SetValue(const Value: string);\n    procedure SetIntValue(const Value: Integer);\n    procedure SetLongValue(const Value: Int64);\n    procedure SetULongValue(const Value: UInt64);\n    procedure SetFloatValue(const Value: Double);\n    procedure SetDateTimeValue(const Value: TDateTime);\n    procedure SetUtcDateTimeValue(const Value: TDateTime);\n    procedure SetBoolValue(const Value: Boolean);\n    procedure SetArrayValue(const Value: TJsonArray);\n    procedure SetObjectValue(const Value: TJsonObject);\n    procedure SetVariantValue(const Value: Variant);\n\n    function GetArrayItem(Index: Integer): TJsonDataValueHelper; inline;\n    function GetArrayCount: Integer; inline;\n\n    function GetObjectString(const Name: string): string; inline;\n    function GetObjectInt(const Name: string): Integer; inline;\n    function GetObjectLong(const Name: string): Int64; inline;\n    function GetObjectULong(const Name: string): UInt64; inline;\n    function GetObjectFloat(const Name: string): Double; inline;\n    function GetObjectDateTime(const Name: string): TDateTime; inline;\n    function GetObjectUtcDateTime(const Name: string): TDateTime; inline;\n    function GetObjectBool(const Name: string): Boolean; inline;\n    function GetArray(const Name: string): TJsonArray; inline;\n    {$IFDEF BCB}\n    function GetObj(const Name: string): TJsonDataValueHelper; inline; // work around C++Builder Windows.h::GetObject macro\n    {$ELSE}\n    function GetObject(const Name: string): TJsonDataValueHelper; inline;\n    {$ENDIF BCB}\n    function GetObjectVariant(const Name: string): Variant; inline;\n    procedure SetObjectString(const Name, Value: string); inline;\n    procedure SetObjectInt(const Name: string; const Value: Integer); inline;\n    procedure SetObjectLong(const Name: string; const Value: Int64); inline;\n    procedure SetObjectULong(const Name: string; const Value: UInt64); inline;\n    procedure SetObjectFloat(const Name: string; const Value: Double); inline;\n    procedure SetObjectDateTime(const Name: string; const Value: TDateTime); inline;\n    procedure SetObjectUtcDateTime(const Name: string; const Value: TDateTime); inline;\n    procedure SetObjectBool(const Name: string; const Value: Boolean); inline;\n    procedure SetArray(const Name: string; const Value: TJsonArray); inline;\n    procedure SetObject(const Name: string; const Value: TJsonDataValueHelper); inline;\n    procedure SetObjectVariant(const Name: string; const Value: Variant); inline;\n\n    function GetObjectPath(const Name: string): TJsonDataValueHelper; inline;\n    procedure SetObjectPath(const Name: string; const Value: TJsonDataValueHelper); inline;\n\n    function GetTyp: TJsonDataType;\n    procedure ResolveName;\n    class procedure SetInternValue(Item: PJsonDataValue; const Value: TJsonDataValueHelper); static;\n  public\n    class operator Implicit(const Value: string): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): string; overload;\n    class operator Implicit(const Value: Integer): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Integer; overload;\n    class operator Implicit(const Value: Int64): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Int64; overload;\n    //class operator Implicit(const Value: UInt64): TJsonDataValueHelper; overload;  conflicts with Int64 operator\n    //class operator Implicit(const Value: TJsonDataValueHelper): UInt64; overload;  conflicts with Int64 operator\n    class operator Implicit(const Value: Double): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Double; overload;\n    class operator Implicit(const Value: Extended): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Extended; overload;\n    class operator Implicit(const Value: TDateTime): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TDateTime; overload;\n    class operator Implicit(const Value: Boolean): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Boolean; overload;\n    class operator Implicit(const Value: TJsonArray): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TJsonArray; overload;\n    class operator Implicit(const Value: TJsonObject): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TJsonObject; overload;\n    class operator Implicit(const Value: Pointer): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Variant; overload;\n    class operator Implicit(const Value: Variant): TJsonDataValueHelper; overload;\n\n    function IsNull: Boolean;\n    \n    property Typ: TJsonDataType read GetTyp;\n    property Value: string read GetValue write SetValue;\n    property IntValue: Integer read GetIntValue write SetIntValue;\n    property LongValue: Int64 read GetLongValue write SetLongValue;\n    property ULongValue: UInt64 read GetULongValue write SetULongValue;\n    property FloatValue: Double read GetFloatValue write SetFloatValue;\n    property DateTimeValue: TDateTime read GetDateTimeValue write SetDateTimeValue;\n    property UtcDateTimeValue: TDateTime read GetUtcDateTimeValue write SetUtcDateTimeValue;\n    property BoolValue: Boolean read GetBoolValue write SetBoolValue;\n    property ArrayValue: TJsonArray read GetArrayValue write SetArrayValue;\n    property ObjectValue: TJsonObject read GetObjectValue write SetObjectValue;\n    property VariantValue: Variant read GetVariantValue write SetVariantValue;\n\n    // Access to array item count\n    property Count: Integer read GetArrayCount;\n    // Access to array items\n    property Items[Index: Integer]: TJsonDataValueHelper read GetArrayItem;\n\n    property S[const Name: string]: string read GetObjectString write SetObjectString;        // returns '' if property doesn't exist, auto type-cast except for array/object\n    property I[const Name: string]: Integer read GetObjectInt write SetObjectInt;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property L[const Name: string]: Int64 read GetObjectLong write SetObjectLong;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property U[const Name: string]: UInt64 read GetObjectULong write SetObjectULong;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property F[const Name: string]: Double read GetObjectFloat write SetObjectFloat;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property D[const Name: string]: TDateTime read GetObjectDateTime write SetObjectDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property DUtc[const Name: string]: TDateTime read GetObjectUtcDateTime write SetObjectUtcDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property B[const Name: string]: Boolean read GetObjectBool write SetObjectBool;           // returns false if property doesn't exist, auto type-cast with \"<>'true'\" and \"<>0\" except for array/object\n    // Used to auto create arrays\n    property A[const Name: string]: TJsonArray read GetArray write SetArray;\n    // Used to auto create objects and as default property where no Implicit operator matches\n    property O[const Name: string]: TJsonDataValueHelper read {$IFDEF BCB}GetObj{$ELSE}GetObject{$ENDIF} write SetObject; default;\n    property V[const Name: string]: Variant read GetObjectVariant write SetObjectVariant;\n\n    property Path[const Name: string]: TJsonDataValueHelper read GetObjectPath write SetObjectPath;\n  private\n    FData: record // hide the data from CodeInsight (bug in CodeInsight)\n ", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace JsonDataObjects\n{\n    #region Exceptions\n\n    public class JsonException : Exception\n    {\n        public JsonException(string message) : base(message) { }\n    }\n\n    public class JsonCastException : JsonException\n    {\n        public JsonCastException(string message) : base(message) { }\n    }\n\n    public class JsonPathException : JsonException\n    {\n        public JsonPathException(string message) : base(message) { }\n    }\n\n    public class JsonParserException : JsonException\n    {\n        public int LineNum { get; }\n        public int Column { get; }\n        public int Position { get; }\n\n        public JsonParserException(string message, int lineNum, int column, int position)\n            : base($\"{message} ({lineNum}, {column})\")\n        {\n            LineNum = lineNum;\n            Column = column;\n            Position = position;\n        }\n    }\n\n    #endregion\n\n    #region Configuration\n\n    public struct JsonSerializationConfig\n    {\n        public string LineBreak;\n        public string IndentChar;\n        public bool UseUtcTime;\n        public bool EscapeAllNonASCIIChars;\n        public bool NullConvertsToValueTypes;\n\n        public void InitDefaults()\n        {\n            LineBreak = \"\\n\";\n            IndentChar = \"\\t\";\n            UseUtcTime = true;\n            EscapeAllNonASCIIChars = false;\n            NullConvertsToValueTypes = false;\n        }\n\n        public static JsonSerializationConfig Default\n        {\n            get\n            {\n                var cfg = new JsonSerializationConfig();\n                cfg.InitDefaults();\n                return cfg;\n            }\n        }\n    }\n\n    #endregion\n\n    #region Core JSON Objects\n\n    \n    public abstract class JsonBaseObject\n    {\n        \n        public abstract JObject ToJson();\n\n        \n        public abstract void FromJson(JObject json);\n\n        \n        public JsonBaseObject Clone()\n        {\n            \n            var json = ToJson();\n            var clone = CreateInstance();\n            clone.FromJson(json);\n            return clone;\n        }\n\n        protected abstract JsonBaseObject CreateInstance();\n\n        public static string DateTimeToJSON(DateTime value, bool useUtcTime)\n        {\n            if (useUtcTime)\n                return value.ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\", CultureInfo.InvariantCulture);\n            else\n                return value.ToString(\"yyyy-MM-ddTHH:mm:ss.fff\", CultureInfo.InvariantCulture);\n        }\n\n        public static DateTime JSONToDateTime(string value, bool convertToLocalTime = true)\n        {\n            \n            var dt = DateTime.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal);\n            return convertToLocalTime ? dt.ToLocalTime() : dt;\n        }\n\n        public static string UtcDateTimeToJSON(DateTime utcDateTime)\n        {\n            return utcDateTime.ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\", CultureInfo.InvariantCulture);\n        }\n    }\n\n    \n    public class JsonObject : JsonBaseObject\n    {\n        private readonly Dictionary<string, object> _dict = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);\n\n        public void Add(string key, object value)\n        {\n            _dict[key] = value;\n        }\n\n        public bool ContainsKey(string key) => _dict.ContainsKey(key);\n\n        public object this[string key]\n        {\n            get => _dict.TryGetValue(key, out var value) ? value : null;\n            set => _dict[key] = value;\n        }\n\n        public override JObject ToJson()\n        {\n            var jobj = new JObject();\n            foreach (var kv in _dict)\n            {\n                if (kv.Value is JsonBaseObject jbo)\n                    jobj[kv.Key] = jbo.ToJson();\n                else if (kv.Value is JsonArray jarr)\n                    jobj[kv.Key] = jarr.ToJson()[\"array\"]; \n                else\n                    jobj[kv.Key] = JToken.FromObject(kv.Value);\n            }\n            return jobj;\n        }\n\n        public override void FromJson(JObject json)\n        {\n            _dict.Clear();\n            foreach (var prop in json.Properties())\n            {\n                \n                _dict[prop.Name] = prop.Value;\n            }\n        }\n\n        protected override JsonBaseObject CreateInstance() => new JsonObject();\n\n        public JsonObject CloneObject() => (JsonObject)this.Clone();\n    }\n\n    \n    public class JsonArray : JsonBaseObject\n    {\n        private readonly List<object> _items = new List<object>();\n\n        public void Add(object value)\n        {\n            _items.Add(value);\n        }\n\n        public object this[int index]\n        {\n            get => _items[index];\n            set => _items[index] = value;\n        }\n\n        public int Count => _items.Count;\n\n        public override JObject ToJson()\n        {\n            var jarr = new JArray();\n            foreach (var item in _items)\n            {\n                if (item is JsonBaseObject jbo)\n                    jarr.Add(jbo.ToJson());\n                else\n                    jarr.Add(JToken.FromObject(item));\n            }\n            \n            return new JObject { [\"array\"] = jarr };\n        }\n\n        public override void FromJson(JObject json)\n        {\n            _items.Clear();\n            var jarr = json[\"array\"] as JArray;\n            if (jarr != null)\n            {\n                foreach (var token in jarr)\n                    _items.Add(token);\n            }\n        }\n\n        protected override JsonBaseObject CreateInstance() => new JsonArray();\n\n        public JsonArray CloneArray() => (JsonArray)this.Clone();\n    }\n\n    #endregion\n\n    #region Data Value Helper\n\n    \n    public class JsonDataValueHelper\n    {\n        public JsonDataType Type { get; set; }\n        public object Value { get; set; }\n\n        public static implicit operator JsonDataValueHelper(string value)\n        {\n            return new JsonDataValueHelper { Type = JsonDataType.String, Value = value };\n        }\n\n        public static implicit operator string(JsonDataValueHelper helper)\n        {\n            return helper.Value?.ToString();\n        }\n\n        public static implicit operator JsonDataValueHelper(int value)\n        {\n            return new JsonDataValueHelper { Type = JsonDataType.Int, Value = value };\n        }\n\n        public static implicit operator int(JsonDataValueHelper helper)\n        {\n            if (helper.Value is int i) return i;\n            if (int.TryParse(helper.Value?.ToString(), out i))\n                return i;\n            return 0;\n        }\n\n        \n    }\n\n    public enum JsonDataType\n    {\n        None,\n        String,\n        Int,\n        Long,\n        ULong,\n        Float,\n        DateTime,\n        UtcDateTime,\n        Bool,\n        Array,\n        Object\n    }\n\n    #endregion\n\n    #region Parsing and Serialization\n\n    \n    public static class JsonParser\n    {\n        \n        public static JsonBaseObject Parse(string json)\n        {\n            if (string.IsNullOrWhiteSpace(json))\n                return null;\n            json = json.Trim();\n            if (json.StartsWith(\"[\"))\n            {\n                var arr = new JsonArray();\n                arr.FromJson(new JObject { [\"array\"] = JArray.Parse(json) });\n                return arr;\n            }\n            else\n            {\n                var obj = new JsonObject();\n                obj.FromJson(JObject.Parse(json));\n                return obj;\n            }\n        }\n\n        \n        public static string Serialize(JsonBaseObject jsonObj, bool compact = true)\n        {\n            var formatting = compact ? Formatting.None : Formatting.Indented;\n            return jsonObj.ToJson().ToString(formatting);\n        }\n    }\n\n    #endregion\n\n    #region Example Usage\n\n    \n\n    #endregion\n}"}
{"input": "unit Horse.Core.Param.Config;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\ntype\n  THorseCoreParamConfig = class\n  private\n    class var FInstance: THorseCoreParamConfig;\n    FRequiredMessage: string;\n    FInvalidFormatMessage: string;\n    FDateFormat: string;\n    FTimeFormat: string;\n    FReturnUTC: Boolean;\n    FTrueValue: string;\n    FCheckLhsBrackets: Boolean;\n    constructor Create;\n  public\n    function RequiredMessage(const AValue: string): THorseCoreParamConfig; overload;\n    function RequiredMessage: string; overload;\n    function InvalidFormatMessage(const AValue: string): THorseCoreParamConfig; overload;\n    function InvalidFormatMessage: string; overload;\n    function DateFormat(const AValue: string): THorseCoreParamConfig; overload;\n    function DateFormat: string; overload;\n    function TimeFormat(const AValue: string): THorseCoreParamConfig; overload;\n    function TimeFormat: string; overload;\n    function ReturnUTC(const AValue: Boolean): THorseCoreParamConfig; overload;\n    function ReturnUTC: Boolean; overload;\n    function TrueValue(const AValue: string): THorseCoreParamConfig; overload;\n    function TrueValue: string; overload;\n    function CheckLhsBrackets(const AValue: Boolean): THorseCoreParamConfig; overload;\n    function CheckLhsBrackets: Boolean; overload;\n    class function GetInstance: THorseCoreParamConfig;\n    class destructor UnInitialize;\n  end;\n\nimplementation\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils;\n{$ELSE}\n  System.SysUtils;\n{$ENDIF}\n\nconstructor THorseCoreParamConfig.Create;\nbegin\n  FReturnUTC := True;\n  FDateFormat := 'yyyy-MM-dd';\n  FTimeFormat := 'hh:mm:ss';\n  FTrueValue := 'true';\n  FRequiredMessage := 'The %s param is required.';\n  FInvalidFormatMessage := 'The %0:s param ''%1:s'' is not valid a %2:s type.';\n  FCheckLhsBrackets := False;\nend;\n\nfunction THorseCoreParamConfig.DateFormat(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FDateFormat := AValue;\nend;\n\nfunction THorseCoreParamConfig.DateFormat: string;\nbegin\n  Result := FDateFormat;\nend;\n\nclass function THorseCoreParamConfig.GetInstance: THorseCoreParamConfig;\nbegin\n  if not Assigned(FInstance) then\n    FInstance := THorseCoreParamConfig.Create;\n  Result := FInstance;\nend;\n\nfunction THorseCoreParamConfig.InvalidFormatMessage: string;\nbegin\n  Result := FInvalidFormatMessage;\nend;\n\nfunction THorseCoreParamConfig.InvalidFormatMessage(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FInvalidFormatMessage := AValue;\nend;\n\nfunction THorseCoreParamConfig.RequiredMessage(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FRequiredMessage := AValue;\nend;\n\nfunction THorseCoreParamConfig.RequiredMessage: string;\nbegin\n  Result := FRequiredMessage;\nend;\n\nfunction THorseCoreParamConfig.ReturnUTC(const AValue: Boolean): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FReturnUTC := AValue;\nend;\n\nfunction THorseCoreParamConfig.ReturnUTC: Boolean;\nbegin\n  Result := FReturnUTC;\nend;\n\nfunction THorseCoreParamConfig.TimeFormat: string;\nbegin\n  Result := FTimeFormat;\nend;\n\nfunction THorseCoreParamConfig.TimeFormat(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FTimeFormat := AValue;\nend;\n\nfunction THorseCoreParamConfig.TrueValue(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FTrueValue := AValue;\nend;\n\nfunction THorseCoreParamConfig.TrueValue: string;\nbegin\n  Result := FTrueValue;\nend;\n\nfunction THorseCoreParamConfig.CheckLhsBrackets(const AValue: Boolean\n  ): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FCheckLhsBrackets := AValue;\nend;\n\nfunction THorseCoreParamConfig.CheckLhsBrackets: Boolean;\nbegin\n  Result := FCheckLhsBrackets;\nend;\n\nclass destructor THorseCoreParamConfig.UnInitialize;\nbegin\n  if Assigned(FInstance) then\n    FreeAndNil(FInstance);\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Core.Param.Config\n{\n    public class HorseCoreParamConfig\n    {\n        private static HorseCoreParamConfig _instance;\n        private string _requiredMessage;\n        private string _invalidFormatMessage;\n        private string _dateFormat;\n        private string _timeFormat;\n        private bool _returnUTC;\n        private string _trueValue;\n        private bool _checkLhsBrackets;\n\n        private HorseCoreParamConfig()\n        {\n            _returnUTC = true;\n            _dateFormat = \"yyyy-MM-dd\";\n            _timeFormat = \"hh:mm:ss\";\n            _trueValue = \"true\";\n            _requiredMessage = \"The %s param is required.\";\n            _invalidFormatMessage = \"The %0:s param '%1:s' is not valid a %2:s type.\";\n            _checkLhsBrackets = false;\n        }\n\n        public HorseCoreParamConfig WithRequiredMessage(string value)\n        {\n            _requiredMessage = value;\n            return this;\n        }\n\n        \n        public string RequiredMessage => _requiredMessage;\n\n        \n        public HorseCoreParamConfig WithInvalidFormatMessage(string value)\n        {\n            _invalidFormatMessage = value;\n            return this;\n        }\n\n        \n        public string InvalidFormatMessage => _invalidFormatMessage;\n\n        \n        public HorseCoreParamConfig WithDateFormat(string value)\n        {\n            _dateFormat = value;\n            return this;\n        }\n\n        \n        public string DateFormat => _dateFormat;\n\n        \n        public HorseCoreParamConfig WithTimeFormat(string value)\n        {\n            _timeFormat = value;\n            return this;\n        }\n\n        \n        public string TimeFormat => _timeFormat;\n\n        \n        public HorseCoreParamConfig WithReturnUTC(bool value)\n        {\n            _returnUTC = value;\n            return this;\n        }\n\n        \n        public bool ReturnUTC => _returnUTC;\n\n        \n        public HorseCoreParamConfig WithTrueValue(string value)\n        {\n            _trueValue = value;\n            return this;\n        }\n\n        \n        public string TrueValue => _trueValue;\n\n        \n        public HorseCoreParamConfig WithCheckLhsBrackets(bool value)\n        {\n            _checkLhsBrackets = value;\n            return this;\n        }\n\n        \n        public bool CheckLhsBrackets => _checkLhsBrackets;\n\n        \n        public static HorseCoreParamConfig GetInstance()\n        {\n            if (_instance == null)\n            {\n                _instance = new HorseCoreParamConfig();\n            }\n            return _instance;\n        }\n\n        \n        public static void UnInitialize()\n        {\n            _instance = null;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit WebModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  FireDAC.Stan.StorageJSON\n{$IFDEF MSWINDOWS}\n    ,MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes\n{$ENDIF}\n    ;\n\ntype\n  TMainWebModule = class(TWebModule)\n    FDStanStorageJSONLink1: TFDStanStorageJSONLink;\n    procedure WebModuleCreate(Sender: TObject);\n  private\n    MVCEngine: TMVCEngine;\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMainWebModule;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  TestServerControllerU,\n  TestServerControllerExceptionU,\n  SpeedMiddlewareU,\n  MVCFramework.Middleware.Authentication,\n  MVCFramework.ActiveRecordController,\n  System.Generics.Collections,\n  MVCFramework.Commons,\n  TestServerControllerPrivateU,\n  AuthHandlersU,\n  TestServerControllerJSONRPCU,\n  {$IFNDEF LINUX}\n  MVCFramework.View.Renderers.Mustache,\n  {$ENDIF}\n  MVCFramework.Middleware.Compression,\n  MVCFramework.Middleware.Session,\n  MVCFramework.Middleware.StaticFiles,\n  FireDAC.Comp.Client,\n  MVCFramework.ActiveRecord,\n  FDConnectionConfigU,\n  System.IOUtils;\n\nprocedure TMainWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  MVCEngine := TMVCEngine.Create(self,\n    procedure(Config: TMVCConfig)\n    begin\n      // no config here\n      Config[TMVCConfigKey.PathPrefix] := '';\n      Config[TMVCConfigKey.ViewPath] := TPath.Combine(AppPath, '..\\templates');\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n    end);\n  MVCEngine\n    .AddController(TTestServerController)\n    .AddController(TTestPrivateServerController)\n    .AddController(TTestServerControllerExceptionAfterCreate)\n    .AddController(TTestServerControllerExceptionBeforeDestroy)\n    .AddController(TTestServerControllerActionFilters)\n    .AddController(TTestPrivateServerControllerCustomAuth)\n    .AddController(TTestMultiPathController)\n    .AddController(TTestActionResultController)\n    .AddController(TTestJSONRPCController, '/jsonrpc')\n    .AddController(TTestJSONRPCControllerWithGet, '/jsonrpcwithget')\n    .AddController(TMVCActiveRecordController, '/api/entities')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCClass.Create\n    end, '/jsonrpcclass')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCClassWithGET.Create\n    end, '/jsonrpcclasswithget')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClass.Create\n    end, '/jsonrpcclass1')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClassWithGet.Create\n    end, '/jsonrpcclass1withget')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClassWithGet.Create\n    end, '/jsonrpcclass1withget')\n    .AddController(TTestFaultController) // this will raise an exception\n    .AddController(TTestFault2Controller,\n    function: TMVCController\n    begin\n      Result := TTestFault2Controller.Create; // this will raise an exception\n    end)\n    .AddMiddleware(UseMemorySessionMiddleware())\n    .AddMiddleware(TMVCSpeedMiddleware.Create)\n    .AddMiddleware(TMVCCustomAuthenticationMiddleware.Create(TCustomAuthHandler.Create, '/system/users/logged'))\n    .AddMiddleware(TMVCStaticFilesMiddleware.Create('/static', 'www', 'index.html', False))\n    .AddMiddleware(TMVCStaticFilesMiddleware.Create('/spa', 'www', 'index.html', True))\n    .AddMiddleware(TMVCBasicAuthenticationMiddleware.Create(TBasicAuthHandler.Create))\n    .AddMiddleware(TMVCCompressionMiddleware.Create);\n{$IFDEF MSWINDOWS}\n  MVCEngine.SetViewEngine(TMVCMustacheViewEngine);\n  RegisterOptionalCustomTypesSerializers(MVCEngine.Serializer(TMVCMediaType.APPLICATION_JSON));\n{$ENDIF}\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing TestServerControllerU;\nusing TestServerControllerExceptionU;\nusing SpeedMiddlewareU;\nusing MVCFramework.Middleware.Authentication;\nusing MVCFramework.ActiveRecordController;\nusing TestServerControllerPrivateU;\nusing AuthHandlersU;\nusing TestServerControllerJSONRPCU;\nusing MVCFramework.Middleware.Compression;\nusing MVCFramework.Middleware.Session;\nusing MVCFramework.Middleware.StaticFiles;\nusing FDConnectionConfigU;\n\nnamespace WebModuleUnit\n{\n    public class MainWebModule : WebModule\n    {\n        public TMVCEngine MVCEngine { get; private set; }\n        public MainWebModule()\n        {\n            WebModuleCreate();\n        }\n        public void WebModuleCreate()\n        {\n            MVCEngine = new TMVCEngine(this, config =>\n            {\n                config[TMVCConfigKey.PathPrefix] = \"\";\n                config[TMVCConfigKey.ViewPath] = Path.Combine(AppPath, @\"..\\templates\");\n                config[TMVCConfigKey.DefaultViewFileExtension] = \"html\";\n            });\n            MVCEngine\n                .AddController(typeof(TestServerController))\n                .AddController(typeof(TestServerControllerException))\n                .AddController(typeof(TestServerControllerExceptionAfterCreate))\n                .AddController(typeof(TestServerControllerExceptionBeforeDestroy))\n                .AddController(typeof(TestServerControllerActionFilters))\n                .AddController(typeof(TestPrivateServerControllerCustomAuth))\n                .AddController(typeof(TestMultiPathController))\n                .AddController(typeof(TestActionResultController))\n                .AddController(typeof(TestJSONRPCController), \"/jsonrpc\")\n                .AddController(typeof(TestJSONRPCControllerWithGet), \"/jsonrpcwithget\")\n                .AddController(typeof(TMVCActiveRecordController), \"/api/entities\")\n                .PublishObject(() => new TestJSONRPCClass(), \"/jsonrpcclass\")\n                .PublishObject(() => new TestJSONRPCClassWithGET(), \"/jsonrpcclasswithget\")\n                .PublishObject(() => new TestJSONRPCHookClass(), \"/jsonrpcclass1\")\n                .PublishObject(() => new TestJSONRPCHookClassWithGet(), \"/jsonrpcclass1withget\")\n                .PublishObject(() => new TestJSONRPCHookClassWithGet(), \"/jsonrpcclass1withget\")\n                .AddController(typeof(TestFaultController))\n                .AddController(() => new TestFault2Controller(), \"/testfault2\")\n                .AddMiddleware(UseMemorySessionMiddleware())\n                .AddMiddleware(new TMVCSpeedMiddleware())\n                .AddMiddleware(new TMVCCustomAuthenticationMiddleware(new TCustomAuthHandler(), \"/system/users/logged\"))\n                .AddMiddleware(new TMVCStaticFilesMiddleware(\"/static\", \"www\", \"index.html\", false))\n                .AddMiddleware(new TMVCStaticFilesMiddleware(\"/spa\", \"www\", \"index.html\", true))\n                .AddMiddleware(new TMVCBasicAuthenticationMiddleware(new TBasicAuthHandler()))\n                .AddMiddleware(new TMVCCompressionMiddleware());\n#if MSWINDOWS\n            MVCEngine.SetViewEngine(new TMVCMustacheViewEngine());\n            RegisterOptionalCustomTypesSerializers(MVCEngine.Serializer(MVCMediaType.APPLICATION_JSON));\n#endif\n        }\n    }\n}"}
{"input": "unit Controller2U;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/controller2')]\n  TMyController2 = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\nprocedure TMyController2.Index;\nbegin\n  // use Context property to access to the HTTP request and response\n  Render('Hello DelphiMVCFramework World');\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\n\nnamespace Controller2U\n{\n\n    [Route(\"controller2\")]\n    [ApiController]\n    public class MyController2 : ControllerBase\n    {\n       \n        [HttpGet]\n        public IActionResult Index()\n        {\n            \n            return Ok(\"Hello DelphiMVCFramework World\");\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.LRUCache;\n\ninterface\n\nuses\n  System.SysUtils, System.Generics.Collections;\n\ntype\n  TMVCLRUCacheAction = reference to function(const Key: string): Boolean;\n\n  TMVCLRUCache<T: class> = class\n  private type\n    TMVCLRUCacheItem = class\n    public\n      Key: string;\n      Value: T;\n      constructor Create(const Key: string; const Item: T);\n      destructor Destroy; override;\n    end;\n  private\n    fCache: TObjectList<TMVCLRUCacheItem>;\n    fCapacity: Integer;\n  public\n    constructor Create(const Capacity: Integer); virtual;\n    destructor Destroy; override;\n    function Contains(const Key: string; out ItemIndex: UInt64): Boolean;\n    procedure Put(const Key: string; const Item: T);\n    function TryGet(const Key: string; out Item: T): Boolean;\n    procedure RemoveIf(const Action: TMVCLRUCacheAction);\n    procedure Clear;\n    function Size: UInt32;\n    procedure Lock;\n    procedure UnLock;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger;\n\n{ TMVCLRUCache }\n\nprocedure TMVCLRUCache<T>.Clear;\nbegin\n  fCache.Clear;\nend;\n\nfunction TMVCLRUCache<T>.Contains(const Key: string; out ItemIndex: UInt64): Boolean;\nvar\n  I: Integer;\nbegin\n  Result := False;\n  for I := 0 to fCache.Count - 1 do\n  begin\n    if Key = fCache[I].Key then\n    begin\n      ItemIndex := I;\n      Exit(True);\n    end;\n  end;\nend;\n\nfunction TMVCLRUCache<T>.Size: UInt32;\nbegin\n  Result := fCache.Count;\nend;\n\nconstructor TMVCLRUCache<T>.Create(const Capacity: Integer);\nbegin\n  inherited Create;\n  fCapacity := Capacity;\n  fCache := TObjectList<TMVCLRUCacheItem>.Create(True);\nend;\n\ndestructor TMVCLRUCache<T>.Destroy;\nbegin\n  fCache.Free;\n  inherited;\nend;\n\nprocedure TMVCLRUCache<T>.Lock;\nbegin\n  TMonitor.Enter(Self);\nend;\n\nprocedure TMVCLRUCache<T>.Put(const Key: string; const Item: T);\nbegin\n  Lock;\n  try\n    if fCache.Count = fCapacity then\n    begin\n\t    fCache.Delete(fCache.Count - 1);\n    end;\n    fCache.Insert(0, TMVCLRUCacheItem.Create(Key, Item));\n  finally\n    UnLock;\n  end;\nend;\n\nprocedure TMVCLRUCache<T>.RemoveIf(const Action: TMVCLRUCacheAction);\nvar\n  lIndex: Integer;\n  lCacheSize: Integer;\nbegin\n  lIndex := 0;\n  lCacheSize := fCache.Count;\n  while lIndex < lCacheSize do\n  begin\n    if Action(fCache[lIndex].Key) then\n    begin\n      fCache.Delete(lIndex);\n    end\n    else\n    begin\n      Inc(lIndex);\n    end;\n    lCacheSize := fCache.Count;\n  end;\nend;\n\nfunction TMVCLRUCache<T>.TryGet(const Key: string; out Item: T): Boolean;\nvar\n  lItemIndex: UInt64;\n  lCacheItem: TMVCLRUCacheItem;\nbegin\n  Result := Contains(Key, lItemIndex);\n  if Result { and (lItemIndex <> 0) } then\n  begin\n    if lItemIndex > 0 then\n    begin\n      fCache.Exchange(lItemIndex, 0);\n    end;\n    //\n    //\n    // if lItemIndex = 0 then\n    // begin\n    // lCacheItem := fCache[0];\n    // end\n    // else\n    // begin\n    // lCacheItem := fCache.Extract(fCache[lItemIndex]);\n    // fCache.Insert(0, lCacheItem);\n    // end;\n    lCacheItem := fCache[0];\n    Item := lCacheItem.Value;\n  end;\nend;\n\nprocedure TMVCLRUCache<T>.UnLock;\nbegin\n  TMonitor.Exit(Self);\nend;\n\n{ TMVCLRUCache<T>.TMVCLRUCacheItem<T> }\n\nconstructor TMVCLRUCache<T>.TMVCLRUCacheItem.Create(const Key: string; const Item: T);\nbegin\n  inherited Create;\n  Self.Key := Key;\n  Self.Value := Item;\nend;\n\ndestructor TMVCLRUCache<T>.TMVCLRUCacheItem.Destroy;\nbegin\n  Value.Free;\n  Value := nil;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\n\nnamespace MVCFramework\n{\n\n    public delegate bool MVCLRUCacheAction(string key);\n\n    \n    public class MVCLRUCache<T> where T : class\n    {\n        \n        private class MVCLRUCacheItem\n        {\n            public string Key { get; }\n            public T Value { get; }\n\n            public MVCLRUCacheItem(string key, T item)\n            {\n                Key = key;\n                Value = item;\n            }\n        }\n\n        \n        private readonly List<MVCLRUCacheItem> _cache;\n        \n        private readonly int _capacity;\n        \n        private readonly object _syncRoot = new object();\n\n        \n        public MVCLRUCache(int capacity)\n        {\n            _capacity = capacity;\n            _cache = new List<MVCLRUCacheItem>();\n        }\n\n        \n        public void Clear()\n        {\n            lock (_syncRoot)\n            {\n                _cache.Clear();\n            }\n        }\n\n        \n        public bool Contains(string key, out int itemIndex)\n        {\n            lock (_syncRoot)\n            {\n                for (int i = 0; i < _cache.Count; i++)\n                {\n                    if (key == _cache[i].Key)\n                    {\n                        itemIndex = i;\n                        return true;\n                    }\n                }\n                itemIndex = -1;\n                return false;\n            }\n        }\n\n        \n        public void Put(string key, T item)\n        {\n            lock (_syncRoot)\n            {\n                \n                if (_cache.Count == _capacity)\n                {\n                    \n                    _cache.RemoveAt(_cache.Count - 1);\n                }\n                \n                _cache.Insert(0, new MVCLRUCacheItem(key, item));\n            }\n        }\n\n        \n        public bool TryGet(string key, out T item)\n        {\n            lock (_syncRoot)\n            {\n                int index;\n                if (Contains(key, out index))\n                {\n                    if (index > 0)\n                    {\n                        \n                        var cacheItem = _cache[index];\n                        _cache.RemoveAt(index);\n                        _cache.Insert(0, cacheItem);\n                    }\n                    item = _cache[0].Value;\n                    return true;\n                }\n                item = null;\n                return false;\n            }\n        }\n\n        \n        public void RemoveIf(MVCLRUCacheAction action)\n        {\n            lock (_syncRoot)\n            {\n                int index = 0;\n                while (index < _cache.Count)\n                {\n                    if (action(_cache[index].Key))\n                    {\n                        _cache.RemoveAt(index);\n                    }\n                    else\n                    {\n                        index++;\n                    }\n                }\n            }\n        }\n\n        \n        public uint Size()\n        {\n            lock (_syncRoot)\n            {\n                return (uint)_cache.Count;\n            }\n        }\n\n        \n        public void Lock()\n        {\n            Monitor.Enter(_syncRoot);\n        }\n\n        \n        public void UnLock()\n        {\n            Monitor.Exit(_syncRoot);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit DMVC.Expert.Commands.Templates;\n\ninterface\n\nuses\n  System.Generics.Collections, DMVC.Expert.CodeGen.Executor;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nprocedure FillTemplateProTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebStencilsTemplates(Gen: TMVCCodeGenerator);\nprocedure FillMustacheTemplates(Gen: TMVCCodeGenerator);\nprocedure FillEntitiesTemplates(Gen: TMVCCodeGenerator);\nprocedure FillServicesTemplates(Gen: TMVCCodeGenerator);\n\nimplementation\n\nuses\n  DMVC.Expert.Commons,\n  DMVC.Expert.CodeGen.Commands;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitProgramCommand.Create,\n    TUnitRunServerProcBody.Create,\n    TUnitMainBeginEndCommand.Create\n  ]);\nend;\n\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerCommand.Create,\n    TUnitControllerControllerDeclarationCommand.Create,\n    TUnitFooterCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebModuleDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitJSONRPCDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TWebModuleDFMCommand.Create\n    ]);\nend;\n\nprocedure FillMustacheTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitMustacheHelpersDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillTemplateProTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitTemplateProHelpersDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebStencilsTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebStencilsHelpersDeclarationCommand.Create\n    ]);\nend;\n\n\nprocedure FillServicesTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitServicesDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillEntitiesTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerEntityDeclarationCommand.Create\n    ]);\nend;\n\n\nend.", "output": "using System.Collections.Generic;\nusing DMVC.Expert.CodeGen.Executor;       \nusing DMVC.Expert.CodeGen.Commands;        \n\nnamespace DMVCExpertCommandsTemplates\n{\n    public static class CommandsTemplates\n    {\n        public static void FillProgramTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitProgramCommand(),\n                new TUnitRunServerProcBody(),\n                new TUnitMainBeginEndCommand()\n            });\n        }\n\n        public static void FillControllerTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitControllerCommand(),\n                new TUnitControllerControllerDeclarationCommand(),\n                new TUnitFooterCommand()\n            });\n        }\n\n        public static void FillWebModuleTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitWebModuleDeclarationCommand()\n            });\n        }\n\n        public static void FillWebModuleDFMTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TWebModuleDFMCommand()\n            });\n        }\n\n        public static void FillJSONRPCTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitJSONRPCDeclarationCommand()\n            });\n        }\n\n        public static void FillTemplateProTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitTemplateProHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillWebStencilsTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitWebStencilsHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillMustacheTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitMustacheHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillEntitiesTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitControllerEntityDeclarationCommand()\n            });\n        }\n\n        public static void FillServicesTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitServicesDeclarationCommand()\n            });\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi Fake Data Utils\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphi_fake_data_utils\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n{$DEFINE GENERATE_DATASETS}\n\nunit RandomUtilsU;\n\ninterface\n\n{$IF Defined(GENERATE_DATASETS)}\nuses\n  Data.DB, FireDAC.Stan.Intf, FireDAC.Stan.Option,\n  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,\n  FireDAC.DApt.Intf, FireDAC.Comp.DataSet, FireDAC.Comp.Client;\n{$ENDIF}\n\nconst\n  FirstNames: array [0 .. 29] of string = (\n    'Daniele',\n    'Debora',\n    'Mattia',\n    'Jack',\n    'James',\n    'William',\n    'Joseph',\n    'David',\n    'Charles',\n    'Thomas',\n    'Ethan',\n    'Liam',\n    'Noah',\n    'Logan',\n    'Lucas',\n    'Mason',\n    'Benjamin',\n    'Alexander',\n    'Elijah',\n    'Jordan',\n    'Alexander',\n    'Jamie',\n    'Tyler',\n    'Caleb',\n    'Kieran',\n    'Ryan',\n    'Colton',\n    'Jaxon',\n    'Gavin',\n    'Ryder'\n    );\n\n  LastNames: array [0 .. 13] of string = (\n    'Smith',\n    'Johnson',\n    'Williams',\n    'Brown',\n    'Black',\n    'Red',\n    'Green',\n    'Willis',\n    'Jones',\n    'Miller',\n    'Davis',\n    'Wilson',\n    'Martinez',\n    'Anderson'\n    );\n\n  Countries: array [0 .. 24] of string = (\n    'italy',\n    'new york',\n    'illinois',\n    'arizona',\n    'nevada',\n    'uk',\n    'france',\n    'georgia',\n    'spain',\n    'portugal',\n    'germany',\n    'norway',\n    'california',\n    'usa',\n    'japan',\n    'australia',\n    'singapore',\n    'hong kong',\n    'taiwan',\n    'south africa',\n    'canada',\n    'switzerland',\n    'sweden',\n    'netherlands',\n    'belgium'\n  );\n\nLOREM_IPSUM =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.' +\n  'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.' +\n  'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' +\n  'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';\n\n    WORDS: array [0 .. 1000] of string = ('bite', 'mate', 'quill', 'back', 'church', 'pear', 'knit', 'bent', 'wrench', 'crack', 'heavenly',\n      'deceive', 'maddening', 'plain', 'writer', 'rapid', 'acidic', 'decide', 'hat', 'paint', 'cow', 'dysfunctional', 'pet', 'giraffe',\n      'connection', 'sour', 'voracious', 'cloudy', 'wry', 'curve', 'agree', 'eggnog', 'flaky', 'painstaking', 'warm', 'silk', 'icy',\n      'hellish', 'toy', 'milky', 'skirt', 'test', 'daffy', 'questionable', 'gamy', 'aware', 'berry', 'throne', 'oven', 'subtract', 'cool',\n      'care', 'charge', 'smash', 'curve', 'comfortable', 'narrow', 'merciful', 'material', 'fear', 'exercise', 'skinny', 'fire',\n      'rainstorm', 'tail', 'nondescript', 'calculating', 'pack', 'steel', 'marvelous', 'baseball', 'furtive', 'stitch', 'abiding', 'empty',\n      'bushes', 'painful', 'tense', 'verse', 'unwritten', 'reproduce', 'receptive', 'bottle', 'silky', 'alleged', 'stingy', 'irritate',\n      'expand', 'cap', 'unsuitable', 'gigantic', 'exist', 'damp', 'scrub', 'disgusted', 'sun', 'ink', 'detailed', 'defeated', 'economic',\n      'chunky', 'stop', 'overflow', 'numerous', 'joyous', 'wipe', 'drink', 'error', 'branch', 'male', 'proud', 'soggy', 'ship', 'excite',\n      'industry', 'wistful', 'man', 'vacation', 'doctor', 'naughty', 'plane', 'ignore', 'open', 'act', 'earthquake', 'inconclusive',\n      'reflect', 'force', 'funny', 'wonder', 'magenta', 'near', 'dam', 'windy', 'maid', 'wacky', 'release', 'birthday', 'statement',\n      'psychotic', 'quicksand', 'things', 'planes', 'boundary', 'nod', 'touch', 'argue', 'sin', 'train', 'adhoc', 'needle', 'regret',\n      'stroke', 'strengthen', 'bruise', 'mine', 'rod', 'tax', 'twig', 'advise', 'stamp', 'rhyme', 'obnoxious', 'few', 'inform', 'fixed',\n      'mailbox', 'bells', 'grade', 'machine', 'yarn', 'lighten', 'tub', 'guiltless', 'hot', 'misty', 'van', 'flap', 'nosy', 'neighborly',\n      'crime', 'nifty', 'uninterested', 'noisy', 'oafish', 'squeal', 'page', 'wet', 'embarrassed', 'long-term', 'closed', 'language',\n      'argument', 'elite', 'ban', 'trip', 'tour', 'wine', 'profit', 'envious', 'love', 'back', 'bite-sized', 'magical', 'snatch', 'elated',\n      'sniff', 'far', 'shy', 'deeply', 'zoom', 'invent', 'downtown', 'heartbreaking', 'angry', 'can', 'bucket', 'important', 'fetch',\n      'shoe', 'self', 'x-ray', 'abhorrent', 'lumpy', 'fertile', 'nest', 'pick', 'history', 'offbeat', 'interrupt', 'yell', 'grain',\n      'scintillating', 'alluring', 'wren', 'form', 'attack', 'foregoing', 'suspect', 'daughter', 'moldy', 'signal', 'placid', 'quirky',\n      'itchy', 'butter', 'ordinary', 'imaginary', 'list', 'known', 'servant', 'slow', 'apparel', 'meeting', 'lovely', 'bat', 'insurance',\n      'waste', 'aromatic', 'foot', 'breakable', 'theory', 'stiff', 'cream', 'train', 'ground', 'fuel', 'wary', 'store', 'wonderful', 'corn',\n      'zippy', 'dashing', 'risk', 'prose', 'try', 'green', 'bead', 'recess', 'chop', 'stain', 'faded', 'heat', 'camera', 'panicky',\n      'depressed', 'wooden', 'clumsy', 'gullible', 'railway', 'guide', 'current', 'giants', 'enter', 'talented', 'bustling', 'square',\n      'jewel', 'bee', 'jelly', 'utopian', 'heal', 'anger', 'balance', 'tick', 'turn', 'unique', 'lively', 'wrist', 'fade', 'tender',\n      'outgoing', 'own', 'sigh', 'jobless', 'boiling', 'parallel', 'vest', 'leather', 'spark', 'suck', 'knot', 'circle', 'square', 'supply',\n      'tank', 'fax', 'spotless', 'habitual', 'feeling', 'watch', 'cattle', 'end', 'true', 'zonked', 'poison', 'man', 'pedal', 'boorish',\n      'moaning', 'mindless', 'bone', 'spot', 'chubby', 'numberless', 'eye', 'bright', 'sweet', 'fanatical', 'oranges', 'calm', 'squash',\n      'tooth', 'petite', 'design', 'one', 'bump', 'aberrant', 'mine', 'fit', 'rub', 'optimal', 'ugly', 'lyrical', 'borrow', 'queue',\n      'alert', 'normal', 'wrathful', 'truculent', 'level', 'hollow', 'disillusioned', 'kick', 'weather', 'mighty', 'upbeat', 'troubled',\n      'snotty', 'many', 'warn', 'thank', 'trains', 'plan', 'choke', 'activity', 'attend', 'walk', 'thought', 'gabby', 'actor', 'prickly',\n      'smell', 'dangerous', 'observation', 'action', 'steady', 'hypnotic', 'second-hand', 'zip', 'mundane', 'sand', 'sneaky', 'harm',\n      'pancake', 'guarantee', 'empty', 'bulb', 'burn', 'reject', 'decorate', 'obese', 'crowd', 'clap', 'flat', 'available', 'hop', 'untidy',\n      'wreck', 'fasten', 'waves', 'dinosaurs', 'dreary', 'fearful', 'answer', 'parched', 'tight', 'animated', 'desk', 'jaded', 'wax',\n      'silver', 'scream', 'puzzling', 'unbiased', 'unite', 'branch', 'quack', 'writing', 'tease', 'mint', 'full', 'plate', 'gusty', 'bear',\n      'bell', 'sparkling', 'absurd', 'past', 'earsplitting', 'seemly', 'unadvised', 'paper', 'battle', 'friend', 'control', 'rich',\n      'regret', 'used', 'scattered', 'redundant', 'slave', 'languid', 'didactic', 'fairies', 'sofa', 'spiteful', 'reply', 'division',\n      'engine', 'suppose', 'homeless', 'pinch', 'ray', 'channel', 'repeat', 'smoke', 'concentrate', 'handy', 'committee', 'songs', 'madly',\n      'itch', 'hands', 'clean', 'addition', 'majestic', 'careful', 'fallacious', 'guarded', 'last', 'time', 'tumble', 'plastic', 'force',\n      'guess', 'grape', 'loving', 'hand', 'remain', 'vigorous', 'wash', 'cars', 'same', 'provide', 'shelf', 'yam', 'onerous', 'claim',\n      'tramp', 'glistening', 'innocent', 'lock', 'close', 'absorbing', 'daily', 'amuck', 'manage', 'energetic', 'absent', 'fantastic',\n      'flippant', 'unnatural', 'amount', 'luxuriant', 'clover', 'alert', 'wheel', 'cellar', 'agonizing', 'card', 'memorise', 'meal',\n      'suspend', 'concerned', 'uneven', 'deranged', 'spiritual', 'arch', 'dare', 'hammer', 'tug', 'jump', 'vase', 'plant', 'color', 'worm',\n      'grab', 'frame', 'taste', 'incandescent', 'little', 'rule', 'confused', 'roomy', 'gorgeous', 'heat', 'whole', 'cracker', 'water',\n      'flimsy', 'high-pitched', 'grandfather', 'spooky', 'natural', 'grease', 'noiseless', 'superficial', 'gaze', 'finger', 'afford',\n      'racial', 'tiresome', 'tremendous', 'zealous', 'slip', 'position', 'mountainous', 'shelter', 'calculator', 'tacky', 'whip',\n      'mountain', 'clear', 'thin', 'smell', 'ants', 'yellow', 'cross', 'employ', 'trouble', 'dazzling', 'enchanting', 'groovy', 'measure',\n      'disapprove', 'elastic', 'sparkle', 'cub', 'foolish', 'discussion', 'stormy', 'pies', 'absorbed', 'trashy', 'mammoth', 'low',\n      'subdued', 'badge', 'letter', 'previous', 'challenge', 'tart', 'cute', 'suit', 'condition', 'pricey', 'rule', 'wrong', 'bomb', 'wiry',\n      'swim', 'crack', 'disgusting', 'gather', 'half', 'sturdy', 'probable', 'stream', 'trick', 'silly', 'sulky', 'nail', 'rotten', 'stir',\n      'sneeze', 'even', 'adamant', 'cluttered', 'object', 'battle', 'petite', 'wait', 'instinctive', 'donkey', 'squeamish', 'rainy',\n      'craven', 'acceptable', 'husky', 'pollution', 'judicious', 'distribution', 'neck', 'left', 'collect', 'thankful', 'describe',\n      'complex', 'transport', 'horses', 'hope', 'chemical', 'dress', 'idea', 'extend', 'laugh', 'event', 'route', 'hose', 'abundant',\n      'insect', 'spectacular', 'whistle', 'home', 'vast', 'massive', 'grey', 'sail', 'lavish', 'word', 'coach', 'repair', 'squeak',\n      'curious', 'beam', 'middle', 'obscene', 'efficacious', 'supreme', 'torpid', 'jazzy', 'linen', 'cause', 'synonymous', 'book', 'brave',\n      'staking', 'weak', 'show', 'birds', 'barbarous', 'hilarious', 'injure', 'walk', 'screeching', 'frequent', 'wide', 'kiss', 'lonely',\n      'quarrelsome', 'arm', 'flowers', 'surround', 'level', 'enjoy', 'calculate', 'reach', 'brother', 'grandiose', 'clammy', 'thunder',\n      'pen', 'rake', 'whirl', 'sharp', 'fence', 'scissors', 'polish', 'recondite', 'brief', 'pig', 'ten', 'spell', 'coal', 'sidewalk',\n      'straight', 'melted', 'ring', 'deadpan', 'nine', 'wound', 'use', 'switch', 'watch', 'meat', 'governor', 'lively', 'neat', 'dapper',\n      'gate', 'rose', 'wealthy', 'psychedelic', 'slap', 'note', 'request', 'match', 'abashed', 'snail', 'tray', 'pump', 'disappear',\n      'vegetable', 'wool', 'abstracted', 'impulse', 'fork', 'brake', 'shiny', 'team', 'coherent', 'dust', 'relieved', 'long', 'broad',\n      'shop', 'innate', 'milk', 'mother', 'screw', 'cushion', 'listen', 'spot', 'willing', 'legs', 'clever', 'obsolete', 'coil', 'smoke',\n      'call', 'men', 'purpose', 'bumpy', 'receipt', 'soothe', 'thinkable', 'launch', 'kittens', 'oceanic', 'dolls', 'jagged', 'fine',\n      'start', 'muddled', 'want', 'develop', 'skillful', 'real', 'sisters', 'cooperative', 'retire', 'scarecrow', 'caring', 'chance',\n      'search', 'visitor', 'stem', 'rabid', 'seed', 'endurable', 'cloistered', 'knife', 'cast', 'trouble', 'cold', 'brainy', 'admit',\n      'base', 'multiply', 'escape', 'bike', 'frighten', 'large', 'pull', 'observant', 'stereotyped', 'dirty', 'tin', 'vague', 'celery',\n      'hungry', 'best', 'difficult', 'burly', 'horse', 'flawless', 'fresh', 'inquisitive', 'illegal', 'omniscient', 'simplistic', 'selfish',\n      'clean', 'hospital', 'encouraging', 'incompetent', 'right', 'learn', 'relation', 'spoil', 'amused', 'ruthless', 'squalid',\n      'aftermath', 'increase', 'greasy', 'futuristic', 'shut', 'friendly', 'steep', 'range', 'faint', 'jail', 'wide-eyed', 'uptight',\n      'erratic', 'eyes', 'cure', 'overwrought', 'muddle', 'bedroom', 'scale', 'rub', 'conscious', 'snake', 'box', 'command', 'slippery',\n      'handsome', 'spy', 'tongue', 'unbecoming', 'magnificent', 'gold', 'resolute', 'face', 'childlike', 'approval', 'meaty', 'frog',\n      'abrasive', 'rat', 'peel', 'office', 'panoramic', 'explode', 'selective', 'ahead', 'thaw', 'mean', 'odd', 'hate', 'window', 'somber',\n      'guard', 'riddle', 'judge', 'flock', 'black', 'amusement', 'bikes', 'milk', 'sock', 'historical', 'tawdry', 'bare', 'mitten', 'harsh',\n      'street', 'unequal', 'five', 'zinc', 'faulty', 'messy', 'thoughtful', 'spicy', 'oval', 'telephone', 'decisive', 'teeny', 'fix',\n      'outstanding', 'excuse', 'abject', 'print', 'receive', 'jump', 'knock', 'ubiquitous', 'anxious', 'fill', 'shrug', 'ossified',\n      'penitent', 'dry', 'abaft', 'uncle', 'voiceless', 'spray', 'town', 'aspiring', 'testy', 'bed', 'likeable', 'breezy', 'jumpy', 'talk',\n      'powerful', 'various', 'crawl', 'lacking', 'lethal', 'baby', 'sore', 'mourn', 'behave', 'pass', 'mark', 'summer', 'cause',\n      'destruction', 'stale', 'basin', 'embarrass', 'rob', 'income', 'overjoyed', 'aback', 'spark', 'air', 'worthless', 'hospitable',\n      'dynamic', 'push', 'nervous', 'dark', 'chin', 'shock', 'frame', 'dojo');\n\nfunction GetRndFirstName: String;\nfunction GetRndLastName: String;\nfunction GetRndFullName: String;\nfunction GetRndCountry: String;\nfunction GetRndEMailAddress: String;\nfunction GetRndDate(const InitialYear: Word = 1980; YearsSpan: Word = 40): TDate;\nfunction GetRndInteger(const aFrom: Integer = 0; aTo: Integer = 1000): Integer;\nfunction GetRndWord: String;\nfunction GetRndPhrase(const aFrom: Integer = 0; aTo: Integer = 1000): String;\n\n{$IF Defined(GENERATE_DATASETS)}\nfunction GetPeople(const Count: Integer = 20): TDataSet;\nfunction GetUsers(const Count: Integer = 10): TDataSet;\nfunction GetPosts(const Count: Integer = 10): TDataSet;\n{$ENDIF}\n\nimplementation\n\n\nuses\n  System.SysUtils, System.DateUtils, System.Math;\n\nconst\n  OneDay = OneHour * 24;\n\nfunction GetRndDate(const InitialYear: Word; YearsSpan: Word): TDate;\nbegin\n  Result := EncodeDate(InitialYear + Random(YearsSpan),1,1) + (OneDay * Random(365));\nend;\n\nfunction GetRndEMailAddress: String;\nbegin\n  Result := GetRndFirstName.Substring(0, RandomRange(1,3)) + '.' +\n    GetRndLastName + '@' + GetRndCountry + GetRndInteger(1,3).ToString + '.com';\n  Result := Result.Replace(' ', '_', [rfReplaceAll]);\nend;\n\nfunction GetRndCountry: String;\nbegin\n  Result := Countries[Random(High(Countries)+1)];\nend;\n\nfunction GetRndFirstName: String;\nbegin\n  Result := FirstNames[Random(High(FirstNames)+1)];\nend;\n\nfunction GetRndFullName: String;\nbegin\n  Result := GetRndFirstName + ' ' + GetRndLastName;\nend;\n\nfunction GetRndLastName: String;\nbegin\n  Result := LastNames[Random(High(LastNames)+1)];\nend;\n\nfunction GetRndWord: String;\nbegin\n  Result := WORDS[RandomRange(0, Length(WORDS))];\nend;\n\nfunction GetRndPhrase(const aFrom: Integer = 0; aTo: Integer = 1000): String;\nvar\n  WordCount: Integer;\n  I: Integer;\nbegin\n  Result := '';\n  WordCount := RandomRange(aFrom, aTo);\n  for I := 1 to WordCount do\n  begin\n    Result := Result + GetRndWord + ' ';\n  end;\n  Result := Result.Trim;\n  Result := UpCase(Result.Chars[0]) + Result.Substring(1) + '.';\nend;\n\nfunction GetRndInteger(const aFrom: Integer; aTo: Integer): Integer;\nbegin\n  if aFrom >= aTo then\n  begin\n    raise Exception.Create('FROM cannot be greater nor equal to TO');\n  end;\n  Result := RandomRange(aFrom, aTo);\nend;\n\n\n{$IF Defined(GENERATE_DATASETS)}\nfunction GetPeople(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('code', ftInteger);\n    lMT.FieldDefs.Add('first_name', ftString, 20);\n    lMT.FieldDefs.Add('last_name', ftString, 20);\n    lMT.FieldDefs.Add('country', ftString, 20);\n    lMT.FieldDefs.Add('dob', ftDate);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([I, GetRndFirstName, GetRndLastName, GetRndCountry, GetRndDate]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction GetUsers(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('first_name', ftString, 100);\n    lMT.FieldDefs.Add('last_name', ftString, 100);\n    lMT.FieldDefs.Add('email', ftString, 100);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([GetRndFirstName, GetRndLastName, GetRndEMailAddress]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction GetPosts(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('title', ftString, 100);\n    lMT.FieldDefs.Add('abstract', ftString, 400);\n    lMT.FieldDefs.Add('word_count', ftInteger);\n    lMT.FieldDefs.Add('comments', ftInteger);\n    lMT.FieldDefs.Add('post_date', ftDate);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([\n        GetRndPhrase(3, 8),\n        GetRndPhrase(30, 50),\n        GetRndInteger(20, 5000),\n        GetRndInteger(0,20),\n        GetRndDate(2020, 4)\n        ]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\n\n{$ENDIF}\n\ninitialization\n\nRandomize;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nnamespace RandomUtilsU\n{\n    public static class RandomUtils\n    {\n        private static readonly Random _random = new Random();\n\n        public static readonly string[] FirstNames = new string[]\n        {\n            \"Daniele\", \"Debora\", \"Mattia\", \"Jack\", \"James\", \"William\", \"Joseph\", \"David\", \"Charles\", \"Thomas\",\n            \"Ethan\", \"Liam\", \"Noah\", \"Logan\", \"Lucas\", \"Mason\", \"Benjamin\", \"Alexander\", \"Elijah\", \"Jordan\",\n            \"Alexander\", \"Jamie\", \"Tyler\", \"Caleb\", \"Kieran\", \"Ryan\", \"Colton\", \"Jaxon\", \"Gavin\", \"Ryder\"\n        };\n\n        public static readonly string[] LastNames = new string[]\n        {\n            \"Smith\", \"Johnson\", \"Williams\", \"Brown\", \"Black\", \"Red\", \"Green\", \"Willis\", \"Jones\", \"Miller\",\n            \"Davis\", \"Wilson\", \"Martinez\", \"Anderson\"\n        };\n\n        public static readonly string[] Countries = new string[]\n        {\n            \"italy\", \"new york\", \"illinois\", \"arizona\", \"nevada\", \"uk\", \"france\", \"georgia\", \"spain\", \"portugal\",\n            \"germany\", \"norway\", \"california\", \"usa\", \"japan\", \"australia\", \"singapore\", \"hong kong\", \"taiwan\",\n            \"south africa\", \"canada\", \"switzerland\", \"sweden\", \"netherlands\", \"belgium\"\n        };\n\n        public const string LOREM_IPSUM =\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" +\n            \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\" +\n            \"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\" +\n            \"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n\n        public static readonly string[] WORDS = new string[]\n        {\n            \"bite\", \"mate\", \"quill\", \"back\", \"church\", \"pear\", \"knit\", \"bent\", \"wrench\", \"crack\", \"heavenly\",\n            \"deceive\", \"maddening\", \"plain\", \"writer\", \"rapid\", \"acidic\", \"decide\", \"hat\", \"paint\", \"cow\",\n            \"dysfunctional\", \"pet\", \"giraffe\", \"connection\", \"sour\", \"voracious\", \"cloudy\", \"wry\", \"curve\",\n            \"agree\", \"eggnog\", \"flaky\", \"painstaking\", \"warm\", \"silk\", \"icy\", \"hellish\", \"toy\", \"milky\",\n            \"skirt\", \"test\", \"daffy\", \"questionable\", \"gamy\", \"aware\", \"berry\", \"throne\", \"oven\", \"subtract\",\n            \"cool\", \"care\", \"charge\", \"smash\", \"curve\", \"comfortable\", \"narrow\", \"merciful\", \"material\", \"fear\",\n            \"exercise\", \"skinny\", \"fire\", \"rainstorm\", \"tail\", \"nondescript\", \"calculating\", \"pack\", \"steel\",\n            \"marvelous\", \"baseball\", \"furtive\", \"stitch\", \"abiding\", \"empty\", \"bushes\", \"painful\", \"tense\",\n            \"verse\", \"unwritten\", \"reproduce\", \"receptive\", \"bottle\", \"silky\", \"alleged\", \"stingy\", \"irritate\",\n            \"expand\", \"cap\", \"unsuitable\", \"gigantic\", \"exist\", \"damp\", \"scrub\", \"disgusted\", \"sun\", \"ink\",\n            \"detailed\", \"defeated\", \"economic\", \"chunky\", \"stop\", \"overflow\", \"numerous\", \"joyous\", \"wipe\",\n            \"drink\", \"error\", \"branch\", \"male\", \"proud\", \"soggy\", \"ship\", \"excite\", \"industry\", \"wistful\",\n            \"man\", \"vacation\", \"doctor\", \"naughty\", \"plane\", \"ignore\", \"open\", \"act\", \"earthquake\", \"inconclusive\",\n            \"reflect\", \"force\", \"funny\", \"wonder\", \"magenta\", \"near\", \"dam\", \"windy\", \"maid\", \"wacky\", \"release\",\n            \"birthday\", \"statement\", \"psychotic\", \"quicksand\", \"things\", \"planes\", \"boundary\", \"nod\", \"touch\",\n            \"argue\", \"sin\", \"train\", \"adhoc\", \"needle\", \"regret\", \"stroke\", \"strengthen\", \"bruise\", \"mine\",\n            \"rod\", \"tax\", \"twig\", \"advise\", \"stamp\", \"rhyme\", \"obnoxious\", \"few\", \"inform\", \"fixed\"\n        };\n\n        public static string GetRndFirstName()\n        {\n            return FirstNames[_random.Next(FirstNames.Length)];\n        }\n\n        public static string GetRndLastName()\n        {\n            return LastNames[_random.Next(LastNames.Length)];\n        }\n\n        public static string GetRndFullName()\n        {\n            return GetRndFirstName() + \" \" + GetRndLastName();\n        }\n\n        public static string GetRndCountry()\n        {\n            return Countries[_random.Next(Countries.Length)];\n        }\n\n        public static string GetRndEMailAddress()\n        {\n            string first = GetRndFirstName();\n            int len = Math.Min(first.Length, _random.Next(1, 3));\n            first = first.Substring(0, len);\n            string last = GetRndLastName();\n            string domain = GetRndCountry() + _random.Next(1, 4).ToString() + \".com\";\n            return (first + \".\" + last + \"@\" + domain).Replace(\" \", \"_\");\n        }\n\n        public static DateTime GetRndDate(ushort initialYear = 1980, ushort yearsSpan = 40)\n        {\n            int year = initialYear + _random.Next(yearsSpan);\n            int dayOfYear = _random.Next(1, 366);\n            return new DateTime(year, 1, 1).AddDays(dayOfYear - 1);\n        }\n\n        public static int GetRndInteger(int aFrom = 0, int aTo = 1000)\n        {\n            if (aFrom >= aTo)\n            {\n                throw new Exception(\"FROM cannot be greater nor equal to TO\");\n            }\n            return _random.Next(aFrom, aTo);\n        }\n\n        public static string GetRndWord()\n        {\n            return WORDS[_random.Next(WORDS.Length)];\n        }\n\n        public static string GetRndPhrase(int aFrom = 0, int aTo = 1000)\n        {\n            int wordCount = _random.Next(aFrom, aTo);\n            var words = new List<string>();\n            for (int i = 0; i < wordCount; i++)\n            {\n                words.Add(GetRndWord());\n            }\n            string phrase = string.Join(\" \", words).Trim();\n            if (phrase.Length > 0)\n            {\n                phrase = char.ToUpper(phrase[0]) + phrase.Substring(1) + \".\";\n            }\n            return phrase;\n        }\n\n#if GENERATE_DATASETS\n        public static DataTable GetPeople(int count = 20)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"code\", typeof(int));\n            dt.Columns.Add(\"first_name\", typeof(string));\n            dt.Columns.Add(\"last_name\", typeof(string));\n            dt.Columns.Add(\"country\", typeof(string));\n            dt.Columns.Add(\"dob\", typeof(DateTime));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(i, GetRndFirstName(), GetRndLastName(), GetRndCountry(), GetRndDate());\n            }\n            return dt;\n        }\n\n        public static DataTable GetUsers(int count = 10)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"first_name\", typeof(string));\n            dt.Columns.Add(\"last_name\", typeof(string));\n            dt.Columns.Add(\"email\", typeof(string));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(GetRndFirstName(), GetRndLastName(), GetRndEMailAddress());\n            }\n            return dt;\n        }\n\n        public static DataTable GetPosts(int count = 10)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"title\", typeof(string));\n            dt.Columns.Add(\"abstract\", typeof(string));\n            dt.Columns.Add(\"word_count\", typeof(int));\n            dt.Columns.Add(\"comments\", typeof(int));\n            dt.Columns.Add(\"post_date\", typeof(DateTime));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(\n                    GetRndPhrase(3, 8),\n                    GetRndPhrase(30, 50),\n                    GetRndInteger(20, 5000),\n                    GetRndInteger(0, 20),\n                    GetRndDate(2020, 4)\n                );\n            }\n            return dt;\n        }\n#endif\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ActiveRecord;\n\n{$I dmvcframework.inc}\n\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Generics.Defaults,\n  System.Generics.Collections,\n  System.RTTI,\n  FireDAC.DApt,\n  Data.DB,\n  FireDAC.Comp.Client,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Stan.Param,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.RQL.Parser,\n  MVCFramework.Cache,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  System.SyncObjs,\n  System.TypInfo;\n\ntype\n  EMVCActiveRecord = class(EMVCException)\n  public\n    constructor Create(const AMsg: string); reintroduce; { do not override!! }\n  end;\n\n  EMVCActiveRecordNotFound = class(EMVCActiveRecord)\n  public\n    procedure AfterConstruction; override;\n  end;\n\n  EMVCActiveRecordValidationError = class(EMVCActiveRecord)\n  private\n    fPropertyName: String;\n  public\n    procedure AfterConstruction; override;\n    constructor Create(const PropertyName: String; const ValidationError: string);\n    property PropertyName: String read fPropertyName;\n  end;\n\n  EMVCActiveRecordVersionedItemNotFound = class(EMVCActiveRecordNotFound)\n  end;\n\n  EMVCActiveRecordTransactionContext = class(EMVCActiveRecord)\n  end;\n\n\n  TMVCActiveRecordClass = class of TMVCActiveRecord;\n  TMVCActiveRecord = class;\n\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\n  TMVCTransactionContext = record\n  private\n    fConnection: TFDConnection;\n  public\n    class operator Finalize(var Dest: TMVCTransactionContext);\n    class operator Assign (var Dest: TMVCTransactionContext; const [ref] Src: TMVCTransactionContext);\n    constructor Create(Dummy: Integer); overload;\n  end;\n{$ENDIF}\n\n  TMVCActiveRecordFieldOption = (\n    /// <summary>\n    /// It's the primary key of the mapped table }\n    /// </summary>\n    foPrimaryKey,\n    /// <summary>\n    /// Not written, read - similar to readonly - is updated after insert and update\n    /// </summary>\n    foAutoGenerated,\n    /// <summary>\n    /// shortcut for --> Insertable := False; Updatable := False; Selectable := True;\n    /// </summary>\n    foReadOnly,\n    /// <summary>\n    /// used for versioning, only one field with foVersion is allowed in class\n    /// </summary>\n    foVersion,\n    /// <summary>\n    /// not included in SQL SELECT commands\n    /// </summary>\n    foDoNotSelect,\n    /// <summary>\n    /// not included in SQL INSERT commands\n    /// </summary>\n    foDoNotInsert,\n    /// <summary>\n    /// not included in SQL UPDATE commands\n    /// </summary>\n    foDoNotUpdate\n  );\n\n\n\n\n  TMVCActiveRecordFieldOptions = set of TMVCActiveRecordFieldOption;\n  TMVCEntityAction = (eaCreate, eaRetrieve, eaUpdate, eaDelete);\n  TMVCEntityActions = set of TMVCEntityAction;\n  TMVCActiveRecordLoadOption = (loIgnoreNotExistentFields);\n  TMVCActiveRecordLoadOptions = set of TMVCActiveRecordLoadOption;\n\n  TPartitionFieldNames = class(TList<String>)\n  end;\n\n  TPartitionFieldValues = class(TList<String>)\n  end;\n\n  TPartitionFieldTypes = class(TList<TFieldType>)\n  end;\n\n  IMVCEntityProcessor = interface\n    ['{E7CD11E6-9FF9-46D2-B7B0-DA5B38EAA14E}']\n    procedure GetEntities(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n    procedure CreateEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n  end;\n\n  TFieldInfo = class\n  public\n    FieldName: string;\n    FieldOptions: TMVCActiveRecordFieldOptions;\n    DataTypeName: string;\n    Selectable, Insertable, Updatable, IsVersion: Boolean;\n    procedure EndUpdates;\n  end;\n\n  TSQLQueryWithName = record\n    Name: String;\n    SQLText: String;\n    BackEnd: String; //TMVCActiveRecordBackEnd\n  end;\n\n  TRQLQueryWithName = record\n    Name: String;\n    RQLText: String;\n  end;\n\n\n  TFieldsMap = class(TObjectDictionary<TRTTIField, TFieldInfo>)\n  private\n    fWritableFieldsCount: Integer;\n    fReadableFieldsCount: Integer;\n  public\n    constructor Create;\n    procedure EndUpdates;\n    property WritableFieldsCount: Integer read fWritableFieldsCount;\n    property ReadableFieldsCount: Integer read fReadableFieldsCount;\n    function GetInfoByFieldName(const FieldName: string): TFieldInfo;\n  end;\n\n  MVCActiveRecordCustomAttribute = class(TCustomAttribute)\n\n  end;\n\n  MVCTableAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    RQLFilter: string;\n    constructor Create(aName: string); overload;\n    constructor Create(aName: string; aRQLFilter: String); overload;\n  end;\n\n  MVCPartitionAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    PartitionClause: String;\n    constructor Create(const PartitionClause: String);\n  end;\n\n  MVCNamedSQLQueryAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    SQLQuery: String;\n    Backend: String; //TMVCActiveRecordBackEnd\n    constructor Create(aName: string; aSQLSelect: String); overload;\n    constructor Create(aName: string; aSQLSelect: String; aBackEnd: String); overload;\n  end;\n\n  MVCNamedRQLQueryAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    RQLQuery: String;\n    constructor Create(aName: string; aRQL: String);\n  end;\n\n  MVCTableFieldAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    FieldName: string;\n    FieldOptions: TMVCActiveRecordFieldOptions;\n    SequenceName, DataTypeName: string;\n    constructor Create(const aFieldName: string; const aFieldOptions: TMVCActiveRecordFieldOptions;\n      const aSequenceName: string = ''; const aDataTypeName: string = ''); overload;\n    constructor Create(aFieldName: string; const aDataTypeName: string = ''); overload;\n  end;\n\n  MVCPrimaryKeyAttribute = MVCTableFieldAttribute deprecated '(ERROR) Use MVCTableFieldAttribute';\n\n  MVCEntityActionsAttribute = class(MVCActiveRecordCustomAttribute)\n  private\n    EntityAllowedActions: TMVCEntityActions;\n  public\n    constructor Create(const aEntityAllowedActions: TMVCEntityActions);\n\n  end;\n\n  TMVCSQLGenerator = class;\n\n  TPartitionInfo = class\n  private\n    class\n      var PartitionInfoCache: TMVCThreadedObjectCache<TPartitionInfo>;\n  private\n    fRQLFilter: String;\n    fSQLFilter: String;\n    fFieldValues: TPartitionFieldValues;\n    fFieldTypes: TPartitionFieldTypes;\n    fFieldNames: TPartitionFieldNames;\n  public\n    property FieldNames: TPartitionFieldNames read fFieldNames;\n    property FieldValues: TPartitionFieldValues read fFieldValues;\n    property FieldTypes: TPartitionFieldTypes read fFieldTypes;\n    property RQLFilter: String read fRQLFilter;\n    property SQLFilter: String read fSQLFilter;\n    constructor Create;\n    destructor Destroy; override;\n    class constructor Create;\n    class destructor Destroy;\n    procedure InitializeFilterStrings(const RQLCompiler: TRQLCompiler);\n    class function BuildPartitionClause(const PartitionClause: String; const RQLCompilerClass: TRQLCompilerClass): TPartitionInfo;\n  end;\n\n  TMVCActiveRecordList = class(TObjectList<TMVCActiveRecord>)\n  public\n    constructor Create; virtual;\n  end;\n\n  TMVCTableMap = class\n  private\n    fVersionRTTIField: TRttiField;\n    fVersionFieldName: String;\n  public\n    fPartitionInfoInternal: TPartitionInfo;\n    fEntityAllowedActions: TMVCEntityActions;\n    fTableName: String;\n    fIsVersioned: Boolean;\n    fPartitionClause: String;\n    fRTTIType: TRttiInstanceType;\n    fObjAttributes: TArray<TCustomAttribute>;\n    fDefaultRQLFilter: string;\n    fMap: TFieldsMap;\n    fPrimaryKey: TRTTIField;\n    fPrimaryKeyInInsert: Boolean;\n    fMapping: TMVCFieldsMapping;\n    fPropsAttributes: TArray<TCustomAttribute>;\n    fProps: TArray<TRTTIField>;\n    fPrimaryKeyFieldName: string;\n    fPrimaryKeyOptions: TMVCActiveRecordFieldOptions;\n    fPrimaryKeySequenceName: string;\n    fPrimaryKeyFieldType: TFieldType;\n    fNamedSQLQueries: TArray<TSQLQueryWithName>;\n    fNamedRQLQueries: TArray<TRQLQueryWithName>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    function VersionValueAsInt64For(AR: TMVCActiveRecord): Int64; //inline;\n  end;\n\n  TMVCActiveRecord = class\n  private\n    fChildren: TObjectList<TObject>;\n    fConn: TFDConnection;\n    fSQLGenerator: TMVCSQLGenerator;\n    fRQL2SQL: TRQL2SQL;\n    function MapNullableTValueToParam(aValue: TValue; const aParam: TFDParam): Boolean;\n    function GetPrimaryKeyIsAutogenerated: Boolean;\n    procedure SetPrimaryKeyIsAutogenerated(const Value: Boolean);\n    function GetAttributes(const AttrName: string): TValue;\n    procedure SetAttributes(const AttrName: string; const Value: TValue);\n    function GetTableName: string;\n    procedure AdvanceVersioning(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord);\n    procedure SetInitialObjVersion(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord);\n  protected\n    fBackendDriver: string;\n    fTableMap: TMVCTableMap;\n    function GetCustomTableName: String; virtual;\n    function GetPartitionInfo: TPartitionInfo;\n    function GetConnection: TFDConnection;\n    procedure MapTValueToParam(aValue: TValue; const aParam: TFDParam); virtual;\n    procedure InitTableInfo(const aTableName: String);\n    class function\n      CreateQuery(const Unidirectional, DirectExecute: Boolean): TFDQuery;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean): TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const Connection: TFDConnection;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean)\n      : TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const ValueTypes: array of TFieldType;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean)\n      : TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const ValueTypes: array of TFieldType;\n      const Connection: TFDConnection;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean): TDataSet; overload;\n    procedure FillPrimaryKey(const SequenceName: string);\n    function ExecNonQuery(const SQL: string; RefreshAutoGenerated: Boolean = false): Int64;\n      overload;\n    class function GetByPK(aActiveRecord: TMVCActiveRecord; const aValue: string; const aFieldType: TFieldType;\n      const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord; overload;\n\n\n    // load events\n    /// <summary>\n    /// Called everywhere before persist object into database\n    /// </summary>\n    procedure OnValidation(const EntityAction: TMVCEntityAction); virtual;\n\n    /// <summary>\n    /// Called just after load the object state from database\n    /// </summary>\n    procedure OnAfterLoad; virtual;\n\n    /// <summary>\n    /// Called before load the object state from database\n    /// </summary>\n    procedure OnBeforeLoad; virtual;\n\n    /// <summary>\n    /// Called before insert the object state to database\n    /// </summary>\n    procedure OnBeforeInsert; virtual;\n\n    /// <summary>\n    /// Called after insert the object state to database\n    /// </summary>\n    procedure OnAfterInsert; virtual;\n\n    /// <summary>\n    /// Called before update the object state to database\n    /// </summary>\n    procedure OnBeforeUpdate; virtual;\n\n    /// <summary>\n    /// Called after update the object state to database\n    /// </summary>\n    procedure OnAfterUpdate; virtual;\n\n    /// <summary>\n    /// Called before delete object from database\n    /// </summary>\n    procedure OnBeforeDelete; virtual;\n\n    /// <summary>\n    /// Called after delete object from database\n    /// </summary>\n    procedure OnAfterDelete; virtual;\n\n    /// <summary>\n    /// Called before insert or update the object to the database\n    /// </summary>\n    procedure OnBeforeInsertOrUpdate; virtual;\n\n    /// <summary>\n    /// Called before execute sql\n    /// </summary>\n    procedure OnBeforeExecuteSQL(var SQL: string); virtual;\n\n    /// <summary>\n    /// Called after insert or update the object to the database\n    /// </summary>\n    procedure OnAfterInsertOrUpdate; virtual;\n\n    procedure MapObjectToParams(const Params: TFDParams; var Handled: Boolean); virtual;\n    procedure MapDatasetToObject(const DataSet: TDataSet; const Options: TMVCActiveRecordLoadOptions;\n      var Handled: Boolean); virtual;\n\n    function GenerateSelectSQL: string;\n\n    function SQLGenerator: TMVCSQLGenerator;\n    function InternalCount(const RQL: string): Int64;\n    function InternalSelectRQL(const RQL: string; const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    function InternalSelectRQL(const RQL: string; const MaxRecordCount: Integer;\n      const OutList: TMVCActiveRecordList): UInt32; overload;\n  public\n    constructor Create(aLazyLoadConnection: Boolean); overload; // cannot be virtual!\n    constructor Create; overload; virtual;\n    constructor Create(const Connection: TFDConnection); overload; virtual;\n    destructor Destroy; override;\n    procedure EnsureConnection;\n    procedure Assign(ActiveRecord: TMVCActiveRecord); virtual;\n    procedure InvalidateConnection(const ReacquireAfterInvalidate: Boolean = false);\n    function GetBackEnd: string;\n    /// <summary>\n    /// Executes an Insert (pk is null) or an Update (pk is not null)\n    /// </summary>\n    procedure Store;\n    /// <summary>\n    ///   Reload the current instance from database if the primary key is not empty.\n    /// </summary>\n    procedure Refresh; virtual;\n    function CheckAction(const aEntityAction: TMVCEntityAction;\n      const aRaiseException: Boolean = True): Boolean;\n    procedure Insert;\n    function GetMapping: TMVCFieldsMapping;\n    function LoadByPK(const id: Int64): Boolean; overload; virtual;\n    function LoadByPK(const id: string): Boolean; overload; virtual;\n    function LoadByPK(const id: TGuid): Boolean; overload; virtual;\n    function LoadByPK(const id: string; const aFieldType: TFieldType): Boolean; overload; virtual;\n    procedure Update(const RaiseExceptionIfNotFound: Boolean = True);\n    procedure Delete(const RaiseExceptionIfNotFound: Boolean = True);\n    function TableInfo: string;\n    procedure LoadByDataset(const aDataSet: TDataSet;\n      const aOptions: TMVCActiveRecordLoadOptions = []);\n    procedure SetPK(const aValue: TValue);\n    procedure SetPropertyValue(const aProp: TRttiProperty; const aValue: TValue);\n    function GetPK: TValue;\n    function TryGetPKValue(var Value: TValue; out IsNullableType: Boolean): Boolean;\n    function PKIsNullable(out PKValue: TValue): Boolean;\n    function PKIsNull: Boolean;\n    procedure AddChildren(const ChildObject: TObject);\n    procedure RemoveChildren(const ChildObject: TObject);\n    function GetPrimaryKeyFieldType: TFieldType;\n\n    function FindSQLQueryByName(const QueryName: String; out NamedSQLQuery: TSQLQueryWithName): Boolean;\n    function FindRQLQueryByName(const QueryName: String; out NamedRQLQuery: TRQLQueryWithName): Boolean;\n\n    property Attributes[const AttrName: string]: TValue\n      read GetAttributes\n      write SetAttributes;\n\n    [MVCDoNotSerialize]\n    property TableName: string\n      read GetTableName;\n\n    [MVCDoNotSerialize]\n    property PrimaryKeyIsAutogenerated: Boolean\n      read GetPrimaryKeyIsAutogenerated\n      write SetPrimaryKeyIsAutogenerated;\n\n    class function GetScalar(const SQL: string; const Params: array of Variant): Variant;\n    class function CurrentConnection: TFDConnection;\n    class function GetConnectionByName(const ConnectionName: String): TFDConnection;\n  end;\n\n  IMVCUnitOfWork<T: TMVCActiveRecord> = interface\n    ['{68B55DD3-57F6-4CC0-A4DE-BFDE7C3AA287}']\n    procedure RegisterDelete(const Value: T); overload;\n    procedure RegisterDelete(const Enumerable: TEnumerable<T>); overload;\n    procedure RegisterUpdate(const Value: T);\n    procedure RegisterInsert(const Value: T);\n    procedure UnregisterDelete(const Value: T);\n    procedure UnregisterUpdate(const Value: T);\n    procedure UnregisterInsert(const Value: T);\n  end;\n\n  TMVCItemApplyAction<T: TMVCActiveRecord> = reference to procedure(const Obj: T;\n    const EntityAction: TMVCEntityAction; var Handled: Boolean);\n\n  TMergeModeItem = (mmInsert, mmUpdate, mmDelete);\n  TMergeMode = set of TMergeModeItem;\n\n  IMVCMultiExecutor<T: TMVCActiveRecord> = interface\n    ['{C815246B-19CA-4F6C-AA67-8E491F809340}']\n    procedure Apply(const ItemApplyAction: TMVCItemApplyAction<T> = nil);\n  end;\n\n  TMVCActiveRecordHelper = class helper for TMVCActiveRecord\n    { GetByPK }\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: Int64;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: string;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: TGuid;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: string; const aFieldType: TFieldType;\n      const RaiseExceptionIfNotFound: Boolean): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: Int64;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: string;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: TGuid;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n\n    { Select }\n    /// <summary>\n    ///   Returns a TObjectList<TMVCActiveRecord> from a SQL using variant params\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const Options: TMVCActiveRecordLoadOptions = []): TObjectList<T>; overload;\n    /// <summary>\n    ///   Returns a TObjectList<TMVCActiveRecord> from a SQL using typed params\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = [])\n      : TObjectList<T>; overload;\n    /// <summary>\n    ///   Returns a TMVCActiveRecordList from a SQL using typed params and class ref\n    /// </summary>\n    class function Select(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = [])\n      : TMVCActiveRecordList; overload;\n    /// <summary>\n    ///   Fills a TObjectList<TMVCActiveRecord> from a SQL using typed params.\n    ///   Returns number of the records in the list (not only the selected records, but the current .Count of the list)\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions;\n      const OutList: TObjectList<T>): UInt32; overload;\n\n    class function Select(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions;\n      const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant)\n      : TMVCActiveRecordList; overload;\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection): TMVCActiveRecordList; overload;\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection; const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    { SelectOne }\n    class function SelectOne<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType; const Options: TMVCActiveRecordLoadOptions = [];\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function SelectOne<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n\n\n    { SelectRQL }\n    function SelectRQL(const RQL: string; const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    class function SelectRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const MaxRecordCount: Integer)\n      : TObjectList<T>; overload;\n    class function SelectRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const MaxRecordCount: Integer; const OutList: TObjectList<T>): UInt32; overload;\n    class function SelectOneByRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function SelectRQL(const aClass: TMVCActiveRecordClass; const RQL: string;\n      const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    class function SelectRQL(const aClass: TMVCActiveRecordClass; const RQL: string;\n      const MaxRecordCount: Integer; const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    { Misc }\n    class function All<T: TMVCActiveRecord, constructor>: TObjectList<T>; overload;\n    class function DeleteRQL<T: TMVCActiveRecord>(const RQL: string = ''): Int64; overload;\n    class function Count<T: TMVCActiveRecord>(const RQL: string = ''): Int64; overload;\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\n    class function UseTransactionContext: TMVCTransactionContext;\n{$ENDIF}\n\n    { Where }\n    class function Where<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant)\n      : TObjectList<T>; overload;\n    /// <summary>\n    ///   Executes a SQL select using the SQLWhere parameter as where clause. This method is partitioning safe.\n    ///   Returns TObjectList<EntityType>.\n    /// </summary>\n    class function Where<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType): TObjectList<T>; overload;\n    class fun", "output": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Data.Common;\nusing System.Reflection;\nusing System.Threading;\n\nnamespace MVCFramework.ActiveRecord\n{\n    #region Exceptions\n\n    public class MVCActiveRecordException : Exception\n    {\n        public int HttpStatusCode { get; protected set; }\n\n        public MVCActiveRecordException(string message)\n            : base(message)\n        {\n            HttpStatusCode = 400;\n        }\n\n        public MVCActiveRecordException(string message, Exception innerException)\n            : base(message, innerException)\n        {\n            HttpStatusCode = 400;\n        }\n    }\n\n    public class MVCActiveRecordNotFoundException : MVCActiveRecordException\n    {\n        public MVCActiveRecordNotFoundException(string message)\n            : base(message)\n        {\n            HttpStatusCode = 404;\n        }\n    }\n\n    public class MVCActiveRecordValidationErrorException : MVCActiveRecordException\n    {\n        public string PropertyName { get; private set; }\n\n        public MVCActiveRecordValidationErrorException(string propertyName, string validationError)\n            : base(validationError)\n        {\n            PropertyName = propertyName;\n            HttpStatusCode = 400;\n        }\n    }\n\n    public class MVCActiveRecordTransactionContextException : MVCActiveRecordException\n    {\n        public MVCActiveRecordTransactionContextException(string message)\n            : base(message)\n        { }\n    }\n\n    #endregion\n\n    #region Enumerations and Attributes\n\n    [Flags]\n    public enum MVCActiveRecordFieldOption\n    {\n        None = 0,\n        PrimaryKey = 1,\n        AutoGenerated = 2,\n        ReadOnly = 4,\n        Version = 8,\n        DoNotSelect = 16,\n        DoNotInsert = 32,\n        DoNotUpdate = 64\n    }\n\n    [Flags]\n    public enum MVCEntityAction\n    {\n        Create = 1,\n        Retrieve = 2,\n        Update = 4,\n        Delete = 8\n    }\n\n    [Flags]\n    public enum MVCActiveRecordLoadOption\n    {\n        None = 0,\n        IgnoreNotExistentFields = 1\n    }\n\n    \n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCTableAttribute : Attribute\n    {\n        public string Name { get; }\n        public string RQLFilter { get; }\n\n        public MVCTableAttribute(string name) : this(name, string.Empty) { }\n\n        public MVCTableAttribute(string name, string rqlFilter)\n        {\n            Name = name;\n            RQLFilter = rqlFilter;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCPartitionAttribute : Attribute\n    {\n        public string PartitionClause { get; }\n        public MVCPartitionAttribute(string partitionClause)\n        {\n            PartitionClause = partitionClause;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\n    public class MVCTableFieldAttribute : Attribute\n    {\n        public string FieldName { get; }\n        public MVCActiveRecordFieldOption FieldOptions { get; }\n        public string SequenceName { get; }\n        public string DataTypeName { get; }\n\n        public MVCTableFieldAttribute(string fieldName, MVCActiveRecordFieldOption fieldOptions, string sequenceName = \"\", string dataTypeName = \"\")\n        {\n            FieldName = fieldName;\n            FieldOptions = fieldOptions;\n            SequenceName = sequenceName;\n            DataTypeName = dataTypeName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCNamedSQLQueryAttribute : Attribute\n    {\n        public string Name { get; }\n        public string SQLQuery { get; }\n        public string Backend { get; }\n\n        public MVCNamedSQLQueryAttribute(string name, string sqlQuery)\n            : this(name, sqlQuery, string.Empty)\n        { }\n\n        public MVCNamedSQLQueryAttribute(string name, string sqlQuery, string backend)\n        {\n            Name = name;\n            SQLQuery = sqlQuery;\n            Backend = backend;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCNamedRQLQueryAttribute : Attribute\n    {\n        public string Name { get; }\n        public string RQLQuery { get; }\n        public MVCNamedRQLQueryAttribute(string name, string rqlQuery)\n        {\n            Name = name;\n            RQLQuery = rqlQuery;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCEntityActionsAttribute : Attribute\n    {\n        public MVCEntityAction EntityAllowedActions { get; }\n        public MVCEntityActionsAttribute(MVCEntityAction entityAllowedActions)\n        {\n            EntityAllowedActions = entityAllowedActions;\n        }\n    }\n\n    #endregion\n\n    #region Field Mapping Classes\n\n\n    public class FieldInfo\n    {\n        public string FieldName { get; set; }\n        public MVCActiveRecordFieldOption FieldOptions { get; set; }\n        public string DataTypeName { get; set; }\n        public bool Selectable { get; set; }\n        public bool Insertable { get; set; }\n        public bool Updatable { get; set; }\n        public bool IsVersion { get; set; }\n\n        public void EndUpdates()\n        {\n            \n            if (string.IsNullOrWhiteSpace(FieldName))\n            {\n                Selectable = false;\n                Insertable = false;\n                Updatable = false;\n            }\n            else\n            {\n                Selectable = !FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotSelect);\n                Insertable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotInsert) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));\n                Updatable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotUpdate) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));\n\n                if (FieldOptions.HasFlag(MVCActiveRecordFieldOption.ReadOnly))\n                {\n                    Insertable = false;\n                    Updatable = false;\n                    Selectable = true;\n                }\n            }\n        }\n    }\n\n    \n    public class FieldsMap : Dictionary<MemberInfo, FieldInfo>\n    {\n        public int WritableFieldsCount { get; private set; }\n        public int ReadableFieldsCount { get; private set; }\n\n        public FieldsMap() : base(new MemberInfoComparer())\n        {\n            WritableFieldsCount = -1;\n            ReadableFieldsCount = -1;\n        }\n\n        public void EndUpdates()\n        {\n            WritableFieldsCount = 0;\n            ReadableFieldsCount = 0;\n            foreach (var pair in this)\n            {\n                pair.Value.EndUpdates();\n                if (pair.Value.Insertable || pair.Value.Updatable)\n                    WritableFieldsCount++;\n                if (pair.Value.Selectable)\n                    ReadableFieldsCount++;\n            }\n        }\n\n        public FieldInfo GetInfoByFieldName(string fieldName)\n        {\n            foreach (var pair in this)\n            {\n                if (string.Equals(pair.Value.FieldName, fieldName, StringComparison.OrdinalIgnoreCase))\n                    return pair.Value;\n            }\n            throw new MVCActiveRecordException($\"FieldName [{fieldName}] not found in table mapping.\");\n        }\n    }\n\n    \n    public class MemberInfoComparer : IEqualityComparer<MemberInfo>\n    {\n        public bool Equals(MemberInfo x, MemberInfo y)\n        {\n            return x.Name.Equals(y.Name, StringComparison.OrdinalIgnoreCase);\n        }\n\n        public int GetHashCode(MemberInfo obj)\n        {\n            return obj.Name.ToLowerInvariant().GetHashCode();\n        }\n    }\n\n    #endregion\n\n    #region Base ActiveRecord Classes\n\n    \n    public abstract class MVCActiveRecord\n    {\n        \n        protected DbConnection Connection { get; private set; }\n\n        protected FieldsMap FieldMapping { get; set; }\n\n        public virtual string TableName { get; protected set; }\n\n        public virtual string PrimaryKeyName { get; protected set; }\n\n        public virtual bool PrimaryKeyIsAutogenerated { get; set; }\n\n        protected abstract MVCSQLGenerator CreateSQLGenerator();\n\n        protected MVCSQLGenerator SQLGenerator { get; private set; }\n\n        protected MVCActiveRecord()\n        {\n            Connection = MVCActiveRecordConnectionRegistry.CurrentConnection;\n            InitializeMapping();\n            SQLGenerator = CreateSQLGenerator();\n        }\n\n        protected virtual void InitializeMapping()\n        {\n            var type = this.GetType();\n            var tableAttr = type.GetCustomAttribute<MVCTableAttribute>();\n            if (tableAttr != null)\n            {\n                TableName = tableAttr.Name;\n            }\n            else\n            {\n                TableName = type.Name;\n            }\n            FieldMapping = new FieldsMap();\n        }\n\n        \n        public virtual void OnValidation(MVCEntityAction action)\n        {\n            // Do nothing by default.\n        }\n\n        \n        public void Store()\n        {\n            if (IsPrimaryKeyNull())\n            {\n                Insert();\n            }\n            else\n            {\n                Update();\n            }\n        }\n\n        \n        public virtual void Insert()\n        {\n            OnValidation(MVCEntityAction.Create);\n            if (!PrimaryKeyIsAutogenerated)\n            {\n                // \u2026 code to fill primary key from sequence, if needed.\n            }\n            string sql = SQLGenerator.CreateInsertSQL(TableName, FieldMapping, this);\n            ExecuteNonQuery(sql);\n            \n            OnAfterInsert();\n        }\n\n        \n        public virtual void Update()\n        {\n            OnValidation(MVCEntityAction.Update);\n            string sql = SQLGenerator.CreateUpdateSQL(TableName, FieldMapping, this);\n            int affected = ExecuteNonQuery(sql);\n            if (affected == 0)\n            {\n                throw new MVCActiveRecordNotFoundException($\"No record updated for primary key [{PrimaryKeyName}] in table [{TableName}].\");\n            }\n            OnAfterUpdate();\n        }\n\n        \n        public virtual void Delete()\n        {\n            OnValidation(MVCEntityAction.Delete);\n            string sql = SQLGenerator.CreateDeleteSQL(TableName, PrimaryKeyName, this);\n            int affected = ExecuteNonQuery(sql);\n            if (affected == 0)\n            {\n                throw new MVCActiveRecordNotFoundException($\"No record deleted for primary key [{PrimaryKeyName}] in table [{TableName}].\");\n            }\n            OnAfterDelete();\n        }\n\n        \n        public virtual void Refresh()\n        {\n            if (IsPrimaryKeyNull())\n            {\n                throw new MVCActiveRecordException(\"Cannot refresh an object with an empty primary key.\");\n            }\n            string sql = SQLGenerator.CreateSelectByPKSQL(TableName, FieldMapping, PrimaryKeyName);\n            DataSet ds = ExecuteQuery(sql, new object[] { GetPrimaryKeyValue() });\n            if (ds.Tables[0].Rows.Count == 0)\n            {\n                throw new MVCActiveRecordNotFoundException(\"Record not found.\");\n            }\n            MapDataRowToObject(ds.Tables[0].Rows[0]);\n        }\n\n        \n        protected virtual int ExecuteNonQuery(string sql)\n        {\n            \n            Console.WriteLine(\"ExecuteNonQuery: \" + sql);\n            return 1;\n        }\n\n        protected virtual DataSet ExecuteQuery(string sql, object[] parameters)\n        {\n            \n            Console.WriteLine(\"ExecuteQuery: \" + sql);\n            return new DataSet();\n        }\n\n        \n        protected virtual void MapDataRowToObject(DataRow row)\n        {\n            // Use reflection or a mapping framework to assign values from row to properties.\n        }\n\n        \n        public virtual object GetPrimaryKeyValue()\n        {\n            \n            return null;\n        }\n\n        \n        public virtual bool IsPrimaryKeyNull()\n        {\n            var pk = GetPrimaryKeyValue();\n            return pk == null || string.IsNullOrEmpty(pk.ToString());\n        }\n\n        \n        protected virtual void OnAfterInsert() { }\n        protected virtual void OnAfterUpdate() { }\n        protected virtual void OnAfterDelete() { }\n\n        \n    }\n\n    #endregion\n\n    #region SQL Generator (Skeleton)\n\n    \n    public abstract class MVCSQLGenerator\n    {\n        protected FieldsMap Mapping { get; }\n        protected string DefaultRQLFilter { get; }\n        \n\n        public MVCSQLGenerator(FieldsMap mapping, string defaultRQLFilter)\n        {\n            Mapping = mapping;\n            DefaultRQLFilter = defaultRQLFilter;\n        }\n\n        public abstract string CreateInsertSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);\n        public abstract string CreateUpdateSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);\n        public abstract string CreateDeleteSQL(string tableName, string primaryKeyName, MVCActiveRecord ar);\n        public abstract string CreateSelectByPKSQL(string tableName, FieldsMap mapping, string primaryKeyName);\n    }\n\n    \n    public class MVCSQLGeneratorRegistry\n    {\n        private static readonly Dictionary<string, Type> sqlGenerators = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private static readonly object lockObj = new object();\n\n        public static void RegisterSQLGenerator(string backend, Type sqlGeneratorType)\n        {\n            lock (lockObj)\n            {\n                sqlGenerators[backend] = sqlGeneratorType;\n            }\n        }\n\n        public static MVCSQLGenerator GetSQLGenerator(string backend, FieldsMap mapping, string defaultRQLFilter)\n        {\n            lock (lockObj)\n            {\n                if (!sqlGenerators.TryGetValue(backend, out Type generatorType))\n                {\n                    throw new MVCActiveRecordException($\"SQLGenerator not found for backend \\\"{backend}\\\".\");\n                }\n                return (MVCSQLGenerator)Activator.CreateInstance(generatorType, mapping, defaultRQLFilter);\n            }\n        }\n    }\n\n    #endregion\n\n    #region Connection Registry\n\n    \n    public static class MVCActiveRecordConnectionRegistry\n    {\n        \n        public static DbConnection CurrentConnection { get; set; }\n\n        static MVCActiveRecordConnectionRegistry()\n        {\n            \n            // CurrentConnection = new YourDbConnection(...);\n        }\n    }\n\n    #endregion\n\n    #region MVCActiveRecord Helper (Static methods)\n\n    public static class MVCActiveRecordHelper\n    {\n        \n        public static T GetByPK<T>(this T ar, object primaryKey, bool raiseExceptionIfNotFound = true)\n            where T : MVCActiveRecord, new()\n        {\n            T recordInstance = new T();\n            throw new NotImplementedException(\"GetByPK is not implemented\");\n        }\n\n        public static List<T> Select<T>(string sql, object[] parameters) where T : MVCActiveRecord, new()\n        {\n            T instance = new T();\n            throw new NotImplementedException(\"Select is not implemented\");\n        }\n\n        \n    }\n\n    #endregion\n\n    #region Interfaces\n\n    \n    public interface IMVCEntityProcessor\n    {\n        void GetEntities(object context, object renderer, string entityName, ref bool handled);\n        void GetEntity(object context, object renderer, string entityName, int id, ref bool handled);\n        void CreateEntity(object context, object renderer, string entityName, ref bool handled);\n        void UpdateEntity(object context, object renderer, string entityName, int id, ref bool handled);\n        void DeleteEntity(object context, object renderer, string entityName, int id, ref bool handled);\n    }\n\n    #endregion\n\n    #region (Optional) Unit Of Work and MultiExecutor Interfaces\n\n    \n\n    public interface IMVCUnitOfWork<T> where T : MVCActiveRecord\n    {\n        void RegisterInsert(T value);\n        void RegisterUpdate(T value);\n        void RegisterDelete(T value);\n        void UnregisterInsert(T value);\n        void UnregisterUpdate(T value);\n        void UnregisterDelete(T value);\n    }\n\n    public interface IMVCMultiExecutor<T> where T : MVCActiveRecord\n    {\n        void Apply(Action<T, MVCEntityAction, ref bool> itemApplyAction = null);\n    }\n\n    #endregion\n\n    #region (Optional) Table Map and Registry Classes\n\n    \n\n    public class MVCTableMap\n    {\n        public string TableName { get; set; }\n        public string PrimaryKeyFieldName { get; set; }\n        public bool IsVersioned { get; set; }\n        public string VersionFieldName { get; set; }\n        public FieldsMap Map { get; set; }\n        public string DefaultRQLFilter { get; set; }\n\n        public MVCTableMap()\n        {\n            Map = new FieldsMap();\n        }\n\n       \n        public long VersionValueAsInt64For(MVCActiveRecord ar)\n        {\n            \n            return 1;\n        }\n    }\n\n    #endregion\n\n    #region (Optional) Entities Registry and Connections Repository\n\n    \n\n    public interface IMVCEntitiesRegistry\n    {\n        void AddEntity(string urlSegment, Type activeRecordClass);\n        void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor);\n        bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass);\n        bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor);\n        string[] GetEntities();\n        KeyValuePair<string, Type>[] GetURLSegmentWithEntities();\n    }\n\n    public class MVCEntitiesRegistry : IMVCEntitiesRegistry\n    {\n        private readonly Dictionary<string, Type> entitiesDict = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private readonly Dictionary<string, IMVCEntityProcessor> processorsDict = new Dictionary<string, IMVCEntityProcessor>(StringComparer.OrdinalIgnoreCase);\n\n        public void AddEntity(string urlSegment, Type activeRecordClass)\n        {\n            entitiesDict[urlSegment.ToLower()] = activeRecordClass;\n        }\n\n        public void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor)\n        {\n            processorsDict[urlSegment.ToLower()] = entityProcessor;\n        }\n\n        public bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass)\n        {\n            return entitiesDict.TryGetValue(urlSegment.ToLower(), out activeRecordClass);\n        }\n\n        public bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor)\n        {\n            return processorsDict.TryGetValue(urlSegment.ToLower(), out entityProcessor);\n        }\n\n        public string[] GetEntities()\n        {\n            var keys = new List<string>(entitiesDict.Keys);\n            return keys.ToArray();\n        }\n\n        public KeyValuePair<string, Type>[] GetURLSegmentWithEntities()\n        {\n            var list = new List<KeyValuePair<string, Type>>(entitiesDict);\n            return list.ToArray();\n        }\n    }\n\n    #endregion\n\n    \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX }\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti. }\n//\n// The DUnitX project is run by Vincent Parrett and can be found at: }\n//\n// https://github.com/VSoftTechnologies/DUnitX }\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.NewControllerUnit;\n\ninterface\n\nuses\n  ToolsApi,\n  System.IOUtils,\n  DMVC.Expert.CodeGen.NewUnit,\n  JsonDataObjects, DMVC.Expert.CodeGen.Executor;\n\ntype\n  TNewControllerUnitEx = class(TNewUnit)\n  protected\n    function NewImplSource(const ModuleIdent, FormIdent, AncestorIdent: string)\n      : IOTAFile; override;\n  public\n    constructor Create(\n      const ConfigModelRef: TJSONObject;\n      const APersonality: string = ''); reintroduce;\n  end;\n\n  TTemplateLoadProcedure = procedure(Gen: TMVCCodeGenerator);\n\n  TNewGenericUnitFromTemplate = class(TNewUnit)\n  private\n    fTemplateLoadProcedure: TTemplateLoadProcedure;\n    fUnitIdentKeyName: string;\n  protected\n    function NewImplSource(const ModuleIdent, FormIdent, AncestorIdent: string)\n      : IOTAFile; override;\n  public\n    constructor Create(\n      const ConfigModelRef: TJSONObject;\n      const TemplateLoadProcedure: TTemplateLoadProcedure;\n      const UnitIdentKeyName: String;\n      const APersonality: string = '');reintroduce;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  DMVC.Expert.CodeGen.SourceFile,\n  DMVC.Expert.Commands.Templates,\n  DMVC.Expert.Commons;\n\nconstructor TNewControllerUnitEx.Create(\n  const ConfigModelRef: TJSONObject;\n  const APersonality: string = '');\nbegin\n  inherited Create(ConfigModelRef);\n  Personality := APersonality;\nend;\n\nfunction TNewControllerUnitEx.NewImplSource(const ModuleIdent, FormIdent,\n  AncestorIdent: string): IOTAFile;\nvar\n  lUnitIdent: string;\n  lFormName: string;\n  lFileName: string;\nbegin\n  // http://stackoverflow.com/questions/4196412/how-do-you-retrieve-a-new-unit-name-from-delphis-open-tools-api\n  // So using method mentioned by Marco Cantu.\n  (BorlandIDEServices as IOTAModuleServices).GetNewModuleAndClassName('',\n    lUnitIdent, lFormName, lFileName);\n\n\n  fConfigModelRef.S[TConfigKey.controller_unit_name] := lUnitIdent;\n\n  Result := TSourceFile.Create(\n    procedure (Gen: TMVCCodeGenerator)\n    begin\n      FillControllerTemplates(Gen);\n    end,\n    fConfigModelRef);\nend;\n\n{ TNewJSONRPCUnitEx }\n\nconstructor TNewGenericUnitFromTemplate.Create(\n  const ConfigModelRef: TJSONObject;\n  const TemplateLoadProcedure: TTemplateLoadProcedure;\n  const UnitIdentKeyName: String;\n  const APersonality: string);\nbegin\n  inherited Create(ConfigModelRef);\n  fTemplateLoadProcedure := TemplateLoadProcedure;\n  fUnitIdentKeyName := UnitIdentKeyName;\n  Personality := aPersonality;\nend;\n\nfunction TNewGenericUnitFromTemplate.NewImplSource(const ModuleIdent, FormIdent,\n  AncestorIdent: string): IOTAFile;\nvar\n  lUnitIdent: string;\n  lFileName: string;\n  lDummy: String;\nbegin\n  // http://stackoverflow.com/questions/4196412/how-do-you-retrieve-a-new-unit-name-from-delphis-open-tools-api\n  // So using method mentioned by Marco Cantu.\n  lFileName := '';\n  (BorlandIDEServices as IOTAModuleServices).GetNewModuleAndClassName('',\n    lUnitIdent, lDummy, lFileName);\n  fConfigModelRef.S[fUnitIdentKeyName] := lUnitIdent;\n  Result := TSourceFile.Create(\n    procedure (Gen: TMVCCodeGenerator)\n    begin\n      //FillJSONRPCTemplates(Gen);\n      fTemplateLoadProcedure(Gen);\n    end,\n    fConfigModelRef);\nend;\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertCodeGenNewControllerUnit\n{\n    \n    public interface IOTAFile\n    {\n        // Define members as needed.\n    }\n\n    \n    public abstract class TNewUnit\n    {\n        \n        protected JObject fConfigModelRef;\n        \n        public string Personality { get; set; }\n\n        protected TNewUnit(JObject configModelRef)\n        {\n            fConfigModelRef = configModelRef;\n        }\n\n        public abstract IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent);\n    }\n\n    public delegate void TTemplateLoadProcedure(TMVCCodeGenerator gen);\n\n    public class TMVCCodeGenerator\n    {\n        // Implementation details omitted.\n    }\n\n    public class TSourceFile : IOTAFile\n    {\n        public string Source { get; private set; }\n\n        public TSourceFile(Action<TMVCCodeGenerator> fillerProc, JObject configModel)\n        {\n            TMVCCodeGenerator generator = new TMVCCodeGenerator();\n            fillerProc(generator);\n            Source = string.Empty;\n        }\n\n        public static IOTAFile Create(Action<TMVCCodeGenerator> fillerProc, JObject configModel)\n        {\n            return new TSourceFile(fillerProc, configModel);\n        }\n    }\n\n    public static class OTAModuleServices\n    {\n        public static void GetNewModuleAndClassName(string prefix, out string unitIdent, out string formName, out string fileName)\n        {\n            unitIdent = \"NewUnitName\";\n            formName = \"NewFormName\";\n            fileName = \"NewFileName.cs\";\n        }\n    }\n\n     public class TNewControllerUnitEx : TNewUnit\n    {\n        public TNewControllerUnitEx(JObject configModelRef, string aPersonality = \"\")\n            : base(configModelRef)\n        {\n            Personality = aPersonality;\n        }\n\n        public override IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent)\n        {\n            OTAModuleServices.GetNewModuleAndClassName(string.Empty, out string lUnitIdent, out string lFormName, out string lFileName);\n\n            fConfigModelRef[\"controller_unit_name\"] = lUnitIdent;\n\n            return TSourceFile.Create(\n                gen =>\n                {\n                    \n                    Console.WriteLine(\"Filling controller templates...\");\n                },\n                fConfigModelRef);\n        }\n    }\n\n    public class TNewGenericUnitFromTemplate : TNewUnit\n    {\n        private readonly TTemplateLoadProcedure fTemplateLoadProcedure;\n        private readonly string fUnitIdentKeyName;\n\n        public TNewGenericUnitFromTemplate(\n            JObject configModelRef,\n            TTemplateLoadProcedure templateLoadProcedure,\n            string unitIdentKeyName,\n            string aPersonality = \"\")\n            : base(configModelRef)\n        {\n            fTemplateLoadProcedure = templateLoadProcedure;\n            fUnitIdentKeyName = unitIdentKeyName;\n            Personality = aPersonality;\n        }\n\n        public override IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent)\n        {\n            OTAModuleServices.GetNewModuleAndClassName(string.Empty, out string lUnitIdent, out string dummy, out string lFileName);\n            fConfigModelRef[fUnitIdentKeyName] = lUnitIdent;\n\n            return TSourceFile.Create(\n                gen =>\n                {\n                    fTemplateLoadProcedure(gen);\n                },\n                fConfigModelRef);\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Swag.Doc.Definition;\n\ninterface\n\nuses\n  Json.Schema,\n  System.JSON;\n\ntype\n  /// <summary>\n  /// The Schema Object allows the definition of input and output data types.\n  /// These types can be objects, but also primitives and arrays.\n  /// This object is based on the JSON Schema Specification Draft 4 and uses a predefined subset of it.\n  /// On top of this subset, there are extensions provided by this specification to allow for more complete documentation.\n  /// Further information about the properties can be found in JSON Schema Core and JSON Schema Validation.\n  /// Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here.\n  /// </summary>\n  TSwagDefinition = class(TObject)\n  private\n    fName: string;\n    fJsonSchema: TJsonObject;\n    procedure SetName(const pValue: string);\n    procedure SetJsonSchema(const pValue: TJsonObject);\n    function GetJsonSchema: TJsonObject;\n  public\n    destructor Destroy; override;\n\n    function GenerateJsonRefDefinition: TJsonObject;\n    /// <summary>\n    /// The schema name alias.\n    /// </summary>\n    property Name: string read fName write SetName;\n\n    /// <summary>\n    /// See more in:\n    ///  * http://json-schema.org\n    ///  * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject\n    /// </summary>\n    property JsonSchema: TJsonObject read GetJsonSchema write SetJsonSchema;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TSwagDefinition }\n\ndestructor TSwagDefinition.Destroy;\nbegin\n  if Assigned(fJsonSchema) then\n    FreeAndNil(fJsonSchema);\n  inherited Destroy;\nend;\n\nfunction TSwagDefinition.GetJsonSchema: TJsonObject;\nbegin\n  Result := fJsonSchema;\nend;\n\nprocedure TSwagDefinition.SetJsonSchema(const pValue: TJsonObject);\nbegin\n  fJsonSchema := pValue;\n  fJsonSchema.Owned := False;\nend;\n\nprocedure TSwagDefinition.SetName(const pValue: string);\nbegin\n  fName := pValue;\nend;\n\nfunction TSwagDefinition.GenerateJsonRefDefinition: TJsonObject;\nconst\n  c_SchemaRef = '$ref';\n  c_PrefixDefinitionName = '#/definitions/';\nbegin\n  Result := TJsonObject.Create;\n  Result.AddPair(c_SchemaRef, c_PrefixDefinitionName + fName);\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing Swag.Common.Consts;\nusing Swag.Doc.Info;\nusing Swag.Doc.Tags;\nusing Swag.Doc.SecurityDefinition;\nusing Swag.Doc.Path;\nusing Swag.Doc.Definition;\nusing Swag.Doc.FileLoader;\nusing Swag.Common.Types;\n\nnamespace Swag.Doc\n{\n    public class SwagDoc\n    {\n        private SwagInfo _info;\n        private List<SwagTag> _tags;\n        private List<string> _consumes;\n        private List<string> _produces;\n        private string _basePath;\n        private string _host;\n        private HashSet<SwagTransferProtocolScheme> _schemes;\n        private List<SwagPath> _paths;\n        private List<SwagDefinition> _definitions;\n        private List<SwagSecurityDefinition> _securityDefinitions;\n        private SwagExternalDocs _externalDocs;\n        private JToken _swaggerJson;\n        private string _swaggerFilesFolder;\n        private List<SwagRequestParameter> _parameters;\n\n        public SwagDoc()\n        {\n            _info = new SwagInfo();\n            _tags = new List<SwagTag>();\n            _securityDefinitions = new List<SwagSecurityDefinition>();\n            _consumes = new List<string>();\n            _produces = new List<string>();\n            _paths = new List<SwagPath>();\n            _definitions = new List<SwagDefinition>();\n            _externalDocs = new SwagExternalDocs();\n            _parameters = new List<SwagRequestParameter>();\n            _schemes = new HashSet<SwagTransferProtocolScheme>();\n        }\n\n        ~SwagDoc()\n        {\n            _consumes = null;\n            _produces = null;\n            _definitions = null;\n            _paths = null;\n            _info = null;\n            _tags = null;\n            _securityDefinitions = null;\n            _externalDocs = null;\n            _parameters = null;\n            _swaggerJson = null;\n        }\n\n        public void GenerateSwaggerJson()\n        {\n            var json = new JObject();\n            json[\"swagger\"] = SwaggerVersion;\n            json[\"info\"] = _info.GenerateJsonObject();\n            if (!string.IsNullOrEmpty(_host))\n                json[\"host\"] = _host;\n            json[\"basePath\"] = _basePath;\n            if (_tags.Count > 0)\n                json[\"tags\"] = GenerateTagsJsonArray();\n            if (_schemes.Count > 0)\n                json[\"schemes\"] = GenerateSchemesJsonArray();\n            if (_consumes.Count > 0)\n                json[\"consumes\"] = GenerateMimeTypesJsonArray(_consumes);\n            if (_produces.Count > 0)\n                json[\"produces\"] = GenerateMimeTypesJsonArray(_produces);\n            if (_paths.Count > 0)\n                json[\"paths\"] = GeneratePathsJsonObject();\n            if (_parameters.Count > 0)\n                json[\"parameters\"] = GenerateParametersJsonObject();\n            if (_securityDefinitions.Count > 0)\n                json[\"securityDefinitions\"] = GenerateSecurityDefinitionsJsonObject();\n            if (_definitions.Count > 0)\n                json[\"definitions\"] = GenerateDefinitionsJsonObject();\n            if (_externalDocs != null)\n                json[\"externalDocs\"] = _externalDocs.GenerateJsonObject();\n            _swaggerJson = json;\n        }\n\n        public void SaveSwaggerJsonToFile()\n        {\n            if (_swaggerJson == null)\n                return;\n            if (!Directory.Exists(_swaggerFilesFolder))\n                Directory.CreateDirectory(_swaggerFilesFolder);\n            string jsonString = _swaggerJson.ToString(Newtonsoft.Json.Formatting.Indented);\n            File.WriteAllText(ReturnSwaggerFileName(), jsonString);\n        }\n\n        public void LoadFromFile(string filename)\n        {\n            var loader = new SwagFileLoader(this);\n            loader.Load(filename);\n        }\n\n        public string SwaggerVersion => Consts.c_SwaggerVersion;\n\n        public SwagInfo Info => _info;\n\n        public string Host { get => _host; set => _host = value; }\n\n        public string BasePath { get => _basePath; set => _basePath = value; }\n\n        public HashSet<SwagTransferProtocolScheme> Schemes { get => _schemes; set => _schemes = value; }\n\n        public List<string> Consumes => _consumes;\n\n        public List<string> Produces => _produces;\n\n        public List<SwagPath> Paths => _paths;\n\n        public List<SwagDefinition> Definitions => _definitions;\n\n        public List<SwagSecurityDefinition> SecurityDefinitions => _securityDefinitions;\n\n        public List<SwagRequestParameter> Parameters => _parameters;\n\n        public List<SwagTag> Tags => _tags;\n\n        public SwagExternalDocs ExternalDocs => _externalDocs;\n\n        public JToken SwaggerJson => _swaggerJson;\n\n        public string SwaggerFilesFolder\n        {\n            get => _swaggerFilesFolder;\n            set => _swaggerFilesFolder = value.EndsWith(Path.DirectorySeparatorChar.ToString()) ? value : value + Path.DirectorySeparatorChar;\n        }\n\n        private string ReturnSwaggerFileName()\n        {\n            return _swaggerFilesFolder + Consts.c_SwaggerFileName;\n        }\n\n        private JArray GenerateMimeTypesJsonArray(List<string> mimeTypes)\n        {\n            var arr = new JArray();\n            foreach (var mime in mimeTypes)\n                arr.Add(mime);\n            return arr;\n        }\n\n        private JArray GenerateConsumesJsonArray()\n        {\n            return GenerateMimeTypesJsonArray(_consumes);\n        }\n\n        private JArray GenerateProducesJsonArray()\n        {\n            return GenerateMimeTypesJsonArray(_produces);\n        }\n\n        private JObject GenerateDefinitionsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var def in _definitions)\n            {\n                if (def.JsonSchema != null)\n                    obj[def.Name] = def.JsonSchema.DeepClone();\n            }\n            return obj;\n        }\n\n        private JObject GenerateParametersJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var param in _parameters)\n                obj[param.Name] = param.GenerateJsonObject();\n            return obj;\n        }\n\n        private JObject GeneratePathsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var path in _paths)\n                obj[path.Uri] = path.GenerateJsonObject();\n            return obj;\n        }\n\n        private JArray GenerateTagsJsonArray()\n        {\n            var arr = new JArray();\n            foreach (var tag in _tags)\n                arr.Add(tag.GenerateJsonObject());\n            return arr;\n        }\n\n        private JArray GenerateSchemesJsonArray()\n        {\n            var arr = new JArray();\n            foreach (SwagTransferProtocolScheme scheme in Enum.GetValues(typeof(SwagTransferProtocolScheme)))\n            {\n                if (_schemes.Contains(scheme))\n                    arr.Add(Consts.c_SwagTransferProtocolScheme[scheme]);\n            }\n            return arr;\n        }\n\n        private JObject GenerateSecurityDefinitionsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var sec in _securityDefinitions)\n                obj[sec.SchemeName] = sec.GenerateJsonObject();\n            return obj;\n        }\n    }\n}"}
{"input": "unit Main.Form;\n\ninterface\n\nuses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Horse, Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.Mask, Vcl.ExtCtrls, Vcl.ComCtrls;\n\ntype\n  TfrmMain = class(TForm)\n    edtPort: TSpinEdit;\n    Button1: TButton;\n    leKey: TLabeledEdit;\n    leCrt: TLabeledEdit;\n    Button2: TButton;\n    Button3: TButton;\n    OpenDialog1: TOpenDialog;\n    lePassword: TLabeledEdit;\n    StatusBar1: TStatusBar;\n    procedure Button2Click(Sender: TObject);\n    procedure Button3Click(Sender: TObject);\n    procedure Button1Click(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n  private\n    function GetFile(const description, extension: string): string;\n    procedure Start;\n    procedure OnGetPassword(var Password: string);\n  end;\n\nvar\n  frmMain: TfrmMain;\n\nimplementation\n\nuses IdSSLOpenSSL;\n\n{$R *.dfm}\n\nprocedure TfrmMain.Button1Click(Sender: TObject);\nbegin\n  Start;\nend;\n\nprocedure TfrmMain.Button2Click(Sender: TObject);\nbegin\n  leKey.Text := GetFile('Private Key', '*key');\nend;\n\nprocedure TfrmMain.Button3Click(Sender: TObject);\nbegin\n  leCrt.Text := GetFile('Public Key', '*crt');\nend;\n\nprocedure TfrmMain.FormCreate(Sender: TObject);\nbegin\n  THorse.Get('/ping',\n    procedure(Req: THorseRequest; Res: THorseResponse)\n    begin\n      Res.Send('securite pong');\n    end);\nend;\n\nfunction TfrmMain.GetFile(const description, extension: string): string;\nbegin\n  Result := EmptyStr;\n  OpenDialog1.Filter := description + '|' + extension;\n  if OpenDialog1.Execute() then\n  begin\n    if OpenDialog1.FileName <> EmptyStr then\n      Result := OpenDialog1.FileName;\n  end;\nend;\n\nprocedure TfrmMain.OnGetPassword(var Password: string);\nbegin\n  Password := lePassword.Text;\nend;\n\nprocedure TfrmMain.Start;\nbegin\n// To use ssl it is necessary to have the ssl, libeay32.dll and ssleay32.dll\n// libraries in your executable folder.\n\n// Command to generate a self-signed certificate using openssl, on windows it is recommended to use git bash.\n// openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout cert.key -out cert.crt\n\n// Not recommended for production, only for testing and internal use, for commercial use in production\n// use a valid certificate, such as Let's Encrypt.\n\n  THorse.IOHandleSSL\n    .KeyFile(leKey.Text)\n    .CertFile(leCrt.Text)\n    .OnGetPassword(Self.OnGetPassword)\n    .SSLVersions([sslvTLSv1_2])\n    .Active(True);\n\n  // Need to set \"HORSE_VCL\" compilation directive\n\n  THorse.Listen(edtPort.Value,\n    procedure\n    begin\n      StatusBar1.Panels.Items[0].Text := Format('Securite Server is running on https://%s:%d', [THorse.Host, THorse.Port]);\n    end);\nend;\n\nend.", "output": "namespace MyHorseApp\n{\n    partial class frmMain\n    {\n        private System.ComponentModel.IContainer components = null;\n\n        private System.Windows.Forms.NumericUpDown numPort;\n        private System.Windows.Forms.Button btnStart;\n        private System.Windows.Forms.TextBox txtKey;\n        private System.Windows.Forms.Label lblKey;\n        private System.Windows.Forms.TextBox txtCrt;\n        private System.Windows.Forms.Label lblCrt;\n        private System.Windows.Forms.Button btnSelectKey;\n        private System.Windows.Forms.Button btnSelectCrt;\n        private System.Windows.Forms.OpenFileDialog openFileDialog1;\n        private System.Windows.Forms.TextBox txtPassword;\n        private System.Windows.Forms.Label lblPassword;\n        private System.Windows.Forms.StatusStrip statusStrip1;\n        private System.Windows.Forms.ToolStripStatusLabel tslStatus;\n\n       \n        protected override void Dispose(bool disposing)\n        {\n            if (disposing && (components != null))\n            {\n                components.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        #region Windows Form Designer generated code\n\n        private void InitializeComponent()\n        {\n            this.numPort = new System.Windows.Forms.NumericUpDown();\n            this.btnStart = new System.Windows.Forms.Button();\n            this.txtKey = new System.Windows.Forms.TextBox();\n            this.lblKey = new System.Windows.Forms.Label();\n            this.txtCrt = new System.Windows.Forms.TextBox();\n            this.lblCrt = new System.Windows.Forms.Label();\n            this.btnSelectKey = new System.Windows.Forms.Button();\n            this.btnSelectCrt = new System.Windows.Forms.Button();\n            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();\n            this.txtPassword = new System.Windows.Forms.TextBox();\n            this.lblPassword = new System.Windows.Forms.Label();\n            this.statusStrip1 = new System.Windows.Forms.StatusStrip();\n            this.tslStatus = new System.Windows.Forms.ToolStripStatusLabel();\n            ((System.ComponentModel.ISupportInitialize)(this.numPort)).BeginInit();\n            this.statusStrip1.SuspendLayout();\n            this.SuspendLayout();\n            \n            this.numPort.Location = new System.Drawing.Point(12, 12);\n            this.numPort.Maximum = new decimal(new int[] {\n            65535,\n            0,\n            0,\n            0});\n            this.numPort.Minimum = new decimal(new int[] {\n            1,\n            0,\n            0,\n            0});\n            this.numPort.Name = \"numPort\";\n            this.numPort.Size = new System.Drawing.Size(120, 20);\n            this.numPort.TabIndex = 0;\n            this.numPort.Value = new decimal(new int[] {\n            8443,\n            0,\n            0,\n            0});\n            \n            this.btnStart.Location = new System.Drawing.Point(12, 38);\n            this.btnStart.Name = \"btnStart\";\n            this.btnStart.Size = new System.Drawing.Size(120, 23);\n            this.btnStart.TabIndex = 1;\n            this.btnStart.Text = \"Start Horse Server\";\n            this.btnStart.UseVisualStyleBackColor = true;\n            this.btnStart.Click += new System.EventHandler(this.btnStart_Click);\n            \n            this.txtKey.Location = new System.Drawing.Point(12, 80);\n            this.txtKey.Name = \"txtKey\";\n            this.txtKey.Size = new System.Drawing.Size(300, 20);\n            this.txtKey.TabIndex = 2;\n            \n            this.lblKey.AutoSize = true;\n            this.lblKey.Location = new System.Drawing.Point(12, 64);\n            this.lblKey.Name = \"lblKey\";\n            this.lblKey.Size = new System.Drawing.Size(49, 13);\n            this.lblKey.TabIndex = 3;\n            this.lblKey.Text = \"Key File:\";\n            \n            this.txtCrt.Location = new System.Drawing.Point(12, 120);\n            this.txtCrt.Name = \"txtCrt\";\n            this.txtCrt.Size = new System.Drawing.Size(300, 20);\n            this.txtCrt.TabIndex = 4;\n            \n            this.lblCrt.AutoSize = true;\n            this.lblCrt.Location = new System.Drawing.Point(12, 104);\n            this.lblCrt.Name = \"lblCrt\";\n            this.lblCrt.Size = new System.Drawing.Size(62, 13);\n            this.lblCrt.TabIndex = 5;\n            this.lblCrt.Text = \"Certificate:\";\n            \n            this.btnSelectKey.Location = new System.Drawing.Point(318, 78);\n            this.btnSelectKey.Name = \"btnSelectKey\";\n            this.btnSelectKey.Size = new System.Drawing.Size(75, 23);\n            this.btnSelectKey.TabIndex = 6;\n            this.btnSelectKey.Text = \"Browse...\";\n            this.btnSelectKey.UseVisualStyleBackColor = true;\n            this.btnSelectKey.Click += new System.EventHandler(this.btnSelectKey_Click);\n            \n            this.btnSelectCrt.Location = new System.Drawing.Point(318, 118);\n            this.btnSelectCrt.Name = \"btnSelectCrt\";\n            this.btnSelectCrt.Size = new System.Drawing.Size(75, 23);\n            this.btnSelectCrt.TabIndex = 7;\n            this.btnSelectCrt.Text = \"Browse...\";\n            this.btnSelectCrt.UseVisualStyleBackColor = true;\n            this.btnSelectCrt.Click += new System.EventHandler(this.btnSelectCrt_Click);\n            \n            this.txtPassword.Location = new System.Drawing.Point(12, 160);\n            this.txtPassword.Name = \"txtPassword\";\n            this.txtPassword.Size = new System.Drawing.Size(300, 20);\n            this.txtPassword.TabIndex = 8;\n            \n            this.lblPassword.AutoSize = true;\n            this.lblPassword.Location = new System.Drawing.Point(12, 144);\n            this.lblPassword.Name = \"lblPassword\";\n            this.lblPassword.Size = new System.Drawing.Size(56, 13);\n            this.lblPassword.TabIndex = 9;\n            this.lblPassword.Text = \"Password:\";\n            \n            this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.tslStatus});\n            this.statusStrip1.Location = new System.Drawing.Point(0, 240);\n            this.statusStrip1.Name = \"statusStrip1\";\n            this.statusStrip1.Size = new System.Drawing.Size(420, 22);\n            this.statusStrip1.TabIndex = 10;\n            this.statusStrip1.Text = \"statusStrip1\";\n             \n            this.tslStatus.Name = \"tslStatus\";\n            this.tslStatus.Size = new System.Drawing.Size(118, 17);\n            this.tslStatus.Text = \"Status: Not running...\";\n            \n            this.ClientSize = new System.Drawing.Size(420, 262);\n            this.Controls.Add(this.statusStrip1);\n            this.Controls.Add(this.lblPassword);\n            this.Controls.Add(this.txtPassword);\n            this.Controls.Add(this.btnSelectCrt);\n            this.Controls.Add(this.btnSelectKey);\n            this.Controls.Add(this.lblCrt);\n            this.Controls.Add(this.txtCrt);\n            this.Controls.Add(this.lblKey);\n            this.Controls.Add(this.txtKey);\n            this.Controls.Add(this.btnStart);\n            this.Controls.Add(this.numPort);\n            this.Name = \"frmMain\";\n            this.Text = \"Horse SSL Server Demo\";\n            this.Load += new System.EventHandler(this.frmMain_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.numPort)).EndInit();\n            this.statusStrip1.ResumeLayout(false);\n            this.statusStrip1.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n\n        }\n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit App.WebModule;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Serializer.JsonDataObjects;\n\ntype\n\n  TAppWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVCEngine: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TAppWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles,\n  Person.Controller;\n\nprocedure TAppWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVCEngine := TMVCEngine.Create(Self,\n    procedure(AConfig: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      AConfig[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      AConfig[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      AConfig[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      AConfig[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      AConfig[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      AConfig[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      AConfig[TMVCConfigKey.ExposeServerSignature] := 'true';\n    end);\n  FMVCEngine.AddController(TPersonController);\n  FMVCEngine.AddSerializer(TMVCMediaType.APPLICATION_JSON, TMVCJsonDataObjectsSerializer.Create);\n  FMVCEngine.AddMiddleware(TMVCStaticFilesMiddleware.Create(\n    '/', { StaticFilesPath }\n    ExtractFilePath(GetModuleName(HInstance)) + 'www', { DocumentRoot }\n    'index.html' {IndexDocument - Before it was named fallbackresource}\n    ));\nend;\n\nprocedure TAppWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVCEngine.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.FileProviders;\nusing System.IO;\nusing System.Collections.Generic;\n\nnamespace App.WebModule\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        \n        public IConfiguration Configuration { get; }\n        \n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers()\n                .AddNewtonsoftJson();\n\n        }\n        \n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            string wwwPath = Path.Combine(env.ContentRootPath, \"www\");\n            var fileProvider = new PhysicalFileProvider(wwwPath);\n            \n            app.UseDefaultFiles(new DefaultFilesOptions\n            {\n                DefaultFileNames = new List<string> { \"index.html\" },\n                FileProvider = fileProvider\n            });\n            app.UseStaticFiles(new StaticFileOptions\n            {\n                FileProvider = fileProvider,\n                RequestPath = \"\"\n            });\n\n            app.UseRouting();\n\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n// Contribution on this file: Copyright (c) 2018 - Jo\ufffdo Ant\ufffdnio Duarte\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.NewProject;\n// This is done to Warnings that I can't control, as Embarcadero has\n// deprecated the functions, but due to design you are still required to\n// to implement.\n{$WARN SYMBOL_DEPRECATED OFF}\ninterface\n\nuses\n  PlatformAPI,\n  ToolsAPI;\n\ntype\n   TNewProject = class abstract(TNotifierObject,IOTACreator, IOTAProjectCreator,IOTAProjectCreator80)\n   protected\n    //IOTACreator\n    function GetCreatorType: string; virtual;\n    function GetExisting: Boolean;\n    function GetFileSystem: string;\n    function GetOwner: IOTAModule;\n    function GetUnnamed: Boolean;\n    // IOTAProjectCreator\n    function GetFileName: string;\n    function GetOptionFileName: string; deprecated;\n    function GetShowSource: Boolean;\n    procedure NewDefaultModule; deprecated;\n    function NewOptionSource(const ProjectName: string): IOTAFile; deprecated;\n    procedure NewProjectResource(const Project: IOTAProject);\n    function NewProjectSource(const ProjectName: string): IOTAFile; virtual; abstract;  // MUST OVERRIDE!\n    // IOTAProjectCreator80\n    function GetProjectPersonality: string;virtual;\n    procedure NewDefaultProjectModule(const Project: IOTAProject);\n  private\n    procedure SetFileName(const Value: String);\n  protected\n    FFileName : String;\n  public\n     property FileName : String read GetFileName write SetFileName;\n  end;\n\n  TNewProjectEx = class(TNewProject, IOTAProjectCreator160)\n  private\n   FPersonality: string;\n  protected\n    function GetProjectPersonality: string;override;\n\n    // IOTAProjectCreator160\n    function GetPlatforms: TArray<string>;\n    function GetFrameworkType: string; virtual;\n    function GetPreferredPlatform: string;\n    procedure SetInitialOptions(const NewProject: IOTAProject);\n  public\n    property Personality : string read FPersonality write FPersonality;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n\n{ TNewProject }\n\nfunction TNewProject.GetCreatorType: string;\nbegin\n  Result := sConsole; // May want to change this in the future, at least making method virtual\nend;\n\nfunction TNewProject.GetExisting: Boolean;\nbegin\n  Result := False;\nend;\n\nfunction TNewProject.GetFileName: string;\nbegin\n  Result := FFileName;\nend;\n\nfunction TNewProject.GetFileSystem: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProject.GetOptionFileName: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProject.GetOwner: IOTAModule;\nbegin\n  Result := (BorlandIDEServices as IOTAModuleServices).MainProjectGroup;\nend;\n\nfunction TNewProject.GetProjectPersonality: string;\nbegin\n  Result := sDelphiPersonality;\nend;\n\nfunction TNewProject.GetShowSource: Boolean;\nbegin\n  Result := False;\nend;\n\nfunction TNewProject.GetUnnamed: Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TNewProject.NewDefaultModule;\nbegin\nend;\n\nprocedure TNewProject.NewDefaultProjectModule(const Project: IOTAProject);\nbegin\nend;\n\nfunction TNewProject.NewOptionSource(const ProjectName: string): IOTAFile;\nbegin\n  Result := nil;\nend;\n\nprocedure TNewProject.NewProjectResource(const Project: IOTAProject);\nbegin\nend;\n\n\nprocedure TNewProject.SetFileName(const Value: String);\nbegin\n  FFileName := Value;\nend;\n\nfunction TNewProjectEx.GetFrameworkType: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProjectEx.GetPlatforms: TArray<string>;\nbegin\n  Result := TArray<string>.Create(cWin32Platform, cWin64Platform);\nend;\n\nfunction TNewProjectEx.GetPreferredPlatform: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProjectEx.GetProjectPersonality: string;\nbegin\n  Result := sDelphiPersonality\nend;\n\nprocedure TNewProjectEx.SetInitialOptions(const NewProject: IOTAProject);\nvar\n  LBuildConf: IOTAProjectOptionsConfigurations;\nbegin\n  if Supports(NewProject.ProjectOptions, IOTAProjectOptionsConfigurations, LBuildConf) then\n  begin\n    LBuildConf.BaseConfiguration.AsBoolean['UsingDelphiRTL'] := True;\n  end;\n\nend;\n\nend.", "output": "using System;\n\nnamespace DMVCExpertCodeGenNewProject\n{\n    public interface IOTACreator { }\n    \n    public interface IOTAProjectCreator { }\n    \n    public interface IOTAProjectCreator80 { }\n    \n    public interface IOTAProjectCreator160 { }\n    \n    public interface IOTAModule { }\n    \n    public interface IOTAFile { }\n    \n    public interface IOTAProject\n    {\n        object ProjectOptions { get; }\n    }\n    \n    public interface IOTAProjectOptionsConfigurations\n    {\n        IBaseConfiguration BaseConfiguration { get; }\n    }\n    \n    public interface IBaseConfiguration\n    {\n        bool this[string key] { get; set; }\n    }\n        public static class Constants\n    {\n        public const string sConsole = \"Console\";\n        public const string sDelphiPersonality = \"Delphi\";\n        public const string cWin32Platform = \"Win32\";\n        public const string cWin64Platform = \"Win64\";\n    }\n    \n    public abstract class TNewProject : IOTACreator, IOTAProjectCreator, IOTAProjectCreator80\n    {\n        protected string FFileName;\n\n        \n        public virtual string GetCreatorType() => Constants.sConsole;  \n        public bool GetExisting() => false;\n        public string GetFileSystem() => \"\";\n        public IOTAModule GetOwner() \n        {\n            \n            return null;\n        }\n        public bool GetUnnamed() => true;\n\n        \n        public string GetFileName() => FFileName;\n        public string GetOptionFileName() => \"\";\n        public bool GetShowSource() => false;\n        public virtual void NewDefaultModule() { } \n        public virtual IOTAFile NewOptionSource(string ProjectName) => null;\n        public virtual void NewProjectResource(IOTAProject Project) { }\n        public abstract IOTAFile NewProjectSource(string ProjectName);\n\n        public virtual string GetProjectPersonality() => Constants.sDelphiPersonality;\n        public virtual void NewDefaultProjectModule(IOTAProject Project) { }\n\n        public string FileName\n        {\n            get => GetFileName();"}
{"input": "unit Horse.Core.Route.Contract;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n  Horse.Callback;\n\ntype\n  IHorseCoreRoute<T: class> = interface\n    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']\n    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\n    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\n    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\n    function Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IFEND}\n    function &End: T;\n  end;\n\nimplementation\n\nend.", "output": "using System;\n\nnamespace Horse.Core.Route.Contract\n{\n    \n    public delegate void THorseCallback();\n    public delegate void THorseCallbackRequestResponse();\n    public delegate void THorseCallbackRequest();\n    public delegate void THorseCallbackResponse();\n\n    public interface IHorseCoreRoute<T> where T : class\n    {\n        IHorseCoreRoute<T> AddCallback(THorseCallback callback);\n        IHorseCoreRoute<T> AddCallbacks(THorseCallback[] callbacks);\n        IHorseCoreRoute<T> All(THorseCallback callback);\n        IHorseCoreRoute<T> All(THorseCallback middleware, THorseCallback callback);\n        IHorseCoreRoute<T> All(params THorseCallback[] callbacks);\n        IHorseCoreRoute<T> All(THorseCallback[] callbacks, THorseCallback callback);\n        IHorseCoreRoute<T> Get(THorseCallback callback);\n        IHorseCoreRoute<T> Get(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Get(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Get(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Put(THorseCallback callback);\n        IHorseCoreRoute<T> Put(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Put(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Put(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Head(THorseCallback callback);\n        IHorseCoreRoute<T> Head(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Head(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Head(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Post(THorseCallback callback);\n        IHorseCoreRoute<T> Post(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Post(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Post(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Patch(THorseCallback callback);\n        IHorseCoreRoute<T> Delete(THorseCallback callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackResponse callback);\n        T End();\n    }\n}"}
{"input": "unit WebModule02U;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, CustomWebModuleU, MVCFramework;\n\ntype\n  TWebModule02 = class(TCustomWebModule)\n  protected\n    procedure DoConfigureEngine(const aMVCEngine: TMVCEngine); override;\n\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses App1MainControllerU;\n{ TWebModule02 }\n\nprocedure TWebModule02.DoConfigureEngine(const aMVCEngine: TMVCEngine);\nbegin\n  inherited;\n  aMVCEngine.AddController(TApp1MainController);\nend;\n\nend.", "output": "using MVCFramework;\n\nnamespace YourNamespace\n{\n    public class WebModule02 : CustomWebModule\n    {\n        protected override void DoConfigureEngine(TMVCEngine engine)\n        {\n            base.DoConfigureEngine(engine);\n            engine.AddController(typeof(App1MainController));\n        }\n    }\n}"}
{"input": "unit Horse.Core.Route;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n{$ELSE}\n  System.SysUtils,\n{$ENDIF}\n  Horse.Core.Route.Contract,\n  Horse.Callback;\n\ntype\n  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)\n  private\n    FPath: string;\n    FHorseCore: TObject;\n  public\n    constructor Create(const APath: string);\n    function This: IHorseCoreRoute<T>;\n    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\n    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\n    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\n    function Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IFEND}\n    function &End: T;\n  end;\n\nimplementation\n\nuses\n  Horse.Core;\n\nconstructor THorseCoreRoute<T>.Create(const APath: string);\nbegin\n  FPath := APath;\n  FHorseCore := THorseCore.GetInstance;\nend;\n\nfunction THorseCoreRoute<T>.This: IHorseCoreRoute<T>;\nbegin\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, [AMiddleware, ACallback]);\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallbacks);\nend;\n\nfunction THorseCoreRoute<T>.&End: T;\nbegin\n  Result := FHorseCore as T;\nend;\n\nfunction THorseCoreRoute<T>.AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).AddCallback(ACallback);\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallbacks);\n  THorseCore(FHorseCore).Use(FPath, [ACallback]);\nend;\n\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Get(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Head(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Post(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Put(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\nvar\n  LCallback: THorseCallback;\nbegin\n  for LCallback in ACallbacks do\n    AddCallback(LCallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing Horse.Core.Route.Contract; \nusing Horse.Core;                \n\nnamespace Horse.Core.Route\n{\n    public class HorseCoreRoute<T> : IHorseCoreRoute<T> where T : class\n    {\n        private readonly string _path;\n        private readonly object _horseCore; \n\n        public HorseCoreRoute(string aPath)\n        {\n            _path = aPath;\n            \n            _horseCore = HorseCore.GetInstance();\n        }\n\n        public IHorseCoreRoute<T> This() => this;\n\n        public IHorseCoreRoute<T> AddCallback(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).AddCallback(callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> AddCallbacks(THorseCallback[] callbacks)\n        {\n            foreach (var cb in callbacks)\n            {\n                AddCallback(cb);\n            }\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback middleware, THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, new THorseCallback[] { middleware, callback });\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback[] callbacks)\n        {\n            ((HorseCore)_horseCore).Use(_path, callbacks);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback[] callbacks, THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, callbacks);\n            ((HorseCore)_horseCore).Use(_path, new THorseCallback[] { callback });\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public T End()\n        {\n            return _horseCore as T;\n        }\n    }\n}"}
{"input": "unit MainWebModuleU;\n\ninterface\n\nuses System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TMyWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMyWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  MyControllerU,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles;\n\nprocedure TMyWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      Config[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] :=\n        TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] :=\n        TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n    end);\n  FMVC.AddController(TMyController);\nend;\n\nprocedure TMyWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MainWebModuleApp\n{\n    \n    [ApiController]\n    [Route(\"api\")]\n    public class MyController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult Index()\n        {\n            return Ok(\"Hello DelphiMVCFramework World\");\n        }\n\n        [HttpGet(\"reversedstrings/{value}\")]\n        public IActionResult GetReversedString(string value)\n        {\n            if (value == null)\n                return BadRequest(\"Value is required\");\n            string reversed = new string(value.Trim().Reverse().ToArray());\n            return Ok(reversed);\n        }\n\n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n            return Ok(Array.Empty<object>());\n        }\n\n        [HttpGet(\"customers/{id:int}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            var customer = new { Id = id, Name = \"Customer \" + id };\n            return Ok(customer);\n        }\n\n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer([FromBody] dynamic customer)\n        {\n            return Created($\"/api/customers/{customer.id}\", customer);\n        }\n\n        [HttpPut(\"customers/{id:int}\")]\n        public IActionResult UpdateCustomer(int id, [FromBody] dynamic customer)\n        {\n            return Ok(customer);\n        }\n\n        [HttpDelete(\"customers/{id:int}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            return NoContent();\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Services.AddControllers();\n\n\n            var app = builder.Build();\n\n            app.UseStaticFiles();\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"securite pong\");\n\n            Console.WriteLine($\"Server is running on: http://{app.Urls.FirstOrDefault()}\");\n\n            app.Run();\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.RQL.AST2InterbaseSQL;\n\ninterface\n\nuses\n  System.Generics.Defaults,\n  MVCFramework.RQL.Parser,\n  MVCFramework.RQL.AST2FirebirdSQL;\n\ntype\n  TRQLInterbaseCompiler = class(TRQLFirebirdCompiler)\n  protected\n    function GetLiteralBoolean(const Value: Boolean): String; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.ActiveRecord;\n\n{ TRQLInterbaseCompiler }\n\nfunction TRQLInterbaseCompiler.GetLiteralBoolean(const Value: Boolean): String;\nbegin\n  if Value then\n  begin\n    Exit('1');\n  end;\n  Exit('0');\nend;\n\ninitialization\n\nTRQLCompilerRegistry.Instance.RegisterCompiler('interbase', TRQLInterbaseCompiler);\n\nfinalization\n\nTRQLCompilerRegistry.Instance.UnRegisterCompiler('interbase');\n\nend.", "output": "using System;\nusing MVCFramework.RQL.Parser;\nusing MVCFramework.RQL.AST2FirebirdSQL; \nusing MVCFramework.ActiveRecord;\n\nnamespace MVCFramework.RQL.AST2InterbaseSQL\n{\n    \n    public class RQLInterbaseCompiler : RQLFirebirdCompiler\n    {\n        \n        protected override string GetLiteralBoolean(bool value)\n        {\n            return value ? \"1\" : \"0\";\n        }\n    }\n\n    \n    public static class RQLInterbaseCompilerRegistration\n    {\n        static RQLInterbaseCompilerRegistration()\n        {\n            \n            RQLCompilerRegistry.Instance.RegisterCompiler(\"interbase\", typeof(RQLInterbaseCompiler));\n        }\n\n        \n        public static void Unregister()\n        {\n            RQLCompilerRegistry.Instance.UnRegisterCompiler(\"interbase\");\n        }\n    }\n}"}
{"input": "unit Horse.Provider.IOHandleSSL;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n  IdSSLOpenSSL,\n  Horse.Provider.IOHandleSSL.Contract;\n\ntype\n  THorseProviderIOHandleSSL = class(TInterfacedObject, IHorseProviderIOHandleSSL)\n  private\n    FKeyFile: string;\n    FRootCertFile: string;\n    FCertFile: string;\n    FDHParamsFile: string;\n    FCipherList: string;\n    FMethod: TIdSSLVersion;\n    FSSLVersions: TIdSSLVersions;\n    FOnGetPassword: TPasswordEvent;\n    FActive: Boolean;\n    function Active: Boolean; overload;\n    function Active(const AValue: Boolean): IHorseProviderIOHandleSSL; overload;\n    function CertFile: string; overload;\n    function CertFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function RootCertFile: string; overload;\n    function RootCertFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function KeyFile: string; overload;\n    function KeyFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function Method: TIdSSLVersion; overload;\n    function Method(const AValue: TIdSSLVersion): IHorseProviderIOHandleSSL; overload;\n    function SSLVersions: TIdSSLVersions; overload;\n    function SSLVersions(const AValue: TIdSSLVersions): IHorseProviderIOHandleSSL; overload;\n    function DHParamsFile: string; overload;\n    function DHParamsFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function CipherList: string; overload;\n    function CipherList(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function OnGetPassword: TPasswordEvent; overload;\n    function OnGetPassword(const AValue: TPasswordEvent): IHorseProviderIOHandleSSL; overload;\n  public\n    constructor Create;\n    class function New: IHorseProviderIOHandleSSL;\n  end;\n\nimplementation\n\nfunction THorseProviderIOHandleSSL.Active(const AValue: Boolean): IHorseProviderIOHandleSSL;\nbegin\n  FActive := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.Active: Boolean;\nbegin\n  Result := FActive;\nend;\n\nfunction THorseProviderIOHandleSSL.CertFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FCertFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.CipherList: string;\nbegin\n  Result := FCipherList;\nend;\n\nfunction THorseProviderIOHandleSSL.CipherList(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FCipherList := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.CertFile: string;\nbegin\n  Result := FCertFile;\nend;\n\nconstructor THorseProviderIOHandleSSL.Create;\nbegin\n  FActive := True;\n  FMethod := DEF_SSLVERSION;\n  FSSLVersions := DEF_SSLVERSIONS;\nend;\n\nfunction THorseProviderIOHandleSSL.DHParamsFile: string;\nbegin\n  Result := FDHParamsFile;\nend;\n\nfunction THorseProviderIOHandleSSL.DHParamsFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FDHParamsFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.KeyFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FKeyFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.KeyFile: string;\nbegin\n  Result := FKeyFile;\nend;\n\nfunction THorseProviderIOHandleSSL.Method(const AValue: TIdSSLVersion): IHorseProviderIOHandleSSL;\nbegin\n  FMethod := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.Method: TIdSSLVersion;\nbegin\n  Result := FMethod;\nend;\n\nclass function THorseProviderIOHandleSSL.New: IHorseProviderIOHandleSSL;\nbegin\n  Result := THorseProviderIOHandleSSL.Create;\nend;\n\nfunction THorseProviderIOHandleSSL.OnGetPassword(const AValue: TPasswordEvent): IHorseProviderIOHandleSSL;\nbegin\n  FOnGetPassword := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.OnGetPassword: TPasswordEvent;\nbegin\n  Result := FOnGetPassword;\nend;\n\nfunction THorseProviderIOHandleSSL.RootCertFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FRootCertFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.RootCertFile: string;\nbegin\n  Result := FRootCertFile;\nend;\n\nfunction THorseProviderIOHandleSSL.SSLVersions: TIdSSLVersions;\nbegin\n  Result := FSSLVersions;\nend;\n\nfunction THorseProviderIOHandleSSL.SSLVersions(const AValue: TIdSSLVersions): IHorseProviderIOHandleSSL;\nbegin\n  FSSLVersions := AValue;\n  Result := Self;\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Provider.IOHandleSSL\n{\n    \n    public enum TIdSSLVersion\n    {\n        TLSv1,\n        TLSv1_1,\n        TLSv1_2\n    }\n\n   \n    [Flags]\n    public enum TIdSSLVersions\n    {\n        TLSv1 = 1,\n        TLSv1_1 = 2,\n        TLSv1_2 = 4\n    }\n\n    \n    public delegate void TPasswordEvent(object sender, ref string password);\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        \n        IHorseProviderIOHandleSSL Active(bool value);\n        bool Active { get; }\n\n        IHorseProviderIOHandleSSL CertFile(string value);\n        string CertFile { get; }\n\n        IHorseProviderIOHandleSSL RootCertFile(string value);\n        string RootCertFile { get; }\n\n        IHorseProviderIOHandleSSL KeyFile(string value);\n        string KeyFile { get; }\n\n        IHorseProviderIOHandleSSL Method(TIdSSLVersion value);\n        TIdSSLVersion Method { get; }\n\n        IHorseProviderIOHandleSSL SSLVersions(TIdSSLVersions value);\n        TIdSSLVersions SSLVersions { get; }\n\n        IHorseProviderIOHandleSSL DHParamsFile(string value);\n        string DHParamsFile { get; }\n\n        IHorseProviderIOHandleSSL CipherList(string value);\n        string CipherList { get; }\n\n        IHorseProviderIOHandleSSL OnGetPassword(TPasswordEvent value);\n        TPasswordEvent OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        private bool _active;\n        private string _keyFile;\n        private string _rootCertFile;\n        private string _certFile;\n        private string _dhParamsFile;\n        private string _cipherList;\n        private TIdSSLVersion _method;\n        private TIdSSLVersions _sslVersions;\n        private TPasswordEvent _onGetPassword;\n\n        \n        private const TIdSSLVersion DEF_SSLVERSION = TIdSSLVersion.TLSv1_2;\n        private const TIdSSLVersions DEF_SSLVERSIONS = TIdSSLVersions.TLSv1_2;\n\n        public HorseProviderIOHandleSSL()\n        {\n            _active = true;\n            _method = DEF_SSLVERSION;\n            _sslVersions = DEF_SSLVERSIONS;\n        }\n\n        public IHorseProviderIOHandleSSL Active(bool value)\n        {\n            _active = value;\n            return this;\n        }\n\n        public bool Active => _active;\n\n        public IHorseProviderIOHandleSSL CertFile(string value)\n        {\n            _certFile = value;\n            return this;\n        }\n\n        public string CertFile => _certFile;\n\n        public IHorseProviderIOHandleSSL RootCertFile(string value)\n        {\n            _rootCertFile = value;\n            return this;\n        }\n\n        public string RootCertFile => _rootCertFile;\n\n        public IHorseProviderIOHandleSSL KeyFile(string value)\n        {\n            _keyFile = value;\n            return this;\n        }\n\n        public string KeyFile => _keyFile;\n\n        public IHorseProviderIOHandleSSL Method(TIdSSLVersion value)\n        {\n            _method = value;\n            return this;\n        }\n\n        public TIdSSLVersion Method => _method;\n\n        public IHorseProviderIOHandleSSL SSLVersions(TIdSSLVersions value)\n        {\n            _sslVersions = value;\n            return this;\n        }\n\n        public TIdSSLVersions SSLVersions => _sslVersions;\n\n        public IHorseProviderIOHandleSSL DHParamsFile(string value)\n        {\n            _dhParamsFile = value;\n            return this;\n        }\n\n        public string DHParamsFile => _dhParamsFile;\n\n        public IHorseProviderIOHandleSSL CipherList(string value)\n        {\n            _cipherList = value;\n            return this;\n        }\n\n        public string CipherList => _cipherList;\n\n        public IHorseProviderIOHandleSSL OnGetPassword(TPasswordEvent value)\n        {\n            _onGetPassword = value;\n            return this;\n        }\n\n        public TPasswordEvent OnGetPassword => _onGetPassword;\n\n        \n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{  Sample author: geoffsmith82 - 2019                                          }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Sample.MvcControllerClientFileBuilder;\n\ninterface\n\nuses\n  System.Classes,\n  System.Json,\n  System.SysUtils,\n  System.Generics.Collections,\n  System.Generics.Defaults,\n  Swag.Doc,\n  Swag.Common.Types,\n  Swag.Doc.Path.Operation,\n  Swag.Doc.Path.Operation.Response,\n  Swag.Doc.Path.Operation.RequestParameter,\n  Sample.DelphiUnit.Generate;\n\ntype\n  TSwagDocToDelphiRESTClientBuilder = class(TObject)\n  strict private\n    fSwagDoc: TSwagDoc;\n\n    function CapitalizeFirstLetter(const pTypeName: string): string;\n    function RewriteUriToSwaggerWay(const pUri: string): string;\n    function OperationIdToFunctionName(pOperation: TSwagPathOperation): string;\n    function GenerateUnitText(pDelphiUnit: TDelphiUnit): string;\n    function ConvertSwaggerTypeToDelphiType(pSwaggerType: TSwagRequestParameter): TUnitTypeDefinition;\n    function ConvertRefToType(const pRef: string): string;\n    function ConvertRefToVarName(const pRef: string): string;\n\n    procedure ChildType(pDelphiUnit: TDelphiUnit; pJson: TJSONPair);\n    procedure HandleArray(pField: TUnitFieldDefinition; pJson: TJSONPair);\n    procedure ConvertSwaggerDefinitionsToTypeDefinitions(pDelphiUnit: TDelphiUnit);\n  public\n    constructor Create(pSwagDoc: TSwagDoc); reintroduce;\n    function Generate: string;\n  end;\n\nimplementation\n\nuses\n  Winapi.Windows,\n  System.IOUtils,\n  System.TypInfo,\n  Json.Common.Helpers;\n\n{ TSwagDocToDelphiMVCFrameworkBuilder }\n\nconstructor TSwagDocToDelphiRESTClientBuilder.Create(pSwagDoc: TSwagDoc);\nbegin\n  inherited Create;\n  fSwagDoc := pSwagDoc;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.OperationIdToFunctionName(pOperation: TSwagPathOperation): string;\nbegin\n  Result := pOperation.OperationId.Replace('{','').Replace('}','').Replace('-','');\n  if not CharInSet(Result[1], ['a'..'z','A'..'Z']) then\n    Result := 'F' + Result;\n\n  Result := CapitalizeFirstLetter(Result);\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.RewriteUriToSwaggerWay(const pUri: string): string;\nbegin\n  Result := pUri.Replace('{','($').Replace('}',')');\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.CapitalizeFirstLetter(const pTypeName: string): string;\nbegin\n  if pTypeName.Length > 2 then\n    Result := Copy(pTypeName, 1, 1).ToUpper + Copy(pTypeName, 2, pTypeName.Length - 1)\n  else\n    Result := pTypeName;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertRefToType(const pRef: string): string;\nbegin\n  Result := Copy(pRef, pRef.LastIndexOf('/') + 2);\n  Result := Copy(Result,1,1).ToUpper + Copy(Result,2);\n  if Result.ToLower <> 'string' then\n    Result := 'T' + Result;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertRefToVarName(const pRef: string): string;\nbegin\n  Result := Copy(pRef, pRef.LastIndexOf('/') + 2);\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.Generate: string;\nvar\n  vPathIndex: Integer;\n  vOperationIndex: Integer;\n  vParameterIndex: Integer;\n  vDelphiUnit: TDelphiUnit;\n  vMVCControllerClient: TUnitTypeDefinition;\n  vMethod: TUnitMethod;\n  vResponse: TPair<string, TSwagResponse>;\n  vSchemaObj: TJsonObject;\n  vResultParam: TUnitParameter;\n  vField: TUnitFieldDefinition;\n  vRef: String;\nbegin\n  vDelphiUnit := TDelphiUnit.Create;\n  try\n    vDelphiUnit.UnitFile := 'UnitFilenameMvcControllerClient';\n    vDelphiUnit.AddInterfaceUnit('IPPeerClient');\n    vDelphiUnit.AddInterfaceUnit('REST.Client');\n    vDelphiUnit.AddInterfaceUnit('REST.Authenticator.OAuth');\n    vDelphiUnit.AddInterfaceUnit('REST.Types');\n    vDelphiUnit.AddInterfaceUnit('MVCFramework');\n    vDelphiUnit.AddInterfaceUnit('MVCFramework.Commons');\n    vDelphiUnit.AddImplementationUnit('Swag.Doc');\n\n    ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n\n    vMVCControllerClient := TUnitTypeDefinition.Create;\n    vMVCControllerClient.TypeName := 'TMyMVCControllerClient';\n    vMVCControllerClient.TypeInherited := 'TObject';\n    vMVCControllerClient.AddAttribute('  [MVCPath(''' + RewriteUriToSwaggerWay(fSwagDoc.BasePath) + ''')]');\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTClient';\n    vField.FieldType := 'TRESTClient';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTRequest';\n    vField.FieldType := 'TRESTRequest';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTResponse';\n    vField.FieldType := 'TRESTResponse';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vDelphiUnit.AddType(vMVCControllerClient);\n    ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n\n    for vPathIndex := 0 to fSwagDoc.Paths.Count - 1 do\n    begin\n      for vOperationIndex := 0 to fSwagDoc.Paths[vPathIndex].Operations.Count - 1 do\n      begin\n        vMethod := TUnitMethod.Create;\n        if fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Description.Trim.Length > 0 then\n          vMethod.AddAttribute('    [MVCDoc(' + QuotedStr(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Description) + ')]');\n        vMethod.AddAttribute('    [MVCPath(''' + fSwagDoc.Paths[vPathIndex].Uri + ''')]');\n        vMethod.AddAttribute('    [MVCHTTPMethod([http' + fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].OperationToString + '])]');\n        vMethod.Name := OperationIdToFunctionName(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex]);\n\n        for vParameterIndex := 0 to fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters.Count - 1 do\n        begin\n          vResultParam := TUnitParameter.Create;\n          vResultParam.ParamName := CapitalizeFirstLetter(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters[vParameterIndex].Name);\n          vResultParam.ParamType := ConvertSwaggerTypeToDelphiType(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters[vParameterIndex]);\n          vMethod.AddParameter(vResultParam);\n        end;\n\n        for vResponse in fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Responses do\n        begin\n          vSchemaObj := vResponse.Value.Schema.JsonSchema;\n          if vSchemaObj = nil then\n            continue;\n          if vSchemaObj.TryGetValue('$ref', vRef) then\n          begin\n            vMethod.AddAttribute('    [MVCResponse(' + vResponse.Key + ', ' +\n                                                   QuotedStr(vResponse.Value.Description) + ', ' + ConvertRefToType(vRef) + ')]');\n            vResultParam := TUnitParameter.Create;\n            vResultParam.ParamName := ConvertRefToVarName(vRef);\n            vResultParam.ParamType := TUnitTypeDefinition.Create;\n            vResultParam.ParamType.TypeName := ConvertRefToType(vRef);\n            vMethod.AddLocalVariable(vResultParam);\n            vMethod.Content.Add('  ' + ConvertRefToVarName(vRef) + ' := ' + ConvertRefToType(vRef) + '.Create;');\n//            method.Content.Add('  Render(' + response.Key + ', ' + ConvertRefToVarName(ref) + ');');\n          end\n          else\n          begin\n            if not vSchemaObj.TryGetValue('properties', vSchemaObj) then\n              continue;\n            if not vSchemaObj.TryGetValue('employees', vSchemaObj) then\n              continue;\n            if not vSchemaObj.TryGetValue('items', vSchemaObj) then\n              continue;\n            if vSchemaObj.TryGetValue('$ref', vRef) then\n            begin\n              vMethod.AddAttribute('    [MVCResponseList(' + vResponse.Key + ', ' +\n                                                     QuotedStr(vResponse.Value.Description) + ', ' + ConvertRefToType(vRef) + ')]');\n              vResultParam := TUnitParameter.Create;\n              vResultParam.ParamName := ConvertRefToVarName(vRef);\n              vResultParam.ParamType := TUnitTypeDefinition.Create;\n              vResultParam.ParamType.TypeName := 'TObjectList<' + ConvertRefToType(vRef) + '>';\n              vMethod.AddLocalVariable(vResultParam);\n              vDelphiUnit.AddInterfaceUnit('Generics.Collections');\n              vMethod.Content.Add('  ' + ConvertRefToVarName(vRef) + ' := TObjectList<' + ConvertRefToType(vRef) + '>.Create;');\n            end;\n          end;\n        end;\n\n        vMVCControllerClient.Methods.Add(vMethod);\n      end;\n    end;\n\n    vDelphiUnit.SortTypeDefinitions;\n\n    Result := GenerateUnitText(vDelphiUnit);\n  finally\n    vDelphiUnit.Free;\n  end;\nend;\n\nprocedure TSwagDocToDelphiRESTClientBuilder.HandleArray(pField : TUnitFieldDefinition; pJson: TJSONPair);\nvar\n  vJsonObj: TJSONObject;\n  vJsonVal: TJSONValue;\n  vType: string;\nbegin\n  if Assigned(((pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject).Values['type']) then\n  begin\n    vType := ((pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject).Values['type'].Value;\n    if vType.ToLower <> 'string' then\n      vType := 'T' + vType;\n    pField.FieldType := 'array of ' + vType;\n  end\n  else\n  begin\n    OutputDebugString(PChar(pJson.ToJSON));\n    vJsonVal := (pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject;\n    OutputDebugString(PChar(vJsonVal.ToJSON));\n    vJsonObj := vJsonVal as TJSONObject;\n    vJsonVal := vJsonObj.Values['$ref'];\n    OutputDebugString(PChar(vJsonVal.Value));\n    pField.FieldType := 'array of ' + ConvertRefToType(vJsonVal.value);\n  end;\nend;\n\n\nprocedure TSwagDocToDelphiRESTClientBuilder.ChildType(pDelphiUnit : TDelphiUnit; pJson: TJSONPair);\nvar\n  vTypeInfo: TUnitTypeDefinition;\n  vJsonProps: TJSONObject;\n  vFieldInfo: TUnitFieldDefinition;\n  vTypeObj: TJSONObject;\n  vJsonPropIndex: Integer;\n  vValue : string;\nbegin\n  OutputDebugString(PChar('Child: ' + pJson.ToJSON));\n  vTypeInfo := TUnitTypeDefinition.Create;\n  vTypeInfo.TypeName := 'T' + CapitalizeFirstLetter(pJson.JSONString.Value);\n\n  vJsonProps := (pJson.JSONValue as TJSONObject).Values['properties'] as TJSONObject;\n  for vJsonPropIndex := 0 to vJsonProps.Count - 1 do\n  begin\n    OutputDebugString(PChar(vJsonProps.Pairs[vJsonPropIndex].ToJSON));\n    vFieldInfo := TUnitFieldDefinition.Create;\n    vFieldInfo.FieldName := vJsonProps.Pairs[vJsonPropIndex].JsonString.Value;\n    vTypeObj := vJsonProps.Pairs[vJsonPropIndex].JsonValue as TJSONObject;\n    vFieldInfo.FieldType := vTypeObj.Values['type'].Value;\n    if vFieldInfo.FieldType = 'number' then\n      vFieldInfo.FieldType := 'Double'\n    else if vFieldInfo.FieldType = 'object' then\n    begin\n      vFieldInfo.FieldType := 'T' + CapitalizeFirstLetter(vJsonProps.Pairs[vJsonPropIndex].JsonString.Value);\n      ChildType(pDelphiUnit, vJsonProps.Pairs[vJsonPropIndex]);\n    end;\n    if vTypeObj.TryGetValue('description', vValue) then\n      vFieldInfo.AddAttribute('[MVCDoc(' + QuotedStr(vValue) + ')]');\n\n    if vTypeObj.TryGetValue('format', vValue) then\n    begin\n      if (vFieldInfo.FieldType.ToLower = 'integer') and (vValue.ToLower = 'int64') then\n        vFieldInfo.FieldType := 'Int64';\n      vFieldInfo.AddAttribute('[MVCFormat(' + QuotedStr(vValue) + ')]');\n    end;\n    if vTypeObj.TryGetValue('maxLength', vValue) then\n      vFieldInfo.AddAttribute('[MVCMaxLength(' + vValue + ')]');\n    vTypeInfo.Fields.Add(vFieldInfo);\n  end;\n  pDelphiUnit.AddType(vTypeInfo);\nend;\n\nprocedure TSwagDocToDelphiRESTClientBuilder.ConvertSwaggerDefinitionsToTypeDefinitions(pDelphiUnit: TDelphiUnit);\nvar\n  vTypeInfo: TUnitTypeDefinition;\n  vJsonProps: TJSONObject;\n  vFieldInfo: TUnitFieldDefinition;\n  vTypeObj: TJSONObject;\n  DefinitionIndex: Integer;\n  vJsonPropIndex: Integer;\n  vValue : string;\nbegin\n  for DefinitionIndex := 0 to fSwagDoc.Definitions.Count - 1 do\n  begin\n    vTypeInfo := TUnitTypeDefinition.Create;\n    vTypeInfo.TypeName := 'T' + CapitalizeFirstLetter(fSwagDoc.Definitions[DefinitionIndex].Name);\n    vJsonProps := fSwagDoc.Definitions[DefinitionIndex].JsonSchema.Values['properties'] as TJSONObject;\n    for vJsonPropIndex := 0 to vJsonProps.Count - 1 do\n    begin\n      OutputDebugString(PChar(vJsonProps.Pairs[vJsonPropIndex].ToJSON));\n      vFieldInfo := TUnitFieldDefinition.Create;\n      vFieldInfo.FieldName := vJsonProps.Pairs[vJsonPropIndex].JsonString.Value;\n      vTypeObj := vJsonProps.Pairs[vJsonPropIndex].JsonValue as TJSONObject;\n      if Assigned(vTypeObj.Values['type']) then\n        vFieldInfo.FieldType := vTypeObj.Values['type'].Value\n      else\n        vFieldInfo.FieldType := ConvertRefToType(vTypeObj.Values['$ref'].Value);\n\n      if vFieldInfo.FieldType = 'number' then\n        vFieldInfo.FieldType := 'Double'\n      else if vFieldInfo.FieldType = 'object' then\n      begin\n        vFieldInfo.FieldType := 'T' + CapitalizeFirstLetter(vJsonProps.Pairs[vJsonPropIndex].JsonString.Value);\n        ChildType(pDelphiUnit, vJsonProps.Pairs[vJsonPropIndex]);\n      end\n      else if vFieldInfo.FieldType = 'array' then\n      begin\n        HandleArray(vFieldInfo, vJsonProps.Pairs[vJsonPropIndex]);\n      end;\n      if vTypeObj.TryGetValue('description', vValue) then\n      begin\n        if vValue.Trim.Length > 0 then\n          vFieldInfo.AddAttribute('[MVCDoc(' + QuotedStr(vValue) + ')]');\n      end;\n      if vTypeObj.TryGetValue('format', vValue) then\n      begin\n        if (vFieldInfo.FieldType.ToLower = 'integer') and (vValue.ToLower = 'int64') then\n          vFieldInfo.FieldType := 'Int64';\n        vFieldInfo.AddAttribute('[MVCFormat(' + QuotedStr(vValue) + ')]');\n      end;\n      if vTypeObj.TryGetValue('maxLength', vValue) then\n        vFieldInfo.AddAttribute('[MVCMaxLength(' + vValue + ')]');\n      if vTypeObj.TryGetValue('minimum', vValue) then\n        vFieldInfo.AddAttribute('[MVCMinimum(' + vValue + ')]');\n      if vTypeObj.TryGetValue('maximum', vValue) then\n        vFieldInfo.AddAttribute('[MVCMaximum(' + vValue + ')]');\n      vTypeInfo.Fields.Add(vFieldInfo);\n    end;\n    pDelphiUnit.AddType(vTypeInfo);\n  end;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertSwaggerTypeToDelphiType(pSwaggerType: TSwagRequestParameter): TUnitTypeDefinition;\nvar\n  vSwaggerType: TSwagTypeParameter;\n  vJson: TJSONObject;\nbegin\n  Result := TUnitTypeDefinition.Create;\n  vSwaggerType := pSwaggerType.TypeParameter;\n  case vSwaggerType of\n    stpNotDefined:\n    begin\n      if Assigned(pSwaggerType.Schema.JsonSchema.Values['$ref']) then\n        Result.TypeName := ConvertRefToType(pSwaggerType.Schema.JsonSchema.Values['$ref'].Value)\n      else\n      begin\n        Result.TypeName := pSwaggerType.Schema.JsonSchema.Values['type'].Value;\n        if Result.TypeName = 'array' then\n        begin\n          if Assigned(pSwaggerType.Schema.JsonSchema.Values['items']) then\n            if Assigned((pSwaggerType.Schema.JsonSchema.Values['items'] as TJSONObject).Values['$ref']) then\n              Result.TypeName := 'array of ' + ConvertRefToType((pSwaggerType.Schema.JsonSchema.Values['items'] as TJSONObject).Values['$ref'].Value);\n        end;\n      end;\n    end;\n    stpString: Result.TypeName := 'String';\n    stpNumber: Result.TypeName := 'Double';\n    stpInteger: Result.TypeName := 'Integer';\n    stpBoolean: Result.TypeName := 'Boolean';\n    stpArray:\n    begin\n      vJson := pSwaggerType.Schema.JsonSchema;\n      if Assigned(vJson) then\n      begin\n        OutputDebugString(PChar('TYPE: ' + vJson.ToJson));\n        Result.TypeName := 'array of ' + pSwaggerType.Schema.JsonSchema.Values['type'].Value;\n      end\n      else\n      begin\n        if Assigned(pSwaggerType.Items.Values['type']) then\n        begin\n          Result.TypeName := 'array of ' + pSwaggerType.Items.Values['type'].Value;\n        end\n        else\n          Result.TypeName := 'array of ';\n      end;\n    end;\n    stpFile: Result.TypeName := 'err File';\n  end;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.GenerateUnitText(pDelphiUnit: TDelphiUnit): string;\nbegin\n  pDelphiUnit.Title := fSwagDoc.Info.Title;\n  pDelphiUnit.Description := fSwagDoc.Info.Description;\n  pDelphiUnit.License := fSwagDoc.Info.License.Name;\n  Result := pDelphiUnit.Generate;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing Swag.Doc;\nusing Swag.Common.Types;\nusing Swag.Doc.Path.Operation;\nusing Swag.Doc.Path.Operation.Response;\nusing Swag.Doc.Path.Operation.RequestParameter;\nusing Sample.DelphiUnit.Generate;\nusing System.Text;\n\nnamespace Sample.MvcControllerClientFileBuilder\n{\n    public class SwagDocToDelphiRESTClientBuilder\n    {\n        private TSwagDoc _swagDoc;\n        public SwagDocToDelphiRESTClientBuilder(TSwagDoc pSwagDoc)\n        {\n            _swagDoc = pSwagDoc;\n        }\n        private string CapitalizeFirstLetter(string pTypeName)\n        {\n            if (pTypeName.Length > 2)\n                return char.ToUpper(pTypeName[0]) + pTypeName.Substring(1);\n            return pTypeName;\n        }\n        private string RewriteUriToSwaggerWay(string pUri)\n        {\n            return pUri.Replace(\"{\", \"($\").Replace(\"}\", \")\");\n        }\n        private string OperationIdToFunctionName(TSwagPathOperation pOperation)\n        {\n            string result = pOperation.OperationId.Replace(\"{\", \"\").Replace(\"}\", \"\").Replace(\"-\", \"\");\n            if (!char.IsLetter(result[0]))\n                result = \"F\" + result;\n            return CapitalizeFirstLetter(result);\n        }\n        private string GenerateUnitText(TDelphiUnit pDelphiUnit)\n        {\n            pDelphiUnit.Title = _swagDoc.Info.Title;\n            pDelphiUnit.Description = _swagDoc.Info.Description;\n            pDelphiUnit.License = _swagDoc.Info.License.Name;\n            return pDelphiUnit.Generate();\n        }\n        private TUnitTypeDefinition ConvertSwaggerTypeToDelphiType(TSwagRequestParameter pSwaggerType)\n        {\n            TUnitTypeDefinition result = new TUnitTypeDefinition();\n            TSwagTypeParameter vSwaggerType = pSwaggerType.TypeParameter;\n            switch (vSwaggerType)\n            {\n                case TSwagTypeParameter.stpNotDefined:\n                    if (pSwaggerType.Schema.JsonSchema.TryGetValue(\"$ref\", out string refValue) && !string.IsNullOrEmpty(refValue))\n                        result.TypeName = ConvertRefToType(refValue);\n                    else\n                    {\n                        result.TypeName = pSwaggerType.Schema.JsonSchema.GetValue(\"type\").ToString();\n                        if (result.TypeName.ToLower() == \"array\")\n                        {\n                            if (pSwaggerType.Schema.JsonSchema.TryGetValue(\"items\", out string itemsJson))\n                                result.TypeName = \"array of \" + pSwaggerType.Schema.JsonSchema.GetValue(\"type\").ToString();\n                        }\n                    }\n                    break;\n                case TSwagTypeParameter.stpString:\n                    result.TypeName = \"String\";\n                    break;\n                case TSwagTypeParameter.stpNumber:\n                    result.TypeName = \"Double\";\n                    break;\n                case TSwagTypeParameter.stpInteger:\n                    result.TypeName = \"Integer\";\n                    break;\n                case TSwagTypeParameter.stpBoolean:\n                    result.TypeName = \"Boolean\";\n                    break;\n                case TSwagTypeParameter.stpArray:\n                    {\n                        var vJson = pSwaggerType.Schema.JsonSchema;\n                        if (vJson != null)\n                            result.TypeName = \"array of \" + vJson.GetValue(\"type\").ToString();\n                        else\n                        {\n                            if (pSwaggerType.Items.Values.TryGetValue(\"type\", out object typeObj))\n                                result.TypeName = \"array of \" + typeObj.ToString();\n                            else\n                                result.TypeName = \"array of \";\n                        }\n                    }\n                    break;\n                case TSwagTypeParameter.stpFile:\n                    result.TypeName = \"err File\";\n                    break;\n            }\n            return result;\n        }\n        private string ConvertRefToType(string pRef)\n        {\n            int idx = pRef.LastIndexOf('/');\n            string result = pRef.Substring(idx + 1);\n            result = char.ToUpper(result[0]) + result.Substring(1);\n            if (result.ToLower() != \"string\")\n                result = \"T\" + result;\n            return result;\n        }\n        private string ConvertRefToVarName(string pRef)\n        {\n            int idx = pRef.LastIndexOf('/');\n            return pRef.Substring(idx + 1);\n        }\n        private void ChildType(TDelphiUnit pDelphiUnit, TJsonPair pJson)\n        {\n            TUnitTypeDefinition vTypeInfo = new TUnitTypeDefinition();\n            vTypeInfo.TypeName = \"T\" + CapitalizeFirstLetter(pJson.JsonString.Value);\n            TJsonObject vJsonProps = pJson.JsonValue.GetValue(\"properties\") as TJsonObject;\n            for (int i = 0; i < vJsonProps.Count; i++)\n            {\n                TUnitFieldDefinition vFieldInfo = new TUnitFieldDefinition();\n                vFieldInfo.FieldName = vJsonProps.Pairs[i].JsonString.Value;\n                TJsonObject vTypeObj = vJsonProps.Pairs[i].JsonValue as TJsonObject;\n                vFieldInfo.FieldType = vTypeObj.GetValue(\"type\").ToString();\n                if (vFieldInfo.FieldType == \"number\")\n                    vFieldInfo.FieldType = \"Double\";\n                else if (vFieldInfo.FieldType == \"object\")\n                {\n                    vFieldInfo.FieldType = \"T\" + CapitalizeFirstLetter(vJsonProps.Pairs[i].JsonString.Value);\n                    ChildType(pDelphiUnit, vJsonProps.Pairs[i]);\n                }\n                if (vTypeObj.TryGetValue(\"description\", out object vValue))\n                    vFieldInfo.AddAttribute(\"[MVCDoc(\" + Quote(vValue.ToString()) + \")]\");\n                if (vTypeObj.TryGetValue(\"format\", out vValue))\n                {\n                    if (vFieldInfo.FieldType.ToLower() == \"integer\" && vValue.ToString().ToLower() == \"int64\")\n                        vFieldInfo.FieldType = \"Int64\";\n                    vFieldInfo.AddAttribute(\"[MVCFormat(\" + Quote(vValue.ToString()) + \")]\");\n                }\n                if (vTypeObj.TryGetValue(\"maxLength\", out vValue))\n                    vFieldInfo.AddAttribute(\"[MVCMaxLength(\" + vValue.ToString() + \")]\");\n                vTypeInfo.Fields.Add(vFieldInfo);\n            }\n            pDelphiUnit.AddType(vTypeInfo);\n        }\n        private void HandleArray(TUnitFieldDefinition pField, TJsonPair pJson)\n        {\n            TJsonObject jsonObj = pJson.JsonValue as TJsonObject;\n            if (jsonObj.Values.ContainsKey(\"items\") && (jsonObj.Values[\"items\"] as TJsonObject).Values.ContainsKey(\"type\"))\n            {\n                string vType = (jsonObj.Values[\"items\"] as TJsonObject).Values[\"type\"].ToString();\n                if (vType.ToLower() != \"string\")\n                    vType = \"T\" + vType;\n                pField.FieldType = \"array of \" + vType;\n            }\n            else\n            {\n                TJsonObject vJsonVal = jsonObj.Values[\"items\"] as TJsonObject;\n                string vRef = vJsonVal.Values[\"$ref\"].ToString();\n                pField.FieldType = \"array of \" + ConvertRefToType(vRef);\n            }\n        }\n        private void ConvertSwaggerDefinitionsToTypeDefinitions(TDelphiUnit pDelphiUnit)\n        {\n            for (int i = 0; i < _swagDoc.Definitions.Count; i++)\n            {\n                TUnitTypeDefinition vTypeInfo = new TUnitTypeDefinition();\n                vTypeInfo.TypeName = \"T\" + CapitalizeFirstLetter(_swagDoc.Definitions[i].Name);\n                TJsonObject vJsonProps = _swagDoc.Definitions[i].JsonSchema.GetValue(\"properties\") as TJsonObject;\n                for (int j = 0; j < vJsonProps.Count; j++)\n                {\n                    TUnitFieldDefinition vFieldInfo = new TUnitFieldDefinition();\n                    vFieldInfo.FieldName = vJsonProps.Pairs[j].JsonString.Value;\n                    TJsonObject vTypeObj = vJsonProps.Pairs[j].JsonValue as TJsonObject;\n                    if (vTypeObj.Values.ContainsKey(\"type\"))\n                        vFieldInfo.FieldType = vTypeObj.Values[\"type\"].ToString();\n                    else\n                        vFieldInfo.FieldType = ConvertRefToType(vTypeObj.Values[\"$ref\"].ToString());\n                    if (vFieldInfo.FieldType == \"number\")\n                        vFieldInfo.FieldType = \"Double\";\n                    else if (vFieldInfo.FieldType == \"object\")\n                    {\n                        vFieldInfo.FieldType = \"T\" + CapitalizeFirstLetter(vJsonProps.Pairs[j].JsonString.Value);\n                        ChildType(pDelphiUnit, vJsonProps.Pairs[j]);\n                    }\n                    else if (vFieldInfo.FieldType == \"array\")\n                    {\n                        HandleArray(vFieldInfo, vJsonProps.Pairs[j]);\n                    }\n                    if (vTypeObj.TryGetValue(\"description\", out object vValue) && vValue.ToString().Trim().Length > 0)\n                        vFieldInfo.AddAttribute(\"[MVCDoc(\" + Quote(vValue.ToString()) + \")]\");\n                    if (vTypeObj.TryGetValue(\"format\", out vValue))\n                    {\n                        if (vFieldInfo.FieldType.ToLower() == \"integer\" && vValue.ToString().ToLower() == \"int64\")\n                            vFieldInfo.FieldType = \"Int64\";\n                        vFieldInfo.AddAttribute(\"[MVCFormat(\" + Quote(vValue.ToString()) + \")]\");\n                    }\n                    if (vTypeObj.TryGetValue(\"maxLength\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMaxLength(\" + vValue.ToString() + \")]\");\n                    if (vTypeObj.TryGetValue(\"minimum\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMinimum(\" + vValue.ToString() + \")]\");\n                    if (vTypeObj.TryGetValue(\"maximum\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMaximum(\" + vValue.ToString() + \")]\");\n                    vTypeInfo.Fields.Add(vFieldInfo);\n                }\n                pDelphiUnit.AddType(vTypeInfo);\n            }\n        }\n        private string Quote(string s)\n        {\n            return \"\\\"\" + s + \"\\\"\";\n        }\n        public string Generate()\n        {\n            TDelphiUnit vDelphiUnit = new TDelphiUnit();\n            vDelphiUnit.UnitFile = \"UnitFilenameMvcControllerClient\";\n            vDelphiUnit.AddInterfaceUnit(\"IPPeerClient\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Client\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Authenticator.OAuth\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Types\");\n            vDelphiUnit.AddInterfaceUnit(\"MVCFramework\");\n            vDelphiUnit.AddInterfaceUnit(\"MVCFramework.Commons\");\n            ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n            TUnitTypeDefinition vMVCControllerClient = new TUnitTypeDefinition();\n            vMVCControllerClient.TypeName = \"TMyMVCControllerClient\";\n            vMVCControllerClient.TypeInherited = \"TObject\";\n            vMVCControllerClient.AddAttribute(\"  [MVCPath('\" + RewriteUriToSwaggerWay(_swagDoc.BasePath) + \"')]\");\n\n            TUnitFieldDefinition vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTClient\";\n            vField.FieldType = \"TRESTClient\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTRequest\";\n            vField.FieldType = \"TRESTRequest\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTResponse\";\n            vField.FieldType = \"TRESTResponse\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vDelphiUnit.AddType(vMVCControllerClient);\n            ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n            for (int pathIndex = 0; pathIndex < _swagDoc.Paths.Count; pathIndex++)\n            {\n                for (int opIndex = 0; opIndex < _swagDoc.Paths[pathIndex].Operations.Count; opIndex++)\n                {\n                    TUnitMethod vMethod = new TUnitMethod();\n                    if (_swagDoc.Paths[pathIndex].Operations[opIndex].Description.Trim().Length > 0)\n                        vMethod.AddAttribute(\"    [MVCDoc(\" + Quote(_swagDoc.Paths[pathIndex].Operations[opIndex].Description) + \")]\");\n                    vMethod.AddAttribute(\"    [MVCPath('\" + _swagDoc.Paths[pathIndex].Uri + \"')]\"); \n                    vMethod.AddAttribute(\"    [MVCHTTPMethod([http\" + _swagDoc.Paths[pathIndex].Operations[opIndex].OperationToString + \"])]\");\n                    vMethod.Name = OperationIdToFunctionName(_swagDoc.Paths[pathIndex].Operations[opIndex]);\n                    for (int paramIndex = 0; paramIndex < _swagDoc.Paths[pathIndex].Operations[opIndex].Parameters.Count; paramIndex++)\n                    {\n                        TUnitParameter vResultParam = new TUnitParameter();\n                        vResultParam.ParamName = CapitalizeFirstLetter(_swagDoc.Paths[pathIndex].Operations[opIndex].Parameters[paramIndex].Name);\n                        vResultParam.ParamType = ConvertSwaggerTypeToDelphiType(_swagDoc.Paths[pathIndex].Operations[opIndex].Parameters[paramIndex]);\n                        vMethod.AddParameter(vResultParam);\n                    }\n                    foreach (var response in _swagDoc.Paths[pathIndex].Operations[opIndex].Responses)\n                    {\n                        TJsonObject vSchemaObj = response.Value.Schema.JsonSchema;\n                        if (vSchemaObj == null)\n                            continue;\n                        if (vSchemaObj.TryGetValue(\"$ref\", out string vRef))\n                        {\n                            vMethod.AddAttribute(\"    [MVCResponse(\" + response.Key + \", \" + Quote(response.Value.Description) + \", \" + ConvertRefToType(vRef) + \")]\");\n                            TUnitParameter vResultParam = new TUnitParameter();\n                            vResultParam.ParamName = ConvertRefToVarName(vRef);\n                            vResultParam.ParamType = new TUnitTypeDefinition { TypeName = ConvertRefToType(vRef) };\n                            vMethod.AddLocalVariable(vResultParam);\n                            vMethod.Content.Add(\"  \" + ConvertRefToVarName(vRef) + \" := \" + ConvertRefToType(vRef) + \".Create;\");\n                        }\n                        else\n                        {\n                            if (!vSchemaObj.TryGetValue(\"properties\", out _))\n                                continue;\n                            if (!vSchemaObj.TryGetValue(\"employees\", out _))\n                                continue;\n                            if (!vSchemaObj.TryGetValue(\"items\", out _))\n                                continue;\n                            if (vSchemaObj.TryGetValue(\"$ref\", out vRef))\n                            {\n                                vMethod.AddAttribute(\"    [MVCResponseList(\" + response.Key + \", \" + Quote(response.Value.Description) + \", \" + ConvertRefToType(vRef) + \")]\");\n                                TUnitParameter vResultParam = new TUnitParameter();\n                                vResultParam.ParamName = ConvertRefToVarName(vRef);\n                                vResultParam.ParamType = new TUnitTypeDefinition { TypeName = \"TObjectList<\" + ConvertRefToType(vRef) + \">\" };\n                                vMethod.AddLocalVariable(vResultParam);\n                                vDelphiUnit.AddInterfaceUnit(\"Generics.Collections\");\n                                vMethod.Content.Add(\"  \" + ConvertRefToVarName(vRef) + \" := TObjectList<\" + ConvertRefToType(vRef) + \">.Create;\");\n                            }\n                        }\n                    }\n                    vMVCControllerClient.Methods.Add(vMethod);\n                }\n            }\n            vDelphiUnit.SortTypeDefinitions();\n            return GenerateUnitText(vDelphiUnit);\n        }\n    }\n}"}
{"input": "unit Controller.Customers;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.ActiveRecord,\n  FireDAC.Comp.Client,\n  FireDAC.Phys.SQLite,\n  MVCFramework.SQLGenerators.Sqlite,\n  System.Generics.Collections,\n  Model.Customer,\n  System.JSON;\n\ntype\n\n  [MVCPath('/api')]\n  TCustomersController = class(TMVCController)\n  private\n    FDConn : TFDConnection;\n  public\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomers;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomer(id: Integer);\n\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure CreateCustomer;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    procedure UpdateCustomer(id: Integer);\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    procedure DeleteCustomer(id: Integer);\n\n    constructor Create; override;\n    destructor Destroy; override;\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\n\n//Sample CRUD Actions for a \"Customer\" entity\nprocedure TCustomersController.GetCustomers;\nbegin\n  Render<TCustomer>(TMVCActiveRecord.SelectRQL<TCustomer>('sort(+id)', 200));\nend;\n\nprocedure TCustomersController.GetCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := TMVCActiveRecord.GetByPK<TCustomer>(id);\n\n  Render(lCustomer);\nend;\n\nconstructor TCustomersController.Create;\nbegin\n  inherited;\n  FDConn := TFDConnection.Create(nil);\n  FDConn.Params.Clear;\n  FDConn.Params.Database :=  '../../../data/activerecorddb.db';\n  FDConn.DriverName := 'SQLite';\n  FDConn.Connected := True;\n\n  ActiveRecordConnectionsRegistry.AddDefaultConnection(FDConn);\nend;\n\nprocedure TCustomersController.CreateCustomer;\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := Context.Request.BodyAs<TCustomer>;\n  try\n    lCustomer.Insert;\n  finally\n    lCustomer.Free;\n  end;\n  Render201Created();\nend;\n\nprocedure TCustomersController.UpdateCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := Context.Request.BodyAs<TCustomer>;\n  lCustomer.id := id;\n\n  lCustomer.Update;\n  Render(lCustomer);\nend;\n\nprocedure TCustomersController.DeleteCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := TMVCActiveRecord.GetByPK<TCustomer>(id);\n  lCustomer.Delete;\n\n  Render(TJSONObject.Create(TJSONPair.Create('result', 'register successefully deleted')));\nend;\n\ndestructor TCustomersController.Destroy;\nbegin\n  ActiveRecordConnectionsRegistry.RemoveDefaultConnection;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Data.Sqlite;\n\nnamespace Controller.Customers\n{\n   \n    [Route(\"api\")]\n    [ApiController]\n    public class CustomersController : ControllerBase, IDisposable\n    {\n        private SqliteConnection _fdConn;\n\n        public CustomersController()\n        {\n            var connectionString = new SqliteConnectionStringBuilder\n            {\n                DataSource = \"../../../data/activerecorddb.db\"\n            }.ToString();\n\n            _fdConn = new SqliteConnection(connectionString);\n            _fdConn.Open();\n\n            ActiveRecordConnectionsRegistry.AddDefaultConnection(_fdConn);\n        }\n\n        \n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n            \n            List<TCustomer> customers = TMVCActiveRecord.SelectRQL<TCustomer>(\"sort(+id)\", 200);\n            return Ok(customers);\n        }\n\n        \n        [HttpGet(\"customers/{id}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            TCustomer customer = TMVCActiveRecord.GetByPK<TCustomer>(id);\n            if (customer == null)\n                return NotFound();\n\n            return Ok(customer);\n        }\n\n        \n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer([FromBody] TCustomer customer)\n        {\n            if (customer == null)\n                return BadRequest();\n\n            try\n            {\n                customer.Insert();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            \n            return StatusCode(201);\n        }\n\n        \n        [HttpPut(\"customers/{id}\")]\n        public IActionResult UpdateCustomer(int id, [FromBody] TCustomer customer)\n        {\n            if (customer == null)\n                return BadRequest();\n\n            \n            customer.ID = id;\n\n            try\n            {\n                customer.Update();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            return Ok(customer);\n        }\n\n        \n        [HttpDelete(\"customers/{id}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            TCustomer customer = TMVCActiveRecord.GetByPK<TCustomer>(id);\n            if (customer == null)\n                return NotFound();\n\n            try\n            {\n                customer.Delete();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            \n            return Ok(new { result = \"register successefully deleted\" });\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                ActiveRecordConnectionsRegistry.RemoveDefaultConnection();\n                if (_fdConn != null)\n                {\n                    _fdConn.Close();\n                    _fdConn.Dispose();\n                    _fdConn = null;\n                }\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n    }\n\n    \n    public static class ActiveRecordConnectionsRegistry\n    {\n        private static SqliteConnection _defaultConnection;\n        public static void AddDefaultConnection(SqliteConnection connection)\n        {\n            _defaultConnection = connection;\n        }\n\n        public static void RemoveDefaultConnection()\n        {\n            _defaultConnection = null;\n        }\n\n        public static SqliteConnection DefaultConnection => _defaultConnection;\n    }\n\n        public abstract class TMVCActiveRecord\n    {\n        public abstract void Insert();\n        public abstract void Update();\n        public abstract void Delete();\n\n        \n        public static List<T> SelectRQL<T>(string query, int limit) where T : TMVCActiveRecord, new()\n        {\n            \n            return new List<T>();\n        }\n\n        \n        public static T GetByPK<T>(int id) where T : TMVCActiveRecord, new()\n        {\n            \n            return new T();\n        }\n    }\n\n    \n    public class TCustomer : TMVCActiveRecord\n    {\n        public int ID { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        \n\n        public override void Insert()\n        {\n            // Insert logic here.\n        }\n\n        public override void Update()\n        {\n            // Update logic here.\n        }\n\n        public override void Delete()\n        {\n            // Delete logic here.\n        }\n    }\n}"}
{"input": "/// Framework Core Low-Level Wrappers to the Operating-System API\n// - this unit is a part of the Open Source Synopse mORMot framework 2,\n// licensed under a MPL/GPL/LGPL three license - see LICENSE.md\nunit mormot.core.os;\n\n{\n  *****************************************************************************\n\n  Cross-platform functions shared by all framework units\n  - Some Cross-System Type and Constant Definitions\n  - Gather Operating System Information\n  - Operating System Specific Types (e.g. TWinRegistry)\n  - Unicode, Time, File, Console, Library process\n  - Cross-Platform Charset and CodePage Support\n  - Per Class Properties O(1) Lookup via vmtAutoTable Slot (e.g. for RTTI cache)\n  - TSynLocker/TSynLocked and Low-Level Threading Features\n  - Unix Daemon and Windows Service Support\n\n   Aim of this unit is to centralize most used OS-specific API calls, like a\n  SysUtils unit on steroids, to avoid $ifdef/$endif in \"uses\" clauses.\n   In practice, no \"Windows\", nor \"Linux/Posix\" reference should be needed in\n  regular units, once mormot.core.os is included. :)\n   This unit only refers to mormot.core.base so can be used almost stand-alone.\n\n  *****************************************************************************\n}\n\ninterface\n\n{$I mormot.defines.inc}\n\nuses\n  {$ifdef OSWINDOWS}\n  Windows, // needed here e.g. for redefinition/redirection of standard types\n  Messages,\n  {$endif OSWINDOWS}\n  classes,\n  contnrs,\n  types,\n  sysutils,\n  mormot.core.base;\n\n\n{ ****************** Some Cross-System Type and Constant Definitions }\n\nconst\n  {$ifdef OSWINDOWS}\n  /// operating-system dependent Line Feed characters (#13#10 or #10)\n  CRLF = #13#10;\n  /// operating-system dependent wildchar to match all files in a folder\n  FILES_ALL = '*.*';\n  /// operating-system dependent \"inverted\" delimiter for NormalizeFileName()\n  InvertedPathDelim = '/';\n  /// operating-system dependent boolean if paths are case-insensitive\n  PathCaseInsensitive = true;\n  {$else}\n  /// operating-system dependent Line Feed characters\n  CRLF = #10;\n  /// operating-system dependent wildchar to match all files in a folder\n  FILES_ALL = '*';\n  /// operating-system dependent \"inverted\" delimiter for NormalizeFileName()\n  InvertedPathDelim = '\\';\n  /// operating-system dependent boolean if paths are case-insensitive\n  PathCaseInsensitive = false;\n  {$endif OSWINDOWS}\n\n  /// human-friendly alias to open a file for exclusive writing\n  fmShareRead      = fmShareDenyWrite;\n  /// human-friendly alias to open a file for exclusive reading\n  fmShareWrite     = fmShareDenyRead;\n  /// human-friendly alias to open a file with no read/write exclusion\n  fmShareReadWrite = fmShareDenyNone;\n\n  /// a convenient constant to open a file for reading without exclusion\n  fmOpenReadShared = fmOpenRead or fmShareReadWrite;\n\n  /// a convenient constant to open a file for writing without exclusion\n  fmOpenWriteShared = fmOpenReadWrite or fmShareReadWrite;\n\n  /// a convenient constant to create a file without exclusion\n  fmCreateShared = fmCreate or fmShareReadWrite;\n\n  /// a convenient array constant to open a file for writing without exclusion\n  fmCreateOrRewrite: array[{rewrite=}boolean] of cardinal = (\n   fmCreateShared,\n   fmOpenWriteShared);\n\nconst\n  /// void HTTP Status Code (not a standard value, for internal use only)\n  HTTP_NONE = 0;\n  /// HTTP Status Code for \"Continue\"\n  HTTP_CONTINUE = 100;\n  /// HTTP Status Code for \"Switching Protocols\"\n  HTTP_SWITCHINGPROTOCOLS = 101;\n  /// HTTP Status Code for \"Success\"\n  HTTP_SUCCESS = 200;\n  /// HTTP Status Code for \"Created\"\n  HTTP_CREATED = 201;\n  /// HTTP Status Code for \"Accepted\"\n  HTTP_ACCEPTED = 202;\n  /// HTTP Status Code for \"Non-Authoritative Information\"\n  HTTP_NONAUTHORIZEDINFO = 203;\n  /// HTTP Status Code for \"No Content\"\n  HTTP_NOCONTENT = 204;\n  /// HTTP Status Code for \"Reset Content\"\n  HTTP_RESETCONTENT = 205;\n  /// HTTP Status Code for \"Partial Content\"\n  HTTP_PARTIALCONTENT = 206;\n  /// HTTP Status Code for \"Multiple Choices\"\n  HTTP_MULTIPLECHOICES = 300;\n  /// HTTP Status Code for \"Moved Permanently\"\n  HTTP_MOVEDPERMANENTLY = 301;\n  /// HTTP Status Code for \"Found\"\n  HTTP_FOUND = 302;\n  /// HTTP Status Code for \"See Other\"\n  HTTP_SEEOTHER = 303;\n  /// HTTP Status Code for \"Not Modified\"\n  HTTP_NOTMODIFIED = 304;\n  /// HTTP Status Code for \"Use Proxy\"\n  HTTP_USEPROXY = 305;\n  /// HTTP Status Code for \"Temporary Redirect\"\n  HTTP_TEMPORARYREDIRECT = 307;\n  /// HTTP Status Code for \"Permanent Redirect\"\n  HTTP_PERMANENTREDIRECT = 308;\n  /// HTTP Status Code for \"Bad Request\"\n  HTTP_BADREQUEST = 400;\n  /// HTTP Status Code for \"Unauthorized\"\n  HTTP_UNAUTHORIZED = 401;\n  /// HTTP Status Code for \"Forbidden\"\n  HTTP_FORBIDDEN = 403;\n  /// HTTP Status Code for \"Not Found\"\n  HTTP_NOTFOUND = 404;\n  // HTTP Status Code for \"Method Not Allowed\"\n  HTTP_NOTALLOWED = 405;\n  // HTTP Status Code for \"Not Acceptable\"\n  HTTP_NOTACCEPTABLE = 406;\n  // HTTP Status Code for \"Proxy Authentication Required\"\n  HTTP_PROXYAUTHREQUIRED = 407;\n  /// HTTP Status Code for \"Request Time-out\"\n  HTTP_TIMEOUT = 408;\n  /// HTTP Status Code for \"Conflict\"\n  HTTP_CONFLICT = 409;\n  /// HTTP Status Code for \"Payload Too Large\"\n  HTTP_PAYLOADTOOLARGE = 413;\n  /// HTTP Status Code for \"Range Not Satisfiable\"\n  HTTP_RANGENOTSATISFIABLE = 416;\n  /// HTTP Status Code for \"I'm a teapot\"\n  HTTP_TEAPOT = 418;\n  /// HTTP Status Code for \"Internal Server Error\"\n  HTTP_SERVERERROR = 500;\n  /// HTTP Status Code for \"Not Implemented\"\n  HTTP_NOTIMPLEMENTED = 501;\n  /// HTTP Status Code for \"Bad Gateway\"\n  HTTP_BADGATEWAY = 502;\n  /// HTTP Status Code for \"Service Unavailable\"\n  HTTP_UNAVAILABLE = 503;\n  /// HTTP Status Code for \"Gateway Timeout\"\n  HTTP_GATEWAYTIMEOUT = 504;\n  /// HTTP Status Code for \"HTTP Version Not Supported\"\n  HTTP_HTTPVERSIONNONSUPPORTED = 505;\n\n  /// clearly wrong response code, used by THttpServerRequest.SetAsyncResponse\n  // - for internal THttpAsyncServer asynchronous process\n  HTTP_ASYNCRESPONSE = 777;\n\n  /// the successful HTTP response codes after a GET request\n  HTTP_GET_OK = [HTTP_SUCCESS, HTTP_NOCONTENT, HTTP_PARTIALCONTENT];\n\n/// retrieve the HTTP reason text from its integer code as PRawUtf8\n// - e.g. StatusCodeToText(200)^='OK'\n// - as defined in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n// - returns the generic 'Invalid Request' for any unknown Code\nfunction StatusCodeToText(Code: cardinal): PRawUtf8;\n\n/// retrieve the HTTP reason text from its integer code\n// - as defined in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\nprocedure StatusCodeToReason(Code: cardinal; var Reason: RawUtf8);\n\n/// convert any HTTP_* constant to an integer status code and its English text\n// - returns e.g. '200 OK' or '404 Not Found', calling StatusCodeToText()\nfunction StatusCodeToShort(Code: cardinal): TShort47;\n\n/// returns true for successful HTTP status codes, i.e. in 200..399 range\n// - will map mainly SUCCESS (200), CREATED (201), NOCONTENT (204),\n// PARTIALCONTENT (206), NOTMODIFIED (304) or TEMPORARYREDIRECT (307) codes\n// - any HTTP status not part of this range will be identified as erronous\n// request in the internal server statistics\nfunction StatusCodeIsSuccess(Code: integer): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// check the supplied HTTP header to not contain more than one EOL\n// - to avoid unexpected HTTP body injection, e.g. from unsafe business code\nfunction IsInvalidHttpHeader(head: PUtf8Char; headlen: PtrInt): boolean;\n\n\nconst\n  /// HTTP header name for the content type, as defined in the corresponding RFC\n  HEADER_CONTENT_TYPE = 'Content-Type: ';\n\n  /// HTTP header name for the content type, in upper case\n  // - as defined in the corresponding RFC\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  HEADER_CONTENT_TYPE_UPPER = 'CONTENT-TYPE: ';\n\n  /// HTTP header name for the client IP, in upper case\n  // - as defined in our HTTP server classes\n  // - could be used e.g. with IdemPChar() to retrieve the remote IP address\n  HEADER_REMOTEIP_UPPER = 'REMOTEIP: ';\n\n  /// HTTP header name for the authorization token, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve a JWT value\n  // - will detect header computed e.g. by motmot.net.http's\n  // AuthorizationBearer()\n  HEADER_BEARER_UPPER = 'AUTHORIZATION: BEARER ';\n\n  /// MIME content type used for JSON communication (as used by the Microsoft\n  // WCF framework and the YUI framework)\n  // - no 'charset=UTF-8' encoding is necessary, as by specified by RFC 7159\n  JSON_CONTENT_TYPE = 'application/json';\n\n  /// HTTP header for MIME content type used for plain JSON\n  // - i.e. 'Content-Type: application/json'\n  JSON_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + JSON_CONTENT_TYPE;\n\n  /// MIME content type used for plain JSON, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  JSON_CONTENT_TYPE_UPPER = 'APPLICATION/JSON';\n\n  /// HTTP header for MIME content type used for plain JSON, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  JSON_CONTENT_TYPE_HEADER_UPPER =\n    HEADER_CONTENT_TYPE_UPPER + JSON_CONTENT_TYPE_UPPER;\n\n  /// MIME content type used for plain UTF-8 text\n  TEXT_CONTENT_TYPE = 'text/plain; charset=UTF-8';\n\n  /// HTTP header for MIME content type used for plain UTF-8 text\n  TEXT_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + TEXT_CONTENT_TYPE;\n\n  /// MIME content type used for UTF-8 encoded HTML\n  HTML_CONTENT_TYPE = 'text/html; charset=UTF-8';\n\n  /// HTTP header for MIME content type used for UTF-8 encoded HTML\n  HTML_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + HTML_CONTENT_TYPE;\n\n  /// MIME content type used for UTF-8 encoded XML\n  XML_CONTENT_TYPE = 'text/xml';\n\n  /// HTTP header for MIME content type used for UTF-8 encoded XML\n  XML_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + XML_CONTENT_TYPE;\n\n  /// MIME content type used for raw binary data\n  BINARY_CONTENT_TYPE = 'application/octet-stream';\n\n  /// MIME content type used for raw binary data, in upper case\n  BINARY_CONTENT_TYPE_UPPER = 'APPLICATION/OCTET-STREAM';\n\n  /// HTTP header for MIME content type used for raw binary data\n  BINARY_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + BINARY_CONTENT_TYPE;\n\n  /// MIME content type used for a JPEG picture\n  JPEG_CONTENT_TYPE = 'image/jpeg';\n\n  /// a IdemPPChar() compatible array of textual MIME content types\n  // - as used e.g. by IsHtmlContentTypeTextual()\n  CONTENT_TYPE_TEXTUAL: array[0..7] of PAnsiChar = (\n    JSON_CONTENT_TYPE_UPPER,\n    'TEXT/',\n    'APPLICATION/XML',\n    'APPLICATION/JSON',\n    'APPLICATION/JAVASCRIPT',\n    'APPLICATION/X-JAVASCRIPT',\n    'IMAGE/SVG+XML',\n    nil);\n\n  /// internal HTTP content-type for efficient static file sending\n  // - detected e.g. by http.sys' THttpApiServer.Request or via the NGINX\n  // X-Accel-Redirect header's THttpServer.Process (see\n  // THttpServer.NginxSendFileFrom) for direct sending with no local bufferring\n  // - the OutCustomHeader should contain the proper 'Content-type: ....'\n  // corresponding to the file (e.g. by calling GetMimeContentType() function)\n  STATICFILE_CONTENT_TYPE = '!STATICFILE';\n\n  /// internal HTTP content-type Header for efficient static file sending\n  STATICFILE_CONTENT_TYPE_HEADER =\n    HEADER_CONTENT_TYPE + STATICFILE_CONTENT_TYPE;\n\n  /// uppercase version of HTTP header for static file content serving\n  STATICFILE_CONTENT_TYPE_HEADER_UPPPER =\n    HEADER_CONTENT_TYPE_UPPER + STATICFILE_CONTENT_TYPE;\n\n  /// used to notify e.g. the THttpServerRequest not to wait for any response\n  // from the client\n  // - is not to be used in normal HTTP process, but may be used e.g. by\n  // TWebSocketProtocolRest.ProcessFrame() to avoid to wait for an incoming\n  // response from the other endpoint\n  NORESPONSE_CONTENT_TYPE = '!NORESPONSE';\n\n  /// HTTP body following RFC 2324 standard e.g. for banned IP\n  HTTP_BANIP_RESPONSE: string[201] =\n    'HTTP/1.0 418 I''m a teapot'#13#10 +\n    'Content-Length: 125'#13#10 +\n    'Content-Type: text/plain'#13#10#13#10 +\n    'Server refuses to brew coffee because it is currently a teapot.'#13#10 +\n    'Do not mess with it and retry from this IP in a few seconds.';\n\n  /// JSON compatible representation of a boolean value, i.e. 'false' and 'true'\n  // - can be used e.g. in logs, or anything accepting a ShortString\n  BOOL_STR: array[boolean] of string[7] = (\n    'false', 'true');\n\n  /// the JavaScript-like values of non-number IEEE constants\n  // - as recognized by FloatToShortNan, and used by TTextWriter.Add()\n  // when serializing such single/double/extended floating-point values\n  JSON_NAN: array[TFloatNan] of string[11] = (\n    '0', '\"NaN\"', '\"Infinity\"', '\"-Infinity\"');\n\nvar\n  /// MIME content type used for JSON communication\n  // - i.e. 'application/json' as stated by datatracker.ietf.org/doc/html/rfc7159\n  // - this global will be initialized with JSON_CONTENT_TYPE constant, to\n  // avoid a memory allocation each time it is assigned to a variable\n  JSON_CONTENT_TYPE_VAR: RawUtf8;\n\n  /// HTTP header for MIME content type used for plain JSON\n  // - this global will be initialized with JSON_CONTENT_TYPE_HEADER constant,\n  // to avoid a memory allocation each time it is assigned to a variable\n  JSON_CONTENT_TYPE_HEADER_VAR: RawUtf8;\n\n  /// can be used to avoid a memory allocation for res := 'null'\n  // - this global will be initialized with 'null' constant, to\n  // avoid a memory allocation each time it is assigned to a variable\n  NULL_STR_VAR: RawUtf8;\n\n  /// JSON compatible representation of a boolean value, i.e. 'false' and 'true'\n  // - can be used when a RawUtf8 string is expected\n  // - this global will be initialized with 'false' and 'true' constants, to\n  // avoid a memory allocation each time it is assigned to a variable\n  BOOL_UTF8: array[boolean] of RawUtf8;\n\n\ntype\n  /// Security IDentifier (SID) Authority, encoded as 48-bit binary\n  TSidAuth = array[0..5] of byte;\n  PSidAuth = ^TSidAuth;\n\n  /// Security IDentifier (SID) binary format, as retrieved e.g. by Windows API\n  // - this definition is not detailed on oldest Delphi, and not available on\n  // POSIX, whereas it makes sense to also have it, e.g. for server process\n  TSid = packed record\n     Revision: byte;\n     SubAuthorityCount: byte;\n     IdentifierAuthority: TSidAuth;\n     SubAuthority: array[byte] of cardinal;\n  end;\n  PSid = ^TSid;\n  PSids = array of PSid;\n\n  /// define a list of well-known Security IDentifier (SID) groups\n  // - for instance, wksBuiltinAdministrators is set for local administrators\n  // - warning: does not exactly match winnt.h WELL_KNOWN_SID_TYPE enumeration\n  TWellKnownSid = (\n    wksNull,\n    wksWorld,\n    wksLocal,\n    wksConsoleLogon,\n    wksCreatorOwner,\n    wksCreatorGroup,\n    wksCreatorOwnerServer,\n    wksCreatorGroupServer,\n    wksIntegrityUntrusted,\n    wksIntegrityLow,\n    wksIntegrityMedium,\n    wksIntegrityMediumPlus,\n    wksIntegrityHigh,\n    wksIntegritySystem,\n    wksIntegrityProtectedProcess,\n    wksIntegritySecureProcess,\n    wksAuthenticationAuthorityAsserted,\n    wksAuthenticationServiceAsserted,\n    wksAuthenticationFreshKeyAuth,\n    wksAuthenticationKeyTrust,\n    wksAuthenticationKeyPropertyMfa,\n    wksAuthenticationKeyPropertyAttestation,\n    wksNtAuthority,\n    wksDialup,\n    wksNetwork,\n    wksBatch,\n    wksInteractive,\n    wksService,\n    wksAnonymous,\n    wksProxy,\n    wksEnterpriseControllers,\n    wksSelf,\n    wksAuthenticatedUser,\n    wksRestrictedCode,\n    wksTerminalServer,\n    wksRemoteLogonId,\n    wksThisOrganisation,\n    wksIisUser,\n    wksLocalSystem,\n    wksLocalService,\n    wksNetworkService,\n    wksLocalAccount,\n    wksLocalAccountAndAdministrator,\n    wksBuiltinDomain,\n    wksBuiltinAdministrators,\n    wksBuiltinUsers,\n    wksBuiltinGuests,\n    wksBuiltinPowerUsers,\n    wksBuiltinAccountOperators,\n    wksBuiltinSystemOperators,\n    wksBuiltinPrintOperators,\n    wksBuiltinBackupOperators,\n    wksBuiltinReplicator,\n    wksBuiltinRasServers,\n    wksBuiltinPreWindows2000CompatibleAccess,\n    wksBuiltinRemoteDesktopUsers,\n    wksBuiltinNetworkConfigurationOperators,\n    wksBuiltinIncomingForestTrustBuilders,\n    wksBuiltinPerfMonitoringUsers,\n    wksBuiltinPerfLoggingUsers,\n    wksBuiltinAuthorizationAccess,\n    wksBuiltinTerminalServerLicenseServers,\n    wksBuiltinDcomUsers,\n    wksBuiltinIUsers,\n    wksBuiltinCryptoOperators,\n    wksBuiltinUnknown,\n    wksBuiltinCacheablePrincipalsGroups,\n    wksBuiltinNonCacheablePrincipalsGroups,\n    wksBuiltinEventLogReadersGroup,\n    wksBuiltinCertSvcDComAccessGroup,\n    wksBuiltinRdsRemoteAccessServers,\n    wksBuiltinRdsEndpointServers,\n    wksBuiltinRdsManagementServers,\n    wksBuiltinHyperVAdmins,\n    wksBuiltinAccessControlAssistanceOperators,\n    wksBuiltinRemoteManagementUsers,\n    wksBuiltinDefaultSystemManagedGroup,\n    wksBuiltinStorageReplicaAdmins,\n    wksBuiltinDeviceOwners,\n    wksCapabilityInternetClient,\n    wksCapabilityInternetClientServer,\n    wksCapabilityPrivateNetworkClientServer,\n    wksCapabilityPicturesLibrary,\n    wksCapabilityVideosLibrary,\n    wksCapabilityMusicLibrary,\n    wksCapabilityDocumentsLibrary,\n    wksCapabilityEnterpriseAuthentication,\n    wksCapabilitySharedUserCertificates,\n    wksCapabilityRemovableStorage,\n    wksCapabilityAppointments,\n    wksCapabilityContacts,\n    wksBuiltinAnyPackage,\n    wksBuiltinAnyRestrictedPackage,\n    wksNtlmAuthentication,\n    wksSChannelAuthentication,\n    wksDigestAuthentication);\n\n  /// define a set of well-known SID\n  TWellKnownSids = set of TWellKnownSid;\n\n  /// custom binary buffer type used as convenient Windows SID storage\n  RawSid = type RawByteString;\n\n  /// a dynamic array of binary SID storage buffers\n  RawSidDynArray = array of RawSid;\n\n\n/// a wrapper around MemCmp() on two Security IDentifier binary buffers\n// - will first compare by length, then by content\nfunction SidCompare(a, b: PSid): integer;\n\n/// compute the actual binary length of a Security IDentifier buffer, in bytes\nfunction SidLength(sid: PSid): PtrInt;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// allocate a RawSid instance from a PSid raw handler\nprocedure ToRawSid(sid: PSid; out result: RawSid);\n\n/// check if a RawSid binary buffer has the expected length of a valid SID\nfunction IsValidRawSid(const sid: RawSid): boolean;\n\n/// search within SID dynamic array for a given SID\nfunction HasSid(const sids: PSids; sid: PSid): boolean;\n\n/// search within SID dynamic array for a given dynamic array of SID buffers\nfunction HasAnySid(const sids: PSids; const sid: RawSidDynArray): boolean;\n\n/// append a SID buffer pointer to a dynamic array of SID buffers\nprocedure AddRawSid(var sids: RawSidDynArray; sid: PSid);\n\n/// convert a Security IDentifier as text, following the standard representation\nprocedure SidToTextShort(sid: PSid; var result: shortstring);\n\n/// convert a Security IDentifier as text, following the standard representation\nfunction SidToText(sid: PSid): RawUtf8;\n\n/// convert several Security IDentifier as text dynamic array\nfunction SidsToText(sids: PSids): TRawUtf8DynArray;\n\n/// convert a Security IDentifier as text, following the standard representation\nfunction RawSidToText(const sid: RawSid): RawUtf8;\n\n/// parse a Security IDentifier text, following the standard representation\n// - won't support hexadecimal IdentifierAuthority, i.e. S-1-0x######-....\nfunction TextToSid(P: PUtf8Char; out sid: TSid): boolean;\n\n/// parse a Security IDentifier text, following the standard representation\nfunction TextToRawSid(const text: RawUtf8): RawSid; overload;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// parse a Security IDentifier text, following the standard representation\nfunction TextToRawSid(const text: RawUtf8; out sid: RawSid): boolean; overload;\n\n/// returns a Security IDentifier of a well-known SID as binary\n// - is using an internal cache for the returned RawSid instances\nfunction KnownRawSid(wks: TWellKnownSid): RawSid;\n\n/// returns a Security IDentifier of a well-known SID as standard text\n// - e.g. wksBuiltinAdministrators as 'S-1-5-32-544'\nfunction KnownSidToText(wks: TWellKnownSid): PShortString;\n\n/// recognize most well-known SID from a Security IDentifier binary buffer\n// - returns wksNull if the supplied buffer was not recognized\nfunction SidToKnown(sid: PSid): TWellKnownSid; overload;\n\n/// recognize most well-known SID from a Security IDentifier standard text\n// - returns wksNull if the supplied text was not recognized\nfunction SidToKnown(const text: RawUtf8): TWellKnownSid; overload;\n\n/// recognize some well-known SIDs from the supplied SID dynamic array\nfunction SidToKnownGroups(const sids: PSids): TWellKnownSids;\n\n\n{ ****************** Gather Operating System Information }\n\ntype\n  /// Exception types raised by this mormot.core.os unit\n  EOSException = class(ExceptionWithProps);\n\n  /// the known operating systems\n  // - it will also recognize most Linux distributions\n  TOperatingSystem = (\n    osUnknown,\n    osWindows,\n    osLinux,\n    osOSX,\n    osBSD,\n    osPOSIX,\n    osArch,\n    osAurox,\n    osDebian,\n    osFedora,\n    osGentoo,\n    osKnoppix,\n    osMint,\n    osMandrake,\n    osMandriva,\n    osNovell,\n    osUbuntu,\n    osSlackware,\n    osSolaris,\n    osSuse,\n    osSynology,\n    osTrustix,\n    osClear,\n    osUnited,\n    osRedHat,\n    osLFS,\n    osOracle,\n    osMageia,\n    osCentOS,\n    osCloud,\n    osXen,\n    osAmazon,\n    osCoreOS,\n    osAlpine,\n    osAndroid);\n\n  /// the recognized Windows versions\n  // - defined even outside OSWINDOWS to access e.g. from monitoring tools\n  TWindowsVersion = (\n    wUnknown,\n    w2000,\n    wXP,\n    wXP_64,\n    wServer2003,\n    wServer2003_R2,\n    wVista,\n    wVista_64,\n    wServer2008,\n    wServer2008_64,\n    wSeven,\n    wSeven_64,\n    wServer2008_R2,\n    wServer2008_R2_64,\n    wEight,\n    wEight_64,\n    wServer2012,\n    wServer2012_64,\n    wEightOne,\n    wEightOne_64,\n    wServer2012R2,\n    wServer2012R2_64,\n    wTen,\n    wTen_64,\n    wServer2016,\n    wServer2016_64,\n    wEleven,\n    wEleven_64,\n    wServer2019_64,\n    wServer2022_64);\n\n  /// the running Operating System, encoded as a 32-bit integer\n  TOperatingSystemVersion = packed record\n    case os: TOperatingSystem of\n    osUnknown: (\n      b: array[0..2] of byte);\n    osWindows: (\n      win: TWindowsVersion;\n      winbuild: word);\n    osLinux: (\n      utsrelease: array[0..2] of byte);\n  end;\n\nconst\n  /// the recognized MacOS versions, as plain text\n  // - indexed from OSVersion32.utsrelease[2] kernel revision\n  MACOS_NAME: array[8 .. 24] of RawUtf8 = (\n    '10.4 Tiger',\n    '10.5 Leopard',\n    '10.6 Snow Leopard',\n    '10.7 Lion',\n    '10.8 Mountain Lion',\n    '10.9 Mavericks',\n    '10.10 Yosemite',\n    '10.11 El Capitan',\n    '10.12 Sierra',\n    '10.13 High Sierra',\n    '10.14 Mojave',\n    '10.15 Catalina',\n    '11 Big Sur',\n    '12 Monterey',\n    '13 Ventura',\n    '14 Sonoma',\n    '15 Glow'); // use known internal codename for upcoming version\n\n  /// the recognized Windows versions, as plain text\n  // - defined even outside OSWINDOWS to allow process e.g. from monitoring tools\n  WINDOWS_NAME: array[TWindowsVersion] of RawUtf8 = (\n    '',\n    '2000',\n    'XP',\n    'XP 64bit',\n    'Server 2003',\n    'Server 2003 R2',\n    'Vista',\n    'Vista 64bit',\n    'Server 2008',\n    'Server 2008 64bit',\n    '7',\n    '7 64bit',\n    'Server 2008 R2',\n    'Server 2008 R2 64bit',\n    '8',\n    '8 64bit',\n    'Server 2012',\n    'Server 2012 64bit',\n    '8.1',\n    '8.1 64bit',\n    'Server 2012 R2',\n    'Server 2012 R2 64bit',\n    '10',\n    '10 64bit',\n    'Server 2016',\n    'Server 2016 64bit',\n    '11',\n    '11 64bit',\n    'Server 2019 64bit',\n    'Server 2022 64bit');\n\n  /// the recognized Windows versions which are 32-bit\n  WINDOWS_32 = [\n     w2000,\n     wXP,\n     wServer2003,\n     wServer2003_R2,\n     wVista,\n     wServer2008,\n     wSeven,\n     wServer2008_R2,\n     wEight,\n     wServer2012,\n     wEightOne,\n     wServer2012R2,\n     wTen,\n     wServer2016,\n     wEleven];\n\n  /// translate one operating system (and distribution) into a its common name\n  OS_NAME: array[TO", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.MemoryMappedFiles;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\n\nnamespace Mormot.Core.OS\n{\n\n    public static class OSConstants\n    {\n        \n        public static readonly string CRLF =\n#if WINDOWS\n            \"\\r\\n\";\n#else\n            \"\\n\";\n#endif\n\n        \n#if WINDOWS\n        public const string FILES_ALL = \"*.*\";\n        public const char InvertedPathDelim = '/';\n        public const bool PathCaseInsensitive = true;\n#else\n        public const string FILES_ALL = \"*\";\n        public const char InvertedPathDelim = '\\\\';\n        public const bool PathCaseInsensitive = false;\n#endif\n\n        \n        public const FileShare fmShareRead      = FileShare.Read;\n        public const FileShare fmShareWrite     = FileShare.Write;\n        public const FileShare fmShareReadWrite = FileShare.ReadWrite;\n    }\n\n    \n\n    public static class HttpStatus\n    {\n        \n        public const int HTTP_NONE = 0;\n        public const int HTTP_CONTINUE = 100;\n        public const int HTTP_SWITCHINGPROTOCOLS = 101;\n        public const int HTTP_SUCCESS = 200;\n        public const int HTTP_CREATED = 201;\n        public const int HTTP_ACCEPTED = 202;\n        public const int HTTP_NONAUTHORIZEDINFO = 203;\n        public const int HTTP_NOCONTENT = 204;\n        public const int HTTP_RESETCONTENT = 205;\n        public const int HTTP_PARTIALCONTENT = 206;\n        public const int HTTP_MULTIPLECHOICES = 300;\n        public const int HTTP_MOVEDPERMANENTLY = 301;\n        public const int HTTP_FOUND = 302;\n        public const int HTTP_SEEOTHER = 303;\n        public const int HTTP_NOTMODIFIED = 304;\n        public const int HTTP_USEPROXY = 305;\n        public const int HTTP_TEMPORARYREDIRECT = 307;\n        public const int HTTP_PERMANENTREDIRECT = 308;\n        public const int HTTP_BADREQUEST = 400;\n        public const int HTTP_UNAUTHORIZED = 401;\n        public const int HTTP_FORBIDDEN = 403;\n        public const int HTTP_NOTFOUND = 404;\n        public const int HTTP_NOTALLOWED = 405;\n        public const int HTTP_NOTACCEPTABLE = 406;\n        public const int HTTP_PROXYAUTHREQUIRED = 407;\n        public const int HTTP_TIMEOUT = 408;\n        public const int HTTP_CONFLICT = 409;\n        public const int HTTP_PAYLOADTOOLARGE = 413;\n        public const int HTTP_RANGENOTSATISFIABLE = 416;\n        public const int HTTP_TEAPOT = 418;\n        public const int HTTP_SERVERERROR = 500;\n        public const int HTTP_NOTIMPLEMENTED = 501;\n        public const int HTTP_BADGATEWAY = 502;\n        public const int HTTP_UNAVAILABLE = 503;\n        public const int HTTP_GATEWAYTIMEOUT = 504;\n        public const int HTTP_HTTPVERSIONNONSUPPORTED = 505;\n\n        private static readonly int[] HTTP_CODES = new int[]\n        {\n            HTTP_SUCCESS,\n            HTTP_NOCONTENT,\n            HTTP_TEMPORARYREDIRECT,\n            HTTP_PERMANENTREDIRECT,\n            HTTP_MOVEDPERMANENTLY,\n            HTTP_BADREQUEST,\n            HTTP_UNAUTHORIZED,\n            HTTP_FORBIDDEN,\n            HTTP_NOTFOUND,\n            HTTP_NOTALLOWED,\n            HTTP_NOTMODIFIED,\n            HTTP_NOTACCEPTABLE,\n            HTTP_PARTIALCONTENT,\n            HTTP_PAYLOADTOOLARGE,\n            HTTP_CREATED,\n            HTTP_SEEOTHER,\n            HTTP_CONTINUE,\n            HTTP_SWITCHINGPROTOCOLS,\n            HTTP_ACCEPTED,\n            HTTP_NONAUTHORIZEDINFO,\n            HTTP_RESETCONTENT,\n            207, \n            HTTP_MULTIPLECHOICES,\n            HTTP_FOUND,\n            HTTP_USEPROXY,\n            HTTP_PROXYAUTHREQUIRED,\n            HTTP_TIMEOUT,\n            HTTP_CONFLICT,\n            410, \n            411, \n            412, \n            414, \n            415, \n            HTTP_RANGENOTSATISFIABLE,\n            HTTP_TEAPOT,\n            426, \n            HTTP_SERVERERROR,\n            HTTP_NOTIMPLEMENTED,\n            HTTP_BADGATEWAY,\n            HTTP_UNAVAILABLE,\n            HTTP_GATEWAYTIMEOUT,\n            HTTP_HTTPVERSIONNONSUPPORTED,\n            511, \n            513  \n        };\n\n        private static readonly string[] HTTP_REASON = new string[]\n        {\n            \"OK\",\n            \"No Content\",\n            \"Temporary Redirect\",\n            \"Permanent Redirect\",\n            \"Moved Permanently\",\n            \"Bad Request\",\n            \"Unauthorized\",\n            \"Forbidden\",\n            \"Not Found\",\n            \"Method Not Allowed\",\n            \"Not Modified\",\n            \"Not Acceptable\",\n            \"Partial Content\",\n            \"Payload Too Large\",\n            \"Created\",\n            \"See Other\",\n            \"Continue\",\n            \"Switching Protocols\",\n            \"Accepted\",\n            \"Non-Authoritative Information\",\n            \"Reset Content\",\n            \"Multi-Status\",\n            \"Multiple Choices\",\n            \"Found\",\n            \"Use Proxy\",\n            \"Proxy Authentication Required\",\n            \"Request Timeout\",\n            \"Conflict\",\n            \"Gone\",\n            \"Length Required\",\n            \"Precondition Failed\",\n            \"URI Too Long\",\n            \"Unsupported Media Type\",\n            \"Requested Range Not Satisfiable\",\n            \"I'm a teapot\",\n            \"Upgrade Required\",\n            \"Internal Server Error\",\n            \"Not Implemented\",\n            \"Bad Gateway\",\n            \"Service Unavailable\",\n            \"Gateway Timeout\",\n            \"HTTP Version Not Supported\",\n            \"Network Authentication Required\",\n            \"Invalid Request\"\n        };\n\n        \n        public static string StatusCodeToText(int code)\n        {\n            int index = Array.IndexOf(HTTP_CODES, code);\n            if (index < 0)\n            {\n                \n                index = HTTP_CODES.Length - 1;\n            }\n            return HTTP_REASON[index];\n        }\n\n        \n        public static void StatusCodeToReason(int code, out string reason)\n        {\n            reason = StatusCodeToText(code);\n        }\n\n        \n        public static string StatusCodeToShort(int code)\n        {\n            if (code > 599) code = 999;\n            return $\"{code} {StatusCodeToText(code)}\";\n        }\n\n        \n        public static bool StatusCodeIsSuccess(int code)\n        {\n            return code >= HTTP_SUCCESS && code < HTTP_BADREQUEST;\n        }\n    }\n\n    \n    public static class FileUtils\n    {\n        \n        public static string NormalizeFileName(string fileName)\n        {\n            if (string.IsNullOrEmpty(fileName)) return fileName;\n#if WINDOWS\n            return fileName.Replace('/', Path.DirectorySeparatorChar);\n#else\n            return fileName.Replace('\\\\', Path.DirectorySeparatorChar);\n#endif\n        }\n\n        \n        public static string QuoteFileName(string fileName)\n        {\n            if (!string.IsNullOrEmpty(fileName) &&\n                fileName.Contains(\" \") &&\n                !fileName.StartsWith(\"\\\"\"))\n            {\n                return $\"\\\"{fileName}\\\"\";\n            }\n            return fileName;\n        }\n\n        \n        public static string EnsureDirectoryExists(string directory)\n        {\n            if (string.IsNullOrEmpty(directory))\n                throw new ArgumentException(\"Directory name is empty\");\n\n            string full = Path.GetFullPath(directory);\n            if (!Directory.Exists(full))\n            {\n                Directory.CreateDirectory(full);\n            }\n            return full;\n        }\n\n        \n        public static string ExtractPath(string fileName)\n        {\n            return Path.GetDirectoryName(fileName) + Path.DirectorySeparatorChar;\n        }\n\n        \n        public static string ExtractName(string fileName)\n        {\n            return Path.GetFileName(fileName);\n        }\n\n        \n        public static string ExtractExt(string fileName, bool withoutDot = false)\n        {\n            string ext = Path.GetExtension(fileName);\n            return withoutDot ? ext.TrimStart('.') : ext;\n        }\n\n        \n        public static string GetFileNameWithoutExt(string fileName, out string extension)\n        {\n            extension = Path.GetExtension(fileName);\n            return Path.GetFileNameWithoutExtension(fileName);\n        }\n\n        \n        public static string GetFileNameWithoutExtOrPath(string fileName)\n        {\n            return Path.GetFileNameWithoutExtension(Path.GetFileName(fileName));\n        }\n\n        \n        public static bool DirectoryDelete(string directory, string mask = \"*.*\", bool deleteOnlyFilesNotDirectory = false, out int deletedCount)\n        {\n            deletedCount = 0;\n            if (!Directory.Exists(directory))\n                return true;\n            bool result = true;\n            foreach (var file in Directory.GetFiles(directory, mask))\n            {\n                try\n                {\n                    File.Delete(file);\n                    deletedCount++;\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            if (!deleteOnlyFilesNotDirectory)\n            {\n                try\n                {\n                    Directory.Delete(directory);\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            return result;\n        }\n\n        \n        public static bool DirectoryDeleteOlderFiles(string directory, TimeSpan ageThreshold, string mask = \"*.*\", bool recursive = false, out long totalSize)\n        {\n            totalSize = 0;\n            if (!Directory.Exists(directory))\n                return true;\n            bool result = true;\n            DateTime cutoff = DateTime.UtcNow - ageThreshold;\n            foreach (var file in Directory.GetFiles(directory, mask))\n            {\n                try\n                {\n                    DateTime lastWrite = File.GetLastWriteTimeUtc(file);\n                    if (lastWrite < cutoff)\n                    {\n                        totalSize += new FileInfo(file).Length;\n                        File.Delete(file);\n                    }\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            if (recursive)\n            {\n                foreach (var subDir in Directory.GetDirectories(directory))\n                {\n                    DirectoryDeleteOlderFiles(subDir, ageThreshold, mask, true, out long subSize);\n                    totalSize += subSize;\n                }\n            }\n            return result;\n        }\n\n        \n        public static string TemporaryFileName()\n        {\n            return Path.Combine(Path.GetTempPath(), $\"{Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetEntryAssembly().Location)}_{Guid.NewGuid():N}.tmp\");\n        }\n    }\n\n\n    public class MemoryMap : IDisposable\n    {\n        private MemoryMappedFile _mmf;\n        private MemoryMappedViewAccessor _accessor;\n        public byte[] Buffer { get; private set; }\n        public long Size { get; private set; }\n        public long FileSize { get; private set; }\n\n        \n        public MemoryMap(string filePath, long? customSize = null, long customOffset = 0)\n        {\n            if (!File.Exists(filePath))\n                throw new FileNotFoundException(\"File not found\", filePath);\n\n            FileSize = new FileInfo(filePath).Length;\n            Size = customSize ?? (FileSize - customOffset);\n            \n            if (Size < (1 << 20))\n            {\n                Buffer = File.ReadAllBytes(filePath);\n            }\n            else\n            {\n                _mmf = MemoryMappedFile.CreateFromFile(filePath, FileMode.Open, null, FileSize, MemoryMappedFileAccess.Read);\n                _accessor = _mmf.CreateViewAccessor(customOffset, Size, MemoryMappedFileAccess.Read);\n                Buffer = new byte[Size];\n                _accessor.ReadArray(0, Buffer, 0, (int)Size);\n            }\n        }\n\n        public void Dispose()\n        {\n            _accessor?.Dispose();\n            _mmf?.Dispose();\n        }\n    }\n\n    \n    public class LightLock\n    {\n        private int _flag;\n\n        public void Lock()\n        {\n            while (Interlocked.Exchange(ref _flag, 1) != 0)\n            {\n                Thread.SpinWait(100);\n                Thread.Yield();\n            }\n        }\n\n        public bool TryLock()\n        {\n            return Interlocked.Exchange(ref _flag, 1) == 0;\n        }\n\n        public void Unlock()\n        {\n            Volatile.Write(ref _flag, 0);\n        }\n    }\n\n    \n    public class RWLock\n    {\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n\n        public void ReadLock() => _lock.EnterReadLock();\n        public void ReadUnlock() => _lock.ExitReadLock();\n        public void WriteLock() => _lock.EnterWriteLock();\n        public void WriteUnlock() => _lock.ExitWriteLock();\n    }\n\n    \n    public class OSLock\n    {\n        private readonly object _lockObj = new object();\n\n        public void Lock() => Monitor.Enter(_lockObj);\n        public bool TryLock() => Monitor.TryEnter(_lockObj);\n        public void Unlock() => Monitor.Exit(_lockObj);\n    }\n\n\n    public class ExecutableCommandLine\n    {\n        public List<string> Args { get; private set; }\n        public ExecutableCommandLine()\n        {\n            Args = new List<string>(Environment.GetCommandLineArgs());\n            if (Args.Count > 0)\n                Args.RemoveAt(0);\n        }\n\n        \n        public string FullDescription(string exeDescription = \"\")\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(string.IsNullOrEmpty(exeDescription)\n                ? \"Usage:\"\n                : exeDescription);\n            sb.AppendLine(\"Arguments:\");\n            foreach (var arg in Args)\n                sb.AppendLine(\"  \" + arg);\n            return sb.ToString();\n        }\n\n        \n        public string DetectUnknown(HashSet<string> expectedParameters)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var arg in Args)\n            {\n                if (!expectedParameters.Contains(arg))\n                    sb.AppendLine($\"Unexpected parameter: {arg}\");\n            }\n            return sb.ToString();\n        }\n    }\n\n    \n    public static class ExceptionInterceptor\n    {\n        \n        public static void Setup(Action<Exception> handler)\n        {\n            AppDomain.CurrentDomain.UnhandledException += (sender, e) =>\n            {\n                handler(e.ExceptionObject as Exception);\n            };\n        }\n    }\n\n    \n    public class FileVersionInfoWrapper\n    {\n        public int Major { get; private set; }\n        public int Minor { get; private set; }\n        public int Release { get; private set; }\n        public int Build { get; private set; }\n        public DateTime BuildDateTime { get; private set; }\n        public string Detailed => $\"{Major}.{Minor}.{Release}.{Build}\";\n        public string FileName { get; private set; }\n\n        public FileVersionInfoWrapper(string fileName)\n        {\n            FileName = fileName;\n            var fvi = System.Diagnostics.FileVersionInfo.GetVersionInfo(fileName);\n            Major = fvi.FileMajorPart;\n            Minor = fvi.FileMinorPart;\n            Release = fvi.FileBuildPart;\n            Build = fvi.FilePrivatePart;\n            BuildDateTime = File.GetCreationTime(fileName);\n        }\n\n        public override string ToString()\n        {\n            return $\"{Path.GetFileName(FileName)} {Detailed} ({BuildDateTime:yyyy-MM-dd HH:mm:ss})\";\n        }\n    }\n\n    \n    public static class ConsoleUtils\n    {\n        \n        public static void ConsoleWrite(string text, ConsoleColor color = ConsoleColor.Gray, bool noLineFeed = false)\n        {\n            Console.ForegroundColor = color;\n            if (noLineFeed)\n                Console.Write(text);\n            else\n                Console.WriteLine(text);\n            Console.ResetColor();\n        }\n\n        \n        public static void ConsoleWaitForEnterKey()\n        {\n            Console.WriteLine(\"Press ENTER to continue...\");\n            Console.ReadLine();\n        }\n    }\n\n    \n    public static class ServiceHelpers\n    {\n        \n        public static bool InstallService(string serviceName, string displayName, string exePath, string dependencies = \"\", string username = \"\", string password = \"\")\n        {\n            throw new NotImplementedException(\"Service installation not implemented in this port.\");\n        }\n\n        public static bool StartService(string serviceName)\n        {\n            \n            throw new NotImplementedException(\"Service start not implemented in this port.\");\n        }\n\n        public static bool StopService(string serviceName)\n        {\n            \n            throw new NotImplementedException(\"Service stop not implemented in this port.\");\n        }\n    }\n\n    \n    public static class PrivilegeHelpers\n    {\n        \n        public static bool DropPrivileges(string userName = \"nobody\")\n        {\n            \n            throw new NotImplementedException(\"Privilege dropping is not implemented in this port.\");\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// LoggerPro\n//\n// Copyright (c) 2015-2017 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.MemoryAppender;\n\ninterface\n\nuses\n  LoggerPro, System.Generics.Collections, System.SyncObjs, System.SysUtils,\n  ThreadSafeQueueU;\n\ntype\n  TMREWLogItemList = class(TMREWObjectList<TLogItem>)\n  end;\n\n  TLoggerProMemoryAppender = class(TLoggerProAppenderBase)\n  private\n    fMREWLogList: TMREWLogItemList;\n    fTag: string;\n    fMaxSize: Int32;\n  public\n    procedure Setup; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    procedure TearDown; override;\n    constructor Create(aLogList: TMREWLogItemList; aTag: string; aMaxSize: Int32); reintroduce; virtual;\n  end;\n\nimplementation\n\nvar\n  Glock: TObject = nil;\n\n  { TLoggerProMemoryAppender }\n\nconstructor TLoggerProMemoryAppender.Create(aLogList: TMREWLogItemList; aTag: string; aMaxSize: Int32);\nbegin\n  inherited Create;\n  fMREWLogList := aLogList;\n  fTag := aTag;\n  fMaxSize := aMaxSize\nend;\n\nprocedure TLoggerProMemoryAppender.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProMemoryAppender.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProMemoryAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lList: TObjectList<TLogItem>;\nbegin\n  if aLogItem.LogTag <> fTag then\n    Exit;\n\n  lList := fMREWLogList.BeginWrite;\n  try\n    if lList.Count >= fMaxSize then\n    begin\n      while lList.Count > (fMaxSize * 0.9) do // remove 10% of the list HEAD\n        lList.Delete(0);\n    end;\n    lList.Add(aLogItem.Clone);\n  finally\n    fMREWLogList.EndWrite;\n  end;\nend;\n\ninitialization\n\nGlock := TObject.Create;\n\nfinalization\n\nGlock.Free;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing LoggerPro; \n\nnamespace LoggerPro.Appenders\n{\n   \n    public class MREWLogItemList\n    {\n        private readonly List<TLogItem> _list = new List<TLogItem>();\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n\n        \n        public List<TLogItem> BeginWrite()\n        {\n            _lock.EnterWriteLock();\n            return _list;\n        }\n\n        \n        public void EndWrite()\n        {\n            _lock.ExitWriteLock();\n        }\n    }\n\n    \n    public class LoggerProMemoryAppender : LoggerProAppenderBase, ILogAppender\n    {\n        private readonly MREWLogItemList _mrewLogList;\n        private readonly string _tag;\n        private readonly int _maxSize;\n\n        \n        public LoggerProMemoryAppender(MREWLogItemList logList, string tag, int maxSize)\n        {\n            _mrewLogList = logList;\n            _tag = tag;\n            _maxSize = maxSize;\n        }\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            if (logItem.LogTag != _tag)\n                return;\n\n            List<TLogItem> list = _mrewLogList.BeginWrite();\n            try\n            {\n                if (list.Count >= _maxSize)\n                {\n                    \n                    int threshold = (int)(_maxSize * 0.9);\n                    while (list.Count > threshold)\n                    {\n                        list.RemoveAt(0);\n                    }\n                }\n                list.Add(logItem.Clone());\n            }\n            finally\n            {\n                _mrewLogList.EndWrite();\n            }\n        }\n    }\n}"}
{"input": "unit MVCFramework.SystemJSONUtils;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.JSON, MVCFramework.RESTClient, System.Rtti;\n\ntype\n  TSystemJSON = class sealed\n  private\n    class var CTX: TRttiContext;\n  public\n    class function StringToJSONValue(const Value: string): TJSONValue;\n    class function StringToJSONValueNoException(const Value: string): TJSONValue;\n    class function StringAsJSONObject(const Value: string): TJSONObject;\n    class function StringAsJSONObjectNoException(const Value: string): TJSONObject;\n    class function StringAsJSONArray(const Value: string): TJSONArray;\n    class function JSONValueToString(JSONValue: TJSONValue; const Owns: Boolean = true): string;\n    class function GetPair(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONPair;\n    class function GetStringDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: string = ''): string;\n    class function GetNumberDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Extended = 0): Extended;\n    class function GetJSONObj(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONObject;\n    class function GetJSONArray(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONArray;\n    class function GetIntegerDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Integer = 0): Integer;\n    class function GetInt64Def(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Int64 = 0): Int64;\n    class function GetBooleanDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: boolean = false): boolean;\n    class function GetProperty(Obj: TObject;\n      const PropertyName: string): TValue; static;\n    class function PropertyExists(JSONObject: TJSONObject;\n      PropertyName: string): boolean;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Commons, System.SysUtils, MVCFramework.DuckTyping,\n  System.Classes, MVCFramework.Serializer.Commons;\n\nclass function TSystemJSON.StringAsJSONArray(const Value: string): TJSONArray;\nbegin\n  Result := TSystemJSON.StringToJSONValue(Value) as TJSONArray;\nend;\n\nclass function TSystemJSON.StringAsJSONObject(const Value: string): TJSONObject;\nbegin\n  Result := TSystemJSON.StringToJSONValue(Value) as TJSONObject;\nend;\n\nclass function TSystemJSON.StringAsJSONObjectNoException(\n  const Value: string): TJSONObject;\nbegin\n  Result := TSystemJSON.StringToJSONValueNoException(Value) as TJSONObject;\nend;\n\nclass function TSystemJSON.StringToJSONValue(const Value: string): TJSONValue;\nvar\n  lBodyAsJSONValue: TJSONValue;\nbegin\n  lBodyAsJSONValue := TJSONObject.ParseJSONValue(Value);\n  if lBodyAsJSONValue = nil then\n    raise EMVCException.Create('Invalid JSON');\n  Result := lBodyAsJSONValue;\nend;\n\nclass function TSystemJSON.StringToJSONValueNoException(\n  const Value: string): TJSONValue;\nbegin\n  Result := TJSONObject.ParseJSONValue(Value);\nend;\n\nclass function TSystemJSON.JSONValueToString(JSONValue: TJSONValue;\n  const Owns: Boolean): string;\nbegin\n  Result := JSONValue.ToJSON;\n  if Owns then\n  begin\n    JSONValue.Free;\n  end;\nend;\n\nclass function TSystemJSON.GetBooleanDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: boolean): boolean;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONFalse then\n    Exit(false)\n  else if pair.JsonValue is TJSONTrue then\n    Exit(True)\n  else\n    raise EMVCException.CreateFmt('Property %s is not a Boolean Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetInt64Def(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Int64): Int64;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsInt64)\n  else\n    raise EMVCException.CreateFmt('Property %s is not a Int64 Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetIntegerDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Integer): Integer;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsInt)\n  else\n    raise EMVCException.CreateFmt('Property %s is not an Integer Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetJSONArray(JSONObject: TJSONObject;\n  PropertyName: string): TJSONArray;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(nil);\n  if pair.JsonValue is TJSONArray then\n    Exit(TJSONArray(pair.JsonValue))\n  else\n    raise EMVCException.Create('Property is not a JSONArray');\nend;\n\nclass function TSystemJSON.GetJSONObj(JSONObject: TJSONObject;\n  PropertyName: string): TJSONObject;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(nil);\n  if pair.JsonValue is TJSONObject then\n    Exit(TJSONObject(pair.JsonValue))\n  else\n    raise EMVCException.Create('Property is not a JSONObject');\nend;\n\nclass function TSystemJSON.PropertyExists(JSONObject: TJSONObject;\n  PropertyName: string): boolean;\nbegin\n  Result := Assigned(GetPair(JSONObject, PropertyName));\nend;\n\nclass function TSystemJSON.GetNumberDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Extended): Extended;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsDouble)\n  else\n    raise EMVCException.Create('Property is not a Number Property');\nend;\n\nclass function TSystemJSON.GetPair(JSONObject: TJSONObject; PropertyName: string)\n  : TJSONPair;\nvar\n  pair: TJSONPair;\nbegin\n  if not Assigned(JSONObject) then\n    raise EMVCException.Create('JSONObject is nil');\n  pair := JSONObject.Get(PropertyName);\n  Result := pair;\nend;\n\nclass function TSystemJSON.GetProperty(Obj: TObject;\n  const PropertyName: string): TValue;\nvar\n  Prop: TRttiProperty;\n  ARTTIType: TRttiType;\nbegin\n  ARTTIType := ctx.GetType(Obj.ClassType);\n  if not Assigned(ARTTIType) then\n    raise EMVCException.CreateFmt('Cannot get RTTI for type [%s]',\n      [ARTTIType.ToString]);\n  Prop := ARTTIType.GetProperty(PropertyName);\n  if not Assigned(Prop) then\n    raise EMVCException.CreateFmt('Cannot get RTTI for property [%s.%s]',\n      [ARTTIType.ToString, PropertyName]);\n  if Prop.IsReadable then\n    Result := Prop.GetValue(Obj)\n  else\n    raise EMVCException.CreateFmt('Property is not readable [%s.%s]',\n      [ARTTIType.ToString, PropertyName]);\nend;\n\nclass function TSystemJSON.GetStringDef(JSONObject: TJSONObject;\n  PropertyName, DefaultValue: string): string;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONString then\n    Exit(TJSONString(pair.JsonValue).Value)\n  else\n    raise EMVCException.Create('Property is not a String Property');\nend;\n\n\n\nend.", "output": "using System;\nusing System.Reflection;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework\n{\n    \n    public static class SystemJSONUtils\n    {\n        \n        public static JToken StringToJSONValue(string value)\n        {\n            try\n            {\n                JToken token = JToken.Parse(value);\n                if (token == null)\n                    throw new Exception(\"Invalid JSON\");\n                return token;\n            }\n            catch (Exception ex)\n            {\n                throw new Exception(\"Invalid JSON: \" + ex.Message);\n            }\n        }\n\n        \n        public static JToken StringToJSONValueNoException(string value)\n        {\n            try\n            {\n                return JToken.Parse(value);\n            }\n            catch\n            {\n                return null;\n            }\n        }\n\n       \n        public static JObject StringAsJSONObject(string value)\n        {\n            var token = StringToJSONValue(value) as JObject;\n            if (token == null)\n                throw new Exception(\"Invalid JSON Object\");\n            return token;\n        }\n\n        \n        public static JObject StringAsJSONObjectNoException(string value)\n        {\n            return StringToJSONValueNoException(value) as JObject;\n        }\n\n        \n        public static JArray StringAsJSONArray(string value)\n        {\n            var token = StringToJSONValue(value) as JArray;\n            return token;\n        }\n\n       \n        public static string JSONValueToString(JToken token, bool owns = true)\n        {\n            string result = token.ToString(Formatting.None);\n            return result;\n        }\n\n        \n        public static JProperty GetPair(JObject obj, string propertyName)\n        {\n            if (obj == null)\n                throw new Exception(\"JSONObject is null\");\n            return obj.Property(propertyName);\n        }\n\n        \n        public static string GetStringDef(JObject obj, string propertyName, string defaultValue = \"\")\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.String)\n                return pair.Value.ToString();\n            throw new Exception($\"Property {propertyName} is not a String Property\");\n        }\n\n        \n        public static double GetNumberDef(JObject obj, string propertyName, double defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Float || pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<double>();\n            throw new Exception(\"Property is not a Number Property\");\n        }\n\n        \n        public static JObject GetJSONObj(JObject obj, string propertyName)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return null;\n            if (pair.Value.Type == JTokenType.Object)\n                return (JObject)pair.Value;\n            throw new Exception(\"Property is not a JSONObject\");\n        }\n\n        \n        public static JArray GetJSONArray(JObject obj, string propertyName)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return null;\n            if (pair.Value.Type == JTokenType.Array)\n                return (JArray)pair.Value;\n            throw new Exception(\"Property is not a JSONArray\");\n        }\n\n        \n        public static int GetIntegerDef(JObject obj, string propertyName, int defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<int>();\n            throw new Exception($\"Property {propertyName} is not an Integer Property\");\n        }\n\n        \n        public static long GetInt64Def(JObject obj, string propertyName, long defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<long>();\n            throw new Exception($\"Property {propertyName} is not an Int64 Property\");\n        }\n\n        \n        public static bool GetBooleanDef(JObject obj, string propertyName, bool defaultValue = false)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Boolean)\n                return pair.Value.Value<bool>();\n            throw new Exception($\"Property {propertyName} is not a Boolean Property\");\n        }\n\n        \n        public static object GetProperty(object obj, string propertyName)\n        {\n            if (obj == null)\n                throw new Exception(\"Object is null\");\n            var type = obj.GetType();\n            PropertyInfo prop = type.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);\n            if (prop == null)\n                throw new Exception($\"Cannot get RTTI for property [{type.Name}.{propertyName}]\");\n            if (prop.CanRead)\n                return prop.GetValue(obj);\n            throw new Exception($\"Property is not readable [{type.Name}.{propertyName}]\");\n        }\n\n        \n        public static bool PropertyExists(JObject obj, string propertyName)\n        {\n            return obj.Property(propertyName) != null;\n        }\n    }\n}"}
{"input": "unit CustomWebModuleU;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n\n  TCustomWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVCEngine: TMVCEngine;\n  protected\n    procedure DoConfigureEngine(const aMVCEngine: TMVCEngine); virtual; abstract;\n  public\n\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  App1MainControllerU,\n  MVCFramework.Commons;\n\nprocedure TCustomWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVCEngine := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // nothing to configure here\n    end);\n  DoConfigureEngine(FMVCEngine);\nend;\n\nprocedure TCustomWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVCEngine.free;\nend;\n\nend.", "output": "using System;\n\nnamespace CustomWebModuleU\n{\n    \n    public class TMVCConfig\n    {\n        // Configuration properties go here.\n    }\n\n    public class TMVCEngine : IDisposable\n    {\n        public TMVCEngine(Action<TMVCConfig> configAction)\n        {\n            \n            TMVCConfig config = new TMVCConfig();\n            configAction(config);\n        }\n\n        public void Dispose()\n        {\n            // Dispose any resources held by the engine.\n        }\n    }\n\n    \n    public abstract class CustomWebModule : IDisposable\n    {\n        protected TMVCEngine MVCEngine { get; private set; }\n\n        \n        protected CustomWebModule()\n        {\n            \n            MVCEngine = new TMVCEngine(config =>\n            {\n                // Nothing to configure here.\n            });\n            \n            DoConfigureEngine(MVCEngine);\n        }\n\n        \n        \n        protected abstract void DoConfigureEngine(TMVCEngine engine);\n\n        \n        public void Dispose()\n        {\n            if (MVCEngine != null)\n            {\n                MVCEngine.Dispose();\n                MVCEngine = null;\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Core.Files;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes;\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections;\n{$ENDIF}\n\ntype\n  THorseCoreFile = class\n  private\n    FFileName: string;\n    FName: string;\n    FFileStream: TStream;\n    FFreeContentStream: Boolean;\n    FContentType: string;\n  public\n    constructor Create(const AFileName: string);\n    destructor Destroy; override;\n    function ContentType: string;\n    function ContentStream: TStream;\n    function Size: Int64;\n    property Name: string read FName;\n    property FreeContentStream: Boolean read FFreeContentStream write FFreeContentStream;\n  end;\n\nimplementation\n\nuses\n  Horse.Mime;\n\nconstructor THorseCoreFile.Create(const AFileName: string);\nbegin\n  if AFileName = EmptyStr then\n    raise Exception.Create('Invalid FileName');\n\n  if not FileExists(AFileName) then\n    raise Exception.Create('File not exist');\n\n  FFileName := AFileName;\n  FName := ExtractFileName(FFileName);\n  FFreeContentStream := True;\n  FContentType := THorseMimeTypes.GetFileType(FFileName);\nend;\n\ndestructor THorseCoreFile.Destroy;\nbegin\n  if FFreeContentStream then\n    FFileStream.Free;\n  inherited;\nend;\n\nfunction THorseCoreFile.ContentType: string;\nbegin\n  Result := FContentType;\nend;\n\nfunction THorseCoreFile.ContentStream: TStream;\nbegin\n  if not Assigned(FFileStream) then\n    FFileStream := TFileStream.Create(FFileName, fmOpenRead or fmShareDenyWrite);\n  Result := FFileStream;\nend;\n\nfunction THorseCoreFile.Size: Int64;\nbegin\n  Result := ContentStream.Size;\nend;\n\nend.", "output": "using System;\nusing System.IO;\n\nnamespace Horse.Core.Files\n{\n    public class HorseCoreFile : IDisposable\n    {\n        private string _fileName;\n        private string _name;\n        private FileStream _fileStream;\n        private bool _freeContentStream;\n        private string _contentType;\n\n        public HorseCoreFile(string fileName)\n        {\n            if (string.IsNullOrEmpty(fileName))\n                throw new ArgumentException(\"Invalid FileName\");\n\n            if (!File.Exists(fileName))\n                throw new FileNotFoundException(\"File not exist\", fileName);\n\n            _fileName = fileName;\n            _name = Path.GetFileName(_fileName);\n            _freeContentStream = true;\n            _contentType = HorseMimeTypes.GetFileType(_fileName);\n        }\n\n        public string ContentType()\n        {\n            return _contentType;\n        }\n\n        public Stream ContentStream()\n        {\n            if (_fileStream == null)\n            {\n                _fileStream = new FileStream(_fileName, FileMode.Open, FileAccess.Read, FileShare.Read);\n            }\n            return _fileStream;\n        }\n\n        public long Size()\n        {\n            return ContentStream().Length;\n        }\n\n        public string Name\n        {\n            get { return _name; }\n        }\n\n        public bool FreeContentStream\n        {\n            get { return _freeContentStream; }\n            set { _freeContentStream = value; }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing && _freeContentStream && _fileStream != null)\n            {\n                _fileStream.Dispose();\n                _fileStream = null;\n            }\n        }\n\n        ~HorseCoreFile()\n        {\n            Dispose(false);\n        }\n    }\n\n    public static class HorseMimeTypes\n    {\n        public static string GetFileType(string fileName)\n        {\n            string ext = Path.GetExtension(fileName)?.ToLowerInvariant();\n            switch (ext)\n            {\n                case \".html\":\n                case \".htm\":\n                    return \"text/html\";\n                case \".txt\":\n                    return \"text/plain\";\n                case \".json\":\n                    return \"application/json\";\n                case \".xml\":\n                    return \"application/xml\";\n                case \".jpg\":\n                case \".jpeg\":\n                    return \"image/jpeg\";\n                case \".png\":\n                    return \"image/png\";\n                case \".gif\":\n                    return \"image/gif\";\n                default:\n                    return \"application/octet-stream\";\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.Apache;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}\nuses\n{$IFDEF unix}\n  cthreads,\n{$ENDIF}\n  fphttp,\n  httpdefs,\n  httpd24,\n  fpApache24,\n  custapache24,\n  SysUtils,\n  Classes,\n  Horse.Provider.Abstract,\n  Horse.Proc;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FApacheApplication: TCustomApacheApplication;\n    class var FHandlerName: string;\n    class var FModuleName: string;\n    class var FDefaultModule: pmodule;\n    class function GetDefaultApacheApplication: TCustomApacheApplication;\n    class function ApacheApplicationIsNil: Boolean;\n    class procedure InternalListen; virtual;\n    class procedure SetHandlerName(const AValue: string); static;\n    class function GetHandlerName: string; static;\n    class procedure SetModuleName(const AValue: string); static;\n    class function GetModuleName: string; static;\n    class procedure SetDefaultModule(const AValue: pmodule); static;\n    class function GetDefaultModule: pmodule; static;\n    class procedure DoGetModule(Sender: TObject; ARequest: TRequest; var pmoduleClass: TCustomHTTPModuleClass);\n  public\n    class property HandlerName: string read GetHandlerName write SetHandlerName;\n    class property ModuleName: string read GetModuleName write SetModuleName;\n    class property DefaultModule: pmodule read GetDefaultModule write SetDefaultModule;\n    class procedure Listen; overload; override;\n    class procedure Listen(const ACallback: TProc); reintroduce; overload; static;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}\nuses\n  Horse.WebModule;\n\nclass function THorseProvider.GetDefaultApacheApplication: TCustomApacheApplication;\nbegin\n  if ApacheApplicationIsNil then\n    FApacheApplication := Application;\n  Result := FApacheApplication;\nend;\n\nclass function THorseProvider.GetDefaultModule: pmodule;\nbegin\n  Result := FDefaultModule;\nend;\n\nclass function THorseProvider.GetHandlerName: string;\nbegin\n  Result := FHandlerName;\nend;\n\nclass procedure THorseProvider.SetModuleName(const AValue: string);\nbegin\n  FModuleName := AValue;\nend;\n\nclass function THorseProvider.GetModuleName: string;\nbegin\n  Result := FModuleName;\nend;\n\nclass function THorseProvider.ApacheApplicationIsNil: Boolean;\nbegin\n  Result := FApacheApplication = nil;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LApacheApplication: TCustomApacheApplication;\nbegin\n  inherited;\n  LApacheApplication := GetDefaultApacheApplication;\n  LApacheApplication.ModuleName := FModuleName;\n  LApacheApplication.HandlerName := FHandlerName;\n  LApacheApplication.SetModuleRecord(FDefaultModule^);\n  LApacheApplication.AllowDefaultModule := True;\n  LApacheApplication.OnGetModule := DoGetModule;\n  LApacheApplication.LegacyRouting := True;\n  DoOnListen;\n  LApacheApplication.Initialize;\nend;\n\nclass procedure THorseProvider.DoGetModule(Sender: TObject; ARequest: TRequest; var pmoduleClass: TCustomHTTPModuleClass);\nbegin\n  pmoduleClass := THorseWebModule;\nend;\n\nclass procedure THorseProvider.SetDefaultModule(const AValue: pmodule);\nbegin\n  FDefaultModule := AValue;\nend;\n\nclass procedure THorseProvider.SetHandlerName(const AValue: string);\nbegin\n  FHandlerName := AValue;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const ACallback: TProc);\nbegin\n  SetOnListen(ACallback);\n  InternalListen;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Collections.Generic;\n\nnamespace Horse.Provider.FPC.Apache\n{\n    \n    public class ModuleRecord\n    {\n        // Define properties as needed.\n    }\n\n    \n    public class CustomApacheApplication\n    {\n        public string ModuleName { get; set; }\n        public string HandlerName { get; set; }\n        public bool AllowDefaultModule { get; set; }\n        public bool LegacyRouting { get; set; }\n        public Action<object, Request, out Type> OnGetModule { get; set; }\n        public bool Active { get; set; }\n        public int ListenQueue { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n        public int MaxConnections { get; set; }\n        public int DefaultPort { get; set; }\n        public bool KeepAlive { get; set; }\n        \n        \n        public void SetModuleRecord(ModuleRecord moduleRecord)\n        {\n            \n            Console.WriteLine(\"Module record set.\");\n        }\n        \n        \n        public void Initialize()\n        {\n            \n            Console.WriteLine(\"Apache application initialized.\");\n        }\n        \n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"Listening on {HandlerName}:{DefaultPort}...\");\n        }\n        \n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"Stopped listening.\");\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public class Request { }\n\n    \n    public class HorseWebModule { }\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        string Method { get; }\n        string SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public string Method => \"TLSv1.2\";\n        public string SSLVersions => \"TLSv1.2\";\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n    \n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        \n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n    }\n\n    \n\n    public static class HorseProvider \n    {\n        \n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static EventWaitHandle _event;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static CustomApacheApplication _apacheApplication;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n        private static string _handlerName;\n        private static string _moduleName;\n        private static ModuleRecord _defaultModule;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => _maxConnections; set => _maxConnections = value; }\n        public static int ListenQueue { get => _listenQueue; set => _listenQueue = value; }\n        public static bool KeepConnectionAlive { get => _keepConnectionAlive; set => _keepConnectionAlive = value; }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetDefaultHorseProviderIOHandleSSL(); set => _horseProviderIOHandleSSL = value; }\n        public static string HandlerName { get => GetHandlerName(); set => SetHandlerName(value); }\n        public static string ModuleName { get => GetModuleName(); set => SetModuleName(value); }\n        public static ModuleRecord DefaultModule { get => _defaultModule; set => _defaultModule = value; }\n\n        \n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static string GetHandlerName() => _handlerName;\n        private static void SetHandlerName(string value) => _handlerName = value;\n        private static string GetModuleName() => _moduleName;\n        private static void SetModuleName(string value) => _moduleName = value;\n\n        private static IHorseProviderIOHandleSSL GetDefaultHorseProviderIOHandleSSL()\n        {\n            if (_horseProviderIOHandleSSL == null)\n                _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New;\n            return _horseProviderIOHandleSSL;\n        }\n\n        private static CustomApacheApplication GetDefaultApacheApplication()\n        {\n            if (_apacheApplication == null)\n            {\n                \n                _apacheApplication = new CustomApacheApplication();\n            }\n            return _apacheApplication;\n        }\n\n        private static bool ApacheApplicationIsNil() => _apacheApplication == null;\n\n        private static EventWaitHandle GetDefaultEvent()\n        {\n            if (_event == null)\n                _event = new EventWaitHandle(false, EventResetMode.AutoReset);\n            return _event;\n        }\n\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n\n        \n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (_horseProviderIOHandleSSL != null) && GetDefaultHorseProviderIOHandleSSL().Active;\n        }\n\n        \n        private static void InitServerIOHandlerSSLOpenSSL(CustomApacheApplication app, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with CertFile: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        \n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var app = GetDefaultApacheApplication();\n            app.ModuleName = _moduleName;\n            app.HandlerName = _handlerName;\n            app.SetModuleRecord(_defaultModule);\n            app.AllowDefaultModule = true;\n            app.OnGetModule = DoGetModule;\n            app.LegacyRouting = true;\n            \n            HorseProviderAbstract.OnListenCallback?.Invoke();\n            app.Initialize();\n            _running = true;\n\n            if (IsConsole())\n            {\n                while (_running)\n                {\n                    GetDefaultEvent().WaitOne();\n                }\n            }\n        }\n\n        \n        private static void InternalStopListen()\n        {\n            if (!ApacheApplicationIsNil())\n            {\n                var app = GetDefaultApacheApplication();\n                app.StopListening();\n                app.Active = false;\n                HorseProviderAbstract.OnStopListenCallback?.Invoke();\n                _running = false;\n                _event?.Set();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        \n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            HorseProviderAbstract.OnListenCallback = callbackListen;\n            HorseProviderAbstract.OnStopListenCallback = callbackStopListen;\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static bool IsRunning() => _running;\n\n        public static void UnInitialize()\n        {\n            _apacheApplication = null;\n            if (_event != null)\n            {\n                _event.Dispose();\n                _event = null;\n            }\n        }\n\n        \n        private static bool IsConsole()\n        {\n            try\n            {\n                return Console.WindowHeight > 0;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \n        private static void DoGetModule(object sender, Request request, out Type moduleClass)\n        {\n            moduleClass = typeof(Horse.WebModule.HorseWebModule);\n        }\n    }\n}"}
{"input": "unit uMovie.Controller;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, uBase.Controller, JsonDataObjects;\n\ntype\n\n  [MVCPath('/movie')]\n  TMovieController = class(TBaseController)\n  private\n    FInsertMode: Boolean;\n    FIncludeBlankRow: Boolean;\n  protected\n    procedure RenderForm(const AViewNames: TArray<string>);\n  public\n    [MVCDoc('Trigger a client side error')]\n    [MVCPath('/error/400'), MVCHTTPMethod([httpGET])]\n    [MVCConsumes('application/json')]\n    procedure TriggerError;\n\n    [MVCDoc('Ask server to swap something on the page')]\n    [MVCPath('/swap'), MVCHTTPMethod([httpPATCH])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure TriggerSwap;\n\n    [MVCDoc('Get the list of Movies')]\n    [MVCPath('/page'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetMoviesPage;\n\n    [MVCDoc('Search for movies')]\n    [MVCPath('/search'), MVCHTTPMethod([httpPOST])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure SearchMovies;\n\n    [MVCDoc('Get the page to edit an individual Movie')]\n    [MVCPath('/($MovieID)/edit'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetEditPanel(MovieID: Integer);\n\n    [MVCDoc('Render a dialog for an insert')]\n    [MVCPath('/insert'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetInsertPanel;\n\n    [MVCDoc('Render a specified Movie to the grid')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetMovie(MovieID: Integer);\n\n    [MVCDoc('Update a specified Movie')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpPUT])]\n    [MVCProduces('text/html')]\n    procedure UpdateMovie(MovieID: Integer);\n\n    [MVCDoc('Create a specified Movie')]\n    [MVCPath(''), MVCHTTPMethod([httpPOST])]\n    [MVCProduces('text/html')]\n    procedure CreateMovie;\n\n    [MVCDoc('Delete a specified Movie')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpDELETE])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure DeleteMovie(MovieID: Integer);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Utils,\n  System.SysUtils,\n  MVCFramework.Serializer.JsonDataObjects,\n  uServices,\n  System.Generics.Collections,\n  uData.Model,\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.HTMX;\n\n{ TMovieController }\n\nprocedure TMovieController.RenderForm(const AViewNames: TArray<string>);\nbegin\n  PageData.b['InsertMode'] := FInsertMode;\n  PageData.b['IncludeBlankRow'] := FIncludeBlankRow;\n  ResponseStream.Append(RenderViews(AViewNames));\n  RenderResponseStream;\nend;\n\n/// // HTML rendering\nprocedure TMovieController.GetMoviesPage;\n// render the Movies page\nvar\n  Movies: TObjectList<TMovie>;\nbegin\n  Movies := GetMovieService.ListAll;\n  try\n    ViewData['Movies'] := Movies;\n    if Context.Request.IsHTMX then\n    begin\n      PageData.S['Explanation'] := 'Loaded via a seamless ajax call';\n      // rendering with htmx, pudsh the URL into the browser bar so a page refresh will not go back to the index page\n      Context.Response.HXSetPushUrl('/movie/page');\n      // Context.Response.SetReswap(soInnerHTML,  ssScroll, sstBottom, '#theFooter');\n      RenderForm(['Movie']);\n    end\n    else\n    begin\n      // just a normal form render\n      PageData.S['Explanation'] :=\n        'Loaded via a full page reload, watch for the flicker in the title bar and see the calls in the browser Dev Tools console (network tab)';\n      RenderForm(['Header', 'Movie', 'Footer']);\n    end;\n  finally\n    Movies.Free;\n  end;\nend;\n\nprocedure TMovieController.SearchMovies;\n// Search the Movies page\nvar\n  Params: TJsonObject;\n  Movies: TObjectList<TMovie>;\nbegin\n  Params := TJsonBaseObject.Parse(Context.Request.Body) as TJsonObject;\n  Movies := GetMovieService.ListBySearchTerm(Params.S['search']);\n  try\n    ViewData['Movies'] := Movies;\n    begin\n      RenderForm(['MovieDataRow']);\n    end;\n  finally\n    Movies.Free;\n    Params.Free;\n  end;\nend;\n\nprocedure TMovieController.TriggerError;\n// propogate an error from the server back to the web page\nbegin\n  raise Exception.Create('Exception for client side');\nend;\n\nprocedure TMovieController.TriggerSwap;\nbegin\n  // make a server side delay so you can see the htmx indicator svg\n  sleep(500);\n  // now tell the web page to delay doing the content swap for another 1 second\n  Context.Response.HXSetReswap(soInnerHTML, 1000);\n  Render(Format('... Button was clicked at %s', [FormatDateTime('hh:mm:ss', Now)]));\nend;\n\nprocedure TMovieController.GetEditPanel(MovieID: Integer);\n// return the editor panel\nvar\n  Genres: TObjectList<TGenre>;\n  Movie: TMovie;\nbegin\n  Movie := GetMovieService.GetByID(MovieID);\n  Genres := GetGenreService.GetGenresAsList(Movie.GenreID);\n  try\n    ViewData['Movies'] := Movie;\n    ViewData['Genres'] := Genres;\n    Context.Response.HXTriggerClientEvent('setFocus', '.focus', etSwapped);\n    RenderForm(['MovieDataEdit']);\n  finally\n    Movie.Free;\n    Genres.Free;\n  end;\nend;\n\nprocedure TMovieController.GetInsertPanel;\n// get the movie insert panel\nvar\n  Movie: TMovie;\n  Genres: TObjectList<TGenre>;\nbegin\n  Movie := TMovie.CreateNew(true);\n  Genres := GetGenreService.GetGenresAsList(Movie.GenreID);\n  try\n    Movie.MovieID := GetMovieService.GetNextID;\n    FInsertMode := true;\n    ViewData['Genres'] := Genres;\n    ViewData['Movies'] := Movie;\n    // make sure the insert panel is visible - this shows how to triiger evenst in the browser from the server\n    Context.Response.HXTriggerClientEvent('setFocus', '.focus', etSwapped);\n    RenderForm(['MovieDataEdit']);\n  finally\n    Genres.Free;\n    Movie.Free;\n  end;\nend;\n\nprocedure TMovieController.GetMovie(MovieID: Integer);\n// render out a specified movie\nvar\n  Movie: TMovie;\nbegin\n  Movie := GetMovieService.GetByID(MovieID);\n  try\n    if Movie <> nil then\n      ViewData['Movies'] := Movie\n    else\n      FIncludeBlankRow := true;\n    RenderForm(['MovieDataRow']);\n  finally\n    if Movie <> nil then\n      Movie.Free;\n  end;\nend;\n\nprocedure TMovieController.CreateMovie;\n// create a new Movie, and return it\nvar\n  MovieID: Integer;\n  Movie: TMovie;\nbegin\n  Movie := Context.Request.BodyAs<TMovie>;\n  try\n    if not GetMovieService.UpdateMovie(Movie, true) then\n      raise Exception.Create('Could not create Movie');\n    MovieID := Movie.MovieID;\n    // send the object back to the script on the page\n    Context.Response.HXTriggerClientEvent('myEventObject', Movie);\n  finally\n    Movie.Free;\n  end;\n  FIncludeBlankRow := true;\n  GetMovie(MovieID);\nend;\n\nprocedure TMovieController.UpdateMovie(MovieID: Integer);\n// handle the update, send back the modified record\nvar\n  Movie: TMovie;\nbegin\n  Movie := Context.Request.BodyAs<TMovie>;\n  try\n    if not GetMovieService.UpdateMovie(Movie, false) then\n      raise Exception.Create('Could not update Movie');\n  finally\n    Movie.Free;\n  end;\n  Context.Response.HXTriggerClientEvent('savedEvent', 'Movie Saved OK');\n\n  GetMovie(MovieID);\nend;\n\nprocedure TMovieController.DeleteMovie(MovieID: Integer);\n// delete the movie, render nothing back so <tr> gets remove from the web page\nbegin\n  if not GetMovieService.DeleteMovie(MovieID) then\n    raise Exception.Create('Could not delete Movie');\n  Context.Response.HXTriggerClientEvent('savedEvent', 'Movie Deleted OK');\n\n  RenderForm([]);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing JsonDataObjects;\nusing System.Threading;\n\nnamespace MovieApp.Controllers\n{\n    [MVCPath(\"/movie\")]\n    public class MovieController : BaseController\n    {\n        private bool _insertMode;\n        private bool _includeBlankRow;\n\n        protected void RenderForm(string[] viewNames)\n        {\n            PageData[\"InsertMode\"] = _insertMode;\n            PageData[\"IncludeBlankRow\"] = _includeBlankRow;\n            ResponseStream.Append(RenderViews(viewNames));\n            RenderResponseStream();\n        }\n\n        [MVCDoc(\"Trigger a client side error\")]\n        [MVCPath(\"/error/400\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCConsumes(\"application/json\")]\n        public void TriggerError()\n        {\n            throw new Exception(\"Exception for client side\");\n        }\n\n        [MVCDoc(\"Ask server to swap something on the page\")]\n        [MVCPath(\"/swap\")]\n        [MVCHTTPMethod(HttpMethod.PATCH)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void TriggerSwap()\n        {\n            Thread.Sleep(500);\n            Context.Response.HXSetReswap(SwapOption.InnerHTML, 1000);\n            Render(string.Format(\"... Button was clicked at {0}\", DateTime.Now.ToString(\"hh:mm:ss\")));\n        }\n\n        [MVCDoc(\"Get the list of Movies\")]\n        [MVCPath(\"/page\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetMoviesPage()\n        {\n            var movies = GetMovieService().ListAll();\n            try\n            {\n                ViewData[\"Movies\"] = movies;\n                if (Context.Request.IsHTMX)\n                {\n                    PageData[\"Explanation\"] = \"Loaded via a seamless ajax call\";\n                    Context.Response.HXSetPushUrl(\"/movie/page\");\n                    RenderForm(new string[] { \"Movie\" });\n                }\n                else\n                {\n                    PageData[\"Explanation\"] = \"Loaded via a full page reload, watch for the flicker in the title bar and see the calls in the browser Dev Tools console (network tab)\";\n                    RenderForm(new string[] { \"Header\", \"Movie\", \"Footer\" });\n                }\n            }\n            finally\n            {\n                movies.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Search for movies\")]\n        [MVCPath(\"/search\")]\n        [MVCHTTPMethod(HttpMethod.POST)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void SearchMovies()\n        {\n            var parameters = JsonObject.Parse(Context.Request.Body) as JsonObject;\n            var movies = GetMovieService().ListBySearchTerm(parameters[\"search\"]);\n            try\n            {\n                ViewData[\"Movies\"] = movies;\n                RenderForm(new string[] { \"MovieDataRow\" });\n            }\n            finally\n            {\n                movies.Dispose();\n                parameters.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Get the page to edit an individual Movie\")]\n        [MVCPath(\"/($MovieID)/edit\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetEditPanel(int movieID)\n        {\n            var movie = GetMovieService().GetByID(movieID);\n            var genres = GetGenreService().GetGenresAsList(movie.GenreID);\n            try\n            {\n                ViewData[\"Movies\"] = movie;\n                ViewData[\"Genres\"] = genres;\n                Context.Response.HXTriggerClientEvent(\"setFocus\", \".focus\", ClientEventType.Swapped);\n                RenderForm(new string[] { \"MovieDataEdit\" });\n            }\n            finally\n            {\n                movie.Dispose();\n                genres.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Render a dialog for an insert\")]\n        [MVCPath(\"/insert\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetInsertPanel()\n        {\n            var movie = TMovie.CreateNew(true);\n            var genres = GetGenreService().GetGenresAsList(movie.GenreID);\n            try\n            {\n                movie.MovieID = GetMovieService().GetNextID();\n                _insertMode = true;\n                ViewData[\"Genres\"] = genres;\n                ViewData[\"Movies\"] = movie;\n                Context.Response.HXTriggerClientEvent(\"setFocus\", \".focus\", ClientEventType.Swapped);\n                RenderForm(new string[] { \"MovieDataEdit\" });\n            }\n            finally\n            {\n                genres.Dispose();\n                movie.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Render a specified Movie to the grid\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetMovie(int movieID)\n        {\n            var movie = GetMovieService().GetByID(movieID);\n            try\n            {\n                if (movie != null)\n                    ViewData[\"Movies\"] = movie;\n                else\n                    _includeBlankRow = true;\n                RenderForm(new string[] { \"MovieDataRow\" });\n            }\n            finally\n            {\n                if (movie != null)\n                    movie.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Update a specified Movie\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.PUT)]\n        [MVCProduces(\"text/html\")]\n        public void UpdateMovie(int movieID)\n        {\n            var movie = Context.Request.BodyAs<TMovie>();\n            try\n            {\n                if (!GetMovieService().UpdateMovie(movie, false))\n                    throw new Exception(\"Could not update Movie\");\n            }\n            finally\n            {\n                movie.Dispose();\n            }\n            Context.Response.HXTriggerClientEvent(\"savedEvent\", \"Movie Saved OK\");\n            GetMovie(movieID);\n        }\n\n        [MVCDoc(\"Create a specified Movie\")]\n        [MVCPath(\"\")]\n        [MVCHTTPMethod(HttpMethod.POST)]\n        [MVCProduces(\"text/html\")]\n        public void CreateMovie()\n        {\n            var movie = Context.Request.BodyAs<TMovie>();\n            try\n            {\n                if (!GetMovieService().UpdateMovie(movie, true))\n                    throw new Exception(\"Could not create Movie\");\n                int movieID = movie.MovieID;\n                Context.Response.HXTriggerClientEvent(\"myEventObject\", movie);\n            }\n            finally\n            {\n                movie.Dispose();\n            }\n            _includeBlankRow = true;\n            GetMovie(movieID);\n        }\n\n        [MVCDoc(\"Delete a specified Movie\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.DELETE)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void DeleteMovie(int movieID)\n        {\n            if (!GetMovieService().DeleteMovie(movieID))\n                throw new Exception(\"Could not delete Movie\");\n            Context.Response.HXTriggerClientEvent(\"savedEvent\", \"Movie Deleted OK\");\n            RenderForm(new string[] { });\n        }\n\n        private IMovieService GetMovieService() => ServiceLocator.GetMovieService();\n        private IGenreService GetGenreService() => ServiceLocator.GetGenreService();\n    }\n}"}
{"input": "unit REST.RestServer;\n\ninterface\n\nuses\n  System.SysUtils,\n  MVCFramework,\n  MVCFramework.Logger,\n  MVCFramework.Commons,\n  MVCFramework.REPLCommandsHandlerU,\n  Web.WebReq,\n  Web.WebBroker,\n  IdHTTPWebBrokerBridge;\n\ntype\n  TDMVCRestServer = class\n  private\n    fServer: TIdHTTPWebBrokerBridge;\n  public\n    constructor Create(const aPort: integer); overload;\n    procedure Activate;\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nuses\n  REST.WebModule;\n\nprocedure TDMVCRestServer.Activate;\nbegin\n  fServer.Active := true;\n\n  if fServer.Active then\n  begin\n    LogD('Server active on port=' + IntToStr(fServer.DefaultPort));\n  end;\nend;\n\nconstructor TDMVCRestServer.Create(const aPort: integer);\nbegin\n  inherited Create;\n  fServer := TIdHTTPWebBrokerBridge.Create();\n  if WebRequestHandler <> nil then\n  begin\n    WebRequestHandler.WebModuleClass := WebModuleClass;\n    WebRequestHandlerProc.MaxConnections := 1024;\n  end;\n  fServer.DefaultPort := aPort;\nend;\n\ndestructor TDMVCRestServer.Destroy;\nbegin\n  EnterInShutdownState;\n  try\n    fServer.Active := false;\n    FreeAndNil(fServer);\n    LogD('Server not active');\n  except\n    on E: Exception do\n    begin\n      LogE('[TDMVCRestServer.Destroy] ' + E.Message);\n    end;\n  end;\n  ReleaseGlobalLogger;\n  inherited Destroy;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing System.Net;\nusing MVCFramework;\nusing MVCFramework.Logger;\nusing MVCFramework.Commons;\nusing MVCFramework.REPLCommandsHandlerU;\nusing REST.WebModule;\n\nnamespace REST\n{\n    public class DMVCRestServer : IDisposable\n    {\n        private HttpListener _server;\n        public Type WebModuleClass { get; set; }\n        public DMVCRestServer(int port)\n        {\n            _server = new HttpListener();\n            _server.Prefixes.Add($\"http://*:{port}/\");\n            if (WebRequestHandler.Instance != null)\n            {\n                WebRequestHandler.Instance.WebModuleClass = WebModuleClass;\n                WebRequestHandlerProc.MaxConnections = 1024;\n            }\n        }\n        public void Activate()\n        {\n            _server.Start();\n            if (_server.IsListening)\n            {\n                var prefix = _server.Prefixes.First();\n                LogD(\"Server active on port=\" + prefix.Split(':')[2].TrimEnd('/'));\n            }\n        }\n        public void Dispose()\n        {\n            EnterInShutdownState();\n            try\n            {\n                if (_server.IsListening)\n                    _server.Stop();\n                _server.Close();\n                LogD(\"Server not active\");\n            }\n            catch (Exception ex)\n            {\n                LogE(\"[DMVCRestServer.Dispose] \" + ex.Message);\n            }\n            ReleaseGlobalLogger();\n        }\n        ~DMVCRestServer()\n        {\n            Dispose();\n        }\n        private void EnterInShutdownState() { }\n        private void ReleaseGlobalLogger() { }\n    }\n}"}
{"input": "unit Controllers.Articles;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  System.Generics.Collections,\n  Controllers.Base,\n  BusinessObjects,\n  Services;\n\ntype\n  [MVCDoc('Resource that manages articles CRUD')]\n  [MVCPath('/articles')]\n  TArticlesController = class(TBaseController)\n  private\n    fArticlesService: IArticlesService;\n  public\n    [MVCInject]\n    constructor Create(ArticlesService: IArticlesService); reintroduce;\n\n    [MVCDoc('Returns the list of articles')]\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticles: IMVCResponse;\n\n    [MVCDoc('Returns the list of articles')]\n    [MVCPath('/searches')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticlesByDescription(const [MVCFromQueryString('q', '')] Search: String): IMVCResponse;\n\n    [MVCDoc('Returns the article with the specified id')]\n    [MVCPath('/meta')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticleMeta: IMVCResponse;\n\n    [MVCDoc('Returns the article with the specified id')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticleByID(id: Integer): IMVCResponse;\n\n    [MVCDoc('Deletes the article with the specified id')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpDelete])]\n    procedure DeleteArticleByID(id: Integer);\n\n    [MVCDoc('Updates the article with the specified id and return \"200: OK\"')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    function UpdateArticleByID(const [MVCFromBody] Article: TArticle; const id: Integer): IMVCResponse;\n\n    [MVCDoc('Creates a new article and returns \"201: Created\"')]\n    [MVCPath]\n    [MVCHTTPMethod([httpPOST])]\n    function CreateArticle(const [MVCFromBody] Article: TArticle): IMVCResponse;\n\n    [MVCDoc('Creates new articles from a list and returns \"201: Created\"')]\n    [MVCPath('/bulk')]\n    [MVCHTTPMethod([httpPOST])]\n    function CreateArticles(const [MVCFromBody] ArticleList: TObjectList<TArticle>): IMVCResponse;\n  end;\n\nimplementation\n\n{ TArticlesController }\n\nuses\n  System.SysUtils;\n\nconstructor TArticlesController.Create(ArticlesService: IArticlesService);\nbegin\n  inherited Create;\n  fArticlesService := ArticlesService;\nend;\n\nfunction TArticlesController.CreateArticle(const Article: TArticle): IMVCResponse;\nbegin\n  fArticlesService.Add(Article);\n  Result := CreatedResponse('/articles/' + Article.id.ToString, 'Article Created');\nend;\n\nfunction TArticlesController.CreateArticles(const ArticleList: TObjectList<TArticle>): IMVCResponse;\nbegin\n  fArticlesService.CreateArticles(ArticleList);\n  Result := CreatedResponse('', 'Articles created');\nend;\n\nprocedure TArticlesController.DeleteArticleByID(id: Integer);\nbegin\n  fArticlesService.Delete(fArticlesService.GetByID(id));\nend;\n\nfunction TArticlesController.GetArticles: IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetAll);\nend;\n\nfunction TArticlesController.GetArticlesByDescription(const Search: String): IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetArticles(Search));\nend;\n\nfunction TArticlesController.UpdateArticleByID(const Article: TArticle; const id: Integer): IMVCResponse;\nbegin\n  Article.id := id;\n  fArticlesService.Update(Article);\n  Result := OKResponse;\nend;\n\nfunction TArticlesController.GetArticleByID(id: Integer): IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetByID(id));\nend;\n\nfunction TArticlesController.GetArticleMeta: IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetMeta);\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Controllers.Base;       \nusing BusinessObjects;        \nusing Services;                \n\nnamespace ControllersArticles\n{\n    \n    [ApiController]\n    [Route(\"articles\")]\n    public class ArticlesController : BaseController\n    {\n        private readonly IArticlesService _articlesService;\n\n        public ArticlesController(IArticlesService articlesService)\n            : base()\n        {\n            _articlesService = articlesService;\n        }\n\n        \n        [HttpGet]\n        public IActionResult GetArticles()\n        {\n            var articles = _articlesService.GetAll();\n            return Ok(articles);\n        }\n\n        \n        [HttpGet(\"searches\")]\n        public IActionResult GetArticlesByDescription([FromQuery(Name = \"q\")] string search = \"\")\n        {\n            var articles = _articlesService.GetArticles(search);\n            return Ok(articles);\n        }\n\n        \n        [HttpGet(\"meta\")]\n        public IActionResult GetArticleMeta()\n        {\n            var meta = _articlesService.GetMeta();\n            return Ok(meta);\n        }\n\n        \n        [HttpGet(\"{id}\")]\n        public IActionResult GetArticleByID(int id)\n        {\n            var article = _articlesService.GetByID(id);\n            return Ok(article);\n        }\n\n \n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteArticleByID(int id)\n        {\n            var article = _articlesService.GetByID(id);\n            _articlesService.Delete(article);\n            return Ok();\n        }\n\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateArticleByID([FromBody] TArticle article, int id)\n        {\n            article.ID = id;\n            _articlesService.Update(article);\n            return Ok();\n        }\n\n        [HttpPost]\n        public IActionResult CreateArticle([FromBody] TArticle article)\n        {\n            _articlesService.Add(article);\n            return Created($\"/articles/{article.ID}\", \"Article Created\");\n        }\n\n        \n        [HttpPost(\"bulk\")]\n        public IActionResult CreateArticles([FromBody] List<TArticle> articleList)\n        {\n            _articlesService.CreateArticles(articleList);\n            return Created(string.Empty, \"Articles created\");\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.DMSEventStreamsAppender;\n\ninterface\n\nuses\n  System.Classes,\n  MVCFramework.Commons, {this demo requires DMVCFramework}\n  System.SysUtils,\n  LoggerPro,\n  System.Net.HttpClient,\n  EventStreamsRPCProxy,\n  JsonDataObjects;\n\ntype\n\n  {\n    Log appender for a DMSContainer EventStreams endpoint\n    Author: Daniele Teti (https://github.com/danieleteti/)\n  }\n\n  TOnCreateJSONData = reference to procedure(const Sender: TObject; const LogItem: TLogItem;\n    const ExtendedInfo: TLoggerProExtendedInfo;\n    Data: TJSONObject);\n  TOnNetSendError = reference to procedure(const Sender: TObject; const LogItem: TLogItem; const NetError: Exception;\n    var RetryCount: Integer);\n\n  {\n    dmsatByTag:\n    all messages with the same tag go in the same queue\n\n    dmsatByType:\n    all messages with the same type go in the same queue\n    dmsatByTagThenType:\n    messages are organized in one queue for each tag,\n    then one queue for each type (es. myapp.mytag.error, myapp.mytag.warning etc)\n\n    dmsatByTypeThenTag:\n    messages are organized in one queue for each type,\n    then one queue for each tag (es. myapp.error.mytag, myapp.warning.mytag etc)\n  }\n  TDMSQueueAggregationType = (dmsatByTag, dmsatByType, dmsatByTagThenType, dmsatByTypeThenTag);\n\n  TLoggerProDMSContainerAppender = class(TLoggerProAppenderBase, ILogAppender)\n  strict private\n    fOnCreateJSONData: TOnCreateJSONData;\n    fOnNetSendError: TOnNetSendError;\n    fExtendedInfo: TLoggerProExtendedInfo;\n    fEventStreamsProxy: TEventStreamsRPCProxy;\n    fDMSContainerAPIKey: String;\n    fExtendedInfoData: array [low(TLogExtendedInfo) .. high(TLogExtendedInfo)] of string;\n    procedure SetOnCreateJSONData(const Value: TOnCreateJSONData);\n    procedure SetOnNetSendError(const Value: TOnNetSendError);\n  private\n    fQueueNameBase: string;\n    fLogItemAggregationType: TDMSQueueAggregationType;\n  strict protected\n    procedure LoadExtendedInfo;\n    function GetExtendedInfo: TJSONObject;\n  protected const\n    DEFAULT_EXTENDED_INFO = [TLogExtendedInfo.EIUserName, TLogExtendedInfo.EIComputerName,\n      TLogExtendedInfo.EIProcessName,\n      TLogExtendedInfo.EIProcessID, TLogExtendedInfo.EIDeviceID];\n    procedure InternalWriteLog(const aLogItem: TLogItem; const aJSONObject: TJSONObject);\n  public\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    constructor Create(aEventStreamsProxy: TEventStreamsRPCProxy;\n      aDMSContainerAPIKey: String;\n      aEventStreamsQueueNameBase: String = 'queues.logs.';\n      aLogItemAggregationType: TDMSQueueAggregationType = dmsatByTag;\n      aLogExtendedInfo: TLoggerProExtendedInfo = DEFAULT_EXTENDED_INFO); reintroduce;\n    destructor Destroy; override;\n    property OnCreateJSONData: TOnCreateJSONData read fOnCreateJSONData write SetOnCreateJSONData;\n    property OnNetSendError: TOnNetSendError read fOnNetSendError write SetOnNetSendError;\n    procedure TearDown; override;\n    procedure Setup; override;\n    function CreateData(const SrcLogItem: TLogItem): TJSONObject; virtual;\n    function GetDefaultLog(const aLogItem: TLogItem): TJSONObject; virtual;\n    class function GetModuleBaseName: String;\n  end;\n\nimplementation\n\nuses\n{$IF Defined(MSWINDOWS) }\n  Winapi.Windows,\n{$ENDIF}\n{$IF Defined(Android) }\n  Androidapi.JNI.GraphicsContentViewText,\n  Androidapi.JNI.JavaTypes,\n  Androidapi.JNI.Os,\n  Androidapi.JNI.Util,\n  Androidapi.Helpers,\n{$ENDIF}\n  System.NetEncoding,\n  System.IOUtils,\n  System.Net.URLClient;\n\n{$IFDEF MSWINDOWS }\n\n\nfunction GetUserFromWindows: string;\nvar\n  iLen: Cardinal;\nbegin\n  iLen := 256;\n  Result := StringOfChar(#0, iLen);\n  GetUserName(PChar(Result), iLen);\n  SetLength(Result, iLen - 1);\nend;\n\nfunction GetComputerNameFromWindows: string;\nvar\n  iLen: Cardinal;\nbegin\n  iLen := MAX_COMPUTERNAME_LENGTH + 1;\n  Result := StringOfChar(#0, iLen);\n  GetComputerName(PChar(Result), iLen);\n  SetLength(Result, iLen);\nend;\n\n{$ENDIF}\n\n\nconstructor TLoggerProDMSContainerAppender.Create(\n  aEventStreamsProxy: TEventStreamsRPCProxy;\n  aDMSContainerAPIKey: String;\n  aEventStreamsQueueNameBase: String;\n  aLogItemAggregationType: TDMSQueueAggregationType;\n  aLogExtendedInfo: TLoggerProExtendedInfo);\nbegin\n  inherited Create;\n  fEventStreamsProxy := aEventStreamsProxy;\n  fQueueNameBase := aEventStreamsQueueNameBase;\n  fLogItemAggregationType := aLogItemAggregationType;\n  if not fQueueNameBase.EndsWith('.') then\n    fQueueNameBase := fQueueNameBase + '.';\n  fExtendedInfo := aLogExtendedInfo;\n  fDMSContainerAPIKey := aDMSContainerAPIKey;\n  LoadExtendedInfo;\nend;\n\nfunction TLoggerProDMSContainerAppender.CreateData(const SrcLogItem: TLogItem): TJSONObject;\nbegin\n  Result := nil;\n  try\n    if Assigned(fOnCreateJSONData) then\n    begin\n      fOnCreateJSONData(Self, SrcLogItem, fExtendedInfo, Result);\n    end\n    else\n    begin\n      Result := GetDefaultLog(SrcLogItem);\n    end;\n  except\n    on E: Exception do\n    begin\n      FreeAndNil(Result);\n      raise;\n    end;\n  end;\nend;\n\ndestructor TLoggerProDMSContainerAppender.Destroy;\nbegin\n  fEventStreamsProxy.Free;\n  inherited;\nend;\n\nfunction TLoggerProDMSContainerAppender.GetDefaultLog(const aLogItem: TLogItem): TJSONObject;\nbegin\n  Result := TJSONObject.Create;\n  try\n    Result.S['timestamp'] := datetimetostr(aLogItem.TimeStamp, FormatSettings);\n    Result.L['tid'] := aLogItem.ThreadID;\n    Result.S['type'] := aLogItem.LogTypeAsString;\n    Result.S['text'] := aLogItem.LogMessage;\n    Result.O['info'] := GetExtendedInfo;\n    // Result.S['tag'] := aLogItem.LogTag;\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nfunction TLoggerProDMSContainerAppender.GetExtendedInfo: TJSONObject;\nbegin\n  Result := TJSONObject.Create;\n  try\n{$IF Defined(MSWINDOWS)}\n    if TLogExtendedInfo.EIUserName in fExtendedInfo then\n    begin\n      Result.S['username'] := fExtendedInfoData[TLogExtendedInfo.EIUserName];\n    end;\n    if TLogExtendedInfo.EIComputerName in fExtendedInfo then\n    begin\n      Result.S['computername'] := fExtendedInfoData[TLogExtendedInfo.EIComputerName];\n    end;\n    if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n    begin\n      Result.S['processname'] := fExtendedInfoData[TLogExtendedInfo.EIProcessName];\n    end;\n    if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n    begin\n      Result.S['pid'] := fExtendedInfoData[TLogExtendedInfo.EIProcessID];\n    end;\n{$ENDIF}\n{$IF Defined(Android)}\n    if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n    begin\n      Result.S['processname'] := fExtendedInfoData[TLogExtendedInfo.EIProcessName];\n    end;\n{$ENDIF}\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TLoggerProDMSContainerAppender.GetModuleBaseName: String;\nbegin\n{$IF Defined(MSWINDOWS)}\n  Result := TPath.ChangeExtension(TPath.GetFileName(GetModuleName(HInstance)), '');\n{$ENDIF}\n{$IF Defined(Android)}\n  Result := TAndroidHelper.ApplicationTitle;\n{$ENDIF}\n  if Result.IsEmpty then\n  begin\n    raise ELoggerPro.Create('Current platform not supported by ' + ClassName);\n  end;\nend;\n\nprocedure TLoggerProDMSContainerAppender.LoadExtendedInfo;\nbegin\n{$IF Defined(MSWINDOWS)}\n  if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessID] := IntToStr(GetCurrentProcessId);\n  end;\n  if TLogExtendedInfo.EIUserName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIUserName] := GetUserFromWindows;\n  end;\n  if TLogExtendedInfo.EIComputerName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIComputerName] := GetComputerNameFromWindows;\n  end;\n  if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessName] := TPath.GetFileName(GetModuleName(HInstance));\n  end;\n  if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessID] := IntToStr(GetCurrentProcessId);\n  end;\n{$ENDIF}\n{$IF Defined(Android)}\n  if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessName] := TAndroidHelper.ApplicationTitle;\n  end;\n{$ENDIF}\nend;\n\nprocedure TLoggerProDMSContainerAppender.SetOnCreateJSONData(const Value: TOnCreateJSONData);\nbegin\n  fOnCreateJSONData := Value;\nend;\n\nprocedure TLoggerProDMSContainerAppender.SetOnNetSendError(const Value: TOnNetSendError);\nbegin\n  fOnNetSendError := Value;\nend;\n\nprocedure TLoggerProDMSContainerAppender.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProDMSContainerAppender.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProDMSContainerAppender.InternalWriteLog(const aLogItem: TLogItem;\n  const aJSONObject: TJSONObject);\nvar\n  lRetryCount: Integer;\n  lJSONResp: TJSONObject;\nconst\n  MAX_RETRY_COUNT = 5;\nbegin\n  lRetryCount := 0;\n  repeat\n    try\n      lJSONResp := fEventStreamsProxy.EnqueueMessage(fDMSContainerAPIKey, fQueueNameBase + aLogItem.LogTag,\n        aJSONObject);\n      try\n\n      finally\n        lJSONResp.Free;\n      end;\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for net exception, call it\n        if Assigned(fOnNetSendError) then\n          OnNetSendError(Self, aLogItem, E, lRetryCount);\n        Inc(lRetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if lRetryCount >= MAX_RETRY_COUNT then\n          Break;\n      end;\n    end;\n  until False;\n  // finally\n  // FreeAndNil(lHTTPCli);\n  // end;\nend;\n\nprocedure TLoggerProDMSContainerAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lRetryCount: Integer;\n  lJSONResp: TJSONObject;\n  lQueueName: string;\nconst\n  MAX_RETRY_COUNT = 5;\nbegin\n  lRetryCount := 0;\n  repeat\n    try\n      case fLogItemAggregationType of\n        dmsatByTag:\n          lQueueName := fQueueNameBase + aLogItem.LogTag;\n        dmsatByType:\n          lQueueName := fQueueNameBase + aLogItem.LogTypeAsString;\n        dmsatByTagThenType:\n          lQueueName := fQueueNameBase + aLogItem.LogTag + '.' + aLogItem.LogTypeAsString;\n        dmsatByTypeThenTag:\n          lQueueName := fQueueNameBase + aLogItem.LogTypeAsString + '.' + aLogItem.LogTag;\n      else\n        raise ELoggerPro.Create('Invalid Aggregation type');\n      end;\n      lJSONResp := fEventStreamsProxy.EnqueueMessage(fDMSContainerAPIKey,\n        lQueueName,\n        CreateData(aLogItem));\n      try\n\n      finally\n        lJSONResp.Free;\n      end;\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for net exception, call it\n        if Assigned(fOnNetSendError) then\n          OnNetSendError(Self, aLogItem, E, lRetryCount);\n        Inc(lRetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if lRetryCount >= MAX_RETRY_COUNT then\n          Break;\n      end;\n    end;\n  until False;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.IO;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing System.Runtime.InteropServices; \n\nnamespace LoggerPro.Appenders\n{\n    \n    public delegate void OnCreateJSONData(object sender, TLogItem logItem, LoggerProExtendedInfo extendedInfo, JObject data);\n\n    \n    public delegate void OnNetSendError(object sender, TLogItem logItem, Exception netError, ref int retryCount);\n\n    \n    public delegate T GetStoredProc<T>(IDbConnection connection) where T : class;\n\n    \n    public delegate void SetParams<T>(T dataObject, TLogItem logItem) where T : class;\n\n    \n    public enum DMSQueueAggregationType\n    {\n        ByTag,\n        ByType,\n        ByTagThenType,\n        ByTypeThenTag\n    }\n\n    \n    public abstract class LoggerProDMSContainerAppender<T> : LoggerProAppenderBase, ILogAppender where T : class\n    {\n        protected const int MAX_RETRY_COUNT = 5;\n\n        protected OnCreateJSONData _onCreateJSONData;\n        protected OnNetSendError _onNetSendError;\n        protected LoggerProExtendedInfo _extendedInfo;\n        \n        protected Dictionary<LogExtendedInfo, string> _extendedInfoData = new Dictionary<LogExtendedInfo, string>();\n        protected TEventStreamsRPCProxy _eventStreamsProxy;\n        protected string _dmsContainerAPIKey;\n        protected string _queueNameBase;\n        protected DMSQueueAggregationType _logItemAggregationType;\n\n        \n        public OnCreateJSONData OnCreateJSONData\n        {\n            get => _onCreateJSONData;\n            set => _onCreateJSONData = value;\n        }\n\n        public OnNetSendError OnNetSendError\n        {\n            get => _onNetSendError;\n            set => _onNetSendError = value;\n        }\n\n        \n        public LoggerProDMSContainerAppender(\n            TEventStreamsRPCProxy eventStreamsProxy,\n            string dmsContainerAPIKey,\n            string eventStreamsQueueNameBase = \"queues.logs.\",\n            DMSQueueAggregationType logItemAggregationType = DMSQueueAggregationType.ByTag,\n            LoggerProExtendedInfo logExtendedInfo = LoggerProExtendedInfo.Default)\n        {\n            _eventStreamsProxy = eventStreamsProxy ?? throw new ArgumentNullException(nameof(eventStreamsProxy));\n            _dmsContainerAPIKey = dmsContainerAPIKey;\n            _queueNameBase = eventStreamsQueueNameBase.EndsWith(\".\") ? eventStreamsQueueNameBase : eventStreamsQueueNameBase + \".\";\n            _logItemAggregationType = logItemAggregationType;\n            _extendedInfo = logExtendedInfo;\n            LoadExtendedInfo();\n        }\n\n        \n        protected abstract void RefreshParams(T dataObject);\n        protected abstract void ExecuteDataObject(T dataObject);\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        public override void TearDown()\n        {\n            base.TearDown();\n            if (_eventStreamsProxy != null)\n            {\n                _eventStreamsProxy.Dispose();\n                _eventStreamsProxy = null;\n            }\n        }\n\n        public override void TryToRestart(out bool restarted)\n        {\n            restarted = false;\n            try\n            {\n                \n                if (DbObject != null)\n                {\n                    if (DbObject is IDisposable disp)\n                    {\n                        disp.Dispose();\n                    }\n                    DbObject = null;\n                }\n            }\n            catch\n            {\n                // Ignore any errors during cleanup.\n            }\n            \n            restarted = true;\n        }\n\n        \n        protected T DbObject;\n\n        \n        protected virtual JObject GetDefaultLog(TLogItem logItem)\n        {\n            var jo = new JObject();\n            jo[\"timestamp\"] = logItem.TimeStamp.ToString(\"o\"); \n            jo[\"tid\"] = logItem.ThreadID;\n            jo[\"type\"] = logItem.LogTypeAsString;\n            jo[\"text\"] = logItem.LogMessage;\n            jo[\"info\"] = GetExtendedInfo();\n            \n            return jo;\n        }\n\n        \n        protected virtual JObject GetExtendedInfo()\n        {\n            var jo = new JObject();\n#if WINDOWS\n            if (_extendedInfo.HasFlag(LogExtendedInfo.UserName) && _extendedInfoData.ContainsKey(LogExtendedInfo.UserName))\n                jo[\"username\"] = _extendedInfoData[LogExtendedInfo.UserName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ComputerName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ComputerName))\n                jo[\"computername\"] = _extendedInfoData[LogExtendedInfo.ComputerName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessName))\n                jo[\"processname\"] = _extendedInfoData[LogExtendedInfo.ProcessName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessID) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessID))\n                jo[\"pid\"] = _extendedInfoData[LogExtendedInfo.ProcessID];\n#elif ANDROID\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessName))\n                jo[\"processname\"] = _extendedInfoData[LogExtendedInfo.ProcessName];\n#endif\n            return jo;\n        }\n\n        \n        public virtual JObject CreateData(TLogItem logItem)\n        {\n            JObject data;\n            try\n            {\n                if (OnCreateJSONDataCallback != null)\n                {\n                    data = new JObject();\n                    OnCreateJSONDataCallback(this, logItem, _extendedInfo, data);\n                }\n                else\n                {\n                    data = GetDefaultLog(logItem);\n                }\n            }\n            catch\n            {\n                throw;\n            }\n            return data;\n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            while (true)\n            {\n                try\n                {\n                    string queueName;\n                    switch (_logItemAggregationType)\n                    {\n                        case DMSQueueAggregationType.ByTag:\n                            queueName = _queueNameBase + logItem.LogTag;\n                            break;\n                        case DMSQueueAggregationType.ByType:\n                            queueName = _queueNameBase + logItem.LogTypeAsString;\n                            break;\n                        case DMSQueueAggregationType.ByTagThenType:\n                            queueName = _queueNameBase + logItem.LogTag + \".\" + logItem.LogTypeAsString;\n                            break;\n                        case DMSQueueAggregationType.ByTypeThenTag:\n                            queueName = _queueNameBase + logItem.LogTypeAsString + \".\" + logItem.LogTag;\n                            break;\n                        default:\n                            throw new Exception(\"Invalid Aggregation type\");\n                    }\n                    \n                    var data = CreateData(logItem);\n                    \n                    using (var response = _eventStreamsProxy.EnqueueMessage(_dmsContainerAPIKey, queueName, data))\n                    {\n                        // Optionally, process the response.\n                    }\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    if (OnNetSendErrorCallback != null)\n                    {\n                        OnNetSendErrorCallback(this, logItem, ex, ref retryCount);\n                    }\n                    retryCount++;\n                    if (retryCount >= MAX_RETRY_COUNT)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        \n        public static string GetModuleBaseName()\n        {\n#if WINDOWS\n            return Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().Location);\n#elif ANDROID\n            \n            return \"AndroidApp\";\n#else\n            throw new NotSupportedException(\"Current platform not supported by LoggerProDMSContainerAppender\");\n#endif\n        }\n\n        \n        protected virtual void LoadExtendedInfo()\n        {\n#if WINDOWS\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessID))\n                _extendedInfoData[LogExtendedInfo.ProcessID] = System.Diagnostics.Process.GetCurrentProcess().Id.ToString();\n            if (_extendedInfo.HasFlag(LogExtendedInfo.UserName))\n                _extendedInfoData[LogExtendedInfo.UserName] = Environment.UserName;\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ComputerName))\n                _extendedInfoData[LogExtendedInfo.ComputerName] = Environment.MachineName;\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName))\n                _extendedInfoData[LogExtendedInfo.ProcessName] = Path.GetFileName(Assembly.GetExecutingAssembly().Location);\n#elif ANDROID\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName))\n                _extendedInfoData[LogExtendedInfo.ProcessName] = \"AndroidApp\"; \n#endif\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit Serializers.JsonDataObjectsTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  System.Rtti,\n  System.Classes,\n  System.SysUtils,\n  System.DateUtils,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.JsonDataObjects,\n  MVCFramework.Tests.Serializer.Intf,\n  MVCFramework.Tests.Serializer.Entities,\n  MVCFramework.Tests.Serializer.EntitiesModule,\n  JsonDataObjects,\n  MVCFramework.DataSet.Utils;\n\ntype\n\n  [TestFixture]\n  TMVCTestSerializerJsonDataObjects = class(TObject)\n  private\n    fSerializer: IMVCSerializer;\n  public\n    [SetupFixture]\n    procedure SetupFixture;\n    [Setup]\n    procedure Setup;\n    [TearDown]\n    procedure TearDown;\n\n    { serialize declarations }\n    [Test]\n    procedure TestSerializeAsSqids;\n    [Test]\n    procedure TestSerializeAllTypes;\n    [Test]\n    procedure TestSerializeDateTimeProperty;\n    [Test]\n    procedure TestSerializeAllNullableTypes;\n    [Test]\n    procedure TestSerializeAllTypesInList;\n    [Test]\n    procedure TestSerializeEntity;\n    [Test]\n    procedure TestSerializeNil;\n    [Test]\n    procedure TestSerializeEntityUpperCaseNames;\n    [Test]\n    procedure TestSerializeEntityWithArray;\n    [Test]\n    procedure TestSerializeEntityLowerCaseNames;\n    [Test]\n    procedure TestSerializeEntityNameAs;\n    [Test]\n    procedure TestSerializeEntityCustomSerializer;\n    [Test]\n    procedure TestSerializeEntityCustomMemberSerializer;\n    [Test]\n    procedure TestSerializeEntitySerializationType;\n    [Test]\n    procedure TestSerializeCollection;\n    [Test]\n    procedure TestSerializeDataSet;\n    [Test]\n    [Category('datasets')]\n    procedure TestDataSetHelpers;\n    { deserialize declarations }\n    [Test]\n    procedure TestDeserializeEntity;\n    [Test]\n    procedure TestDeserializeEntityCustomSerializer;\n    [Test]\n    procedure TestDeserializeEntityCustomValueTypeSerializer;\n    [Test]\n    procedure TestDeserializeEntityCustomMemberSerializer;\n    [Test]\n    procedure TestDeserializeEntitySerializationType;\n    [Test]\n    procedure TestDeserializeCollection;\n    [Test]\n    procedure TestDeserializeDataSet;\n    [Test]\n    procedure TestSerializeEmptyDataSet;\n    [Test]\n    // [Category('this')]\n    procedure TestDeserializeEntityWithArray;\n    { full cycle }\n    [Test]\n    procedure TestSerializeDeSerializeEntityWithEnums;\n    [Test]\n    procedure TestSerializeDeSerializeEntityWithSet;\n    [Test]\n    procedure TestStringDictionary;\n    [Test]\n    procedure TestSerializeDeserializeGuid;\n    [Test]\n    procedure TestSerializeDeserializeEntityWithInterface;\n\n    [Test]\n    procedure TestSerializeDeserializeGenericEntity;\n    [Test]\n    procedure TestSerializeDeserializeMultipleGenericEntity;\n    [Test]\n    procedure TestDoNotSerializeDoNotDeSerialize;\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListOfSomething;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListWithNulls;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListWithNulls2;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNotExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithFieldsUnassigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedField_WithFieldsAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists_Polimorphic;\n\n    [Test]\n    [Category('issues')]\n    procedure TestIssue792;\n  end;\n\n  TMVCEntityCustomSerializerJsonDataObjects = class(TInterfacedObject, IMVCTypeSerializer)\n  private\n    { private declarations }\n  protected\n    procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n      const AAttributes: TArray<TCustomAttribute>);\n  public\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n\n  end;\n\n  TMVCNullableIntegerSerializerJsonDataObjects = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n  end;\n\n  /// <summary>\n  /// When using nested generic types it is necessary to declare explicitly for delphi's RTTI to recognize them.\n  /// </summary>\n  TNestedGenericEntity = TGenericEntity<TGenericEntity<TNote>>;\n\n  TMyObj = class\n  private\n    fName: string;\n    fNumber: integer;\n  public\n    property Name: string read FName write FName;\n    property Number: integer read FNumber write FNumber;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Serializer.JsonDataObjects.CustomTypes,\n  MVCFramework.Commons, System.TypInfo, BOs, BusinessObjectsU;\n\nconst\n  LINE_BREAK = #$A;\n  TAB_SPACE = #9;\n\n  { TMVCTestSerializerJsonDataObjects }\n\nprocedure TMVCTestSerializerJsonDataObjects.Setup;\nbegin\n  inherited;\n  fSerializer := TMVCJsonDataObjectsSerializer.Create;\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TStringStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TMemoryStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TEntityCustom), TMVCEntityCustomSerializerJsonDataObjects.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TMVCNullable<Integer>),\n    TMVCNullableIntegerSerializerJsonDataObjects.Create);\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.SetupFixture;\nbegin\n  FormatSettings.ShortDateFormat := 'dd/mm/yyyy';\n  FormatSettings.DateSeparator:= '/';\n  FormatSettings.TimeSeparator:= ':';\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TearDown;\nbegin\n  inherited;\n  fSerializer := nil;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDataSetHelpers;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50.000+01:00\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Amount\":100.0,' + '\"BlobFld\":\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\",' +\n    '\"Items\":[' + '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id\":2,' + '\"Name\":\"Juliano\"' +\n    '}' + '],' + '\"Departament\":{' + '\"Name\":\"Depto1\"' + '},' + '\"GUID\":\"{9386C957-5379-4370-8492-8FA464A9CF0C}\"' + '}';\n\n  JSON_LOWERCASE = '{' + '\"id\":1,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_UPPERCASE = '{' + '\"ID\":1,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_ASIS = '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_LIST = '[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id_Id\":2,' +\n    '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}' + ']';\n\nvar\n  Dm: TEntitiesModule;\n  S: string;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    Dm.Entity.Insert;\n    Dm.EntityId.AsLargeInt := 1;\n    Dm.EntityCode.AsInteger := 2;\n    Dm.EntityName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityBirthday.AsDateTime := StrToDate('15/10/1987');\n    Dm.EntityAccessDateTime.AsDateTime := StrToDateTime('17/02/2017 16:37:50');\n    Dm.EntityAccessTime.AsDateTime := StrToTime('16:40:50');\n    Dm.EntityActive.AsBoolean := True;\n    Dm.EntitySalary.AsCurrency := 100;\n    Dm.EntityAmount.AsFloat := 100;\n    Dm.EntityBlobFld.AsString := '<html><body><h1>BLOB</h1></body></html>';\n    Dm.EntityGUID.AsGuid := StringToGUID('{9386C957-5379-4370-8492-8FA464A9CF0C}');\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 1;\n    Dm.ItemName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.Item.Post;\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 2;\n    Dm.ItemName.AsString := 'Juliano';\n    Dm.Item.Post;\n\n    Dm.Departament.Insert;\n    Dm.DepartamentName.AsString := 'Depto1';\n    Dm.Departament.Post;\n\n    S := Dm.Entity.AsJSONObject(ncAsIs, ['Ignored']);\n    Assert.areEqual(JSON, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncAsIs);\n    Assert.areEqual(JSON_ASIS, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncUpperCase);\n    Assert.areEqual(JSON_UPPERCASE, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncLowerCase);\n    Assert.areEqual(JSON_LOWERCASE, S, False);\n\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeCollection;\n\n  procedure CheckObjectList(const AList: TObjectList<TNote>);\n  begin\n    Assert.isTrue(AList.Count = 4);\n    Assert.isTrue(AList.Items[0].Description = 'Description 1');\n    Assert.isTrue(AList.Items[1].Description = 'Description 2');\n    Assert.isTrue(AList.Items[2].Description = 'Description 3');\n    Assert.isTrue(AList.Items[3].Description = 'Description 4');\n  end;\n\nconst\n  JSON_PROPERTIES = '[' + '{' + '\"Description\":\"Description 1\"' + '},' + '{' + '\"Description\":\"Description 2\"' + '},' +\n    '{' + '\"Description\":\"Description 3\"' + '},' + '{' + '\"Description\":\"Description 4\"' + '}' + ']';\n\n  JSON_FIELDS = '[' + '{' + '\"FDescription\":\"Description 1\"' + '},' + '{' + '\"FDescription\":\"Description 2\"' + '},' +\n    '{' + '\"FDescription\":\"Description 3\"' + '},' + '{' + '\"FDescription\":\"Description 4\"' + '}' + ']';\nvar\n  O: TObjectList<TNote>;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TObjectList<TNote>.Create(True);\n  try\n    fSerializer.DeserializeCollection(JSON_PROPERTIES, O, TNote);\n    CheckObjectList(O);\n  finally\n    O.Free;\n  end;\n\n  O := TObjectList<TNote>.Create(True);\n  try\n    fSerializer.DeserializeCollection(JSON_FIELDS, O, TNote, stFields);\n    CheckObjectList(O);\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeDataSet;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17 16:37:50\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Amount\":100.0,' + '\"BlobFld\":\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\",' +\n    '\"Items\":[' + '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel\"' + '},' + '{' + '\"Id\":2,' + '\"Name\":\"Juliano\"' + '}' + '],' +\n    '\"Departament\":{' + '\"Name\":\"Depto1\"' + '},' + '\"GUID\":\"{9386C957-5379-4370-8492-8FA464A9CF0C}\"' + '}';\n\n  JSON_LOWERCASE = '{' + '\"id\":1,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_UPPERCASE = '{' + '\"ID\":1,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_ASIS = '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_LIST = '[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id_Id\":2,' +\n    '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}' + ']';\n\n  JSON_ITEMS = '{' + '\"items\":[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Pedro Henrique de Oliveira\"' + '},' + '{' +\n    '\"Id_Id\":2,' + '\"Name_Name\":\"Rogers Abe\"' + '}' + '],' + '\"meta\":{\"count\":\"2\"}}';\nvar\n  Dm: TEntitiesModule;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    fSerializer.DeserializeDataSetRecord(JSON, Dm.Entity, ['Ignored']);\n    Assert.isTrue(Dm.EntityId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityCode.AsInteger = 2);\n    Assert.isTrue(Dm.EntityName.AsString = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(Dm.EntityBirthday.AsDateTime = StrToDate('15/10/1987'));\n    Assert.isTrue(Dm.EntityAccessDateTime.AsDateTime = StrToDateTime('17/02/2017 16:37:50'));\n    Assert.isTrue(Dm.EntityAccessTime.AsDateTime = StrToTime('16:40:50'));\n    Assert.isTrue(Dm.EntityActive.AsBoolean = True);\n    Assert.isTrue(Dm.EntitySalary.AsCurrency = 100);\n    Assert.isTrue(Dm.EntityAmount.AsFloat = 100);\n    Assert.isTrue(Dm.EntityBlobFld.AsString = '<html><body><h1>BLOB</h1></body></html>');\n    Assert.isTrue(GUIDToString(Dm.EntityGUID.AsGuid) = '{9386C957-5379-4370-8492-8FA464A9CF0C}');\n\n    Dm.Item.First;\n    Assert.isTrue(Dm.ItemId.AsLargeInt = 1);\n    Assert.isTrue(Dm.ItemName.AsString = 'Ezequiel');\n\n    Dm.Item.Next;\n    Assert.isTrue(Dm.ItemId.AsLargeInt = 2);\n    Assert.isTrue(Dm.ItemName.AsString = 'Juliano');\n\n    Dm.Departament.First;\n    Assert.isTrue(Dm.DepartamentName.AsString = 'Depto1');\n\n    fSerializer.DeserializeDataSetRecord(JSON_LOWERCASE, Dm.EntityLowerCase);\n    Assert.isTrue(Dm.EntityLowerCaseId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityLowerCaseName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_UPPERCASE, Dm.EntityUpperCase);\n    Assert.isTrue(Dm.EntityUpperCaseId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityUpperCaseName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_UPPERCASE, Dm.EntityUpperCase2, [], ncUpperCase);\n    Assert.isTrue(Dm.EntityUpperCase2Id.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityUpperCase2Name.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_ASIS, Dm.EntityAsIs);\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.EmptyDataSet;\n    fSerializer.DeserializeDataSet(JSON_LIST, Dm.EntityAsIs);\n    Dm.EntityAsIs.First;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.Next;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 2);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.EmptyDataSet;\n    Dm.EntityAsIs.LoadJSONArrayFromJSONObjectProperty('items', JSON_ITEMS, ncAsIs);\n    Dm.EntityAsIs.First;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Pedro Henrique de Oliveira');\n\n    Dm.EntityAsIs.Next;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 2);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Rogers Abe');\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntity;\n\n  procedure CheckObject(const AEntity: TEntity);\n  begin\n    Assert.isTrue(AEntity.Id = 1);\n    Assert.isTrue(AEntity.Code = 2);\n    Assert.isTrue(AEntity.Name = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(AEntity.Salary = 100);\n    Assert.isTrue(DateToStr(AEntity.Birthday) = '15/10/1987');\n    Assert.isTrue(DateTimeToStr(AEntity.AccessDateTime) = '17/02/2017 16:37:50');\n    Assert.isTrue(TimeToStr(AEntity.AccessTime) = '16:40:50');\n    Assert.isTrue(AEntity.Active = True);\n    Assert.isTrue(AEntity.Role = TRole.roGuest);\n    Assert.isTrue(DateTimeToStr(TimeStampToDateTime(AEntity.Temporization)) = '17/02/2017 16:37:50');\n    Assert.isTrue(AEntity.Department <> nil);\n    Assert.isTrue(AEntity.Department.Id = 1);\n    Assert.isTrue(AEntity.Department.Name = 'Development');\n    Assert.isTrue(AEntity.DepartmentNull = nil);\n    Assert.isTrue(AEntity.Notes.Count = 2);\n    Assert.isTrue(AEntity.Notes[0].Description = 'EntNote1');\n    Assert.isTrue(AEntity.Notes[1].Description = 'EntNote2');\n    Assert.isTrue(AEntity.NotesEmpty.Count = 0);\n    Assert.isTrue(AEntity.AppreciationAs.AsString = 'Yes');\n    Assert.isTrue(AEntity.Appreciation.AsString = 'Yes');\n  end;\n\nconst\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Role\":\"roGuest\",' + '\"Temporization\":63623032670000,' + '\"Department\":{' + '\"Id\":1,' +\n    '\"Name\":\"Development\",' + '\"Notes\":[' + '{' + '\"Description\":\"DepNote1\"' + '},' + '{' + '\"Description\":\"DepNote2\"' +\n    '}' + ']' + '},' + '\"DepartmentNull\":null,' + '\"Notes\":[' + '{' + '\"Description\":\"EntNote1\"' + '},' + '{' +\n    '\"Description\":\"EntNote2\"' + '}' + '],' + '\"NotesEmpty\":[],' + '\"AppreciationAs\":\"Yes\",' + '\"Appreciation\":{' +\n    '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\n\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\",' + '\"FSalary\":100.0,' +\n    '\"FBirthday\":\"1987-10-15\",' + '\"FAccessDateTime\":\"2017-02-17T16:37:50\",' + '\"FAccessTime\":\"16:40:50\",' +\n    '\"FActive\":true,' + '\"FRole\":\"roGuest\",' + '\"FTemporization\":63623032670000,' + '\"FDepartment\":{' + '\"FId\":1,' +\n    '\"FName\":\"Development\",' + '\"FNotes\":[' + '{' + '\"FDescription\":\"DepNote1\"' + '},' + '{' +\n    '\"FDescription\":\"DepNote2\"' + '}' + ']' + '},' + '\"FDepartmentNull\":null,' + '\"FNotes\":[' + '{' +\n    '\"FDescription\":\"EntNote1\"' + '},' + '{' + '\"FDescription\":\"EntNote2\"' + '}' + '],' + '\"FNotesEmpty\":[],' +\n    '\"FAppreciationAs\":\"Yes\",' + '\"FAppreciation\":{' + '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\nvar\n  O: TEntity;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntity.Create;\n  try\n    fSerializer.DeserializeObject(JSON_PROPERTIES, O);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n\n  O := TEntity.Create;\n  try\n    fSerializer.DeserializeObject(JSON_FIELDS, O, stFields);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomMemberSerializer;\nconst\n  JSON = '{' + '\"Entity\":{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' +\n    '\"Notes\":\"RXplcXVpZWwgSnVsaWFubyBN/GxsZXI=\",' + '\"NotesAsString\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TSale;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TSale.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Entity.Id = 1);\n    Assert.isTrue(O.Entity.Code = 2);\n    Assert.isTrue(O.Entity.Name = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(O.Notes.DataString = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(O.NotesAsString.DataString = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomSerializer;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityCustom;\nbegin\n  O := TEntityCustom.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Id = 1);\n    Assert.isTrue(O.Code = 2);\n    Assert.isTrue(O.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomValueTypeSerializer;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"NullableInteger\":3' + '}';\nvar\n  O: TEntityCustomWithNullables;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntityCustomWithNullables.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Id = 1);\n    Assert.isTrue(O.Code = 2);\n    Assert.isTrue(O.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntitySerializationType;\nconst\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  OFields: TEntitySerializeFields;\n  OProperties: TEntitySerializeProperties;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  OFields := TEntitySerializeFields.Create;\n  try\n    fSerializer.DeserializeObject(JSON_FIELDS, OFields);\n    Assert.isTrue(OFields.Id = 1);\n    Assert.isTrue(OFields.Code = 2);\n    Assert.isTrue(OFields.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    OFields.Free;\n  end;\n\n  OProperties := TEntitySerializeProperties.Create;\n  try\n    fSerializer.DeserializeObject(JSON_PROPERTIES, OProperties);\n    Assert.isTrue(OProperties.Id = 1);\n    Assert.isTrue(OProperties.Code = 2);\n    Assert.isTrue(OProperties.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    OProperties.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityWithArray;\n  procedure CheckObject(const AEntity: TEntityWithArray);\n  begin\n    Assert.isTrue(AEntity.Id = 1);\n    Assert.isTrue(AEntity.Names[0] = 'Pedro');\n    Assert.isTrue(AEntity.Names[1] = 'Oliveira');\n    Assert.isTrue(AEntity.Values[0] = 1);\n    Assert.isTrue(AEntity.Values[1] = 2);\n    Assert.isTrue(AEntity.Booleans[0] = True);\n    Assert.isTrue(AEntity.Booleans[1] = False);\n    Assert.isTrue(AEntity.Booleans[2] = True);\n  end;\n\nconst\n  JSON_WITH_ARRAY = '{' + '\"Id\":1,' + '\"Names\":[\"Pedro\",\"Oliveira\"],' + '\"Values\":[1,2],\"Booleans\":[true,false,true]}';\nvar\n  O: TEntityWithArray;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntityWithArray.Create;\n  try\n    fSerializer.DeserializeObject(JSON_WITH_ARRAY, O);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.Te", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Globalization;\nusing NUnit.Framework;\nusing MVCFramework.Serializer.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.JsonDataObjects;\nusing MVCFramework.Tests.Serializer.Intf;\nusing MVCFramework.Tests.Serializer.Entities;\nusing MVCFramework.Tests.Serializer.EntitiesModule;\nusing JsonDataObjects;\nusing MVCFramework.DataSet.Utils;\n\nnamespace MVCFramework.Tests.Serializer\n{\n    [TestFixture]\n    public class MVCTestSerializerJsonDataObjects\n    {\n        private IMVCSerializer fSerializer;\n\n        [OneTimeSetUp]\n        public void SetupFixture()\n        {\n            CultureInfo.CurrentCulture = new CultureInfo(\"en-GB\");\n            CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern = \"dd/MM/yyyy\";\n            CultureInfo.CurrentCulture.DateTimeFormat.DateSeparator = \"/\";\n            CultureInfo.CurrentCulture.DateTimeFormat.TimeSeparator = \":\";\n        }\n\n        [SetUp]\n        public void Setup()\n        {\n            fSerializer = new TMVCJsonDataObjectsSerializer();\n            fSerializer.RegisterTypeSerializer(typeof(Stream), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(StringReader), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(MemoryStream), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(EntityCustom), new TMVCEntityCustomSerializerJsonDataObjects());\n            fSerializer.RegisterTypeSerializer(typeof(TMVCNullable<int>), new TMVCNullableIntegerSerializerJsonDataObjects());\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            fSerializer = null;\n        }\n\n        [Test]\n        public void TestDataSetHelpers()\n        {\n            TEntitiesModule dm = new TEntitiesModule(null);\n            try\n            {\n                dm.Entity.Insert();\n                dm.EntityId.AsLargeInt = 1;\n                dm.EntityCode.AsInteger = 2;\n                dm.EntityName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityBirthday.AsDateTime = DateTime.ParseExact(\"15/10/1987\", \"dd/MM/yyyy\", CultureInfo.InvariantCulture);\n                dm.EntityAccessDateTime.AsDateTime = DateTime.Parse(\"17/02/2017 16:37:50\");\n                dm.EntityAccessTime.AsDateTime = DateTime.ParseExact(\"16:40:50\", \"HH:mm:ss\", CultureInfo.InvariantCulture);\n                dm.EntityActive.AsBoolean = true;\n                dm.EntitySalary.AsCurrency = 100;\n                dm.EntityAmount.AsFloat = 100;\n                dm.EntityBlobFld.AsString = \"<html><body><h1>BLOB</h1></body></html>\";\n                dm.EntityGUID.AsGuid = Guid.Parse(\"{9386C957-5379-4370-8492-8FA464A9CF0C}\");\n\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 1;\n                dm.ItemName.AsString = \"Ezequiel\";\n                dm.Item.Post();\n\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 2;\n                dm.ItemName.AsString = \"Juliano\";\n                dm.Item.Post();\n\n                dm.Departament.Insert();\n                dm.DepartamentName.AsString = \"Depto1\";\n                dm.Departament.Post();\n\n                string s = dm.Entity.AsJSONObject(MVCNameCaseDefault.ncAsIs, new List<string> { \"Ignored\" });\n                Assert.AreEqual(\"{\\\"Id\\\":1,\\\"Code\\\":2,\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\",\\\"Salary\\\":100.0,\\\"Birthday\\\":\\\"1987-10-15\\\",\\\"AccessDateTime\\\":\\\"2017-02-17T16:37:50.000+01:00\\\",\\\"AccessTime\\\":\\\"16:40:50\\\",\\\"Active\\\":true,\\\"Amount\\\":100.0,\\\"BlobFld\\\":\\\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\\\",\\\"GUID\\\":\\\"{9386C957-5379-4370-8492-8FA464A9CF0C}\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncAsIs);\n                Assert.AreEqual(\"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncUpperCase);\n                Assert.AreEqual(\"{\\\"ID\\\":1,\\\"NAME\\\":\\\"Ezequiel\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncLowerCase);\n                Assert.AreEqual(\"{\\\"id\\\":1,\\\"name\\\":\\\"ezequiel\\\"}\", s);\n            }\n            finally\n            {\n                dm.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestDeserializeCollection()\n        {\n            void CheckObjectList(IList<TNote> list)\n            {\n                Assert.IsTrue(list.Count == 4);\n                Assert.IsTrue(list[0].Description == \"Description 1\");\n                Assert.IsTrue(list[1].Description == \"Description 2\");\n                Assert.IsTrue(list[2].Description == \"Description 3\");\n                Assert.IsTrue(list[3].Description == \"Description 4\");\n            }\n            const string JSON_PROPERTIES = \"[{\\\"Description\\\":\\\"Description 1\\\"},{\\\"Description\\\":\\\"Description 2\\\"},{\\\"Description\\\":\\\"Description 3\\\"},{\\\"Description\\\":\\\"Description 4\\\"}]\";\n            const string JSON_FIELDS = \"[{\\\"FDescription\\\":\\\"Description 1\\\"},{\\\"FDescription\\\":\\\"Description 2\\\"},{\\\"FDescription\\\":\\\"Description 3\\\"},{\\\"FDescription\\\":\\\"Description 4\\\"}]\";\n            var list1 = new List<TNote>();\n            fSerializer.DeserializeCollection(JSON_PROPERTIES, list1, typeof(TNote));\n            CheckObjectList(list1);\n            var list2 = new List<TNote>();\n            fSerializer.DeserializeCollection(JSON_FIELDS, list2, typeof(TNote), TMVCSerializationType.stFields);\n            CheckObjectList(list2);\n        }\n\n        [Test]\n        public void TestDeserializeDataSet()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\",\" +\n                \"\\\"Salary\\\":100.0,\" +\n                \"\\\"Birthday\\\":\\\"1987-10-15\\\",\" +\n                \"\\\"AccessDateTime\\\":\\\"2017-02-17 16:37:50\\\",\" +\n                \"\\\"AccessTime\\\":\\\"16:40:50\\\",\" +\n                \"\\\"Active\\\":true,\" +\n                \"\\\"Amount\\\":100.0,\" +\n                \"\\\"BlobFld\\\":\\\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\\\",\" +\n                \"\\\"Items\\\":[{\\\"Id\\\":1,\\\"Name\\\":\\\"Ezequiel\\\"},{\\\"Id\\\":2,\\\"Name\\\":\\\"Juliano\\\"}],\" +\n                \"\\\"Departament\\\":{\\\"Name\\\":\\\"Depto1\\\"},\" +\n                \"\\\"GUID\\\":\\\"{9386C957-5379-4370-8492-8FA464A9CF0C}\\\"\" +\n                \"}\";\n            const string JSON_LOWERCASE = \"{\\\"id\\\":1,\\\"name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_UPPERCASE = \"{\\\"ID\\\":1,\\\"NAME\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_ASIS = \"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_LIST = \"[\" +\n                \"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"},\" +\n                \"{\\\"Id_Id\\\":2,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\" +\n                \"]\";\n            var dm = new TEntitiesModule(null);\n            try\n            {\n                dm.Entity.Insert();\n                dm.EntityId.AsLargeInt = 1;\n                dm.EntityCode.AsInteger = 2;\n                dm.EntityName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityBirthday.AsDateTime = DateTime.ParseExact(\"15/10/1987\", \"dd/MM/yyyy\", CultureInfo.InvariantCulture);\n                dm.EntityAccessDateTime.AsDateTime = DateTime.Parse(\"17/02/2017 16:37:50\");\n                dm.EntityAccessTime.AsDateTime = DateTime.ParseExact(\"16:40:50\", \"HH:mm:ss\", CultureInfo.InvariantCulture);\n                dm.EntityActive.AsBoolean = true;\n                dm.EntitySalary.AsCurrency = 100;\n                dm.EntityAmount.AsFloat = 100;\n                dm.EntityBlobFld.AsString = \"<html><body><h1>BLOB</h1></body></html>\";\n                dm.EntityGUID.AsGuid = Guid.Parse(\"{9386C957-5379-4370-8492-8FA464A9CF0C}\");\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 1;\n                dm.ItemName.AsString = \"Ezequiel\";\n                dm.Item.Post();\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 2;\n                dm.ItemName.AsString = \"Juliano\";\n                dm.Item.Post();\n                dm.Departament.Insert();\n                dm.DepartamentName.AsString = \"Depto1\";\n                dm.Departament.Post();\n                dm.Entity.Post();\n                string s = fSerializer.SerializeDataSetRecord(dm.Entity, new List<string> { \"Ignored\" });\n                Assert.AreEqual(JSON, s);\n                dm.EntityLowerCase.Insert();\n                dm.EntityLowerCaseId.AsLargeInt = 1;\n                dm.EntityLowerCaseName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityLowerCase.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityLowerCase);\n                Assert.AreEqual(JSON_LOWERCASE, s);\n                dm.EntityUpperCase.Insert();\n                dm.EntityUpperCaseId.AsLargeInt = 1;\n                dm.EntityUpperCaseName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityUpperCase.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityUpperCase);\n                Assert.AreEqual(JSON_UPPERCASE, s);\n                dm.EntityUpperCase2.Insert();\n                dm.EntityUpperCase2Id.AsLargeInt = 1;\n                dm.EntityUpperCase2Name.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityUpperCase2.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityUpperCase2, new List<string>(), MVCNameCaseDefault.ncUpperCase);\n                Assert.AreEqual(JSON_UPPERCASE, s);\n                dm.EntityAsIs.Insert();\n                dm.EntityAsIsId.AsLargeInt = 1;\n                dm.EntityAsIsName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityAsIs.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityAsIs);\n                Assert.AreEqual(JSON_ASIS, s);\n                dm.EntityAsIs.Append();\n                dm.EntityAsIsId.AsLargeInt = 2;\n                dm.EntityAsIsName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityAsIs.Post();\n                s = fSerializer.SerializeDataSet(dm.EntityAsIs);\n                Assert.AreEqual(JSON_LIST, s);\n                s = fSerializer.SerializeObject(dm.EntityAsIs);\n                Assert.AreEqual(JSON_LIST, s);\n            }\n            finally\n            {\n                dm.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDateTimeProperty()\n        {\n            TMyObjectWithUTC obj1 = new TMyObjectWithUTC();\n            try\n            {\n                obj1.MyDateTime = new DateTime(2020, 11, 4, 12, 12, 12, 0);\n                string ser = fSerializer.SerializeObject(obj1);\n                TMyObjectWithUTC obj2 = new TMyObjectWithUTC();\n                try\n                {\n                    fSerializer.DeserializeObject(ser, obj2);\n                    Assert.IsTrue(obj1.Equals(obj2));\n                }\n                finally\n                {\n                    obj2.Dispose();\n                }\n            }\n            finally\n            {\n                obj1.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithEnums()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Daniele Teti\\\",\" +\n                \"\\\"Color\\\":\\\"RED\\\",\" +\n                \"\\\"MonthName\\\":\\\"January\\\",\" +\n                \"\\\"MonthName2\\\":\\\"meFebruary\\\",\" +\n                \"\\\"MonthOrder\\\":0\" +\n                \"}\";\n            TEntityWithEnums o = new TEntityWithEnums();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Daniele Teti\";\n                o.Color = TColorEnum.RED;\n                o.MonthName = TMonthEnum.meJanuary;\n                o.MonthName2 = TMonthEnum.meFebruary;\n                o.MonthOrder = TMonthEnum.meJanuary;\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n            o = new TEntityWithEnums();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, o);\n                Assert.AreEqual(1, o.Id);\n                Assert.AreEqual(2, o.Code);\n                Assert.AreEqual(\"Daniele Teti\", o.Name);\n                Assert.AreEqual((int)TMonthEnum.meJanuary, (int)o.MonthName);\n                Assert.AreEqual((int)TMonthEnum.meFebruary, (int)o.MonthName2);\n                Assert.AreEqual((int)TMonthEnum.meJanuary, (int)o.MonthOrder);\n                Assert.AreEqual((int)TColorEnum.RED, (int)o.Color);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityCustomMemberSerializer()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Entity\\\":{\" +\n                \"\\\"AId\\\":1,\" +\n                \"\\\"ACode\\\":2,\" +\n                \"\\\"AName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"},\" +\n                \"\\\"Notes\\\":\\\"RXplcXVpZWwgSnVsaWFubyBN/GxsZXI=\\\",\" +\n                \"\\\"NotesAsString\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TSale o = new TSale();\n            try\n            {\n                o.Entity.Id = 1;\n                o.Entity.Code = 2;\n                o.Entity.Name = \"Ezequiel Juliano M\u00fcller\";\n                o.Notes.WriteString(\"Ezequiel Juliano M\u00fcller\");\n                o.NotesAsString.WriteString(\"Ezequiel Juliano M\u00fcller\");\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityCustomSerializer()\n        {\n            const string JSON = \"{\" +\n                \"\\\"AId\\\":1,\" +\n                \"\\\"ACode\\\":2,\" +\n                \"\\\"AName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityCustom o = new TEntityCustom();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityLowerCaseNames()\n        {\n            const string JSON = \"{\" +\n                \"\\\"id\\\":1,\" +\n                \"\\\"code\\\":2,\" +\n                \"\\\"name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityLowerCase o = new TEntityLowerCase();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityNameAs()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id_Id\\\":1,\" +\n                \"\\\"Code_Code\\\":2,\" +\n                \"\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityNameAs o = new TEntityNameAs();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n                s = fSerializer.SerializeObject(o, TMVCSerializationType.stFields);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntitySerializationType()\n        {\n            const string JSON_FIELDS = \"{\" +\n                \"\\\"FId\\\":1,\" +\n                \"\\\"FCode\\\":2,\" +\n                \"\\\"FName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            const string JSON_PROPERTIES = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntitySerializeFields oFields = new TEntitySerializeFields();\n            try\n            {\n                oFields.Id = 1;\n                oFields.Code = 2;\n                oFields.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(oFields);\n                Assert.AreEqual(JSON_FIELDS, s);\n            }\n            finally\n            {\n                oFields.Dispose();\n            }\n            TEntitySerializeProperties oProperties = new TEntitySerializeProperties();\n            try\n            {\n                oProperties.Id = 1;\n                oProperties.Code = 2;\n                oProperties.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(oProperties);\n                Assert.AreEqual(JSON_PROPERTIES, s);\n            }\n            finally\n            {\n                oProperties.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityUpperCaseNames()\n        {\n            const string JSON = \"{\" +\n                \"\\\"ID\\\":1,\" +\n                \"\\\"CODE\\\":2,\" +\n                \"\\\"NAME\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityUpperCase o = new TEntityUpperCase();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityWithArray()\n        {\n            const string JSON_WITH_ARRAY = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Names\\\":[\\\"Pedro\\\",\\\"Oliveira\\\"],\" +\n                \"\\\"Values\\\":[1,2],\" +\n                \"\\\"Values8\\\":[7,8],\" +\n                \"\\\"Values64\\\":[3,4],\" +\n                \"\\\"Booleans\\\":[true,false,true]\" +\n                \"}\";\n            TEntityWithArray o = new TEntityWithArray();\n            try\n            {\n                o.Id = 1;\n                o.Names = new string[] { \"Pedro\", \"Oliveira\" };\n                o.Values = new int[] { 1, 2 };\n                o.Values8 = new byte[] { 7, 8 };\n                o.Values64 = new long[] { 3, 4 };\n                o.Booleans = new bool[] { true, false, true };\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON_WITH_ARRAY, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListOfSomething()\n        {\n            TListOfSomething list = new TListOfSomething();\n            try\n            {\n                string s = fSerializer.SerializeObject(list);\n                Assert.AreEqual(\"[\" +\n                    \"{\\\"Description\\\":\\\"Description 1\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 2\\\"}\" +\n                    \"]\", s);\n                s = fSerializer.SerializeObject(list, TMVCSerializationType.stFields);\n                Assert.AreEqual(\"[\" +\n                    \"{\\\"FDescription\\\":\\\"Description 1\\\"},\" +\n                    \"{\\\"FDescription\\\":\\\"Description 2\\\"}\" +\n                    \"]\", s);\n            }\n            finally\n            {\n                list.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListWithNulls()\n        {\n            TPeople people = new TPeople();\n            try\n            {\n                TPerson person = new TPerson();\n                person.Id = 1;\n                person.FirstName = \"Daniele\";\n                person.LastName = \"Teti\";\n                people.Add(person);\n                people.Add(null);\n                string s = fSerializer.SerializeObject(people);\n                JsonObject jObj = JsonObject.Parse(s) as JsonObject;\n                Assert.IsFalse(jObj.A(\"List\").Items[0].IsNull);\n                Assert.IsTrue(jObj.A(\"List\").Items[1].IsNull);\n            }\n            finally\n            {\n                people.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListWithNulls2()\n        {\n            TPeople people = new TPeople();\n            try\n            {\n                TPerson person = new TPerson();\n                person.Id = 1;\n                person.FirstName = \"Daniele\";\n                person.LastName = \"Teti\";\n                people.Add(person);\n                people.Add(null);\n                string s = fSerializer.SerializeCollection(people);\n                JsonArray jArr = JsonObject.Parse(s) as JsonArray;\n                Assert.IsFalse(jArr.Items[0].IsNull);\n                Assert.IsTrue(jArr.Items[1].IsNull);\n            }\n            finally\n            {\n                people.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                \"\\\"Code\\\":10,\" +\n                \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46ba-bfde-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46ba-bfde-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestDoNotSerializeDoNotDeSerialize()\n        {\n            TPartialSerializableType obj = new TPartialSerializableType();\n            try\n            {\n                string s = fSerializer.SerializeObject(obj);\n                Assert.IsFalse(s.Contains(\"prop1\"));\n                Assert.IsTrue(s.Contains(\"prop2\"));\n                Assert.IsFalse(s.Contains(\"prop3\"));\n                Assert.IsTrue(s.Contains(\"prop4\"));\n            }\n            finally\n            {\n                obj.Dispose();\n            }\n            obj = new TPartialSerializableType();\n            try\n            {\n                fSerializer.DeserializeObject(\"{\\\"prop1\\\":\\\"x1\\\",\\\"prop2\\\":\\\"x2\\\",\\\"prop3\\\":\\\"x3\\\",\\\"prop4\\\":\\\"x4\\\"}\", obj);\n                Assert.AreEqual(\"x1\", obj.Prop1);\n                Assert.AreEqual(\"prop2\", obj.Prop2);\n                Assert.AreEqual(\"prop3\", obj.Prop3);\n                Assert.AreEqual(\"x4\", obj.Prop4);\n            }\n            finally\n            {\n                obj.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestIssue792()\n        {\n            TMyObj myObj = new TMyObj();\n            try\n            {\n                myObj.Name = \"will be changed\";\n                IMVCSerializer ser = new TMVCJsonDataObjectsSerializer();\n                ser.DeserializeObject(\"{ \\\"dataobject\\\" : { \\\"name\\\" : \\\"Daniele\\\", \\\"number\\\" : 123 } }\", myObj, TMVCSerializationType.stDefault, null, \"dataobject\");\n                Assert.IsTrue(ser.SerializeObject(myObj).Contains(\"Daniele\"));\n            }\n            finally\n            {\n                myObj.Dispose();\n            }\n            myObj = new TMyObj();\n            try\n            {\n                IMVCSerializer ser = new TMVCJsonDataObjectsSerializer();\n                myObj.Name = \"the untouchable\";\n                ser.DeserializeObject(\"{ \\\"dataobject\\\" : null}\", myObj, TMVCSerializationType.stDefault, null, \"dataobject\");\n                Assert.IsTrue(ser.SerializeObject(myObj).Contains(\"the untouchable\"));\n            }\n            finally\n            {\n                myObj.Dispose();\n            }\n        }\n    }\n\n    public class MVCTestSerializerJsonDataObjects_EntityCustomSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(TValue elementValue, out object serializerObject, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            serializerObject = new JsonObject();\n            ((JsonObject)serializerObject).L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).S[\"AName\"] = entity.Name;\n        }\n\n        public void SerializeAttribute(TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            ((JsonObject)serializerObject).Object[propertyName].L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).Object[propertyName].I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).Object[propertyName].S[\"AName\"] = entity.Name;\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, TCustomAttribute[] attributes, TMVCSerializationAction serializationAction = null)\n        {\n            TEntityCustom entity = obj as TEntityCustom;\n            serializerObject = new JsonObject();\n            ((JsonObject)serializerObject).L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).S[\"AName\"] = entity.Name;\n        }\n\n        public void Deserialize(object serializedObject, ref TValue elementValue, TCustomAttribute[] attributes)\n        {\n            JsonObject json = serializedObject as JsonObject;\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            entity.Id = json.I[\"AId\"];\n            entity.Code = json.I[\"ACode\"];\n            entity.Name = json.S[\"AName\"];\n        }\n\n        public void DeserializeAttribute(ref TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n            DeserializeRoot(serializerObject, ref elementValue, attributes);\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = obj as TEntityCustom;\n            JsonObject json = serializerObject as JsonObject;\n            entity.Id = json.I[\"AId\"];\n            entity.Code = json.I[\"ACode\"];\n            entity.Name = json.S[\"AName\"];\n        }\n    }\n\n    public class MVCTestSerializerJsonDataObjects_NullableIntegerSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(TValue elementValue, out object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void SerializeAttribute(TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, TCustomAttribute[] attributes, TMVCSerializationAction serializationAction = null)\n        {\n        }\n\n        public void Deserialize(object serializerObject, ref TValue elementValue, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void DeserializeAttribute(ref TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, TCustomAttribute[] attributes)\n        {\n        }\n    }\n\n    public static class Extensions\n    {\n        public static void Dispose(this object obj)\n        {\n            (obj as IDisposable)?.Dispose();\n        }\n    }\n}"}
{"input": "unit Service1U;\n\ninterface\n\nuses ServicesInterfaceU, Spring.Container.Common;\n\ntype\n  TUsersService = class(TInterfacedObject, IUsersService)\n  protected\n    [Inject]\n    fCommonService: ICommonService;\n  public\n    function GetUserNameByID(const ID: Integer): string;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TUsersService }\n\nfunction TUsersService.GetUserNameByID(const ID: Integer): string;\nbegin\n  Result := Format('User #%d (CommonServiceID = %s)', [ID, fCommonService.GetID]);\nend;\n\nend.", "output": "using System;\nusing ServicesInterfaceU;\nusing Spring.Container.Common;\n\nnamespace ServiceNamespace\n{\n    public class UsersService : IUsersService\n    {\n        [Inject]\n        private ICommonService commonService;\n\n        public string GetUserNameByID(int id)\n        {\n            return string.Format(\"User #{0} (CommonServiceID = {1})\", id, commonService.GetID);\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.HTTPApplication;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(FPC)}\nuses\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fphttpapp,\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Proc;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FListenQueue: Integer;\n    class var FHTTPApplication: THTTPApplication;\n    class function GetDefaultHTTPApplication: THTTPApplication;\n    class function HTTPApplicationIsNil: Boolean;\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetHost(const AValue: string); static;\n    class function GetListenQueue: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure DoGetModule(Sender: TObject; ARequest: TRequest; var ModuleClass: TCustomHTTPModuleClass);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallback: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallback: TProc); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallback: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallback: TProc); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(FPC)}\n\nuses\n  Horse.WebModule;\n\nclass function THorseProvider.GetDefaultHTTPApplication: THTTPApplication;\nbegin\n  if HTTPApplicationIsNil then\n    FHTTPApplication := Application;\n  Result := FHTTPApplication;\nend;\n\nclass function THorseProvider.HTTPApplicationIsNil: Boolean;\nbegin\n  Result := FHTTPApplication = nil;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LHTTPApplication: THTTPApplication;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n  if FListenQueue = 0 then\n    FListenQueue := 15;\n  LHTTPApplication := GetDefaultHTTPApplication;\n  LHTTPApplication.AllowDefaultModule := True;\n  LHTTPApplication.OnGetModule := DoGetModule;\n  LHTTPApplication.Threaded := True;\n  LHTTPApplication.QueueSize := FListenQueue;\n  LHTTPApplication.Port := FPort;\n  LHTTPApplication.LegacyRouting := True;\n  LHTTPApplication.Address := FHost;\n  LHTTPApplication.Initialize;\n  FRunning := True;\n  DoOnListen;\n  LHTTPApplication.Run;\nend;\n\nclass procedure THorseProvider.DoGetModule(Sender: TObject; ARequest: TRequest; var ModuleClass: TCustomHTTPModuleClass);\nbegin\n  ModuleClass := THorseWebModule;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallback: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallback);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallback: TProc);\nbegin\n  Listen(FPort, AHost, ACallback);\nend;\n\nclass procedure THorseProvider.Listen(const ACallback: TProc);\nbegin\n  Listen(FPort, FHost, ACallback);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallback: TProc);\nbegin\n  Listen(APort, FHost, ACallback);\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Threading;\n\nnamespace Horse.Provider.FPC.HTTPApplication\n{\n    \n    public class HTTPApplication\n    {\n        public bool AllowDefaultModule { get; set; }\n        public OnGetModuleDelegate OnGetModule { get; set; }\n        public bool Threaded { get; set; }\n        public int QueueSize { get; set; }\n        public int Port { get; set; }\n        public bool LegacyRouting { get; set; }\n        public string Address { get; set; }\n        public bool Active { get; set; }\n\n        \n        public void Initialize()\n        {\n            \n            Console.WriteLine(\"HTTPApplication initialized.\");\n        }\n\n        \n        public void Run()\n        {\n            Active = true;\n            Console.WriteLine($\"HTTPApplication running on {Address}:{Port}.\");\n            \n            while (Active)\n            {\n                Thread.Sleep(1000);\n            }\n        }\n    }\n\n    \n    public delegate void OnGetModuleDelegate(object sender, Request request, out Type moduleClass);\n\n    \n    public class Request\n    {\n        // Define request properties as needed.\n    }\n\n    \n    public class HorseWebModule\n    {\n        // Define your web module logic here.\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n    }\n\n    \n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        \n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n\n        protected static void DoOnListen() => OnListenCallback?.Invoke();\n        protected static void DoOnStopListen() => OnStopListenCallback?.Invoke();\n\n        public static void SetOnListen(Action callback) => OnListenCallback = callback;\n        public static void SetOnStopListen(Action callback) => OnStopListenCallback = callback;\n    }\n\n    \n    public static class HorseProvider \n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _listenQueue;\n        private static HTTPApplication _httpApplication;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n\n        \n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost = \"0.0.0.0\", Action callbackListen = null)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            HorseProviderAbstract.SetOnListen(callbackListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen)\n        {\n            Listen(_port, aHost, callbackListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen)\n        {\n            Listen(aPort, _host, callbackListen);\n        }\n\n        public static void Listen(Action callbackListen)\n        {\n            Listen(_port, _host, callbackListen);\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n\n        private static HTTPApplication GetDefaultHTTPApplication()\n        {\n            if (HTTPApplicationIsNil())\n            {\n                _httpApplication = new HTTPApplication();\n            }\n            return _httpApplication;\n        }\n\n        private static bool HTTPApplicationIsNil() => _httpApplication == null;\n\n        private static void DoGetModule(object sender, Request request, out Type moduleClass)\n        {\n            moduleClass = typeof(HorseWebModule);\n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n            if (_listenQueue == 0)\n                _listenQueue = HorseConstants.IdListenQueueDefault;\n\n            var app = GetDefaultHTTPApplication();\n            app.AllowDefaultModule = true;\n            app.OnGetModule = DoGetModule;\n            app.Threaded = true;\n            app.QueueSize = _listenQueue;\n            app.Port = _port;\n            app.LegacyRouting = true;\n            app.Address = _host;\n            app.Initialize();\n            _running = true;\n            HorseProviderAbstract.DoOnListen();\n            app.Run();\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPApplicationIsNil())\n            {\n                var app = GetDefaultHTTPApplication();\n                app.Active = false;\n                HorseProviderAbstract.DoOnStopListen();\n                _running = false;\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Redirect;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Logger,\n  MVCFramework.Commons;\n\ntype\n  TMVCRedirectMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fRedirectToURL: string;\n    fRequestedPathInfos: TArray<String>;\n  protected\n    procedure OnBeforeRouting(Context: TWebContext; var Handled: Boolean);\n    procedure OnBeforeControllerAction(Context: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionNAme: string; var Handled: Boolean);\n    procedure OnAfterRouting(Context: TWebContext; const AHandled: Boolean);\n    procedure OnAfterControllerAction(Context: TWebContext; const AControllerQualifiedClassName: string; const AActionName: string; const AHandled: Boolean);\n  public\n    constructor Create(\n      const RequestedPathInfos: TArray<String>;\n      const RedirectToURL: String);\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.Classes;\n\nconstructor TMVCRedirectMiddleware.Create(\n  const RequestedPathInfos: TArray<String>;\n  const RedirectToURL: String);\nbegin\n  inherited Create;\n  fRequestedPathInfos := RequestedPathInfos;\n  fRedirectToURL := RedirectToURL;\nend;\n\nprocedure TMVCRedirectMiddleware.OnAfterControllerAction(\n  Context: TWebContext; const AControllerQualifiedClassName: string;\n  const AActionName: string; const AHandled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnAfterRouting(Context: TWebContext; const AHandled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnBeforeControllerAction(Context: TWebContext;\n  const AControllerQualifiedClassName, AActionNAme: string; var Handled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnBeforeRouting(Context: TWebContext; var Handled: Boolean);\nvar\n  I: Integer;\n  lPathInfo: string;\nbegin\n  if not Handled then\n  begin\n    lPathInfo := Context.Request.PathInfo;\n    for I := 0 to Pred(Length(fRequestedPathInfos)) do\n    begin\n      if lPathInfo = fRequestedPathInfos[I] then\n      begin\n        Context.Response.RawWebResponse.SendRedirect(fRedirectToURL);\n        LogI(Format('Redirected from [%s] to [%s]', [lPathInfo, fRedirectToURL]));\n        Handled := True;\n      end;\n    end;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Logger;\n\nnamespace MVCFramework.Middleware\n{\n    \n    public class MVCRedirectMiddleware : IMVCMiddleware\n    {\n        private readonly string[] _requestedPathInfos;\n        private readonly string _redirectToURL;\n\n        public MVCRedirectMiddleware(string[] requestedPathInfos, string redirectToURL)\n        {\n            _requestedPathInfos = requestedPathInfos;\n            _redirectToURL = redirectToURL;\n        }\n\n        \n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            if (!handled)\n            {\n                string pathInfo = context.Request.PathInfo;\n                foreach (var requestedPath in _requestedPathInfos)\n                {\n                    if (string.Equals(pathInfo, requestedPath, StringComparison.OrdinalIgnoreCase))\n                    {\n                        context.Response.RawWebResponse.SendRedirect(_redirectToURL);\n                        Logger.LogInfo($\"Redirected from [{pathInfo}] to [{_redirectToURL}]\");\n                        handled = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // No additional logic needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // No additional logic needed.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No additional logic needed.\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Tests.Serializer.EntitiesModule;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Data.DB,\n  Datasnap.DBClient,\n  MVCFramework.Serializer.Commons,\n  MidasLib;\n\ntype\n\n  TEntitiesModule = class(TDataModule)\n    Entity: TClientDataSet;\n    EntityId: TLargeintField;\n    EntityCode: TIntegerField;\n    EntityName: TStringField;\n    EntitySalary: TCurrencyField;\n    EntityBirthday: TDateField;\n    EntityAccessDateTime: TDateTimeField;\n    EntityAccessTime: TTimeField;\n    EntityActive: TBooleanField;\n    EntityAmount: TFloatField;\n    EntityIgnored: TStringField;\n    EntityBlobFld: TBlobField;\n\n    [MVCDoNotSerialize]\n    EntityIgnoredAtt: TStringField;\n\n    [MVCDataSetField(dtArray)]\n    EntityItems: TDataSetField;\n    Item: TClientDataSet;\n    ItemId: TLargeintField;\n    ItemName: TStringField;\n\n    [MVCDataSetField(dtObject)]\n    EntityDepartament: TDataSetField;\n    Departament: TClientDataSet;\n    DepartamentName: TStringField;\n\n    [MVCNameCase(ncLowerCase)]\n    EntityLowerCase: TClientDataSet;\n    EntityLowerCaseId: TLargeintField;\n    EntityLowerCaseName: TStringField;\n\n    [MVCNameCase(ncUpperCase)]\n    EntityUpperCase: TClientDataSet;\n    EntityUpperCaseId: TLargeintField;\n    EntityUpperCaseName: TStringField;\n\n    EntityUpperCase2: TClientDataSet;\n    EntityUpperCase2Id: TLargeintField;\n    EntityUpperCase2Name: TStringField;\n\n    EntityAsIs: TClientDataSet;\n\n    [MVCNameAs('Id_Id')]\n    EntityAsIsId: TLargeintField;\n\n    [MVCNameAs('Name_Name')]\n    EntityAsIsName: TStringField;\n    EntityGUID: TGuidField;\n\n    procedure DataModuleCreate(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{ %CLASSGROUP 'System.Classes.TPersistent' }\n\n{$R *.dfm}\n\nprocedure TEntitiesModule.DataModuleCreate(Sender: TObject);\nbegin\n  Entity.CreateDataSet;\n  EntityLowerCase.CreateDataSet;\n  EntityUpperCase.CreateDataSet;\n  EntityUpperCase2.CreateDataSet;\n  EntityAsIs.CreateDataSet;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.Collections.Generic;\n\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property)]\npublic class MVCNameCaseAttribute : Attribute\n{\n    public string Case { get; }\n    public MVCNameCaseAttribute(string nameCase)\n    {\n        Case = nameCase;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Property)]\npublic class MVCDoNotSerializeAttribute : Attribute\n{\n}\n\n[AttributeUsage(AttributeTargets.Property)]\npublic class MVCNameAsAttribute : Attribute\n{\n    public string Name { get; }\n    public MVCNameAsAttribute(string name)\n    {\n        Name = name;\n    }\n}\n\nnamespace MVCFramework.Tests.Serializer\n{\n    \n    public class EntitiesModule\n    {\n        public DataTable Entity { get; private set; }\n\n        public DataTable Item { get; private set; }\n\n        public DataTable Departament { get; private set; }\n\n        [MVCNameCase(\"ncLowerCase\")]\n        public DataTable EntityLowerCase { get; private set; }\n\n        [MVCNameCase(\"ncUpperCase\")]\n        public DataTable EntityUpperCase { get; private set; }\n\n        public DataTable EntityUpperCase2 { get; private set; }\n\n        public DataTable EntityAsIs { get; private set; }\n\n        public EntitiesModule()\n        {\n            CreateDataSets();\n        }\n\n        private void CreateDataSets()\n        {\n            Entity = new DataTable(\"Entity\");\n            Entity.Columns.Add(\"EntityId\", typeof(long));\n            Entity.Columns.Add(\"EntityCode\", typeof(int));\n            Entity.Columns.Add(\"EntityName\", typeof(string));\n            Entity.Columns.Add(\"EntitySalary\", typeof(decimal)); // Currency\n            Entity.Columns.Add(\"EntityBirthday\", typeof(DateTime));\n            Entity.Columns.Add(\"EntityAccessDateTime\", typeof(DateTime));\n            Entity.Columns.Add(\"EntityAccessTime\", typeof(TimeSpan));\n            Entity.Columns.Add(\"EntityActive\", typeof(bool));\n            Entity.Columns.Add(\"EntityAmount\", typeof(double));\n            Entity.Columns.Add(\"EntityIgnored\", typeof(string));\n            Entity.Columns.Add(\"EntityIgnoredAtt\", typeof(string));\n            Entity.Columns.Add(\"EntityBlobFld\", typeof(byte[]));\n            Entity.Columns.Add(\"EntityGUID\", typeof(Guid));\n\n            Item = new DataTable(\"Item\");\n            Item.Columns.Add(\"ItemId\", typeof(long));\n            Item.Columns.Add(\"ItemName\", typeof(string));\n\n            Departament = new DataTable(\"Departament\");\n            Departament.Columns.Add(\"DepartamentName\", typeof(string));\n\n            EntityLowerCase = new DataTable(\"EntityLowerCase\");\n            EntityLowerCase.Columns.Add(\"entitylowercaseid\", typeof(long));\n            EntityLowerCase.Columns.Add(\"entitylowercasename\", typeof(string));\n\n            EntityUpperCase = new DataTable(\"EntityUpperCase\");\n            EntityUpperCase.Columns.Add(\"ENTITYUPPERCASEID\", typeof(long));\n            EntityUpperCase.Columns.Add(\"ENTITYUPPERCASENAME\", typeof(string));\n\n            EntityUpperCase2 = new DataTable(\"EntityUpperCase2\");\n            EntityUpperCase2.Columns.Add(\"EntityUpperCase2Id\", typeof(long));\n            EntityUpperCase2.Columns.Add(\"EntityUpperCase2Name\", typeof(string));\n\n            EntityAsIs = new DataTable(\"EntityAsIs\");\n            EntityAsIs.Columns.Add(\"Id_Id\", typeof(long));\n            EntityAsIs.Columns.Add(\"Name_Name\", typeof(string));\n\n            \n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Session;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils,\n  System.Generics.Collections,\n  MVCFramework.Commons,\n  MVCFramework.Nullables;\n\nconst\n  DEFAULT_SESSION_INACTIVITY = 60; // in minutes\n\ntype\n  EMVCSession = class(EMVCException)\n\n  end;\n\n  TMVCWebSessionFactory = class;\n\n  TMVCWebSession = class abstract\n  strict private\n    fChanged: Boolean;\n    fExpirationTimeStamp: NullableTDateTime;\n    fSessionFactory: TMVCWebSessionFactory;\n  protected\n    fSessionId: string;\n    fTimeout: UInt64;\n    function GetSessionFactory: TMVCWebSessionFactory;\n    function GetItems(const AKey: string): string; virtual; abstract;\n    procedure SetItems(const AKey, AValue: string); virtual;\n    procedure InternalApplyChanges; virtual;\n    function GetExpirationTimeStamp: NullableTDateTime; virtual;\n    procedure SetExpirationTimeStamp(const Value: NullableTDateTime); virtual;\n    procedure SetTimeout(const Value: UInt64); virtual;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory); virtual;\n    destructor Destroy; override;\n    procedure MarkAsUsed; virtual;\n    procedure ApplyChanges;\n    function ToString: string; override;\n    function IsExpired: Boolean; virtual;\n    function Keys: TArray<String>; virtual;\n    procedure StopSession; virtual;\n    procedure RefreshSessionExpiration; virtual;\n    property ExpirationTimeStamp: NullableTDateTime read GetExpirationTimeStamp write SetExpirationTimeStamp;\n    function Clone: TMVCWebSession; virtual; abstract;\n    property Items[const AKey: string]: string read GetItems write SetItems; default;\n    property SessionId: string read FSessionId;\n    property Timeout: UInt64 read FTimeout write SetTimeout;\n  end;\n\n  TMVCWebSessionFactory = class abstract\n  private\n    fTimeoutInMinutes: Integer;\n  public\n    function GetTimeout: Integer;\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; virtual; abstract;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; virtual; abstract;\n    function TryFindSessionID(const ASessionID: String): Boolean; virtual; abstract;\n    procedure TryDeleteSessionID(const ASessionID: String); virtual; abstract;\n    constructor Create(aTimeoutInMinutes: Integer = 0); virtual;\n  end;\n\n  TMVCWebSessionClass = class of TMVCWebSession;\n\n  TMVCWebSessionMemory = class(TMVCWebSession)\n  private\n    FData: TDictionary<string, string>;\n  protected\n    function GetItems(const AKey: string): string; override;\n    procedure SetItems(const AKey, AValue: string); override;\n    procedure InternalApplyChanges; override;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory); override;\n    destructor Destroy; override;\n    function Keys: TArray<String>; override;\n    function Clone: TMVCWebSession; override;\n    function ToString: string; override;\n    property Data: TDictionary<string, string> read FData;\n//    class function CreateNewSession(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function TryFindSessionID(const ASessionID: String): Boolean; override;\n//    class procedure TryDeleteSessionID(const aSessionID: String); override;\n  end;\n\n  TMVCWebSessionMemoryFactory = class(TMVCWebSessionFactory)\n  protected\n    class function GlobalSessionList: TObjectDictionary<string, TMVCWebSessionMemory>;\n  public\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; override;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; override;\n    function TryFindSessionID(const ASessionID: String): Boolean; override;\n    procedure TryDeleteSessionID(const ASessionID: String); override;\n  end;\n\n  TMVCWebSessionFile = class(TMVCWebSession)\n  private\n    fSessionFolder: String;\n    fData: TDictionary<string, string>;\n  protected\n    class var gLock: TObject;\n    function GetItems(const AKey: string): string; override;\n    procedure SetItems(const AKey, AValue: string); override;\n    procedure LoadFromFile;\n    procedure SaveToFile;\n    procedure InternalApplyChanges; override;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory; const SessionFolder: String); reintroduce;\n    destructor Destroy; override;\n    function Keys: TArray<String>; override;\n    function Clone: TMVCWebSession; override;\n    function ToString: string; override;\n    property Data: TDictionary<string, string> read FData;\n//    class function CreateNewSession(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function TryFindSessionID(const ASessionID: String): Boolean; override;\n//    class procedure TryDeleteSessionID(const aSessionID: String); override;\n    //\n    class constructor Create;\n    class destructor Destroy;\n  end;\n\n  TMVCWebSessionFileFactory = class(TMVCWebSessionFactory)\n  protected\n    fSessionFolder: String;\n    function GetSessionFolder(aAbsoluteOrRelativePath: String): String;\n    function GetSessionFileName(aSessionID: String): String;\n  public\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; override;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; override;\n    function TryFindSessionID(const ASessionID: String): Boolean; override;\n    procedure TryDeleteSessionID(const ASessionID: String); override;\n    constructor Create(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'); reintroduce; virtual;\n  end;\n\n\n//  TMVCSessionFactory = class sealed\n//  private\n//    FSessionTypeClass: TMVCWebSessionClass;\n//    FRegisteredSessionTypes: TDictionary<string, TMVCWebSessionClass>;\n//  protected\n//    class var cInstance: TMVCSessionFactory;\n//    constructor Create;\n//  public\n//    destructor Destroy; override;\n//    procedure RegisterSessionType(const AName: string; AWebSessionClass: TMVCWebSessionClass);\n//    function CreateNewSession(const ATimeout: UInt64): TMVCWebSession;\n//    function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession;\n//    function TryFindSessionID(const ASessionID: String): Boolean;\n//    procedure TryDeleteSessionID(const ASessionID: String);\n//    class function GetInstance: TMVCSessionFactory; static;\n//    procedure SetSessionType(const SessionType: String);\n//  end;\n\n\nimplementation\n\nuses\n  System.IOUtils,\n  MVCFramework.Logger,\n  MVCFramework.Serializer.Commons, System.DateUtils;\n\nvar\n  GlSessionList: TObjectDictionary<string, TMVCWebSessionMemory> = nil;\n  GlLastSessionListClear: TDateTime;\n  GlCriticalSection: TCriticalSection;\n  GSessionTypeLock: Int64 = 0;\n\nclass function TMVCWebSessionMemoryFactory.GlobalSessionList: TObjectDictionary<string, TMVCWebSessionMemory>;\nvar\n  S: string;\nbegin\n  if not Assigned(GlSessionList) then\n  begin\n    GlCriticalSection.Enter;\n    try\n      if not Assigned(GlSessionList) then\n      begin\n        GlSessionList := TObjectDictionary<string, TMVCWebSessionMemory>.Create([doOwnsValues], 1024);\n      end;\n    finally\n      GlCriticalSection.Leave;\n    end;\n  end;\n\n  if MinutesBetween(Now, GlLastSessionListClear) >= 1 then\n  begin\n    TMonitor.Enter(GlSessionList);\n    try\n      for S in GlSessionList.Keys do\n        if TMVCWebSession(GlSessionList.Items[S]).IsExpired then\n          GlSessionList.Remove(S);\n      GlLastSessionListClear := Now;\n    finally\n      TMonitor.Exit(GlSessionList);\n    end;\n  end;\n\n  Result := GlSessionList;\nend;\n\nprocedure TMVCWebSessionMemory.InternalApplyChanges;\nbegin\n  TMonitor.Enter(TMVCWebSessionMemoryFactory.GlobalSessionList);\n  try\n    TMVCWebSessionMemoryFactory.GlobalSessionList.AddOrSetValue(fSessionId, TMVCWebSessionMemory(Self.Clone));\n  finally\n    TMonitor.Exit(TMVCWebSessionMemoryFactory.GlobalSessionList);\n  end;\nend;\n\nfunction TMVCWebSessionMemory.Keys: TArray<String>;\nbegin\n  Result := Data.Keys.ToArray;\nend;\n\nprocedure TMVCWebSession.ApplyChanges;\nbegin\n  if Self <> nil then\n  begin\n    if FChanged then\n    begin\n      InternalApplyChanges;\n      FChanged := False;\n    end;\n  end;\nend;\n\nconstructor TMVCWebSession.Create(const aOwnerFactory: TMVCWebSessionFactory);\nbegin\n  inherited Create;\n  fSessionFactory := aOwnerFactory;\n  fChanged := False;\nend;\n\n{ TWebSession }\n\ndestructor TMVCWebSession.Destroy;\nbegin\n  inherited Destroy;\nend;\n\nfunction TMVCWebSession.GetExpirationTimeStamp: NullableTDateTime;\nbegin\n  Result := fExpirationTimeStamp;\nend;\n\nfunction TMVCWebSession.GetSessionFactory: TMVCWebSessionFactory;\nbegin\n  Result := fSessionFactory;\nend;\n\nprocedure TMVCWebSession.InternalApplyChanges;\nbegin\n  // do nothing\nend;\n\nfunction TMVCWebSession.IsExpired: Boolean;\nbegin\n  if ExpirationTimeStamp.HasValue then\n    Result := ExpirationTimeStamp.Value < RecodeMilliSecond(RecodeSecond(Now(), 0), 0)\n  else\n    Result := False;\nend;\n\nfunction TMVCWebSession.Keys: TArray<String>;\nbegin\n  Result := ['<not implemented>'];\nend;\n\nprocedure TMVCWebSession.MarkAsUsed;\nbegin\n  fChanged := True;\n  ExpirationTimeStamp := Now + OneMinute * Timeout;\nend;\n\nprocedure TMVCWebSession.SetTimeout(const Value: UInt64);\nbegin\n  fTimeout := Value;\n  RefreshSessionExpiration;\nend;\n\nprocedure TMVCWebSession.SetExpirationTimeStamp(const Value: NullableTDateTime);\nbegin\n  fExpirationTimeStamp := Value;\nend;\n\nprocedure TMVCWebSession.SetItems(const AKey, AValue: string);\nbegin\n  FChanged := True;\nend;\n\nprocedure TMVCWebSession.StopSession;\nbegin\n  //do nothing\nend;\n\nprocedure TMVCWebSession.RefreshSessionExpiration;\nbegin\n  if fTimeout > 0 then\n    fExpirationTimeStamp := RecodeMilliSecond(RecodeSecond(Now() + OneMinute * fTimeout, 0), 0)\n  else\n    fExpirationTimeStamp.Clear;\nend;\n\nfunction TMVCWebSession.ToString: string;\nbegin\n  Result := String.Join(',', Keys);\nend;\n\nfunction TMVCWebSessionMemory.Clone: TMVCWebSession;\nvar\n  lMemSess: TMVCWebSessionMemory;\n  lItem: TPair<String, String>;\nbegin\n  lMemSess := TMVCWebSessionMemory.Create(GetSessionFactory);\n  try\n    lMemSess.fSessionId := SessionId;\n    lMemSess.Timeout := Timeout;\n    for lItem in Self.Data do\n    begin\n      lMemSess.Data.Add(lItem.Key, lItem.Value);\n    end;\n  except\n    lMemSess.Free;\n    raise;\n  end;\n  Result := lMemSess;\nend;\n\nconstructor TMVCWebSessionMemory.Create(const aOwnerFactory: TMVCWebSessionFactory);\nbegin\n  inherited;\n  fData := TDictionary<String, String>.Create;\nend;\n\nfunction TMVCWebSessionMemoryFactory.CreateFromSessionID(const ASessionId: string): TMVCWebSession;\nvar\n  lSess: TMVCWebSessionMemory;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    Result := nil;\n    if GlobalSessionList.TryGetValue(ASessionId, lSess) then\n    begin\n      lSess.Timeout := GetTimeout;\n      Result := lSess.Clone;\n    end;\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TWebSessionMemory }\n\ndestructor TMVCWebSessionMemory.Destroy;\nbegin\n  FData.Free;\n  inherited Destroy;\nend;\n\nfunction TMVCWebSessionMemory.GetItems(const AKey: string): string;\nbegin\n  TMonitor.Enter(Self);\n  try\n    if not FData.TryGetValue(AKey, Result) then\n      Result := '';\n  finally\n    TMonitor.Exit(Self);\n  end;\nend;\n\nprocedure TMVCWebSessionMemory.SetItems(const AKey, AValue: string);\nbegin\n  inherited;\n  TMonitor.Enter(Self);\n  try\n    FData.AddOrSetValue(AKey, AValue);\n  finally\n    TMonitor.Exit(Self);\n  end;\nend;\n\nfunction TMVCWebSessionMemory.ToString: string;\nvar\n  LKey: string;\nbegin\n  Result := '';\n  for LKey in FData.Keys do\n    Result := Result + LKey + '=' + QuotedStr(FData.Items[LKey]) + sLineBreak;\nend;\n\nprocedure TMVCWebSessionMemoryFactory.TryDeleteSessionID(const ASessionID: String);\nbegin\n  inherited;\n  TMonitor.Enter(GlobalSessionList);\n  try\n    GlobalSessionList.Remove(aSessionID);\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\nfunction TMVCWebSessionMemoryFactory.TryFindSessionID(const ASessionID: String): Boolean;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    Result := GlobalSessionList.ContainsKey(ASessionId);\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TMVCSessionFactory }\n\n//constructor TMVCSessionFactory.Create;\n//begin\n//  inherited Create;\n//  FRegisteredSessionTypes := TDictionary<string, TMVCWebSessionClass>.Create;\n//end;\n//\n//function TMVCSessionFactory.CreateNewSession(const ATimeout: UInt64): TMVCWebSession;\n//begin\n//  Result := FSessionTypeClass.CreateNewSession(GenerateSessionID, ATimeout);\n//end;\n//\n//function TMVCSessionFactory.CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession;\n//begin\n//  Result := FSessionTypeClass.CreateFromSessionID(ASessionId, ATimeout);\n//  if (Result = nil) or Result.IsExpired then\n//  begin\n//    raise EMVCSessionExpiredException.Create;\n//  end;\n//end;\n//\n//destructor TMVCSessionFactory.Destroy;\n//begin\n//  FRegisteredSessionTypes.Free;\n//  inherited Destroy;\n//end;\n//\n//class function TMVCSessionFactory.GetInstance: TMVCSessionFactory;\n//begin\n//  if not Assigned(cInstance) then\n//  begin\n//    cInstance := TMVCSessionFactory.Create;\n//  end;\n//  Result := cInstance;\n//end;\n//\n//procedure TMVCSessionFactory.RegisterSessionType(const AName: string; AWebSessionClass: TMVCWebSessionClass);\n//begin\n//  if TInterlocked.Read(GSessionTypeLock) = 1 then\n//  begin\n//    raise EMVCSession.Create('Session factory already initialized');\n//  end;\n//  FRegisteredSessionTypes.AddOrSetValue(AName, AWebSessionClass);\n//end;\n//\n//procedure TMVCSessionFactory.SetSessionType(const SessionType: String);\n//var\n//  Clazz: TMVCWebSessionClass;\n//begin\n//  if TInterlocked.CompareExchange(GSessionTypeLock, 1, 0) = 0 then\n//  begin\n//    if not FRegisteredSessionTypes.TryGetValue(SessionType, Clazz) then\n//      raise EMVCSession.Create('Unknown session type: ' + SessionType);\n//    FSessionTypeClass := Clazz;\n//  end;\n//end;\n//\n//procedure TMVCSessionFactory.TryDeleteSessionID(const ASessionID: String);\n//begin\n//  FSessionTypeClass.TryDeleteSessionID(ASessionID);\n//end;\n//\n//function TMVCSessionFactory.TryFindSessionID(const ASessionID: String): Boolean;\n//begin\n//  Result := FSessionTypeClass.TryFindSessionID(ASessionID);\n//end;\n\nfunction TMVCWebSessionFile.Clone: TMVCWebSession;\nvar\n  lMemSess: TMVCWebSessionFile;\n  lItem: TPair<String, String>;\nbegin\n  lMemSess := TMVCWebSessionFile.Create(GetSessionFactory, Self.fSessionFolder);\n  try\n    lMemSess.fSessionFolder := Self.fSessionFolder;\n    lMemSess.fSessionId := Self.fSessionId;\n    lMemSess.fTimeout := Self.fTimeout;\n    for lItem in Self.Data do\n    begin\n      lMemSess.Data.Add(lItem.Key, lItem.Value);\n    end;\n  except\n    lMemSess.Free;\n    raise;\n  end;\n  Result := lMemSess;\nend;\n\n{ TMVCWebSessionFile }\n\ndestructor TMVCWebSessionFile.Destroy;\nbegin\n  inherited;\n  fData.Free;\nend;\n\nconstructor TMVCWebSessionFile.Create(const aOwnerFactory: TMVCWebSessionFactory; const SessionFolder: String);\nbegin\n  inherited Create(aOwnerFactory);\n  fData := TDictionary<String, String>.Create;\n  fSessionFolder := SessionFolder;\nend;\n\nclass destructor TMVCWebSessionFile.Destroy;\nbegin\n  gLock.Free;\nend;\n\nfunction TMVCWebSessionFile.GetItems(const AKey: string): string;\nbegin\n  if not fData.TryGetValue(AKey, Result) then\n    Result := '';\nend;\n\nfunction TMVCWebSessionFileFactory.GetSessionFileName(aSessionID: String): String;\nbegin\n  Result := TPath.Combine(fSessionFolder, aSessionId);\nend;\n\nfunction TMVCWebSessionFileFactory.GetSessionFolder(aAbsoluteOrRelativePath: String): String;\nbegin\n  if TPath.IsRelativePath(aAbsoluteOrRelativePath) then\n    Result := TPath.Combine(AppPath, aAbsoluteOrRelativePath)\n  else\n    Result := aAbsoluteOrRelativePath;\n  TDirectory.CreateDirectory(Result);\nend;\n\nprocedure TMVCWebSessionFile.InternalApplyChanges;\nbegin\n  TMonitor.Enter(gLock);\n  try\n    SaveToFile;\n  finally\n    TMonitor.Exit(gLock);\n  end;\nend;\n\nfunction TMVCWebSessionFile.Keys: TArray<String>;\nbegin\n  Result := fData.Keys.ToArray;\nend;\n\nprocedure TMVCWebSessionFile.LoadFromFile;\nvar\n  lFileName: String;\n  lFile: TStreamReader;\n  lLine: string;\n  lPieces: TArray<System.string>;\nbegin\n  lFileName := TMVCWebSessionFileFactory(GetSessionFactory).GetSessionFileName(fSessionId);\n  if not TFile.Exists(lFileName) then\n  begin\n    Exit;\n  end;\n  lFile := TFile.OpenText(lFileName);\n  try\n    ExpirationTimeStamp := ISOTimeStampToDateTime(lFile.ReadLine);\n    fTimeout := lFile.ReadLine.ToInteger;\n    while not lFile.EndOfStream do\n    begin\n      lLine := lFile.ReadLine;\n      lPieces := lLine.Split(['=']);\n      SetItems(lPieces[0], lPieces[1]);\n    end;\n  finally\n    lFile.Free;\n  end;\nend;\n\nprocedure TMVCWebSessionFile.SaveToFile;\nvar\n  lFileName: String;\n  lPair: TPair<String, String>;\n  lFile: TStreamWriter;\nbegin\n  MarkAsUsed;\n  lFileName := TMVCWebSessionFileFactory(GetSessionFactory).GetSessionFileName(fSessionId);\n  lFile := TFile.CreateText(lFileName);\n  try\n    lFile.WriteLine(DateTimeToISOTimeStamp(ExpirationTimeStamp));\n    lFile.WriteLine(fTimeout);\n    for lPair in Data do\n    begin\n      lFile.WriteLine(String.Join('=', [lPair.Key, lPair.Value]));\n    end;\n    lFile.Close;\n  finally\n    lFile.Free;\n  end;\nend;\n\nprocedure TMVCWebSessionFile.SetItems(const AKey, AValue: string);\nbegin\n  inherited;\n  fData.AddOrSetValue(AKey, AValue);\nend;\n\nfunction TMVCWebSessionFile.ToString: string;\nbegin\n  Result := String.Join(',', Keys);\nend;\n\nprocedure TMVCWebSessionFileFactory.TryDeleteSessionID(const ASessionID: String);\nvar\n  lSessionFileName: string;\nbegin\n  inherited;\n  lSessionFileName := GetSessionFileName(ASessionID);\n  if TFile.Exists(lSessionFileName) then\n  begin\n    try\n      TFile.Delete(lSessionFileName);\n    except\n      on E: Exception do\n      begin\n        LogE('Cannot delete session file ' + lSessionFileName);\n      end;\n    end;\n  end;\nend;\n\nfunction TMVCWebSessionFileFactory.TryFindSessionID(\n  const ASessionID: String): Boolean;\nbegin\n  inherited;\n  Result := TFile.Exists(GetSessionFileName(ASessionID));\nend;\n\nclass constructor TMVCWebSessionFile.Create;\nbegin\n  gLock := TObject.Create;\nend;\n\nconstructor TMVCWebSessionFileFactory.Create(aTimeoutInMinutes: Integer; aSessionFolder: String);\nbegin\n  inherited Create(aTimeoutInMinutes);\n  fSessionFolder := GetSessionFolder(aSessionFolder);\nend;\n\nfunction TMVCWebSessionFileFactory.CreateFromSessionID(const aSessionId: string): TMVCWebSession;\nbegin\n  Result := TMVCWebSessionFile.Create(Self,  GetSessionFolder(fSessionFolder));\n  try\n    TMVCWebSessionFile(Result).fSessionId := aSessionId;\n    TMVCWebSessionFile(Result).LoadFromFile;\n    TMVCWebSessionFile(Result).fTimeout := GetTimeout;\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nfunction TMVCWebSessionFileFactory.CreateNewSession(const aSessionId: string): TMVCWebSession;\nbegin\n  Result := TMVCWebSessionFile.Create(Self, GetSessionFolder(fSessionFolder));\n  Result.fSessionId := aSessionId;\n  Result.fTimeout := GetTimeout;\n  TMVCWebSessionFile(Result).SaveToFile;\nend;\n\n{ TMVCWebSessionMemoryFactory }\n\nfunction TMVCWebSessionMemoryFactory.CreateNewSession(const ASessionId: string): TMVCWebSession;\nvar\n  lSess: TMVCWebSessionMemory;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    lSess := TMVCWebSessionMemory.Create(Self);\n    try\n      lSess.fSessionId := ASessionId;\n      lSess.fTimeout := GetTimeout;\n      lSess.MarkAsUsed;\n      GlobalSessionList.Add(ASessionId, lSess);\n      Result := lSess.Clone;\n    except\n      lSess.Free;\n      raise;\n    end;\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TMVCWebSessionFactory }\n\nconstructor TMVCWebSessionFactory.Create(aTimeoutInMinutes: Integer);\nbegin\n  inherited Create;\n  fTimeoutInMinutes := aTimeoutInMinutes;\nend;\n\nfunction TMVCWebSessionFactory.GetTimeout: Integer;\nbegin\n  Result := fTimeoutInMinutes;\nend;\n\ninitialization\n\nGlCriticalSection := TCriticalSection.Create;\n\nfinalization\n\nFreeAndNil(GlCriticalSection);\n\nif Assigned(GlSessionList) then\n  FreeAndNil(GlSessionList);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace MVCFramework.Session\n{\n    public class MVCSessionException : Exception\n    {\n        public MVCSessionException() { }\n        public MVCSessionException(string message) : base(message) { }\n        public MVCSessionException(string message, Exception innerException) : base(message, innerException) { }\n    }\n\n    \n    public abstract class MVCWebSession\n    {\n        protected bool _changed;\n        protected DateTime? _expirationTimeStamp;\n        protected MVCWebSessionFactory _sessionFactory;\n\n        protected MVCWebSession(MVCWebSessionFactory ownerFactory)\n        {\n            _sessionFactory = ownerFactory;\n            _changed = false;\n        }\n\n        \n        public abstract string GetItem(string key);\n        public virtual void SetItem(string key, string value)\n        {\n            _changed = true;\n        }\n\n       \n        protected virtual void InternalApplyChanges() { }\n\n       \n        public virtual DateTime? ExpirationTimeStamp\n        {\n            get { return _expirationTimeStamp; }\n            set { _expirationTimeStamp = value; }\n        }\n\n        \n        public string SessionId { get; protected set; }\n\n        \n        public int Timeout { get; set; }\n\n        public MVCWebSessionFactory SessionFactory => _sessionFactory;\n\n        \n        public void MarkAsUsed()\n        {\n            _changed = true;\n            RefreshSessionExpiration();\n        }\n\n        \n        public void ApplyChanges()\n        {\n            if (_changed)\n            {\n                InternalApplyChanges();\n                _changed = false;\n            }\n        }\n\n        public override string ToString()\n        {\n            return string.Join(\",\", Keys());\n        }\n\n        \n        public abstract string[] Keys();\n\n        \n        public virtual void StopSession() { }\n\n        \n        public virtual void RefreshSessionExpiration()\n        {\n            if (Timeout > 0)\n                _expirationTimeStamp = DateTime.Now.AddMinutes(Timeout);\n            else\n                _expirationTimeStamp = null;\n        }\n\n        \n        public abstract MVCWebSession Clone();\n\n        \n        public virtual string this[string key]\n        {\n            get { return GetItem(key); }\n            set { SetItem(key, value); }\n        }\n\n        \n        public bool IsExpired()\n        {\n            if (_expirationTimeStamp.HasValue)\n            {\n                return _expirationTimeStamp.Value < DateTime.Now;\n            }\n            return false;\n        }\n    }\n\n    \n    public abstract class MVCWebSessionFactory\n    {\n        protected int _timeoutInMinutes;\n\n        public const int DEFAULT_SESSION_INACTIVITY = 60;\n\n        public MVCWebSessionFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY)\n        {\n            _timeoutInMinutes = timeoutInMinutes;\n        }\n\n        public int TimeoutInMinutes => _timeoutInMinutes;\n\n        public abstract MVCWebSession CreateNewSession(string sessionId);\n        public abstract MVCWebSession CreateFromSessionID(string sessionId);\n        public abstract bool TryFindSessionID(string sessionId);\n        public abstract void TryDeleteSessionID(string sessionId);\n    }\n\n    #region In\u2010Memory Sessions\n\n   \n    public class MVCWebSessionMemory : MVCWebSession\n    {\n        private Dictionary<string, string> _data;\n\n        public MVCWebSessionMemory(MVCWebSessionFactory ownerFactory) : base(ownerFactory)\n        {\n            _data = new Dictionary<string, string>();\n        }\n\n        public override string GetItem(string key)\n        {\n            return _data.TryGetValue(key, out string value) ? value : string.Empty;\n        }\n\n        public override void SetItem(string key, string value)\n        {\n            base.SetItem(key, value);\n            _data[key] = value;\n        }\n\n        public override string[] Keys()\n        {\n            return _data.Keys.ToArray();\n        }\n\n        public override MVCWebSession Clone()\n        {\n            var clone = new MVCWebSessionMemory(_sessionFactory);\n            clone.SessionId = this.SessionId;\n            clone.Timeout = this.Timeout;\n            foreach (var kvp in _data)\n            {\n                clone._data[kvp.Key] = kvp.Value;\n            }\n            return clone;\n        }\n\n        public override string ToString()\n        {\n            return string.Join(Environment.NewLine, _data.Select(kvp => $\"{kvp.Key}='{kvp.Value}'\"));\n        }\n\n        protected override void InternalApplyChanges()\n        {\n            \n            lock (MVCWebSessionMemoryFactory.GlobalSessionListLock)\n            {\n                MVCWebSessionMemoryFactory.GlobalSessionList[SessionId] = (MVCWebSessionMemory)this.Clone();\n            }\n        }\n    }\n\n    \n    public class MVCWebSessionMemoryFactory : MVCWebSessionFactory\n    {\n        \n        internal static Dictionary<string, MVCWebSessionMemory> GlobalSessionList = new Dictionary<string, MVCWebSessionMemory>();\n        internal static readonly object GlobalSessionListLock = new object();\n        private static DateTime _lastSessionListClear = DateTime.Now;\n\n        public MVCWebSessionMemoryFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY)\n            : base(timeoutInMinutes)\n        {\n        }\n\n        private void ClearExpiredSessions()\n        {\n            lock (GlobalSessionListLock)\n            {\n                if ((DateTime.Now - _lastSessionListClear).TotalMinutes >= 1)\n                {\n                    var expiredKeys = GlobalSessionList\n                        .Where(pair => pair.Value.IsExpired())\n                        .Select(pair => pair.Key)\n                        .ToList();\n                    foreach (var key in expiredKeys)\n                    {\n                        GlobalSessionList.Remove(key);\n                    }\n                    _lastSessionListClear = DateTime.Now;\n                }\n            }\n        }\n\n        public override MVCWebSession CreateNewSession(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                var newSession = new MVCWebSessionMemory(this)\n                {\n                    SessionId = sessionId,\n                    Timeout = _timeoutInMinutes\n                };\n                newSession.MarkAsUsed();\n                GlobalSessionList[sessionId] = newSession;\n                return newSession.Clone();\n            }\n        }\n\n        public override MVCWebSession CreateFromSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                if (GlobalSessionList.TryGetValue(sessionId, out MVCWebSessionMemory session))\n                {\n                    session.Timeout = _timeoutInMinutes;\n                    return session.Clone();\n                }\n                return null;\n            }\n        }\n\n        public override bool TryFindSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                return GlobalSessionList.ContainsKey(sessionId);\n            }\n        }\n\n        public override void TryDeleteSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                GlobalSessionList.Remove(sessionId);\n            }\n        }\n    }\n\n    #endregion\n\n    #region File-based Sessions\n\n    \n    public class MVCWebSessionFile : MVCWebSession\n    {\n        private Dictionary<string, string> _data;\n        private string _sessionFolder;\n\n        public MVCWebSessionFile(MVCWebSessionFactory ownerFactory, string sessionFolder)\n            : base(ownerFactory)\n        {\n            _data = new Dictionary<string, string>();\n            _sessionFolder = sessionFolder;\n        }\n\n        public override string GetItem(string key)\n        {\n            return _data.TryGetValue(key, out string value) ? value : string.Empty;\n        }\n\n        public override void SetItem(string key, string value)\n        {\n            base.SetItem(key, value);\n            _data[key] = value;\n        }\n\n        public override string[] Keys()\n        {\n            return _data.Keys.ToArray();\n        }\n\n        public override MVCWebSession Clone()\n        {\n            var clone = new MVCWebSessionFile(_sessionFactory, _sessionFolder);\n            clone.SessionId = this.SessionId;\n            clone.Timeout = this.Timeout;\n            foreach (var kvp in _data)\n            {\n                clone._data[kvp.Key] = kvp.Value;\n            }\n            return clone;\n        }\n\n        public override string ToString()\n        {\n            return string.Join(Environment.NewLine, _data.Select(kvp => $\"{kvp.Key}='{kvp.Value}'\"));\n        }\n\n        protected override void InternalApplyChanges()\n        {\n           \n            lock (MVCWebSessionFileFactory.GlobalFileLock)\n            {\n                SaveToFile();\n            }\n        }\n\n        \n        protected void LoadFromFile()\n        {\n            string fileName = MVCWebSessionFileFactory.GetSessionFileNameStatic(_sessionFactory, SessionId, _sessionFolder);\n            if (!File.Exists(fileName))\n                return;\n\n            using (var reader = new StreamReader(fileName))\n            {\n                \n                string expLine = reader.ReadLine();\n                _expirationTimeStamp = ISOTimeStampToDateTime(expLine);\n                string timeoutLine = reader.ReadLine();\n                Timeout = int.Parse(timeoutLine);\n                while (!reader.EndOfStream)\n                {\n                    string line = reader.ReadLine();\n                    var parts = line.Split('=');\n                    if (parts.Length >= 2)\n                        SetItem(parts[0], parts[1]);\n                }\n            }\n        }\n\n        \n        protected void SaveToFile()\n        {\n            MarkAsUsed();\n            string fileName = MVCWebSessionFileFactory.GetSessionFileNameStatic(_sessionFactory, SessionId, _sessionFolder);\n            Directory.CreateDirectory(Path.GetDirectoryName(fileName));\n            using (var writer = new StreamWriter(fileName, false))\n            {\n                writer.WriteLine(DateTimeToISOTimeStamp(ExpirationTimeStamp));\n                writer.WriteLine(Timeout);\n                foreach (var kvp in _data)\n                {\n                    writer.WriteLine($\"{kvp.Key}={kvp.Value}\");\n                }\n            }\n        }\n    }\n\n    \n    public class MVCWebSessionFileFactory : MVCWebSessionFactory\n    {\n        private string _sessionFolder;\n\n        public MVCWebSessionFileFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY, string sessionFolder = \"dmvc_sessions\")\n            : base(timeoutInMinutes)\n        {\n            _sessionFolder = GetSessionFolder(sessionFolder);\n        }\n\n        private string GetSessionFolder(string path)\n        {\n            if (!Path.IsPathRooted(path))\n                return Path.Combine(AppPath.Value, path);\n            else\n                return path;\n        }\n\n        \n        public static string GetSessionFileNameStatic(MVCWebSessionFactory factory, string sessionId, string folder)\n        {\n            string fullFolder = folder;\n            if (!Path.IsPathRooted(folder))\n                fullFolder = Path.Combine(AppPath.Value, folder);\n            return Path.Combine(fullFolder, sessionId);\n        }\n\n        public override MVCWebSession CreateNewSession(string sessionId)\n        {\n            var session = new MVCWebSessionFile(this, _sessionFolder)\n            {\n                SessionId = sessionId,\n                Timeout = _timeoutInMinutes\n            };\n            session.MarkAsUsed();\n            session.RefreshSessionExpiration();\n            (session as MVCWebSessionFile).SaveToFile();\n            return session;\n        }\n\n        public override MVCWebSession CreateFromSessionID(string sessionId)\n        {\n            var session = new MVCWebSessionFile(this, _sessionFolder)\n            {\n                SessionId = sessionId,\n                Timeout = _timeoutInMinutes\n            };\n            (session as MVCWebSessionFile).LoadFromFile();\n            return session;\n        }\n\n        public override bool TryFindSessionID(string sessionId)\n        {\n            string fileName = GetSessionFileNameStatic(this, sessionId, _sessionFolder);\n            return File.Exists(fileName);\n        }\n\n        public override void TryDeleteSessionID(string sessionId)\n        {\n            string fileName = GetSessionFileNameStatic(this, sessionId, _sessionFolder);\n            if (File.Exists(fileName))\n            {\n                try\n                {\n                    File.Delete(fileName);\n                }\n                catch (Exception ex)\n                {\n                    Console.Error.WriteLine($\"Cannot delete session file {fileName}: {ex.Message}\");\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region Application Path Helper\n\n    public static class AppPath\n    {\n        public static string Value => AppDomain.CurrentDomain.BaseDirectory;\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes;\n\n{$IFDEF LINUX}\n{$ERROR 'This unit is not compatible with linux!'}\n{$ENDIF}\n\ninterface\n\nuses\n  System.Rtti,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons;\n\ntype\n  TMVCBitmapSerializerJsonDataObject = class(TInterfacedObject, IMVCTypeSerializer)\n  protected\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>; const ASerializationAction: TMVCSerializationAction = nil);\n\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: TArray<TCustomAttribute>);\n\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n\n  end;\n\nprocedure RegisterOptionalCustomTypesSerializers(const JDOSerializer: IMVCSerializer); overload;\nprocedure RegisterOptionalCustomTypesSerializersForJSON(const Serializers\n  : TDictionary<string, IMVCSerializer>); overload;\n\nimplementation\n\nuses\n{$IFDEF MSWINDOWS}\n  Vcl.Graphics, {do not specialize VCL or FMX, let use the UnitScope defined in the project}\n  Vcl.Imaging.pngimage, {do not specialize VCL or FMX, le use the UnitScope defined in the project}\n  Vcl.Imaging.jpeg, {do not specialize VCL or FMX, le use the UnitScope defined in the project}\n{$ENDIF}\n  System.Classes,\n  System.SysUtils,\n  JsonDataObjects,\n  MVCFramework.Commons;\n\nprocedure RegisterOptionalCustomTypesSerializers(const JDOSerializer: IMVCSerializer);\nbegin\n{$IFDEF MSWINDOWS}\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TBitmap), TMVCBitmapSerializerJsonDataObject.Create);\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TPngImage), TMVCBitmapSerializerJsonDataObject.Create);\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TJPEGImage), TMVCBitmapSerializerJsonDataObject.Create);\n{$ENDIF}\nend;\n\nprocedure RegisterOptionalCustomTypesSerializersForJSON(const Serializers: TDictionary<string, IMVCSerializer>);\nbegin\n  RegisterOptionalCustomTypesSerializers(Serializers.Items[TMVCMediaType.APPLICATION_JSON]);\nend;\n\n{ TMVCBitmapSerializerJsonDataObject }\n\nprocedure TMVCBitmapSerializerJsonDataObject.DeserializeAttribute(\n  var AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nvar\n  lGraphic: TGraphic;\n  SS: TStringStream;\n  lJSON: TJDOJsonObject;\n  lTmpStream: TMemoryStream;\nbegin\n  lJSON := ASerializerObject as TJDOJsonObject;\n  if Assigned(lJSON) then\n  begin\n    lGraphic := AElementValue.AsObject as TGraphic;\n    if Assigned(lGraphic) then\n    begin\n      SS := TStringStream.Create(lJSON.S[APropertyName]);\n      try\n        SS.Position := 0;\n        lTmpStream := TMemoryStream.Create;\n        try\n          TMVCSerializerHelper.DecodeStream(SS, lTmpStream);\n          lTmpStream.Position := 0;\n          lGraphic.LoadFromStream(lTmpStream);\n        finally\n          lTmpStream.Free;\n        end;\n      finally\n        SS.Free;\n      end;\n    end;\n  end;\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.DeserializeRoot(\n  const ASerializerObject, AObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n  raise EMVCDeserializationException.Create('Direct image deserialization not supported');\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.SerializeAttribute(\n  const AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nvar\n  lGraphic: TGraphic;\n  lTmpStream: TMemoryStream;\n  lStringStream: TStringStream;\nbegin\n  lGraphic := AElementValue.AsObject as TGraphic;\n  if Assigned(lGraphic) then\n  begin\n    lStringStream := TStringStream.Create('', TEncoding.ASCII);\n    try\n      lTmpStream := TMemoryStream.Create;\n      try\n        lGraphic.SaveToStream(lTmpStream);\n        lTmpStream.Position := 0;\n        TMVCSerializerHelper.EncodeStream(lTmpStream, lStringStream);\n      finally\n        lTmpStream.Free;\n      end;\n      TJDOJsonObject(ASerializerObject).S[APropertyName] := lStringStream.DataString;\n    finally\n      lStringStream.Free;\n    end;\n  end\n  else\n  begin\n    TJsonObject(ASerializerObject).Values[APropertyName] := nil;\n  end;\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.SerializeRoot(\n  const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nbegin\n  ASerializerObject := TJsonObject.Create;\n  try\n    SerializeAttribute(AObject, 'data', ASerializerObject, AAttributes);\n  except\n    ASerializerObject.Free;\n    raise;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.IO;\nusing Newtonsoft.Json.Linq;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.Commons;\n\nnamespace MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes\n{\n#if WINDOWS\n    public class MVCBitmapSerializerJsonDataObject : IMVCTypeSerializer\n    {\n        \n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, object[] attributes)\n        {\n            var image = elementValue as Image;\n            if (image != null)\n            {\n                using (var ms = new MemoryStream())\n                {\n                    \n                    image.Save(ms, System.Drawing.Imaging.ImageFormat.Png);\n                    ms.Position = 0;\n                    string base64 = Convert.ToBase64String(ms.ToArray());\n                    \n                    if (serializerObject is JObject jObj)\n                    {\n                        jObj[propertyName] = base64;\n                    }\n                }\n            }\n            else\n            {\n                if (serializerObject is JObject jObj)\n                {\n                    jObj[propertyName] = null;\n                }\n            }\n        }\n\n        \n        public void SerializeRoot(object obj, out object serializerObject, object[] attributes, Action serializationAction = null)\n        {\n            var jObj = new JObject();\n            serializerObject = jObj;\n            try\n            {\n                SerializeAttribute(obj, \"data\", jObj, attributes);\n            }\n            catch (Exception)\n            {\n                \n                throw;\n            }\n        }\n\n        \n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, object[] attributes)\n        {\n            if (serializerObject is JObject jObj)\n            {\n                string base64 = jObj.Value<string>(propertyName);\n                if (!string.IsNullOrEmpty(base64))\n                {\n                    byte[] bytes = Convert.FromBase64String(base64);\n                    using (var ms = new MemoryStream(bytes))\n                    {\n                        var image = Image.FromStream(ms);\n                        elementValue = image;\n                    }\n                }\n            }\n        }\n\n        \n        public void DeserializeRoot(object serializerObject, object obj, object[] attributes)\n        {\n            throw new NotSupportedException(\"Direct image deserialization not supported\");\n        }\n    }\n#endif\n\n    public static class OptionalCustomTypesSerializers\n    {\n#if WINDOWS\n        \n        public static void RegisterOptionalCustomTypesSerializers(IMVCSerializer serializer)\n        {\n            \n            serializer.RegisterTypeSerializer(typeof(Bitmap), new MVCBitmapSerializerJsonDataObject());\n            serializer.RegisterTypeSerializer(typeof(Image), new MVCBitmapSerializerJsonDataObject());\n        }\n#endif\n\n        \n        public static void RegisterOptionalCustomTypesSerializersForJSON(System.Collections.Generic.Dictionary<string, IMVCSerializer> serializers)\n        {\n#if WINDOWS\n            if (serializers.TryGetValue(MVCMediaType.APPLICATION_JSON, out IMVCSerializer serializer))\n            {\n                RegisterOptionalCustomTypesSerializers(serializer);\n            }\n#endif\n        }\n    }\n}"}
{"input": "unit MyController2U;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/api/person')]\n  TMyController2 = class(TMVCController)\n  public\n    [MVCPath('')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetPerson;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Controllers.Register;\n\n{ TMyController2 }\n\ntype\n  TPerson = class\n  private\n    FName: string;\n    FAge: Integer;\n    FCountry: string;\n  public\n    property Name: string read FName write FName;\n    property Age: Integer read FAge write FAge;\n    property Country: string read FCountry write FCountry;\n  end;\n\nprocedure TMyController2.GetPerson;\nvar\n  LPerson: TPerson;\nbegin\n  LPerson := TPerson.Create;\n  LPerson.Name := 'Jo\ufffdo Ant\ufffdnio Duarte';\n  LPerson.Age := 26;\n  LPerson.Country := 'Brasil';\n  Render(LPerson);\nend;\n\ninitialization\n\nTControllersRegister.Instance.RegisterController(TMyController2, 'MyServerName');\n\nend.", "output": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Country { get; set; }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.Executor;\n\ninterface\n\nuses\n  MVCFramework.Commons, System.SysUtils, System.Generics.Collections,\n  JsonDataObjects, DMVC.Expert.Commons;\n\ntype\n  TMVCCodeGenerator = class\n  private\n    fIntf: TStringBuilder;\n    fImpl: TStringBuilder;\n    fCommands: TList<IGenCommand>;\n    fSource: string;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n    procedure Execute(Model: TJSONObject);\n    function Commands: TList<IGenCommand>;\n    function Source: String;\n    class function GenerateSource(ConfigModelRef: TJSONObject; FillerProc: TProc<TMVCCodeGenerator>): String;\n  end;\n\n\nimplementation\n\nfunction TMVCCodeGenerator.Commands: TList<IGenCommand>;\nbegin\n  Result := fCommands;\nend;\n\nconstructor TMVCCodeGenerator.Create;\nbegin\n  inherited;\n  fCommands := TList<IGenCommand>.Create;\n  fSource := '';\nend;\n\ndestructor TMVCCodeGenerator.Destroy;\nbegin\n  fCommands.Free;\n  inherited;\nend;\n\n{ TMVCProjectGenerator }\n\nprocedure TMVCCodeGenerator.Execute(Model: TJSONObject);\nvar\n  I: Integer;\nbegin\n  fSource := '';\n  fIntf := TStringBuilder.Create;\n  try\n    fImpl := TStringBuilder.Create;\n    try\n      for I := 0 to fCommands.Count - 1 do\n      begin\n        fCommands[I].ExecuteInterface(fIntf, Model);\n        fCommands[I].ExecuteImplementation(fImpl, Model);\n      end;\n      fSource := fIntf.ToString + fImpl.ToString;\n    finally\n      fImpl.Free;\n    end;\n  finally\n    fIntf.Free;\n  end;\nend;\n\nclass function TMVCCodeGenerator.GenerateSource(ConfigModelRef: TJSONObject;\n  FillerProc: TProc<TMVCCodeGenerator>): String;\nvar\n  lGenerator: TMVCCodeGenerator;\nbegin\n  lGenerator := TMVCCodeGenerator.Create;\n  try\n    lGenerator.Commands.Clear;\n    FillerProc(lGenerator);\n    lGenerator.Execute(ConfigModelRef);\n    Result := lGenerator.Source;\n  finally\n    lGenerator.Free;\n  end;\nend;\n\n{ TIntfCommand }\n\nfunction TMVCCodeGenerator.Source: String;\nbegin\n  Result := fSource;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertCodeGenExecutor\n{\n        public interface IGenCommand\n    {\n                void ExecuteInterface(StringBuilder intf, JObject model);\n        void ExecuteImplementation(StringBuilder impl, JObject model);\n    }\n\n    public class TMVCCodeGenerator\n    {\n        private StringBuilder fIntf;\n        private StringBuilder fImpl;\n        private List<IGenCommand> fCommands;\n        private string fSource;\n\n        public TMVCCodeGenerator()\n        {\n            fCommands = new List<IGenCommand>();\n            fSource = string.Empty;\n        }\n\n        public List<IGenCommand> Commands => fCommands;\n\n        public string Source => fSource;\n\n        public void Execute(JObject model)\n        {\n            fSource = string.Empty;\n            fIntf = new StringBuilder();\n            try\n            {\n                fImpl = new StringBuilder();\n                try\n                {\n                    foreach (var command in fCommands)\n                    {\n                        command.ExecuteInterface(fIntf, model);\n                        command.ExecuteImplementation(fImpl, model);\n                    }\n                    fSource = fIntf.ToString() + fImpl.ToString();\n                }\n                finally\n                {\n                    // fImpl is a managed object; no explicit disposal is required.\n                }\n            }\n            finally\n            {\n                // fIntf is a managed object; no explicit disposal is required.\n            }\n        }\n\n        \n        public static string GenerateSource(JObject configModelRef, Action<TMVCCodeGenerator> fillerProc)\n        {\n            var generator = new TMVCCodeGenerator();\n            try\n            {\n                generator.Commands.Clear();\n                fillerProc(generator);\n                generator.Execute(configModelRef);\n                return generator.Source;\n            }\n            finally\n            {\n                // No unmanaged resources to dispose.\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Authentication;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.StrUtils,\n  System.Generics.Collections,\n  System.JSON,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons;\n\ntype\n\n  TMVCBasicAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FRealm: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      );\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean\n      );\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  public\n    constructor Create(\n      const AAuthenticationHandler: IMVCAuthenticationHandler;\n      const ARealm: string = 'DelphiMVCFramework REALM'\n      ); virtual;\n  end;\n\n  TMVCCustomAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FLoginUrl: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      ); virtual;\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(\n      AContext: TWebContext;\n      const AHandled: Boolean\n      );\n\n    procedure SendResponse(AContext: TWebContext; var AHandled: Boolean; AHttpStatus: Word = HTTP_STATUS.Unauthorized);\n    procedure DoLogin(AContext: TWebContext; var AHandled: Boolean);\n    procedure DoLogout(AContext: TWebContext; var AHandled: Boolean);\n  public\n    constructor Create(\n      const AAuthenticationHandler: IMVCAuthenticationHandler;\n      const ALoginUrl: string = '/system/users/logged'\n      ); virtual;\n  end;\n\nimplementation\n\nconst\n  CONTENT_HTML_FORMAT = '<html><body><h1>%s</h1><p>%s</p></body></html>';\n  CONTENT_401_NOT_AUTHORIZED = '401: Not authorized';\n  CONTENT_403_FORBIDDEN = '403: Forbidden';\n\n  { TMVCBasicAuthenticationMiddleware }\n\nconstructor TMVCBasicAuthenticationMiddleware.Create(\n  const AAuthenticationHandler: IMVCAuthenticationHandler;\n  const ARealm: string);\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FRealm := ARealm;\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean\n      );\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string;\n  var AHandled: Boolean);\n\n  procedure SendWWWAuthenticate;\n  begin\n    AContext.LoggedUser.Clear;\n    if AContext.Request.ClientPreferHTML then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n      AContext.Response.RawWebResponse.Content :=\n        Format(CONTENT_HTML_FORMAT, [CONTENT_401_NOT_AUTHORIZED, AContext.Config[TMVCConfigKey.ServerName]]);\n    end\n    else\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_PLAIN;\n      AContext.Response.RawWebResponse.Content := CONTENT_401_NOT_AUTHORIZED + sLineBreak + AContext.Config\n        [TMVCConfigKey.ServerName];\n    end;\n    AContext.Response.StatusCode := HTTP_STATUS.Unauthorized;\n    AContext.Response.SetCustomHeader('WWW-Authenticate', 'Basic realm=' + QuotedStr(FRealm));\n    AContext.SessionStop(False);\n    AHandled := True;\n  end;\n\n  procedure Send403Forbidden;\n  begin\n    AContext.LoggedUser.Clear;\n    if AContext.Request.ClientPreferHTML then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n      AContext.Response.RawWebResponse.Content :=\n        Format(CONTENT_HTML_FORMAT, [CONTENT_403_FORBIDDEN, AContext.Config[TMVCConfigKey.ServerName]]);\n    end\n    else if AContext.Request.ContentMediaType.StartsWith(TMVCMediaType.APPLICATION_JSON) then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n      AContext.Response.RawWebResponse.Content :=\n        '{\"status\":\"error\", \"message\":\"' + CONTENT_403_FORBIDDEN.Replace('\"', '\\\"') + '\"}';\n    end\n    else\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_PLAIN;\n      AContext.Response.RawWebResponse.Content := CONTENT_403_FORBIDDEN + sLineBreak + AContext.Config\n        [TMVCConfigKey.ServerName];\n    end;\n    AContext.Response.StatusCode := HTTP_STATUS.Forbidden;\n    AContext.Response.ReasonString := AContext.Config[TMVCConfigKey.ServerName];\n    AHandled := True;\n  end;\n\nvar\n  AuthRequired: Boolean;\n  IsValid, IsAuthorized: Boolean;\n  AuthHeader, Token: string;\n  AuthPieces: TArray<string>;\n  RolesList: TList<string>;\n  SessionData: TSessionData;\n  SessionPair: TPair<string, string>;\nbegin\n  FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n  if not AuthRequired then\n  begin\n    AHandled := False;\n    Exit;\n  end;\n\n  AContext.LoggedUser.LoadFromSession(AContext.Session);\n  IsValid := AContext.LoggedUser.IsValid;\n  if not IsValid then\n  begin\n    AuthHeader := AContext.Request.Headers['Authorization'];\n    if AuthHeader.IsEmpty or (not AuthHeader.StartsWith('Basic ', True)) then\n    begin\n      SendWWWAuthenticate;\n      Exit;\n    end;\n    Token := AuthHeader.Remove(0, 'Basic '.Length).Trim;\n    AuthHeader := TMVCSerializerHelper.DecodeString(Token);\n    AuthPieces := AuthHeader.Split([':']);\n    if Length(AuthPieces) <> 2 then\n    begin\n      SendWWWAuthenticate;\n      Exit;\n    end;\n\n    RolesList := TList<string>.Create;\n    try\n      SessionData := TSessionData.Create;\n      try\n        FAuthenticationHandler.OnAuthentication(AContext, AuthPieces[0], AuthPieces[1], RolesList, IsValid,\n          SessionData);\n        if IsValid then\n        begin\n          AContext.LoggedUser.Roles.AddRange(RolesList);\n          AContext.LoggedUser.UserName := AuthPieces[0];\n          AContext.LoggedUser.LoggedSince := Now;\n          AContext.LoggedUser.Realm := FRealm;\n          AContext.LoggedUser.SaveToSession(AContext.Session);\n          for SessionPair in SessionData do\n            AContext.Session[SessionPair.Key] := SessionPair.Value;\n        end;\n      finally\n        SessionData.Free;\n      end;\n    finally\n      RolesList.Free;\n    end;\n  end;\n\n  IsAuthorized := False;\n  if IsValid then\n    FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n      AActionName, IsAuthorized);\n\n  if IsAuthorized then\n    AHandled := False\n  else\n  begin\n    if IsValid then\n      Send403Forbidden\n    else\n    begin\n      SendWWWAuthenticate;\n    end;\n  end;\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnBeforeRouting(\n  AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  AHandled := False;\nend;\n\n{ TMVCCustomAuthenticationMiddleware }\n\nconstructor TMVCCustomAuthenticationMiddleware.Create(\n  const AAuthenticationHandler: IMVCAuthenticationHandler;\n  const ALoginUrl: string);\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FLoginUrl := ALoginUrl.ToLower;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.DoLogin(\n  AContext: TWebContext;\n  var AHandled: Boolean);\nvar\n  Jo: TJSONObject;\n  UserName, Password: string;\n  RolesList: TList<string>;\n  SessionPair: TPair<string, string>;\n  SessionData: TSessionData;\n  IsValid: Boolean;\nbegin\n  AContext.SessionStop(False);\n  AContext.LoggedUser.Clear;\n  if not AContext.Request.HasBody then\n  begin\n    AHandled := True;\n    AContext.Response.StatusCode := HTTP_STATUS.BadRequest;\n    AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n    AContext.Response.RawWebResponse.Content :=\n      '{\"status\":\"error\", \"message\":\"username and password are mandatory in the body request as json object\"}';\n    Exit;\n  end;\n\n  Jo := TJSONObject.ParseJSONValue(AContext.Request.Body) as TJSONObject;\n  try\n    if not Assigned(Jo) then\n    begin\n      AHandled := True;\n      SendResponse(AContext, AHandled, HTTP_STATUS.BadRequest);\n      Exit;\n    end;\n\n    UserName := EmptyStr;\n    if (Jo.Get('username') <> nil) then\n      UserName := Jo.Get('username').JsonValue.Value;\n\n    Password := EmptyStr;\n    if (Jo.Get('password') <> nil) then\n      Password := Jo.Get('password').JsonValue.Value;\n\n    if UserName.IsEmpty or Password.IsEmpty then\n    begin\n      AHandled := True;\n      SendResponse(AContext, AHandled);\n      Exit;\n    end;\n\n    RolesList := TList<string>.Create;\n    try\n      SessionData := TSessionData.Create;\n      try\n        IsValid := False;\n        FAuthenticationHandler.OnAuthentication(AContext, UserName, Password, RolesList, IsValid, SessionData);\n        if not IsValid then\n        begin\n          SendResponse(AContext, AHandled);\n          Exit;\n        end;\n\n        AContext.LoggedUser.Roles.AddRange(RolesList);\n        AContext.LoggedUser.UserName := UserName;\n        AContext.LoggedUser.LoggedSince := Now;\n        AContext.LoggedUser.Realm := 'custom';\n        AContext.LoggedUser.SaveToSession(AContext.Session);\n\n        for SessionPair in SessionData do\n          AContext.Session[SessionPair.Key] := SessionPair.Value;\n\n        AContext.Response.StatusCode := HTTP_STATUS.OK;\n        AContext.Response.CustomHeaders.Values['X-LOGOUT-URL'] := FLoginUrl;\n        AContext.Response.CustomHeaders.Values['X-LOGOUT-METHOD'] := 'DELETE';\n        AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n        AContext.Response.RawWebResponse.Content := '{\"status\":\"OK\"}';\n\n        AHandled := True;\n      finally\n        SessionData.Free;\n      end;\n    finally\n      RolesList.Free;\n    end;\n  finally\n    Jo.Free;\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.DoLogout(\n  AContext: TWebContext; var AHandled: Boolean);\nbegin\n  AContext.SessionStop(False);\n  SendResponse(AContext, AHandled, HTTP_STATUS.OK);\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string;\n  var AHandled: Boolean);\nvar\n  IsValid: Boolean;\n  IsAuthorized: Boolean;\n  AuthRequired: Boolean;\nbegin\n  FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n  if not AuthRequired then\n  begin\n    AHandled := False;\n    Exit;\n  end;\n\n  AContext.LoggedUser.LoadFromSession(AContext.Session);\n  IsValid := AContext.LoggedUser.IsValid;\n  if not IsValid then\n  begin\n    AContext.SessionStop(False);\n    SendResponse(AContext, AHandled);\n    Exit;\n  end;\n\n  IsAuthorized := False;\n  FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n    AActionName, IsAuthorized);\n  if IsAuthorized then\n    AHandled := False\n  else\n  begin\n    if IsValid then\n      SendResponse(AContext, AHandled, HTTP_STATUS.Forbidden)\n    else\n      SendResponse(AContext, AHandled, HTTP_STATUS.Unauthorized);\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnBeforeRouting(\n  AContext: TWebContext; var AHandled: Boolean);\nbegin\n  if (AContext.Request.PathInfo.ToLower = FLoginUrl) then\n  begin\n    AHandled := False;\n\n    if (AContext.Request.HTTPMethod = httpPOST) and\n      (AContext.Request.ContentType.StartsWith(TMVCMediaType.APPLICATION_JSON)) then\n      DoLogin(AContext, AHandled);\n\n    if (AContext.Request.HTTPMethod = httpDELETE) then\n      DoLogout(AContext, AHandled);\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.SendResponse(\n  AContext: TWebContext; var AHandled: Boolean; AHttpStatus: Word);\nvar\n  IsPositive: Boolean;\n  Msg: string;\nbegin\n  AContext.LoggedUser.Clear;\n  AContext.Response.CustomHeaders.Values['X-LOGIN-URL'] := FLoginUrl;\n  AContext.Response.CustomHeaders.Values['X-LOGIN-METHOD'] := 'POST';\n  AContext.Response.StatusCode := AHttpStatus;\n  if AContext.Request.ClientPreferHTML then\n  begin\n    AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n    AContext.Response.RawWebResponse.Content :=\n      Format(CONTENT_HTML_FORMAT, [IntToStr(AHttpStatus), AContext.Config[TMVCConfigKey.ServerName]]);\n  end\n  else\n  begin\n    IsPositive := (AHttpStatus div 100) = 2;\n    Msg := IfThen(IsPositive, 'OK', 'KO');\n    AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n    AContext.Response.RawWebResponse.Content := '{\"status\":\"' + Msg + '\", \"message\":\"' + IntToStr(AHttpStatus) + '\"}';\n  end;\n  AHandled := True;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Text.Json;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Commons;\n\nnamespace MVCFramework.Middleware.Authentication\n{\n    \n    public class MVCBasicAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly string _realm;\n\n        private const string CONTENT_HTML_FORMAT = \"<html><body><h1>{0}</h1><p>{1}</p></body></html>\";\n        private const string CONTENT_401_NOT_AUTHORIZED = \"401: Not authorized\";\n        private const string CONTENT_403_FORBIDDEN = \"403: Forbidden\";\n\n        public MVCBasicAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            string realm = \"DelphiMVCFramework REALM\")\n        {\n            _authenticationHandler = authenticationHandler;\n            _realm = realm;\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            \n            handled = false;\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            \n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                return;\n            }\n\n            \n            context.LoggedUser.LoadFromSession(context.Session);\n            bool isValid = context.LoggedUser.IsValid;\n\n            \n            if (!isValid)\n            {\n                string authHeader = context.Request.Headers[\"Authorization\"];\n                if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith(\"Basic \", StringComparison.OrdinalIgnoreCase))\n                {\n                    SendWWWAuthenticate(context, ref handled);\n                    return;\n                }\n\n                \n                string token = authHeader.Substring(\"Basic \".Length).Trim();\n                \n                authHeader = MVCSerializerHelper.DecodeString(token);\n                string[] authPieces = authHeader.Split(':');\n                if (authPieces.Length != 2)\n                {\n                    SendWWWAuthenticate(context, ref handled);\n                    return;\n                }\n\n                var rolesList = new List<string>();\n                SessionData sessionData = new SessionData();\n                _authenticationHandler.OnAuthentication(context, authPieces[0], authPieces[1], rolesList, out isValid, sessionData);\n                if (isValid)\n                {\n                    context.LoggedUser.Roles.AddRange(rolesList);\n                    context.LoggedUser.UserName = authPieces[0];\n                    context.LoggedUser.LoggedSince = DateTime.Now;\n                    context.LoggedUser.Realm = _realm;\n                    context.LoggedUser.SaveToSession(context.Session);\n                    foreach (var pair in sessionData)\n                    {\n                        context.Session[pair.Key] = pair.Value;\n                    }\n                }\n            }\n\n            \n            bool isAuthorized = false;\n            if (isValid)\n            {\n                _authenticationHandler.OnAuthorization(\n                    context,\n                    context.LoggedUser.Roles,\n                    controllerQualifiedClassName,\n                    actionName,\n                    out isAuthorized);\n            }\n\n            if (isAuthorized)\n            {\n                handled = false;\n            }\n            else\n            {\n                if (isValid)\n                    Send403Forbidden(context, ref handled);\n                else\n                    SendWWWAuthenticate(context, ref handled);\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No post-action processing in basic authentication.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Nothing to do after routing.\n        }\n\n        #region Helper Methods\n\n        private void SendWWWAuthenticate(WebContext context, ref bool handled)\n        {\n            context.LoggedUser.Clear();\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    CONTENT_HTML_FORMAT,\n                    CONTENT_401_NOT_AUTHORIZED,\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else\n            {\n                context.Response.ContentType = MediaType.TextPlain;\n                context.Response.RawWebResponse.Content = CONTENT_401_NOT_AUTHORIZED + Environment.NewLine +\n                    context.Config[ConfigKey.ServerName];\n            }\n            context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n            context.Response.SetCustomHeader(\"WWW-Authenticate\", $\"Basic realm={Quote(_realm)}\");\n            context.SessionStop(false);\n            handled = true;\n        }\n\n        private void Send403Forbidden(WebContext context, ref bool handled)\n        {\n            context.LoggedUser.Clear();\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    CONTENT_HTML_FORMAT,\n                    CONTENT_403_FORBIDDEN,\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else if (context.Request.ContentMediaType.StartsWith(MediaType.ApplicationJson, StringComparison.OrdinalIgnoreCase))\n            {\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content = \"{\\\"status\\\":\\\"error\\\", \\\"message\\\":\\\"\" +\n                    CONTENT_403_FORBIDDEN.Replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"}\";\n            }\n            else\n            {\n                context.Response.ContentType = MediaType.TextPlain;\n                context.Response.RawWebResponse.Content = CONTENT_403_FORBIDDEN + Environment.NewLine +\n                    context.Config[ConfigKey.ServerName];\n            }\n            context.Response.StatusCode = (int)HttpStatusCode.Forbidden;\n            context.Response.ReasonString = context.Config[ConfigKey.ServerName];\n            handled = true;\n        }\n\n        private string Quote(string s) => $\"\\\"{s}\\\"\";\n\n        #endregion\n    }\n\n    \n    public class MVCCustomAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly string _loginUrl;\n\n        public MVCCustomAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            string loginUrl = \"/system/users/logged\")\n        {\n            _authenticationHandler = authenticationHandler;\n            _loginUrl = loginUrl.ToLower();\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            if (context.Request.PathInfo.ToLower() == _loginUrl)\n            {\n                handled = false;\n                if (context.Request.HTTPMethod.Equals(\"POST\", StringComparison.OrdinalIgnoreCase) &&\n                    context.Request.ContentType.StartsWith(MediaType.ApplicationJson, StringComparison.OrdinalIgnoreCase))\n                {\n                    DoLogin(context, ref handled);\n                }\n                else if (context.Request.HTTPMethod.Equals(\"DELETE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    DoLogout(context, ref handled);\n                }\n            }\n        }\n\n        public virtual void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                return;\n            }\n            context.LoggedUser.LoadFromSession(context.Session);\n            bool isValid = context.LoggedUser.IsValid;\n            if (!isValid)\n            {\n                context.SessionStop(false);\n                SendResponse(context, ref handled);\n                return;\n            }\n            bool isAuthorized = false;\n            _authenticationHandler.OnAuthorization(\n                context,\n                context.LoggedUser.Roles,\n                controllerQualifiedClassName,\n                actionName,\n                out isAuthorized);\n            if (isAuthorized)\n            {\n                handled = false;\n            }\n            else\n            {\n                if (isValid)\n                    SendResponse(context, ref handled, HttpStatusCode.Forbidden);\n                else\n                    SendResponse(context, ref handled, HttpStatusCode.Unauthorized);\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement post-action processing if needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Nothing to do.\n        }\n\n        #region Protected Helpers\n\n        protected void SendResponse(WebContext context, ref bool handled, HttpStatusCode status = HttpStatusCode.Unauthorized)\n        {\n            context.LoggedUser.Clear();\n            context.Response.SetCustomHeader(\"X-LOGIN-URL\", _loginUrl);\n            context.Response.SetCustomHeader(\"X-LOGIN-METHOD\", \"POST\");\n            context.Response.StatusCode = (int)status;\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    MVCBasicAuthenticationMiddleware.CONTENT_HTML_FORMAT,\n                    ((int)status).ToString(),\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else\n            {\n                bool isPositive = (((int)status) / 100) == 2;\n                string msg = isPositive ? \"OK\" : \"KO\";\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content = $\"{{\\\"status\\\":\\\"{msg}\\\", \\\"message\\\":\\\"{(int)status}\\\"}}\";\n            }\n            handled = true;\n        }\n\n        protected void DoLogin(WebContext context, ref bool handled)\n        {\n            context.SessionStop(false);\n            context.LoggedUser.Clear();\n            if (!context.Request.HasBody)\n            {\n                handled = true;\n                context.Response.StatusCode = (int)HttpStatusCode.BadRequest;\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content =\n                    \"{\\\"status\\\":\\\"error\\\", \\\"message\\\":\\\"username and password are mandatory in the body request as json object\\\"}\";\n                return;\n            }\n\n            \n            JsonDocument doc = JsonDocument.Parse(context.Request.Body);\n            JsonElement root = doc.RootElement;\n            string userName = root.TryGetProperty(\"username\", out JsonElement userProp)\n                ? userProp.GetString() ?? string.Empty : string.Empty;\n            string password = root.TryGetProperty(\"password\", out JsonElement passProp)\n                ? passProp.GetString() ?? string.Empty : string.Empty;\n\n            if (string.IsNullOrEmpty(userName) || string.IsNullOrEmpty(password))\n            {\n                handled = true;\n                SendResponse(context, ref handled);\n                return;\n            }\n\n            var rolesList = new List<string>();\n            SessionData sessionData = new SessionData();\n            bool isValid = false;\n            _authenticationHandler.OnAuthentication(context, userName, password, rolesList, out isValid, sessionData);\n            if (!isValid)\n            {\n                SendResponse(context, ref handled);\n                return;\n            }\n\n            context.LoggedUser.Roles.AddRange(rolesList);\n            context.LoggedUser.UserName = userName;\n            context.LoggedUser.LoggedSince = DateTime.Now;\n            context.LoggedUser.Realm = \"custom\";\n            context.LoggedUser.SaveToSession(context.Session);\n\n            foreach (var pair in sessionData)\n            {\n                context.Session[pair.Key] = pair.Value;\n            }\n\n            context.Response.StatusCode = (int)HttpStatusCode.OK;\n            context.Response.SetCustomHeader(\"X-LOGOUT-URL\", _loginUrl);\n            context.Response.SetCustomHeader(\"X-LOGOUT-METHOD\", \"DELETE\");\n            context.Response.ContentType = MediaType.ApplicationJson;\n            context.Response.RawWebResponse.Content = \"{\\\"status\\\":\\\"OK\\\"}\";\n            handled = true;\n        }\n\n        protected void DoLogout(WebContext context, ref bool handled)\n        {\n            context.SessionStop(false);\n            SendResponse(context, ref handled, HttpStatusCode.OK);\n        }\n\n        #endregion\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.DotEnv;\n\ninterface\n\nuses\n  System.Generics.Collections,\n  MVCFramework.DotEnv.Parser,\n  System.SysUtils;\n\ntype\n{$SCOPEDENUMS ON}\n  TMVCDotEnvPriority = (FileThenEnv, EnvThenFile, OnlyFile, OnlyEnv);\n\n  EMVCDotEnv = class(Exception)\n\n  end;\n\n  IMVCDotEnv = interface\n    ['{5FD2C3CB-0895-4CCD-985F-27394798E4A8}']\n    function Env(const Name: string): string; overload;\n    function Env(const Name: string; const DefaultValue: String): string; overload;\n    function Env(const Name: string; const DefaultValue: Integer): Integer; overload;\n    function Env(const Name: string; const DefaultValue: Boolean): Boolean; overload;\n    procedure RequireKeys(const Keys: TArray<String>);\n    function SaveToFile(const FileName: String): IMVCDotEnv;\n    function ToArray(): TArray<String>;\n  end;\n\n  IMVCDotEnvBuilder = interface\n    ['{1A5EDD44-7226-40BC-A8EE-789E27522392}']\n    function UseStrategy(const Strategy: TMVCDotEnvPriority = TMVCDotEnvPriority.EnvThenFile): IMVCDotEnvBuilder;\n    function SkipDefaultEnv: IMVCDotEnvBuilder;\n    function UseLogger( const Logger: TProc<String>): IMVCDotEnvBuilder;\n    function UseProfile(const ProfileName: String): IMVCDotEnvBuilder; overload;\n    function UseProfile(const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder; overload;\n    function ClearProfiles: IMVCDotEnvBuilder;\n    function Build(const DotEnvPath: string = ''): IMVCDotEnv; overload;\n  end;\n\nfunction NewDotEnv: IMVCDotEnvBuilder;\n\nimplementation\n\nuses\n  System.IOUtils,\n  System.TypInfo,\n  System.Classes,\n  MVCFramework.Commons;\n\nvar\n  gDotEnv: IMVCDotEnvBuilder = nil;\n\n{ TDotEnv }\n\ntype\n{$SCOPEDENUMS ON}\n  TdotEnvEngineState = (created, building, built);\n  TMVCDotEnv = class(TInterfacedObject, IMVCDotEnv, IMVCDotEnvBuilder)\n  strict private\n    fState: TdotEnvEngineState;\n    fPriority: TMVCDotEnvPriority;\n    fEnvPath: string;\n    fEnvDict: TMVCDotEnvDictionary;\n    fLoggerProc: TProc<String>;\n    fProfiles: TList<String>;\n    fSkipDefaultEnv: Boolean;\n    procedure DoLog(const Value: String);\n    procedure ReadEnvFile;\n    function GetDotEnvVar(const key: string): string;\n    function GetBuiltInVariable(const VarName: String; out Value: String): Boolean;\n    function ExplodePlaceholders(const Value: string): string;\n    procedure PopulateDictionary(const EnvDict: TDictionary<string, string>; const EnvFilePath: String);\n    procedure CheckAlreadyBuilt;\n    procedure ExplodeReferences;\n  strict protected\n    function UseStrategy(const Priority: TMVCDotEnvPriority = TMVCDotEnvPriority.EnvThenFile): IMVCDotEnvBuilder; overload;\n    function SkipDefaultEnv: IMVCDotEnvBuilder;\n    function UseProfile(const ProfileName: String): IMVCDotEnvBuilder; overload;\n    function UseProfile(const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder; overload;\n    function UseLogger(const LoggerProc: TProc<String>): IMVCDotEnvBuilder;\n    function ClearProfiles: IMVCDotEnvBuilder;\n    function Build(const DotEnvDirectory: string = ''): IMVCDotEnv; overload;\n    function Env(const Name: string): string; overload;\n    function Env(const Name: string; const DefaultValue: String): string; overload;\n    function Env(const Name: string; const DefaultValue: Integer): Integer; overload;\n    function Env(const Name: string; const DefaultValue: Boolean): Boolean; overload;\n    procedure RequireKeys(const Keys: TArray<String>);\n    function SaveToFile(const FileName: String): IMVCDotEnv;\n    function ToArray(): TArray<String>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n  end;\n\n\nfunction TMVCDotEnv.GetBuiltInVariable(const VarName: String;\n  out Value: String): Boolean;\nvar\n  lVarName: string;\nbegin\n  Result := False;\n  lVarName := VarName.ToLower.Remove(VarName.Length -2, 2).Remove(0,2);\n\n  if lVarName = 'os' then\n  begin\n    Value := TOSVersion.Name;\n    Exit(True);\n  end;\n\n  if lVarName = 'home' then\n  begin\n    Value := AppPath;\n    Exit(True);\n  end;\n\n  if lVarName = 'dmvc.version' then\n  begin\n    Value := DMVCFRAMEWORK_VERSION;\n    Exit(True);\n  end;\n  DoLog('Unknown built-in env var named ' + lVarName + '.');\nend;\n\nfunction TMVCDotEnv.GetDotEnvVar(const key: string): string;\nbegin\n  fEnvDict.TryGetValue(key, Result);\nend;\n\nfunction TMVCDotEnv.Env(const Name: string): string;\nvar\n  lTmp: String;\nbegin\n  if fState = TdotEnvEngineState.created then\n  begin\n    raise EMVCDotEnv.Create('dotEnv Engine not built');\n  end;\n\n  if fPriority in [TMVCDotEnvPriority.FileThenEnv, TMVCDotEnvPriority.OnlyFile] then\n  begin\n    Result := GetDotEnvVar(name);\n    if Result.Contains('${' + Name + '}') then\n    begin\n      raise EMVCDotEnv.CreateFmt('Configuration loop detected with key \"%s\"', [Name]);\n    end;\n\n    if fPriority = TMVCDotEnvPriority.OnlyFile then\n    begin\n      // OnlyFile\n      Exit;\n    end;\n    // FileThenEnv\n    if Result.IsEmpty then\n    begin\n      Exit(ExplodePlaceholders(GetEnvironmentVariable(Name)));\n    end;\n  end\n  else if fPriority in [TMVCDotEnvPriority.EnvThenFile, TMVCDotEnvPriority.OnlyEnv] then\n  begin\n    Result := ExplodePlaceholders(GetEnvironmentVariable(Name));\n    if fPriority = TMVCDotEnvPriority.OnlyEnv then\n    begin\n      // OnlyEnv\n      Exit;\n    end;\n    // EnvThenFile\n    if Result.IsEmpty then\n    begin\n      lTmp := GetDotEnvVar(Name);\n      if lTmp.Contains('${' + Name + '}') then\n      begin\n        raise EMVCDotEnv.CreateFmt('Configuration loop detected with key \"%s\"', [Name]);\n      end;\n      Exit(lTmp);\n    end;\n  end\n  else\n  begin\n    raise EMVCDotEnv.CreateFmt('Unknown dotEnv Priority: %s', [GetEnumName(TypeInfo(TMVCDotEnvPriority), Ord(fPriority))]);\n  end;\nend;\n\nfunction TMVCDotEnv.UseLogger(\n  const LoggerProc: TProc<String>): IMVCDotEnvBuilder;\nbegin\n  if Assigned(fLoggerProc) then\n  begin\n    raise EMVCDotEnv.Create('Logger already set');\n  end;\n  fLoggerProc := LoggerProc;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseProfile(\n  const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Add(ProfileDelegate());\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseProfile(const ProfileName: String): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Add(ProfileName);\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseStrategy(const Priority: TMVCDotEnvPriority): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  Result := Self;\n  fPriority := Priority;\nend;\n\nfunction TMVCDotEnv.Build(const DotEnvDirectory: string): IMVCDotEnv;\nvar\n  lAllProfiles: TArray<String>;\nbegin\n  if fState <> TdotEnvEngineState.created then\n  begin\n    raise EMVCDotEnv.Create('dotEnv engine already built');\n  end;\n  fState := TdotEnvEngineState.building;\n  Result := Self;\n  fEnvPath := TDirectory.GetParent(GetModuleName(HInstance));\n  if not DotEnvDirectory.IsEmpty then\n  begin\n    fEnvPath := TPath.Combine(fEnvPath, DotEnvDirectory);\n  end;\n  DoLog('Path = ' + fEnvPath);\n  fEnvDict.Clear;\n  lAllProfiles := ['default'] + fProfiles.ToArray();\n  if fSkipDefaultEnv then\n  begin\n    Delete(lAllProfiles, 0, 1);\n  end;\n  DoLog('Active profile/s priority = [' + String.Join(',', lAllProfiles) +\n    '] (Priority: ' + GetEnumName(TypeInfo(TMVCDotEnvPriority), Ord(fPriority)) + ')');\n  ReadEnvFile;\n  ExplodeReferences;\n  fState := TdotEnvEngineState.built;\nend;\n\nprocedure TMVCDotEnv.CheckAlreadyBuilt;\nbegin\n  if fState in [TdotEnvEngineState.built] then\n  begin\n    raise Exception.Create('DotEnv Engine Already Built');\n  end;\nend;\n\nfunction TMVCDotEnv.ClearProfiles: IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Clear;\n  Result := Self;\nend;\n\nconstructor TMVCDotEnv.Create;\nbegin\n  inherited;\n  fState := TdotEnvEngineState.created;\n  fProfiles := TList<String>.Create;\n  fEnvDict := TMVCDotEnvDictionary.Create;\n  fEnvPath := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0)));\n  fPriority := TMVCDotEnvPriority.EnvThenFile;\n  fSkipDefaultEnv := False;\nend;\n\ndestructor TMVCDotEnv.Destroy;\nbegin\n  FreeAndNil(fEnvDict);\n  fProfiles.Free;\n  inherited;\nend;\n\nprocedure TMVCDotEnv.DoLog(const Value: String);\nbegin\n  if Assigned(fLoggerProc) then\n  begin\n    fLoggerProc(Value);\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name, DefaultValue: String): string;\nbegin\n  Result := Env(Name);\n  if Result.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name: string;\n  const DefaultValue: Integer): Integer;\nvar\n  lTmp: string;\nbegin\n  lTmp := Env(Name);\n  if lTmp.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end\n  else\n  begin\n    if not TryStrToInt(lTmp.Trim, Result) then\n    begin\n      raise EMVCDotEnv.CreateFmt('Env \"%s\" is not a valid integer [Current Value: \"%s\"]', [Name, lTmp]);\n    end;\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name: string;\n  const DefaultValue: Boolean): Boolean;\nvar\n  lTmp: string;\nbegin\n  lTmp := Env(Name);\n  if lTmp.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end\n  else\n  begin\n    lTmp := lTmp.Trim.ToLower;\n    if (lTmp = 'yes') or (lTmp='1') or (lTmp='true') then\n    begin\n      Exit(True);\n    end;\n    if (lTmp = 'no') or (lTmp='0') or (lTmp='false') then\n    begin\n      Exit(False);\n    end;\n    if not TryStrToBool(lTmp, Result) then\n    begin\n      raise EMVCDotEnv.CreateFmt('Env \"%s\" is not a valid boolean [Current Value: \"%s\"]', [Name, lTmp]);\n    end;\n  end;\nend;\n\nfunction TMVCDotEnv.ExplodePlaceholders(const Value: string): string;\nvar\n  lStartPos, lEndPos: Integer;\n  lKey, lValue: string;\nbegin\n  Result := Value;\n  while Result.IndexOf('${') > -1 do\n  begin\n    lStartPos := Result.IndexOf('${');\n    lEndPos := Result.IndexOf('}');\n    if (lEndPos = -1) or (lEndPos < lStartPos) then\n    begin\n      raise EMVCDotEnv.Create('Unclosed expansion (${...}) at: ' + Value);\n    end;\n    lKey := Result.Substring(lStartPos + 2, lEndPos - (lStartPos + 2));\n\n    if lKey.StartsWith('__') and lKey.EndsWith('__') then\n    begin\n      if not GetBuiltInVariable(lKey, lValue) then\n      begin\n        lValue := Env(lKey);\n      end\n    end\n    else\n    begin\n      lValue := Env(lKey);\n    end;\n    Result := StringReplace(Result, '${' + lKey + '}', lValue, [rfReplaceAll]);\n  end;\nend;\n\nprocedure TMVCDotEnv.ExplodeReferences;\nvar\n  lKey: String;\nbegin\n  for lKey in fEnvDict.Keys do\n  begin\n    fEnvDict.AddOrSetValue(lKey, ExplodePlaceholders(fEnvDict[lKey]));\n  end;\nend;\n\nfunction TMVCDotEnv.SaveToFile(const FileName: String): IMVCDotEnv;\nvar\n  lKeys: TArray<String>;\n  lKey: String;\n  lSL: TStringList;\nbegin\n  lKeys := fEnvDict.Keys.ToArray;\n  TArray.Sort<String>(lKeys);\n  lSL := TStringList.Create;\n  try\n    for lKey in lKeys do\n    begin\n      lSL.Values[lKey] := GetDotEnvVar(lKey);\n    end;\n    lSL.SaveToFile(FileName);\n  finally\n    lSL.Free;\n  end;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.SkipDefaultEnv: IMVCDotEnvBuilder;\nbegin\n  fSkipDefaultEnv := True;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.ToArray: TArray<String>;\nvar\n  lKeys: TArray<String>;\n  lKey: String;\n  I: Integer;\nbegin\n  lKeys := fEnvDict.Keys.ToArray;\n  TArray.Sort<String>(lKeys);\n  SetLength(Result, Length(lKeys));\n  I := 0;\n  for lKey in lKeys do\n  begin\n    Result[I] := lKey + '=' + GetDotEnvVar(lKey);\n    Inc(I);\n  end;\nend;\n\nprocedure TMVCDotEnv.PopulateDictionary(const EnvDict: TDictionary<string, string>; const EnvFilePath: String);\nvar\n  lDotEnvCode: string;\n  lParser: TMVCDotEnvParser;\nbegin\n  if not TFile.Exists(EnvFilePath) then\n  begin\n    DoLog('Missed file ' + EnvFilePath);\n    Exit;\n  end;\n\n  lDotEnvCode := TFile.ReadAllText(EnvFilePath);\n  lParser := TMVCDotEnvParser.Create;\n  try\n    lParser.Parse(fEnvDict, lDotEnvCode);\n    DoLog('Applied file ' + EnvFilePath);\n  finally\n    lParser.Free;\n  end;\nend;\n\nprocedure TMVCDotEnv.ReadEnvFile;\nvar\n  lProfileEnvPath: string;\n  I: Integer;\nbegin\n  if not fSkipDefaultEnv then\n  begin\n    PopulateDictionary(fEnvDict, IncludeTrailingPathDelimiter(fEnvPath) + '.env');\n  end;\n  for I := 0 to fProfiles.Count - 1 do\n  begin\n    lProfileEnvPath := TPath.Combine(fEnvPath, '.env') + '.' + fProfiles[I];\n    PopulateDictionary(fEnvDict, lProfileEnvPath);\n  end;\nend;\n\nprocedure TMVCDotEnv.RequireKeys(const Keys: TArray<String>);\nvar\n  lKey: String;\n  lNotFoundKeys: TArray<String>;\n  lMsg: string;\nbegin\n  if Length(Keys) = 0 then\n  begin\n    Exit;\n  end;\n  DoLog('Checking required keys: ' + String.Join(', ', Keys));\n  lNotFoundKeys := [];\n  for lKey in Keys do\n  begin\n    if Env(lKey).IsEmpty then\n    begin\n      lNotFoundKeys := lNotFoundKeys + [lKey];\n    end;\n  end;\n  if Length(lNotFoundKeys) > 0 then\n  begin\n    lMsg := 'Required keys not found: ' + String.Join(', ', lNotFoundKeys);\n    DoLog(lMsg);\n    raise EMVCDotEnv.Create(lMsg);\n  end;\nend;\n\nfunction NewDotEnv: IMVCDotEnvBuilder;\nbegin\n  Result := TMVCDotEnv.Create;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace MVCFramework.DotEnv\n{\n    #region Exceptions and Enums\n\n    \n    public class DotEnvException : Exception\n    {\n        public DotEnvException(string message) : base(message) { }\n    }\n\n    public enum DotEnvPriority\n    {\n        FileThenEnv,\n        EnvThenFile,\n        OnlyFile,\n        OnlyEnv\n    }\n\n    #endregion\n\n    #region Interfaces\n\n    public interface IMVCDotEnv\n    {\n        string Env(string name);\n        string Env(string name, string defaultValue);\n        int Env(string name, int defaultValue);\n        bool Env(string name, bool defaultValue);\n        void RequireKeys(string[] keys);\n        IMVCDotEnv SaveToFile(string fileName);\n        string[] ToArray();\n    }\n\n    public interface IMVCDotEnvBuilder : IMVCDotEnv\n    {\n        IMVCDotEnvBuilder UseStrategy(DotEnvPriority strategy = DotEnvPriority.EnvThenFile);\n        IMVCDotEnvBuilder SkipDefaultEnv();\n        IMVCDotEnvBuilder UseLogger(Action<string> logger);\n        IMVCDotEnvBuilder UseProfile(string profileName);\n        IMVCDotEnvBuilder UseProfile(Func<string> profileDelegate);\n        IMVCDotEnvBuilder ClearProfiles();\n        IMVCDotEnv Build(string dotEnvDirectory = \"\");\n    }\n\n    #endregion\n\n    #region Public Static API\n\n    public static class DotEnv\n    {\n        private static IMVCDotEnvBuilder _instance;\n\n        public static IMVCDotEnvBuilder NewDotEnv()\n        {\n            if (_instance == null)\n            {\n                _instance = new MVCDotEnv();\n            }\n            return _instance;\n        }\n    }\n\n    #endregion\n\n    #region Implementation\n\n    internal class MVCDotEnv : IMVCDotEnvBuilder\n    {\n        #region Private Types and Fields\n\n        private enum DotEnvEngineState { Created, Building, Built }\n\n        private DotEnvEngineState _state;\n        private DotEnvPriority _priority;\n        private string _envPath;\n        private readonly Dictionary<string, string> _envDict;\n        private Action<string> _loggerProc;\n        private readonly List<string> _profiles;\n        private bool _skipDefaultEnv;\n\n        #endregion\n\n        #region Constructor / Destructor\n\n        public MVCDotEnv()\n        {\n            _state = DotEnvEngineState.Created;\n            _profiles = new List<string>();\n            _envDict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            _envPath = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) ?? \"\";\n            _envPath = Path.EndsInDirectorySeparator(_envPath) ? _envPath : _envPath + Path.DirectorySeparatorChar;\n            _priority = DotEnvPriority.EnvThenFile;\n            _skipDefaultEnv = false;\n        }\n\n        #endregion\n\n        #region Private Helper Methods\n\n        private void DoLog(string value)\n        {\n            _loggerProc?.Invoke(value);\n        }\n\n        private void CheckAlreadyBuilt()\n        {\n            if (_state == DotEnvEngineState.Built)\n            {\n                throw new Exception(\"DotEnv Engine Already Built\");\n            }\n        }\n\n        private void PopulateDictionary(Dictionary<string, string> envDict, string envFilePath)\n        {\n            if (!File.Exists(envFilePath))\n            {\n                DoLog($\"Missed file {envFilePath}\");\n                return;\n            }\n\n            string dotenvCode = File.ReadAllText(envFilePath);\n            DotEnvParser.Parse(envDict, dotenvCode);\n            DoLog($\"Applied file {envFilePath}\");\n        }\n\n        private void ReadEnvFile()\n        {\n            if (!_skipDefaultEnv)\n            {\n                PopulateDictionary(_envDict, Path.Combine(_envPath, \".env\"));\n            }\n            foreach (var profile in _profiles)\n            {\n                string profileEnvPath = Path.Combine(_envPath, $\".env.{profile}\");\n                PopulateDictionary(_envDict, profileEnvPath);\n            }\n        }\n\n        private string ExplodePlaceholders(string value)\n        {\n            string result = value;\n            while (result.Contains(\"${\"))\n            {\n                int startPos = result.IndexOf(\"${\", StringComparison.Ordinal);\n                int endPos = result.IndexOf(\"}\", startPos, StringComparison.Ordinal);\n                if (endPos == -1 || endPos < startPos)\n                {\n                    throw new DotEnvException(\"Unclosed expansion (${...}) at: \" + value);\n                }\n                string key = result.Substring(startPos + 2, endPos - (startPos + 2));\n\n                string replacement = \"\";\n                if (key.StartsWith(\"__\") && key.EndsWith(\"__\"))\n                {\n                    if (!GetBuiltInVariable(key, out replacement))\n                    {\n                        replacement = Env(key);\n                    }\n                }\n                else\n                {\n                    replacement = Env(key);\n                }\n                result = result.Replace($\"${{{key}}}\", replacement);\n            }\n            return result;\n        }\n\n        private void ExplodeReferences()\n        {\n            foreach (var key in _envDict.Keys.ToList())\n            {\n                _envDict[key] = ExplodePlaceholders(_envDict[key]);\n            }\n        }\n\n        private bool GetBuiltInVariable(string varName, out string value)\n        {\n            string lVarName = varName.ToLower(); \n            if (lVarName == \"__os__\")\n            {\n                value = System.Runtime.InteropServices.RuntimeInformation.OSDescription;\n                return true;\n            }\n            if (lVarName == \"__home__\")\n            {\n                value = AppPath();\n                return true;\n            }\n            if (lVarName == \"__dmvc.version__\")\n            {\n                value = DMVCFRAMEWORK_VERSION();\n                return true;\n            }\n            DoLog(\"Unknown built-in env var named \" + lVarName + \".\");\n            value = \"\";\n            return false;\n        }\n\n        private string AppPath()\n        {\n            return _envPath;\n        }\n\n        private string DMVCFRAMEWORK_VERSION()\n        {\n            return \"6.0.0\";\n        }\n\n        private string GetDotEnvVar(string key)\n        {\n            _envDict.TryGetValue(key, out string val);\n            return val ?? \"\";\n        }\n\n        #endregion\n\n        #region IMVCDotEnv Implementation\n\n        public string Env(string name)\n        {\n            if (_state == DotEnvEngineState.Created)\n            {\n                throw new DotEnvException(\"dotEnv Engine not built\");\n            }\n\n            string result = \"\";\n            if (_priority == DotEnvPriority.FileThenEnv || _priority == DotEnvPriority.OnlyFile)\n            {\n                result = GetDotEnvVar(name);\n                if (result.Contains($\"${{{name}}}\"))\n                {\n                    throw new DotEnvException($\"Configuration loop detected with key \\\"{name}\\\"\");\n                }\n                if (_priority == DotEnvPriority.OnlyFile)\n                {\n                    return result;\n                }\n                if (string.IsNullOrEmpty(result))\n                {\n                    result = ExplodePlaceholders(Environment.GetEnvironmentVariable(name) ?? \"\");\n                    return result;\n                }\n                return result;\n            }\n            else if (_priority == DotEnvPriority.EnvThenFile || _priority == DotEnvPriority.OnlyEnv)\n            {\n                result = ExplodePlaceholders(Environment.GetEnvironmentVariable(name) ?? \"\");\n                if (_priority == DotEnvPriority.OnlyEnv)\n                {\n                    return result;\n                }\n                if (string.IsNullOrEmpty(result))\n                {\n                    string tmp = GetDotEnvVar(name);\n                    if (tmp.Contains($\"${{{name}}}\"))\n                    {\n                        throw new DotEnvException($\"Configuration loop detected with key \\\"{name}\\\"\");\n                    }\n                    return tmp;\n                }\n                return result;\n            }\n            else\n            {\n                throw new DotEnvException($\"Unknown dotEnv Priority: {_priority}\");\n            }\n        }\n\n        public string Env(string name, string defaultValue)\n        {\n            string val = Env(name);\n            return string.IsNullOrEmpty(val) ? defaultValue : val;\n        }\n\n        public int Env(string name, int defaultValue)\n        {\n            string val = Env(name);\n            if (string.IsNullOrEmpty(val))\n                return defaultValue;\n            if (!int.TryParse(val.Trim(), out int result))\n            {\n                throw new DotEnvException($\"Env \\\"{name}\\\" is not a valid integer [Current Value: \\\"{val}\\\"]\");\n            }\n            return result;\n        }\n\n        public bool Env(string name, bool defaultValue)\n        {\n            string val = Env(name);\n            if (string.IsNullOrEmpty(val))\n                return defaultValue;\n            val = val.Trim().ToLower();\n            if (val == \"yes\" || val == \"1\" || val == \"true\")\n                return true;\n            if (val == \"no\" || val == \"0\" || val == \"false\")\n                return false;\n            if (!bool.TryParse(val, out bool result))\n            {\n                throw new DotEnvException($\"Env \\\"{name}\\\" is not a valid boolean [Current Value: \\\"{val}\\\"]\");\n            }\n            return result;\n        }\n\n        public void RequireKeys(string[] keys)\n        {\n            if (keys == null || keys.Length == 0) return;\n            DoLog(\"Checking required keys: \" + string.Join(\", \", keys));\n            List<string> notFoundKeys = new List<string>();\n            foreach (var key in keys)\n            {\n                if (string.IsNullOrEmpty(Env(key)))\n                    notFoundKeys.Add(key);\n            }\n            if (notFoundKeys.Any())\n            {\n                string msg = \"Required keys not found: \" + string.Join(\", \", notFoundKeys);\n                DoLog(msg);\n                throw new DotEnvException(msg);\n            }\n        }\n\n        public IMVCDotEnv SaveToFile(string fileName)\n        {\n            var keys = _envDict.Keys.ToList();\n            keys.Sort(StringComparer.OrdinalIgnoreCase);\n            StringBuilder sb = new StringBuilder();\n            foreach (var key in keys)\n            {\n                sb.AppendLine($\"{key}={GetDotEnvVar(key)}\");\n            }\n            File.WriteAllText(fileName, sb.ToString());\n            return this;\n        }\n\n        public string[] ToArray()\n        {\n            var keys = _envDict.Keys.ToList();\n            keys.Sort(StringComparer.OrdinalIgnoreCase);\n            return keys.Select(key => $\"{key}={GetDotEnvVar(key)}\").ToArray();\n        }\n\n        #endregion\n\n        #region IMVCDotEnvBuilder Implementation\n\n        public IMVCDotEnvBuilder UseStrategy(DotEnvPriority strategy = DotEnvPriority.EnvThenFile)\n        {\n            CheckAlreadyBuilt();\n            _priority = strategy;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder SkipDefaultEnv()\n        {\n            _skipDefaultEnv = true;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseLogger(Action<string> logger)\n        {\n            if (_loggerProc != null)\n                throw new DotEnvException(\"Logger already set\");\n            _loggerProc = logger;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseProfile(string profileName)\n        {\n            CheckAlreadyBuilt();\n            _profiles.Add(profileName);\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseProfile(Func<string> profileDelegate)\n        {\n            CheckAlreadyBuilt();\n            _profiles.Add(profileDelegate());\n            return this;\n        }\n\n        public IMVCDotEnvBuilder ClearProfiles()\n        {\n            CheckAlreadyBuilt();\n            _profiles.Clear();\n            return this;\n        }\n\n        public IMVCDotEnv Build(string dotEnvDirectory = \"\")\n        {\n            if (_state != DotEnvEngineState.Created)\n            {\n                throw new DotEnvException(\"dotEnv engine already built\");\n            }\n            _state = DotEnvEngineState.Building;\n            _envPath = string.IsNullOrEmpty(dotEnvDirectory)\n                ? _envPath\n                : Path.Combine(_envPath, dotEnvDirectory);\n            DoLog(\"Path = \" + _envPath);\n            _envDict.Clear();\n\n            List<string> allProfiles = new List<string> { \"default\" };\n            allProfiles.AddRange(_profiles);\n            if (_skipDefaultEnv && allProfiles.Count > 0)\n            {\n                allProfiles.RemoveAt(0);\n            }\n            DoLog(\"Active profile/s priority = [\" + string.Join(\",\", allProfiles) +\n                $\"] (Priority: {_priority})\");\n            ReadEnvFile();\n            ExplodeReferences();\n            _state = DotEnvEngineState.Built;\n            return this;\n        }\n\n        #endregion\n\n    }\n\n    #endregion\n\n    #region Simple DotEnv Parser\n\n    public static class DotEnvParser\n    {\n        public static void Parse(Dictionary<string, string> envDict, string dotenvCode)\n        {\n            if (string.IsNullOrWhiteSpace(dotenvCode))\n                return;\n            var lines = dotenvCode.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries);\n            foreach (var line in lines)\n            {\n                string trimmed = line.Trim();\n                if (trimmed.StartsWith(\"#\") || string.IsNullOrEmpty(trimmed))\n                    continue;\n                int idx = trimmed.IndexOf('=');\n                if (idx > 0)\n                {\n                    string key = trimmed.Substring(0, idx).Trim();\n                    string value = trimmed.Substring(idx + 1).Trim();\n                    if ((value.StartsWith(\"\\\"\") && value.EndsWith(\"\\\"\")) ||\n                        (value.StartsWith(\"'\") && value.EndsWith(\"'\")))\n                    {\n                        value = value.Substring(1, value.Length - 2);\n                    }\n                    envDict[key] = value;\n                }\n            }\n        }\n    }\n\n    #endregion\n}"}
{"input": "unit BaseControllerU;\n\ninterface\n\nuses\n  MVCFramework, BaseDataModuleU, FireDAC.Comp.Client, MVCFramework.Serializer.Commons;\n\ntype\n  TBaseController = class(TMVCController)\n  private\n    FCommon: TBaseDataModule;\n\n  public\n    procedure OnBeforeAction(Context: TWebContext; const AActionNAme: string; var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionNAme: string); override;\n    function Connection: TFDConnection;\n    function CommonModule: TBaseDataModule;\n\n    // function CreateQuery(const SQL: String; Obj: TObject = nil): TFDQuery;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nfunction TBaseController.CommonModule: TBaseDataModule;\nbegin\n  if not Assigned(FCommon) then\n    FCommon := TBaseDataModule.Create(nil);\n  Result := FCommon;\nend;\n\nfunction TBaseController.Connection: TFDConnection;\nbegin\n  Result := CommonModule.Conn;\nend;\n\n// function TBaseController.CreateQuery(const SQL: String; Obj: TObject): TFDQuery;\n// var\n// qry: TFDQuery;\n// begin\n// qry := TFDQuery.Create(nil);\n// try\n// qry.Connection := Connection;\n// qry.SQL.Text := SQL;\n// qry.Prepare;\n// if Assigned(Obj) then\n// Mapper.ObjectToFDParameters(qry.Params, Obj);\n// Result := qry;\n// except\n// FreeAndNil(qry);\n// raise;\n// end;\n// end;\n\nprocedure TBaseController.OnAfterAction(Context: TWebContext; const AActionNAme: string);\nbegin\n  inherited;\n  FreeAndNil(FCommon);\nend;\n\nprocedure TBaseController.OnBeforeAction(Context: TWebContext; const AActionNAme: string; var Handled: Boolean);\nbegin\n  inherited;\n\nend;\n\nend.", "output": "using System;\nusing System.Data.Common;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace BaseControllerU\n{    public class BaseDataModule : IDisposable\n    {\n        public DbConnection Conn { get; private set; }\n\n        public BaseDataModule()\n        {\n            \n            Conn = null; \n        }\n\n        public void Dispose()\n        {\n            if (Conn != null)\n            {\n                Conn.Dispose();\n                Conn = null;\n            }\n        }\n    }\n\n    \n    public class BaseController : Controller\n    {\n        private BaseDataModule _common;\n\n        \n        protected BaseDataModule CommonModule()\n        {\n            if (_common == null)\n            {\n                _common = new BaseDataModule();\n            }\n            return _common;\n        }\n\n        \n        protected DbConnection Connection()\n        {\n            return CommonModule().Conn;\n        }\n\n        \n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            base.OnActionExecuting(context);\n            \n        }\n\n        \n        public override void OnActionExecuted(ActionExecutedContext context)\n        {\n            base.OnActionExecuted(context);\n            \n            if (_common != null)\n            {\n                _common.Dispose();\n                _common = null;\n            }\n        }\n\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.JWT;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.JWT,\n  JsonDataObjects,\n  MVCFramework.HMAC,\n  Web.HTTPApp;\n\ntype\n  TMVCJWTDefaults = class sealed\n  public const\n    /// <summary>\n    /// Default authorization header name (RFC 6750)\n    /// </summary>\n    AUTHORIZATION_HEADER = 'Authorization';\n    /// <summary>\n    /// Default username header name\n    /// </summary>\n    USERNAME_HEADER = 'jwtusername';\n    /// <summary>\n    /// Default password header name\n    /// </summary>\n    PASSWORD_HEADER = 'jwtpassword';\n    /// <summary>\n    /// Default AUTH schema\n    /// </summary>\n    AUTH_SCHEMA = 'Bearer';\n    /// <summary>\n    /// Default url authorization token\n    /// </summary>\n    AUTHORIZATION_ACCESS_TOKEN = 'access_token';\n  end;\n\n  TJWTClaimsSetup = reference to procedure(const JWT: TJWT);\n\n  TMVCJWTAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FClaimsToChecks: TJWTCheckableClaims;\n    FSetupJWTClaims: TJWTClaimsSetup;\n    FSecret: string;\n    FLeewaySeconds: Cardinal;\n    FLoginURLSegment: string;\n    FAuthorizationHeaderName: string;\n    FAuthorizationAccessToken: string;\n    FUserNameHeaderName: string;\n    FPasswordHeaderName: string;\n    FHMACAlgorithm: String;\n    FUseHttpOnly: Boolean;\n    FTokenHttpOnlyExpires: TDateTime;\n    FLogoffURLSegment: string;\n    procedure SendLogoffRender(AContext: TWebContext);\n  protected\n    function NeedsToBeExtended(const JWTValue: TJWT): Boolean;\n    procedure ExtendExpirationTime(const JWTValue: TJWT);\n    procedure InternalRender(AJSONOb: TJDOJsonObject; AContentType: string; AContentEncoding: string;\n      AContext: TWebContext; AInstanceOwner: Boolean = True); virtual;\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean); virtual;\n    procedure OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName: string;\n      const AActionName: string; var AHandled: Boolean); virtual;\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean); virtual;\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean); virtual;\n  public\n    constructor Create(AAuthenticationHandler: IMVCAuthenticationHandler;\n      AConfigClaims: TJWTClaimsSetup;\n      ASecret: string = 'D3lph1MVCFram3w0rk';\n      ALoginURLSegment: string = '/login';\n      AClaimsToCheck: TJWTCheckableClaims = [];\n      ALeewaySeconds: Cardinal = 300;\n      AHMACAlgorithm: String = HMAC_HS512); overload; virtual;\n    constructor Create(AAuthenticationHandler: IMVCAuthenticationHandler;\n      AConfigClaims: TJWTClaimsSetup;\n      AUseHttpOnly: Boolean;\n      ALogoffURLSegment: string = '/logoff';\n      ASecret: string = 'D3lph1MVCFram3w0rk';\n      ALoginURLSegment: string = '/login';\n      AClaimsToCheck: TJWTCheckableClaims = [];\n      ALeewaySeconds: Cardinal = 300;\n      AHMACAlgorithm: String = HMAC_HS512); overload; virtual;\n    property AuthorizationHeaderName: string read FAuthorizationHeaderName;\n    property UserNameHeaderName: string read FUserNameHeaderName;\n    property PasswordHeaderName: string read FPasswordHeaderName;\n  end;\n\n  TMVCOnAcceptTokenProc = reference to procedure(AContext: TWebContext; AJWTToken: String;\n    var AAccepted: Boolean);\n  TMVCOnNewJWTToBlackList = reference to procedure(AContext: TWebContext; AJWTToken: String);\n\n  TMVCJWTBlackListMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fOnAcceptToken: TMVCOnAcceptTokenProc;\n    fOnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n    fBlackListRequestURLSegment: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      );\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(\n      AContext: TWebContext;\n      const AHandled: Boolean\n      );\n  public\n    constructor Create(\n      OnAcceptToken: TMVCOnAcceptTokenProc;\n      OnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n      BlackListRequestURLSegment: string = '/logout');\n  end;\n\n\nimplementation\n\nuses\n  System.NetEncoding,\n  System.DateUtils,\n  System.Math,\n  MVCFramework.Logger;\n\n{ TMVCJWTAuthenticationMiddleware }\n\nconstructor TMVCJWTAuthenticationMiddleware.Create(\n  AAuthenticationHandler: IMVCAuthenticationHandler;\n  AConfigClaims: TJWTClaimsSetup;\n  ASecret, ALoginURLSegment: string;\n  AClaimsToCheck: TJWTCheckableClaims;\n  ALeewaySeconds: Cardinal;\n  AHMACAlgorithm: String\n  );\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FSetupJWTClaims := AConfigClaims;\n  FClaimsToChecks := AClaimsToCheck;\n  FSecret := ASecret;\n  FLoginURLSegment := ALoginURLSegment;\n  FLeewaySeconds := ALeewaySeconds;\n  FAuthorizationHeaderName := TMVCJWTDefaults.AUTHORIZATION_HEADER;\n  FAuthorizationAccessToken := TMVCJWTDefaults.AUTHORIZATION_ACCESS_TOKEN;\n  FUserNameHeaderName := TMVCJWTDefaults.USERNAME_HEADER;\n  FPasswordHeaderName := TMVCJWTDefaults.PASSWORD_HEADER;\n  FHMACAlgorithm := AHMACAlgorithm;\n  FUseHttpOnly := False;\n  FTokenHttpOnlyExpires := Now;\nend;\n\nconstructor TMVCJWTAuthenticationMiddleware.Create(AAuthenticationHandler: IMVCAuthenticationHandler; AConfigClaims: TJWTClaimsSetup; AUseHttpOnly: Boolean; ALogoffURLSegment: string;\n  ASecret, ALoginURLSegment: string; AClaimsToCheck: TJWTCheckableClaims; ALeewaySeconds: Cardinal; AHMACAlgorithm: String);\nbegin\n  Create(AAuthenticationHandler, AConfigClaims, ASecret, ALoginURLSegment, AClaimsToCheck, ALeewaySeconds, AHMACAlgorithm);\n  FUseHttpOnly := AUseHttpOnly;\n  FLogoffURLSegment := ALogoffURLSegment;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.ExtendExpirationTime(const JWTValue: TJWT);\nbegin\n  JWTValue.Claims.ExpirationTime := Max(JWTValue.Claims.ExpirationTime, Now) +\n    (JWTValue.LeewaySeconds + JWTValue.LiveValidityWindowInSeconds) * OneSecond;\n  if FUseHttpOnly then\n  begin\n    FTokenHttpOnlyExpires := JWTValue.Claims.ExpirationTime;\n  end;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.InternalRender(AJSONOb: TJDOJsonObject;\n  AContentType, AContentEncoding: string; AContext: TWebContext; AInstanceOwner: Boolean);\nvar\n  Encoding: TEncoding;\n  ContentType, JValue: string;\n  Cookie: TCookie;\nbegin\n  JValue := AJSONOb.ToJSON;\n\n  if FUseHttpOnly then\n  begin\n    Cookie := AContext.Response.Cookies.Add;\n    Cookie.Expires := FTokenHttpOnlyExpires;\n    Cookie.Path := '/';\n    Cookie.Name := 'token';\n    Cookie.Value := AJSONOb.S['token'];\n    Cookie.HttpOnly := True;\n    // Cookie.Secure := True;\n    // Cookie.SameSite := 'none';\n  end;\n\n  AContext.Response.RawWebResponse.ContentType := AContentType + '; charset=' + AContentEncoding;\n  ContentType := AContentType + '; charset=' + AContentEncoding;\n\n  Encoding := TEncoding.GetEncoding(AContentEncoding);\n  try\n    AContext.Response.SetContentStream(TBytesStream.Create(TEncoding.Convert(TEncoding.Default, Encoding,\n      TEncoding.Default.GetBytes(JValue))), ContentType);\n  finally\n    Encoding.Free;\n  end;\n\n  if AInstanceOwner then\n    FreeAndNil(AJSONOb)\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.SendLogoffRender(AContext: TWebContext);\nconst\n  returnMessage = '{ \"message\": \"Successful logout\" }';\n  ContentType = 'application/json; charset=UTF-8';\n  AContentEncoding = 'UTF-8';\nvar\n  Encoding: TEncoding;\n  Cookie: TCookie;\nbegin\n  Cookie := AContext.Response.Cookies.Add;\n  Cookie.Name := 'token';\n  Cookie.Path := '/';\n\n  Encoding := TEncoding.GetEncoding(AContentEncoding);\n  try\n    AContext.Response.SetContentStream(TBytesStream.Create(TEncoding.Convert(TEncoding.Default, Encoding, TEncoding.Default.GetBytes(returnMessage))), ContentType);\n  finally\n    Encoding.Free;\n  end;\nend;\n\nfunction TMVCJWTAuthenticationMiddleware.NeedsToBeExtended(const JWTValue: TJWT): Boolean;\nvar\n  lWillExpireIn: Int64;\nbegin\n  lWillExpireIn := SecondsBetween(Now, JWTValue.Claims.ExpirationTime);\n  Result := lWillExpireIn <= JWTValue.LiveValidityWindowInSeconds;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnBeforeControllerAction(AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string; var AHandled: Boolean);\nvar\n  AuthRequired: Boolean;\n  IsAuthorized: Boolean;\n  JWTValue: TJWT;\n  AuthHeader: string;\n  AuthAccessToken: string;\n  AuthToken: string;\n  ErrorMsg: string;\n  CookieToken: string;\nbegin\n  // check if the resource is protected\n  if Assigned(FAuthenticationHandler) then\n  begin\n    FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n    if not AuthRequired then\n    begin\n      AHandled := False;\n      { this section handles the case when the authenticated user (with a token) need to call an action which doesn't require\n        authentication. To make Context.LoggerdUser.IsValid works we need to load the JWT if present. In such way\n        the \"public\" action can distriminate is has been called by a not-authnticated user or an authenticated user.\n        If there isn't a token, we don't have to raise exceptions, just make sure that the LoggedUser doesn't contain\n        information.\n      }\n      // retrieve the token from the \"authentication Bearer\" header\n      AuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n      if AuthHeader.IsEmpty then\n        // retrieve the token from the \"access_token\" query param\n        AuthHeader := AContext.Request.Params[FAuthorizationAccessToken];\n\n      if not AuthHeader.IsEmpty then\n      begin\n        { load and verify token even for an action that doesn't require it }\n        JWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n        try\n          JWTValue.RegClaimsToChecks := Self.FClaimsToChecks;\n\n          // retrieve the token from the \"authentication Bearer\" header\n          AuthToken := '';\n          if AuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n          begin\n            AuthToken := AuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n            AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n          end;\n\n          if JWTValue.LoadToken(AuthToken, ErrorMsg) then\n          begin\n            { load token info only if the token is still valid }\n            AContext.LoggedUser.UserName := JWTValue.CustomClaims['username'];\n            AContext.LoggedUser.Roles.AddRange(JWTValue.CustomClaims['roles'].Split([',']));\n            AContext.LoggedUser.LoggedSince := JWTValue.Claims.IssuedAt;\n            AContext.LoggedUser.CustomData := JWTValue.CustomClaims.AsCustomData;\n          end;\n        finally\n          JWTValue.Free;\n        end;\n      end;\n      Exit;\n    end;\n  end;\n\n  // Checking token in subsequent requests\n  // ***************************************************\n  JWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n  try\n    JWTValue.RegClaimsToChecks := Self.FClaimsToChecks;\n    // retrieve the token from the \"authentication Bearer\" header\n    AuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n    if (not AuthHeader.IsEmpty) then\n    begin\n      AuthToken := '';\n      if AuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n      begin\n        AuthToken := AuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n        AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n      end;\n    end\n    else\n    begin\n      // retrieve the token from the \"access_token\" query param\n      AuthAccessToken := AContext.Request.Params[FAuthorizationAccessToken];\n      if (not AuthAccessToken.IsEmpty) then\n      begin\n        AuthToken := AuthAccessToken.Trim;\n        AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n      end\n      else\n      begin\n        if FUseHttpOnly then\n        begin\n          CookieToken := AContext.Request.Cookie('token');\n          if (not CookieToken.IsEmpty) then\n          begin\n            AuthToken := CookieToken.Trim;\n            AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n          end;\n        end;\n      end;\n    end;\n\n    if AuthToken.IsEmpty then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Authorization Required');\n    if not JWTValue.LoadToken(AuthToken, ErrorMsg) then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, ErrorMsg);\n\n    if JWTValue.CustomClaims['username'].IsEmpty then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid Token, Authorization Required');\n\n    AContext.LoggedUser.UserName := JWTValue.CustomClaims['username'];\n    AContext.LoggedUser.Roles.AddRange(JWTValue.CustomClaims['roles'].Split([',']));\n    AContext.LoggedUser.LoggedSince := JWTValue.Claims.IssuedAt;\n    AContext.LoggedUser.CustomData := JWTValue.CustomClaims.AsCustomData;\n\n    if Assigned(FAuthenticationHandler) then\n    begin\n      FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n        AActionName, IsAuthorized);\n      if not IsAuthorized then\n        raise EMVCJWTException.Create(HTTP_STATUS.Forbidden, 'Authorization Forbidden');\n    end;\n\n    if JWTValue.LiveValidityWindowInSeconds > 0 then\n    begin\n      if NeedsToBeExtended(JWTValue) then\n      begin\n        ExtendExpirationTime(JWTValue);\n        AContext.Response.SetCustomHeader(FAuthorizationHeaderName, 'Bearer ' + JWTValue.GetToken);\n      end;\n    end;\n\n    AHandled := False;\n  finally\n    JWTValue.Free;\n  end;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  LUsername: string;\n  LPassword: string;\n  LBasicAuthHeader: string;\n  LBasicAuthParts: TArray<string>;\n  LRolesList: TList<string>;\n  LSessionData: TSessionData;\n  LIsValid: Boolean;\n  LJWTValue: TJWT;\n  LCustomPair: TPair<string, string>;\n  LJsonObject: TJDOJsonObject;\n  lJObj: TJsonObject;\nbegin\n  if SameText(AContext.Request.PathInfo, FLoginURLSegment) then\n  begin\n    LBasicAuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n    if LBasicAuthHeader.IsEmpty then\n    begin\n      // read from headers\n      LUsername := TNetEncoding.URL.Decode(AContext.Request.Headers[FUserNameHeaderName]);\n      LPassword := TNetEncoding.URL.Decode(AContext.Request.Headers[FPasswordHeaderName]);\n\n      // read from content\n      if LUsername.IsEmpty and not SameText(AContext.Request.ContentMediaType, TMVCMediaType.APPLICATION_JSON) then\n      begin\n        LUsername := AContext.Request.ContentParam(FUserNameHeaderName);\n        LPassword := AContext.Request.ContentParam(FPasswordHeaderName);\n      end;\n\n      // read from json content\n      if LUsername.IsEmpty then\n      begin\n        lJObj := StrToJSONObject(AContext.Request.Body, False);\n        try\n          if Assigned(lJObj) then\n          begin\n            LUsername := lJObj.S[FUserNameHeaderName];\n            LPassword := lJObj.S[FPasswordHeaderName];\n            if LUsername.IsEmpty then\n            begin\n              LUsername := lJObj.S['username'];\n              LPassword := lJObj.S['password'];\n            end;\n          end;\n        finally\n          lJObj.Free;\n        end;\n      end;\n\n      if (LUsername.IsEmpty) or (LPassword.IsEmpty) then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Username and password required');\n    end\n    else\n    begin\n      if not LBasicAuthHeader.StartsWith('basic', True) then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid authorization type');\n\n      LBasicAuthHeader := LBasicAuthHeader.Remove(0, 'basic'.Length).Trim;\n      LBasicAuthParts := TBase64Encoding.Base64.Decode(LBasicAuthHeader).Split([':']);\n\n      if Length(LBasicAuthParts) <> 2 then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid authorization type');\n\n      LUsername := LBasicAuthParts[0];\n      LPassword := LBasicAuthParts[1];\n    end;\n\n    // check the authorization for the requested resource\n    LRolesList := TList<string>.Create;\n    try\n      LSessionData := TSessionData.Create;\n      try\n        if Assigned(FAuthenticationHandler) then\n        begin\n          FAuthenticationHandler.OnAuthentication(AContext, LUsername, LPassword, LRolesList, LIsValid, LSessionData);\n          if not LIsValid then\n            raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Unauthorized');\n        end;\n\n        LJWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n        try\n          // let's user config claims and custom claims\n          if not Assigned(FSetupJWTClaims) then\n            raise EMVCJWTException.Create('SetupJWTClaims not set');\n          LJWTValue.Data := AContext.Request;\n          FSetupJWTClaims(LJWTValue);\n\n          if FUseHttpOnly then\n          begin\n            FTokenHttpOnlyExpires := LJWTValue.Claims.ExpirationTime;\n          end;\n\n          // these claims are mandatory and managed by the middleware\n          if not LJWTValue.CustomClaims['username'].IsEmpty then\n            raise EMVCJWTException.Create\n              ('Custom claim \"username\" is reserved and cannot be modified in the JWT setup');\n\n          if not LJWTValue.CustomClaims['roles'].IsEmpty then\n            raise EMVCJWTException.Create('Custom claim \"roles\" is reserved and cannot be modified in the JWT setup');\n\n          LJWTValue.CustomClaims['username'] := LUsername;\n          LJWTValue.CustomClaims['roles'] := string.Join(',', LRolesList.ToArray);\n\n          if LJWTValue.LiveValidityWindowInSeconds > 0 then\n            if NeedsToBeExtended(LJWTValue) then\n              ExtendExpirationTime(LJWTValue);\n\n          // setup the current logged user from the JWT\n          AContext.LoggedUser.Roles.AddRange(LRolesList);\n          AContext.LoggedUser.UserName := LJWTValue.CustomClaims['username'];\n          AContext.LoggedUser.LoggedSince := LJWTValue.Claims.IssuedAt;\n          AContext.LoggedUser.Realm := LJWTValue.Claims.Subject;\n\n          if LSessionData.Count > 0 then\n          begin\n            AContext.LoggedUser.CustomData := TMVCCustomData.Create;\n            for LCustomPair in LSessionData do\n            begin\n              AContext.LoggedUser.CustomData.AddOrSetValue(LCustomPair.Key, LCustomPair.Value);\n              if not LJWTValue.CustomClaims.Items[LCustomPair.Key].IsEmpty then\n                raise EMVCJWTException.CreateFmt('JWT Error: \"%s\" is a reserved key name', [LCustomPair.Key]);\n              LJWTValue.CustomClaims.Items[LCustomPair.Key] := LCustomPair.Value;\n            end;\n          end;\n\n          LJsonObject := TJDOJsonObject.Create;\n          try\n            LJsonObject.S['token'] := LJWTValue.GetToken;\n            InternalRender(LJsonObject, TMVCMediaType.APPLICATION_JSON, TMVCConstants.DEFAULT_CONTENT_CHARSET,\n              AContext, False);\n          finally\n            LJsonObject.Free;\n          end;\n          AHandled := True;\n        finally\n          LJWTValue.Free;\n        end;\n      finally\n        LSessionData.Free;\n      end;\n    finally\n      LRolesList.Free;\n    end;\n  end\n  else\n  begin\n    if SameText(AContext.Request.PathInfo, FLogoffURLSegment) and (FUseHttpOnly) then\n    begin\n      SendLogoffRender(AContext);\n      AHandled := True;\n    end;\n  end;\nend;\n\n\nconstructor TMVCJWTBlackListMiddleware.Create(\n  OnAcceptToken: TMVCOnAcceptTokenProc;\n  OnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n  BlackListRequestURLSegment: string = '/logout');\nbegin\n  inherited Create;\n  fOnAcceptToken := OnAcceptToken;\n  fOnNewJWTToBlackList := OnNewJWTToBlackList;\n  fBlackListRequestURLSegment := BlackListRequestURLSegment;\n  Assert(Assigned(fOnAcceptToken));\n  Assert(not fBlackListRequestURLSegment.IsEmpty);\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  lAuthHeader: string;\n  lAuthToken: string;\n  lAccepted: Boolean;\nbegin\n  lAuthToken := '';\n  lAuthHeader := AContext.Request.Headers[TMVCJWTDefaults.AUTHORIZATION_HEADER];\n  if not lAuthHeader.IsEmpty then\n  begin\n    // retrieve the token from the \"authentication Bearer\" header\n    if lAuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n    begin\n      lAuthToken := lAuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n      lAuthToken := Trim(TNetEncoding.URL.Decode(lAuthToken));\n    end;\n  end;\n\n  if SameText(AContext.Request.PathInfo, fBlackListRequestURLSegment) then\n  begin\n    // add the token in the blacklist\n    if lAuthToken.IsEmpty then\n    begin\n      raise EMVCException.Create(HTTP_STATUS.BadRequest,\n        'JWTToken required - cannot blacklist an unknown token');\n    end;\n    fOnNewJWTToBlackList(AContext, lAuthToken);\n    AContext.Response.StatusCode := HTTP_STATUS.NoContent;\n    AHandled := True;\n  end\n  else\n  begin\n    // just check if token is blacklisted.\n    // if the token is not available, just ignore the check\n    // remember, here jwtmiddleware already did its job.\n    if lAuthToken.IsEmpty then\n    begin\n      AHandled := False;\n    end\n    else\n    begin\n      lAccepted := True;\n      fOnAcceptToken(AContext, lAuthToken, lAccepted);\n      if not lAccepted then\n      begin\n        raise EMVCJWTException.Create(HTTP_STATUS.Forbidden, 'JWT not accepted');\n      end;\n    end;\n  end;\nend;\n\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.IO;\nusing Newtonsoft.Json.Linq; \nusing MVCFramework;         \nusing MVCFramework.Commons;  \nusing MVCFramework.JWT;      \nusing MVCFramework.HMAC;     \n\nnamespace MVCFramework.Middleware.JWT\n{\n    \n    public static class MVCJWTDefaults\n    {\n        public const string AUTHORIZATION_HEADER = \"Authorization\";\n        public const string USERNAME_HEADER = \"jwtusername\";\n        public const string PASSWORD_HEADER = \"jwtpassword\";\n        public const string AUTH_SCHEMA = \"Bearer\";\n        public const string AUTHORIZATION_ACCESS_TOKEN = \"access_token\";\n    }\n\n    \n    public delegate void JWTClaimsSetup(JWT jwt);\n\n    \n    public class MVCJWTAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly JWTCheckableClaims _claimsToCheck;\n        private readonly JWTClaimsSetup _setupJWTClaims;\n        private readonly string _secret;\n        private readonly uint _leewaySeconds;\n        private readonly string _loginURLSegment;\n        private readonly string _authorizationHeaderName;\n        private readonly string _authorizationAccessToken;\n        private readonly string _userNameHeaderName;\n        private readonly string _passwordHeaderName;\n        private readonly string _hmacAlgorithm;\n        private readonly bool _useHttpOnly;\n        private DateTime _tokenHttpOnlyExpires;\n        private readonly string _logoffURLSegment;\n\n        #region Constructors\n\n        public MVCJWTAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            JWTClaimsSetup configClaims,\n            string secret = \"D3lph1MVCFram3w0rk\",\n            string loginURLSegment = \"/login\",\n            JWTCheckableClaims claimsToCheck = JWTCheckableClaims.None,\n            uint leewaySeconds = 300,\n            string hmacAlgorithm = HMAC_HS512)\n        {\n            _authenticationHandler = authenticationHandler;\n            _setupJWTClaims = configClaims;\n            _claimsToCheck = claimsToCheck;\n            _secret = secret;\n            _loginURLSegment = loginURLSegment;\n            _leewaySeconds = leewaySeconds;\n            _authorizationHeaderName = MVCJWTDefaults.AUTHORIZATION_HEADER;\n            _authorizationAccessToken = MVCJWTDefaults.AUTHORIZATION_ACCESS_TOKEN;\n            _userNameHeaderName = MVCJWTDefaults.USERNAME_HEADER;\n            _passwordHeaderName = MVCJWTDefaults.PASSWORD_HEADER;\n            _hmacAlgorithm = hmacAlgorithm;\n            _useHttpOnly = false;\n            _tokenHttpOnlyExpires = DateTime.Now;\n        }\n\n        public MVCJWTAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            JWTClaimsSetup configClaims,\n            bool useHttpOnly,\n            string logoffURLSegment = \"/logoff\",\n            string secret = \"D3lph1MVCFram3w0rk\",\n            string loginURLSegment = \"/login\",\n            JWTCheckableClaims claimsToCheck = JWTCheckableClaims.None,\n            uint leewaySeconds = 300,\n            string hmacAlgorithm = HMAC_HS512)\n            : this(authenticationHandler, configClaims, secret, loginURLSegment, claimsToCheck, leewaySeconds, hmacAlgorithm)\n        {\n            _useHttpOnly = useHttpOnly;\n            _logoffURLSegment = logoffURLSegment;\n        }\n\n        #endregion\n\n        #region Helper Methods\n\n        \n        protected bool NeedsToBeExtended(JWT jwt)\n        {\n            double secondsToExpire = (jwt.Claims.ExpirationTime - DateTime.Now).TotalSeconds;\n            return secondsToExpire <= jwt.LiveValidityWindowInSeconds;\n        }\n\n        \n        protected void ExtendExpirationTime(JWT jwt)\n        {\n            \n            jwt.Claims.ExpirationTime = Max(jwt.Claims.ExpirationTime, DateTime.Now)\n                .AddSeconds(jwt.LeewaySeconds + jwt.LiveValidityWindowInSeconds);\n            if (_useHttpOnly)\n            {\n                _tokenHttpOnlyExpires = jwt.Claims.ExpirationTime;\n            }\n        }\n\n        private DateTime Max(DateTime a, DateTime b)\n        {\n            return (a > b) ? a : b;\n        }\n\n        \n        protected void InternalRender(JObject jsonObj, string contentType, string contentEncoding, WebContext context, bool instanceOwner = true)\n        {\n            string jValue = jsonObj.ToString();\n\n            if (_useHttpOnly)\n            {\n                \n                context.Response.Cookies.Add(new Cookie(\"token\", jsonObj[\"token\"]?.ToString())\n                {\n                    Expires = _tokenHttpOnlyExpires,\n                    Path = \"/\",\n                    HttpOnly = true\n                });\n            }\n\n            context.Response.RawWebResponse.ContentType = $\"{contentType}; charset={contentEncoding}\";\n            Encoding encoding = Encoding.GetEncoding(contentEncoding);\n            byte[] bytes = encoding.GetBytes(jValue);\n            context.Response.SetContentStream(new MemoryStream(bytes), $\"{contentType}; charset={contentEncoding}\");\n        }\n\n        #endregion\n\n        #region IMVCMiddleware Members\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            // No routing logic needed for JWT middleware.\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            \n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                \n                string authHeader = context.Request.Headers[_authorizationHeaderName];\n                if (!string.IsNullOrEmpty(authHeader))\n                {\n                    JWT jwtTemp = new JWT(_secret, _leewaySeconds);\n                    try\n                    {\n                        jwtTemp.RegClaimsToChecks = _claimsToCheck;\n                        string token = \"\";\n                        if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                        {\n                            token = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                            token = WebUtility.UrlDecode(token);\n                        }\n                        if (jwtTemp.LoadToken(token, out string errorMsg))\n                        {\n                            context.LoggedUser.UserName = jwtTemp.CustomClaims[\"username\"];\n                            context.LoggedUser.Roles.AddRange(jwtTemp.CustomClaims[\"roles\"].Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries));\n                            context.LoggedUser.LoggedSince = jwtTemp.Claims.IssuedAt;\n                            context.LoggedUser.CustomData = jwtTemp.CustomClaims.AsCustomData;\n                        }\n                    }\n                    finally\n                    {\n                        jwtTemp.Dispose();\n                    }\n                }\n                return;\n            }\n\n            \n            using (JWT jwt = new JWT(_secret, _leewaySeconds))\n            {\n                jwt.RegClaimsToChecks = _claimsToCheck;\n                string authHeader = context.Request.Headers[_authorizationHeaderName];\n                string authToken = \"\";\n                if (!string.IsNullOrEmpty(authHeader))\n                {\n                    if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                    {\n                        authToken = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                        authToken = WebUtility.UrlDecode(authToken);\n                    }\n                }\n                else\n                {\n                    \n                    string queryToken = context.Request.Params[_authorizationAccessToken];\n                    if (!string.IsNullOrEmpty(queryToken))\n                    {\n                        authToken = queryToken.Trim();\n                        authToken = WebUtility.UrlDecode(authToken);\n                    }\n                    else if (_useHttpOnly)\n                    {\n                        \n                        string cookieToken = context.Request.Cookie(\"token\");\n                        if (!string.IsNullOrEmpty(cookieToken))\n                        {\n                            authToken = cookieToken.Trim();\n                            authToken = WebUtility.UrlDecode(authToken);\n                        }\n                    }\n                }\n                if (string.IsNullOrEmpty(authToken))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, \"Authorization Required\");\n\n                if (!jwt.LoadToken(authToken, out string errorMsg))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, errorMsg);\n\n                if (string.IsNullOrEmpty(jwt.CustomClaims[\"username\"]))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, \"Invalid Token, Authorization Required\");\n\n                context.LoggedUser.UserName = jwt.CustomClaims[\"username\"];\n                context.LoggedUser.Roles.AddRange(jwt.CustomClaims[\"roles\"].Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries));\n                context.LoggedUser.LoggedSince = jwt.Claims.IssuedAt;\n                context.LoggedUser.CustomData = jwt.CustomClaims.AsCustomData;\n\n                if (_authenticationHandler != null)\n                {\n                    _authenticationHandler.OnAuthorization(context, context.LoggedUser.Roles, controllerQualifiedClassName, actionName, out bool isAuthorized);\n                    if (!isAuthorized)\n                        throw new MVCJWTException(HTTP_STATUS.Forbidden, \"Authorization Forbidden\");\n                }\n\n                \n                if (jwt.LiveValidityWindowInSeconds > 0 && NeedsToBeExtended(jwt))\n                {\n                    ExtendExpirationTime(jwt);\n                    context.Response.SetCustomHeader(_authorizationHeaderName, \"Bearer \" + jwt.GetToken());\n                }\n                handled = false;\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement if any after-action logic is needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Implement if any after-routing logic is needed.\n        }\n\n        #endregion\n\n        #region Exposed Properties\n\n        public string AuthorizationHeaderName => _authorizationHeaderName;\n        public string UserNameHeaderName => _userNameHeaderName;\n        public string PasswordHeaderName => _passwordHeaderName;\n\n        #endregion\n    }\n\n    \n    public class MVCJWTBlackListMiddleware : IMVCMiddleware\n    {\n        private readonly Action<WebContext, string, ref bool> _onAcceptToken;\n        private readonly Action<WebContext, string> _onNewJWTToBlackList;\n        private readonly string _blackListRequestURLSegment;\n\n        public MVCJWTBlackListMiddleware(\n            Action<WebContext, string, ref bool> onAcceptToken,\n            Action<WebContext, string> onNewJWTToBlackList,\n            string blackListRequestURLSegment = \"/logout\")\n        {\n            _onAcceptToken = onAcceptToken ?? throw new ArgumentNullException(nameof(onAcceptToken));\n            _onNewJWTToBlackList = onNewJWTToBlackList;\n            _blackListRequestURLSegment = blackListRequestURLSegment;\n            if (string.IsNullOrWhiteSpace(_blackListRequestURLSegment))\n                throw new ArgumentException(\"BlackListRequestURLSegment cannot be empty\", nameof(blackListRequestURLSegment));\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            string authHeader = context.Request.Headers[MVCJWTDefaults.AUTHORIZATION_HEADER];\n            string authToken = \"\";\n            if (!string.IsNullOrEmpty(authHeader))\n            {\n                if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                {\n                    authToken = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                    authToken = WebUtility.UrlDecode(authToken);\n                }\n            }\n\n            if (string.Equals(context.Request.PathInfo, _blackListRequestURLSegment, StringComparison.OrdinalIgnoreCase))\n            {\n                if (string.IsNullOrEmpty(authToken))\n                    throw new Exception(\"JWTToken required - cannot blacklist an unknown token\");\n                _onNewJWTToBlackList(context, authToken);\n                context.Response.StatusCode = HTTP_STATUS.NoContent;\n                handled = true;\n            }\n            else\n            {\n                if (string.IsNullOrEmpty(authToken))\n                {\n                    handled = false;\n                }\n                else\n                {\n                    bool accepted = true;\n                    _onAcceptToken(context, authToken, ref accepted);\n                    if (!accepted)\n                        throw new MVCJWTException(HTTP_STATUS.Forbidden, \"JWT not accepted\");\n                }\n            }\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Implement as needed.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement as needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Implement as needed.\n        }\n    }\n}"}
{"input": "unit Services.InterfacesU;\n\ninterface\n\nuses Entities, System.Generics.Collections;\n\n\ntype\n  IPeopleService = interface\n    ['{347532A0-1B28-40C3-A2E9-51DF62365FE7}']\n    function GetAll: TObjectList<TPerson>;\n  end;\n\n  IConnectionService = interface\n    ['{146C21A5-07E8-456D-8E6D-A72820BD17AA}']\n    function GetConnectionName: String;\n  end;\n\nimplementation\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing Entities;\n\nnamespace Services.InterfacesU\n{\n    [Guid(\"347532A0-1B28-40C3-A2E9-51DF62365FE7\")]\n    public interface IPeopleService\n    {\n        IList<TPerson> GetAll();\n    }\n\n    [Guid(\"146C21A5-07E8-456D-8E6D-A72820BD17AA\")]\n    public interface IConnectionService\n    {\n        string GetConnectionName();\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Json.Schema.Common.Types;\n\ninterface\n\ntype\n  TSchemaKind = (skUnknown, skInteger, skInt64, skNumber, skDateTime, skDate, skTime, skEnumeration, skBoolean,\n     skObject, skArray, skString, skChar, skGuid);\n\n  ASchemaType = class(TCustomAttribute)\n  strict private\n    fKind: TSchemaKind;\n\n    const c_SchemaTypeBoolean = 'boolean';\n    const c_SchemaTypeInteger = 'integer';\n    const c_SchemaTypeNumber = 'number';\n    const c_SchemaTypeString = 'string';\n    const c_SchemaTypeArray = 'array';\n    const c_SchemaTypeObject = 'object';\n\n    function GetName: string;\n  public\n    constructor Create(const pKind: TSchemaKind);\n    property Name: string read GetName;\n    property Kind: TSchemaKind read fKind;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ ASchemaType }\n\nconstructor ASchemaType.Create(const pKind: TSchemaKind);\nbegin\n  inherited Create;\n  fKind := pKind;\nend;\n\nfunction ASchemaType.GetName: string;\nbegin\n  Result := EmptyStr;\n  case fKind of\n    skInteger, skInt64, skEnumeration: Result := c_SchemaTypeInteger;\n    skNumber: Result := c_SchemaTypeNumber;\n    skString, skChar, skGuid, skDateTime, skDate, skTime: Result := c_SchemaTypeString;\n    skBoolean: Result := c_SchemaTypeBoolean;\n    skObject: Result := c_SchemaTypeObject;\n    skArray: Result := c_SchemaTypeArray;\n  end;\nend;\n\nend.", "output": "using System;\n\nnamespace Json.Schema.Common.Types\n{\n    public enum SchemaKind\n    {\n        Unknown,\n        Integer,\n        Int64,\n        Number,\n        DateTime,\n        Date,\n        Time,\n        Enumeration,\n        Boolean,\n        Object,\n        Array,\n        String,\n        Char,\n        Guid\n    }\n\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\n    public class SchemaTypeAttribute : Attribute\n    {\n        private readonly SchemaKind _kind;\n\n        private const string SchemaTypeBoolean = \"boolean\";\n        private const string SchemaTypeInteger = \"integer\";\n        private const string SchemaTypeNumber = \"number\";\n        private const string SchemaTypeString = \"string\";\n        private const string SchemaTypeArray = \"array\";\n        private const string SchemaTypeObject = \"object\";\n\n        public SchemaTypeAttribute(SchemaKind kind)\n        {\n            _kind = kind;\n        }\n\n        public string Name\n        {\n            get\n            {\n                switch (_kind)\n                {\n                    case SchemaKind.Integer:\n                    case SchemaKind.Int64:\n                    case SchemaKind.Enumeration:\n                        return SchemaTypeInteger;\n                    case SchemaKind.Number:\n                        return SchemaTypeNumber;\n                    case SchemaKind.String:\n                    case SchemaKind.Char:\n                    case SchemaKind.Guid:\n                    case SchemaKind.DateTime:\n                    case SchemaKind.Date:\n                    case SchemaKind.Time:\n                        return SchemaTypeString;\n                    case SchemaKind.Boolean:\n                        return SchemaTypeBoolean;\n                    case SchemaKind.Object:\n                        return SchemaTypeObject;\n                    case SchemaKind.Array:\n                        return SchemaTypeArray;\n                    default:\n                        return string.Empty;\n                }\n            }\n        }\n\n        public SchemaKind Kind => _kind;\n    }\n}"}
{"input": "{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Sample.SwagDoc;\n\ninterface\n\nuses\n  Swag.Doc;\n\ntype\n  TSampleApiSwagDocBuilder = class(TObject)\n  strict private\n    fSwagDoc: TSwagDoc;\n    fDeployFolder: string;\n\n    procedure DocumentApiInfo;\n    procedure DocumentApiSettings;\n    procedure DocumentApi;\n    procedure DocumentApiEmployee;\n\n    procedure SaveSwaggerJson;\n  private\n    procedure SetDeployFolder(const Value: string);\n  public\n    function Generate: string;\n    property DeployFolder: string read fDeployFolder write SetDeployFolder;\n  end;\n\nimplementation\n\nuses\n  Json.Common.Helpers,\n  Swag.Common.Types,\n  Sample.Api.Employee;\n\n{ TSampleApiSwagDocBuilder }\n\nfunction TSampleApiSwagDocBuilder.Generate: string;\nbegin\n  fSwagDoc := TSwagDoc.Create;\n  try\n    DocumentApiInfo;\n    DocumentApiSettings;\n    DocumentApi;\n    fSwagDoc.GenerateSwaggerJson;\n    SaveSwaggerJson;\n    Result := fSwagDoc.SwaggerJson.Format;\n  finally\n    fSwagDoc.Free;\n  end;\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiInfo;\nbegin\n  fSwagDoc.Info.Title := 'Sample API';\n  fSwagDoc.Info.Version := 'v1';\n  fSwagDoc.Info.TermsOfService := 'http://www.apache.org/licenses/LICENSE-2.0.txt';\n  fSwagDoc.Info.Description := 'Sample API Description';\n  fSwagDoc.Info.Contact.Name := 'Marcelo Jaloto';\n  fSwagDoc.Info.Contact.Email := 'marcelojaloto@gmail.com';\n  fSwagDoc.Info.Contact.Url := 'https://github.com/marcelojaloto/SwagDoc';\n  fSwagDoc.Info.License.Name := 'Apache License - Version 2.0, January 2004';\n  fSwagDoc.Info.License.Url := 'http://www.apache.org/licenses/LICENSE-2.0';\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiSettings;\nbegin\n  fSwagDoc.Host := 'localhost';\n  fSwagDoc.BasePath := '/api';\n\n  fSwagDoc.Consumes.Add('application/json');\n  fSwagDoc.Produces.Add('application/json');\n\n  fSwagDoc.Schemes := [tpsHttp];\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApi;\nbegin\n  DocumentApiEmployee;\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiEmployee;\nvar\n  vApiEmployee: TFakeApiEmployee;\nbegin\n  vApiEmployee := TFakeApiEmployee.Create;\n  try\n    vApiEmployee.DocumentApi(fSwagDoc);\n  finally\n    vApiEmployee.Free;\n  end;\nend;\n\nprocedure TSampleApiSwagDocBuilder.SaveSwaggerJson;\nbegin\n  fSwagDoc.SwaggerFilesFolder := fDeployFolder;\n  fSwagDoc.SaveSwaggerJsonToFile;\nend;\n\nprocedure TSampleApiSwagDocBuilder.SetDeployFolder(const Value: string);\nbegin\n  fDeployFolder := Value;\nend;\n\nend.", "output": "using System;\nusing Swag.Doc;\nusing Swag.Common.Types;\nusing Sample.Api.Employee;\n\nnamespace Sample\n{\n    public class SampleApiSwagDocBuilder\n    {\n        private TSwagDoc _swagDoc;\n        private string _deployFolder;\n        public string DeployFolder { get => _deployFolder; set => _deployFolder = value; }\n        public string Generate()\n        {\n            _swagDoc = new TSwagDoc();\n            try\n            {\n                DocumentApiInfo();\n                DocumentApiSettings();\n                DocumentApi();\n                _swagDoc.GenerateSwaggerJson();\n                SaveSwaggerJson();\n                return _swagDoc.SwaggerJson.Format;\n            }\n            finally\n            {\n                _swagDoc.Dispose();\n            }\n        }\n        private void DocumentApiInfo()\n        {\n            _swagDoc.Info.Title = \"Sample API\";\n            _swagDoc.Info.Version = \"v1\";\n            _swagDoc.Info.TermsOfService = \"http://www.apache.org/licenses/LICENSE-2.0.txt\";\n            _swagDoc.Info.Description = \"Sample API Description\";\n            _swagDoc.Info.Contact.Name = \"Marcelo Jaloto\";\n            _swagDoc.Info.Contact.Email = \"marcelojaloto@gmail.com\";\n            _swagDoc.Info.Contact.Url = \"https://github.com/marcelojaloto/SwagDoc\";\n            _swagDoc.Info.License.Name = \"Apache License - Version 2.0, January 2004\";\n            _swagDoc.Info.License.Url = \"http://www.apache.org/licenses/LICENSE-2.0\";\n        }\n        private void DocumentApiSettings()\n        {\n            _swagDoc.Host = \"localhost\";\n            _swagDoc.BasePath = \"/api\";\n            _swagDoc.Consumes.Add(\"application/json\");\n            _swagDoc.Produces.Add(\"application/json\");\n            _swagDoc.Schemes = new TSwagProtocol[] { TSwagProtocol.tpsHttp };\n        }\n        private void DocumentApi()\n        {\n            DocumentApiEmployee();\n        }\n        private void DocumentApiEmployee()\n        {\n            using (TFakeApiEmployee vApiEmployee = new TFakeApiEmployee())\n            {\n                vApiEmployee.DocumentApi(_swagDoc);\n            }\n        }\n        private void SaveSwaggerJson()\n        {\n            _swagDoc.SwaggerFilesFolder = _deployFolder;\n            _swagDoc.SaveSwaggerJsonToFile();\n        }\n    }\n}"}
{"input": "{\n *\tPROGRAM:\tObject oriented API samples.\n *\tMODULE:\t\t01.create.pas\n *\tDESCRIPTION:\tA sample of creating new database and new table in it.\n *\t\t\t\t\tRun second time (when database already exists) to see\n *\t\t\t\t\thow FbException is caught and handled by this code.\n *\n *\t\t\t\t\tExample for the following interfaces:\n *\t\t\t\t\tIMaster - main inteface to access all the rest\n *\t\t\t\t\tStatus - returns the status of executed command\n *\t\t\t\t\tProvider - main interface to access DB / service\n *\t\t\t\t\tAttachment - database attachment interface\n *\t\t\t\t\tTransaction - transaction interface\n *\t\t\t\t\tUtil - helper calls here and there\n *\t\t\t\t\tXpbBuilder - build various parameters blocks\n *\n *\t\t\t\t\tRun something like this to build: fpc -Fu<path-to-Firebird.pas> -Mdelphi 01.create.pas\n *\n *  The contents of this file are subject to the Initial\n *  Developer's Public License Version 1.0 (the \"License\");\n *  you may not use this file except in compliance with the\n *  License. You may obtain a copy of the License at\n *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.\n *\n *  Software distributed under the License is distributed AS IS,\n *  WITHOUT WARRANTY OF ANY KIND, either express or implied.\n *  See the License for the specific language governing rights\n *  and limitations under the License.\n *\n *  The Original Code was created by Alexander Peshkoff\n *  for the Firebird Open Source RDBMS project.\n *\n *  Copyright (c) 2015 Alexander Peshkoff <peshkoff@mail.ru>\n *  and all contributors signed below.\n *\n *  All Rights Reserved.\n *  Contributor(s): ______________________________________. }\n\nProgram create;\n\nuses Sysutils, Firebird;\n\nvar\n\t// Declare pointers to required interfaces\n\n\t// Status is used to return wide error description to user\n\tst : IStatus;\n\n\t// This is main interface of firebird, and the only one\n\t// for getting which there is special function in our API\n\tmaster : IMaster;\n\tutil : IUtil;\n\n\t// XpbBuilder helps to create various parameter blocks for API calls\n\tdpb : IXpbBuilder;\n\n\t// Provider is needed to start to work with database (or service)\n\tprov : IProvider;\n\n\t// Attachment and Transaction contain methods to work with\n\t// database attachment and transaction\n\tatt : IAttachment;\n\ttra : ITransaction;\n\n\tprocedure PrintError(s : IStatus);\n\tvar\n\t\tmaxMessage : Integer;\n\t\toutMessage : PAnsiChar;\n\tbegin\n\t\tmaxMessage := 256;\n\t\toutMessage := StrAlloc(maxMessage);\n\t\tutil.formatStatus(outMessage, maxMessage, s);\n\t\twriteln(outMessage);\n\t\tStrDispose(outMessage);\n\tend;\n\nbegin\n\t// Here we get access to master interface and helper utility interface\n\t// no error return may happen - these functions always succeed\n\tmaster := fb_get_master_interface;\n\tutil := master.getUtilInterface;\n\n\t// status vector and main dispatcher are returned by calls to IMaster functions\n\t// no error return may happen - these functions always succeed\n\tst := master.getStatus;\n\tprov := master.getDispatcher;\n\n\ttry\n\t\t// create DPB\n\t\tdpb := util.getXpbBuilder(st, IXpbBuilder.DPB, nil, 0);\n\t\tdpb.insertInt(st, isc_dpb_page_size, 4 * 1024);\n\t\tdpb.insertString(st, isc_dpb_user_name, 'sysdba');\n\t\tdpb.insertString(st, isc_dpb_password, 'masterkey');\n\n\t\t// create empty database\n\t\tatt := prov.createDatabase(st, 'fbtests.fdb', dpb.getBufferLength(st), dpb.getBuffer(st));\n\t\twriteln ('Database fbtests.fdb created');\n\n\t\t// detach from database\n\t\tatt.detach(st);\n\t\tatt := nil;\n\n\t\t// remove unneeded any more tag from DPB\n\t\tif dpb.findFirst(st, isc_dpb_page_size)\n\t\t\tthen dpb.removeCurrent(st);\n\n\t\t// attach it once again\n\t\tatt := prov.attachDatabase(st, 'fbtests.fdb', dpb.getBufferLength(st), dpb.getBuffer(st));\n\t\twriteln ('Re-attached database fbtests.fdb');\n\n\t\t// start transaction\n\t\ttra := att.startTransaction(st, 0, nil);\n\n\t\t// create table\n\t\tatt.execute(st, tra, 0, 'create table dates_table (d1 date)', 3,\n\t\t\tnil, nil, nil, nil);\t// Input parameters and output data not used\n\n\t\t// commit transaction retaining\n\t\ttra.commitRetaining(st);\n\t\twriteln ('Table dates_table created');\n\n\t\t// insert a record into dates_table\n\t\tatt.execute(st, tra, 0, 'insert into dates_table values (CURRENT_DATE)', 3,\n\t\t\tnil, nil, nil, nil);\t// Input parameters and output data not used\n\n\t\t// commit transaction (will close interface)\n\t\ttra.commit(st);\n\t\ttra := nil;\n\n\t\twriteln ('Record inserted into dates_table');\n\n\t\t// detach from database (will close interface)\n\t\tatt.detach(st);\n\t\tatt := nil;\n\n\t\tdpb.dispose;\n\t\tdpb := nil;\n\texcept\n\t\ton e: FbException do PrintError(e.getStatus);\n\tend;\n\n\tprov.release;\nend.", "output": "using System;\nusing System.IO;\nusing FirebirdSql.Data.FirebirdClient;\n\nnamespace CreateDatabaseSample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string connectionString = \"User=SYSDBA;\" +\n                                      \"Password=masterkey;\" +\n                                      \"Database=fbtests.fdb;\" +\n                                      \"DataSource=localhost;\" +\n                                      \"Port=3050;\" +\n                                      \"Dialect=3;\";\n            try\n            {\n                if (!File.Exists(\"fbtests.fdb\"))\n                {\n                    FbConnection.CreateDatabase(connectionString);\n                    Console.WriteLine(\"Database fbtests.fdb created\");\n                }\n                else\n                {\n                    Console.WriteLine(\"Database fbtests.fdb already exists. Re-attaching.\");\n                }\n\n                using (var connection = new FbConnection(connectionString))\n                {\n                    connection.Open();\n                    Console.WriteLine(\"Re-attached database fbtests.fdb\");\n\n                    using (var transaction = connection.BeginTransaction())\n                    {\n                        using (var command = new FbCommand(\"CREATE TABLE dates_table (d1 DATE)\", connection, transaction))\n                        {\n                            command.ExecuteNonQuery();\n                        }\n                        transaction.Commit();\n                        Console.WriteLine(\"Table dates_table created\");\n                    }\n\n                    using (var transaction = connection.BeginTransaction())\n                    {\n                        using (var command = new FbCommand(\"INSERT INTO dates_table VALUES (CURRENT_DATE)\", connection, transaction))\n                        {\n                            command.ExecuteNonQuery();\n                        }\n                        transaction.Commit();\n                        Console.WriteLine(\"Record inserted into dates_table\");\n                    }\n\n                    connection.Close();\n                }\n            }\n            catch (FbException ex)\n            {\n                Console.WriteLine(\"Error: \" + ex.Message);\n            }\n        }\n    }\n}"}
{"input": "unit Horse.WebModule;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fpWeb,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$ENDIF}\n  Horse.Core;\n\ntype\n{$IF DEFINED(FPC)}\n  THorseWebModule = class(TFPWebModule)\n    procedure DoOnRequest(ARequest: TRequest; AResponse: TResponse; var AHandled: Boolean); override;\n{$ELSE}\n  THorseWebModule = class(TWebModule)\n{$ENDIF}\n    procedure HandlerAction(const Sender: TObject; const Request: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}; const Response: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; var Handled: Boolean);\n  private\n    FHorse: THorseCore;\n    class var FInstance: THorseWebModule;\n  public\n    property Horse: THorseCore read FHorse write FHorse;\n    constructor Create(AOwner: TComponent); override;\n  \tclass function GetInstance: THorseWebModule;\n  end;\n\nvar\n{$IF DEFINED(FPC)}\n  HorseWebModule: THorseWebModule;\n{$ELSE}\n  WebModuleClass: TComponentClass = THorseWebModule;\n{$ENDIF}\n\nimplementation\n\nuses\n  Horse.Request,\n  Horse.Response,\n  Horse.Exception.Interrupted;\n\n{$IF DEFINED(FPC)}\n  {$R Horse.WebModule.lfm}\n{$ELSE}\n  {$R *.dfm}\n{$ENDIF}\n\nclass function THorseWebModule.GetInstance: THorseWebModule;\nbegin\n  Result := FInstance;\nend;\n\nconstructor THorseWebModule.Create(AOwner: TComponent);\nbegin\n{$IF DEFINED(FPC)}\n  inherited CreateNew(AOwner, 0);\n{$ELSE}\n  inherited;\n{$ENDIF}\n  FHorse := THorseCore.GetInstance;\n  FInstance := Self;\nend;\n\n{$IF DEFINED(FPC)}\nprocedure THorseWebModule.DoOnRequest(ARequest: {$IF DEFINED(FPC)}TRequest{$ELSE}  TWebRequest {$ENDIF}; AResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}  TWebResponse {$ENDIF}; var AHandled: Boolean);\nbegin\n  HandlerAction(Self, ARequest, AResponse, AHandled);\nend;\n{$ENDIF}\n\nprocedure THorseWebModule.HandlerAction(const Sender: TObject; const Request: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\n  const Response: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; var Handled: Boolean);\nvar\n  LRequest: THorseRequest;\n  LResponse: THorseResponse;\nbegin\n  Handled := True;\n  LRequest := THorseRequest.Create(Request);\n  LResponse := THorseResponse.Create(Response);\n  try\n    try\n      FHorse.Routes.Execute(LRequest, LResponse)\n    except\n      on E: Exception do\n        if not E.InheritsFrom(EHorseCallbackInterrupted) then\n          raise;\n    end;\n  finally\n    if LRequest.Body<TObject> = LResponse.Content then\n      LResponse.Content(nil);\n    LRequest.Free;\n    LResponse.Free;\n  end;\nend;\n\n{$IF DEFINED(FPC)}\ninitialization\n  RegisterHTTPModule(THorseWebModule);\n{$ENDIF}\n\nend.", "output": "using System;\nusing Horse.Request;     \nusing Horse.Response;    \nusing Horse.Core;        \nusing System.Web;       \n\nnamespace Horse.WebModule\n{\n    \n    public class HorseWebModule \n    {\n        private THorseCore _horse;\n        private static HorseWebModule _instance;\n\n        \n        public THorseCore Horse\n        {\n            get { return _horse; }\n            set { _horse = value; }\n        }\n\n       \n        public HorseWebModule(object owner = null)\n        {\n            \n            _horse = THorseCore.GetInstance();\n            _instance = this;\n        }\n\n        \n        public static HorseWebModule GetInstance()\n        {\n            return _instance;\n        }\n\n        \n        public void HandlerAction(object sender, TWebRequest request, TWebResponse response, ref bool handled)\n        {\n            handled = true;\n            \n            HorseRequest horseRequest = new HorseRequest(request);\n            HorseResponse horseResponse = new HorseResponse(response);\n            try\n            {\n                try\n                {\n                    \n                    _horse.Routes.Execute(horseRequest, horseResponse);\n                }\n                catch (Exception ex)\n                {\n                    \n                    if (!(ex is HorseCallbackInterruptedException))\n                    {\n                        throw;\n                    }\n                }\n            }\n            finally\n            {\n                \n                if (horseRequest.Body<object>() == horseResponse.Content())\n                {\n                    horseResponse.Content(null);\n                }\n                horseRequest.Dispose();\n                horseResponse.Dispose();\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Core.Param.Field;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  DateUtils,\n  Generics.Collections,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  System.DateUtils,\n  System.Generics.Collections,\n  System.Rtti,\n{$ENDIF}\n  Horse.Exception,\n  Horse.Commons,\n  Horse.Core.Param.Field.Brackets,\n  Horse.Core.Param.Config;\n\ntype\n\n  THorseCoreParamField = class\n  private\n    FContains: Boolean;\n    FFieldName: string;\n    FRequired: Boolean;\n    FRequiredMessage: string;\n    FInvalidFormatMessage: string;\n    FDateFormat: string;\n    FTimeFormat: string;\n    FReturnUTC: Boolean;\n    FTrueValue: string;\n    FValue: string;\n    FStream: TStream;\n    FLhsBrackets: THorseCoreParamFieldLhsBrackets;\n\n    function GetFormatSettings: TFormatSettings;\n    procedure RaiseHorseException(const AMessage: string); overload;\n    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;\n    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;\n    procedure InitializeLhsBrackets(const AParams: TDictionary<string, string>; const AFieldName: string);\n  public\n    function DateFormat(const AValue: string): THorseCoreParamField;\n    function InvalidFormatMessage(const AValue: string): THorseCoreParamField;\n    function Required: THorseCoreParamField; overload;\n    function Required(const AValue: Boolean): THorseCoreParamField; overload;\n    function RequiredMessage(const AValue: string): THorseCoreParamField;\n    function ReturnUTC(const AValue: Boolean): THorseCoreParamField;\n    function TimeFormat(const AValue: string): THorseCoreParamField;\n    function TrueValue(const AValue: string): THorseCoreParamField;\n    procedure SaveToFile(const AFileName: String);\n    function AsBoolean: Boolean;\n    function AsCurrency: Currency;\n    function AsDate: TDateTime;\n    function AsDateTime: TDateTime;\n    function AsExtended: Extended;\n    function AsFloat: Double;\n    function AsInteger: Integer;\n    function AsInt64: Int64;\n    function AsISO8601DateTime: TDateTime;\n    function AsStream: TStream;\n    function AsString: string;\n    function AsTime: TTime;\n    function AsList: TList<string>; overload;\n   {$IF NOT DEFINED(FPC)}\n    function AsList<T>: TList<T>; overload;\n   {$ENDIF}\n    property LhsBrackets:THorseCoreParamFieldLhsBrackets read FLhsBrackets;\n    constructor Create(const AParams: TDictionary<string, string>; const AFieldName: string); overload;\n    constructor Create(const AStream: TStream; const AFieldName: string); overload;\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseCoreParamField.AsBoolean: Boolean;\nvar\n  LStrParam: string;\nbegin\n  Result := False;\n  LStrParam := Trim(AsString);\n  if LStrParam <> EmptyStr then\n    Result := LowerCase(LStrParam) = LowerCase(FTrueValue);\nend;\n\nfunction THorseCoreParamField.AsCurrency: Currency;\nbegin\n  Result := AsFloat;\nend;\n\nfunction THorseCoreParamField.AsDate: TDateTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToDate(Copy(LStrParam, 1, Length(FDateFormat)), LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'date']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsDateTime: TDateTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToDateTime(LStrParam, LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'datetime']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsExtended: Extended;\nbegin\n  Result := AsFloat;\nend;\n\nfunction THorseCoreParamField.AsFloat: Double;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LStrParam := LStrParam.Replace(',', FormatSettings.DecimalSeparator).Replace('.', FormatSettings.DecimalSeparator);\n    Result := StrToFloat(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'numeric']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsInt64: Int64;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam <> EmptyStr then\n      Result := StrToInt64(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'int64']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsInteger: Integer;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam <> EmptyStr then\n      Result := StrToInt(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'integer']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsISO8601DateTime: TDateTime;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  if LStrParam = EmptyStr then\n    Exit;\n  if not TryISO8601ToDate(LStrParam, Result) then\n    RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'ISO8601 date']);\nend;\n\nfunction THorseCoreParamField.AsList: TList<string>;\nvar\n  ValueArray : TArray<string>;\n  i: Integer;\nbegin\n  Result := TList<string>.Create;\n  if FContains then\n  begin\n    ValueArray := FValue.Split([',']);\n    for i := 0 to High(ValueArray) do\n    begin\n      Result.Add(ValueArray[i]);\n    end;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\n{$IF NOT DEFINED(FPC)}\nfunction THorseCoreParamField.AsList<T>: TList<T>;\nvar\n  ValueArray : TArray<string>;\n  i: Integer;\nbegin\n  Result := TList<T>.Create;\n  if FContains then\n  begin\n    ValueArray := FValue.Split([',']);\n    for i := 0 to High(ValueArray) do\n    begin\n      case GetTypeKind(T) of\n        tkString, tkUString:\n          Result.Add(TValue.From<string>(ValueArray[i]).AsType<T>);\n        tkInteger:\n          Result.Add(TValue.From<Integer>(StrToInt(ValueArray[i])).AsType<T>);\n        tkInt64:\n          Result.Add(TValue.From<Int64>(StrToInt64(ValueArray[i])).AsType<T>);\n        tkFloat:\n          Result.Add(TValue.From<Double>(StrToFloat(ValueArray[i])).AsType<T>);\n        tkVariant:\n          Result.Add(TValue.From<variant>(ValueArray[i]).AsType<T>);\n      else\n        // Specific handling for Datetime, Date, and Time, as they are not present in the TypeKind list.\n        begin\n          if TypeInfo(T) = TypeInfo(TDateTime) then\n            Result.Add(TValue.From<TDateTime>(StrToDateTime(ValueArray[i])).AsType<T>)\n          else if TypeInfo(T) = TypeInfo(TDate) then\n            Result.Add(TValue.From<TDate>(StrToDate(ValueArray[i])).AsType<T>)\n          else if TypeInfo(T) = TypeInfo(TTime) then\n            Result.Add(TValue.From<TTime>(StrToTime(ValueArray[i])).AsType<T>)\n          else\n            raise EHorseException.New.Error('Unsupported type');\n        end;\n      end;\n    end;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n{$ENDIF}\n\nfunction THorseCoreParamField.AsStream: TStream;\nbegin\n  Result := nil;\n  if FContains then\n  begin\n    Result := FStream;\n    if Assigned(Result) then\n      Result.Position := 0;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\nfunction THorseCoreParamField.AsString: string;\nbegin\n  Result := EmptyStr;\n  if FContains then\n    Result := FValue\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\nfunction THorseCoreParamField.AsTime: TTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToTime(Copy(LStrParam, 1, Length(FTimeFormat)), LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'time']);\n  end;\nend;\n\nconstructor THorseCoreParamField.Create(const AStream: TStream; const AFieldName: string);\nbegin\n  FContains := True;\n  FFieldName := AFieldName;\n  FValue := EmptyStr;\n  FRequired := False;\n  FStream := AStream;\nend;\n\nconstructor THorseCoreParamField.Create(const AParams: TDictionary<string, string>; const AFieldName: string);\nvar\n  LKey: string;\nbegin\n  FContains := False;\n  FFieldName := AFieldName;\n  FValue := EmptyStr;\n  FRequired := False;\n\n  for LKey in AParams.Keys do\n  begin\n    if AnsiCompareText(LKey, FFieldName) = 0 then\n    begin\n      FContains := True;\n      Break;\n    end;\n  end;\n\n  if FContains then\n    FValue := AParams.Items[LKey];\n\n  InitializeLhsBrackets(AParams, AFieldName);\nend;\n\ndestructor THorseCoreParamField.Destroy;\nbegin\n  FLhsBrackets.Free;\n  inherited Destroy;\nend;\n\nfunction THorseCoreParamField.DateFormat(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FDateFormat := AValue;\nend;\n\nfunction THorseCoreParamField.GetFormatSettings: TFormatSettings;\nbegin\n{$IF DEFINED(FPC)}\n  Result := DefaultFormatSettings;\n{$ELSE}\n  Result := TFormatSettings.Create;\n{$ENDIF}\n  if FDateFormat.IndexOf('-') > 0 then\n    Result.DateSeparator := '-';\n  Result.ShortDateFormat := FDateFormat;\n  Result.ShortTimeFormat := FTimeFormat;\nend;\n\nprocedure THorseCoreParamField.InitializeLhsBrackets(const AParams: TDictionary<string, string>; const AFieldName: string);\nvar\n  LLhsBracketType: TLhsBracketsType;\nbegin\n  FLhsBrackets := THorseCoreParamFieldLhsBrackets.Create;\n  if THorseCoreParamConfig.GetInstance.CheckLhsBrackets then\n  begin\n    for LLhsBracketType := Low(TLhsBracketsType) to High(TLhsBracketsType) do\n    begin\n      if AParams.ContainsKey(FFieldName + LLhsBracketType.ToString) then\n      begin\n        FLhsBrackets.SetValue(LLhsBracketType, AParams.Items[FFieldName+LLhsBracketType.ToString]);\n        FLhsBrackets.Types := FLhsBrackets.Types + [LLhsBracketType];\n      end;\n    end;\n  end;\nend;\n\nfunction THorseCoreParamField.InvalidFormatMessage(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FInvalidFormatMessage := AValue;\nend;\n\nprocedure THorseCoreParamField.RaiseHorseException(const AMessage: string; const Args: array of const);\nbegin\n  RaiseHorseException(Format(AMessage, Args));\nend;\n\nprocedure THorseCoreParamField.RaiseHorseException(const AMessage: string);\nvar\n  LException: EHorseException;\nbegin\n  LException := EHorseException.New.Status(THTTPStatus.BadRequest).Error(AMessage);\n  LException.Message := AMessage;\n  raise LException;\nend;\n\nfunction THorseCoreParamField.Required(const AValue: Boolean): THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequired := AValue;\nend;\n\nfunction THorseCoreParamField.Required: THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequired := True;\nend;\n\nfunction THorseCoreParamField.RequiredMessage(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequiredMessage := AValue;\nend;\n\nfunction THorseCoreParamField.ReturnUTC(const AValue: Boolean): THorseCoreParamField;\nbegin\n  Result := Self;\n  FReturnUTC := AValue;\nend;\n\nprocedure THorseCoreParamField.SaveToFile(const AFileName: String);\nvar\n  LMemoryStream: TMemoryStream;\nbegin\n  if AsStream = nil then\n    Exit;\n\n  LMemoryStream := TMemoryStream.Create;\n  try\n    LMemoryStream.LoadFromStream(AsStream);\n    LMemoryStream.Position := 0;\n    LMemoryStream.SaveToFile(AFileName);\n  finally\n    LMemoryStream.Free;\n  end;\nend;\n\nfunction THorseCoreParamField.TimeFormat(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FTimeFormat := AValue;\nend;\n\nfunction THorseCoreParamField.TrueValue(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FTrueValue := AValue;\nend;\n\nfunction THorseCoreParamField.TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;\nbegin\n  Value := ISO8601ToDate(AValue, FReturnUTC);\n  Result := True;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nnamespace Horse.Core.Param.Field\n{\n    #region Dependent Stubs\n\n    public class HorseException : Exception\n    {\n        public int Status { get; set; }\n        public HorseException(string message) : base(message) { }\n        public static HorseException New(int status, string message)\n        {\n            return new HorseException(message) { Status = status };\n        }\n    }\n\n    public static class HTTPStatus\n    {\n        public const int BadRequest = 400;\n    }\n\n    public class HorseCoreParamConfig\n    {\n        private static HorseCoreParamConfig _instance;\n        public bool CheckLhsBrackets { get; set; } = false;\n        private HorseCoreParamConfig() { }\n        public static HorseCoreParamConfig GetInstance()\n        {\n            if (_instance == null)\n                _instance = new HorseCoreParamConfig();\n            return _instance;\n        }\n    }\n\n    public enum TLhsBracketsType\n    {\n        Square, \n        Curly   \n        \n    }\n\n    \n    public class HorseCoreParamFieldLhsBrackets\n    {\n        public List<TLhsBracketsType> Types { get; } = new List<TLhsBracketsType>();\n        private readonly Dictionary<TLhsBracketsType, string> _values = new Dictionary<TLhsBracketsType, string>();\n        public void SetValue(TLhsBracketsType type, string value)\n        {\n            _values[type] = value;\n        }\n    }\n\n    #endregion\n\n    public class HorseCoreParamField : IDisposable\n    {\n        \n        private bool FContains;\n        private string FFieldName;\n        private bool FRequired;\n        private string FRequiredMessage;\n        private string FInvalidFormatMessage;\n        private string FDateFormat;\n        private string FTimeFormat;\n        private bool FReturnUTC;\n        private string FTrueValue;\n        private string FValue;\n        private Stream FStream;\n        private HorseCoreParamFieldLhsBrackets FLhsBrackets;\n\n        \n        public HorseCoreParamField(Dictionary<string, string> AParams, string AFieldName)\n        {\n            FFieldName = AFieldName;\n            FValue = \"\";\n            FRequired = false;\n            FContains = false;\n            \n            foreach (var key in AParams.Keys)\n            {\n                if (string.Equals(key, FFieldName, StringComparison.OrdinalIgnoreCase))\n                {\n                    FContains = true;\n                    FValue = AParams[key];\n                    break;\n                }\n            }\n            InitializeLhsBrackets(AParams, AFieldName);\n        }\n\n       \n        public HorseCoreParamField(Stream AStream, string AFieldName)\n        {\n            FFieldName = AFieldName;\n            FValue = \"\";\n            FRequired = false;\n            FContains = true;\n            FStream = AStream;\n        }\n\n        \n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                \n                FLhsBrackets = null;\n                \n            }\n        }\n        ~HorseCoreParamField() => Dispose(false);\n\n        #region Fluent Setters and Getters\n\n        public HorseCoreParamField DateFormat(string AValue)\n        {\n            FDateFormat = AValue;\n            return this;\n        }\n        public string DateFormat() => FDateFormat;\n\n        public HorseCoreParamField InvalidFormatMessage(string AValue)\n        {\n            FInvalidFormatMessage = AValue;\n            return this;\n        }\n        public string InvalidFormatMessage() => FInvalidFormatMessage;\n\n        public HorseCoreParamField Required()\n        {\n            FRequired = true;\n            return this;\n        }\n        public HorseCoreParamField Required(bool AValue)\n        {\n            FRequired = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField RequiredMessage(string AValue)\n        {\n            FRequiredMessage = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField ReturnUTC(bool AValue)\n        {\n            FReturnUTC = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField TimeFormat(string AValue)\n        {\n            FTimeFormat = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField TrueValue(string AValue)\n        {\n            FTrueValue = AValue;\n            return this;\n        }\n\n        \n        public HorseCoreParamField CheckLhsBrackets(bool AValue)\n        {\n            \n            return this;\n        }\n\n        \n        public HorseCoreParamFieldLhsBrackets LhsBrackets => FLhsBrackets;\n\n        #endregion\n\n        #region Conversion Methods\n\n        public bool AsBoolean()\n        {\n            string LStrParam = AsString().Trim();\n            if (!string.IsNullOrEmpty(LStrParam))\n                return LStrParam.ToLowerInvariant() == FTrueValue.ToLowerInvariant();\n            return false;\n        }\n\n        public double AsCurrency() => AsFloat();\n\n        public DateTime AsDate()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            try\n            {\n                var fs = GetFormatSettings();\n                \n                string datePart = LStrParam.Substring(0, Math.Min(FDateFormat.Length, LStrParam.Length));\n                return DateTime.ParseExact(datePart, FDateFormat, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"date\" });\n                return default;\n            }\n        }\n\n        public DateTime AsDateTime()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            try\n            {\n                var fs = GetFormatSettings();\n                return DateTime.Parse(LStrParam, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"datetime\" });\n                return default;\n            }\n        }\n\n        public double AsExtended() => AsFloat();\n\n        public double AsFloat()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (string.IsNullOrEmpty(LStrParam))\n                    return 0;\n                var fs = GetFormatSettings();\n                \n                LStrParam = LStrParam.Replace(\",\", fs.NumberFormat.NumberDecimalSeparator)\n                                   .Replace(\".\", fs.NumberFormat.NumberDecimalSeparator);\n                return double.Parse(LStrParam, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"numeric\" });\n                return 0;\n            }\n        }\n\n        public long AsInt64()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (!string.IsNullOrEmpty(LStrParam))\n                    return long.Parse(LStrParam);\n                return 0;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"int64\" });\n                return 0;\n            }\n        }\n\n        public int AsInteger()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (!string.IsNullOrEmpty(LStrParam))\n                    return int.Parse(LStrParam);\n                return 0;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"integer\" });\n                return 0;\n            }\n        }\n\n        public DateTime AsISO8601DateTime()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            DateTime dt;\n            if (!TryISO8601ToDate(LStrParam, out dt))\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"ISO8601 date\" });\n            return dt;\n        }\n\n        public Stream AsStream()\n        {\n            if (FContains)\n            {\n                if (FStream != null)\n                    FStream.Position = 0;\n                return FStream;\n            }\n            else if (FRequired)\n            {\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            }\n            return null;\n        }\n\n        public string AsString()\n        {\n            if (FContains)\n                return FValue;\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return \"\";\n        }\n\n        public TimeSpan AsTime()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (string.IsNullOrEmpty(LStrParam))\n                    return default;\n                var fs = GetFormatSettings();\n                string timePart = LStrParam.Substring(0, Math.Min(FTimeFormat.Length, LStrParam.Length));\n                DateTime dt = DateTime.ParseExact(timePart, FTimeFormat, fs);\n                return dt.TimeOfDay;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"time\" });\n                return default;\n            }\n        }\n\n        public List<string> AsList()\n        {\n            if (FContains)\n            {\n                var arr = FValue.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                                .Select(s => s.Trim()).ToList();\n                return arr;\n            }\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return new List<string>();\n        }\n\n        public List<T> AsList<T>()\n        {\n            if (FContains)\n            {\n                var arr = FValue.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n                var list = new List<T>();\n                foreach (var s in arr)\n                {\n                    string trimmed = s.Trim();\n                    try\n                    {\n                        object converted = null;\n                        var targetType = typeof(T);\n                        if (targetType == typeof(string))\n                            converted = trimmed;\n                        else if (targetType == typeof(int))\n                            converted = int.Parse(trimmed);\n                        else if (targetType == typeof(long))\n                            converted = long.Parse(trimmed);\n                        else if (targetType == typeof(double))\n                            converted = double.Parse(trimmed, GetFormatSettings());\n                        else if (targetType == typeof(DateTime))\n                            converted = DateTime.Parse(trimmed, GetFormatSettings());\n                        else\n                        {\n                            if (targetType == typeof(DateTime)) \n                                converted = DateTime.Parse(trimmed, GetFormatSettings());\n                            else\n                                throw new Exception(\"Unsupported type\");\n                        }\n                        list.Add((T)converted);\n                    }\n                    catch (Exception)\n                    {\n                        RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, trimmed, targetType.Name.ToLowerInvariant() });\n                    }\n                }\n                return list;\n            }\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return new List<T>();\n        }\n\n        #endregion\n\n        #region Helpers\n\n        \n        private CultureInfo GetFormatSettings()\n        {\n            CultureInfo ci = (CultureInfo)CultureInfo.CurrentCulture.Clone();\n            if (!string.IsNullOrEmpty(FDateFormat) && FDateFormat.Contains(\"-\"))\n                ci.DateTimeFormat.DateSeparator = \"-\";\n            ci.DateTimeFormat.ShortDatePattern = FDateFormat;\n            ci.DateTimeFormat.ShortTimePattern = FTimeFormat;\n            return ci;\n        }\n\n        private void RaiseHorseException(string AMessage, object[] Args)\n        {\n            string msg = string.Format(AMessage, Args);\n            RaiseHorseException(msg);\n        }\n\n        private void RaiseHorseException(string AMessage)\n        {\n            throw HorseException.New(HTTPStatus.BadRequest, AMessage);\n        }\n\n        \n        private bool TryISO8601ToDate(string AValue, out DateTime Value)\n        {\n            var style = FReturnUTC ? DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal : DateTimeStyles.None;\n            return DateTime.TryParse(AValue, null, style, out Value);\n        }\n\n        \n        private void InitializeLhsBrackets(Dictionary<string, string> AParams, string AFieldName)\n        {\n            FLhsBrackets = new HorseCoreParamFieldLhsBrackets();\n            if (HorseCoreParamConfig.GetInstance().CheckLhsBrackets)\n            {\n                foreach (TLhsBracketsType type in Enum.GetValues(typeof(TLhsBracketsType)))\n                {\n                    string key = FFieldName + type.ToString();\n                    if (AParams.ContainsKey(key))\n                    {\n                        FLhsBrackets.SetValue(type, AParams[key]);\n                        FLhsBrackets.Types.Add(type);\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region Fluent Setters (Additional)\n\n        public HorseCoreParamField RequiredMessage(string AValue)\n        {\n            FRequiredMessage = AValue;\n            return this;\n        }\n\n        #endregion\n       \n        #region Conversion of String Value\n\n        \n        private string Trim(string s)\n        {\n            return s?.Trim() ?? \"\";\n        }\n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit LiveServerTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  MVCFramework.RESTClient.Intf,\n  MVCFramework.RESTClient,\n  MVCFramework.JSONRPC.Client,\n  System.DateUtils,\n  System.Hash, System.Rtti, MVCFramework.Commons;\n\ntype\n\n  TBaseServerTest = class(TObject)\n  protected\n    RESTClient: IMVCRESTClient;\n    procedure DoLoginWith(UserName: string);\n    procedure DoLogout;\n  public\n    [Setup]\n    procedure Setup; virtual;\n    [TearDown]\n    procedure TearDown; virtual;\n\n  end;\n\n  [TestFixture]\n  TServerTest = class(TBaseServerTest)\n  public\n    [Test]\n    [TestCase('request url /fault', '/exception/fault')]\n    [TestCase('request url /fault2', '/exception/fault2')]\n    procedure TestControllerWithExceptionInCreate(const URLSegment: string);\n\n    [Test]\n    [TestCase('url \"/\"', '/')]\n    [TestCase('url \"/action1\"', '/action1')]\n    [TestCase('url \"/action2\"', '/action2')]\n    [TestCase('url \"/api/v1\"', '/api/v1')]\n    [TestCase('url \"/api/v1/action1\"', '/api/v1/action1')]\n    [TestCase('url \"/api/v1/action2\"', '/api/v1/action2')]\n    [TestCase('url \"/api/v2\"', '/api/v2')]\n    [TestCase('url \"/api/v2/action1\"', '/api/v2/action1')]\n    [TestCase('url \"/api/v2/action2\"', '/api/v2/action2')]\n    procedure TestMultiMVCPathOnControllerAndAction(const URLSegment: string);\n\n    [Test]\n    procedure TestReqWithParams;\n\n    // URL_MAPPED_PARAMS_ALLOWED_CHARS = ' \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd@\\[\\]\\{\\}\\(\\)\\=;&#\\.\\_\\,%\\w\\d\\x2D\\x3A';\n    [Test]\n    [TestCase('1', ' \ufffd,\ufffd')]\n    [TestCase('2', '\ufffd,\ufffd,\ufffd')]\n    [TestCase('3', '\ufffd,@,[')]\n    [TestCase('4', '],{,}')]\n    [TestCase('5', '(,),\\')]\n    [TestCase('6', '=,;,&')]\n    [TestCase('7', '#,.,_')]\n    [TestCase('8', '%, , ')]\n    procedure TestReqWithURLMappedParams(const par1, par2, par3: string);\n    [Test]\n    procedure TestPOSTWithParamsAndJSONBody;\n    [Test]\n    procedure TestPOSTWithObjectJSONBody;\n    [Test]\n    procedure TestCustomerEcho;\n    [Test]\n    procedure TestCustomerEchoWithRootNode;\n    [Test]\n    procedure TestEchoWithAllVerbs;\n    [Test]\n    procedure TestCustomerEchoBodyFor;\n    [Test]\n    procedure TestPOSTWithoutContentType;\n    [Test]\n    procedure TestXHTTPMethodOverride_POST_as_PUT;\n    [Test]\n    procedure TestPUTWithParamsAndJSONBody;\n    [Test]\n    procedure TestCookies;\n    [Test]\n    procedure TestSessionWithLogin;\n    [Test]\n    procedure TestSession;\n    [Test]\n    procedure TestInvalidateSession;\n    [Test]\n    procedure TestAsynchRequestPOST;\n    [Test]\n    procedure TestAsynchRequestPUT;\n    [Test]\n    procedure TestAsynchRequestGET;\n    [Test]\n    procedure TestAsynchRequestDELETE;\n    [Test]\n    procedure TestEncodingRenderJSONValue;\n    [Test]\n    procedure TestRenderWrappedList;\n    [Test]\n    procedure TestObjectDictIgnoredFields;\n    [Test]\n    procedure TestObjectDictIgnoredFieldsWithDataSets;\n    [Test]\n    procedure TestRenderActionInCollections;\n    [Test]\n    procedure TestRenderWrappedListWithCompression;\n    [Test]\n    procedure TestRenderStreamAndFreeWithOwnerFalse;\n    [Test]\n    procedure TestRenderStreamAndFreeWithOwnerTrue;\n    [Test]\n    procedure TestObjectDict;\n    [Test]\n    procedure TestGetImagePng;\n    [Test]\n    procedure TestProducesConsumes01;\n    [Test]\n    procedure TestProducesConsumes02;\n    [Test]\n    procedure TestProducesConsumes03;\n    [Test]\n    procedure TestProducesConsumesWithWrongAcceptHeader;\n    [Test]\n    procedure TestExceptionInMVCAfterCreate;\n    [Test]\n    procedure TestExceptionInMVCBeforeDestroy;\n    [Test]\n    procedure TestActionFiltersOnBeforeAction;\n    [Test]\n    procedure TestMiddlewareSpeedMiddleware;\n    [Test]\n    procedure TestMiddlewareHandler;\n    [Test]\n    procedure TestPostAListOfObjects;\n    // test authentication/authorization with BasicAuth\n    [Test]\n    procedure TestBasicAuth01;\n    [Test]\n    // [Category('this')]\n    procedure TestEntityWithArrays;\n    [Test]\n    // [Category('this')]\n    procedure TestEntityWithEmptyArrays;\n    [Test]\n    procedure TestEntityWithGUIDs;\n    [Test]\n    procedure TestEntityWithGUIDsEcho;\n    [Test]\n    procedure TestBasicAuth02;\n    [Test]\n    procedure TestBasicAuth03;\n    [Test]\n    procedure TestBasicAuth04;\n    [Test]\n    procedure TestBasicAuth05;\n    // test authentication/authorization with CustomAuth\n    [Test]\n    procedure TestCustomAuthRequestWithoutLogin;\n    [Test]\n    procedure TestCustomAuthRequestsWithValidLogin;\n    [Test]\n    procedure TestCustomAuthRequestsWithValidLogin_HTML;\n    [Test]\n    procedure TestCustomAuthWrongRequestBodies;\n    [Test]\n    procedure TestCustomAuthLoginLogout;\n\n    // typed actions\n    [Test]\n    procedure TestTypedString1;\n    [Test]\n    procedure TestTypedInteger1;\n    [Test]\n    procedure TestTypedInt641;\n    [Test]\n    procedure TestTypedSingle1;\n    [Test]\n    procedure TestTypedDouble1;\n    [Test]\n    procedure TestTypedExtended1;\n    [Test]\n    procedure TestTypedAll;\n    [Test]\n    [Category('datetime')]\n    procedure TestTypedDateTimeTypes;\n    [Test]\n    [Category('datetime')]\n    procedure TestTypedDateTimeTypes_UTC;\n    [Test]\n    procedure TestTypedBooleans;\n    [Test]\n    procedure TestTypedTGuid1;\n    [Test]\n    procedure TestStringDictionary;\n    [Test]\n    procedure TestWrongJSONBody;\n    [Test]\n    procedure TestTypedIntegerWrongParam1;\n\n    // test exceptions rendering\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException1;\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException2;\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException3;\n\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException4;\n\n    [Test]\n    [Category('renders,exceptions')]\n    [TestCase('404'+'invalid_accept',               '404,/invalidurl,invalid_accept,' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('404'+TMVCMediaType.TEXT_HTML,        '404,/invalidurl,' + TMVCMediaType.TEXT_HTML + ',' + TMVCMediaType.TEXT_HTML)]\n    [TestCase('404'+TMVCMediaType.TEXT_PLAIN,       '404,/invalidurl,' +  TMVCMediaType.TEXT_PLAIN + ',' + TMVCMediaType.TEXT_PLAIN)]\n    [TestCase('404'+TMVCMediaType.APPLICATION_JSON, '404,/invalidurl,' + TMVCMediaType.APPLICATION_JSON + ',' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('500'+'invalid_accept',               '500,/exception/emvcexception1,invalid_accept,' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('500'+TMVCMediaType.TEXT_HTML,        '500,/exception/emvcexception1,' + TMVCMediaType.TEXT_HTML + ',' + TMVCMediaType.TEXT_HTML)]\n    [TestCase('500'+TMVCMediaType.TEXT_PLAIN,       '500,/exception/emvcexception1,' +  TMVCMediaType.TEXT_PLAIN + ',' + TMVCMediaType.TEXT_PLAIN)]\n    [TestCase('500'+TMVCMediaType.APPLICATION_JSON, '500,/exception/emvcexception1,' + TMVCMediaType.APPLICATION_JSON + ',' + TMVCMediaType.APPLICATION_JSON)]\n\n    procedure TestResponseContentTypes(\n        const ExpectedStatus: Integer;\n        const URL: String;\n        const RequestAccept: String;\n        const ResponseContentType: String);\n\n    // test nullables\n    [Test]\n    procedure TestDeserializeNullablesWithValue;\n    [Test]\n    procedure TestDeserializeNullablesWithNulls;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables_ISSUE_362;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables_Passing_Integers_InsteadOf_Floats;\n\n    //test sqids\n    [Test]\n    [TestCase('1', '1,Im1JUf')]\n    [TestCase('2','1234567890,LhXiwKz')]\n    [TestCase('3','9007199254740991,PTP7uQmcmk')]\n    procedure TestSqidSingle(IntValue: UInt64; Sqid: String);\n\n    [Test]\n    procedure TestWrongSqid;\n\n    [Test]\n    procedure TestInvalidConverter;\n\n    // test responses objects\n    [Test]\n    procedure TestResponseCreated;\n    [Test]\n    procedure TestResponseNoContent;\n    [Test]\n    procedure TestResponseAccepted;\n\n    // test web server\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryTraversal1;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryTraversal2;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryRedirect;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestFileWithFolderName;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestSPASupport;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestGetInject10;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestGetInject20;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject30;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject40;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject50;\n\n    // test server side views\n    [Test]\n    procedure TestViewDataViewDataSet;\n\n    // test functional actions\n    [Test]\n    procedure TestFuncActionGetSingleRecord;\n\n    [Test]\n    procedure TestFuncActionGetMultipleRecords;\n\n    [Test]\n    procedure TestFuncActionGetDatasetSingle;\n\n    [Test]\n    procedure TestFuncActionGetDatasetMultiple;\n\n    [Test]\n    procedure TestFuncActionGetComplexObject;\n\n\n    // test functional actions with IMVCResponse and the MVCResponseBuilder\n    [Test]\n    procedure TestGetMVCResponseSimple;\n\n    [Test]\n    procedure TestGetMVCResponseWithJSON;\n\n    [Test]\n    procedure TestGetMVCResponseWithObjectList;\n\n    [Test]\n    procedure TestGetMVCResponseWithDataAndMessage;\n\n    [Test]\n    procedure TestGetMVCResponseSimpleBuilderWithHeaders;\n\n    // test issues\n    [Test]\n    [Category('renders')]\n    procedure TestIssue406;\n\n    [Test]\n    procedure TestIssue542;\n\n  end;\n\n  [TestFixture]\n  [Category('jsonrpc')]\n  TJSONRPCServerTest = class(TObject)\n  protected\n    FExecutor: IMVCJSONRPCExecutor;\n    FExecutor2: IMVCJSONRPCExecutor;\n    FExecutor3: IMVCJSONRPCExecutor;\n    procedure InitExecutors; virtual;\n  public\n    [Setup]\n    procedure Setup; virtual;\n    [Test]\n    procedure TestRequestWithoutParams;\n    [Test]\n    procedure TestNotificationWithoutParams;\n    [Test]\n    procedure TestNotificationWhichRaisesError;\n    [Test]\n    procedure TestRequestToNotFoundMethod;\n    [Test]\n    procedure TestRequestWithParams_I_I_ret_I;\n    [Test]\n    procedure TestRequestWithNamedParams_I_I_ret_I;\n    [Test]\n    procedure TestRequestWithParams_I_I_I_ret_O;\n    [Test]\n    procedure TestRequestWithNamedParams_I_I_I_ret_O;\n    [Test]\n    procedure TestRequestWithWrongNamedParams;\n    [Test]\n    procedure TestRequest_S_I_ret_S;\n    [Test]\n    procedure TestRequest_NamedParams_S_I_ret_S;\n    [Test]\n    procedure TestRequestWithParams_I_I_ret_A;\n    [Test]\n    procedure TestRequestWithParams_DT_T_ret_DT;\n    // objects tests\n    [Test]\n    procedure TestRequestWithObjectParameters;\n    // exception tests\n    [Test]\n    procedure TestRequestWithException;\n    // hooks tests\n    [Test]\n    procedure TestHooks;\n    [Test]\n    procedure TestHooksWhenMethodRaisesError;\n    [Test]\n    procedure TestHooksWhenOnAfterCallHookRaisesError;\n    [Test]\n    procedure TestHooksNotif;\n    [Test]\n    procedure TestHooksNotifWhenOnBeforeRoutingHookRaisesError;\n    [Test]\n    procedure TestHooksNotifWhenOnBeforeCallHookRaisesError;\n    [Test]\n    procedure TestHooksNotifWhenOnAfterCallHookRaisesError;\n    [Test]\n    procedure TestHooksWhenOnBeforeCallHookRaisesError;\n    [Test]\n    procedure TestHooksWhenOnBeforeRoutingHookRaisesError;\n    //record tests\n    [Test]\n    procedure TestRequest_NoParams_SingleRecordAsResult;\n    [Test]\n    procedure TestRequest_NoParams_SingleComplexRecordAsResult;\n    [Test]\n    procedure TestRequest_Echo_SingleRecordAsResult;\n    [Test]\n    procedure TestRequest_Echo_ComplexRecord;\n    [Test]\n    procedure TestRequest_Echo_ComplexRecords;\n    [Test]\n    procedure TestRequest_NoParams_DynamicArrayOfRecordAsResult;\n    //enum tests\n    [Test]\n    procedure TestEnum;\n    [Test]\n    procedure TestInvalidEnum;\n    //set tests\n    [Test]\n    procedure TestSet;\n    [Test]\n    procedure TestInvalidSet;\n\n    //test issues\n    [Test]\n    procedure TestGetTCustomer_ISSUE648;\n\n  end;\n\n  [TestFixture]\n  [Category('jsonrpc')]\n  TJSONRPCServerWithGETTest = class(TJSONRPCServerTest)\n  protected\n    procedure InitExecutors; override;\n  end;\n\nimplementation\n\nuses\n  System.TypInfo,\n  System.Math,\n  System.JSON,\n  MVCFramework.Serializer.Defaults,\n  JsonDataObjects,\n  MVCFramework.Serializer.JsonDataObjects,\n  System.SyncObjs,\n  System.Generics.Collections,\n  System.SysUtils,\n  BusinessObjectsU,\n  MVCFramework.Serializer.Commons,\n  Soap.EncdDecd,\n  System.Classes,\n  MVCFramework.SystemJSONUtils,\n  IdCookie,\n  MVCFramework.JSONRPC,\n  MVCFramework.Serializer.Intf\n{$IFDEF MSWINDOWS}\n    ,\n  MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes,\n  Vcl.Graphics\n{$ENDIF}\n    , TestConstsU, MVCFramework.Tests.Serializer.Entities,\n  MVCFramework.Logger, System.IOUtils, MVCFramework.Utils,\n  System.Net.HttpClient, System.Net.URLClient;\n\nfunction GetServer: string;\nbegin\n  Result := 'http://' + TEST_SERVER_ADDRESS + ':8888';\nend;\n\n{ TServerTest }\n\nprocedure TBaseServerTest.DoLogout;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/logout');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Logout Failed: ' + res.Content);\nend;\n\nprocedure TBaseServerTest.Setup;\nbegin\n  inherited;\n  RESTClient := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  RESTClient\n    .ReadTimeout(60 * 1000 * 30)\n    .ProxyServer('localhost')\n    .ProxyPort(8080);\nend;\n\nprocedure TBaseServerTest.TearDown;\nbegin\n  inherited;\n  RESTClient := nil;\nend;\n\nprocedure TServerTest.TestActionFiltersOnBeforeAction;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/actionfilters/beforeaction/alwayscalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n\n  res := RESTClient.Get('/actionfilters/beforeaction/nevercalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, res.StatusCode);\nend;\n\nprocedure TServerTest.TestAsynchRequestDELETE;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  OK: boolean;\nbegin\n  OK := false;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        OK := true;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n        OK := false;\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Delete('/req/with/params/($par1)/($par2)/($par3)');\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.areEqual(true, OK);\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestGET;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Get('/req/with/params/($par1)/($par2)/($par3)');\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('1', j.Get('par1').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestPOST;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Post('/echo/($par1)/($par2)/($par3)',\n      TSystemJSON.JSONValueToString(System.JSON.TJSONObject.Create(TJSONPair.Create('from client',\n      'hello world'))));\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('from server', j.Get('echo').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestPUT;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Put('/echo/($par1)/($par2)/($par3)',\n      TSystemJSON.JSONValueToString(System.JSON.TJSONObject.Create(System.JSON.TJSONPair.Create\n      ('from client', 'hello world'))));\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('from server', j.Get('echo').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestBasicAuth01;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  Assert.areEqual('Basic dXNlcjE6dXNlcjE=', RESTClient.Authorization);\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth02;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth03;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  lRes := RESTClient.Get('/private/role2');\n  Assert.areEqual<Integer>(HTTP_STATUS.Forbidden, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth04;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/people');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth05;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n\n  // first\n  lRes := RESTClient.Get('/private/role1session?value=danieleteti');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/private/role1session');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  Assert.areEqual('danieleteti', lRes.Content);\n\n  // second\n  lRes := RESTClient.Get('/private/role1session?value=johndoe');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/private/role1session');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  Assert.areEqual('johndoe', lRes.Content);\nend;\n\nprocedure TServerTest.TestControllerWithExceptionInCreate(const URLSegment: string);\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON).Get(URLSegment);\n  Assert.areEqual(HTTP_STATUS.InternalServerError, res.StatusCode);\n  // Assert.Contains(res.ContentType, 'text/plain', true, 'Is not a text/plain in case of error');\n  Assert.Contains(res.ContentType, 'application/json', true,\n    'Is not a application/json in case of error');\n  Assert.Contains(res.Content, 'Cannot create controller', true,\n    'Exception message in body is not correct');\n  // Assert.Contains(res.BodyAsString, 'Cannot create controller', true, 'Exception message in body is not correct');\nend;\n\nprocedure TServerTest.TestCookies;\nvar\n  res: IMVCRESTResponse;\n  I: Integer;\nbegin\n  res := RESTClient.Get('/lotofcookies');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual<Integer>(4, res.Cookies.Count, 'Wrong number of cookies');\n  for I := 0 to 3 do\n  begin\n    Assert.areEqual('usersettings' + IntToStr(I + 1), res.Cookies[I].Name);\n    Assert.areEqual('usersettings' + IntToStr(I + 1) + '-value', res.Cookies[I].Value);\n    Assert.areEqual('/usersettings' + IntToStr(I + 1) + '/', res.Cookies[I].Path);\n  end;\n\nend;\n\nprocedure TServerTest.TestCustomAuthRequestWithoutLogin;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/privatecustom/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\n  Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGIN-URL'));\n  Assert.areEqual('POST', lRes.HeaderValue('X-LOGIN-METHOD'));\n\n  lRes := RESTClient.Get('/privatecustom/role2');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\n  Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGIN-URL'));\n  Assert.areEqual('POST', lRes.HeaderValue('X-LOGIN-METHOD'));\nend;\n\nprocedure TServerTest.TestCustomAuthRequestsWithValidLogin;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\n  lCookieValue: string;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    lJSON.AddPair('username', 'user1');\n    lJSON.AddPair('password', 'user1');\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n    Assert.areEqual('application/json', lRes.ContentType);\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n    Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGOUT-URL'));\n    Assert.areEqual('DELETE', lRes.HeaderValue('X-LOGOUT-METHOD'));\n    Assert.areEqual('{\"status\":\"OK\"}', lRes.Content);\n    lCookieValue := lRes.CookieByName(TMVCConstants.SESSION_TOKEN_NAME).Value;\n    Assert.AreNotEqual('', lCookieValue, 'Session cookie not returned after login');\n    Assert.IsFalse(lCookieValue.Contains('invalid'), 'Returned an invalid session token');\n\n    lRes := RESTClient.Get('/privatecustom/role2');\n    Assert.areEqual<Integer>(HTTP_STATUS.Forbidden, lRes.StatusCode,\n      'Authorization not respected for not allowed action');\n\n    lRes := RESTClient.Get('/privatecustom/role1');\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode,\n      'Authorization not respected for allowed action');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomAuthRequestsWithValidLogin_HTML;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\n  lCookieValue: string;\n  lContentType: string;\n  lContentCharset: string;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    lJSON.AddPair('username', 'user1');\n    lJSON.AddPair('password', 'user1');\n    lRes := RESTClient.Accept('text/html').Post('/system/users/logged',\n      TSystemJSON.JSONValueToString(lJSON, false));\n    SplitContentMediaTypeAndCharset(lRes.ContentType, lContentType, lContentCharset);\n    Assert.areEqual(lContentType, TMVCMediaType.APPLICATION_JSON);\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n    Assert.areEqual('/system/users/logged', lRes.HeaderVa", "output": "using System;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing NUnit.Framework;\nusing Newtonsoft.Json.Linq; \n\nnamespace LiveServerTests\n{\n    public interface IRestClient\n    {\n        \n        IRestClient BaseUrl(string host, int port);\n        IRestClient Accept(string mediaType);\n        IRestClient AddHeader(string name, string value);\n        IRestClient AddPathParam(string name, object value);\n        IRestClient AddQueryStringParam(string name, object value);\n        IRestClient AddCookie(string name, string value);\n        Task<IRestResponse> GetAsync(string url);\n        Task<IRestResponse> PostAsync(string url, string body, string contentType = null);\n        Task<IRestResponse> PutAsync(string url, string body, string contentType = null);\n        Task<IRestResponse> DeleteAsync(string url);\n        IRestClient ClearHeaders();\n        \n    }\n\n    public interface IRestResponse\n    {\n        int StatusCode { get; }\n        string StatusText { get; }\n        string Content { get; }\n        string ContentType { get; }\n        long ContentLength { get; }\n        string GetHeaderValue(string name);\n        \n        JObject ToJObject();\n        JArray ToJArray();\n    }\n\n    public abstract class BaseServerTest\n    {\n        protected IRestClient RestClient;\n        protected const string TEST_SERVER_ADDRESS = \"127.0.0.1\";\n\n        [SetUp]\n        public virtual void Setup()\n        {\n            \n            RestClient = RestClientFactory.Create()\n                          .BaseUrl(TEST_SERVER_ADDRESS, 8888);\n            \n        }\n\n        [TearDown]\n        public virtual void TearDown()\n        {\n            RestClient = null;\n        }\n\n        protected async Task DoLoginWithAsync(string userName)\n        {\n            \n            var response = await RestClient.AddPathParam(\"username\", userName)\n                                           .GetAsync(\"/login/{username}\");\n            Assert.That(response.StatusCode, Is.EqualTo(200), \"Login Failed: \" + response.Content);\n        }\n\n        protected async Task DoLogoutAsync()\n        {\n            var response = await RestClient.GetAsync(\"/logout\");\n            Assert.That(response.StatusCode, Is.EqualTo(200), \"Logout Failed: \" + response.Content);\n        }\n    }\n\n    [TestFixture]\n    public class ServerTest : BaseServerTest\n    {\n        \n        [Test]\n        [TestCase(\"/exception/fault\")]\n        [TestCase(\"/exception/fault2\")]\n        public async Task TestControllerWithExceptionInCreate(string urlSegment)\n        {\n            \n            var response = await RestClient.Accept(\"application/json\")\n                                           .GetAsync(urlSegment);\n            Assert.That(response.StatusCode, Is.EqualTo(500));\n            Assert.That(response.ContentType, Does.Contain(\"application/json\"));\n            Assert.That(response.Content, Does.Contain(\"Cannot create controller\"));\n        }\n\n        [Test]\n        [TestCase(\"/\")]\n        [TestCase(\"/action1\")]\n        [TestCase(\"/action2\")]\n        [TestCase(\"/api/v1\")]\n        [TestCase(\"/api/v1/action1\")]\n        [TestCase(\"/api/v1/action2\")]\n        [TestCase(\"/api/v2\")]\n        [TestCase(\"/api/v2/action1\")]\n        [TestCase(\"/api/v2/action2\")]\n        public async Task TestMultiMVCPathOnControllerAndAction(string urlSegment)\n        {\n            var response = await RestClient.GetAsync(urlSegment);\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n        }\n\n        [Test]\n        public async Task TestReqWithParams()\n        {\n            \n            var response = await RestClient.GetAsync(\"/unknownurl/bla/bla\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.GetAsync(\"/req/with/params/\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.GetAsync(\"/req/with/params\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.AddPathParam(\"par1\", \"1\")\n                                       .AddPathParam(\"par2\", \"2\")\n                                       .AddPathParam(\"par3\", \"3\")\n                                       .GetAsync(\"/req/with/params/($par1)/($par2)/($par3)\");\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n\n            \n            JObject json = response.ToJObject();\n            Assert.That(json.Value<string>(\"par1\"), Is.EqualTo(\"1\"));\n            Assert.That(json.Value<string>(\"par2\"), Is.EqualTo(\"2\"));\n            Assert.That(json.Value<string>(\"par3\"), Is.EqualTo(\"3\"));\n            Assert.That(json.Value<string>(\"method\"), Is.EqualTo(\"GET\"));\n\n            \n            response = await RestClient.AddPathParam(\"par1\", \"1\")\n                                       .AddPathParam(\"par2\", \"2\")\n                                       .AddPathParam(\"par3\", \"3\")\n                                       .DeleteAsync(\"/req/with/params/($par1)/($par2)/($par3)\");\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n            json = response.ToJObject();\n            Assert.That(json.Value<string>(\"par1\"), Is.EqualTo(\"1\"));\n            Assert.That(json.Value<string>(\"par2\"), Is.EqualTo(\"2\"));\n            Assert.That(json.Value<string>(\"par3\"), Is.EqualTo(\"3\"));\n            Assert.That(json.Value<string>(\"method\"), Is.EqualTo(\"DELETE\"));\n        }\n\n        \n        [Test]\n        public async Task TestPOSTWithParamsAndJSONBody()\n        {\n            JObject jsonBody = new JObject\n            {\n                [\"client\"] = \"clientdata\"\n            };\n            var response = await RestClient.AddPathParam(\"par1\", 1)\n                                           .AddPathParam(\"par2\", 2)\n                                           .AddPathParam(\"par3\", 3)\n                                           .PostAsync(\"/echo/($par1)/($par2)/($par3)\",\n                                                      jsonBody.ToString());\n            JObject jsonResponse = JObject.Parse(response.Content);\n            Assert.That(jsonResponse.Value<string>(\"client\"), Is.EqualTo(\"clientdata\"));\n            Assert.That(jsonResponse.Value<string>(\"echo\"), Is.EqualTo(\"from server\"));\n        }\n\n        \n    }\n\n    [TestFixture]\n    [Category(\"jsonrpc\")]\n    public class JSONRPCServerTest\n    {\n        \n        private IJSONRPCExecutor _executor;\n        private IJSONRPCExecutor _executor2;\n        private IJSONRPCExecutor _executor3;\n\n        [SetUp]\n        public void Setup()\n        {\n            \n            _executor = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpc\", false);\n            _executor2 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass\", false);\n            _executor3 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass1\", false);\n\n            \n            _executor.SetOnSendCommand((jsonRequest) => Console.WriteLine(\"[JSONRPC REQUEST] : \" + jsonRequest));\n            _executor.SetOnReceiveHTTPResponse((httpResponse) => Console.WriteLine(\"[JSONRPC RESPONSE]: \" + httpResponse.Content));\n        }\n\n        [Test]\n        public void TestRequestWithoutParams()\n        {\n            var request = new JSONRPCRequest(1234, \"MyRequest\");\n            var response = _executor.ExecuteRequest(request);\n            Assert.IsFalse(response.IsError);\n            Assert.IsTrue(response.Result.AsBoolean);\n        }\n\n        \n    }\n\n    [TestFixture]\n    [Category(\"jsonrpc\")]\n    public class JSONRPCServerWithGETTest : JSONRPCServerTest\n    {\n        [SetUp]\n        public new void Setup()\n        {\n            \n            _executor = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcwithget\", false, JSONRPCMethodType.Get);\n            _executor2 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclasswithget\", false, JSONRPCMethodType.Get);\n            _executor3 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass1withget\", false, JSONRPCMethodType.Get);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Patches;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes\n{$IFDEF SYSTEMJSON}\n    , System.JSON\n{$ENDIF}\n{$IFNDEF SYSTEMJSON} // XE6\n    , Data.DBXJSON\n{$ENDIF}\n    ;\n\n{$IFNDEF TOJSON}\n\n\ntype\n  TJSONValueHelper = class helper for TJSONValue\n  public\n    function GetItem(const Index: Integer): TJSONValue;\n    function ToJSON: String;\n    function Count: Integer;\n    property Items[const Index: Integer]: TJSONValue read GetItem;\n  end;\n{$ENDIF}\n\nimplementation\n\n{ TJSONValueHelper }\n\n{$IFNDEF TOJSON}\n\n\nfunction TJSONValueHelper.Count: Integer;\nbegin\n  Result := Size;\nend;\n\nfunction TJSONValueHelper.GetItem(const Index: Integer): TJSONValue;\nbegin\n  Result := Get(Index);\nend;\n\nfunction TJSONValueHelper.ToJSON: String;\nbegin\n  Result := Self.ToString;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.Patches\n{\n    \n    public static class JsonValueExtensions\n    {\n        \n        public static JToken GetItem(this JToken token, int index)\n        {\n            if (token is JArray array)\n            {\n                return array[index];\n            }\n            throw new InvalidOperationException(\"JToken is not an array; cannot use indexer.\");\n        }\n\n        \n        public static string ToJSON(this JToken token)\n        {\n            \n            return token.ToString();\n        }\n\n        \n        public static int Count(this JToken token)\n        {\n            if (token is JArray array)\n            {\n                return array.Count;\n            }\n            if (token is JObject obj)\n            {\n                return obj.Count;\n            }\n            throw new InvalidOperationException(\"JToken does not have a count (not an array or object).\");\n        }\n    }\n}"}
{"input": "unit WinesBO;\n\n{ ** Note: In case of Delphi clients you can share the units containing the business objects\n  between client and server. This is not required, and could lead to difficult\n  dependencies schemas in buig project. In this demo this file is shared between\n  clients and server. }\n\ninterface\n\nuses System.Generics.Collections, MVCFramework.Serializer.Commons;\n\ntype\n\n  [MVCNameCase(ncLowerCase)]\n  TWine = class\n  private\n    FYEAR: string;\n    FNAME: string;\n    FPICTURE: string;\n    FGRAPES: string;\n    FID: integer;\n    FDESCRIPTION: string;\n    FCOUNTRY: string;\n    FREGION: string;\n    procedure SetCOUNTRY(const Value: string);\n    procedure SetDESCRIPTION(const Value: string);\n    procedure SetGRAPES(const Value: string);\n    procedure SetID(const Value: integer);\n    procedure SetNAME(const Value: string);\n    procedure SetPICTURE(const Value: string);\n    procedure SetREGION(const Value: string);\n    procedure SetYEAR(const Value: string);\n\n  public\n    property id: integer read FID write SetID;\n    property name: string read FNAME write SetNAME;\n    property year: string read FYEAR write SetYEAR;\n    property grapes: string read FGRAPES write SetGRAPES;\n    property country: string read FCOUNTRY write SetCOUNTRY;\n    property region: string read FREGION write SetREGION;\n    property description: string read FDESCRIPTION write SetDESCRIPTION;\n    property picture: string read FPICTURE write SetPICTURE;\n  end;\n\n  TWines = class(TObjectList<TWine>)\n    constructor Create;\n  end;\n\nimplementation\n\n{ TWine }\n\nprocedure TWine.SetCOUNTRY(const Value: string);\nbegin\n  FCOUNTRY := Value;\nend;\n\nprocedure TWine.SetDESCRIPTION(const Value: string);\nbegin\n  FDESCRIPTION := Value;\nend;\n\nprocedure TWine.SetGRAPES(const Value: string);\nbegin\n  FGRAPES := Value;\nend;\n\nprocedure TWine.SetID(const Value: integer);\nbegin\n  FID := Value;\nend;\n\nprocedure TWine.SetNAME(const Value: string);\nbegin\n  FNAME := Value;\nend;\n\nprocedure TWine.SetPICTURE(const Value: string);\nbegin\n  FPICTURE := Value;\nend;\n\nprocedure TWine.SetREGION(const Value: string);\nbegin\n  FREGION := Value;\nend;\n\nprocedure TWine.SetYEAR(const Value: string);\nbegin\n  FYEAR := Value;\nend;\n\n{ TWines }\n\nconstructor TWines.Create;\nbegin\n  inherited Create(True);\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing MVCFramework.Serializer.Commons;\n\nnamespace WinesBO\n{\n    [MVCNameCase(\"ncLowerCase\")]\n    public class Wine\n    {\n        private string _year;\n        private string _name;\n        private string _picture;\n        private string _grapes;\n        private int _id;\n        private string _description;\n        private string _country;\n        private string _region;\n\n        public int Id { get => _id; set => _id = value; }\n        public string Name { get => _name; set => _name = value; }\n        public string Year { get => _year; set => _year = value; }\n        public string Grapes { get => _grapes; set => _grapes = value; }\n        public string Country { get => _country; set => _country = value; }\n        public string Region { get => _region; set => _region = value; }\n        public string Description { get => _description; set => _description = value; }\n        public string Picture { get => _picture; set => _picture = value; }\n    }\n\n    public class Wines : List<Wine>\n    {\n        public Wines() : base() { }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.FileAppender;\n\n{$IF Defined(Android) or Defined(iOS)}\n{$DEFINE MOBILE}\n{$ENDIF}\n\ninterface\n\nuses\n  LoggerPro,\n  System.Generics.Collections,\n  System.Classes,\n  System.SysUtils;\n\ntype\n  {\n    @abstract(Logs to file using one different file for each different TAG used.)\n    @author(Daniele Teti - d.teti@bittime.it)\n    Implements log rotations.\n    This appender is the default appender when no configuration is done on the @link(TLogger) class.\n\n    Without any configuration LoggerPro uses the @link(TLoggerProFileAppender) with the default configuration.\n\n    So the following two blocks of code are equivalent:\n\n    @longcode(#\n    ...\n    TLogger.Initialize; //=> uses the TLoggerProFileAppender because no other configuration is provided\n    ...\n\n    ...\n    TLogger.AddAppender(TLoggerProFileAppender.Create);\n    TLogger.Initialize //=> uses the TLoggerProFileAppender as configured\n    ...\n    #)\n\n  }\n\n  { @abstract(The base class for different file appenders)\n    Do not use this class directly, but one of TLoggerProFileAppender or TLoggerProSimpleFileAppender.\n    Check the sample @code(file_appender.dproj)\n  }\n  TLoggerProFileAppenderBase = class(TLoggerProAppenderBase)\n  private\n    procedure RetryMove(const aFileSrc, aFileDest: string);\n    procedure RetryDelete(const aFileSrc: string);\n  protected\n    fEncoding: TEncoding;\n    fMaxBackupFileCount: Integer;\n    fMaxFileSizeInKiloByte: Integer;\n    fLogFileNameFormat: string;\n    fLogsFolder: string;\n    function CreateWriter(const aFileName: string; const aBufferSize: Integer = 32): TStreamWriter;\n    procedure CheckLogFileNameFormat(const LogFileNameFormat: String); virtual;\n    procedure EmitStartRotateLogItem(aWriter: TStreamWriter); virtual;\n    procedure EmitEndRotateLogItem(aWriter: TStreamWriter); virtual;\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; virtual;\n    procedure WriteToStream(const aStreamWriter: TStreamWriter; const aValue: string); inline;\n    procedure RotateFile(const aLogTag: string; out aNewFileName: string); virtual;\n    procedure InternalWriteLog(const aStreamWriter: TStreamWriter; const aLogItem: TLogItem);\n  public const\n    { @abstract(Defines the default format string used by the @link(TLoggerProFileAppender).)\n      The positional parameters are the following:\n      @orderedList(\n      @item Number\n      @item Module\n      @item Tag\n      )\n    }\n    DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n    DEFAULT_FILENAME_FORMAT_WITH_PID = '{module}.{number}.{pid}.{tag}.log';\n    DEFAULT_FILENAME_FORMAT_WITHOUT_TAG = '{module}.{number}.log';\n    { @abstract(Defines number of log file set to maintain during logs rotation) }\n    DEFAULT_MAX_BACKUP_FILE_COUNT = 5;\n    { @abstract(Defines the max size of each log file)\n      The actual meaning is: \"If the file size is > than @link(DEFAULT_MAX_FILE_SIZE_KB) then rotate logs. }\n    DEFAULT_MAX_FILE_SIZE_KB = 1000;\n    { @abstract(Milliseconds to wait between the RETRY_COUNT times. }\n    RETRY_DELAY = 200;\n    { @abstract(How many times do we have to retry if the file is locked?. }\n    RETRY_COUNT = 5;\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT;\n      aLogItemRenderer: ILogItemRenderer = nil;\n      aEncoding: TEncoding = nil);\n      reintroduce; virtual;\n    procedure Setup; override;\n  end;\n\n  { @abstract(The default file appender)\n    This file appender separates TLogItems with different tags into a log file for each tag.\n    To learn how to use this appender, check the sample @code(file_appender.dproj)\n  }\n  TLoggerProFileAppender = class(TLoggerProFileAppenderBase)\n  private\n    fWritersDictionary: TObjectDictionary<string, TStreamWriter>;\n    procedure AddWriter(const aLogTag: string; var aWriter: TStreamWriter; var aLogFileName: string);\n    procedure RotateLog(const aLogTag: string; aWriter: TStreamWriter);\n  public\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); overload; override;\n  end;\n\n  { @abstract(File appender with multiple tags)\n    This file appender writes all TLogItems into a single log file.\n    Combined with a @code(TLoggerProAppenderFilterImpl) you can filter out any log tags you like.\n    If you want to run several TLoggerProSimpleFileAppender in parallel you have to provide a different\n    LogFileFormat for each of them in the constructor in order to prevent name collisions.\n    To learn how to use this appender, check the sample @code(file_appender.dproj)\n  }\n  TLoggerProSimpleFileAppender = class(TLoggerProFileAppenderBase)\n  private\n    fFileWriter: TStreamWriter;\n    procedure RotateLog;\n  protected\n    procedure CheckLogFileNameFormat(const LogFileNameFormat: String); override;\n  public\n  const\n    DEFAULT_FILENAME_FORMAT = '{module}.{number}.log';\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); overload; override;\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT;\n      aLogItemRenderer: ILogItemRenderer = nil;\n      aEncoding: TEncoding = nil);\n      override;\n  end;\n\n\n  TMakeFileNameProc = reference to procedure(out AFileName: string);\n\n  { by an idea of Mark Lobanov <mark.v.lobanov@gmail.com> }\n  TLoggerProFileByFolderAppender = class(TLoggerProFileAppender)\n  private\n    fFileWriter: TStreamWriter;\n    fCurrentDate: TDateTime;\n    function GetLogFolder: string;\n    function GetFileFormat: string;\n    procedure RotateLog;\n    procedure ChangeLogFolder;\n    procedure RefreshCurrentDate;\n    procedure InternalRotateLog(aMakeFileNameProc: TMakeFileNameProc);\n  protected\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; override;\n    procedure CheckLogFileNameFormat(const aLogFileNameFormat: string); override;\n  public\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      const aLogsFolder: string = '';\n      const aLogItemRenderer: ILogItemRenderer = nil;\n      const aEncoding: TEncoding = nil); reintroduce;\n\n    procedure WriteLog(const ALogItem: TLogItem); override;\n    procedure Setup; override;\n    procedure TearDown; override;\n  end;\n\n  TLoggerProLogFmtFileAppender = class(TLoggerProSimpleFileAppender)\n  protected\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; override;\n    procedure EmitStartRotateLogItem(aWriter: TStreamWriter); override;\n    procedure EmitEndRotateLogItem(aWriter: TStreamWriter); override;\n  public\n    constructor Create(aMaxBackupFileCount: Integer = TLoggerProFileAppender.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppender.DEFAULT_MAX_FILE_SIZE_KB; aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT; aEncoding: TEncoding = nil);\n      reintroduce;\n  end;\n\nimplementation\n\nuses\n  System.IOUtils,\n  System.StrUtils,\n  System.Math,\n  System.DateUtils,\n  LoggerPro.Renderers,\n  idGlobal\n{$IF Defined(Android)}\n    ,Androidapi.Helpers\n    ,Androidapi.JNI.GraphicsContentViewText\n    ,Androidapi.JNI.JavaTypes\n{$ENDIF}\n    ;\n\n\nfunction OccurrencesOfChar(const S: string; const C: char): integer;\nvar\n  i: Integer;\nbegin\n  result := 0;\n  for i := 1 to Length(S) do\n    if S[i] = C then\n      inc(result);\nend;\n\nprocedure TLoggerProFileAppenderBase.CheckLogFileNameFormat(const LogFileNameFormat: String);\nbegin\n  //DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n  if not (LogFileNameFormat.Contains('{number}') and LogFileNameFormat.Contains('{tag}')) then\n  begin\n    raise ELoggerPro.CreateFmt('Wrong FileFormat [%s] - [HINT] A correct file format for %s requires {number} and {tag} placeholders ({module} is optional). A valid file format is : %s',\n      [\n        ClassName,\n        LogFileNameFormat,\n        TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT\n      ]);\n  end;\nend;\n\n\n{ TLoggerProFileAppenderBase }\n\nfunction TLoggerProFileAppenderBase.GetLogFileName(const aTag: string; const aFileNumber: Integer): string;\nvar\n  lModuleName: string;\n  lPath: string;\n  lFormat: string;\nbegin\n{$IF Defined(Android)}\n  lModuleName := TAndroidHelper.ApplicationTitle.Replace(' ', '_', [rfReplaceAll]);\n{$ENDIF}\n{$IF not Defined(Mobile)}\n  lModuleName := TPath.GetFileNameWithoutExtension(GetModuleName(HInstance));\n{$ENDIF}\n{$IF Defined(IOS)}\n  raise Exception.Create('Platform not supported');\n{$ENDIF}\n  lFormat := fLogFileNameFormat;\n\n  lPath := fLogsFolder;\n  lFormat := lFormat\n    .Replace('{module}', lModuleName, [rfReplaceAll])\n    .Replace('{number}', aFileNumber.ToString.PadLeft(\n      Max(2,fMaxBackupFileCount.ToString.Length), //min padding 2\n      '0') , [rfReplaceAll])\n    .Replace('{tag}', aTag, [rfReplaceAll])\n    .Replace('{pid}', CurrentProcessId.ToString.PadLeft(8,'0'), [rfReplaceAll]);\n  Result := TPath.Combine(lPath, lFormat);\nend;\n\nprocedure TLoggerProFileAppenderBase.Setup;\nbegin\n  inherited;\n\n  if fLogsFolder = '' then\n  begin\n{$IF (Defined(MSWINDOWS) or Defined(POSIX)) and (not Defined(MOBILE))}\n    fLogsFolder := TPath.GetDirectoryName(GetModuleName(HInstance));\n{$ENDIF}\n{$IF Defined(Android) or Defined(IOS)}\n    fLogsFolder := TPath.GetSharedDocumentsPath();\n{$ENDIF}\n  end;\n  if not TDirectory.Exists(fLogsFolder) then\n    TDirectory.CreateDirectory(fLogsFolder);\nend;\n\nprocedure TLoggerProFileAppenderBase.WriteToStream(const aStreamWriter: TStreamWriter; const aValue: string);\nbegin\n  aStreamWriter.WriteLine(aValue);\n  aStreamWriter.Flush;\nend;\n\nprocedure TLoggerProFileAppenderBase.InternalWriteLog(const aStreamWriter: TStreamWriter; const aLogItem: TLogItem);\nbegin\n  WriteToStream(aStreamWriter, FormatLog(aLogItem));\nend;\n\nprocedure TLoggerProFileAppenderBase.RetryDelete(const aFileSrc: string);\nvar\n  lRetries: Integer;\nconst\n  MAX_RETRIES = 5;\nbegin\n  lRetries := 0;\n  repeat\n    try\n      Sleep(50);\n      // the incidence of \"Locked file goes to nearly zero...\"\n      TFile.Delete(aFileSrc);\n      if not TFile.Exists(aFileSrc) then\n      begin\n        Break;\n      end;\n    except\n      on E: Exception do\n      begin\n        Inc(lRetries);\n        Sleep(100);\n      end;\n    end;\n  until lRetries = MAX_RETRIES;\n\n  if lRetries = MAX_RETRIES then\n    raise ELoggerPro.CreateFmt('Cannot delete file %s', [aFileSrc]);\nend;\n\nprocedure TLoggerProFileAppenderBase.RetryMove(const aFileSrc, aFileDest: string);\nvar\n  lRetries: Integer;\nconst\n  MAX_RETRIES = 5;\nbegin\n  lRetries := 0;\n  repeat\n    try\n      Sleep(50);\n      // the incidence of \"Locked file goes to nearly zero...\"\n      TFile.Move(aFileSrc, aFileDest);\n      Break;\n    except\n      on E: EInOutError do\n      begin\n        Inc(lRetries);\n        Sleep(100);\n      end;\n      on E: Exception do\n      begin\n        raise;\n      end;\n    end;\n  until lRetries = MAX_RETRIES;\n\n  if lRetries = MAX_RETRIES then\n    raise ELoggerPro.CreateFmt('Cannot rename %s to %s', [aFileSrc, aFileDest]);\nend;\n\nprocedure TLoggerProFileAppenderBase.RotateFile(const aLogTag: string; out aNewFileName: string);\nvar\n  lRenamedFile: string;\n  I: Integer;\n  lCurrentFileName: string;\nbegin\n  aNewFileName := GetLogFileName(aLogTag, 0);\n  // remove the last file of backup set\n  lRenamedFile := GetLogFileName(aLogTag, fMaxBackupFileCount - 1);\n  if TFile.Exists(lRenamedFile) then\n  begin\n    TFile.Delete(lRenamedFile);\n    if TFile.Exists(lRenamedFile) then // double check for slow file systems\n    begin\n      RetryDelete(lRenamedFile);\n    end;\n  end;\n  // shift the files names\n  for I := fMaxBackupFileCount - 1 downto 1 do\n  begin\n    lCurrentFileName := GetLogFileName(aLogTag, I);\n    lRenamedFile := GetLogFileName(aLogTag, I + 1);\n    if TFile.Exists(lCurrentFileName) then\n    begin\n      RetryMove(lCurrentFileName, lRenamedFile);\n    end;\n  end;\n  lRenamedFile := GetLogFileName(aLogTag, 1);\n  RetryMove(aNewFileName, lRenamedFile);\nend;\n\nconstructor TLoggerProFileAppenderBase.Create(\n  aMaxBackupFileCount: Integer;\n  aMaxFileSizeInKiloByte: Integer;\n  aLogsFolder: string;\n  aLogFileNameFormat: string;\n  aLogItemRenderer: ILogItemRenderer;\n  aEncoding: TEncoding);\nbegin\n  inherited Create(aLogItemRenderer);\n  fLogsFolder := aLogsFolder;\n  fMaxBackupFileCount:= Max(1, aMaxBackupFileCount);\n  fMaxFileSizeInKiloByte := aMaxFileSizeInKiloByte;\n  CheckLogFileNameFormat(aLogFileNameFormat);\n  fLogFileNameFormat := aLogFileNameFormat;\n  if Assigned(aEncoding) then\n    fEncoding := aEncoding\n  else\n    fEncoding := TEncoding.DEFAULT;\nend;\n\nfunction TLoggerProFileAppenderBase.CreateWriter(const aFileName: string; const aBufferSize: Integer = 32): TStreamWriter;\nvar\n  lFileStream: TFileStream;\n  lFileAccessMode: Word;\n  lRetries: Integer;\nbegin\n  lFileAccessMode := fmOpenWrite or fmShareDenyNone;\n  if not TFile.Exists(aFileName) then\n    lFileAccessMode := lFileAccessMode or fmCreate;\n\n  // If the file si still blocked by a precedent execution or\n  // for some other reasons, we try to access the file for 5 times.\n  // If after 5 times (with a bit of delay in between) the file is still\n  // locked, then the exception is raised.\n  lRetries := 0;\n  while true do\n  begin\n    try\n      lFileStream := TFileStream.Create(aFileName, lFileAccessMode);\n      try\n        lFileStream.Seek(0, TSeekOrigin.soEnd);\n        Result := TStreamWriter.Create(lFileStream, fEncoding, aBufferSize);\n        Result.AutoFlush := true;\n        Result.OwnStream;\n        Break;\n      except\n        lFileStream.Free;\n        raise;\n      end;\n    except\n      if lRetries = RETRY_COUNT then\n      begin\n        raise;\n      end\n      else\n      begin\n        Inc(lRetries);\n        Sleep(RETRY_DELAY); // just wait a little bit\n      end;\n    end;\n  end;\nend;\n\n{ TLoggerProFileAppender }\n\nprocedure TLoggerProFileAppender.AddWriter(const aLogTag:string; var aWriter: TStreamWriter; var aLogFileName: string);\nbegin\n  aLogFileName := GetLogFileName(aLogTag, 0);\n  aWriter := CreateWriter(aLogFileName);\n  fWritersDictionary.Add(aLogTag, aWriter);\nend;\n\nprocedure TLoggerProFileAppenderBase.EmitEndRotateLogItem(aWriter: TStreamWriter);\nbegin\n  WriteToStream(aWriter, '#[ROTATE LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppenderBase.EmitStartRotateLogItem(aWriter: TStreamWriter);\nbegin\n  WriteToStream(aWriter, '#[START LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppender.RotateLog(const aLogTag: string; aWriter: TStreamWriter);\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(aWriter);\n  //WriteToStream(aWriter, '#[ROTATE LOG ' + datetimetostr(Now, FormatSettings) + ']');\n  // remove the writer during rename\n  fWritersDictionary.Remove(aLogTag);\n  RotateFile(aLogTag, lLogFileName);\n  // re-create the writer\n  AddWriter(aLogTag, aWriter, lLogFileName);\n  EmitStartRotateLogItem(aWriter);\n  //WriteToStream(aWriter, '#[START LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppender.Setup;\nbegin\n  inherited;\n  fWritersDictionary := TObjectDictionary<string, TStreamWriter>.Create([doOwnsValues]);\nend;\n\nprocedure TLoggerProFileAppender.TearDown;\nbegin\n  fWritersDictionary.Free;\n  inherited;\nend;\n\nprocedure TLoggerProFileAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lWriter: TStreamWriter;\n  lLogFileName:string;\nbegin\n  if not fWritersDictionary.TryGetValue(aLogItem.LogTag, lWriter) then\n  begin\n    AddWriter(aLogItem.LogTag, lWriter, lLogFileName);\n  end;\n\n  InternalWriteLog(lWriter, aLogItem);\n\n  if lWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog(aLogItem.LogTag, lWriter);\n  end;\nend;\n\n{ TLoggerProSimpleFileAppender }\n\nprocedure TLoggerProSimpleFileAppender.CheckLogFileNameFormat(const LogFileNameFormat: String);\nbegin\n  //DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n  if not LogFileNameFormat.Contains('{number}') then\n  begin\n    raise ELoggerPro.CreateFmt('Wrong FileFormat [%s] - [HINT] A correct file format for %s requires {number} placeholder ({module} is optional). A valid file format is : %s',\n      [\n        ClassName,\n        LogFileNameFormat,\n        TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT\n      ]);\n  end;\nend;\n\nconstructor TLoggerProSimpleFileAppender.Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer;\n  aLogsFolder: string; aLogFileNameFormat: String;\n  aLogItemRenderer: ILogItemRenderer;\n  aEncoding: TEncoding);\nbegin\n  inherited Create(\n    aMaxBackupFileCount,\n    aMaxFileSizeInKiloByte,\n    aLogsFolder,\n    aLogFileNameFormat,\n    aLogItemRenderer,\n    aEncoding);\nend;\n\nprocedure TLoggerProSimpleFileAppender.RotateLog;\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(fFileWriter);\n  // remove the writer during rename\n  fFileWriter.Free;\n  RotateFile('', lLogFileName);\n  // re-create the writer\n  fFileWriter := CreateWriter(GetLogFileName('', 0));\n  EmitStartRotateLogItem(fFileWriter);\nend;\n\nprocedure TLoggerProSimpleFileAppender.Setup;\nbegin\n  inherited;\n  fFileWriter := CreateWriter(GetLogFileName('', 0));\nend;\n\nprocedure TLoggerProSimpleFileAppender.TearDown;\nbegin\n  fFileWriter.Free;\n  inherited;\nend;\n\nprocedure TLoggerProSimpleFileAppender.WriteLog(const aLogItem: TLogItem);\nbegin\n  InternalWriteLog(fFileWriter, aLogItem);\n  if fFileWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog;\n  end;\nend;\n\n{ TLoggerProFileByFolderAppender }\n\nconstructor TLoggerProFileByFolderAppender.Create(\n  aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer;\n  const aLogsFolder: string;\n  const aLogItemRenderer: ILogItemRenderer;\n  const aEncoding: TEncoding);\nvar\n  lEncoding: TEncoding;\nbegin\n  if AEncoding = nil then\n    LEncoding := TEncoding.UTF8\n  else\n    LEncoding := AEncoding;\n\n  inherited Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte,\n    aLogsFolder, GetFileFormat, aLogItemRenderer, LEncoding);\n  RefreshCurrentDate;\nend;\n\nprocedure TLoggerProFileByFolderAppender.CheckLogFileNameFormat(const ALogFileNameFormat: string);\nbegin\n  //do nothing, user cannot change filename format in this appender\nend;\n\nfunction TLoggerProFileByFolderAppender.GetLogFolder: string;\nconst\n  LOG_DIR = 'Logs';\nbegin\n  if fLogsFolder.IsEmpty then\n    fLogsFolder := TPath.Combine(TPath.GetDirectoryName({ParamStr(0)} GetModuleName(HInstance)), LOG_DIR)\n  else\n  if not EndsText(LOG_DIR, fLogsFolder) then\n    fLogsFolder := TPath.Combine(FLogsFolder, LOG_DIR);\n  if not TDirectory.Exists(fLogsFolder) then\n    TDirectory.CreateDirectory(fLogsFolder);\n\n  Result := TPath.Combine(fLogsFolder, FormatDateTime('yyyymmdd', Now));\n  if not TDirectory.Exists(Result) then\n    TDirectory.CreateDirectory(Result);\nend;\n\n\nprocedure TLoggerProFileByFolderAppender.InternalRotateLog(aMakeFileNameProc: TMakeFileNameProc);\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(fFileWriter);\n  FreeAndNil(fFileWriter);\n  aMakeFileNameProc(lLogFileName);\n  fFileWriter := CreateWriter(lLogFileName, 16 * 1024);\n  EmitStartRotateLogItem(fFileWriter);\nend;\n\nprocedure TLoggerProFileByFolderAppender.ChangeLogFolder;\nbegin\n  InternalRotateLog(\n    procedure(out AFileName: string)\n    begin\n      AFileName := GetLogFileName(EmptyStr, 0);\n    end\n );\nend;\n\nprocedure TLoggerProFileByFolderAppender.RotateLog;\nbegin\n  InternalRotateLog(\n    procedure(out AFileName: string)\n    begin\n      RotateFile(EmptyStr, AFileName);\n    end\n );\nend;\n\nfunction TLoggerProFileByFolderAppender.GetFileFormat: string;\nbegin\n  Result := TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT_WITHOUT_TAG;\nend;\n\nfunction TLoggerProFileByFolderAppender.GetLogFileName(const ATag: string; const AFileNumber: Integer): string;\nvar\n  lOnlyFileName: String;\nbegin\n  lOnlyFileName := TPath.GetFileName(inherited);\n  Result := TPath.Combine(GetLogFolder, lOnlyFileName);\nend;\n\n\nprocedure TLoggerProFileByFolderAppender.RefreshCurrentDate;\nbegin\n  fCurrentDate := Date;\nend;\n\nprocedure TLoggerProFileByFolderAppender.Setup;\nbegin\n  inherited;\n  fFileWriter := CreateWriter(GetLogFileName(EmptyStr, 0));\n  RefreshCurrentDate;\nend;\n\nprocedure TLoggerProFileByFolderAppender.TearDown;\nbegin\n  fFileWriter.Free;\n  inherited;\nend;\n\nprocedure TLoggerProFileByFolderAppender.WriteLog(const ALogItem: TLogItem);\nvar\n  lLogRow: string;\nbegin\n  if not SameDate(fCurrentDate, Date) then\n  begin\n    ChangeLogFolder;\n    RefreshCurrentDate;\n  end;\n\n  if Assigned(OnLogRow) then\n  begin\n    OnLogRow(ALogItem, lLogRow);\n  end\n  else\n  begin\n    lLogRow := LogItemRenderer.RenderLogItem(ALogItem);\n  end;\n\n  WriteToStream(fFileWriter, lLogRow);\n\n  if fFileWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog;\n  end;\nend;\n\n{ TLoggerProLogFmtFileAppender }\n\nconstructor TLoggerProLogFmtFileAppender.Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer; aLogsFolder,\n  aLogFileNameFormat: string; aEncoding: TEncoding);\nbegin\n  inherited Create(\n    aMaxBackupFileCount,\n    aMaxFileSizeInKiloByte,\n    aLogsFolder,\n    aLogFileNameFormat,\n    TLogItemRendererLogFmt.Create,\n    aEncoding);\nend;\n\nprocedure TLoggerProLogFmtFileAppender.EmitEndRotateLogItem(aWriter: TStreamWriter);\nbegin\n  // do nothing\nend;\n\nprocedure TLoggerProLogFmtFileAppender.EmitStartRotateLogItem(aWriter: TStreamWriter);\nbegin\n  // do nothing\nend;\n\nfunction TLoggerProLogFmtFileAppender.GetLogFileName(const aTag: string; const aFileNumber: Integer): string;\nvar\n  lOrigFName, lOrigExt: string;\nbegin\n  lOrigFName := inherited;\n  lOrigExt := TPath.GetExtension(lOrigFName);\n  if lOrigExt.IsEmpty then\n  begin\n    lOrigExt := '.log';\n  end;\n  Result := TPath.ChangeExtension(lOrigFName, '.logfmt' + lOrigExt);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace LoggerPro.Appenders\n{\n   #region Base Class\n\n   \n   public abstract class LoggerProFileAppenderBase : LoggerProAppenderBase, ILogAppender\n   {\n      \n      public const int DEFAULT_MAX_BACKUP_FILE_COUNT = 5;\n      public const int DEFAULT_MAX_FILE_SIZE_KB = 1000;\n      public const string DEFAULT_FILENAME_FORMAT = \"{module}.{number}.{tag}.log\";\n      public const string DEFAULT_FILENAME_FORMAT_WITH_PID = \"{module}.{number}.{pid}.{tag}.log\";\n      public const string DEFAULT_FILENAME_FORMAT_WITHOUT_TAG = \"{module}.{number}.log\";\n      protected const int RETRY_DELAY = 200;\n      protected const int RETRY_COUNT = 5;\n\n      \n      protected Encoding FileEncoding;\n      protected int MaxBackupFileCount;\n      protected int MaxFileSizeInKiloByte;\n      protected string LogFileNameFormat;\n      protected string LogsFolder;\n      \n      protected virtual void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         if (!logFileNameFormat.Contains(\"{number}\") || !logFileNameFormat.Contains(\"{tag}\"))\n         {\n            throw new LoggerProException(\n               string.Format(\"Wrong FileFormat [{0}] - [HINT] A correct file format for {1} requires {{number}} and {{tag}} placeholders. A valid file format is : {2}\",\n                  logFileNameFormat, this.GetType().Name, DEFAULT_FILENAME_FORMAT));\n         }\n      }\n\n      \n      protected virtual string GetLogFileName(string tag, int fileNumber)\n      {\n         \n         string moduleName = Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location);\n         string fileFormat = LogFileNameFormat\n            .Replace(\"{module}\", moduleName)\n            .Replace(\"{number}\", fileNumber.ToString(\"D\" + Math.Max(2, MaxBackupFileCount.ToString().Length)))\n            .Replace(\"{tag}\", tag)\n            .Replace(\"{pid}\", Environment.ProcessId.ToString(\"D8\"));\n         \n         return Path.Combine(LogsFolder, fileFormat);\n      }\n\n      \n      protected virtual StreamWriter CreateWriter(string fileName, int bufferSize = 32)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               \n               FileStream fs = new FileStream(fileName, FileMode.Append, FileAccess.Write, FileShare.Read);\n               StreamWriter sw = new StreamWriter(fs, FileEncoding, bufferSize)\n               {\n                  AutoFlush = true\n               };\n               return sw;\n            }\n            catch (IOException)\n            {\n               if (++retries >= RETRY_COUNT)\n                  throw;\n               System.Threading.Thread.Sleep(RETRY_DELAY);\n            }\n         }\n      }\n\n      \n      protected virtual void EmitStartRotateLogItem(StreamWriter writer)\n      {\n         WriteToStream(writer, \"#[START LOG \" + DateTime.Now.ToString(\"o\") + \"]\");\n      }\n\n      \n      protected virtual void EmitEndRotateLogItem(StreamWriter writer)\n      {\n         WriteToStream(writer, \"#[ROTATE LOG \" + DateTime.Now.ToString(\"o\") + \"]\");\n      }\n\n      \n      protected virtual void WriteToStream(StreamWriter writer, string value)\n      {\n         writer.WriteLine(value);\n         writer.Flush();\n      }\n\n      \n      protected virtual void RotateFile(string logTag, out string newFileName)\n      {\n         newFileName = GetLogFileName(logTag, 0);\n         \n         string oldest = GetLogFileName(logTag, MaxBackupFileCount - 1);\n         if (File.Exists(oldest))\n         {\n            TryDeleteFile(oldest);\n         }\n         \n         for (int i = MaxBackupFileCount - 1; i >= 1; i--)\n         {\n            string src = GetLogFileName(logTag, i);\n            string dst = GetLogFileName(logTag, i + 1);\n            if (File.Exists(src))\n            {\n               TryMoveFile(src, dst);\n            }\n         }\n         \n         string firstBackup = GetLogFileName(logTag, 1);\n         TryMoveFile(newFileName, firstBackup);\n      }\n\n      protected void TryDeleteFile(string fileSrc)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               File.Delete(fileSrc);\n               if (!File.Exists(fileSrc))\n                  break;\n            }\n            catch\n            {\n               if (++retries == RETRY_COUNT)\n                  throw new LoggerProException($\"Cannot delete file {fileSrc}\");\n               System.Threading.Thread.Sleep(100);\n            }\n         }\n      }\n\n      protected void TryMoveFile(string fileSrc, string fileDest)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               File.Move(fileSrc, fileDest);\n               break;\n            }\n            catch (IOException)\n            {\n               if (++retries == RETRY_COUNT)\n                  throw new LoggerProException($\"Cannot rename {fileSrc} to {fileDest}\");\n               System.Threading.Thread.Sleep(100);\n            }\n         }\n      }\n\n      \n      protected virtual void InternalWriteLog(StreamWriter writer, TLogItem logItem)\n      {\n         WriteToStream(writer, FormatLog(logItem));\n      }\n\n      \n      public LoggerProFileAppenderBase(int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n                                       int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n                                       string logsFolder = \"\",\n                                       string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n                                       ILogItemRenderer logItemRenderer = null,\n                                       Encoding encoding = null)\n         : base(logItemRenderer)\n      {\n         LogsFolder = logsFolder;\n         MaxBackupFileCount = Math.Max(1, maxBackupFileCount);\n         MaxFileSizeInKiloByte = maxFileSizeInKiloByte;\n         CheckLogFileNameFormat(logFileNameFormat);\n         LogFileNameFormat = logFileNameFormat;\n         FileEncoding = encoding ?? Encoding.Default;\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         \n         if (string.IsNullOrEmpty(LogsFolder))\n         {\n#if WINDOWS\n            LogsFolder = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);\n#else\n            LogsFolder = Environment.CurrentDirectory;\n#endif\n         }\n         if (!Directory.Exists(LogsFolder))\n            Directory.CreateDirectory(LogsFolder);\n      }\n   }\n\n   #endregion\n\n   #region LoggerProFileAppender\n\n   \n   public class LoggerProFileAppender : LoggerProFileAppenderBase\n   {\n      \n      private readonly Dictionary<string, StreamWriter> _writersDictionary = new Dictionary<string, StreamWriter>();\n\n      private void AddWriter(string logTag, out StreamWriter writer, out string logFileName)\n      {\n         logFileName = GetLogFileName(logTag, 0);\n         writer = CreateWriter(logFileName);\n         _writersDictionary.Add(logTag, writer);\n      }\n\n      private void RotateLog(string logTag, StreamWriter writer)\n      {\n         string logFileName;\n         EmitEndRotateLogItem(writer);\n         _writersDictionary.Remove(logTag);\n         RotateFile(logTag, out logFileName);\n         AddWriter(logTag, out writer, out logFileName);\n         EmitStartRotateLogItem(writer);\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         \n      }\n\n      public override void TearDown()\n      {\n         foreach (var writer in _writersDictionary.Values)\n         {\n            writer.Dispose();\n         }\n         _writersDictionary.Clear();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         StreamWriter writer;\n         string logFileName;\n         if (!_writersDictionary.TryGetValue(logItem.LogTag, out writer))\n         {\n            AddWriter(logItem.LogTag, out writer, out logFileName);\n         }\n\n         InternalWriteLog(writer, logItem);\n\n         if (((FileStream)writer.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog(logItem.LogTag, writer);\n         }\n      }\n   }\n\n   #endregion\n\n   #region LoggerProSimpleFileAppender\n\n   \n   public class LoggerProSimpleFileAppender : LoggerProFileAppenderBase\n   {\n      private StreamWriter _fileWriter;\n\n      protected override void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         \n         if (!logFileNameFormat.Contains(\"{number}\"))\n         {\n            throw new LoggerProException(\n               string.Format(\"Wrong FileFormat [{0}] - [HINT] A correct file format for {1} requires the {{number}} placeholder. A valid file format is : {2}\",\n                  logFileNameFormat, this.GetType().Name, DEFAULT_FILENAME_FORMAT));\n         }\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n      }\n\n      public override void TearDown()\n      {\n         _fileWriter?.Dispose();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         InternalWriteLog(_fileWriter, logItem);\n         if (((FileStream)_fileWriter.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog();\n         }\n      }\n\n      private void RotateLog()\n      {\n         EmitEndRotateLogItem(_fileWriter);\n         _fileWriter.Dispose();\n         RotateFile(\"\", out string newFileName);\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n         EmitStartRotateLogItem(_fileWriter);\n      }\n\n      public LoggerProSimpleFileAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n         ILogItemRenderer logItemRenderer = null,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, logFileNameFormat, logItemRenderer, encoding)\n      {\n      }\n   }\n\n   #endregion\n\n   #region LoggerProFileByFolderAppender\n\n   \n   public class LoggerProFileByFolderAppender : LoggerProFileAppender\n   {\n      private StreamWriter _fileWriter;\n      private DateTime _currentDate;\n\n      private string GetLogFolder()\n      {\n         \n         string baseFolder = string.IsNullOrEmpty(LogsFolder)\n            ? Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)\n            : LogsFolder;\n\n         string logsDir = Path.Combine(baseFolder, \"Logs\");\n         if (!Directory.Exists(logsDir))\n            Directory.CreateDirectory(logsDir);\n\n         \n         string dayFolder = Path.Combine(logsDir, DateTime.Now.ToString(\"yyyyMMdd\"));\n         if (!Directory.Exists(dayFolder))\n            Directory.CreateDirectory(dayFolder);\n\n         return dayFolder;\n      }\n\n      \n      protected override string GetLogFileName(string tag, int fileNumber)\n      {\n         string moduleName = Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location);\n         string fileName = string.Format(\"{0}.{1}.log\", moduleName, fileNumber.ToString(\"D2\"));\n         return Path.Combine(GetLogFolder(), fileName);\n      }\n\n      protected override void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         // Do nothing, file format is fixed.\n      }\n\n      private void ChangeLogFolder()\n      {\n         InternalRotateLog(out string newFileName, () =>\n         {\n            newFileName = GetLogFileName(\"\", 0);\n         });\n      }\n\n      private void RotateLog()\n      {\n         InternalRotateLog(out string newFileName, () =>\n         {\n            RotateFile(\"\", out newFileName);\n         });\n      }\n\n      private void InternalRotateLog(out string newFileName, Action<TLoggerProFileByFolderAppender> makeFileNameProc = null)\n      {\n         EmitEndRotateLogItem(_fileWriter);\n         _fileWriter.Dispose();\n         if (makeFileNameProc != null)\n         {\n            \n            makeFileNameProc(this);\n         }\n         else\n         {\n            newFileName = GetLogFileName(\"\", 0);\n         }\n         _fileWriter = CreateWriter(newFileName, 16 * 1024);\n         EmitStartRotateLogItem(_fileWriter);\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n         _currentDate = DateTime.Today;\n      }\n\n      public override void TearDown()\n      {\n         _fileWriter?.Dispose();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         if (_currentDate != DateTime.Today)\n         {\n            ChangeLogFolder();\n            _currentDate = DateTime.Today;\n         }\n         string logRow;\n         if (OnLogRow != null)\n         {\n            OnLogRow(logItem, out logRow);\n         }\n         else\n         {\n            logRow = LogItemRenderer.RenderLogItem(logItem);\n         }\n         WriteToStream(_fileWriter, logRow);\n         if (((FileStream)_fileWriter.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog();\n         }\n      }\n\n      public LoggerProFileByFolderAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         ILogItemRenderer logItemRenderer = null,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, DEFAULT_FILENAME_FORMAT_WITHOUT_TAG, logItemRenderer, encoding)\n      {\n      }\n   }\n\n   #endregion\n\n   #region LoggerProLogFmtFileAppender\n\n   \n   public class LoggerProLogFmtFileAppender : LoggerProSimpleFileAppender\n   {\n      public LoggerProLogFmtFileAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, logFileNameFormat, new LogItemRendererLogFmt(), encoding)\n      {\n      }\n\n      protected override void EmitEndRotateLogItem(StreamWriter writer)\n      {\n         // In this appender, do nothing\n      }\n\n      protected override void EmitStartRotateLogItem(StreamWriter writer)\n      {\n         // In this appender, do nothing\n      }\n\n      protected override string GetLogFileName(string tag, int fileNumber)\n      {\n        \n         string origFileName = base.GetLogFileName(tag, fileNumber);\n         string ext = Path.GetExtension(origFileName);\n         if (string.IsNullOrEmpty(ext))\n         {\n            ext = \".log\";\n         }\n         return Path.ChangeExtension(origFileName, \".logfmt\" + ext);\n      }\n   }\n\n   #endregion\n}"}
{"input": "unit uConfig.Module;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TConfigModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TConfigModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  uBase.Controller,\n  uMovie.Controller,\n  System.IOUtils,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles,\n  MVCFramework.HTMX,\n  JsonDataObjects,\n  MVCFramework.View.Renderers.Mustache;\n\nprocedure TConfigModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      \n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // enables or not system controllers loading (available only from localhost requests)\n      Config[TMVCConfigKey.LoadSystemControllers] := 'true';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'htmx';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'htmx_templates';\n      // Max Record Count for automatic Entities CRUD\n      Config[TMVCConfigKey.MaxEntitiesRecordCount] := '20';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n      // Enable X-Powered-By Header in response\n      Config[TMVCConfigKey.ExposeXPoweredBy] := 'true';\n      // Max request size in bytes\n      Config[TMVCConfigKey.MaxRequestSize] := IntToStr(TMVCConstants.DEFAULT_MAX_REQUEST_SIZE);\n    end);\n\n  (* Use Mustache View Engine *)\n  FMVC.SetViewEngine(TMVCMustacheViewEngine);\n\n  FMVC.AddMiddleware(TMVCStaticFilesMiddleware.Create('/img', TPath.Combine(ExtractFilePath(GetModuleName(HInstance)),\n    'www\\img')));\n\n  FMVC.AddController(TBaseController);\n  FMVC.AddController(TMovieController);\n\n  FMVC.SetExceptionHandler(\n    procedure(E: Exception; SelectedController: TMVCController; WebContext: TWebContext; var ExceptionHandled: Boolean)\n\n    function ProcessJSONErrors: TJsonObject;\n    var\n      Nested: Exception;\n      Errors: TJsonArray;\n      Error: TJsonObject;\n    begin\n      Result := TJsonObject.Create;\n      Errors := TJsonArray.Create;\n      Result.A['errors'] := Errors;\n      Nested := E;\n      while Nested <> nil do\n      begin\n        Error := TJsonObject.Create;\n        Error.S['className'] := Nested.ClassName;\n        Error.S['message'] := Nested.Message;\n        Errors.Add(Error);\n        Nested := Nested.InnerException;\n      end;\n    end;\n\n    begin\n      if WebContext.Request.IsHTMX then\n      begin\n        if SelectedController <> nil then\n        begin\n          SelectedController.Render(E.Message);\n          // else etc\n          ExceptionHandled := true;\n          WebContext.Response.StatusCode := 400;\n        end;\n\n      end;\n\n    end);\nend;\n\nprocedure TConfigModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Middleware.StaticFiles;\nusing MVCFramework.HTMX;\nusing JsonDataObjects;\nusing MVCFramework.View.Renderers.Mustache;\nusing uBase.Controller;\nusing uMovie.Controller;\n\nnamespace uConfigModule\n{\n    public class ConfigModule : WebModule\n    {\n        private MVCEngine _mvcEngine;\n        public override void OnCreate()\n        {\n            _mvcEngine = new MVCEngine(this, config =>\n            {\n                config[MVCCOnfigKey.DefaultContentType] = MVCConstants.DEFAULT_CONTENT_TYPE;\n                config[MVCCOnfigKey.DefaultContentCharset] = MVCConstants.DEFAULT_CONTENT_CHARSET;\n                config[MVCCOnfigKey.AllowUnhandledAction] = \"false\";\n                config[MVCCOnfigKey.LoadSystemControllers] = \"true\";\n                config[MVCCOnfigKey.DefaultViewFileExtension] = \"htmx\";\n                config[MVCCOnfigKey.ViewPath] = \"htmx_templates\";\n                config[MVCCOnfigKey.MaxEntitiesRecordCount] = \"20\";\n                config[MVCCOnfigKey.ExposeServerSignature] = \"true\";\n                config[MVCCOnfigKey.ExposeXPoweredBy] = \"true\";\n                config[MVCCOnfigKey.MaxRequestSize] = MVCConstants.DEFAULT_MAX_REQUEST_SIZE.ToString();\n            });\n            _mvcEngine.SetViewEngine(new MVCMustacheViewEngine());\n            string modulePath = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);\n            string imgPath = Path.Combine(modulePath, @\"www\\img\");\n            _mvcEngine.AddMiddleware(new MVCStaticFilesMiddleware(\"/img\", imgPath));\n            _mvcEngine.AddController<BaseController>();\n            _mvcEngine.AddController<MovieController>();\n            _mvcEngine.SetExceptionHandler((ex, selectedController, webContext, out bool exceptionHandled) =>\n            {\n                exceptionHandled = false;\n                if (webContext.Request.IsHTMX)\n                {\n                    if (selectedController != null)\n                    {\n                        selectedController.Render(ex.Message);\n                        exceptionHandled = true;\n                        webContext.Response.StatusCode = 400;\n                    }\n                }\n            });\n        }\n        public override void OnDestroy()\n        {\n            _mvcEngine.Dispose();\n        }\n    }\n}"}
{"input": "unit LoggerPro.DBAppender;\n\n// Abstract LoggerPro Appender that writes to a database\n// Subclass to use with DB connection stack of choice e.g. ADO, FireDAC etc\n// only supports parameterised stored procedures for security and performance\n\ninterface\n\nuses\n  System.Classes, LoggerPro, System.SysUtils, Data.DB;\n\ntype\n  TOnDBWriteError = reference to procedure(const Sender: TObject; const LogItem: TLogItem; const DBError: Exception;\n    var RetryCount: Integer);\n\n  TGetDBConnection = reference to function: TCustomConnection;\n\n  TGetStoredProc<T: class> = reference to function(Connection: TCustomConnection): T;\n\n  TSetParams<T: class> = reference to procedure(DataObject: T; LogItem: TLogItem);\n\n\n  ///<summary>Abstract class for writing logs to database</summary>\n  /// <remarks>Subclass with your choice of stored procedure class to get a working logger </remarks>\n  TLoggerProDBAppender<T: class> = class(TLoggerProAppenderBase)\n  protected\n    const MAX_RETRY_COUNT = 5;\n  protected\n    FOnDBWriteError: TOnDBWriteError;\n    FGetDBConnection: TGetDBConnection;\n    FGetStoredProc: TGetStoredProc<T>;\n    FSetParams: TSetParams<T>;\n\n    FDBConnection: TCustomConnection;\n    FDBObject: T;\n    procedure RefreshParams(DataObj: T); virtual; abstract;\n    procedure ExecuteDataObject(DataObj: T); virtual; abstract;\n  public\n    constructor Create(GetDBConnection: TGetDBConnection; GetStoredProc: TGetStoredProc<T>; SetParams: TSetParams<T>;\n      OnDBWriteError: TOnDBWriteError); reintroduce;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure TryToRestart(var Restarted: Boolean); override;\n    procedure WriteLog(const ALogItem: TLogItem); override;\n  end;\n\nimplementation\n\n{ TLoggerProDBAppender }\n\n///<summary>Create an instance of the DB logger</summary>\n/// <param name=\"GetDBConnection\">anonymous function that returns a configured DB Connection</param>\n/// <param name=\"GetStoredProc\">anonymous function that returns a stored proc that can write to the DB</param>\n/// <param name=\"SetParams\">anonymous procedure that populates parameters before the stored proc is executed</param>\n/// <param name=\"OnDBWriteError\">anonymous procedure to handle retry of a failed operaation</param>\nconstructor TLoggerProDBAppender<T>.Create(GetDBConnection: TGetDBConnection; GetStoredProc: TGetStoredProc<T>;\n  SetParams: TSetParams<T>; OnDBWriteError: TOnDBWriteError);\nbegin\n  inherited Create;\n  FGetDBConnection := GetDBConnection;\n  FGetStoredProc := GetStoredProc;\n  FSetParams := SetParams;\n  FOnDBWriteError := OnDBWriteError;\nend;\n\nprocedure TLoggerProDBAppender<T>.Setup;\nbegin\n  inherited;\n  FDBConnection := FGetDBConnection;\nend;\n\nprocedure TLoggerProDBAppender<T>.TearDown;\nbegin\n  inherited;\n  if FDBObject <> nil then\n    FDBObject.Free;\n\n  if FDBConnection <> nil then\n  begin\n    FDBConnection.Connected := False;\n    FDBConnection.Free;\n  end;\nend;\n\nprocedure TLoggerProDBAppender<T>.TryToRestart(var Restarted: Boolean);\nbegin\n  try\n    // remove the DB Object\n    if FDBObject <> nil then\n    begin\n      FDBObject.Free;\n      FDBObject := nil;\n    end;\n\n    // reset the DB connection\n    if FDBConnection <> nil then\n    begin\n      FDBConnection.Connected := False;\n      FDBConnection.Free;\n      FDBConnection := nil;\n    end;\n  except\n    // no point catching the exception\n  end;\n\n  // now try to restart it\n  FDBConnection := FGetDBConnection;\n  Restarted := True;\nend;\n\nprocedure TLoggerProDBAppender<T>.WriteLog(const ALogItem: TLogItem);\nvar\n  RetryCount: Integer;\nbegin\n  RetryCount := 0;\n  repeat\n    try\n      if FDBObject = nil then\n      begin\n        FDBConnection.Connected := True;  //force an exception if needed\n        FDBObject := FGetStoredProc(FDBConnection);\n        RefreshParams(FDBObject); //this may not raise unhandled exception even in case of disconnection\n      end;\n      FSetParams(FDBObject, ALogItem);\n      ExecuteDataObject(FDBObject);\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for DB exception, call it\n        if Assigned(FOnDBWriteError) then\n          FOnDBWriteError(Self, ALogItem, E, RetryCount);\n        Inc(RetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if RetryCount >= MAX_RETRY_COUNT then\n          raise;\n      end;\n    end;\n  until False;\nend;\n\nend.", "output": "using System;\nusing System.Data;\n\nnamespace LoggerPro.Appenders\n{\n    \n        public delegate void OnDBWriteError(object sender, TLogItem logItem, Exception dbError, ref int retryCount);\n\n    \n    public delegate IDbConnection GetDBConnection();\n\n   \n    public delegate T GetStoredProc<T>(IDbConnection connection) where T : class;\n\n    \n    public delegate void SetParams<T>(T dataObject, TLogItem logItem) where T : class;\n\n    \n    public abstract class LoggerProDBAppender<T> : LoggerProAppenderBase where T : class\n    {\n        protected const int MAX_RETRY_COUNT = 5;\n\n        protected OnDBWriteError OnDBWriteErrorCallback;\n        protected GetDBConnection GetDBConnectionCallback;\n        protected GetStoredProc<T> GetStoredProcCallback;\n        protected SetParams<T> SetParamsCallback;\n\n        protected IDbConnection DbConnection;\n        protected T DbObject;\n\n       \n        public LoggerProDBAppender(GetDBConnection getDBConnection, GetStoredProc<T> getStoredProc, SetParams<T> setParams,\n                                   OnDBWriteError onDBWriteError)\n        {\n            GetDBConnectionCallback = getDBConnection ?? throw new ArgumentNullException(nameof(getDBConnection));\n            GetStoredProcCallback = getStoredProc ?? throw new ArgumentNullException(nameof(getStoredProc));\n            SetParamsCallback = setParams ?? throw new ArgumentNullException(nameof(setParams));\n            OnDBWriteErrorCallback = onDBWriteError; \n        }\n\n                protected abstract void RefreshParams(T dataObject);\n\n        \n        protected abstract void ExecuteDataObject(T dataObject);\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            DbConnection = GetDBConnectionCallback();\n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            if (DbObject != null)\n            {\n                if (DbObject is IDisposable disposableObj)\n                {\n                    disposableObj.Dispose();\n                }\n                DbObject = null;\n            }\n            if (DbConnection != null)\n            {\n                try\n                {\n                    DbConnection.Close();\n                }\n                finally\n                {\n                    DbConnection.Dispose();\n                    DbConnection = null;\n                }\n            }\n        }\n\n        \n        public override void TryToRestart(out bool restarted)\n        {\n            restarted = false;\n            try\n            {\n                if (DbObject != null)\n                {\n                    if (DbObject is IDisposable disposableObj)\n                    {\n                        disposableObj.Dispose();\n                    }\n                    DbObject = null;\n                }\n                if (DbConnection != null)\n                {\n                    DbConnection.Close();\n                    DbConnection.Dispose();\n                    DbConnection = null;\n                }\n            }\n            catch\n            {\n                // Ignore exceptions during cleanup\n            }\n            DbConnection = GetDBConnectionCallback();\n            restarted = true;\n        }\n\n                public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            while (true)\n            {\n                try\n                {\n                    if (DbObject == null)\n                    {\n                        \n                        DbConnection.Open();\n                        DbObject = GetStoredProcCallback(DbConnection);\n                        RefreshParams(DbObject);\n                    }\n                    SetParamsCallback(DbObject, logItem);\n                    ExecuteDataObject(DbObject);\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    if (OnDBWriteErrorCallback != null)\n                    {\n                        OnDBWriteErrorCallback(this, logItem, ex, ref retryCount);\n                    }\n                    retryCount++;\n                    if (retryCount >= MAX_RETRY_COUNT)\n                    {\n                        throw;\n                    }\n                }\n            }\n        }\n    }\n}"}
{"input": "unit MVCFramework.Serializer.Defaults;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Intf;\n\nfunction GetDefaultSerializer: IMVCSerializer;\n\nimplementation\n\nuses\n  MVCFramework.Serializer.JsonDataObjects;\n\nfunction GetDefaultSerializer: IMVCSerializer;\nbegin\n  Result := TMVCJsonDataObjectsSerializer.Create;\nend;\n\nend.", "output": "using MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.JsonDataObjects;\n\nnamespace MVCFramework.Serializer.Defaults\n{\n    public static class SerializerDefaults\n    {\n        public static IMVCSerializer GetDefaultSerializer()\n        {\n            return new MVCJsonDataObjectsSerializer();\n        }\n    }\n}"}
{"input": "unit ServiceU;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.SvcMgr,\n  Vcl.Dialogs,\n  IdHTTPWebBrokerBridge;\n\ntype\n  TArticlesService = class(TService)\n    procedure ServiceCreate(Sender: TObject);\n    procedure ServiceExecute(Sender: TService);\n    procedure ServiceStart(Sender: TService; var Started: Boolean);\n    procedure ServiceStop(Sender: TService; var Stopped: Boolean);\n  private\n    fServer: TIdHTTPWebBrokerBridge;\n  public\n    function GetServiceController: TServiceController; override;\n  end;\n\nvar\n  ArticlesService: TArticlesService;\n\nimplementation\n\nuses\n  Web.WebReq,\n  WebModuleUnit1, MVCFramework.Commons;\n\n{$R *.DFM}\n\n\nprocedure ServiceController(CtrlCode: DWord); stdcall;\nbegin\n  ArticlesService.Controller(CtrlCode);\nend;\n\nfunction TArticlesService.GetServiceController: TServiceController;\nbegin\n  Result := ServiceController;\nend;\n\nprocedure TArticlesService.ServiceCreate(Sender: TObject);\nbegin\n  if WebRequestHandler <> nil then\n    WebRequestHandler.WebModuleClass := WebModuleClass;\nend;\n\nprocedure TArticlesService.ServiceExecute(Sender: TService);\nbegin\n  while not Terminated do\n  begin\n    ServiceThread.ProcessRequests(True);\n    Sleep(1000);\n  end;\nend;\n\nprocedure TArticlesService.ServiceStart(Sender: TService; var Started: Boolean);\nbegin\n  fServer := TIdHTTPWebBrokerBridge.Create(nil);\n  fServer.OnParseAuthentication := TMVCParseAuthentication.OnParseAuthentication;\n  fServer.DefaultPort := 8080;\n  fServer.Active := True;\nend;\n\nprocedure TArticlesService.ServiceStop(Sender: TService; var Stopped: Boolean);\nbegin\n  fServer.Free;\nend;\n\nend.", "output": "using System;\nusing System.ServiceProcess;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing Web.WebReq;\nusing WebModuleUnit1;\nusing IdHTTPWebBrokerBridge;\n\nnamespace REST.RestServer\n{\n    public class ArticlesService : ServiceBase\n    {\n        private HTTPWebBrokerBridge fServer;\n        private Thread serviceThread;\n        private volatile bool terminated;\n        public ArticlesService()\n        {\n            this.ServiceName = \"ArticlesService\";\n        }\n        protected override void OnStart(string[] args)\n        {\n            if (WebRequestHandler.Instance != null)\n            {\n                WebRequestHandler.Instance.WebModuleClass = typeof(WebModule);\n            }\n            fServer = new HTTPWebBrokerBridge();\n            fServer.OnParseAuthentication += MVCParseAuthentication.OnParseAuthentication;\n            fServer.DefaultPort = 8080;\n            fServer.Active = true;\n            terminated = false;\n            serviceThread = new Thread(ServiceExecute);\n            serviceThread.Start();\n        }\n        protected override void OnStop()\n        {\n            terminated = true;\n            serviceThread.Join();\n            if (fServer != null)\n            {\n                fServer.Active = false;\n                fServer.Dispose();\n                fServer = null;\n            }\n        }\n        private void ServiceExecute()\n        {\n            while (!terminated)\n            {\n                ServiceThread.ProcessRequests(true);\n                Thread.Sleep(1000);\n            }\n        }\n        public static void Main()\n        {\n            ServiceBase.Run(new ArticlesService());\n        }\n    }\n}"}
{"input": "unit AppControllerU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Logger,\n  Web.HTTPApp,\n  JsonDataObjects;\n\ntype\n\n  [MVCPath('/')]\n  TApp1MainController = class(TMVCController)\n  public\n    [MVCPath('/public')]\n    [MVCHTTPMethod([httpGET])]\n    function PublicSection: String;\n    [MVCPath('/')]\n    [MVCHTTPMethod([httpGET])]\n    function Index: String;\n  end;\n\n  [MVCPath('/admin')]\n  TAdminController = class(TMVCController)\n  public\n    [MVCPath('/role1')]\n    [MVCProduces('text/html')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole1: String;\n    [MVCPath('/role1')]\n    [MVCProduces('application/json')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole1EmittingJSON: TJSONObject;\n    [MVCPath('/role2')]\n    [MVCProduces('text/html')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole2: String;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, System.Classes;\n\n{ TApp1MainController }\n\nfunction TApp1MainController.Index: String;\nbegin\n  Redirect('/index.html');\nend;\n\nfunction TApp1MainController.PublicSection: String;\nbegin\n  Result := 'This is a public section';\nend;\n\n{ TAdminController }\n\nfunction TAdminController.OnlyRole1: String;\nbegin\n  ContentType := TMVCMediaType.TEXT_PLAIN;\n  Result := Context.LoggedUser.CustomData['mycustomvalue'] + sLineBreak +\n  'Hey! Hello ' + Context.LoggedUser.UserName + ', now you are a logged user and this is a protected content!' + sLineBreak +\n  'As logged user you have the following roles: ' + sLineBreak + string.Join(sLineBreak, Context.LoggedUser.Roles.ToArray);\nend;\n\nfunction TAdminController.OnlyRole1EmittingJSON: TJsonObject;\nvar\n  lJObj: TJSONObject;\n  lJArr: TJSONArray;\n  lQueryParams: TStrings;\n  I: Integer;\n  lItem: TJsonObject;\nbegin\n  ContentType := TMVCMediaType.APPLICATION_JSON;\n  lJObj := TJSONObject.Create;\n  try\n    lJObj.S['message'] := 'This is protected content accessible only by user1';\n    lJArr := lJObj.A['querystringparameters'];\n    lQueryParams := Context.Request.QueryStringParams;\n    for I := 0 to lQueryParams.Count - 1 do\n    begin\n      lItem := lJArr.AddObject;\n      lItem.S[lQueryParams.Names[I]] := lQueryParams.ValueFromIndex[I];\n    end;\n    Result := lJObj;\n  except\n    lJObj.Free;\n    raise;\n  end;\nend;\n\nfunction TAdminController.OnlyRole2: String;\nbegin\n  ContentType := TMVCMediaType.TEXT_PLAIN;\n  Result := Context.LoggedUser.CustomData['mycustomvalue'] + sLineBreak +\n    'Hey! Hello ' + Context.LoggedUser.UserName + ', now you are a logged user and this is a protected content!' + sLineBreak +\n    'As logged user you have the following roles: ' + sLineBreak + string.Join(sLineBreak, Context.LoggedUser.Roles.ToArray);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Primitives;\n\nnamespace AppControllerU\n{\n    \n    [Route(\"/\")]\n    [ApiController]\n    public class App1MainController : ControllerBase\n    {\n        \n        [HttpGet(\"public\")]\n        public IActionResult PublicSection()\n        {\n            return Content(\"This is a public section\", \"text/plain\");\n        }\n        \n        \n        [HttpGet(\"\")]\n        public IActionResult Index()\n        {\n            return Redirect(\"/index.html\");\n        }\n    }\n    \n    \n    [Route(\"admin\")]\n    [ApiController]\n    public class AdminController : ControllerBase\n    {\n        [HttpGet(\"role1\")]\n        public IActionResult OnlyRole1()\n        {\n            if (Request.Headers.TryGetValue(\"Accept\", out StringValues acceptHeader) &&\n                acceptHeader.Any(h => h.Contains(\"application/json\", StringComparison.OrdinalIgnoreCase)))\n            {\n                var response = new Dictionary<string, object>\n                {\n                    [\"message\"] = \"This is protected content accessible only by user1\"\n                };\n\n                var queryParams = Request.Query.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToString());\n                response[\"querystringparameters\"] = queryParams;\n                \n                return new JsonResult(response);\n            }\n            else\n            {\n                \n                var customValue = HttpContext.User?.FindFirst(\"custom\")?.Value ?? \"default_custom_value\";\n                var userName = HttpContext.User?.Identity?.Name ?? \"Anonymous\";\n                var roles = HttpContext.User?.FindAll(\"role\").Select(r => r.Value).ToArray() ?? new string[] { \"NoRoles\" };\n                var rolesText = string.Join(Environment.NewLine, roles);\n                \n                string result = $\"{customValue}{Environment.NewLine}\" +\n                                $\"Hey! Hello {userName}, now you are a logged user and this is a protected content!{Environment.NewLine}\" +\n                                $\"As logged user you have the following roles:{Environment.NewLine}{rolesText}\";\n                return Content(result, \"text/plain\");\n            }\n        }\n        \n        [HttpGet(\"role2\")]\n        [Produces(\"text/html\")]\n        public IActionResult OnlyRole2()\n        {\n            var customValue = HttpContext.User?.FindFirst(\"custom\")?.Value ?? \"default_custom_value\";\n            var userName = HttpContext.User?.Identity?.Name ?? \"Anonymous\";\n            var roles = HttpContext.User?.FindAll(\"role\").Select(r => r.Value).ToArray() ?? new string[] { \"NoRoles\" };\n            var rolesText = string.Join(Environment.NewLine, roles);\n            \n            string result = $\"{customValue}{Environment.NewLine}\" +\n                            $\"Hey! Hello {userName}, now you are a logged user and this is a protected content!{Environment.NewLine}\" +\n                            $\"As logged user you have the following roles:{Environment.NewLine}{rolesText}\";\n            return Content(result, \"text/plain\");\n        }\n    }\n}"}
{"input": "unit Horse.Core.RouterTree.NextCaller;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Generics.Collections,\n  fpHTTP,\n  httpprotocol,\n{$ELSE}\n  System.NetEncoding,\n  System.SysUtils,\n  Web.HTTPApp,\n  System.Generics.Collections,\n{$ENDIF}\n  Horse.Commons,\n  Horse.Request,\n  Horse.Response,\n  Horse.Callback;\n\ntype\n  TNextCaller = class\n  private\n    FIndex: Integer;\n    FIndexCallback: Integer;\n    FPath: TQueue<string>;\n    FHTTPType: TMethodType;\n    FRequest: THorseRequest;\n    FResponse: THorseResponse;\n    FMiddleware: TList<THorseCallback>;\n    FCallBack: TObjectDictionary<TMethodType, TList<THorseCallback>>;\n    FCallNextPath: TCallNextPath;\n    FIsGroup: Boolean;\n    FTag: string;\n    FIsParamsKey: Boolean;\n    FFound: ^Boolean;\n  public\n    function Init: TNextCaller;\n    function SetCallback(const ACallback: TObjectDictionary<TMethodType, TList<THorseCallback>>): TNextCaller;\n    function SetPath(const APath: TQueue<string>): TNextCaller;\n    function SetHTTPType(const AHTTPType: TMethodType): TNextCaller;\n    function SetRequest(const ARequest: THorseRequest): TNextCaller;\n    function SetResponse(const AResponse: THorseResponse): TNextCaller;\n    function SetIsGroup(const AIsGroup: Boolean): TNextCaller;\n    function SetMiddleware(const AMiddleware: TList<THorseCallback>): TNextCaller;\n    function SetTag(const ATag: string): TNextCaller;\n    function SetIsParamsKey(const AIsParamsKey: Boolean): TNextCaller;\n    function SetOnCallNextPath(const ACallNextPath: TCallNextPath): TNextCaller;\n    function SetFound(var AFound: Boolean): TNextCaller;\n    procedure Next;\n  end;\n\nimplementation\n\nuses\n  Horse.Exception,\n  Horse.Exception.Interrupted;\n\nfunction TNextCaller.Init: TNextCaller;\nvar\n  LCurrent: string;\nbegin\n  Result := Self;\n  if not FIsGroup then\n    LCurrent := FPath.Dequeue;\n  FIndex := -1;\n  FIndexCallback := -1;\n  if FIsParamsKey then\n    FRequest.Params.Dictionary.Add(FTag, {$IF DEFINED(FPC)}HTTPDecode(LCurrent){$ELSE}TNetEncoding.URL.Decode(LCurrent){$ENDIF});\nend;\n\nprocedure TNextCaller.Next;\nvar\n  LCallback: TList<THorseCallback>;\nbegin\n  Inc(FIndex);\n  if (FMiddleware.Count > FIndex) then\n  begin\n    FFound^ := True;\n    Self.FMiddleware.Items[FIndex](FRequest, FResponse, Next);\n    if (FMiddleware.Count > FIndex) then\n      Next;\n  end\n  else if (FPath.Count = 0) and Assigned(FCallBack) then\n  begin\n    Inc(FIndexCallback);\n    if FCallBack.TryGetValue(FHTTPType, LCallback) then\n    begin\n      if (LCallback.Count > FIndexCallback) then\n      begin\n        try\n          FFound^ := True;\n          LCallback.Items[FIndexCallback](FRequest, FResponse, Next);\n        except\n          on E: Exception do\n          begin\n            if (not(E is EHorseCallbackInterrupted)) and\n               (not(E is EHorseException)) and\n               (FResponse.Status < Integer(THTTPStatus.BadRequest))\n            then\n              FResponse.Send('Internal Application Error').Status(THTTPStatus.InternalServerError);\n            raise;\n          end;\n        end;\n        Next;\n      end;\n    end\n    else\n    begin\n      if FCallBack.Count > 0 then\n      begin\n        FFound^ := True;\n        FResponse.Send('Method Not Allowed').Status(THTTPStatus.MethodNotAllowed);\n      end\n      else\n        FResponse.Send('Not Found').Status(THTTPStatus.NotFound)\n    end;\n  end\n  else\n    FFound^ := FCallNextPath(FPath, FHTTPType, FRequest, FResponse);\n  if not FFound^ then\n    FResponse.Send('Not Found').Status(THTTPStatus.NotFound);\nend;\n\nfunction TNextCaller.SetCallback(const ACallback: TObjectDictionary<TMethodType, TList<THorseCallback>>): TNextCaller;\nbegin\n  FCallBack := ACallback;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetFound(var AFound: Boolean): TNextCaller;\nbegin\n  FFound := @AFound;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetHTTPType(const AHTTPType: TMethodType): TNextCaller;\nbegin\n  FHTTPType := AHTTPType;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetIsGroup(const AIsGroup: Boolean): TNextCaller;\nbegin\n  FIsGroup := AIsGroup;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetIsParamsKey(const AIsParamsKey: Boolean): TNextCaller;\nbegin\n  FIsParamsKey := AIsParamsKey;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetMiddleware(const AMiddleware: TList<THorseCallback>): TNextCaller;\nbegin\n  FMiddleware := AMiddleware;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetOnCallNextPath(const ACallNextPath: TCallNextPath): TNextCaller;\nbegin\n  FCallNextPath := ACallNextPath;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetPath(const APath: TQueue<string>): TNextCaller;\nbegin\n  FPath := APath;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetRequest(const ARequest: THorseRequest): TNextCaller;\nbegin\n  FRequest := ARequest;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetResponse(const AResponse: THorseResponse): TNextCaller;\nbegin\n  FResponse := AResponse;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetTag(const ATag: string): TNextCaller;\nbegin\n  FTag := ATag;\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\n\nnamespace Horse.Core.RouterTree\n{\n    \n    public delegate void THorseCallback(THorseRequest request, THorseResponse response, Action next);\n\n    \n    public delegate bool TCallNextPath(Queue<string> path, TMethodType httpType, THorseRequest request, THorseResponse response);\n\n    \n    public enum TMethodType\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH\n    }\n\n    \n    public class THorseRequest\n    {\n        public Dictionary<string, string> Params { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n    }\n\n    \n    public class THorseResponse\n    {\n        public int Status { get; set; }\n        public THorseResponse Send(string message)\n        {\n            Console.WriteLine(\"Response: \" + message);\n            return this;\n        }\n        public THorseResponse StatusCode(int status)\n        {\n            Status = status;\n            Console.WriteLine(\"Status: \" + status);\n            return this;\n        }\n    }\n\n    \n    public class HorseCallbackInterrupted : Exception { }\n    public class HorseException : Exception\n    {\n        public int Status { get; set; }\n        public static HorseException New(int status, string message)\n        {\n            return new HorseException(message) { Status = status };\n        }\n        public HorseException(string message) : base(message) { }\n    }\n\n    \n    public class BooleanHolder\n    {\n        public bool Value { get; set; }\n    }\n\n    \n    public class TNextCaller\n    {\n        private int FIndex;\n        private int FIndexCallback;\n        private Queue<string> FPath;\n        private TMethodType FHTTPType;\n        private THorseRequest FRequest;\n        private THorseResponse FResponse;\n        private List<THorseCallback> FMiddleware;\n        private Dictionary<TMethodType, List<THorseCallback>> FCallBack;\n        private TCallNextPath FCallNextPath;\n        private bool FIsGroup;\n        private string FTag;\n        private bool FIsParamsKey;\n        private BooleanHolder FFound;\n        private object FHorseCore; \n\n        \n        public TNextCaller(object horseCore)\n        {\n            FHorseCore = horseCore;\n        }\n\n        \n        public TNextCaller Init()\n        {\n            if (!FIsGroup && FPath != null && FPath.Count > 0)\n            {\n                string LCurrent = FPath.Dequeue();\n                if (FIsParamsKey && FRequest != null)\n                {\n                    \n                    FRequest.Params[FTag] = WebUtility.UrlDecode(LCurrent);\n                }\n            }\n            FIndex = -1;\n            FIndexCallback = -1;\n            return this;\n        }\n\n        \n        public void Next()\n        {\n            FIndex++;\n            if (FMiddleware != null && FMiddleware.Count > FIndex)\n            {\n                FFound.Value = true;\n                FMiddleware[FIndex](FRequest, FResponse, Next);\n                if (FMiddleware.Count > FIndex)\n                    Next();\n            }\n            else if ((FPath == null || FPath.Count == 0) && FCallBack != null)\n            {\n                FIndexCallback++;\n                if (FCallBack.TryGetValue(FHTTPType, out List<THorseCallback> LCallback))\n                {\n                    if (LCallback.Count > FIndexCallback)\n                    {\n                        try\n                        {\n                            FFound.Value = true;\n                            LCallback[FIndexCallback](FRequest, FResponse, Next);\n                        }\n                        catch (Exception E)\n                        {\n                            if (!(E is HorseCallbackInterrupted) &&\n                                !(E is HorseException) &&\n                                FResponse.Status < (int)HttpStatusCode.BadRequest)\n                            {\n                                FResponse.Send(\"Internal Application Error\")\n                                         .StatusCode((int)HttpStatusCode.InternalServerError);\n                            }\n                            throw;\n                        }\n                        Next();\n                    }\n                }\n                else\n                {\n                    if (FCallBack.Count > 0)\n                    {\n                        FFound.Value = true;\n                        FResponse.Send(\"Method Not Allowed\")\n                                 .StatusCode((int)HttpStatusCode.MethodNotAllowed);\n                    }\n                    else\n                    {\n                        FResponse.Send(\"Not Found\")\n                                 .StatusCode((int)HttpStatusCode.NotFound);\n                    }\n                }\n            }\n            else\n            {\n                FFound.Value = FCallNextPath(FPath, FHTTPType, FRequest, FResponse);\n            }\n            if (!FFound.Value)\n                FResponse.Send(\"Not Found\")\n                         .StatusCode((int)HttpStatusCode.NotFound);\n        }\n\n        \n        public TNextCaller SetCallback(Dictionary<TMethodType, List<THorseCallback>> aCallback)\n        {\n            FCallBack = aCallback;\n            return this;\n        }\n\n        public TNextCaller SetFound(BooleanHolder aFound)\n        {\n            FFound = aFound;\n            return this;\n        }\n\n        public TNextCaller SetHTTPType(TMethodType aHTTPType)\n        {\n            FHTTPType = aHTTPType;\n            return this;\n        }\n\n        public TNextCaller SetIsGroup(bool aIsGroup)\n        {\n            FIsGroup = aIsGroup;\n            return this;\n        }\n\n        public TNextCaller SetIsParamsKey(bool aIsParamsKey)\n        {\n            FIsParamsKey = aIsParamsKey;\n            return this;\n        }\n\n        public TNextCaller SetMiddleware(List<THorseCallback> aMiddleware)\n        {\n            FMiddleware = aMiddleware;\n            return this;\n        }\n\n        public TNextCaller SetOnCallNextPath(TCallNextPath aCallNextPath)\n        {\n            FCallNextPath = aCallNextPath;\n            return this;\n        }\n\n        public TNextCaller SetPath(Queue<string> aPath)\n        {\n            FPath = aPath;\n            return this;\n        }\n\n        public TNextCaller SetRequest(THorseRequest aRequest)\n        {\n            FRequest = aRequest;\n            return this;\n        }\n\n        public TNextCaller SetResponse(THorseResponse aResponse)\n        {\n            FResponse = aResponse;\n            return this;\n        }\n\n        public TNextCaller SetTag(string aTag)\n        {\n            FTag = aTag;\n            return this;\n        }\n\n        \n        public T End<T>() where T : class\n        {\n            return FHorseCore as T;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// Contributors for this file: \n//    David Cornelius\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.VCLListBoxAppender;\n\ninterface\n\nuses\n  LoggerPro,\n  System.Classes,\n  Vcl.StdCtrls;\n\ntype\n  { @abstract(Appends formatted @link(TLogItem) to a TListBox in a VCL application) }\n  TVCLListBoxAppender = class(TLoggerProAppenderBase)\n  private\n    FLB: TListBox;\n    FMaxLogLines: Word;\n  public\n    constructor Create(aLB: TListBox; aMaxLogLines: Word = 500; aLogItemRenderer: ILogItemRenderer = nil); reintroduce;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TVCLListBoxAppender }\n\nconstructor TVCLListBoxAppender.Create(aLB: TListBox; aMaxLogLines: Word = 500; aLogItemRenderer: ILogItemRenderer = nil);\nbegin\n  inherited Create(aLogItemRenderer);\n  FLB := aLB;\n  FMaxLogLines := aMaxLogLines;\nend;\n\nprocedure TVCLListBoxAppender.Setup;\nbegin\n  inherited;\n  TThread.Synchronize(nil,\n    procedure\n    begin\n      FLB.Clear;\n    end);\nend;\n\nprocedure TVCLListBoxAppender.TearDown;\nbegin\n  // do nothing\nend;\n\nprocedure TVCLListBoxAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lText: string;\nbegin\n  lText := FormatLog(aLogItem);\n  TThread.Queue(nil,\n    procedure\n    var\n      Lines: integer;\n    begin\n      FLB.Items.BeginUpdate;\n      try\n        Lines := FLB.Items.Count;\n        if Lines > FMaxLogLines then\n          FLB.Items.Delete(0);\n        FLB.AddItem(lText, nil);\n        FLB.ItemIndex := FLB.Items.Count - 1;\n      finally\n        FLB.Items.EndUpdate;\n      end;\n    end);\nend;\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Windows.Forms;\nusing LoggerPro; \n\nnamespace LoggerPro\n{\n    \n    public class VCLListBoxAppender : LoggerProAppenderBase\n    {\n        private readonly ListBox _listBox;\n        private readonly int _maxLogLines;\n\n        public VCLListBoxAppender(ListBox listBox, int maxLogLines = 500, ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n            _listBox = listBox ?? throw new ArgumentNullException(nameof(listBox));\n            _maxLogLines = maxLogLines;\n        }\n        public override void Setup()\n        {\n            base.Setup();\n            \n            if (_listBox.InvokeRequired)\n            {\n                _listBox.Invoke(new Action(() => _listBox.Items.Clear()));\n            }\n            else\n            {\n                _listBox.Items.Clear();\n            }\n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public override void WriteLog(LogItem logItem)\n        {\n            \n            string formattedLog = FormatLog(logItem);\n\n            \n            if (_listBox.InvokeRequired)\n            {\n                _listBox.BeginInvoke(new Action(() => AppendLog(formattedLog)));\n            }\n            else\n            {\n                AppendLog(formattedLog);\n            }\n        }\n\n        private void AppendLog(string logText)\n        {\n            _listBox.BeginUpdate();\n            try\n            {\n                \n                while (_listBox.Items.Count >= _maxLogLines)\n                {\n                    _listBox.Items.RemoveAt(0);\n                }\n                _listBox.Items.Add(logText);\n                \n                _listBox.SelectedIndex = _listBox.Items.Count - 1;\n            }\n            finally\n            {\n                _listBox.EndUpdate();\n            }\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.SQLGenerators.MySQL;\n\ninterface\n\nuses\n  FireDAC.Phys.MySQLDef,\n  FireDAC.Phys.MySQL,\n  System.Rtti,\n  System.Generics.Collections,\n  MVCFramework.RQL.Parser,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Commons;\n\ntype\n  TMVCSQLGeneratorMySQL = class(TMVCSQLGenerator)\n  protected\n    function GetCompilerClass: TRQLCompilerClass; override;\n  public\n    function CreateInsertSQL(\n      const TableMap: TMVCTableMap;\n      const ARInstance: TMVCActiveRecord\n      ): string; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.RQL.AST2MySQL;\n\nfunction TMVCSQLGeneratorMySQL.CreateInsertSQL(\n  const TableMap: TMVCTableMap;\n  const ARInstance: TMVCActiveRecord\n  ): string;\nvar\n  lKeyValue: TPair<TRttiField, TFieldInfo>;\n  lSB: TStringBuilder;\n  lPKInInsert: Boolean;\n  lFieldName: String;\nbegin\n  lPKInInsert := (not TableMap.fPrimaryKeyFieldName.IsEmpty) and (not(TMVCActiveRecordFieldOption.foAutoGenerated in TableMap.fPrimaryKeyOptions));\n  lPKInInsert := lPKInInsert and (not(TMVCActiveRecordFieldOption.foReadOnly in TableMap.fPrimaryKeyOptions));\n  lSB := TStringBuilder.Create;\n  try\n    lSB.Append('INSERT INTO ' + GetTableNameForSQL(TableMap.fTableName) + '(');\n    if lPKInInsert then\n    begin\n      lSB.Append(GetFieldNameForSQL(TableMap.fPrimaryKeyFieldName) + ',');\n    end;\n\n    {partition}\n    for lFieldName in fPartitionInfo.FieldNames do\n    begin\n      lSB.Append(GetFieldNameForSQL(lFieldName) + ',');\n    end;\n    {end-partition}\n\n    for lKeyValue in TableMap.fMap do\n    begin\n      if lKeyValue.Value.Insertable then\n      begin\n        lSB.Append(GetFieldNameForSQL(lKeyValue.Value.FieldName) + ',');\n      end;\n    end;\n\n    lSB.Remove(lSB.Length - 1, 1);\n    lSB.Append(') values (');\n    if lPKInInsert then\n    begin\n      lSB.Append(':' + GetParamNameForSQL(TableMap.fPrimaryKeyFieldName) + ',');\n    end;\n\n    {partition}\n    for lFieldName in fPartitionInfo.FieldNames do\n    begin\n      lSB.Append(':' + GetParamNameForSQL(lFieldName) + ',');\n    end;\n    {end-partition}\n\n    for lKeyValue in TableMap.fMap do\n    begin\n      if lKeyValue.Value.IsVersion then\n      begin\n        lSB.Append(OBJECT_VERSION_STARTING_VALUE + ',');\n      end else if lKeyValue.Value.Insertable then\n      begin\n        lSB.Append(':' + GetParamNameForSQL(lKeyValue.Value.FieldName) + ',');\n      end;\n    end;\n    lSB.Remove(lSB.Length - 1, 1);\n    lSB.Append(')');\n\n    if TMVCActiveRecordFieldOption.foAutoGenerated in TableMap.fPrimaryKeyOptions then\n    begin\n      lSB.Append(';SELECT LAST_INSERT_ID() as ' + TableMap.fPrimaryKeyFieldName);\n    end;\n    Result := lSB.ToString;\n  finally\n    lSB.Free;\n  end;\nend;\n\nfunction TMVCSQLGeneratorMySQL.GetCompilerClass: TRQLCompilerClass;\nbegin\n  Result := TRQLMySQLCompiler;\nend;\n\ninitialization\n\nTMVCSQLGeneratorRegistry.Instance.RegisterSQLGenerator('mysql', TMVCSQLGeneratorMySQL);\n\nfinalization\n\nTMVCSQLGeneratorRegistry.Instance.UnRegisterSQLGenerator('mysql');\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing MVCFramework.RQL.Parser;       \nusing MVCFramework.ActiveRecord;    \nusing MVCFramework.Commons;          \n\nnamespace MVCFramework.SQLGenerators.MySQL\n{\n    \n    public class MVCSQLGeneratorMySQL : MVCSQLGenerator\n    {\n        \n        private const string OBJECT_VERSION_STARTING_VALUE = \"1\";\n\n        \n        protected override TRQLCompiler GetCompilerClass()\n        {\n           \n            return new TRQLMySQLCompiler();\n        }\n\n        \n        public override string CreateInsertSQL(MVCTableMap tableMap, MVCActiveRecord arInstance)\n        {\n            \n            bool pkInInsert = !string.IsNullOrEmpty(tableMap.PrimaryKeyFieldName) &&\n                              !tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.AutoGenerated);\n            pkInInsert = pkInInsert && !tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.ReadOnly);\n\n            StringBuilder sb = new StringBuilder();\n            try\n            {\n                sb.Append(\"INSERT INTO \" + GetTableNameForSQL(tableMap.TableName) + \"(\");\n                if (pkInInsert)\n                {\n                    sb.Append(GetFieldNameForSQL(tableMap.PrimaryKeyFieldName) + \",\");\n                }\n\n                foreach (string fieldName in this.PartitionInfo.FieldNames)\n                {\n                    sb.Append(GetFieldNameForSQL(fieldName) + \",\");\n                }\n\n                foreach (var keyValue in tableMap.Map)\n                {\n                    if (keyValue.Value.Insertable)\n                    {\n                        sb.Append(GetFieldNameForSQL(keyValue.Value.FieldName) + \",\");\n                    }\n                }\n\n                if (sb[sb.Length - 1] == ',')\n                    sb.Remove(sb.Length - 1, 1);\n\n                sb.Append(\") values (\");\n\n                if (pkInInsert)\n                {\n                    sb.Append(\":\" + GetParamNameForSQL(tableMap.PrimaryKeyFieldName) + \",\");\n                }\n\n                foreach (string fieldName in this.PartitionInfo.FieldNames)\n                {\n                    sb.Append(\":\" + GetParamNameForSQL(fieldName) + \",\");\n                }\n\n                foreach (var keyValue in tableMap.Map)\n                {\n                    if (keyValue.Value.IsVersion)\n                    {\n                        sb.Append(OBJECT_VERSION_STARTING_VALUE + \",\");\n                    }\n                    else if (keyValue.Value.Insertable)\n                    {\n                        sb.Append(\":\" + GetParamNameForSQL(keyValue.Value.FieldName) + \",\");\n                    }\n                }\n\n                if (sb[sb.Length - 1] == ',')\n                    sb.Remove(sb.Length - 1, 1);\n\n                sb.Append(\")\");\n\n                if (tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.AutoGenerated))\n                {\n                    sb.Append(\";SELECT LAST_INSERT_ID() as \" + tableMap.PrimaryKeyFieldName);\n                }\n\n                return sb.ToString();\n            }\n            finally\n            {\n                // Dispose StringBuilder if needed.\n            }\n        }\n    }\n\n    \n    public static class MVCSQLGeneratorMySQLRegistration\n    {\n        static MVCSQLGeneratorMySQLRegistration()\n        {\n            MVCSQLGeneratorRegistry.Instance.RegisterSQLGenerator(\"mysql\", typeof(MVCSQLGeneratorMySQL));\n        }\n\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Server;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  MVCFramework.Commons, MVCFramework;\n\ntype\n\n  EMVCServerException = class(Exception);\n\n  IMVCListenerProperties = interface\n    ['{82721C88-A308-4B2E-B94A-8E7CEEC4721F}']\n    function GetName: string;\n    function SetName(const AValue: string): IMVCListenerProperties;\n\n    function GetPort: Integer;\n    function SetPort(AValue: Integer): IMVCListenerProperties;\n\n    function GetMaxConnections: Integer;\n    function SetMaxConnections(AValue: Integer): IMVCListenerProperties;\n\n    function GetWebModuleClass: TComponentClass;\n    function SetWebModuleClass(AValue: TComponentClass): IMVCListenerProperties;\n\n    function GetSSLOptions(out SSLCertFile, SSLRootCertFile, SSLKeyFile, SSLPassword: String): Boolean;\n    function SetSSLOptions(const SSLCertFile, SSLRootCertFile, SSLKeyFile, SSLPassword: String): IMVCListenerProperties;\n  end;\n\n  IMVCListener = interface\n    ['{127A5E5D-D968-4409-BE9A-8D3AE08E6009}']\n    function GetActive: Boolean;\n\n    procedure Start;\n    procedure Stop;\n\n    property Active: Boolean read GetActive;\n  end;\n\n  IMVCListenersContext = interface\n    ['{9EA6BBDB-B5C1-462E-BBF4-AA30A4317F54}']\n    function Add(const AName: string; AListener: IMVCListener): IMVCListenersContext; overload;\n    function Add(AProperties: IMVCListenerProperties): IMVCListenersContext; overload;\n    function Remove(const AListenerName: string): IMVCListenersContext;\n\n    procedure StartAll;\n    procedure StopAll;\n\n    function FindByName(const AListenerName: string): IMVCListener;\n\n    procedure ForEach(AProc: TProc<string, IMVCListener>);\n    function Count: Integer;\n  end;\n\n  TMVCRequestDelegate = reference to procedure(const AControllerQualifiedClassName, AActionName: string;\n    var AAuthenticationRequired: Boolean);\n\n  TMVCAuthenticationDelegate = reference to procedure(const AUserName, APassword: string; AUserRoles: TList<string>;\n    var IsValid: Boolean; const ASessionData: TDictionary<String, String>);\n\n  TMVCAuthorizationDelegate = reference to procedure(AUserRoles: TList<string>; const AControllerQualifiedClassName: string;\n    const AActionName: string; var IsAuthorized: Boolean);\n\n  IMVCDefaultAuthenticationHandler = interface(IMVCAuthenticationHandler)\n    ['{0B292EEF-B871-4FA9-81AC-FED633C3A238}']\n    function SetOnRequest(AMethod: TMVCRequestDelegate): IMVCDefaultAuthenticationHandler;\n    function SetOnAuthentication(AMethod: TMVCAuthenticationDelegate): IMVCDefaultAuthenticationHandler;\n    function SetOnAuthorization(AMethod: TMVCAuthorizationDelegate): IMVCDefaultAuthenticationHandler;\n  end;\n\nimplementation\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace MVCFramework.Server\n{\n    public class MVCServerException : Exception\n    {\n        public MVCServerException() { }\n        public MVCServerException(string message) : base(message) { }\n        public MVCServerException(string message, Exception innerException) : base(message, innerException) { }\n    }\n\n    public interface IMVCListenerProperties\n    {\n        string Name { get; set; }\n        IMVCListenerProperties SetName(string value);\n\n        int Port { get; set; }\n        IMVCListenerProperties SetPort(int value);\n\n        int MaxConnections { get; set; }\n        IMVCListenerProperties SetMaxConnections(int value);\n\n        Type WebModuleClass { get; set; }\n        IMVCListenerProperties SetWebModuleClass(Type value);\n\n        \n        bool TryGetSSLOptions(out string sslCertFile, out string sslRootCertFile, out string sslKeyFile, out string sslPassword);\n        \n        IMVCListenerProperties SetSSLOptions(string sslCertFile, string sslRootCertFile, string sslKeyFile, string sslPassword);\n    }\n\n    \n    public interface IMVCListener\n    {\n        bool Active { get; }\n        void Start();\n        void Stop();\n    }\n\n    \n    public interface IMVCListenersContext\n    {\n        \n        IMVCListenersContext Add(string name, IMVCListener listener);\n        \n        IMVCListenersContext Add(IMVCListenerProperties properties);\n        \n        IMVCListenersContext Remove(string listenerName);\n\n        \n        void StartAll();\n        \n        void StopAll();\n\n        \n        IMVCListener FindByName(string listenerName);\n\n        \n        void ForEach(Action<string, IMVCListener> action);\n        \n        int Count { get; }\n    }\n\n    \n    public delegate void MVCRequestDelegate(string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n\n    \n    public delegate void MVCAuthenticationDelegate(string userName, string password, List<string> userRoles, ref bool isValid, IDictionary<string, string> sessionData);\n\n    \n    public delegate void MVCAuthorizationDelegate(List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized);\n\n    \n    public interface IMVCDefaultAuthenticationHandler : IMVCAuthenticationHandler\n    {\n        IMVCDefaultAuthenticationHandler SetOnRequest(MVCRequestDelegate method);\n        IMVCDefaultAuthenticationHandler SetOnAuthentication(MVCAuthenticationDelegate method);\n        IMVCDefaultAuthenticationHandler SetOnAuthorization(MVCAuthorizationDelegate method);\n    }\n\n    \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit AuthHandlersU;\n\ninterface\n\nuses\n  MVCFramework.Commons, System.Generics.Collections, MVCFramework;\n\ntype\n  TAuthHandlerBase = class abstract(TInterfacedObject, IMVCAuthenticationHandler)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); virtual; abstract;\n    procedure OnAuthentication(const AContext: TWebContext; const UserName: string; const Password: string;\n      UserRoles: System.Generics.Collections.TList<System.string>;\n      var IsValid: Boolean; const SessionData: TDictionary<string, string>); virtual;\n    procedure OnAuthorization(const AContext: TWebContext;\n      UserRoles: System.Generics.Collections.TList<System.string>;\n      const ControllerQualifiedClassName: string; const ActionName: string;\n      var IsAuthorized: Boolean); virtual;\n  end;\n\n  TBasicAuthHandler = class(TAuthHandlerBase)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); override;\n  end;\n\n  TCustomAuthHandler = class(TAuthHandlerBase)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nprocedure TAuthHandlerBase.OnAuthentication(\n  const AContext: TWebContext;\n  const UserName: string; const Password: string;\n  UserRoles: System.Generics.Collections.TList<System.string>; var IsValid: Boolean;\n  const SessionData: TDictionary<string, string>);\nbegin\n  UserRoles.Clear;\n  IsValid := UserName = Password;\n  if not IsValid then\n    Exit;\n  if UserName = 'user1' then\n  begin\n    IsValid := True;\n    UserRoles.Add('role1');\n  end;\n  if UserName = 'user2' then\n  begin\n    IsValid := True;\n    UserRoles.Add('role2');\n  end;\nend;\n\nprocedure TAuthHandlerBase.OnAuthorization(\n  const AContext: TWebContext;\n  UserRoles: System.Generics.Collections.TList<System.string>;\n  const ControllerQualifiedClassName, ActionName: string;\n  var IsAuthorized: Boolean);\nbegin\n  IsAuthorized := False;\n  if (ActionName = 'OnlyRole1') or (ActionName = 'OnlyRole1Session') then\n    IsAuthorized := UserRoles.Contains('role1');\n  if ActionName = 'OnlyRole2' then\n    IsAuthorized := UserRoles.Contains('role2');\nend;\n\nprocedure TBasicAuthHandler.OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean);\nbegin\n  AuthenticationRequired := ControllerQualifiedClassName.EndsWith\n    ('TTestPrivateServerController');\nend;\n\nprocedure TCustomAuthHandler.OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean);\nbegin\n  AuthenticationRequired := ControllerQualifiedClassName.EndsWith\n    ('TTestPrivateServerControllerCustomAuth');\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace AuthHandlerU\n{\n    public class WebContext\n    {\n        // Add any context properties as needed.\n    }\n    \n    public interface IMVCAuthenticationHandler\n    {\n        void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n        void OnAuthentication(WebContext context, string userName, string password, List<string> userRoles, ref bool isValid, Dictionary<string, string> sessionData);\n        void OnAuthorization(WebContext context, List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized);\n    }\n    \n    public abstract class AuthHandlerBase : IMVCAuthenticationHandler\n    {\n        public abstract void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n        \n        public virtual void OnAuthentication(WebContext context, string userName, string password, List<string> userRoles, ref bool isValid, Dictionary<string, string> sessionData)\n        {\n            userRoles.Clear();\n            isValid = userName == password;\n            if (!isValid)\n                return;\n            if (userName == \"user1\")\n            {\n                isValid = true;\n                userRoles.Add(\"role1\");\n            }\n            if (userName == \"user2\")\n            {\n                isValid = true;\n                userRoles.Add(\"role2\");\n            }\n        }\n        \n        public virtual void OnAuthorization(WebContext context, List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized)\n        {\n            isAuthorized = false;\n            if (actionName == \"OnlyRole1\" || actionName == \"OnlyRole1Session\")\n                isAuthorized = userRoles.Contains(\"role1\");\n            if (actionName == \"OnlyRole2\")\n                isAuthorized = userRoles.Contains(\"role2\");\n        }\n    }\n    \n    public class BasicAuthHandler : AuthHandlerBase\n    {\n        public override void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired)\n        {\n            authenticationRequired = controllerQualifiedClassName.EndsWith(\"TTestPrivateServerController\");\n        }\n    }\n    \n    public class CustomAuthHandler : AuthHandlerBase\n    {\n        public override void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired)\n        {\n            authenticationRequired = controllerQualifiedClassName.EndsWith(\"TTestPrivateServerControllerCustomAuth\");\n        }\n    }\n}"}
{"input": "unit Service2U;\n\ninterface\n\nuses\n  ServicesInterfaceU, Spring.Container.Common;\n\ntype\n  TCustomersService = class(TInterfacedObject, ICustomersService)\n  protected\n    [Inject]\n    fCommonService: ICommonService;\n  public\n    function GetCustomerNameByID(const ID: Integer): string;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TCustomersService }\n\nfunction TCustomersService.GetCustomerNameByID(const ID: Integer): string;\nbegin\n  Result := Format('Customer #%d (CommonServiceID = %s)', [ID, fCommonService.GetID]);\nend;\n\nend.", "output": "using System;\nusing ServicesInterfaceU;\nusing Spring.Container.Common;\n\nnamespace ServiceNamespace\n{\n    public class CustomersService : ICustomersService\n    {\n        [Inject]\n        private ICommonService commonService;\n\n        public string GetCustomerNameByID(int id)\n        {\n            return string.Format(\"Customer #{0} (CommonServiceID = {1})\", id, commonService.GetID);\n        }\n    }\n}"}
{"input": "{ Invokable implementation File for TSOAPCustomer which implements ISOAPCustomer }\n\nunit SOAPCustomerImplU;\n\ninterface\n\nuses Soap.InvokeRegistry, System.Types, Soap.XSBuiltIns, SOAPCustomerIntfU;\n\ntype\n\n  { TSOAPCustomer }\n  TSOAPCustomer = class(TInvokableClass, ISOAPCustomer)\n  public\n    function GetCustomers: string; stdcall;\n  end;\n\nimplementation\n\nuses\n  BOCustomersU, WSHelperCustomersU, System.SysUtils, System.JSON, MVCFramework.Serializer.Defaults;\n\nfunction TSOAPCustomer.GetCustomers: string;\nvar\n  WSHelperCustomers: TWSHelperCustomers;\n  Customers: TCustomers;\nbegin\n  WSHelperCustomers := TWSHelperCustomers.Create;\n  try\n    begin\n      Customers := WSHelperCustomers.GetCustomers;\n      try\n        Result := GetDefaultSerializer.SerializeCollection(Customers);\n      finally\n        FreeAndNil(Customers);\n      end;\n    end;\n  finally\n    FreeAndNil(WSHelperCustomers);\n  end;\nend;\n\ninitialization\n\n{ Invokable classes must be registered }\nInvRegistry.RegisterInvokableClass(TSOAPCustomer);\n\nend.", "output": "using System;\nusing System.Web.Services;\nusing SOAPCustomerIntfU;\nusing BOCustomersU;\nusing WSHelperCustomersU;\nusing MVCFramework.Serializer.Defaults;\n\n[WebService(Namespace = \"http://tempuri.org/\")]\n[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]\npublic class SOAPCustomer : WebService, ISOAPCustomer\n{\n    [WebMethod]\n    public string GetCustomers()\n    {\n        WSHelperCustomers wsHelper = new WSHelperCustomers();\n        try\n        {\n            var customers = wsHelper.GetCustomers();\n            try\n            {\n                return GetDefaultSerializer().SerializeCollection(customers);\n            }\n            finally\n            {\n                if (customers is IDisposable disposableCustomers)\n                {\n                    disposableCustomers.Dispose();\n                }\n            }\n        }\n        finally\n        {\n            if (wsHelper is IDisposable disposableWsHelper)\n            {\n                disposableWsHelper.Dispose();\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MainControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/api')]\n  TMainController = class(TMVCController) \n  public\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n\n    [MVCPath('/reversedstrings/($Value)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetReversedString(const Value: String);\n  protected\n    procedure OnBeforeAction(Context: TWebContext; const AActionName: string; var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionName: string); override;\n\n  public\n    //Sample CRUD Actions for a \"Customer\" entity\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomers;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomer(id: Integer);\n\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure CreateCustomer;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    procedure UpdateCustomer(id: Integer);\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    procedure DeleteCustomer(id: Integer);\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\nprocedure TMainController.Index;\nbegin\n  //use Context property to access to the HTTP request and response \n  Render('Hello DelphiMVCFramework World');\nend;\n\nprocedure TMainController.GetReversedString(const Value: String);\nbegin\n  Render(System.StrUtils.ReverseString(Value.Trim));\nend;\n\nprocedure TMainController.OnAfterAction(Context: TWebContext; const AActionName: string); \nbegin\n  { Executed after each action }\n  inherited;\nend;\n\nprocedure TMainController.OnBeforeAction(Context: TWebContext; const AActionName: string; var Handled: Boolean);\nbegin\n  { Executed before each action\n    if handled is true (or an exception is raised) the actual\n    action will not be called }\n  inherited;\nend;\n\n//Sample CRUD Actions for a \"Customer\" entity\nprocedure TMainController.GetCustomers;\nbegin\n  //todo: render a list of customers\nend;\n\nprocedure TMainController.GetCustomer(id: Integer);\nbegin\n  //todo: render the customer by id\nend;\n\nprocedure TMainController.CreateCustomer;\n\nbegin\n  //todo: create a new customer\nend;\n\nprocedure TMainController.UpdateCustomer(id: Integer);\nbegin\n  //todo: update customer by id\nend;\n\nprocedure TMainController.DeleteCustomer(id: Integer);\nbegin\n  //todo: delete customer by id\nend;\n\n\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing System;\nusing System.Linq;\n\nnamespace MyMvcApp.Controllers\n{\n    \n    [Route(\"api\")]\n    [ApiController]\n    public class MainController : ControllerBase\n    {\n        \n        [HttpGet]\n        public IActionResult Index()\n        {\n            \n            return Content(\"Hello DelphiMVCFramework World\");\n        }\n\n        \n        [HttpGet(\"reversedstrings/{value}\")]\n        public IActionResult GetReversedString(string value)\n        {\n            if (string.IsNullOrWhiteSpace(value))\n            {\n                return BadRequest(\"Value cannot be empty.\");\n            }\n            \n            string reversed = new string(value.Trim().Reverse().ToArray());\n            return Content(reversed);\n        }\n\n        \n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n           \n            return Ok(\"GetCustomers not implemented\");\n        }\n\n        \n        [HttpGet(\"customers/{id:int}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            \n            return Ok($\"GetCustomer {id} not implemented\");\n        }\n\n        \n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer()\n        {\n            \n            return Ok(\"CreateCustomer not implemented\");\n        }\n\n        \n        [HttpPut(\"customers/{id:int}\")]\n        public IActionResult UpdateCustomer(int id)\n        {\n            \n            return Ok($\"UpdateCustomer {id} not implemented\");\n        }\n\n        \n        [HttpDelete(\"customers/{id:int}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            \n            return Ok($\"DeleteCustomer {id} not implemented\");\n        }\n\n        \n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            \n            base.OnActionExecuting(context);\n        }\n\n        public override void OnActionExecuted(ActionExecutedContext context)\n        {\n            \n            base.OnActionExecuted(context);\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// Contributors for this file: \n//    Fulgan - https://github.com/Fulgan\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.NSQAppender;\n\ninterface\n\nuses Classes, SysUtils, LoggerPro, System.Net.HttpClient;\n\ntype\n\n{\n  Author: St\ufffdphane \"Fulgan\" GROBETY (https://github.com/Fulgan/)\n  Log appender for NSQ (https://nsq.io) (https://github.com/nsqio/nsq)\n  \"NSQ is a realtime message processing system designed to operate at bitly's\n  scale, handling billions of messages per day. It promotes distributed and\n  decentralized topologies without single points of failure, enabling fault\n  tolerance and high availability coupled with a reliable message delivery\n  guarantee\"\n\n  For testing, you can navigate to the NSQ folder and type the following commands:\n\n  This starts the NSQLookup service then starts a listener on the default\n  endpoint(http:/127.0.0.1:4151)\n\n  start nsqlookupd\n  start nsqd --lookupd-tcp-address=127.0.0.1:4160\n\n\n  This starts a consumer for the topic \"test\" that outputs the messages to the console:\n\n  start nsq_tail --topic=test --lookupd-http-address=127.0.0.1:4161\n\n  (optional) This starts a consumer for the ephemeral topic \"test\" that outputs the messages to the console:\n\n  start nsq_tail --topic=test#ephemeral --lookupd-http-address=127.0.0.1:4161\n\n  (optional) This starts a NSQAdmin web interface that can be reached on http://localhost:4171/\n\n  start nsqadmin --lookupd-http-address=127.0.0.1:4161\n\n  Note about consumers:\n  - If there is no consumer to received messages for a channel, NSQ will\n    save them to memory and disk unless the topic has been marked as Ephemeral.\n    Use NSQAdmin to delete any extra channel created.\n  - Ephemeral topics are not saved or cached and the topic will be deleted\n    once the last consumer disconnects\n  - Writing a consumer is more complex than writing a client. A list of available\n    client libraries can be found at https://nsq.io/clients/client_libraries.html\n}\n\n\n  TOnCreateData = procedure(const sender : TObject; const LogItem: TLogItem; var Data: TStream);\n  TOnNetSendError = procedure(const sender : TObject; const LogItem: TLogItem; const NetError: ENetHTTPClientException; var RetryCount: Integer);\n  TLoggerProNSQAppenderBase = class(TLoggerProAppenderBase, ILogAppender)\n  private\n    FOnCreateData: TOnCreateData;\n    FOnNetSendError: TOnNetSendError;\n    procedure SetOnCreateData(const Value: TOnCreateData);\n    procedure SetOnNetSendError(const Value: TOnNetSendError);\n  protected\n    FNSQUrl : string;\n    FTopic: String;\n    FUserName, FMachineName: string;\n    FEphemeral: Boolean;\n    FLastSignature: string;\n  public\n    const DEFAULT_NSQ_URL = 'http://127.0.0.1:4151';\n\n    function GetNSQUrl: string;\n    procedure SetNSQUrl(const Value: string);\n    function GetTopic: string;\n    procedure SetTopic(const Value: string);\n    procedure SetEphemeral(const Value: Boolean);\n    /// <summary>TLoggerProNSQAppenderBase.Create\n    /// </summary>\n    /// <param name=\"aTopic\"> (string) This is the \"topic\" of the channel. If left\n    /// empty, the LogItem's tag will be used. </param>\n    /// <param name=\"aEphemeral\"> (Boolean) If true, the NSQ channel will be marked as\n    /// Ephemeral: messages sent to this channel will neither be cached nor\n    /// queued</param>\n    /// <param name=\"aNSQUrl\"> (string) URL of the NSQD service (usually, http://127.0.\n    /// 0.1:4151)</param>\n    /// <param name=\"aLogFormat\"> (string) Log format to use if no custom log message\n    /// creation event is defined </param>\n    constructor Create(aTopic: string=''; aEphemeral: Boolean = False;\n        aNSQUrl: string=DEFAULT_NSQ_URL;\n        aLogItemRenderer: ILogItemRenderer = nil);\n        reintroduce;\n    property NSQUrl: string read GetNSQUrl write SetNSQUrl;\n    property Ephemeral: Boolean read FEphemeral write SetEphemeral;\n    property OnCreateData: TOnCreateData read FOnCreateData write SetOnCreateData;\n    property OnNetSendError: TOnNetSendError read FOnNetSendError write SetOnNetSendError;\n    property Topic: string read GetTopic write SetTopic;\n    procedure TearDown; override;\n    procedure Setup; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    function CreateData(const SrcLogItem: TLogItem): TStream; virtual;\n  end;\n\nimplementation\n\nuses  System.NetEncoding;\n\nconstructor TLoggerProNSQAppenderBase.Create(aTopic: string; aEphemeral: Boolean;\n  aNSQUrl: string; aLogItemRenderer: ILogItemRenderer);\nbegin\n  inherited Create(aLogItemRenderer);\n  FEphemeral := aEphemeral;\n  FNSQUrl := 'http://127.0.0.1:4151';\n  FUserName := aNSQUrl;\n  FTopic := aTopic;\nend;\n\nfunction TLoggerProNSQAppenderBase.CreateData(\n  const SrcLogItem: TLogItem): TStream;\nbegin\n  result := nil;\n  try\n    if assigned(FOnCreateData) then\n    begin\n      FOnCreateData(Self, SrcLogItem, Result);\n    end\n    else\n    begin\n      result := TStringStream.Create(FormatLog(SrcLogItem), TEncoding.UTF8);\n    end;\n  except\n    on e: Exception do\n    begin\n      FreeAndNil(Result);\n      raise;\n    end;\n  end;\nend;\n\nfunction TLoggerProNSQAppenderBase.GetNSQUrl: string;\nbegin\n  result := FNSQUrl;\nend;\n\nfunction TLoggerProNSQAppenderBase.GetTopic: string;\nbegin\n  result := FTopic;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetEphemeral(const Value: Boolean);\nbegin\n  FEphemeral := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetNSQUrl(const Value: string);\nbegin\n  FNSQUrl := value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetOnCreateData(const Value: TOnCreateData);\nbegin\n  FOnCreateData := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetOnNetSendError(\n  const Value: TOnNetSendError);\nbegin\n  FOnNetSendError := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetTopic(const Value: string);\nbegin\n  FTopic := value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProNSQAppenderBase.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProNSQAppenderBase.WriteLog(const aLogItem: TLogItem);\nvar\n  FHTTPCli: THTTPClient;\n  URI: string;\n  Data: TStream;\n  TopicName: string;\n  FRetryCount: Integer;\nbegin\n  FRetryCount := 0;\n  FHTTPCli := THTTPClient.Create;\n  try\n    if Topic.trim.IsEmpty then\n      TopicName := aLogItem.LogTag.Trim\n    else\n      TopicName := Topic.Trim;\n    URI :=NSQUrl + '/pub?topic=' + TNetEncoding.URL.Encode(TopicName);\n    if Ephemeral then\n      URI := URI + '#ephemeral';\n    Data := CreateData(aLogItem);\n    if Assigned(Data) then\n    begin\n      repeat\n        try\n          // Set very short timeouts: this is a local call and we don't want to block the queue for too long.\n{$IF CompilerVersion >= 31}\n          FHTTPCli.ConnectionTimeout := 100;\n          FHTTPCli.ResponseTimeout := 200;\n{$ENDIF}\n          Data.Seek(0, soFromBeginning);\n          // ignore the respnse: as long as NSQD has accepted the POST, it will handle the result\n          FHTTPCli.Post(URI, Data);\n          break;\n        except\n          on e: ENetHTTPClientException do\n          begin\n            // if there is an event handler for net exception, call it\n            if Assigned(FOnNetSendError) then\n              OnNetSendError(self, aLogItem, e, FRetryCount);\n            // if the handler has set FRetryCount to a positive value then retry the call\n            if FRetryCount <= 0 then\n              break;\n          end;\n        end;\n      until false;\n    end;\n  finally\n    FreeAndNil(FHTTPCli);\n  end;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Http.Json;\nusing System.Text;\nusing LoggerPro; \nusing System.Threading.Tasks;\nusing System.Web;\n\nnamespace LoggerPro.Appenders\n{\n    \n    public delegate void OnCreateData(object sender, TLogItem logItem, out Stream data);\n    public delegate void OnNetSendError(object sender, TLogItem logItem, Exception netError, ref int retryCount);\n\n    \n    public class LoggerProNSQAppenderBase : LoggerProAppenderBase, ILogAppender\n    {\n        public const string DEFAULT_NSQ_URL = \"http://127.0.0.1:4151\";\n\n        \n        private OnCreateData _onCreateData;\n        private OnNetSendError _onNetSendError;\n\n        \n        private string _nsqUrl;\n        private string _topic;\n        private bool _ephemeral;\n        \n        private string _userName;\n        private string _machineName;\n        private string _lastSignature;\n\n        public LoggerProNSQAppenderBase(string topic = \"\", bool ephemeral = false, string nsqUrl = DEFAULT_NSQ_URL, ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n            \n            _ephemeral = ephemeral;\n            _nsqUrl = nsqUrl; \n            _userName = nsqUrl; \n            _topic = topic;\n        }\n\n       \n        public string NSQUrl\n        {\n            get => _nsqUrl;\n            set => _nsqUrl = value;\n        }\n\n        \n        public string Topic\n        {\n            get => _topic;\n            set => _topic = value;\n        }\n\n        \n        public bool Ephemeral\n        {\n            get => _ephemeral;\n            set => _ephemeral = value;\n        }\n\n        public OnCreateData OnCreateData\n        {\n            get => _onCreateData;\n            set => _onCreateData = value;\n        }\n\n        public OnNetSendError OnNetSendError\n        {\n            get => _onNetSendError;\n            set => _onNetSendError = value;\n        }\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public virtual Stream CreateData(TLogItem srcLogItem)\n        {\n            try\n            {\n                if (OnCreateData != null)\n                {\n                    OnCreateData(this, srcLogItem, out Stream data);\n                    return data;\n                }\n                else\n                {\n                    \n                    string logText = FormatLog(srcLogItem);\n                    return new MemoryStream(Encoding.UTF8.GetBytes(logText));\n                }\n            }\n            catch (Exception)\n            {\n                \n                throw;\n            }\n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            \n            using (HttpClient httpClient = new HttpClient())\n            {\n                \n                string topicName = string.IsNullOrWhiteSpace(Topic) ? logItem.LogTag.Trim() : Topic.Trim();\n\n                \n                string uri = NSQUrl.TrimEnd('/') + \"/pub?topic=\" + HttpUtility.UrlEncode(topicName);\n                if (Ephemeral)\n                {\n                    uri += \"#ephemeral\";\n                }\n\n                \n                Stream data = CreateData(logItem);\n                if (data != null)\n                {\n                    while (true)\n                    {\n                        try\n                        {\n                            \n                            httpClient.Timeout = TimeSpan.FromMilliseconds(200);\n                            data.Seek(0, SeekOrigin.Begin);\n                            \n                            using (var content = new StreamContent(data))\n                            {\n                                \n                                content.Headers.ContentType = new MediaTypeHeaderValue(\"text/plain\")\n                                {\n                                    CharSet = \"utf-8\"\n                                };\n                                \n                                HttpResponseMessage response = httpClient.PostAsync(uri, content).Result;\n                                response.EnsureSuccessStatusCode();\n                            }\n                            break;\n                        }\n                        catch (HttpRequestException ex)\n                        {\n                            \n                            if (OnNetSendError != null)\n                            {\n                                OnNetSendError(this, logItem, ex, ref retryCount);\n                            }\n                            retryCount++;\n                            if (retryCount >= 5) \n                            {\n                                \n                                throw;\n                            }\n                            \n                            System.Threading.Thread.Sleep(200);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"}
{"input": "unit MultipleLoggersU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,\n  System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, LoggerPro, Vcl.StdCtrls;\n\ntype\n  TMultipleLoggersForm = class(TForm)\n    Memo1: TMemo;\n    btnFormLocalLog: TButton;\n    btnApplicationLevelLog: TButton;\n    procedure FormCreate(Sender: TObject);\n    procedure btnFormLocalLogClick(Sender: TObject);\n    procedure btnApplicationLevelLogClick(Sender: TObject);\n  private\n    FLogWriter: ILogWriter;\n    function LocalLog: ILogWriter;\n  public\n    { Public declarations }\n  end;\n\nvar\n  MultipleLoggersForm: TMultipleLoggersForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender, LoggerProConfig;\n\n{$R *.dfm}\n\nprocedure TMultipleLoggersForm.btnApplicationLevelLogClick(Sender: TObject);\nbegin\n  Log.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the application level LoggerPro instance (random type)',\n    'APP');\nend;\n\nprocedure TMultipleLoggersForm.btnFormLocalLogClick(Sender: TObject);\nbegin\n  LocalLog.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the form local LoggerPro instance (random type)', 'tag');\nend;\n\nprocedure TMultipleLoggersForm.FormCreate(Sender: TObject);\nbegin\n  FLogWriter := BuildLogWriter([TVCLMemoLogAppender.Create(Memo1)], nil,\n    TLogType.Info);\n  FLogWriter.Info('Local log correctly initialized', 'tag');\nend;\n\nfunction TMultipleLoggersForm.LocalLog: ILogWriter;\nbegin\n  Result := FLogWriter;\nend;\n\nend.", "output": "unit MultipleLoggersU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,\n  System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, LoggerPro, Vcl.StdCtrls;\n\ntype\n  TMultipleLoggersForm = class(TForm)\n    Memo1: TMemo;\n    btnFormLocalLog: TButton;\n    btnApplicationLevelLog: TButton;\n    procedure FormCreate(Sender: TObject);\n    procedure btnFormLocalLogClick(Sender: TObject);\n    procedure btnApplicationLevelLogClick(Sender: TObject);\n  private\n    FLogWriter: ILogWriter;\n    function LocalLog: ILogWriter;\n  public\n    { Public declarations }\n  end;\n\nvar\n  MultipleLoggersForm: TMultipleLoggersForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender, LoggerProConfig;\n\n{$R *.dfm}\n\nprocedure TMultipleLoggersForm.btnApplicationLevelLogClick(Sender: TObject);\nbegin\n  Log.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the application level LoggerPro instance (random type)',\n    'APP');\nend;\n\nprocedure TMultipleLoggersForm.btnFormLocalLogClick(Sender: TObject);\nbegin\n  LocalLog.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the form local LoggerPro instance (random type)', 'tag');\nend;\n\nprocedure TMultipleLoggersForm.FormCreate(Sender: TObject);\nbegin\n  FLogWriter := BuildLogWriter([TVCLMemoLogAppender.Create(Memo1)], nil,\n    TLogType.Info);\n  FLogWriter.Info('Local log correctly initialized', 'tag');\nend;\n\nfunction TMultipleLoggersForm.LocalLog: ILogWriter;\nbegin\n  Result := FLogWriter;\nend;\n\nend."}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.RQL.AST2PostgreSQL;\n\ninterface\n\nuses\n  MVCFramework.RQL.Parser;\n\ntype\n  TRQLPostgreSQLCompiler = class(TRQLCompiler)\n  private\n    function RQLFilterToSQL(const aRQLFIlter: TRQLFilter): string;\n    function RQLSortToSQL(const aRQLSort: TRQLSort): string;\n    function RQLLimitToSQL(const aRQLLimit: TRQLLimit): string;\n    function RQLWhereToSQL(const aRQLWhere: TRQLWhere): string;\n    function RQLLogicOperatorToSQL(const aRQLFIlter: TRQLLogicOperator): string;\n  protected\n    function RQLCustom2SQL(const aRQLCustom: TRQLCustom): string; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  FireDAC.Phys.PG;\n\n{ TRQLPostgreSQLCompiler }\n\nfunction TRQLPostgreSQLCompiler.RQLCustom2SQL(\n  const aRQLCustom: TRQLCustom): string;\nbegin\n  if aRQLCustom is TRQLFilter then\n  begin\n    Result := RQLFilterToSQL(TRQLFilter(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLLogicOperator then\n  begin\n    Result := RQLLogicOperatorToSQL(TRQLLogicOperator(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLSort then\n  begin\n    Result := RQLSortToSQL(TRQLSort(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLLimit then\n  begin\n    Result := RQLLimitToSQL(TRQLLimit(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLWhere then\n  begin\n    Result := RQLWhereToSQL(TRQLWhere(aRQLCustom));\n  end\n  else\n    raise ERQLException.CreateFmt('Unknown token in compiler: %s', [aRQLCustom.ClassName]);\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLFilterToSQL(const aRQLFIlter: TRQLFilter): string;\nvar\n  lValue, lDBFieldName: string;\nbegin\n  if (aRQLFIlter.RightValueType = vtString) and not(aRQLFIlter.Token in [tkContains, tkStarts]) then\n    lValue := aRQLFIlter.OpRight.QuotedString('''')\n  else\n    lValue := aRQLFIlter.OpRight;\n\n  lDBFieldName := GetDatabaseFieldName(aRQLFIlter.OpLeft, True);\n\n  case aRQLFIlter.Token of\n    tkEq:\n      begin\n        if aRQLFIlter.RightValueType = vtNull then\n          Result := Format('(%s IS NULL)', [GetFieldNameForSQL(lDBFieldName)])\n        else\n          Result := Format('(%s = %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkLt:\n      begin\n        Result := Format('(%s < %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkLe:\n      begin\n        Result := Format('(%s <= %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkGt:\n      begin\n        Result := Format('(%s > %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkGe:\n      begin\n        Result := Format('(%s >= %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkNe:\n      begin\n        if aRQLFIlter.RightValueType = vtNull then\n          Result := Format('(%s IS NOT NULL)', [GetFieldNameForSQL(lDBFieldName)])\n        else\n          Result := Format('(%s != %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkContains:\n      begin\n        lValue := Format('%%%s%%', [lValue]).QuotedString('''');\n        Result := Format('(%s ILIKE %s)', [GetFieldNameForSQL(lDBFieldName), lValue.ToLower])\n      end;\n    tkStarts:\n      begin\n        lValue := Format('%s%%', [lValue]).QuotedString('''');\n        Result := Format('(%s ILIKE %s)', [GetFieldNameForSQL(lDBFieldName), lValue.ToLower])\n      end;\n    tkIn:\n      begin\n        case aRQLFIlter.RightValueType of\n          vtIntegerArray: // if array is empty, RightValueType is always vtIntegerArray\n            begin\n              Result := Format('(%s IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', aRQLFIlter.OpRightArray)\n                ]);\n            end;\n          vtStringArray:\n            begin\n              Result := Format('(%s IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', QuoteStringArray(aRQLFIlter.OpRightArray))\n                ]);\n            end;\n        else\n          raise ERQLException.Create('Invalid RightValueType for tkIn');\n        end;\n      end;\n    tkOut:\n      begin\n        case aRQLFIlter.RightValueType of\n          vtIntegerArray:\n            begin\n              Result := Format('(%s NOT IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', aRQLFIlter.OpRightArray)\n                ]);\n            end;\n          vtStringArray:\n            begin\n              Result := Format('(%s NOT IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', QuoteStringArray(aRQLFIlter.OpRightArray))\n                ]);\n            end;\n        else\n          raise ERQLException.Create('Invalid RightValueType for tkOut');\n        end;\n      end;\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLLimitToSQL(const aRQLLimit: TRQLLimit): string;\nbegin\n  if aRQLLimit.Start = 0 then\n  begin\n    Result := Format(' /*limit*/ LIMIT %d', [aRQLLimit.Count]);\n  end\n  else\n  begin\n    Result := Format(' /*limit*/ LIMIT %d OFFSET %d', [aRQLLimit.Count, aRQLLimit.Start]);\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLLogicOperatorToSQL(const aRQLFIlter: TRQLLogicOperator): string;\nvar\n  lJoin: string;\n  lRQLCustom: TRQLCustom;\n  lFirst: Boolean;\nbegin\n  case aRQLFIlter.Token of\n    tkAnd:\n      begin\n        lJoin := ' and ';\n      end;\n    tkOr:\n      begin\n        lJoin := ' or ';\n      end;\n  else\n    raise ERQLException.Create('Invalid token in RQLLogicOperator');\n  end;\n\n  Result := '';\n  lFirst := True;\n  for lRQLCustom in aRQLFIlter.FilterAST do\n  begin\n    if not lFirst then\n    begin\n      Result := Result + lJoin;\n    end;\n    lFirst := False;\n    Result := Result + RQLCustom2SQL(lRQLCustom);\n  end;\n  Result := '(' + Result + ')';\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLSortToSQL(const aRQLSort: TRQLSort): string;\nvar\n  I: Integer;\nbegin\n  Result := ' /*sort*/ ORDER BY';\n  for I := 0 to aRQLSort.Fields.Count - 1 do\n  begin\n    if I > 0 then\n      Result := Result + ',';\n    Result := Result + ' ' + GetFieldNameForSQL(GetDatabaseFieldName(aRQLSort.Fields[I], True));\n    if aRQLSort.Signs[I] = '+' then\n      Result := Result + ' ASC'\n    else\n      Result := Result + ' DESC';\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLWhereToSQL(const aRQLWhere: TRQLWhere): string;\nbegin\n  Result := ' WHERE ';\nend;\n\ninitialization\n\nTRQLCompilerRegistry.Instance.RegisterCompiler('postgresql', TRQLPostgreSQLCompiler);\n\nfinalization\n\nTRQLCompilerRegistry.Instance.UnRegisterCompiler('postgresql');\n\nend.", "output": "using System;\nusing System.Linq;\nusing System.Globalization;\nusing MVCFramework.RQL.Parser; \nusing MVCFramework.ActiveRecord; \n\nnamespace MVCFramework.RQL.AST2PostgreSQL\n{\n    \n    public class RQLPostgreSQLCompiler : RQLCompiler\n    {\n        \n        private string RQLFilterToSQL(TRQLFilter filter)\n        {\n            string value;\n            \n            if (filter.RightValueType == ValueTypeEnum.vtString &&\n                !(filter.Token == TokenType.tkContains || filter.Token == TokenType.tkStarts))\n            {\n                \n                value = QuoteString(filter.OpRight, \"'\");\n            }\n            else\n            {\n                value = filter.OpRight;\n            }\n\n            \n            string dbFieldName = GetDatabaseFieldName(filter.OpLeft, true);\n            string sqlField = GetFieldNameForSQL(dbFieldName);\n\n            switch (filter.Token)\n            {\n                case TokenType.tkEq:\n                    if (filter.RightValueType == ValueTypeEnum.vtNull)\n                        return $\"({sqlField} IS NULL)\";\n                    else\n                        return $\"({sqlField} = {value})\";\n\n                case TokenType.tkLt:\n                    return $\"({sqlField} < {value})\";\n\n                case TokenType.tkLe:\n                    return $\"({sqlField} <= {value})\";\n\n                case TokenType.tkGt:\n                    return $\"({sqlField} > {value})\";\n\n                case TokenType.tkGe:\n                    return $\"({sqlField} >= {value})\";\n\n                case TokenType.tkNe:\n                    if (filter.RightValueType == ValueTypeEnum.vtNull)\n                        return $\"({sqlField} IS NOT NULL)\";\n                    else\n                        return $\"({sqlField} != {value})\";\n\n                case TokenType.tkContains:\n                    {\n                        \n                        string likeValue = QuoteString($\"%{value.Trim('\\'')}%\", \"'\");\n                        \n                        return $\"({sqlField} ILIKE {likeValue.ToLowerInvariant()})\";\n                    }\n                case TokenType.tkStarts:\n                    {\n                        string likeValue = QuoteString($\"{value.Trim('\\'')}%\", \"'\");\n                        return $\"({sqlField} ILIKE {likeValue.ToLowerInvariant()})\";\n                    }\n                case TokenType.tkIn:\n                    {\n                        if (filter.RightValueType == ValueTypeEnum.vtIntegerArray)\n                        {\n                            string joined = string.Join(\",\", filter.OpRightArray);\n                            return $\"({sqlField} IN ({joined}))\";\n                        }\n                        else if (filter.RightValueType == ValueTypeEnum.vtStringArray)\n                        {\n                            string[] quotedArray = QuoteStringArray(filter.OpRightArray, \"'\");\n                            string joined = string.Join(\",\", quotedArray);\n                            return $\"({sqlField} IN ({joined}))\";\n                        }\n                        else\n                        {\n                            throw new RQLException(\"Invalid RightValueType for tkIn\");\n                        }\n                    }\n                case TokenType.tkOut:\n                    {\n                        if (filter.RightValueType == ValueTypeEnum.vtIntegerArray)\n                        {\n                            string joined = string.Join(\",\", filter.OpRightArray);\n                            return $\"({sqlField} NOT IN ({joined}))\";\n                        }\n                        else if (filter.RightValueType == ValueTypeEnum.vtStringArray)\n                        {\n                            string[] quotedArray = QuoteStringArray(filter.OpRightArray, \"'\");\n                            string joined = string.Join(\",\", quotedArray);\n                            return $\"({sqlField} NOT IN ({joined}))\";\n                        }\n                        else\n                        {\n                            throw new RQLException(\"Invalid RightValueType for tkOut\");\n                        }\n                    }\n                default:\n                    throw new RQLException($\"Unsupported filter token: {filter.Token}\");\n            }\n        }\n\n        \n        private string RQLLimitToSQL(TRQLLimit limit)\n        {\n            if (limit.Start == 0)\n            {\n                return $\" /*limit*/ LIMIT {limit.Count}\";\n            }\n            else\n            {\n                return $\" /*limit*/ LIMIT {limit.Count} OFFSET {limit.Start}\";\n            }\n        }\n\n        \n        private string RQLLogicOperatorToSQL(TRQLLogicOperator logicOp)\n        {\n            string joinOp = logicOp.Token == TokenType.tkAnd ? \" and \" :\n                            logicOp.Token == TokenType.tkOr ? \" or \" :\n                            throw new RQLException(\"Invalid token in RQLLogicOperator\");\n\n            bool first = true;\n            string sql = \"\";\n            foreach (TRQLCustom token in logicOp.FilterAST)\n            {\n                if (!first)\n                {\n                    sql += joinOp;\n                }\n                first = false;\n                sql += RQLCustom2SQL(token);\n            }\n            return \"(\" + sql + \")\";\n        }\n\n        \n        private string RQLSortToSQL(TRQLSort sort)\n        {\n            string sql = \" /*sort*/ ORDER BY\";\n            for (int i = 0; i < sort.Fields.Count; i++)\n            {\n                if (i > 0)\n                {\n                    sql += \",\";\n                }\n                string field = GetDatabaseFieldName(sort.Fields[i], true);\n                string sqlField = GetFieldNameForSQL(field);\n                sql += \" \" + sqlField;\n                sql += sort.Signs[i] == \"+\" ? \" ASC\" : \" DESC\";\n            }\n            return sql;\n        }\n\n        \n        private string RQLWhereToSQL(TRQLWhere where)\n        {\n            return \" WHERE \";\n        }\n\n        \n        protected override string RQLCustom2SQL(TRQLCustom rqlCustom)\n        {\n            if (rqlCustom is TRQLFilter filter)\n            {\n                return RQLFilterToSQL(filter);\n            }\n            else if (rqlCustom is TRQLLogicOperator logicOp)\n            {\n                return RQLLogicOperatorToSQL(logicOp);\n            }\n            else if (rqlCustom is TRQLSort sort)\n            {\n                return RQLSortToSQL(sort);\n            }\n            else if (rqlCustom is TRQLLimit limit)\n            {\n                return RQLLimitToSQL(limit);\n            }\n            else if (rqlCustom is TRQLWhere where)\n            {\n                return RQLWhereToSQL(where);\n            }\n            else\n            {\n                throw new RQLException($\"Unknown token in compiler: {rqlCustom.GetType().Name}\");\n            }\n        }\n    }\n\n    \n    public static class RQLPostgreSQLCompilerRegistration\n    {\n        static RQLPostgreSQLCompilerRegistration()\n        {\n            \n            RQLCompilerRegistry.Instance.RegisterCompiler(\"postgresql\", typeof(RQLPostgreSQLCompiler));\n        }\n\n        \n        public static void Unregister()\n        {\n            RQLCompilerRegistry.Instance.UnRegisterCompiler(\"postgresql\");\n        }\n    }\n}"}
{"input": "unit StorageU;\n\ninterface\n\nconst\n  TITLES: array [1 .. 4] of string = ('IBM', 'AAPL', 'GOOG', 'MSFT');\n\nfunction GetNextDataToSend(const LastID: Integer;\n  out CurrentEventID: Integer): string;\n\nimplementation\n\nuses\n  System.JSON;\n\nfunction GetNextDataToSend(const LastID: Integer;\n  out CurrentEventID: Integer): string;\nvar\n  lIndex: Integer;\n  lJOBJ: TJSONObject;\nbegin\n  // You can get the \"next\" event reading the LastID or, as in this case,\n  // just send another event\n\n  lIndex := LastID;\n  while lIndex = LastID do\n  begin\n    lIndex := Random(Length(Titles)) + 1;\n  end;\n\n  lJOBJ := TJSONObject.Create;\n  try\n    lJOBJ.AddPair('stock', TITLES[lIndex]);\n    lJOBJ.AddPair('value', TJSONNumber.Create((500 + Random(200)) +\n      (Random(50) / 100)));\n    Result := lJOBJ.ToJSON;\n    CurrentEventID := LastID + 1;\n  finally\n    lJOBJ.Free;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace YourNamespace\n{\n    public static class Storage\n    {\n        private static readonly string[] Titles = { \"IBM\", \"AAPL\", \"GOOG\", \"MSFT\" };\n        private static readonly Random RandomInstance = new Random();\n\n        public static string GetNextDataToSend(int lastID, out int currentEventID)\n        {\n            int index = lastID;\n            while (index == lastID)\n            {\n                index = RandomInstance.Next(1, Titles.Length + 1);\n            }\n            double value = (500 + RandomInstance.Next(0, 200)) + (RandomInstance.Next(0, 50) / 100.0);\n            var jsonData = new Dictionary<string, object>\n            {\n                { \"stock\", Titles[index - 1] },\n                { \"value\", value }\n            };\n            currentEventID = lastID + 1;\n            return JsonSerializer.Serialize(jsonData);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n// \n// THIS FILE IS GENERATED BY \"inv generate-nullables\" DO NOT CHANGE MANUALLY!\n// \n// ***************************************************************************\n//\n// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nunit MVCFramework.Nullables;\n\ninterface\n\nuses\n  System.SysUtils, System.Classes, System.TypInfo, System.RTTI;\n\ntype\n  EMVCNullable = class(Exception)\n\n  end;\n\n//**************************\n// ** NullableString\n//**************************\n\n  NullableString = record\n  private\n    fValue: String;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: String;\n    procedure SetValue(const Value: String);\n    class operator Implicit(const Value: String): NullableString;\n    class operator Implicit(const Value: NullableString): String;\n    class operator Implicit(const Value: Pointer): NullableString;\t\n\t  class operator Equal(LeftValue: NullableString; RightValue: NullableString) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableString contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableString contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: String;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: String): String;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableString): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: String): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: String read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableCurrency\n//**************************\n\n  NullableCurrency = record\n  private\n    fValue: Currency;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Currency;\n    procedure SetValue(const Value: Currency);\n    class operator Implicit(const Value: Currency): NullableCurrency;\n    class operator Implicit(const Value: NullableCurrency): Currency;\n    class operator Implicit(const Value: Pointer): NullableCurrency;\t\n\t  class operator Equal(LeftValue: NullableCurrency; RightValue: NullableCurrency) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableCurrency contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableCurrency contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Currency;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Currency): Currency;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableCurrency): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Currency): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Currency read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableBoolean\n//**************************\n\n  NullableBoolean = record\n  private\n    fValue: Boolean;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Boolean;\n    procedure SetValue(const Value: Boolean);\n    class operator Implicit(const Value: Boolean): NullableBoolean;\n    class operator Implicit(const Value: NullableBoolean): Boolean;\n    class operator Implicit(const Value: Pointer): NullableBoolean;\t\n\t  class operator Equal(LeftValue: NullableBoolean; RightValue: NullableBoolean) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableBoolean contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableBoolean contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Boolean;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Boolean): Boolean;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableBoolean): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Boolean): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Boolean read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTDate\n//**************************\n\n  NullableTDate = record\n  private\n    fValue: TDate;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TDate;\n    procedure SetValue(const Value: TDate);\n    class operator Implicit(const Value: TDate): NullableTDate;\n    class operator Implicit(const Value: NullableTDate): TDate;\n    class operator Implicit(const Value: Pointer): NullableTDate;\t\n\t  class operator Equal(LeftValue: NullableTDate; RightValue: NullableTDate) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTDate contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTDate contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TDate;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TDate): TDate;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTDate): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TDate): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TDate read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTTime\n//**************************\n\n  NullableTTime = record\n  private\n    fValue: TTime;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TTime;\n    procedure SetValue(const Value: TTime);\n    class operator Implicit(const Value: TTime): NullableTTime;\n    class operator Implicit(const Value: NullableTTime): TTime;\n    class operator Implicit(const Value: Pointer): NullableTTime;\t\n\t  class operator Equal(LeftValue: NullableTTime; RightValue: NullableTTime) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTTime contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTTime contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TTime;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TTime): TTime;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTTime): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TTime): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TTime read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTDateTime\n//**************************\n\n  NullableTDateTime = record\n  private\n    fValue: TDateTime;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TDateTime;\n    procedure SetValue(const Value: TDateTime);\n    class operator Implicit(const Value: TDateTime): NullableTDateTime;\n    class operator Implicit(const Value: NullableTDateTime): TDateTime;\n    class operator Implicit(const Value: Pointer): NullableTDateTime;\t\n\t  class operator Equal(LeftValue: NullableTDateTime; RightValue: NullableTDateTime) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTDateTime contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTDateTime contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TDateTime;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TDateTime): TDateTime;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTDateTime): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TDateTime): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TDateTime read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableSingle\n//**************************\n\n  NullableSingle = record\n  private\n    fValue: Single;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Single;\n    procedure SetValue(const Value: Single);\n    class operator Implicit(const Value: Single): NullableSingle;\n    class operator Implicit(const Value: NullableSingle): Single;\n    class operator Implicit(const Value: Pointer): NullableSingle;\t\n\t  class operator Equal(LeftValue: NullableSingle; RightValue: NullableSingle) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableSingle contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableSingle contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Single;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Single): Single;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableSingle): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Single): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Single read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableDouble\n//**************************\n\n  NullableDouble = record\n  private\n    fValue: Double;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Double;\n    procedure SetValue(const Value: Double);\n    class operator Implicit(const Value: Double): NullableDouble;\n    class operator Implicit(const Value: NullableDouble): Double;\n    class operator Implicit(const Value: Pointer): NullableDouble;\t\n\t  class operator Equal(LeftValue: NullableDouble; RightValue: NullableDouble) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableDouble contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableDouble contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Double;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Double): Double;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableDouble): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Double): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Double read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableExtended\n//**************************\n\n  NullableExtended = record\n  private\n    fValue: Extended;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Extended;\n    procedure SetValue(const Value: Extended);\n    class operator Implicit(const Value: Extended): NullableExtended;\n    class operator Implicit(const Value: NullableExtended): Extended;\n    class operator Implicit(const Value: Pointer): NullableExtended;\t\n\t  class operator Equal(LeftValue: NullableExtended; RightValue: NullableExtended) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableExtended contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableExtended contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Extended;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Extended): Extended;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableExtended): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Extended): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Extended read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableInt16\n//**************************\n\n  NullableInt16 = record\n  private\n    fValue: Int16;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Int16;\n    procedure SetValue(const Value: Int16);\n    class operator Implicit(const Value: Int16): NullableInt16;\n    class operator Implicit(const Value: NullableInt16): Int16;\n    class operator Implicit(const Value: Pointer): NullableInt16;\t\n\t  class operator Equal(LeftValue: NullableInt16; RightValue: NullableInt16) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableInt16 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableInt16 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Int16;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Int16): Int16;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableInt16): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Int16): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Int16 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableUInt16\n//**************************\n\n  NullableUInt16 = record\n  private\n    fValue: UInt16;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: UInt16;\n    procedure SetValue(const Value: UInt16);\n    class operator Implicit(const Value: UInt16): NullableUInt16;\n    cla", "output": "using System;\nusing System.Globalization;\n\nnamespace MVCFramework.Nullables\n{\n    \n    public class EMVCNullable : Exception\n    {\n        public EMVCNullable(string message) : base(message) { }\n    }\n\n    \n    public struct NullableString\n    {\n        private string _value;\n        private bool _hasValue;\n\n        \n        public bool HasValue => _hasValue;\n\n        \n        public bool IsNull => !_hasValue;\n\n        \n        public string Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableString value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        \n        public void Clear() => SetNull();\n\n        \n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n\n        \n        public string ValueOrDefault() => HasValue ? _value : default;\n\n        \n        public string ValueOrElse(string elseValue) => HasValue ? _value : elseValue;\n\n        \n        public bool TryHasValue(out string value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n\n        public override bool Equals(object obj) =>\n            obj is NullableString other && Equals(other);\n\n        public bool Equals(NullableString other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableString(string value) =>\n            new NullableString { _value = value, _hasValue = true };\n\n        public static implicit operator string(NullableString ns) => ns.Value;\n\n        public static bool operator ==(NullableString left, NullableString right) =>\n            left.Equals(right);\n\n        public static bool operator !=(NullableString left, NullableString right) =>\n            !left.Equals(right);\n\n        public override string ToString() => HasValue ? _value : \"\";\n    }\n\n    \n    public struct NullableCurrency\n    {\n        private decimal _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public decimal Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableCurrency value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public decimal ValueOrDefault() => HasValue ? _value : default;\n        public decimal ValueOrElse(decimal elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out decimal value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableCurrency other && Equals(other);\n        public bool Equals(NullableCurrency other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableCurrency(decimal value) =>\n            new NullableCurrency { _value = value, _hasValue = true };\n        public static implicit operator decimal(NullableCurrency nc) => nc.Value;\n\n        public static bool operator ==(NullableCurrency left, NullableCurrency right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableCurrency left, NullableCurrency right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableBoolean\n    {\n        private bool _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public bool Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableBoolean value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public bool ValueOrDefault() => HasValue ? _value : default;\n        public bool ValueOrElse(bool elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out bool value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableBoolean other && Equals(other);\n        public bool Equals(NullableBoolean other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableBoolean(bool value) =>\n            new NullableBoolean { _value = value, _hasValue = true };\n        public static implicit operator bool(NullableBoolean nb) => nb.Value;\n\n        public static bool operator ==(NullableBoolean left, NullableBoolean right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableBoolean left, NullableBoolean right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDate\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        \n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDate value is null\");\n                return _value.Date;\n            }\n            set\n            {\n                _value = value.Date;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value.Date : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value.Date : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value.Date;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDate other && Equals(other);\n        public bool Equals(NullableTDate other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Date.Equals(other._value.Date));\n        public override int GetHashCode() => HasValue ? _value.Date.GetHashCode() : 0;\n\n        public static implicit operator NullableTDate(DateTime value) =>\n            new NullableTDate { _value = value.Date, _hasValue = true };\n        public static implicit operator DateTime(NullableTDate ntd) => ntd.Value;\n\n        public static bool operator ==(NullableTDate left, NullableTDate right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDate left, NullableTDate right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTTime\n    {\n        private TimeSpan _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public TimeSpan Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public TimeSpan ValueOrDefault() => HasValue ? _value : default;\n        public TimeSpan ValueOrElse(TimeSpan elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out TimeSpan value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTTime other && Equals(other);\n        public bool Equals(NullableTTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTTime(TimeSpan value) =>\n            new NullableTTime { _value = value, _hasValue = true };\n        public static implicit operator TimeSpan(NullableTTime ntt) => ntt.Value;\n\n        public static bool operator ==(NullableTTime left, NullableTTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTTime left, NullableTTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDateTime\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDateTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDateTime other && Equals(other);\n        public bool Equals(NullableTDateTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTDateTime(DateTime value) =>\n            new NullableTDateTime { _value = value, _hasValue = true };\n        public static implicit operator DateTime(NullableTDateTime ntdt) => ntdt.Value;\n\n        public static bool operator ==(NullableTDateTime left, NullableTDateTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDateTime left, NullableTDateTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableSingle\n    {\n        private float _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public float Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableSingle value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public float ValueOrDefault() => HasValue ? _value : default;\n        public float ValueOrElse(float elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out float value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableSingle other && Equals(other);\n        public bool Equals(NullableSingle other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-6);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableSingle(float value) =>\n            new NullableSingle { _value = value, _hasValue = true };\n        public static implicit operator float(NullableSingle ns) => ns.Value;\n\n        public static bool operator ==(NullableSingle left, NullableSingle right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableSingle left, NullableSingle right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableDouble\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableDouble value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableDouble other && Equals(other);\n        public bool Equals(NullableDouble other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableDouble(double value) =>\n            new NullableDouble { _value = value, _hasValue = true };\n        public static implicit operator double(NullableDouble nd) => nd.Value;\n\n        public static bool operator ==(NullableDouble left, NullableDouble right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableDouble left, NullableDouble right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableExtended\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableExtended value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableExtended other && Equals(other);\n        public bool Equals(NullableExtended other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableExtended(double value) =>\n            new NullableExtended { _value = value, _hasValue = true };\n        public static implicit operator double(NullableExtended ne) => ne.Value;\n\n        public static bool operator ==(NullableExtended left, NullableExtended right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableExtended left, NullableExtended right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt16\n    {\n        private short _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public short Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public short ValueOrDefault() => HasValue ? _value : default;\n        public short ValueOrElse(short elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out short value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt16 other && Equals(other);\n        public bool Equals(NullableInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt16(short value) =>\n            new NullableInt16 { _value = value, _hasValue = true };\n        public static implicit operator short(NullableInt16 ni16) => ni16.Value;\n\n        public static bool operator ==(NullableInt16 left, NullableInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt16 left, NullableInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt16\n    {\n        private ushort _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ushort Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ushort ValueOrDefault() => HasValue ? _value : default;\n        public ushort ValueOrElse(ushort elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ushort value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt16 other && Equals(other);\n        public bool Equals(NullableUInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt16(ushort value) =>\n            new NullableUInt16 { _value = value, _hasValue = true };\n        public static implicit operator ushort(NullableUInt16 nu16) => nu16.Value;\n\n        public static bool operator ==(NullableUInt16 left, NullableUInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt16 left, NullableUInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt32\n    {\n        private int _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public int Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public int ValueOrDefault() => HasValue ? _value : default;\n        public int ValueOrElse(int elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out int value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt32 other && Equals(other);\n        public bool Equals(NullableInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt32(int value) =>\n            new NullableInt32 { _value = value, _hasValue = true };\n        public static implicit operator int(NullableInt32 ni32) => ni32.Value;\n\n        public static bool operator ==(NullableInt32 left, NullableInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt32 left, NullableInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt32\n    {\n        private uint _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public uint Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public uint ValueOrDefault() => HasValue ? _value : default;\n        public uint ValueOrElse(uint elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out uint value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt32 other && Equals(other);\n        public bool Equals(NullableUInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt32(uint value) =>\n            new NullableUInt32 { _value = value, _hasValue = true };\n        public static implicit operator uint(NullableUInt32 nu32) => nu32.Value;\n\n        public static bool operator ==(NullableUInt32 left, NullableUInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt32 left, NullableUInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt64\n    {\n        private long _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public long Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public long ValueOrDefault() => HasValue ? _value : default;\n        public long ValueOrElse(long elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out long value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt64 other && Equals(other);\n        public bool Equals(NullableInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt64(long value) =>\n            new NullableInt64 { _value = value, _hasValue = true };\n        public static implicit operator long(NullableInt64 ni64) => ni64.Value;\n\n        public static bool operator ==(NullableInt64 left, NullableInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt64 left, NullableInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt64\n    {\n        private ulong _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ulong Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ulong ValueOrDefault() => HasValue ? _value : default;\n        public ulong ValueOrElse(ulong elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ulong value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt64 other && Equals(other);\n        public bool Equals(NullableUInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt64(ulong value) =>\n            new NullableUInt64 { _value = value, _hasValue = true };\n        public static implicit operator ulong(NullableUInt64 nu64) => nu64.Value;\n\n        public static bool operator ==(NullableUInt64 left, NullableUInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt64 left, NullableUInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTGUID\n    {\n        private Guid _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public Guid Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTGUID value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public Guid ValueOrDefault() => HasValue ? _value : default;\n        public Guid ValueOrElse(Guid elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out Guid value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTGUID other && Equals(other);\n        public bool Equals(NullableTGUID other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTGUID(Guid value) =>\n            new NullableTGUID { _value = value, _hasValue = true };\n        public static implicit operator Guid(NullableTGUID ntguid) => ntguid.Value;\n\n        public static bool operator ==(NullableTGUID left, NullableTGUID right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTGUID left, NullableTGUID right) =>\n            !left.Equals(right);\n    }\n\n    \n    public enum NullableType\n    {\n        InvalidNullableType,\n        NullableString,\n        NullableCurrency,\n        NullableBoolean,\n        NullableTDate,\n        NullableTTime,\n        NullableTDateTime,\n        NullableSingle,\n        NullableDouble,\n        NullableExtended,\n        NullableInt16,\n        NullableUInt16,\n        NullableInt32,\n        NullableUInt32,\n        NullableInt64,\n        NullableUInt64,\n        NullableTGUID\n    }\n\n    \n    public static class NullableHelper\n    {\n        public static NullableType GetNullableType(Type type)\n        {\n            if (type == typeof(NullableString)) return NullableType.NullableString;\n            if (type == typeof(NullableCurrency)) return NullableType.NullableCurrency;\n            if (type == typeof(NullableBoolean)) return NullableType.NullableBoolean;\n            if (type == typeof(NullableTDate)) return NullableType.NullableTDate;\n            if (type == typeof(NullableTTime)) return NullableType.NullableTTime;\n            if (type == typeof(NullableTDateTime)) return NullableType.NullableTDateTime;\n            if (type == typeof(NullableSingle)) return NullableType.NullableSingle;\n            if (type == typeof(NullableDouble)) return NullableType.NullableDouble;\n            if (type == typeof(NullableExtended)) return NullableType.NullableExtended;\n            if (type == typeof(NullableInt16)) return NullableType.NullableInt16;\n            if (type == typeof(NullableUInt16)) return NullableType.NullableUInt16;\n            if (type == typeof(NullableInt32)) return NullableType.NullableInt32;\n            if (type == typeof(NullableUInt32)) return NullableType.NullableUInt32;\n            if (type == typeof(NullableInt64)) return NullableType.NullableInt64;\n            if (type == typeof(NullableUInt64)) return NullableType.NullableUInt64;\n            if (type == typeof(NullableTGUID)) return NullableType.NullableTGUID;\n            return NullableType.InvalidNullableType;\n        }\n    }\n}"}
{"input": "unit RESTServicesU;\n\ninterface\n\nuses\n  Generics.Collections, WinesBO, MVCFramework.RESTAdapter,\n  MVCFramework.Serializer.Commons, MVCFramework.Commons;\n\ntype\n\n  IWineResource = interface(IInvokable)\n    ['{068C51B2-F413-48ED-97CE-463234DB3E41}']\n\n    [RESTResource(HttpGet, '/api/wines')]\n    [MVCListOf(TWine)]\n    [Mapping(TWines)]\n    procedure GetWineList(AAsynchReq: IAsynchRequest);\n\n    [RESTResource(httpPOST, '/api/wines')]\n    procedure SaveWine([Body] AWine: TWine; AAsynchReq: IAsynchRequest);\n\n    [RESTResource(httpPUT, '/api/wines/{id}')]\n    procedure UpdateWineById([Param('id')] AID: integer; [Body] AWine: TWine;\n      AAsynchReq: IAsynchRequest);\n\n  end;\n\nimplementation\n\nend.", "output": "using System.Collections.Generic;\nusing WinesBO;\nusing MVCFramework.RESTAdapter;\nusing MVCFramework.Serializer.Commons;\nusing MVCFramework.Commons;\n\nnamespace RESTServicesU\n{\n    [RESTResource(HttpMethod.Get, \"/api/wines\")]\n    [MVCListOf(typeof(TWine))]\n    [Mapping(typeof(TWines))]\n    public interface IWineResource : IInvokable\n    {\n        void GetWineList(IAsynchRequest asynchReq);\n\n        [RESTResource(HttpMethod.Post, \"/api/wines\")]\n        void SaveWine([Body] TWine aWine, IAsynchRequest asynchReq);\n\n        [RESTResource(HttpMethod.Put, \"/api/wines/{id}\")]\n        void UpdateWineById([Param(\"id\")] int aId, [Body] TWine aWine, IAsynchRequest asynchReq);\n    }\n}"}
{"input": "unit MainWebModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Logger,\n  MVCFramework.DotEnv\n  ;\n\ntype\n  Twm = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n\n  private\n    MVCEngine: TMVCEngine;\n  end;\n\nvar\n  WebModuleClass: TComponentClass = Twm;\n\nimplementation\n\nuses\n  WineCellarAppControllerU,\n  MVCFramework.Middleware.StaticFiles,\n  MVCFramework.Middleware.CORS,\n  System.IOUtils;\n\n{$R *.dfm}\n\nprocedure Twm.WebModuleCreate(Sender: TObject);\nbegin\n  MVCEngine := TMVCEngine.Create(self,\n    procedure(Conf: TMVCConfig)\n    begin\n//      Conf.Value[tmvcconfigkey.PathPrefix] := '/dmvc';\n    end);\n  MVCEngine.AddController(TWineCellarApp);\n  MVCEngine.AddMiddleware(TMVCCORSMiddleware.Create);\n  if not IsLibrary then\n  begin\n    MVCEngine.AddMiddleware(TMVCStaticFilesMiddleware.Create('/app', { StaticFilesPath }\n      TPath.Combine(AppPath, '..\\..\\www'), { DocumentRoot }\n      'index.html' { IndexDocument - Before it was named fallbackresource }\n      ));\n  end;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.FileProviders;\nusing Microsoft.Extensions.Hosting;\nusing System.IO;\n\nnamespace WineCellarApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n\n            builder.Services.AddControllers();\n\n            builder.Services.AddCors(options =>\n            {\n                options.AddPolicy(\"CorsPolicy\", policyBuilder =>\n                {\n                    policyBuilder\n                      .AllowAnyOrigin()\n                      .AllowAnyHeader()\n                      .AllowAnyMethod();\n                });\n            });\n\n            var app = builder.Build();\n\n            app.UseCors(\"CorsPolicy\");\n\n            \n            var currentDir = Directory.GetCurrentDirectory();\n            var wwwPath = Path.Combine(currentDir, \"..\", \"..\", \"www\");\n            if (Directory.Exists(wwwPath))\n            {\n                app.UseStaticFiles(new StaticFileOptions\n                {\n                    RequestPath = \"/app\",\n                    FileProvider = new PhysicalFileProvider(Path.GetFullPath(wwwPath)),\n                    \n                });\n            }\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"Wine Cellar API is up!\");\n\n            System.Console.WriteLine(\"Server is running on: \" + string.Join(\", \", app.Urls));\n\n            app.Run();\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Some code in this file is from Thijs van Dien (https://stackoverflow.com/users/1163893/thijs-van-dien)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Crypt.Utils;\n\ninterface\n\nuses\n  System.SysUtils, System.Math, IdHMAC, IdHMACSHA1, IdGlobal;\n\ntype\n  TIdHMACClass = class of TIdHMAC;\nfunction PBKDF2(const Password: TBytes; const Salt: TBytes; const IterationsCount: Integer;\n  const KeyLengthInBytes: Integer; PRFC: TIdHMACClass = nil): TBytes;\nfunction BytesToHexString(const _B: TIdBytes): string; overload;\nfunction BytesToHexString(const _B: TBytes): string; overload;\nprocedure MVCCryptInit;\n\nimplementation\n\nuses\n  IdSSLOpenSSL, MVCFramework.Commons;\n\n{\n  PBKDF2 algorithm implementation from\n  https://stackoverflow.com/a/20134669/6825479\n  and then slighly modified. Copyright, if any, is from the original owner.\n}\n// Modeled after http://www.di-mgt.com.au/cryptoKDFs.html#PKCS5\nfunction PBKDF2(const Password: TBytes; const Salt: TBytes; const IterationsCount: Integer;\n  const KeyLengthInBytes: Integer; PRFC: TIdHMACClass = nil): TBytes;\nvar\n  PRF: TIdHMAC;\n  D: Integer;\n  I: Int32;\n  F: TIdBytes;\n  U: TIdBytes;\n  J: Integer;\n  T: TIdBytes;\n  lPassword, lSalt: TIdBytes;\n\n  function _ConcatenateBytes(const _B1: TIdBytes; const _B2: TIdBytes): TIdBytes; inline;\n  begin\n    SetLength(Result, Length(_B1) + Length(_B2));\n    if Length(_B1) > 0 then\n      Move(_B1[low(_B1)], Result[low(Result)], Length(_B1));\n    if Length(_B2) > 0 then\n      Move(_B2[low(_B2)], Result[low(Result) + Length(_B1)], Length(_B2));\n  end;\n\n  function _INT_32_BE(const _I: Int32): TIdBytes; inline;\n  begin\n    Result := TIdBytes.Create(_I shr 24, _I shr 16, _I shr 8, _I);\n  end;\n\n  procedure _XorBytes(var _B1: TIdBytes; const _B2: TIdBytes); inline;\n  var\n    _I: Integer;\n  begin\n    for _I := low(_B1) to high(_B1) do\n      _B1[_I] := _B1[_I] xor _B2[_I];\n  end;\n\nbegin\n  if not Assigned(PRFC) then\n    PRFC := TIdHMACSHA1;\n\n  try\n    PRF := PRFC.Create;\n  except\n    on E: Exception do\n    begin\n      if E.Message.Contains('is not available') then\n        raise EMVCException.Create(HTTP_STATUS.InternalServerError,\n          E.Message +\n          ' [HINT: May be OpenSSL is not been loaded yet. Did you invoked MVCCryptInit?]');\n      raise EMVCException.Create(HTTP_STATUS.InternalServerError, E.Message);\n    end;\n  end;\n  try\n    {\n      Conversion TBytes -> TidBytes as Remy Lebeau says\n      https://stackoverflow.com/a/18854367/6825479\n    }\n    lPassword := TIdBytes(Password);\n    lSalt := TIdBytes(Salt);\n\n    D := Ceil(KeyLengthInBytes / PRF.HashSize);\n    PRF.Key := lPassword;\n    for I := 1 to D do\n    begin\n      F := PRF.HashValue(_ConcatenateBytes(lSalt, _INT_32_BE(I)));\n      U := Copy(F);\n      for J := 2 to IterationsCount do\n      begin\n        U := PRF.HashValue(U);\n        _XorBytes(F, U);\n      end;\n      T := _ConcatenateBytes(T, F);\n    end;\n    Result := TBytes(Copy(T, low(T), KeyLengthInBytes));\n  finally\n    PRF.Free;\n  end;\nend;\n\nfunction BytesToHexString(const _B: TIdBytes): string; overload;\nvar\n  _I: Integer;\nbegin\n  for _I := low(_B) to high(_B) do\n    Result := Result + IntToHex(_B[_I], 2);\nend;\n\nfunction BytesToHexString(const _B: TBytes): string; overload;\nbegin\n  Result := BytesToHexString(TIdBytes(_B));\nend;\n\nprocedure MVCCryptInit;\nbegin\n  if not LoadOpenSSLLibrary then\n  begin\n    raise EMVCException.Create('Cannot load OpenSSL');\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace MVCFramework.Crypt.Utils\n{\n    public static class CryptUtils\n    {\n        \n        public static byte[] PBKDF2(byte[] password, byte[] salt, int iterationsCount, int keyLengthInBytes, HashAlgorithmName? prfc = null)\n        {\n            var algorithm = prfc ?? HashAlgorithmName.SHA1;\n            using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, iterationsCount, algorithm))\n            {\n                return deriveBytes.GetBytes(keyLengthInBytes);\n            }\n        }\n\n        public static string BytesToHexString(byte[] bytes)\n        {\n            if (bytes == null)\n                throw new ArgumentNullException(nameof(bytes));\n\n            var sb = new StringBuilder(bytes.Length * 2);\n            foreach (var b in bytes)\n            {\n                sb.AppendFormat(\"{0:x2}\", b);\n            }\n            return sb.ToString();\n        }\n\n        public static void MVCCryptInit()\n        {\n            \n            // If you need to enforce any checks (such as FIPS compliance), you could do so here.\n        }\n    }\n}"}
{"input": "{ Invokable interface ISOAPCustomer }\n\nunit SOAPCustomerIntfU;\n\ninterface\n\nuses Soap.InvokeRegistry, System.Types, Soap.XSBuiltIns;\n\ntype\n\n  { Invokable interfaces must derive from IInvokable }\n  ISOAPCustomer = interface(IInvokable)\n    ['{9D4C2E66-F0AB-470E-9A48-2084DAD75FD3}']\n    function GetCustomers: string; stdcall;\n    { Methods of Invokable interface must not use the default }\n    { calling convention; stdcall is recommended }\n  end;\n\nimplementation\n\ninitialization\n\n{ Invokable interfaces must be registered }\nInvRegistry.RegisterInterface(TypeInfo(ISOAPCustomer));\n\nend.", "output": "using System;\nusing System.Runtime.InteropServices;\nusing System.Web.Services;\nusing System.Web.Services.Protocols;\n\n[Guid(\"9D4C2E66-F0AB-470E-9A48-2084DAD75FD3\")]\n[WebServiceBinding(Name = \"ISOAPCustomerSoap\", Namespace = \"http://tempuri.org/\")]\npublic interface ISOAPCustomer\n{\n    [SoapDocumentMethod]\n    string GetCustomers();\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\n\nunit MVCFramework.Tests.AppController;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Generics.Collections,\n  System.Classes,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Server,\n  MVCFramework.Serializer.Commons;\n\ntype\n  [MVCNameCase(ncAsIs)]\n  TAppUser = class\n  strict private\n    FCod: Integer;\n    FName: string;\n    FPass: string;\n  public\n    property Cod: Integer read FCod write FCod;\n    property Name: string read FName write FName;\n    property Pass: string read FPass write FPass;\n  end;\n\n  [MVCPath('/')]\n  TAppController = class(TMVCController)\n  public\n    [MVCPath('/hello')]\n    [MVCHTTPMethod([httpGET])]\n    procedure HelloWorld(ctx: TWebContext);\n\n    [MVCPath('/user')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetUser(ctx: TWebContext);\n\n    [MVCPath('/user/save')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure PostUser(ctx: TWebContext);\n\n    [MVCPath('/users')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetUsers(ctx: TWebContext);\n\n    [MVCPath('/users/save')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure PostUsers(ctx: TWebContext);\n\n    [MVCPath('/file/upload')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCConsumes(TMVCMediaType.MULTIPART_FORM_DATA)]\n    procedure ReceiveFile;\n\n    [MVCPath('/body-url-encoded')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCConsumes(TMVCMediaType.APPLICATION_FORM_URLENCODED)]\n    procedure PostBodyURLEncoded;\n  end;\n\nimplementation\n\nuses\n  System.Hash, JsonDataObjects;\n\n{ TAppController }\n\nprocedure TAppController.GetUser(ctx: TWebContext);\nvar\n  LUser: TAppUser;\nbegin\n  LUser := TAppUser.Create;\n  try\n    LUser.Cod := 1;\n    LUser.Name := 'Ezequiel';\n    LUser.Pass := '123';\n  finally\n    Render(LUser, True);\n  end;\nend;\n\nprocedure TAppController.GetUsers(ctx: TWebContext);\nvar\n  LUsers: TObjectList<TAppUser>;\n  LUser: TAppUser;\n  I: Integer;\nbegin\n  LUsers := TObjectList<TAppUser>.Create(True);\n\n  for I := 0 to 10 do\n  begin\n    LUser := TAppUser.Create;\n    LUser.Cod := I;\n    LUser.Name := 'Ezequiel ' + IntToStr(I);\n    LUser.Pass := IntToStr(I);\n\n    LUsers.Add(LUser);\n  end;\n\n  Self.Render<TAppUser>(LUsers, True);\nend;\n\nprocedure TAppController.HelloWorld(ctx: TWebContext);\nbegin\n  Render('Hello World called with GET');\nend;\n\nprocedure TAppController.PostBodyURLEncoded;\nvar\n  lResponse: TJDOJsonObject;\n  lParamValue: string;\nbegin\n  lResponse := TJDOJsonObject.Create;\n\n  if Context.Request.ContentFields.TryGetValue('field1', lParamValue) then\n    lResponse.S['field1'] := lParamValue\n  else\n    lResponse.S['field1'] := '';\n\n  if Context.Request.ContentFields.TryGetValue('field2', lParamValue) then\n    lResponse.S['field2'] := lParamValue\n  else\n    lResponse.S['field2'] := '';\n\n  if Context.Request.ContentFields.TryGetValue('field3', lParamValue) then\n    lResponse.S['field3'] := lParamValue\n  else\n    lResponse.S['field3'] := '';\n\n  Render(lResponse);\nend;\n\nprocedure TAppController.PostUser(ctx: TWebContext);\nvar\n  LUser: TAppUser;\nbegin\n  LUser := ctx.Request.BodyAs<TAppUser>();\n  try\n    if (LUser.Cod > 0) then\n      Render('Success!')\n    else\n      Render('Error!');\n  finally\n    LUser.Free;\n  end;\nend;\n\nprocedure TAppController.PostUsers(ctx: TWebContext);\nvar\n  LUsers: TObjectList<TAppUser>;\nbegin\n  LUsers := ctx.Request.BodyAsListOf<TAppUser>();\n  try\n    LUsers.OwnsObjects := True;\n\n    if (LUsers.Count > 0) then\n      Render('Success!')\n    else\n      Render('Error!');\n\n  finally\n    LUsers.Free;\n  end;\nend;\n\nprocedure TAppController.ReceiveFile;\nbegin\n  if Context.Request.Files.Count = 0 then\n  begin\n    Render(HTTP_STATUS.BadRequest, 'No file found!')\n  end\n  else\n  begin\n    Render(THashMD5.GetHashString(Context.Request.Files[0].Stream))\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Http;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.Tests\n{\n    // This model corresponds to the Delphi TAppUser\n    public class AppUser\n    {\n        public int Cod { get; set; }\n        public string Name { get; set; }\n        public string Pass { get; set; }\n    }\n\n    // The controller routes are defined using attributes.\n    // In Delphi they were defined with [MVCPath] and [MVCHTTPMethod]\n    [ApiController]\n    [Route(\"/\")]\n    public class AppController : ControllerBase\n    {\n        // GET /hello\n        [HttpGet(\"hello\")]\n        public IActionResult HelloWorld()\n        {\n            return Ok(\"Hello World called with GET\");\n        }\n\n        // GET /user\n        [HttpGet(\"user\")]\n        public IActionResult GetUser()\n        {\n            var user = new AppUser\n            {\n                Cod = 1,\n                Name = \"Ezequiel\",\n                Pass = \"123\"\n            };\n\n            // Render returns the user as JSON (automatically by ASP.NET Core)\n            return Ok(user);\n        }\n\n        // POST /user/save\n        [HttpPost(\"user/save\")]\n        public async Task<IActionResult> PostUser()\n        {\n            // The framework will bind the JSON body to an AppUser object.\n            // Using System.Text.Json (or you may use Newtonsoft.Json if preferred)\n            var user = await System.Text.Json.JsonSerializer.DeserializeAsync<AppUser>(Request.Body);\n            if (user != null && user.Cod > 0)\n            {\n                return Ok(\"Success!\");\n            }\n            else\n            {\n                return BadRequest(\"Error!\");\n            }\n        }\n\n        // GET /users\n        [HttpGet(\"users\")]\n        public IActionResult GetUsers()\n        {\n            var users = new List<AppUser>();\n            for (int i = 0; i <= 10; i++)\n            {\n                users.Add(new AppUser\n                {\n                    Cod = i,\n                    Name = $\"Ezequiel {i}\",\n                    Pass = i.ToString()\n                });\n            }\n\n            return Ok(users);\n        }\n\n        // POST /users/save\n        [HttpPost(\"users/save\")]\n        public async Task<IActionResult> PostUsers()\n        {\n            // Deserialize a JSON array of AppUser objects\n            var users = await System.Text.Json.JsonSerializer.DeserializeAsync<List<AppUser>>(Request.Body);\n            if (users != null && users.Count > 0)\n            {\n                return Ok(\"Success!\");\n            }\n            else\n            {\n                return BadRequest(\"Error!\");\n            }\n        }\n\n        // POST /file/upload\n        [HttpPost(\"file/upload\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ReceiveFile([FromForm] IFormFile file)\n        {\n            if (file == null)\n            {\n                return BadRequest(\"No file found!\");\n            }\n\n            // Compute the MD5 hash of the uploaded file stream\n            using (var md5 = MD5.Create())\n            using (var stream = file.OpenReadStream())\n            {\n                var hashBytes = await md5.ComputeHashAsync(stream);\n                // Convert hash to a hexadecimal string\n                var hashString = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLower();\n                return Ok(hashString);\n            }\n        }\n\n        // POST /body-url-encoded\n        [HttpPost(\"body-url-encoded\")]\n        [Consumes(\"application/x-www-form-urlencoded\")]\n        public IActionResult PostBodyURLEncoded([FromForm] Dictionary<string, string> formData)\n        {\n            var response = new JObject();\n            response[\"field1\"] = formData.TryGetValue(\"field1\", out var field1) ? field1 : \"\";\n            response[\"field2\"] = formData.TryGetValue(\"field2\", out var field2) ? field2 : \"\";\n            response[\"field3\"] = formData.TryGetValue(\"field3\", out var field3) ? field3 : \"\";\n            return Ok(response);\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\u00fcller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomTypesSerializersU;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Intf,\n  System.Rtti,\n  MVCFramework.Serializer.Commons;\n\ntype\n  // Custom serializer for TUserRoles type\n  TUserRolesSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    // procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n    // const AAttributes: TArray<TCustomAttribute>);\n    // procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n    // const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\n  // Custom serializer for TSysUserSerializer type\n  TSysUserSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\n\n  // Custom serializer for TNullableAliasSerializer type\n  TNullableAliasSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\nimplementation\n\nuses\n  JsonDataObjects,\n  CustomTypesU,\n  MVCFramework.Serializer.JsonDataObjects,\n  System.SysUtils;\n\n{ TUserPasswordSerializer }\n\nprocedure TUserRolesSerializer.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n  raise Exception.Create('To implement');\nend;\n\nprocedure TUserRolesSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TUserRolesSerializer.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nvar\n  lJSONArr: TJDOJsonArray;\n  lRole: string;\n  I: Integer;\nbegin\n  // I know that the selected serializer uses JsonDataObject as serialization engine.\n  // You have to check the serializer documentation to find out what are the\n  // correct objects to create here!\n\n  lJSONArr := (ASerializerObject as TJDOJsonObject).A[APropertyName];\n  { Here I want to serialize the userroles array as json array }\n  // reading from the AElementValue\n  lJSONArr.Add('--begin--'); { just to prove that the custom serialization happends }\n  for I := 0 to AElementValue.GetArrayLength - 1 do\n  begin\n    lRole := AElementValue.GetArrayElement(I).AsString;\n    lJSONArr.Add(lRole);\n  end;\n  lJSONArr.Add('--end--'); { just to prove that the custom serialization happends }\nend;\n\n{ TNullableAliasSerializer }\n\nprocedure TNullableAliasSerializer.Deserialize(const ASerializedObject: TObject;\n  var AElementValue: TValue;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.Serialize(const AElementValue: TValue;\n  var ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n  raise Exception.Create('TODO');\n  // ASerializerObject := TJsonValue.Create;\n  // TJsonValue(ASerializerObject).Value := AElementValue.AsType<TNullableRecordAlias>.Value;\nend;\n\nprocedure TNullableAliasSerializer.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.SerializeRoot(const AObject: TObject;\n  out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nbegin\n  raise EMVCSerializationException.CreateFmt('%s cannot be used as root object', [ClassName]);\nend;\n\nprocedure TUserRolesSerializer.SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction = nil);\nbegin\n  raise EMVCSerializationException.CreateFmt('%s cannot be used as root object', [ClassName]);\nend;\n\n{ TSysUserSerializer }\n\nprocedure TSysUserSerializer.DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TSysUserSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TSysUserSerializer.SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n  (ASerializerObject as TJDOJsonObject).S['prop'] := 'hello there attribute';\nend;\n\nprocedure TSysUserSerializer.SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>; const ASerializationAction: TMVCSerializationAction);\nvar\n  lJObj: TJDOJsonObject;\nbegin\n  lJObj := (ASerializerObject as TJDOJsonObject);\n  lJObj.S['username'] := TSysUser(AObject).UserName;\n  lJObj.S['roles'] := String.Join(',', TSysUser(AObject).Roles);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\n\nnamespace CustomTypesSerializersU\n{\n    public class MVCSerializationException : Exception\n    {\n        public MVCSerializationException(string message) : base(message) { }\n    }\n\n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes);\n    }\n\n    public class TUserRolesSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            JArray jArray = jObj[propertyName] as JArray;\n            if (jArray == null)\n            {\n                jArray = new JArray();\n                jObj[propertyName] = jArray;\n            }\n\n            jArray.Add(\"--begin--\");\n\n            if (elementValue is IEnumerable<string> roles)\n            {\n                foreach (var role in roles)\n                    jArray.Add(role);\n            }\n            else if (elementValue is string[] rolesArray)\n            {\n                foreach (var role in rolesArray)\n                    jArray.Add(role);\n            }\n\n            jArray.Add(\"--end--\");\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"To implement\");\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TSysUserSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            jObj[\"prop\"] = \"hello there attribute\";\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            JObject jObj = new JObject();\n            serializerObject = jObj;\n\n            if (!(obj is TSysUser user))\n                throw new Exception(\"obj is not of type TSysUser.\");\n\n            jObj[\"username\"] = user.UserName;\n            jObj[\"roles\"] = string.Join(\",\", user.Roles);\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TNullableAliasSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(object elementValue, ref object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"TODO\");\n        }\n\n        public void Deserialize(object serializedObject, ref object elementValue, Attribute[] attributes)\n        {\n            // No implementation.\n        }\n\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n    }\n\n    public class TSysUser\n    {\n        public string UserName { get; set; }\n        public List<string> Roles { get; set; }\n    }\n}"}
{"input": "unit EntitiesProcessors;\n\ninterface\n\nuses\n  MVCFramework.ActiveRecord,\n  MVCFramework,\n  MVCFramework.Serializer.Intf;\n\ntype\n  TArticleProcessor = class(TInterfacedObject, IMVCEntityProcessor)\n  public\n    procedure CreateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntities(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n  end;\n\n  TContactProcessor = class(TInterfacedObject, IMVCEntityProcessor)\n  public\n    procedure CreateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntities(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n  end;\n\nimplementation\n\n{ TArticleProcessor }\n\nuses\n  System.SysUtils,\n  Entities,\n  MVCFramework.Serializer.JsonDataObjects,\n  JsonDataObjects,\n  MVCFramework.Serializer.Commons,\n  System.Generics.Collections,\n  MVCFramework.DuckTyping, MVCFramework.Commons, System.NetEncoding;\n\nprocedure TArticleProcessor.CreateEntity(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nvar\n  lArticle: TArticle;\nbegin\n  lArticle := Context.Request.BodyAs<TArticle>;\n  try\n    lArticle.Insert;\n    Renderer.Render(lArticle, False);\n  finally\n    lArticle.Free;\n  end;\n  Handled := True;\nend;\n\nprocedure TArticleProcessor.DeleteEntity(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n  var Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\nprocedure TArticleProcessor.GetEntities(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nbegin\n  Handled := True;\n  Renderer.Render(ObjectDict().Add('data', TMVCActiveRecord.All<TArticle>,\n    procedure(const AObject: TObject; const Links: IMVCLinks)\n    begin\n      Links.AddRefLink\n        .Add(HATEOAS.HREF, 'https://www.google.com/search?q=' + TNetEncoding.URL.EncodeQuery(TArticle(AObject).Description))\n        .Add(HATEOAS._TYPE, 'text/html')\n        .Add(HATEOAS.REL, 'googlesearch');\n    end));\nend;\n\nprocedure TArticleProcessor.GetEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\nprocedure TArticleProcessor.UpdateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\n{ TPeopleProcessor }\n\nprocedure TContactProcessor.CreateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lJSON: TJsonObject;\n  lPerson: TPerson;\n  lPhones: TObjectList<TPhone>;\n  lPhone: TPhone;\n  lID: Int64;\nbegin\n  Handled := True;\n\n  // If you have an entity already defined you can use the usual BodyAs<T>, if not\n  // you have to deserialize request body manually\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lJSON := lSer.ParseObject(Context.Request.Body);\n    try\n      lPerson := TPerson.Create;\n      try\n        // deserialize person\n        lSer.JsonObjectToObject(lJSON, lPerson,\n          TMVCSerializationType.stDefault, nil);\n\n        lPhones := TObjectList<TPhone>.Create(True);\n        try\n          // deserialize phones\n          lSer.JsonArrayToList(lJSON.A['phones'], WrapAsList(lPhones), TPhone,\n            TMVCSerializationType.stDefault, nil);\n\n          // persist to database using transaction\n          TMVCActiveRecord.CurrentConnection.StartTransaction;\n          try\n            lPerson.Insert; // insert Person\n            lID := lPerson.id;\n            for lPhone in lPhones do\n            begin\n              lPhone.IDPerson := lPerson.id;\n              lPhone.Insert; // insert phone\n            end;\n            TMVCActiveRecord.CurrentConnection.Commit;\n          except\n            TMVCActiveRecord.CurrentConnection.Rollback;\n            raise;\n          end;\n\n        finally\n          lPhones.Free;\n        end;\n      finally\n        lPerson.Free;\n      end;\n    finally\n      lJSON.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\n  Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo +\n    '/' + lID.ToString;\n  Renderer.Render(TMVCResponse.Create(201, 'Contact created with phones'));\nend;\n\nprocedure TContactProcessor.DeleteEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\nprocedure TContactProcessor.GetEntities(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\nprocedure TContactProcessor.GetEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nvar\n  lContact: TContact;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lJSON: TJsonObject;\n  lPhones: TObjectList<TPhone>;\nbegin\n  // You can write your own entity which already load relations\n  // The following is the manual approach\n  lContact := TMVCActiveRecord.GetByPK<TContact>(id);\n  try\n    lPhones := TMVCActiveRecord.Where<TPhone>('id_person = ?', [id]);\n    try\n      lSer := TMVCJsonDataObjectsSerializer.Create;\n      try\n        lJSON := TJsonObject.Create;\n        try\n          lSer.ObjectToJsonObject(lContact, lJSON,\n            TMVCSerializationType.stDefault, nil);\n          lSer.ListToJsonArray(WrapAsList(lPhones), lJSON.A['phones'],\n            TMVCSerializationType.stDefault, nil);\n          Renderer.Render(lJSON, False);\n        finally\n          lJSON.Free;\n        end;\n      finally\n        lSer.Free;\n      end;\n    finally\n      lPhones.Free;\n    end;\n  finally\n    lContact.Free;\n  end;\n  Handled := True;\nend;\n\nprocedure TContactProcessor.UpdateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\ninitialization\n\nActiveRecordMappingRegistry.AddEntityProcessor('articles',\n  TArticleProcessor.Create);\nActiveRecordMappingRegistry.AddEntityProcessor('contacts',\n  TContactProcessor.Create);\n\nfinalization\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing Newtonsoft.Json.Linq;\nusing Newtonsoft.Json;\nusing System.Linq;\n\nnamespace EntitiesProcessors\n{\n    \n    public class WebContext\n    {\n        public RequestData Request { get; set; } = new RequestData();\n        public ResponseData Response { get; set; } = new ResponseData();\n    }\n\n    public class RequestData\n    {\n        \n        public T BodyAs<T>()\n        {\n            \n            return Activator.CreateInstance<T>();\n        }\n        public string PathInfo { get; set; } = \"/api/contacts\";\n        public string Body { get; set; }\n    }\n\n    public class ResponseData\n    {\n        public Dictionary<string, string> CustomHeaders { get; set; } = new Dictionary<string, string>();\n    }\n\n    \n    public class MVCRenderer\n    {\n        public void Render(object obj, bool formatted = true)\n        {\n            \n            Console.WriteLine(JsonConvert.SerializeObject(obj, Formatting.Indented));\n        }\n    }\n\n    \n    public class Link\n    {\n        public string HREF { get; set; }\n        public string TYPE { get; set; }\n        public string REL { get; set; }\n    }\n\n    \n    public class TArticle\n    {\n        public string Description { get; set; } = \"Default description\";\n        public List<Link> Links { get; set; } = new List<Link>();\n\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Article inserted.\");\n        }\n    }\n\n    \n    public class TContact\n    {\n        // Properties for a contact entity.\n    }\n\n    public class TPhone\n    {\n        public int IDPerson { get; set; }\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Phone inserted.\");\n        }\n    }\n\n    public class TPerson\n    {\n        public long id { get; set; }\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Person inserted.\");\n            \n            id = new Random().Next(1000, 9999);\n        }\n    }\n\n    \n    public static class TMVCActiveRecord\n    {\n        \n        public static List<T> All<T>() where T : new() => new List<T>();\n\n        \n        public static T GetByPK<T>(int id) where T : new() => new T();\n\n        public static List<T> Where<T>(string query, params object[] args) where T : new() => new List<T>();\n\n        public static ConnectionWrapper CurrentConnection { get; } = new ConnectionWrapper();\n    }\n\n    public class ConnectionWrapper\n    {\n        public void StartTransaction() { Console.WriteLine(\"Transaction started.\"); }\n        public void Commit() { Console.WriteLine(\"Transaction committed.\"); }\n        public void Rollback() { Console.WriteLine(\"Transaction rolled back.\"); }\n    }\n\n    public enum MVCSerializationType { stDefault }\n\n    public class MVCTJsonDataObjectsSerializer : IDisposable\n    {\n        public JObject ParseObject(string body)\n        {\n            return JObject.Parse(body);\n        }\n\n        public void JsonObjectToObject(JObject json, object target, MVCSerializationType serializationType, object options)\n        {\n            JsonConvert.PopulateObject(json.ToString(), target);\n        }\n\n        public void JsonArrayToList<T>(JArray jsonArray, List<T> list, MVCSerializationType serializationType, object options)\n        {\n            var items = jsonArray.ToObject<List<T>>();\n            list.AddRange(items);\n        }\n\n        public void ObjectToJsonObject(object obj, JObject json, MVCSerializationType serializationType, object options)\n        {\n            var temp = JObject.FromObject(obj);\n            json.Merge(temp);\n        }\n\n        public void ListToJsonArray<T>(List<T> list, JArray jsonArray, MVCSerializationType serializationType, object options)\n        {\n            jsonArray.Merge(JArray.FromObject(list));\n        }\n\n        public void Dispose()\n        {\n            // Dispose resources if needed.\n        }\n    }\n\n    public List<T> WrapAsList<T>(List<T> list) => list;\n\n    public class MVCRResponse\n    {\n        public int StatusCode { get; set; }\n        public string Message { get; set; }\n        public MVCRResponse(int statusCode, string message)\n        {\n            StatusCode = statusCode;\n            Message = message;\n        }\n    }\n\n    public static class ActiveRecordMappingRegistry\n    {\n        private static Dictionary<string, IMVCEntityProcessor> _processors = new Dictionary<string, IMVCEntityProcessor>();\n        public static void AddEntityProcessor(string entityName, IMVCEntityProcessor processor)\n        {\n            _processors[entityName] = processor;\n            Console.WriteLine($\"Entity processor for '{entityName}' registered.\");\n        }\n    }\n    public interface IMVCEntityProcessor\n    {\n        void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled);\n        void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled);\n        void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n        void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n        void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n    }\n    public class ArticleProcessor : IMVCEntityProcessor\n    {\n        public void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            TArticle article = context.Request.BodyAs<TArticle>();\n            try\n            {\n                article.Insert();\n                renderer.Render(article, false);\n            }\n            finally\n            {\n                \n                (article as IDisposable)?.Dispose();\n            }\n            handled = true;\n        }\n\n        public void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = true;\n            \n            List<TArticle> articles = TMVCActiveRecord.All<TArticle>();\n\n            foreach (var article in articles)\n            {\n                string encoded = WebUtility.UrlEncode(article.Description);\n                article.Links.Add(new Link\n                {\n                    HREF = \"https://www.google.com/search?q=\" + encoded,\n                    TYPE = \"text/html\",\n                    REL = \"googlesearch\"\n                });\n            }\n\n            var dict = new Dictionary<string, object> { { \"data\", articles } };\n            renderer.Render(dict);\n        }\n\n        public void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n    }\n\n    public class ContactProcessor : IMVCEntityProcessor\n    {\n        public void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = true;\n            long lID = 0;\n            using (var ser = new MVCTJsonDataObjectsSerializer())\n            {\n                JObject lJSON = ser.ParseObject(context.Request.Body);\n                try\n                {\n                    TPerson person = new TPerson();\n                    ser.JsonObjectToObject(lJSON, person, MVCSerializationType.stDefault, null);\n\n                    List<TPhone> phones = new List<TPhone>();\n                    ser.JsonArrayToList(lJSON[\"phones\"] as JArray, phones, MVCSerializationType.stDefault, null);\n\n                    TMVCActiveRecord.CurrentConnection.StartTransaction();\n                    try\n                    {\n                        person.Insert();\n                        lID = person.id;\n                        foreach (var phone in phones)\n                        {\n                            phone.IDPerson = (int)person.id;\n                            phone.Insert();\n                        }\n                        TMVCActiveRecord.CurrentConnection.Commit();\n                    }\n                    catch (Exception)\n                    {\n                        TMVCActiveRecord.CurrentConnection.Rollback();\n                        throw;\n                    }\n                }\n                finally\n                {\n                    // Free the JSON object if needed.\n                }\n            }\n            context.Response.CustomHeaders[\"X-REF\"] = context.Request.PathInfo + \"/\" + lID.ToString();\n            renderer.Render(new MVCRResponse(201, \"Contact created with phones\"));\n        }\n\n        public void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = false; \n        }\n\n        public void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            TContact contact = TMVCActiveRecord.GetByPK<TContact>(id);\n            List<TPhone> phones = TMVCActiveRecord.Where<TPhone>(\"id_person = ?\", id.ToString());\n            using (var ser = new MVCTJsonDataObjectsSerializer())\n            {\n                JObject lJSON = new JObject();\n                ser.ObjectToJsonObject(contact, lJSON, MVCSerializationType.stDefault, null);\n                if (lJSON[\"phones\"] == null)\n                    lJSON[\"phones\"] = new JArray();\n                ser.ListToJsonArray(phones, lJSON[\"phones\"] as JArray, MVCSerializationType.stDefault, null);\n                renderer.Render(lJSON, false);\n            }\n            handled = true;\n        }\n\n        public void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n    }\n\n\n    public static class EntitiesProcessorsRegistration\n    {\n        static EntitiesProcessorsRegistration()\n        {\n            ActiveRecordMappingRegistry.AddEntityProcessor(\"articles\", new ArticleProcessor());\n            ActiveRecordMappingRegistry.AddEntityProcessor(\"contacts\", new ContactProcessor());\n        }\n    }\n}"}
{"input": "unit MainDataModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  MVCFramework.Commons,\n  Data.DB,\n  Data.SqlExpr,\n  FireDAC.Stan.Intf,\n  FireDAC.Stan.Option,\n  FireDAC.Stan.Error,\n  FireDAC.UI.Intf,\n  FireDAC.Phys.Intf,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Phys,\n  FireDAC.Comp.Client,\n  FireDAC.Stan.Param,\n  FireDAC.DatS,\n  FireDAC.DApt.Intf,\n  FireDAC.DApt,\n  FireDAC.Comp.DataSet,\n  FireDAC.Phys.IBBase,\n  FireDAC.Phys.FB,\n  WinesBO,\n  FireDAC.Phys.FBDef,\n  FireDAC.VCLUI.Wait;\n\ntype\n  TWineCellarDataModule = class(TDataModule)\n    Connection: TFDConnection;\n    qryWines: TFDQuery;\n    updWines: TFDUpdateSQL;\n    FDPhysFBDriverLink1: TFDPhysFBDriverLink;\n    procedure ConnectionBeforeConnect(Sender: TObject);\n\n  public\n    function GetWineById(id: Integer): TDataSet;\n    function FindWines(Search: string): TDataSet;\n    function GetAllWines: TDataSet;\n    procedure AddWine(AWine: TWine);\n    procedure UpdateWine(AWine: TWine);\n    procedure DeleteWine(id: Integer);\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  System.StrUtils,\n  MVCFramework.FireDAC.Utils;\n\n{ TCellarSM }\n\nprocedure TWineCellarDataModule.AddWine(AWine: TWine);\nbegin\n  TFireDACUtils.ObjectToParameters(updWines.Commands[arInsert].Params, AWine, 'NEW_');\n  updWines.Commands[arInsert].Execute;\nend;\n\nprocedure TWineCellarDataModule.DeleteWine(id: Integer);\nbegin\n  updWines.Commands[arDelete].ParamByName('OLD_ID').AsInteger := id;\n  updWines.Commands[arDelete].Execute;\nend;\n\nprocedure TWineCellarDataModule.ConnectionBeforeConnect(Sender: TObject);\nvar\n  lDBPath: string;\nbegin\n  // if database is defined in .env use that, otherwise try to\n  // understand where the database is\n  if not dotEnv.Env('database.path').IsEmpty then\n  begin\n    Connection.Params.Values['Database'] := dotEnv.Env('database.path');\n  end\n  else\n  begin\n    if not IsLibrary then\n    begin\n      // Is compiled as EXE\n      Connection.Params.Values['Database'] := ExtractFilePath(ParamStr(0)) + '..\\..\\WINES_FB30.FDB';\n    end\n    else\n    begin\n      // compiled as apache module or isapi\n      lDBPath := ExtractFilePath(GetModuleName(HInstance)) + '..\\..\\..\\wine_cellar_sample\\winecellarserver\\WINES_FB30.FDB';\n      if lDBPath.StartsWith('\\\\?\\') then\n        lDBPath := lDBPath.Remove(0, 4);\n      Connection.Params.Values['Database'] := lDBPath;\n    end;\n  end;\nend;\n\nfunction TWineCellarDataModule.FindWines(Search: string): TDataSet;\nbegin\n  if Search.IsEmpty then\n    qryWines.Open('SELECT * FROM wine')\n  else\n    qryWines.Open('SELECT * FROM wine where NAME CONTAINING ?', [Search]);\n  Result := qryWines;\nend;\n\nfunction TWineCellarDataModule.GetAllWines: TDataSet;\nbegin\n  Result := FindWines('');\nend;\n\nfunction TWineCellarDataModule.GetWineById(id: Integer): TDataSet;\nbegin\n  qryWines.Open('SELECT * FROM wine where id = ?', [id]);\n  Result := qryWines;\nend;\n\nprocedure TWineCellarDataModule.UpdateWine(AWine: TWine);\nbegin\n  TFireDACUtils.ObjectToParameters(updWines.Commands[arUpdate].Params, AWine, 'NEW_');\n  updWines.Commands[arUpdate].Params.ParamByName('OLD_ID').AsInteger := AWine.id;\n  updWines.Commands[arUpdate].Execute;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.IO;\nusing FirebirdSql.Data.FirebirdClient;\nusing WinesBO; \n\nnamespace MyApp.Data\n{\n    \n    public class WineCellarDataModule : IDisposable\n    {\n        \n        private FbConnection _connection;\n\n        \n        public WineCellarDataModule()\n        {\n            \n            _connection = new FbConnection();\n            _connection.ConnectionString = \"\"; \n            ConnectionBeforeConnect();\n        }\n\n       \n        private void ConnectionBeforeConnect()\n        {\n            string envDbPath = Environment.GetEnvironmentVariable(\"database.path\");\n            string dbPath;\n            if (!string.IsNullOrEmpty(envDbPath))\n            {\n                dbPath = envDbPath;\n            }\n            else\n            {\n                \n                string exePath = AppDomain.CurrentDomain.BaseDirectory;\n                dbPath = Path.Combine(exePath, @\"..\\..\\WINES_FB30.FDB\");\n            }\n\n            \n            _connection.ConnectionString =\n                $\"User=SYSDBA;Password=masterkey;Database={dbPath};DataSource=localhost;Port=3050;Dialect=3;Charset=NONE;Pooling=true;\";\n        }\n\n        \n        public DataSet GetAllWines()\n        {\n            return FindWines(\"\");\n        }\n\n        \n        public DataSet GetWineById(int id)\n        {\n            string sql = \"SELECT * FROM wine WHERE id = @id\";\n            return ExecuteQuery(sql, new FbParameter(\"@id\", id));\n        }\n\n        \n        public DataSet FindWines(string search)\n        {\n            string sql;\n            FbParameter param = null;\n            if (string.IsNullOrWhiteSpace(search))\n            {\n                sql = \"SELECT * FROM wine\";\n            }\n            else\n            {\n                sql = \"SELECT * FROM wine WHERE NAME CONTAINING @search\";\n                param = new FbParameter(\"@search\", search);\n            }\n            return ExecuteQuery(sql, param);\n        }\n\n        \n        public void AddWine(TWine wine)\n        {\n            \n            string sql = \"INSERT INTO wine (NAME, YEAR, DESCRIPTION) VALUES (@NEW_Name, @NEW_Year, @NEW_Description)\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                \n                cmd.Parameters.AddWithValue(\"@NEW_Name\", wine.Name);\n                cmd.Parameters.AddWithValue(\"@NEW_Year\", wine.Year);\n                cmd.Parameters.AddWithValue(\"@NEW_Description\", wine.Description);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        public void UpdateWine(TWine wine)\n        {\n            \n            string sql = \"UPDATE wine SET NAME = @NEW_Name, YEAR = @NEW_Year, DESCRIPTION = @NEW_Description WHERE id = @OLD_ID\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                cmd.Parameters.AddWithValue(\"@NEW_Name\", wine.Name);\n                cmd.Parameters.AddWithValue(\"@NEW_Year\", wine.Year);\n                cmd.Parameters.AddWithValue(\"@NEW_Description\", wine.Description);\n                cmd.Parameters.AddWithValue(\"@OLD_ID\", wine.Id);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        public void DeleteWine(int id)\n        {\n            string sql = \"DELETE FROM wine WHERE id = @OLD_ID\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                cmd.Parameters.AddWithValue(\"@OLD_ID\", id);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        private DataSet ExecuteQuery(string sql, params FbParameter[] parameters)\n        {\n            DataSet ds = new DataSet();\n            using (FbDataAdapter adapter = new FbDataAdapter(sql, _connection))\n            {\n                if (parameters != null && parameters.Length > 0)\n                {\n                    adapter.SelectCommand.Parameters.AddRange(parameters);\n                }\n                _connection.Open();\n                adapter.Fill(ds);\n                _connection.Close();\n            }\n            return ds;\n        }\n\n        #region IDisposable Support\n        private bool disposedValue = false;\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    \n                    if (_connection != null)\n                    {\n                        _connection.Dispose();\n                        _connection = null;\n                    }\n                }\n                \n                disposedValue = true;\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        #endregion\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.GlobalLogger;\n\ninterface\n\nuses\n  LoggerPro;\n{ @abstract(The global logger. Just uses @link(Logger.GlobalLogger) and you can start to log using @code(Log) function.)\n  The global logger is configured with a @link(TLoggerProFileAppender) using default settings.\n}\nfunction Log: ILogWriter;\n\n{ @abstract(Use only inside DLL because dll unloading is not a safe place to shutdown threads, so call this before unload DLL)\n  Use this also in ISAPI dll. Check the @code(loggerproisapisample.dll) sample\n}\nprocedure ReleaseGlobalLogger;\n\nimplementation\n\nuses\n  LoggerPro.FileAppender;\n\nvar\n  _Logger: ILogWriter;\n  _Lock: TObject = nil;\n  _ShuttedDown: boolean = false;\n\nfunction Log: ILogWriter;\nbegin\n  if _Logger = nil then\n  begin\n    if not _ShuttedDown then\n    begin\n      TMonitor.Enter(_Lock);\n      try\n        if _Logger = nil then // double check\n        begin\n          _Logger := BuildLogWriter([TLoggerProFileAppender.Create]);\n        end;\n      finally\n        TMonitor.Exit(_Lock);\n      end;\n    end;\n  end;\n  Result := _Logger;\nend;\n\nprocedure ReleaseGlobalLogger;\nbegin\n  if _Logger <> nil then\n  begin\n    TMonitor.Enter(_Lock);\n    try\n      if _Logger <> nil then // double check\n      begin\n        _Logger := nil;\n        _ShuttedDown := True;\n      end;\n    finally\n      TMonitor.Exit(_Lock);\n    end;\n  end;\nend;\n\ninitialization\n\n_Lock := TObject.Create;\n\nfinalization\n\n_Lock.Free;\n\nend.", "output": "using System;\nusing LoggerPro; \nusing LoggerPro.Appenders; \n\nnamespace LoggerPro\n{\n   \n   public static class GlobalLogger\n   {\n      private static ILogWriter _logger = null;\n      private static readonly object _lock = new object();\n      private static bool _shuttedDown = false;\n\n      \n      public static ILogWriter Log\n      {\n         get\n         {\n            if (_logger == null)\n            {\n               if (!_shuttedDown)\n               {\n                  lock (_lock)\n                  {\n                     \n                     if (_logger == null)\n                     {\n                        \n                        _logger = LoggerProBuilder.BuildLogWriter(\n                           new ILogAppender[] { new LoggerProFileAppender() }\n                        );\n                     }\n                  }\n               }\n            }\n            return _logger;\n         }\n      }\n\n      \n      public static void ReleaseGlobalLogger()\n      {\n         if (_logger != null)\n         {\n            lock (_lock)\n            {\n               if (_logger != null)\n               {\n                  _logger = null;\n                  _shuttedDown = true;\n               }\n            }\n         }\n      }\n   }\n}"}
{"input": "unit LoggerProTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework, LoggerPro, LoggerPro.Proxy, System.SysUtils;\n\ntype\n\n  [TestFixture]\n  TLoggerProTest = class(TObject)\n  public\n    [Setup]\n    procedure Setup;\n    [TearDown]\n    procedure TearDown;\n    [Test]\n    procedure TestTLogItemClone;\n    [Test]\n    [TestCase('Type DEBUG', '0,DEBUG')]\n    [TestCase('Type INFO', '1,INFO')]\n    [TestCase('Type WARN', '2,WARNING')]\n    [TestCase('Type ERROR', '3,ERROR')]\n    [TestCase('Type FATAL', '4,FATAL')]\n    procedure TestTLogItemTypeAsString(aLogType: Byte; aExpected: String);\n\n//    [Test]   {refactor this}\n//    procedure TestOnAppenderError;\n\n    [Test]\n    [TestCase('No proxy', 'false')]\n    [TestCase('With proxy', 'true')]\n    procedure TestLogLevel(UseProxy: boolean);\n\n    [Test]\n    procedure TestAddAndDeleteAppenders;\n\n    [Test]\n    [TestCase('Case1', '{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG')]\n    [TestCase('Case2', '{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG')]\n    [TestCase('Case3', '{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE')]\n    [TestCase('Case4', '{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]')]\n    procedure TestLogLayoutToLogIndices(const LogLayout, ResultOutput: string);\n\n  end;\n\nimplementation\n\nuses\n  TestSupportAppendersU, System.SyncObjs, LoggerPro.OutputDebugStringAppender;\n\nfunction LogItemAreEquals(A, B: TLogItem): Boolean;\nbegin\n  Assert.AreEqual(A.LogType, B.LogType, 'LogType is different');\n  Assert.AreEqual(A.LogMessage, B.LogMessage, 'LogMessage is different');\n  Assert.AreEqual(A.LogTag, B.LogTag, 'LogTag is different');\n  Assert.AreEqual(A.TimeStamp, B.TimeStamp, 'TimeStamp is different');\n  Assert.AreEqual(A.ThreadID, B.ThreadID, 'ThreadID is different');\n  Result := True;\nend;\n\nprocedure TLoggerProTest.Setup;\nbegin\nend;\n\nprocedure TLoggerProTest.TearDown;\nbegin\nend;\n\nprocedure TLoggerProTest.TestAddAndDeleteAppenders;\nvar\n  LAppender1, LAppender2: ILogAppender;\n  LLogWriter: ILogWriter;\nbegin\n  LAppender1 := TLoggerProOutputDebugStringAppender.Create();\n  LAppender2 := TLoggerProOutputDebugStringAppender.Create();\n\n  LLogWriter := BuildLogWriter([LAppender1, LAppender2]);\n  LLogWriter.Debug('Added Appenders', 'Appender');\n  Assert.AreEqual(2, LLogWriter.AppendersCount);\n\n  LLogWriter.DelAppender(LAppender1);\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\n  Assert.AreEqual(1, LLogWriter.AppendersCount);\n\n  LLogWriter.DelAppender(LAppender2);\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\n  Assert.AreEqual(0, LLogWriter.AppendersCount);\n\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\nend;\n\nprocedure TLoggerProTest.TestLogLayoutToLogIndices(const LogLayout, ResultOutput: string);\nbegin\n  var lWithIndices := LogLayoutByPlaceHoldersToLogLayoutByIndexes(LogLayout);\n  var s := Format(\n    lWithIndices,\n    [\n      FormatDateTime('yyyy-mm-dd hh:nn:ss:zzz', encodedate(2020,3,15) + EncodeTime(12,30,20,123)),\n      '1234',\n      'LOGLEVEL',\n      'THIS IS THE MESSAGE',\n      'THE_TAG'\n    ]);\n  Assert.AreEqual(ResultOutput, s);\nend;\n\nprocedure TLoggerProTest.TestLogLevel(UseProxy: boolean);\nvar\n  lSetup, lTearDown: TProc;\n  lTearDownCalled, lSetupCalled: Boolean;\n  lWriteLog: TProc<TLogItem>;\n  lLogWriter: ILogWriter;\n  lLogItem: TLogItem;\n  lEvent: TEvent;\n  lLock: TObject;\n  lHistory: TArray<String>;\n  Appender: ILogAppender;\n  InvalidItemLogged: int64;\nconst\n  STR_FORBIDDEN = 'ignoredmessage';\nbegin\n  lHistory := [];\n  lLock := TObject.Create;\n  try\n    lSetup := procedure\n      begin\n        lHistory := lHistory + ['setup'];\n        lSetupCalled := True;\n      end;\n    lTearDown := procedure\n      begin\n        lHistory := lHistory + ['teardown'];\n        lTearDownCalled := True;\n      end;\n    lWriteLog := procedure(aLogItem: TLogItem)\n      begin\n        lHistory := lHistory + ['writelog' + aLogItem.LogTypeAsString];\n        // If the logged message is suppsed to be filtered, increase the \"InvalidItemLogged\" count\n        if aLogItem.LogMessage.Equals(STR_FORBIDDEN) then\n          TInterlocked.Increment(InvalidItemLogged);\n        TMonitor.Enter(lLock);\n        try\n          FreeAndNil(lLogItem);\n          lLogItem := aLogItem.Clone;\n          lEvent.SetEvent;\n        finally\n          TMonitor.Exit(lLock);\n        end;\n      end;\n    Appender := TMyAppender.Create(lSetup, lTearDown, lWriteLog);\n    if UseProxy then\n    begin\n      Appender := TLoggerProFilter.Build(Appender,\n        function (LogItem: TLogItem): Boolean\n        begin\n          result := not LogItem.LogMessage.Equals(STR_FORBIDDEN);\n        end\n      );\n    end;\n    InvalidItemLogged := 0;\n    lLogWriter := BuildLogWriter([Appender]);\n    lEvent := TEvent.Create(nil, True, false, '');\n    try\n      // debug message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Debug('debug message', 'debug');\n      if UseProxy then\n        lLogWriter.Debug('ignoredmessage', 'debug');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('debug message', lLogItem.LogMessage);\n      Assert.AreEqual('debug', lLogItem.LogTag);\n      Assert.AreEqual('DEBUG', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // info message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Info('info message', 'info');\n      if UseProxy then\n        lLogWriter.Info('ignoredmessage', 'info');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('info message', lLogItem.LogMessage);\n      Assert.AreEqual('info', lLogItem.LogTag);\n      Assert.AreEqual('INFO', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // warning message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Warn('warning message', 'warning');\n      if UseProxy then\n        lLogWriter.Warn('ignoredmessage', 'warning');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('warning message', lLogItem.LogMessage);\n      Assert.AreEqual('warning', lLogItem.LogTag);\n      Assert.AreEqual('WARNING', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // error message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Error('error message', 'error');\n      if UseProxy then\n        lLogWriter.Error('ignoredmessage', 'error');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('error message', lLogItem.LogMessage);\n      Assert.AreEqual('error', lLogItem.LogTag);\n      Assert.AreEqual('ERROR', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // fatal message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Fatal('fatal message', 'fatal');\n      if UseProxy then\n        lLogWriter.Fatal('ignoredmessage', 'fatal');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('fatal message', lLogItem.LogMessage);\n      Assert.AreEqual('fatal', lLogItem.LogTag);\n      Assert.AreEqual('FATAL', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n\n      lLogWriter := nil;\n      Assert.AreEqual(7, Length(lHistory));\n      Assert.AreEqual('setup', lHistory[0]);\n      Assert.AreEqual('writelogDEBUG', lHistory[1]);\n      Assert.AreEqual('writelogINFO', lHistory[2]);\n      Assert.AreEqual('writelogWARNING', lHistory[3]);\n      Assert.AreEqual('writelogERROR', lHistory[4]);\n      Assert.AreEqual('writelogFATAL', lHistory[5]);\n      Assert.AreEqual('teardown', lHistory[6]);\n    finally\n      lEvent.Free;\n    end;\n  finally\n    lLock.Free;\n  end;\nend;\n\n//procedure TLoggerProTest.TestOnAppenderError;\n//var\n//  lLog: ILogWriter;\n//  I: Integer;\n//  lEventsHandlers: TLoggerProEventsHandler;\n//  lAppenders: TArray<String>;\n//  lSavedLoggerProAppenderQueueSize: Cardinal;\n//  lOldestsDiscarded: Int64;\n//  lNewestsSkipped: Int64;\n//  lCount: Int64;\n//  lTempCount: Int64;\n//begin\n//  lCount := 0;\n//  lSavedLoggerProAppenderQueueSize := DefaultLoggerProAppenderQueueSize;\n//  DefaultLoggerProMainQueueSize := 1;\n//  DefaultLoggerProAppenderQueueSize := 1;\n//\n//  lNewestsSkipped := 0;\n//  lOldestsDiscarded := 0;\n//  lEventsHandlers := TLoggerProEventsHandler.Create;\n//  try\n//    lEventsHandlers.OnAppenderError :=\n//        procedure(const AppenderClassName: String;\n//        const FailedLogItem: TLogItem; const Reason: TLogErrorReason;\n//        var Action: TLogErrorAction)\n//      var\n//        lLocalCount: Int64;\n//      begin\n//        lLocalCount := TInterlocked.Add(lCount, 1);\n//        if lLocalCount <= 20 then\n//        begin\n//          Action := TLogErrorAction.SkipNewest;\n//          TInterlocked.Increment(lNewestsSkipped);\n//        end\n//        else\n//        begin\n//          Action := TLogErrorAction.DiscardOlder;\n//          TInterlocked.Increment(lOldestsDiscarded);\n//        end;\n//      end;\n//\n//    lLog := BuildLogWriter([TMyVerySlowAppender.Create(1000)], lEventsHandlers);\n//    for I := 1 to 40 do\n//    begin\n//      lLog.Debug('log message ' + I.ToString, 'tag');\n//    end;\n//\n//    {TODO -oDanieleT -cGeneral : Refactor this test}\n////    while True do\n////    begin\n////      lTempCount := TInterlocked.Read(lNewestsSkipped);\n////      if lTempCount < 20 then\n////        Sleep(10)\n////      else\n////        break;\n////    end;\n//\n//    {TODO -oDanieleT -cGeneral : Refactor this test}\n////    while True do\n////    begin\n////      lTempCount := TInterlocked.Read(lOldestsDiscarded);\n////      if lTempCount < 20 then\n////        Sleep(10)\n////      else\n////        break;\n////    end;\n//\n////    while TInterlocked.Read(lCount) < 40 do\n////      Sleep(100);\n//\n//    lAppenders := lLog.GetAppendersClassNames;\n//    Assert.AreEqual(1, Length(lAppenders));\n//    Assert.AreEqual('TMyVerySlowAppender', lAppenders[0]);\n//    lLog := nil;\n//  finally\n//    DefaultLoggerProAppenderQueueSize := lSavedLoggerProAppenderQueueSize;\n//    lEventsHandlers.Free;\n//  end;\n//\n//end;\n\nprocedure TLoggerProTest.TestTLogItemClone;\nvar\n  lLogItem: TLogItem;\n  lClonedLogItem: TLogItem;\nbegin\n  lLogItem := TLogItem.Create(TLogType.Debug, 'message', 'tag');\n  try\n    lClonedLogItem := lLogItem.Clone;\n    try\n      LogItemAreEquals(lLogItem, lClonedLogItem);\n    finally\n      lClonedLogItem.Free;\n    end;\n  finally\n    lLogItem.Free;\n  end;\nend;\n\nprocedure TLoggerProTest.TestTLogItemTypeAsString(aLogType: Byte;\n  aExpected: String);\nvar\n  lLogItem: TLogItem;\nbegin\n  lLogItem := TLogItem.Create(TLogType(aLogType), 'message', 'tag');\n  try\n    Assert.AreEqual(aExpected, lLogItem.LogTypeAsString);\n  finally\n    lLogItem.Free;\n  end;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TLoggerProTest);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing NUnit.Framework;\nusing LoggerPro;            \nusing LoggerPro.Proxy;     \n\nnamespace LoggerPro.Tests\n{\n    \n    public static class TestHelpers\n    {\n        \n        public static bool LogItemAreEquals(LogItem a, LogItem b)\n        {\n            Assert.AreEqual(a.LogType, b.LogType, \"LogType is different\");\n            Assert.AreEqual(a.LogMessage, b.LogMessage, \"LogMessage is different\");\n            Assert.AreEqual(a.LogTag, b.LogTag, \"LogTag is different\");\n            Assert.AreEqual(a.TimeStamp, b.TimeStamp, \"TimeStamp is different\");\n            Assert.AreEqual(a.ThreadID, b.ThreadID, \"ThreadID is different\");\n            return true;\n        }\n    }\n\n    \n    public class TestAppender : ILogAppender\n    {\n        private readonly Action _onSetup;\n        private readonly Action _onTearDown;\n        private readonly Action<LogItem> _onWriteLog;\n\n        public TestAppender(Action onSetup, Action onTearDown, Action<LogItem> onWriteLog)\n        {\n            _onSetup = onSetup;\n            _onTearDown = onTearDown;\n            _onWriteLog = onWriteLog;\n        }\n\n        public void Setup() => _onSetup?.Invoke();\n\n        public void TearDown() => _onTearDown?.Invoke();\n\n        public void WriteLog(LogItem logItem) => _onWriteLog?.Invoke(logItem);\n\n        \n        public int AppendersCount => 1;\n\n        \n        public string[] GetAppendersClassNames() => new string[] { GetType().Name };\n    }\n\n    \n    [TestFixture]\n    public class LoggerProTest\n    {\n        \n        private LogItem _lastLogItem;\n\n        [SetUp]\n        public void Setup()\n        {\n            // Nothing needed here.\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            // Clean up if needed.\n        }\n\n        [Test]\n        public void TestTLogItemClone()\n        {\n            LogItem logItem = new LogItem(LogType.Debug, \"message\", \"tag\");\n            try\n            {\n                LogItem clonedLogItem = logItem.Clone();\n                try\n                {\n                    Assert.IsTrue(TestHelpers.LogItemAreEquals(logItem, clonedLogItem));\n                }\n                finally\n                {\n                    clonedLogItem.Dispose();\n                }\n            }\n            finally\n            {\n                logItem.Dispose();\n            }\n        }\n\n        [Test]\n        [TestCase(0, \"DEBUG\")]\n        [TestCase(1, \"INFO\")]\n        [TestCase(2, \"WARNING\")]\n        [TestCase(3, \"ERROR\")]\n        [TestCase(4, \"FATAL\")]\n        public void TestTLogItemTypeAsString(byte logType, string expected)\n        {\n            LogItem logItem = new LogItem((LogType)logType, \"message\", \"tag\");\n            try\n            {\n                Assert.AreEqual(expected, logItem.LogTypeAsString);\n            }\n            finally\n            {\n                logItem.Dispose();\n            }\n        }\n\n        [Test]\n        [TestCase(false)]\n        [TestCase(true)]\n        public void TestLogLevel(bool useProxy)\n        {\n            \n            List<string> history = new List<string>();\n            object syncLock = new object();\n            long invalidItemLogged = 0;\n            ManualResetEvent mre = new ManualResetEvent(false);\n\n            \n            TestAppender appender = new TestAppender(\n                onSetup: () => history.Add(\"setup\"),\n                onTearDown: () => history.Add(\"teardown\"),\n                onWriteLog: (logItem) =>\n                {\n                    history.Add(\"writelog\" + logItem.LogTypeAsString);\n                    \n                    if (logItem.LogMessage.Equals(\"ignoredmessage\", StringComparison.Ordinal))\n                    {\n                        Interlocked.Increment(ref invalidItemLogged);\n                    }\n                    \n                    lock (syncLock)\n                    {\n                        _lastLogItem?.Dispose();\n                        _lastLogItem = logItem.Clone();\n                        mre.Set();\n                    }\n                }\n            );\n\n            ILogAppender finalAppender = appender;\n            if (useProxy)\n            {\n                \n                finalAppender = LoggerProFilter.Build(appender, logItem =>\n                {\n                    return !logItem.LogMessage.Equals(\"ignoredmessage\", StringComparison.Ordinal);\n                });\n            }\n            invalidItemLogged = 0;\n            ILogWriter logWriter = LoggerProExtensions.BuildLogWriter(new ILogAppender[] { finalAppender });\n\n            \n            mre.Reset();\n            logWriter.Debug(\"debug message\", \"debug\");\n            if (useProxy)\n                logWriter.Debug(\"ignoredmessage\", \"debug\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"debug message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"debug\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"DEBUG\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Info(\"info message\", \"info\");\n            if (useProxy)\n                logWriter.Info(\"ignoredmessage\", \"info\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"info message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"info\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"INFO\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Warn(\"warning message\", \"warning\");\n            if (useProxy)\n                logWriter.Warn(\"ignoredmessage\", \"warning\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"warning message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"warning\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"WARNING\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Error(\"error message\", \"error\");\n            if (useProxy)\n                logWriter.Error(\"ignoredmessage\", \"error\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"error message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"error\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"ERROR\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Fatal(\"fatal message\", \"fatal\");\n            if (useProxy)\n                logWriter.Fatal(\"ignoredmessage\", \"fatal\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"fatal message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"fatal\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"FATAL\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            logWriter = null;\n            \n            Assert.AreEqual(7, history.Count);\n            Assert.AreEqual(\"setup\", history[0]);\n            Assert.AreEqual(\"writelogDEBUG\", history[1]);\n            Assert.AreEqual(\"writelogINFO\", history[2]);\n            Assert.AreEqual(\"writelogWARNING\", history[3]);\n            Assert.AreEqual(\"writelogERROR\", history[4]);\n            Assert.AreEqual(\"writelogFATAL\", history[5]);\n            Assert.AreEqual(\"teardown\", history[6]);\n        }\n\n        [Test]\n        public void TestAddAndDeleteAppenders()\n        {\n            \n            ILogAppender appender1 = new OutputDebugStringAppender();\n            ILogAppender appender2 = new OutputDebugStringAppender();\n\n            ILogWriter logWriter = LoggerProExtensions.BuildLogWriter(new ILogAppender[] { appender1, appender2 });\n            logWriter.Debug(\"Added Appenders\", \"Appender\");\n            Assert.AreEqual(2, logWriter.AppendersCount);\n\n            logWriter.DelAppender(appender1);\n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n            Assert.AreEqual(1, logWriter.AppendersCount);\n\n            logWriter.DelAppender(appender2);\n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n            Assert.AreEqual(0, logWriter.AppendersCount);\n\n            \n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n        }\n\n        [Test]\n        [TestCase(\"{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\",\n                  \"{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\")]\n        [TestCase(\"{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\",\n                  \"{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\")]\n        [TestCase(\"{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE\",\n                  \"{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE\")]\n        [TestCase(\"{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]\",\n                  \"{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]\")]\n        public void TestLogLayoutToLogIndices(string logLayout, string expectedOutput)\n        {\n            \n            string layoutWithIndices = LoggerProExtensions.LogLayoutByPlaceHoldersToLogLayoutByIndexes(logLayout);\n\n            \n            DateTime dt = new DateTime(2020, 3, 15, 12, 30, 20, 123);\n            \n            string formatted = string.Format(layoutWithIndices,\n                dt.ToString(\"yyyy-MM-dd HH:mm:ss:fff\"),\n                \"    1234\",       \n                \"LOGLEVEL\",\n                \"THIS IS THE MESSAGE\",\n                \"THE_TAG\");\n\n            Assert.AreEqual(expectedOutput, formatted);\n        }\n    }\n}"}
{"input": "unit MainSenderFormU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, System.Net.URLClient,\n  System.Net.HttpClient, System.Net.HttpClientComponent;\n\ntype\n  TForm10 = class(TForm)\n    edtMessage: TEdit;\n    Label1: TLabel;\n    btnSend: TButton;\n    HTTPSend: TNetHTTPClient;\n    procedure btnSendClick(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nvar\n  Form10: TForm10;\n\nimplementation\n\nuses\n  JsonDataObjects;\n\n{$R *.dfm}\n\nprocedure TForm10.btnSendClick(Sender: TObject);\nvar\n  lStream: TStringStream;\n  lJSON: TJsonObject;\n  lRes: IHTTPResponse;\nbegin\n  lStream := TStringStream.Create;\n  try\n    lJSON := TJsonObject.Create;\n    try\n      lJSON.S['value'] := edtMessage.Text;\n      lStream.WriteString(lJSON.ToJSON());\n    finally\n      lJSON.Free;\n    end;\n    lStream.Position := 0;\n    lRes := HTTPSend.Post('http://localhost:8080/api/notifications', lStream, nil, [TNetHEader.Create('content-type', 'application/json')]);\n    if lRes.StatusCode <> 201 then\n    begin\n      ShowMessage(Format('%d: %s (%s)', [lRes.StatusCode, lres.StatusText, lres.ContentAsString]));\n    end;\n  finally\n    lStream.Free;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Windows.Forms;\n\nnamespace MainSenderFormApp\n{\n    public class MainSenderForm : Form\n    {\n        private TextBox edtMessage;\n        private Label lblMessage;\n        private Button btnSend;\n        private HttpClient httpClient;\n\n        public MainSenderForm()\n        {\n            \n            httpClient = new HttpClient();\n\n            \n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            \n            this.edtMessage = new TextBox();\n            this.lblMessage = new Label();\n            this.btnSend = new Button();\n\n            \n            this.lblMessage.Text = \"Enter Message:\";\n            this.lblMessage.Location = new Point(20, 33);\n            this.lblMessage.AutoSize = true;\n\n            \n            this.edtMessage.Location = new Point(100, 30);\n            this.edtMessage.Size = new Size(250, 20);\n\n            \n            this.btnSend.Text = \"Send Message\";\n            this.btnSend.Location = new Point(100, 70);\n            this.btnSend.Click += new EventHandler(btnSend_Click);\n\n            \n            this.ClientSize = new Size(400, 120);\n            this.Controls.Add(this.lblMessage);\n            this.Controls.Add(this.edtMessage);\n            this.Controls.Add(this.btnSend);\n            this.Text = \"Main Sender Form\";\n        }\n\n        private async void btnSend_Click(object sender, EventArgs e)\n        {\n            var jsonObject = new { value = edtMessage.Text };\n            string jsonString = JsonSerializer.Serialize(jsonObject);\n\n            using (var content = new StringContent(jsonString, Encoding.UTF8, \"application/json\"))\n            {\n                try\n                {\n                    HttpResponseMessage response = await httpClient.PostAsync(\"http://localhost:8080/api/notifications\", content);\n                    \n                    if (response.StatusCode != HttpStatusCode.Created)\n                    {\n                        string responseContent = await response.Content.ReadAsStringAsync();\n                        MessageBox.Show(\n                            $\"{(int)response.StatusCode}: {response.ReasonPhrase} ({responseContent})\",\n                            \"Error\",\n                            MessageBoxButtons.OK,\n                            MessageBoxIcon.Error);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message, \"Exception\", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                }\n            }\n        }\n\n        protected override void OnFormClosed(FormClosedEventArgs e)\n        {\n            httpClient.Dispose();\n            base.OnFormClosed(e);\n        }\n    }\n\n    static class Program\n    {\n        \n        [STAThread]\n        static void Main()\n        {\n            \n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new MainSenderForm());\n        }\n    }\n}"}
{"input": "unit Views.Main;\n\n{$MODE DELPHI}{$H+}\n\ninterface\n\nuses Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons, Horse;\n\ntype\n  TFrmMain = class(TForm)\n    btnStart: TBitBtn;\n    btnStop: TBitBtn;\n    edtPort: TEdit;\n    Label1: TLabel;\n    procedure btnStartClick(Sender: TObject);\n    procedure btnStopClick(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n  private\n    procedure Status;\n    procedure Start;\n    procedure Stop;\n  end;\n\nvar\n  FrmMain: TFrmMain;\n\nimplementation\n\nprocedure DoPing(Req: THorseRequest; Res: THorseResponse);\nbegin\n  Res.Send('pong');\nend;\n\n{$R *.lfm}\n\nprocedure TFrmMain.btnStartClick(Sender: TObject);\nbegin\n  Start;\n  Status;\nend;\n\nprocedure TFrmMain.btnStopClick(Sender: TObject);\nbegin\n  Stop;\n  Status;\nend;\n\nprocedure TFrmMain.FormCreate(Sender: TObject);\nbegin\n  THorse.Get('/ping', DoPing);\nend;\n\nprocedure TFrmMain.Status;\nbegin\n  btnStop.Enabled := THorse.IsRunning;\n  btnStart.Enabled := not THorse.IsRunning;\n  edtPort.Enabled := not THorse.IsRunning;\nend;\n\nprocedure TFrmMain.Start;\nbegin\n  // Need to set \"HORSE_LCL\" compilation directive\n  THorse.Listen(StrToInt(edtPort.Text));\nend;\n\nprocedure TFrmMain.Stop;\nbegin\n  THorse.StopListen;\nend;\n\nend.", "output": "namespace YourNamespace\n{\n    public interface IUsersService\n    {\n        string GetUserNameByID(int id);\n    }\n\n    public interface ICustomersService\n    {\n        string GetCustomerNameByID(int id);\n    }\n\n    public interface ICommonService\n    {\n        string GetID();\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Renderers.WebStencils;\n\n{$I dmvcframework.inc}\n\ninterface\n\n{$if Defined(WEBSTENCILS)}\n\n//This unit is usable from Delphi 12.2+\n\nuses\n  MVCFramework, System.Generics.Collections, System.SysUtils,\n  MVCFramework.Commons, System.IOUtils, System.Classes, Web.Stencils,\n  System.Rtti, MVCFramework.Nullables, System.DateUtils, System.TypInfo;\n\ntype\n  TMVCWebStencilsEvent = reference to procedure(const WebStencilsProcessor: TWebStencilsProcessor);\n\n  { This class implements the WebStencils view engine for server side views }\n  TMVCWebStencilsViewEngine = class(TMVCBaseViewEngine)\n  protected\n    procedure RegisterWSFunctions(WSProcessor: TWebStencilsProcessor);\n    procedure OnGetValue(Sender: TObject; const AObjectName, APropName: string; var AReplaceText: string; var AHandled: Boolean);\n    procedure OnGetFile(Sender: TObject; const AFilename: string; var AText: string; var AHandled: Boolean);\n  public\n    class function GetTValueVarAsString(const Value: TValue; const VarName: string; const Processor: TWebStencilsProcessor): String;\n    procedure Execute(const ViewName: string; const Builder: TStringBuilder); override;\n  end;\n\n  TMVCWebStencilsConfiguration = class sealed\n  private\n    class var fOnProcessorConfiguration: TMVCWebStencilsEvent;\n  public\n    class property OnProcessorConfiguration: TMVCWebStencilsEvent\n      read fOnProcessorConfiguration\n      write fOnProcessorConfiguration;\n  end;\n\n{$endif}\n\nimplementation\n\n\n{$if Defined(WEBSTENCILS)}\nuses\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.DuckTyping,\n  System.Bindings.EvalProtocol,\n  System.Bindings.Methods,\n  MVCFramework.Cache,\n  Data.DB,\n  JsonDataObjects;\n\n{$WARNINGS OFF}\n\nvar\n  gFunctionInitialized: Boolean = False;\n  gWSLock: TObject = nil;\n\nfunction GetDataSetOrObjectListCount(const aValue: TValue; const aParameters: TArray<string>): TValue;\nvar\n  lWrappedList: IMVCList;\nbegin\n  if aValue.IsEmpty or  (not aValue.IsObject) then\n  begin\n    Result := False;\n  end;\n\n  if Length(aParameters) <> 0 then\n  begin\n    Result := '(Error: Expected 0 params, got ' + Length(aParameters).ToString + ')';\n  end;\n\n  if aValue.AsObject is TDataSet then\n  begin\n    Result := TDataSet(aValue.AsObject).RecordCount;\n  end\n  else if aValue.AsObject is TJsonArray then\n  begin\n    Result := TJsonArray(aValue.AsObject).Count;\n  end\n  else if aValue.AsObject is TJsonObject then\n  begin\n    Result := TJsonObject(aValue.AsObject).Count;\n  end\n  else\n  begin\n    if (aValue.AsObject <> nil) and TDuckTypedList.CanBeWrappedAsList(aValue.AsObject, lWrappedList) then\n    begin\n      Result := lWrappedList.Count;\n    end\n    else\n    begin\n      Result := False;\n    end;\n  end;\nend;\n\nfunction DumpAsJSONString(const aValue: TValue; const aParameters: TArray<string>): TValue;\nvar\n  lWrappedList: IMVCList;\nbegin\n  if not aValue.IsObject then\n  begin\n    Result := '(Error: Cannot serialize non-object as JSON)';\n  end;\n\n  if TDuckTypedList.CanBeWrappedAsList(aValue.AsObject, lWrappedList) then\n  begin\n    Result := GetDefaultSerializer.SerializeCollection(lWrappedList)\n  end\n  else\n  begin\n    if aValue.AsObject is TDataSet then\n      Result := GetDefaultSerializer.SerializeDataSet(TDataSet(aValue.AsObject))\n    else\n      Result := GetDefaultSerializer.SerializeObject(aValue.AsObject);\n  end;\nend;\n\n\nfunction MakeMethodJSON: IInvokable;\nbegin\n  Result :=\n    MakeInvokable(function(Args: TArray<IValue>): IValue\n    begin\n      Result := TValueWrapper.Create(DumpAsJSONString(Args[0].GetValue.AsObject, []));\n    end);\nend;\n\nprocedure TMVCWebStencilsViewEngine.OnGetFile(Sender: TObject; const AFilename: string; var AText: string; var AHandled: Boolean);\nvar\n  lFName: String;\nbegin\n  AHandled := False;\n  if TPath.IsRelativePath(AFilename) then\n  begin\n    lFName := TPath.Combine(FViewPath, AFilename);\n    lFName := TPath.ChangeExtension(lfname, FDefaultViewFileExtension);\n    lFName := TPath.Combine(AppPath, lfname);\n    AText := TFile.ReadAllText(lfname);\n    AHandled := True;\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.OnGetValue(Sender: TObject; const AObjectName, APropName: string; var AReplaceText: string; var AHandled: Boolean);\nvar\n  lValue: TValue;\nbegin\n  AHandled := False;\n  if (ViewModel <> nil) and ViewModel.TryGetValue(AObjectName, lValue) then\n  begin\n    AReplaceText := GetTValueVarAsString(lValue, AObjectName, TWebStencilsProcessor(Sender));\n    AHandled := True;\n  end\n  else\n  begin\n    AReplaceText := '';\n    AHandled := True;\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.RegisterWSFunctions(WSProcessor: TWebStencilsProcessor);\nbegin\n  if gFunctionInitialized then Exit;\n  TMonitor.Enter(gWSLock);\n  try\n    if gFunctionInitialized then Exit;\n    gFunctionInitialized := True;\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EMVCSSVException.Create(500, 'Expected 1 parameter in \"JSON\" function, got ' + Length(Args).ToString);\n        end;\n        Result := TValueWrapper.Create(DumpAsJSONString(Args[0].GetValue.AsObject, []));\n      end) as IInvokable,\n      'json', 'json', '', True, 'Serialize an object to JSON', nil));\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EWebStencilsException.Create('Expected 1 parameter, got ' + Length(Args).ToString);\n        end;\n        Result := TValueWrapper.Create(TMVCWebStencilsViewEngine.GetTValueVarAsString(Args[0].GetValue, '', nil));\n      end),\n      'ValueOf', 'ValueOf', '', True, 'ValueOf returns the inner value of a nullable as string - the non-nullable types are returned as-is', nil));\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EWebStencilsException.Create('Expected 1 parameter, got ' + Length(Args).ToString);\n        end;\n        if (ViewModel <> nil) and ViewModel.ContainsKey(Args[0].GetValue.AsString) then\n          Result := TValueWrapper.Create(True)\n        else\n          Result := TValueWrapper.Create(False);\n      end),\n      'Defined', 'Defined', '', True, 'Defined returns true if variable is defined', nil));\n\n\n  finally\n    TMonitor.Exit(gWSLock);\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.Execute(const ViewName: string; const Builder: TStringBuilder);\nvar\n  lViewFileName: string;\n  lWebStencilsProcessor: TWebStencilsProcessor;\n  lPair: TPair<String, TValue>;\nbegin\n  lViewFileName := GetRealFileName(ViewName);\n  if lViewFileName.IsEmpty then\n    raise EMVCSSVException.CreateFmt('View [%s] not found', [ViewName]);\n\n  lWebStencilsProcessor := TWebStencilsProcessor.Create(nil);\n  try\n    RegisterWSFunctions(lWebStencilsProcessor);\n    try\n      if Assigned(TMVCWebStencilsConfiguration.fOnProcessorConfiguration) then\n      begin\n        TMVCWebStencilsConfiguration.OnProcessorConfiguration(lWebStencilsProcessor);\n      end;\n      lWebStencilsProcessor.OnValue := OnGetValue;\n      lWebStencilsProcessor.InputFileName := lViewFileName;\n      lWebStencilsProcessor.PathTemplate := Config[TMVCConfigKey.ViewPath];\n      lWebStencilsProcessor.WebRequest := WebContext.Request.RawWebRequest;\n      lWebStencilsProcessor.OnFile := OnGetFile;\n\n      if Assigned(ViewModel) then\n      begin\n        for lPair in ViewModel do\n        begin\n          if ViewModel[lPair.Key].IsObject then\n            lWebStencilsProcessor.AddVar(lPair.Key, ViewModel[lPair.Key].AsObject, False);\n        end;\n      end;\n      if Assigned(WebContext.LoggedUser) then\n      begin\n        lWebStencilsProcessor.UserLoggedIn := True;\n        lWebStencilsProcessor.UserRoles := WebContext.LoggedUser.Roles.ToString;\n      end;\n      if Assigned(FBeforeRenderCallback) then\n      begin\n        FBeforeRenderCallback(lWebStencilsProcessor);\n      end;\n      Builder.Append(lWebStencilsProcessor.Content);\n    except\n      on E: EWebStencilsException do\n      begin\n        raise EMVCViewError.CreateFmt('View [%s] error: %s (%s)',\n          [ViewName, E.Message, E.ClassName]);\n      end;\n    end;\n  finally\n    lWebStencilsProcessor.Free;\n  end;\nend;\n\nclass function TMVCWebStencilsViewEngine.GetTValueVarAsString(const Value: TValue; const VarName: string; const Processor: TWebStencilsProcessor): String;\nvar\n  lIsObject: Boolean;\n  lAsObject: TObject;\n  lNullableInt32: NullableInt32;\n  lNullableUInt32: NullableUInt32;\n  lNullableInt16: NullableInt16;\n  lNullableUInt16: NullableUInt16;\n  lNullableInt64: NullableInt64;\n  lNullableUInt64: NullableUInt64;\n  lNullableCurrency: NullableCurrency;\n  lNullableBoolean: NullableBoolean;\n  lNullableTDate: NullableTDate;\n  lNullableTTime: NullableTTime;\n  lNullableTDateTime: NullableTDateTime;\nbegin\n  if Value.IsEmpty then\n  begin\n    Exit('');\n  end;\n\n  lIsObject := False;\n  lAsObject := nil;\n  if Value.IsObject then\n  begin\n    lIsObject := True;\n    lAsObject := Value.AsObject;\n  end;\n\n  if lIsObject then\n  begin\n    if lAsObject is TField then\n      Result := TField(Value.AsObject).AsString\n    else if lAsObject is TJsonBaseObject then\n      Result := TJsonBaseObject(lAsObject).ToJSON()\n    else\n      Result := lAsObject.ToString;\n  end\n  else\n  begin\n    if Value.TypeInfo.Kind = tkRecord then\n    begin\n      Result := '';\n      if Value.TypeInfo = TypeInfo(NullableInt32) then\n      begin\n        lNullableInt32 := Value.AsType<NullableInt32>;\n        if lNullableInt32.HasValue then\n          Result := lNullableInt32.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt32) then\n      begin\n        lNullableUInt32 := Value.AsType<NullableUInt32>;\n        if lNullableUInt32.HasValue then\n          Result := lNullableUInt32.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableInt16) then\n      begin\n        lNullableInt16 := Value.AsType<NullableInt16>;\n        if lNullableInt16.HasValue then\n          Result := lNullableInt16.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt16) then\n      begin\n        lNullableUInt16 := Value.AsType<NullableUInt16>;\n        if lNullableUInt16.HasValue then\n          Result := lNullableUInt16.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableInt64) then\n      begin\n        lNullableInt64 := Value.AsType<NullableInt64>;\n        if lNullableInt64.HasValue then\n          Result := lNullableInt64.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt64) then\n      begin\n        lNullableUInt64 := Value.AsType<NullableUInt64>;\n        if lNullableUInt64.HasValue then\n          Result := lNullableUInt64.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableString) then\n      begin\n        Result := Value.AsType<NullableString>.ValueOrDefault;\n      end\n      else if Value.TypeInfo = TypeInfo(NullableCurrency) then\n      begin\n        lNullableCurrency := Value.AsType<NullableCurrency>;\n        if lNullableCurrency.HasValue then\n          Result := FloatToStr(lNullableCurrency.Value);\n          //Result := FloatToStr(lNullableCurrency.Value, fLocaleFormatSettings);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableBoolean) then\n      begin\n        lNullableBoolean := Value.AsType<NullableBoolean>;\n        if lNullableBoolean.HasValue then\n          Result := BoolToStr(lNullableBoolean.Value, True);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTDate) then\n      begin\n        lNullableTDate := Value.AsType<NullableTDate>;\n        if lNullableTDate.HasValue then\n          Result := DateToISO8601(lNullableTDate.Value);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTTime) then\n      begin\n        lNullableTTime := Value.AsType<NullableTTime>;\n        if lNullableTTime.HasValue then\n          Result := DateToISO8601(lNullableTTime.Value);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTDateTime) then\n      begin\n        lNullableTDateTime := Value.AsType<NullableTDateTime>;\n        if lNullableTDateTime.HasValue then\n          Result := DateToISO8601(lNullableTDateTime.Value);\n      end\n      else\n      begin\n        raise EWebStencilsException.Create('Unsupported type for variable \"' + VarName + '\"');\n      end;\n    end\n    else\n    begin\n      case Value.Kind of\n        tkInteger: Result := Value.AsInteger.ToString;\n        tkInt64: Result := Value.AsInt64.ToString;\n        tkString, tkUString, tkWString, tkLString: Result := Value.AsString;\n        tkWChar, tkChar: Result := Value.AsType<Char>;\n        tkFloat: begin\n          if Value.TypeInfo.Name = 'TDate' then\n          begin\n            //Result := DateToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := DateToStr(Value.AsExtended);\n          end\n          else if Value.TypeInfo.Name = 'TDateTime' then\n          begin\n            //Result := DateTimeToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := DateTimeToStr(Value.AsExtended);\n          end\n          else\n          begin\n            //Result := FloatToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := FloatToStr(Value.AsExtended);\n          end;\n        end;\n        tkEnumeration: Result := Value.ToString.ToLower;\n        else\n          raise EWebStencilsException.Create('Unsupported type for variable \"' + VarName + '\"');\n      end;\n    end;\n  end;\n\nend;\n\n\ninitialization\n\ngWSLock := TObject.Create;\n\nfinalization\n\nFreeAndNil(gWSLock);\n\n{$endif}\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.Defaults;\nusing System.Linq;\n\nnamespace MVCFramework.View.Renderers\n{\n    #region Dummy/Placeholder Types\n\n    public abstract class MVCBaseViewEngine\n    {\n        protected MVCEngine Engine { get; }\n        protected TWebContext WebContext { get; }\n        protected MVCController Controller { get; }\n        protected MVCViewDataObject ViewModel { get; }\n        protected string ContentType { get; }\n        protected IDictionary<string, string> Config { get; } \n        protected Action<TWebStencilsProcessor> BeforeRenderCallback { get; set; }\n\n        protected MVCBaseViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller, MVCViewDataObject viewModel, string contentType)\n        {\n            Engine = engine;\n            WebContext = webContext;\n            Controller = controller;\n            ViewModel = viewModel;\n            ContentType = contentType;\n            Config = engine.Config;\n        }\n\n        public abstract void Execute(string viewName, StringBuilder builder);\n\n        protected virtual string GetRealFileName(string viewName)\n        {\n            string viewPath = Config.ContainsKey(\"ViewPath\") ? Config[\"ViewPath\"] : \"Views\";\n            string extension = Config.ContainsKey(\"DefaultViewFileExtension\") ? Config[\"DefaultViewFileExtension\"] : \"html\";\n            string fullPath = Path.Combine(AppPath, viewPath, $\"{viewName}.{extension}\");\n            return File.Exists(fullPath) ? fullPath : string.Empty;\n        }\n\n        protected string AppPath => AppDomain.CurrentDomain.BaseDirectory;\n    }\n\n    public class MVCEngine\n    {\n        public IDictionary<string, string> Config { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n        {\n            { \"ViewPath\", \"Views\" },\n            { \"DefaultViewFileExtension\", \"html\" },\n            { \"ViewCache\", \"true\" }\n        };\n    }\n\n    public class TWebContext\n    {\n        public TWebRequest Request { get; set; }\n        public TWebResponse Response { get; set; }\n        public MVCLoggedUser LoggedUser { get; set; }\n    }\n\n    public class TWebRequest\n    {\n        public object RawWebRequest { get; set; }\n    }\n\n    public class TWebResponse { }\n\n    public class MVCController { }\n\n    public class MVCViewDataObject : Dictionary<string, TValue> { }\n\n    public interface IMVCSerializer\n    {\n        string SerializeObject(object obj);\n        string SerializeCollection(object collection);\n    }\n\n    public static class MVCSerializerDefaults\n    {\n        public static IMVCSerializer GetDefaultSerializer() => new MVCJsonDataObjectsSerializer();\n    }\n\n    public class MVCJsonDataObjectsSerializer : IMVCSerializer\n    {\n        public string SerializeObject(object obj)\n        {\n            return Newtonsoft.Json.JsonConvert.SerializeObject(obj);\n        }\n        public string SerializeCollection(object collection)\n        {\n            return SerializeObject(collection);\n        }\n    }\n\n    public class TWebStencilsProcessor : IDisposable\n    {\n        public string InputFileName { get; set; }\n        public string PathTemplate { get; set; }\n        public object WebRequest { get; set; }\n        public bool UserLoggedIn { get; set; }\n        public string UserRoles { get; set; }\n        public event Action<object, string, ref string, ref bool> OnValue;\n        public event Action<object, string, ref string, ref bool> OnFile;\n\n        public string Content\n        {\n            get\n            {\n                return File.ReadAllText(InputFileName);\n            }\n        }\n\n        public void AddVar(string key, object value, bool flag)\n        {\n            // Implementation to add variable into the processor's model.\n        }\n\n        public void Dispose()\n        {\n            // Dispose resources if necessary.\n        }\n    }\n\n    public static class WebStencilsGlobalFunctions\n    {\n        public static bool Initialized { get; set; } = false;\n        public static readonly object LockObject = new object();\n\n        public static void RegisterMethod(string name, Func<IValue[], IValue> invokable, string description)\n        {\n            // Implementation for binding method registration.\n        }\n    }\n\n    public interface IValue\n    {\n        TValue GetValue();\n    }\n\n    public struct TValue\n    {\n        private object _value;\n        public TValue(object value) { _value = value; }\n        public bool IsEmpty => _value == null;\n        public bool IsObject => _value != null;\n        public object AsObject => _value;\n        public int AsInteger => Convert.ToInt32(_value);\n        public long AsInt64 => Convert.ToInt64(_value);\n        public double AsDouble => Convert.ToDouble(_value);\n        public string AsString => Convert.ToString(_value);\n        public bool AsBoolean => Convert.ToBoolean(_value);\n        public static implicit operator TValue(int value) => new TValue(value);\n        public static implicit operator TValue(string value) => new TValue(value);\n    }\n\n    public class TValueWrapper : IValue\n    {\n        private TValue _value;\n        public TValueWrapper(object value) { _value = new TValue(value); }\n        public TValue GetValue() => _value;\n    }\n\n    #endregion\n\n    #region MVCWebStencilsViewEngine\n\n    public class MVCWebStencilsViewEngine : MVCBaseViewEngine\n    {\n        private bool modelPrepared = false;\n        private string jsonModelAsString = \"\";\n        private static TSynMustachePartials partials;\n        private static TSynMustacheHelpers helpers;\n        private static readonly object globalLock = new object();\n        private static bool gPartialsLoaded = false;\n        private static bool gHelpersLoaded = false;\n\n        public MVCWebStencilsViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller,\n            MVCViewDataObject viewModel, string contentType)\n            : base(engine, webContext, controller, viewModel, contentType)\n        {\n            LoadPartials();\n            LoadHelpers();\n        }\n\n        \n        public void OnGetValue(object sender, string objectName, string propName, ref string replaceText, ref bool handled)\n        {\n            if (ViewModel != null && ViewModel.TryGetValue(objectName, out TValue value))\n            {\n                replaceText = GetTValueVarAsString(value, objectName, sender as TWebStencilsProcessor);\n                handled = true;\n            }\n            else\n            {\n                replaceText = \"\";\n                handled = true;\n            }\n        }\n\n        \n        public void OnGetFile(object sender, string filename, ref string text, ref bool handled)\n        {\n            if (!Path.IsPathRooted(filename))\n            {\n                string fullFileName = Path.Combine(Config[\"ViewPath\"], filename);\n                fullFileName = Path.ChangeExtension(fullFileName, Config[\"DefaultViewFileExtension\"]);\n                fullFileName = Path.Combine(AppPath, fullFileName);\n                text = File.ReadAllText(fullFileName);\n                handled = true;\n            }\n        }\n\n        \n        public static string GetTValueVarAsString(TValue value, string varName, TWebStencilsProcessor processor)\n        {\n            if (value.IsEmpty)\n                return \"\";\n            if (value.IsObject)\n            {\n                object obj = value.AsObject;\n                if (obj is System.Data.DataRowView) \n                    return obj.ToString();\n                else if (obj is JsonObject)\n                    return ((JsonObject)obj).ToJSON();\n                else\n                    return obj.ToString();\n            }\n            else\n            {\n                \n                if (value.AsObject is int)\n                    return value.AsInteger.ToString();\n                if (value.AsObject is long)\n                    return value.AsInt64.ToString();\n                if (value.AsObject is double)\n                    return value.AsDouble.ToString();\n                if (value.AsObject is bool)\n                    return value.AsBoolean.ToString().ToLower();\n                if (value.AsObject is string)\n                    return value.AsString;\n                throw new Exception($\"Unsupported type for variable \\\"{varName}\\\"\");\n            }\n        }\n\n        \n        private void RegisterWSFunctions(TWebStencilsProcessor processor)\n        {\n            if (WebStencilsGlobalFunctions.Initialized)\n                return;\n            lock (globalLock)\n            {\n                if (!WebStencilsGlobalFunctions.Initialized)\n                {\n                    WebStencilsGlobalFunctions.RegisterMethod(\"json\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'json' function\");\n                            object obj = args[0].GetValue().AsObject;\n                            return new TValueWrapper(GetDefaultSerializer().SerializeObject(obj));\n                        },\n                        \"Serialize an object to JSON\");\n\n                    WebStencilsGlobalFunctions.RegisterMethod(\"ValueOf\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'ValueOf' function\");\n                            return new TValueWrapper(GetTValueVarAsString(args[0].GetValue(), \"\", null));\n                        },\n                        \"Returns inner value of a nullable as string\");\n\n                    WebStencilsGlobalFunctions.RegisterMethod(\"Defined\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'Defined' function\");\n                            bool exists = (ViewModel != null && ViewModel.ContainsKey(args[0].GetValue().AsString));\n                            return new TValueWrapper(exists);\n                        },\n                        \"Returns true if variable is defined\");\n\n                    WebStencilsGlobalFunctions.Initialized = true;\n                }\n            }\n        }\n\n        private void LoadPartials()\n        {\n            if (gPartialsLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gPartialsLoaded)\n                {\n                    string viewsExtension = Config[\"DefaultViewFileExtension\"];\n                    string viewPath = Config[\"ViewPath\"];\n                    string[] files = Directory.GetFiles(viewPath, \"*.\" + viewsExtension, SearchOption.AllDirectories);\n                    partials?.Dispose();\n                    partials = new TSynMustachePartials();\n                    foreach (string file in files)\n                    {\n                        string partialName = file.Substring(0, file.Length - (viewsExtension.Length + 1))\n                            .Replace(Path.DirectorySeparatorChar, '/');\n                        partialName = partialName.Substring(viewPath.Length + 1);\n                        string content = File.ReadAllText(file);\n                        partials.Add(partialName, content);\n                    }\n                    gPartialsLoaded = string.Equals(Config[\"ViewCache\"], \"true\", StringComparison.OrdinalIgnoreCase);\n                }\n            }\n        }\n\n        private void LoadHelpers()\n        {\n            if (gHelpersLoaded)\n                return;\n            lock (globalLock)\n            {\n                if (!gHelpersLoaded)\n                {\n                    helpers = TSynMustache.HelpersGetStandardList();\n                    MVCWebStencilsHelpers.RegisterHandlers(ref helpers);\n                    gHelpersLoaded = true;\n                }\n            }\n        }\n\n        private void PrepareModels()\n        {\n            if (modelPrepared)\n                return;\n\n            IMVCSerializer serializer = serializerPool.GetFromPool(true) as IMVCSerializer;\n            try\n            {\n                var jsonModel = new JsonObject();\n                if (ViewModel != null)\n                {\n                    foreach (var pair in ViewModel)\n                    {\n                        ((MVCJsonDataObjectsSerializer)serializer).TValueToJSONObjectProperty(jsonModel, pair.Key, pair.Value,\n                            TMVCSerializationType.stDefault, null, null);\n                    }\n                }\n                jsonModelAsString = jsonModel.ToJSON();\n            }\n            finally\n            {\n                serializerPool.ReleaseToPool(serializer);\n            }\n            modelPrepared = true;\n        }\n    }\n\n    #endregion\n\n    #region MVCWebStencilsHelpers\n\n    public static class MVCWebStencilsHelpers\n    {\n        public delegate void LoadCustomHelpersProc(ref TSynMustacheHelpers mustacheHelpers);\n        private static LoadCustomHelpersProc onLoadCustomHelpers;\n        public static LoadCustomHelpersProc OnLoadCustomHelpers\n        {\n            get => onLoadCustomHelpers;\n            set => onLoadCustomHelpers = value;\n        }\n\n        public static void RegisterHandlers(ref TSynMustacheHelpers mustacheHelpers)\n        {\n            TSynMustache.HelperAdd(mustacheHelpers, \"UpperCase\", new TSynMustacheHelperDelegate(ToUpperCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"LowerCase\", new TSynMustacheHelperDelegate(ToLowerCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"Capitalize\", new TSynMustacheHelperDelegate(Capitalize));\n            TSynMustache.HelperAdd(mustacheHelpers, \"SnakeCase\", new TSynMustacheHelperDelegate(SnakeCase));\n            onLoadCustomHelpers?.Invoke(ref mustacheHelpers);\n        }\n\n        public static void ToLowerCase(object value, out object result)\n        {\n            result = value?.ToString().ToLower();\n        }\n\n        public static void ToUpperCase(object value, out object result)\n        {\n            result = value?.ToString().ToUpper();\n        }\n\n        public static void Capitalize(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (!string.IsNullOrEmpty(s))\n                result = char.ToUpper(s[0]) + s.Substring(1).ToLower();\n            else\n                result = s;\n        }\n\n        public static void SnakeCase(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (string.IsNullOrEmpty(s))\n            {\n                result = s;\n                return;\n            }\n            var sb = new StringBuilder();\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (char.IsUpper(s[i]))\n                {\n                    if (i > 0)\n                        sb.Append('_');\n                    sb.Append(char.ToLower(s[i]));\n                }\n                else\n                {\n                    sb.Append(s[i]);\n                }\n            }\n            result = sb.ToString();\n        }\n    }\n\n    #endregion\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\u00fcller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomTypesU;\n\ninterface\n\nuses\n  System.Generics.Defaults, System.Generics.Collections;\n\ntype\n  // custom serialization is by-type so we define a type alias\n  // useful to identify all the fields that must be serialized\n  // using the custom serializer defined for this type\n  TUserRoles = TArray<string>;\n\n  TNullableRecord<T> = record\n    Value: T;\n    HasValue: Boolean;\n  end;\n\n  TNullableRecordAlias = TNullableRecord<string>;\n\n  // This is the main object which uses the\n  // custom serialized type as property Roles\n  TSysUser = class\n  private\n    fUserName: string;\n    fRoles: TUserRoles;\n    fRecordAlias: TNullableRecordAlias;\n    procedure SetUserName(const Value: string);\n    function GetUserRoles: TUserRoles;\n  public\n    constructor Create(aUserName: string; aRoles: TUserRoles);\n    property UserName: string read FUserName write SetUserName;\n    // Here we are using the custom-serialized type TUserRoles\n    property Roles: TUserRoles read GetUserRoles;\n    property RecordAlias: TNullableRecordAlias read fRecordAlias write fRecordAlias;\n  end;\n\n  TSysUser2 = class\n  private\n    FUserName: string;\n    fRoles: TUserRoles;\n    fRecordAlias: TNullableRecordAlias;\n  public\n    constructor Create(aUserName: string; aRoles: TUserRoles);\n    property UserName: string read FUserName write FUserName;\n    // Here we are using the custom-serialized type TUserRoles\n    property Roles: TUserRoles read fRoles write fRoles;\n  end;\n\n\n  TArrayTest = class\n  private\n    fStrings: TArray<string>;\n    fIntegers: TArray<Integer>;\n    fDoubles: TArray<Double>;\n    fEmptyIntegers: TArray<Integer>;\n    fNilArrayOfIntegers: TArray<Integer>;\n  public\n    constructor Create;\n    property Integers: TArray<Integer> read fIntegers write fIntegers;\n    property Strings: TArray<string> read fStrings write fStrings;\n    property Doubles: TArray<Double> read fDoubles write fDoubles;\n    property EmptyIntegers: TArray<Integer> read fEmptyIntegers write fEmptyIntegers;\n    property NilArrayOfIntegers: TArray<Integer> read fNilArrayOfIntegers write fNilArrayOfIntegers;\n  end;\n\n  TSimpleListTest = class\n  private\n    fDoubles: TList<Double>;\n    fStrings: TList<string>;\n    fIntegers: TList<Integer>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    property Integers: TList<Integer> read fIntegers;\n    property Strings: TList<string> read fStrings;\n    property Doubles: TList<Double> read fDoubles;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, System.Math;\n\n{ TSysUser }\n\nconstructor TSysUser.Create(aUserName: string; aRoles: TUserRoles);\nbegin\n  inherited Create;\n  FUserName := aUserName;\n  FRoles := aRoles;\nend;\n\nfunction TSysUser.GetUserRoles: TUserRoles;\nbegin\n  Result := FRoles;\nend;\n\nprocedure TSysUser.SetUserName(const Value: string);\nbegin\n  FUserName := Value;\nend;\n\n{ TArrayTest }\n\nconstructor TArrayTest.Create;\nvar\n  I: Integer;\nbegin\n  inherited;\n  fNilArrayOfIntegers := nil;\n  SetLength(fEmptyIntegers, 0);\n  SetLength(fStrings, 5);\n  for I := 0 to Length(fStrings) - 1 do\n  begin\n    fStrings[I] := 'Value ' + I.ToString;\n  end;\n  SetLength(fIntegers, 5);\n  for I := 0 to Length(fIntegers) - 1 do\n  begin\n    fIntegers[I] := I;\n  end;\n  SetLength(fDoubles, 5);\n  for I := 0 to Length(fDoubles) - 1 do\n  begin\n    fDoubles[I] := Power(I, I) * 1.1;\n  end;\nend;\n\n{ TSimpleListTest }\n\nconstructor TSimpleListTest.Create;\nbegin\n  inherited;\n  fIntegers := TList<Integer>.Create();\n  fIntegers.AddRange([1, 2, 3, 4, 5]);\n  fStrings := TList<string>.Create();\n  fStrings.AddRange(['good', 'bye', 'cruel', 'world']);\n  fDoubles := TList<Double>.Create();\n  fDoubles.AddRange([1.2, 2.3, 3.4, 4.5, 5.6]);\nend;\n\ndestructor TSimpleListTest.Destroy;\nbegin\n  fIntegers.Free;\n  fStrings.Free;\n  fDoubles.Free;\n  inherited;\nend;\n\n{ TSysUser2 }\n\nconstructor TSysUser2.Create(aUserName: string; aRoles: TUserRoles);\nbegin\n  inherited Create;\n  FUserName := aUserName;\n  fRoles := aRoles;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\n\nnamespace CustomTypesU\n{\n    public class MVCSerializationException : Exception\n    {\n        public MVCSerializationException(string message) : base(message) { }\n    }\n\n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes);\n    }\n\n    public class TUserRolesSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            JArray jArray = jObj[propertyName] as JArray;\n            if (jArray == null)\n            {\n                jArray = new JArray();\n                jObj[propertyName] = jArray;\n            }\n\n            jArray.Add(\"--begin--\");\n\n            if (elementValue is IEnumerable<string> roles)\n            {\n                foreach (var role in roles)\n                    jArray.Add(role);\n            }\n            else if (elementValue is string[] rolesArray)\n            {\n                foreach (var role in rolesArray)\n                    jArray.Add(role);\n            }\n\n            jArray.Add(\"--end--\");\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"To implement\");\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TSysUserSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            jObj[\"prop\"] = \"hello there attribute\";\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            JObject jObj = new JObject();\n            serializerObject = jObj;\n\n            if (!(obj is TSysUser user))\n                throw new Exception(\"obj is not of type TSysUser.\");\n\n            jObj[\"username\"] = user.UserName;\n            jObj[\"roles\"] = string.Join(\",\", user.Roles);\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TNullableAliasSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(object elementValue, ref object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"TODO\");\n        }\n\n        public void Deserialize(object serializedObject, ref object elementValue, Attribute[] attributes)\n        {\n            // No implementation.\n        }\n\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n    }\n\n    public class TSysUser\n    {\n        public string UserName { get; set; }\n        public List<string> Roles { get; set; }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit Person;\n\ninterface\n\ntype\n\n  TPerson = class\n  private\n    FId: Int64;\n    FName: string;\n    FAddress: string;\n    FBirthday: TDate;\n  public\n    property Id: Int64 read FId write FId;\n    property Name: string read FName write FName;\n    property Address: string read FAddress write FAddress;\n    property Birthday: TDate read FBirthday write FBirthday;\n  end;\n\nimplementation\n\nend.", "output": "namespace MyApp { public class Person { public long Id { get; set; } \n    public string Name { get; set; } \n    public string Address { get; set; } \n    public System.DateTime Birthday { get; set; } \n    \n    } \n}"}
{"input": "unit StatusesServiceU;\n\ninterface\n\nuses BaseServiceU, MainDMU, EntitiesU;\n\ntype\n  TStatusService = class(TBaseService)\n  private\n    fModule: TdmMain;\n\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure PersistStatus(aStatus: TNotificationEntity);\n    function GetCurrentStatus: TCurrentStatusEntity;\n    function GetLastPersistedStatus: TFullStatusEntity;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Commons, MVCFramework.Serializer.Commons,\n  Data.DB;\n\n{ TStatusService }\n\nconstructor TStatusService.Create;\nbegin\n  inherited;\n  fModule := TdmMain.Create(nil);\nend;\n\ndestructor TStatusService.Destroy;\nbegin\n  fModule.Free;\n  inherited;\nend;\n\nfunction TStatusService.GetCurrentStatus: TCurrentStatusEntity;\nvar\n  lInitializer: TFunc<TFullStatusEntity>;\nbegin\n  lInitializer := function: TFullStatusEntity\n    begin\n      Result := Self.GetLastPersistedStatus;\n      // Result := fModule.Connection.ExecSQLScalar\n      // ('SELECT\tTOP 1 CS.idStato FROM CambiStato CS ORDER BY CS.idRecord DESC');\n    end;\n  Result := TCurrentStatusEntity.GetInstance(lInitializer);\nend;\n\nfunction TStatusService.GetLastPersistedStatus: TFullStatusEntity;\nvar\n  lDataSet: TDataSet;\nbegin\n  fModule.Connection.ExecSQL('select id, value, created_at from notifications order by id desc limit 1', lDataSet);\n  try\n    Result := TFullStatusEntity.Create;\n    if lDataSet.Eof then\n    begin\n      Result.Id := -1;\n      Result.Value := '';\n      Result.PushedAt := '';\n    end\n    else\n    begin\n      Result := TFullStatusEntity.Create;\n      Result.Id := lDataSet.FieldByName('id').AsInteger;\n      Result.Value := lDataSet.FieldByName('value').AsString;\n      Result.PushedAt := lDataSet.FieldByName('created_at').AsString;\n    end;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\nprocedure TStatusService.PersistStatus(aStatus: TNotificationEntity);\nbegin\n  fModule.qryInsertNotification.ExecSQL('', [aStatus.Value]);\n  TCurrentStatusEntity.GetInstance.SetStatus(GetLastPersistedStatus);\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing MVCFramework.Commons;\nusing MainDMU;\nusing EntitiesU;\n\nnamespace YourNamespace\n{\n    public class StatusService : BaseService, IDisposable\n    {\n        private dmMain _module;\n\n        public StatusService() : base()\n        {\n            _module = new dmMain();\n        }\n\n        public void PersistStatus(NotificationEntity aStatus)\n        {\n            _module.qryInsertNotification.ExecSQL(\"\", new object[] { aStatus.Value });\n            CurrentStatusEntity.GetInstance(() => GetLastPersistedStatus()).SetStatus(GetLastPersistedStatus());\n        }\n\n        public CurrentStatusEntity GetCurrentStatus()\n        {\n            return CurrentStatusEntity.GetInstance(() => GetLastPersistedStatus());\n        }\n\n        public FullStatusEntity GetLastPersistedStatus()\n        {\n            DataSet ds;\n            _module.Connection.ExecSQL(\"select id, value, created_at from notifications order by id desc limit 1\", out ds);\n            FullStatusEntity result = new FullStatusEntity();\n            if (ds.Tables.Count == 0 || ds.Tables[0].Rows.Count == 0)\n            {\n                result.Id = -1;\n                result.Value = \"\";\n                result.PushedAt = \"\";\n            }\n            else\n            {\n                DataRow row = ds.Tables[0].Rows[0];\n                result.Id = Convert.ToInt32(row[\"id\"]);\n                result.Value = row[\"value\"].ToString();\n                result.PushedAt = row[\"created_at\"].ToString();\n            }\n            ds.Dispose();\n            return result;\n        }\n\n        public void Dispose()\n        {\n            if (_module != null)\n            {\n                _module.Dispose();\n                _module = null;\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MyObjectU;\n\ninterface\n\nuses\n  JsonDataObjects,\n  System.Generics.Collections,\n  Data.DB,\n  BusinessObjectsU,\n  FireDAC.Comp.Client,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.Commons, MVCFramework,\n  MVCFramework.JSONRPC, CommonTypesU;\n\ntype\n\n  TMyObject = class\n  private\n    function GetCustomersDataset: TFDMemTable;\n    procedure FillCustomersDataset(const DataSet: TDataSet);\n    procedure FillPeopleDataset(const DataSet: TDataSet);\n  public\n    procedure OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJDOJsonObject);\n    procedure OnBeforeCallHook(const Context: TWebContext; const JSONRequest: TJDOJsonObject);\n    procedure OnAfterCallHook(const Context: TWebContext; const JSONResponse: TJDOJsonObject);\n  public\n    [MVCDoc('You know, returns aValue1 - aValue2')]\n    [MVCJSONRPCAllowGET]\n    function Subtract(Value1, Value2: Integer): Integer;\n    [MVCDoc('Returns the revers of the string passed as input')]\n    function ReverseString(const aString: string; const aUpperCase: Boolean): string;\n    [MVCDoc('Returns the next monday starting from aDate')]\n    function GetNextMonday(const aDate: TDate): TDate;\n    function PlayWithDatesAndTimes(const aJustAFloat: Double; const aTime: TTime;\n      const aDate: TDate; const aDateAndTime: TDateTime): TDateTime;\n    [MVCJSONRPCAllowGET]\n    function GetCustomers(FilterString: string): TDataSet;\n    [MVCJSONRPCAllowGET]\n    function GetMulti: TMultiDataset;\n    [MVCJSONRPCAllowGET]\n    function GetStringDictionary: TMVCStringDictionary;\n    function GetUser(aUserName: string): TPerson;\n    function SavePerson(const Person: TPerson): Integer;\n    function FloatsTest(const aDouble: Double; const aExtended: Extended): Extended;\n    procedure DoSomething;\n    procedure RaiseCustomException;\n    function RaiseGenericException(const ExceptionType: Integer): Integer;\n    function SaveObjectWithJSON(const WithJSON: TJsonObject): TJsonObject;\n\n    //enums and sets support\n    function PassingEnums(Value1: TEnumTest; Value2: TEnumTest): TEnumTest;\n    function GetSetBySet(Value: TSetTest): TSetTest;\n\n    //records support\n    function SavePersonRec(PersonRec: TTestRec): TTestRec;\n    function GetPeopleRecDynArray: TTestRecDynArray;\n    function GetPeopleRecStaticArray: TTestRecArray;\n    function GetPersonRec: TTestRec;\n    function GetComplex1: TNestedArraysRec;\n    function EchoComplexArrayOfRecords(PeopleList: TTestRecDynArray): TTestRecDynArray;\n    function EchoComplexArrayOfRecords2(VendorProxiesAndLinks: TNestedArraysRec): TNestedArraysRec;\n\n    // invalid parameters modifiers\n    procedure InvalidMethod1(var MyVarParam: Integer);\n    procedure InvalidMethod2(out MyOutParam: Integer);\n\n  end;\n\n  TUtils = class sealed\n    class function JSONObjectAs<T: constructor, class>(const JSON: TJsonObject): T;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.Logger,\n  System.StrUtils,\n  System.DateUtils, MVCFramework.Serializer.JsonDataObjects;\n\nclass function TUtils.JSONObjectAs<T>(const JSON: TJsonObject): T;\nvar\n  lObj: TObject;\n  lSerializer: TMVCJsonDataObjectsSerializer;\nbegin\n  lObj := T.Create;\n  try\n    lSerializer := TMVCJsonDataObjectsSerializer.Create;\n    try\n      lSerializer.JsonObjectToObject(JSON, lObj, TMVCSerializationType.stProperties, []);\n    finally\n      lSerializer.Free;\n    end;\n  except\n    lObj.Free;\n    raise;\n  end;\n  Result := T(lObj);\nend;\n\n{ TMyDerivedController }\n\nprocedure TMyObject.DoSomething;\nbegin\n\nend;\n\nfunction TMyObject.PassingEnums(Value1, Value2: TEnumTest): TEnumTest;\nbegin\n  if Value1 = Value2 then\n  begin\n    Result := TEnumTest.ptEnumValue4;\n  end\n  else\n  begin\n    Result := TEnumTest.ptEnumValue3;\n  end;\nend;\n\nfunction TMyObject.EchoComplexArrayOfRecords(\n  PeopleList: TTestRecDynArray): TTestRecDynArray;\nbegin\n  Result := PeopleList;\nend;\n\nfunction TMyObject.EchoComplexArrayOfRecords2(\n  VendorProxiesAndLinks: TNestedArraysRec): TNestedArraysRec;\nbegin\n  Result := VendorProxiesAndLinks;\n  Result.TestRecProp.StringProp := VendorProxiesAndLinks.TestRecProp.StringProp + ' (changed from server)';\nend;\n\nprocedure TMyObject.FillCustomersDataset(const DataSet: TDataSet);\nbegin\n  DataSet.AppendRecord([1, 'Ford']);\n  DataSet.AppendRecord([2, 'Ferrari']);\n  DataSet.AppendRecord([3, 'Lotus']);\n  DataSet.AppendRecord([4, 'FCA']);\n  DataSet.AppendRecord([5, 'Hyundai']);\n  DataSet.AppendRecord([6, 'De Tomaso']);\n  DataSet.AppendRecord([7, 'Dodge']);\n  DataSet.AppendRecord([8, 'Tesla']);\n  DataSet.AppendRecord([9, 'Kia']);\n  DataSet.AppendRecord([10, 'Tata']);\n  DataSet.AppendRecord([11, 'Volkswagen']);\n  DataSet.AppendRecord([12, 'Audi']);\n  DataSet.AppendRecord([13, 'Skoda']);\n  DataSet.First;\nend;\n\nprocedure TMyObject.FillPeopleDataset(const DataSet: TDataSet);\nbegin\n  DataSet.AppendRecord(['Daniele', 'Teti']);\n  DataSet.AppendRecord(['Peter', 'Parker']);\n  DataSet.AppendRecord(['Bruce', 'Banner']);\n  DataSet.AppendRecord(['Scott', 'Summers']);\n  DataSet.AppendRecord(['Sue', 'Storm']);\n  DataSet.First;\nend;\n\nfunction TMyObject.FloatsTest(const aDouble: Double; const aExtended: Extended): Extended;\nbegin\n  Result := aDouble + aExtended;\nend;\n\nfunction TMyObject.GetComplex1: TNestedArraysRec;\nbegin\n  SetLength(Result.ArrayProp1, 2);\n  SetLength(Result.ArrayProp2, 2);\n\n  Result.ArrayProp1[0] := TTestRec.Create(1234);\n  Result.ArrayProp1[1] := TTestRec.Create(2345);\n\n  Result.ArrayProp2[0] := TTestRec.Create(3456);\n  Result.ArrayProp2[1] := TTestRec.Create(4567);\n\nend;\n\nfunction TMyObject.GetCustomers(FilterString: string): TDataSet;\nvar\n  lMT: TFDMemTable;\nbegin\n  lMT := GetCustomersDataset;\n  try\n    if not FilterString.IsEmpty then\n    begin\n      lMT.Filter := FilterString;\n      lMT.Filtered := True;\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction TMyObject.GetCustomersDataset: TFDMemTable;\nvar\n  lMT: TFDMemTable;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('Code', ftInteger);\n    lMT.FieldDefs.Add('Name', ftString, 20);\n    lMT.Active := True;\n    lMT.AppendRecord([1, 'Ford']);\n    lMT.AppendRecord([2, 'Ferrari']);\n    lMT.AppendRecord([3, 'Lotus']);\n    lMT.AppendRecord([4, 'FCA']);\n    lMT.AppendRecord([5, 'Hyundai']);\n    lMT.AppendRecord([6, 'De Tomaso']);\n    lMT.AppendRecord([7, 'Dodge']);\n    lMT.AppendRecord([8, 'Tesla']);\n    lMT.AppendRecord([9, 'Kia']);\n    lMT.AppendRecord([10, 'Tata']);\n    lMT.AppendRecord([11, 'Volkswagen']);\n    lMT.AppendRecord([12, 'Audi']);\n    lMT.AppendRecord([13, 'Skoda']);\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction TMyObject.GetMulti: TMultiDataset;\nbegin\n  Result := TMultiDataset.Create;\n  FillCustomersDataset(Result.Customers);\n  FillPeopleDataset(Result.People);\nend;\n\nfunction TMyObject.GetNextMonday(const aDate: TDate): TDate;\nvar\n  lDate: TDate;\nbegin\n  lDate := aDate + 1;\n  while DayOfTheWeek(lDate) <> 1 do\n  begin\n    lDate := lDate + 1;\n  end;\n  Result := lDate;\nend;\n\nfunction TMyObject.GetPeopleRecDynArray: TTestRecDynArray;\nbegin\n  SetLength(Result, 2);\n  Result[0] := TTestRec.Create(1);\n  Result[1] := TTestRec.Create(2);\nend;\n\nfunction TMyObject.GetPeopleRecStaticArray: TTestRecArray;\nbegin\n  Result[0] := TTestRec.Create(7);\n  Result[1] := TTestRec.Create(8);\nend;\n\nfunction TMyObject.GetPersonRec: TTestRec;\nbegin\n  Result := TTestRec.Create(99);\nend;\n\nfunction TMyObject.GetSetBySet(Value: TSetTest): TSetTest;\nbegin\n  Result := [];\n  for var lItem := ptEnumValue1 to ptEnumValue4 do\n  begin\n    if lItem in Value then\n    begin\n      Result := Result - [lItem];\n    end\n    else\n    begin\n      Result := Result + [lItem];\n    end;\n  end;\nend;\n\nfunction TMyObject.GetStringDictionary: TMVCStringDictionary;\nbegin\n  Result := TMVCStringDictionary.Create;\n  Result.Add('key1', 'value1');\n  Result.Add('key2', 'value2');\n  Result.Add('key3', 'value3');\n  Result.Add('key4', 'value4');\nend;\n\nfunction TMyObject.GetUser(aUserName: string): TPerson;\nbegin\n  Result := TPerson.Create;\n  Result.FirstName := 'Daniele (a.k.a. ' + aUserName + ')';\n  Result.LastName := 'Teti';\n  Result.DOB := EncodeDate(1932, 11, 4); // hey, it is a joke :-)\n  Result.Married := True;\nend;\n\nprocedure TMyObject.InvalidMethod1(var MyVarParam: Integer);\nbegin\n  // do nothing\nend;\n\nprocedure TMyObject.InvalidMethod2(out MyOutParam: Integer);\nbegin\n  // do nothing\nend;\n\nfunction TMyObject.PlayWithDatesAndTimes(const aJustAFloat: Double; const aTime: TTime;\n  const aDate: TDate; const aDateAndTime: TDateTime): TDateTime;\nbegin\n  Result := aDateAndTime + aDate + aTime + TDateTime(aJustAFloat);\nend;\n\nprocedure TMyObject.RaiseCustomException;\nbegin\n  raise EMVCJSONRPCError.Create(JSONRPC_USER_ERROR + 1, 'This is an exception message');\nend;\n\nfunction TMyObject.RaiseGenericException(const ExceptionType: Integer): Integer;\nvar\n  l: Integer;\nbegin\n  case ExceptionType of\n    1:\n      begin\n        l := 0;\n        Result := 10 div l;\n      end;\n    2:\n      begin\n        raise EInvalidPointer.Create('Fake Invalid Pointer Operation');\n      end;\n    else\n    begin\n      raise Exception.Create('BOOOOM!');\n    end;\n  end;\nend;\n\nfunction TMyObject.ReverseString(const aString: string; const aUpperCase: Boolean): string;\nbegin\n  Result := System.StrUtils.ReverseString(aString);\n  if aUpperCase then\n    Result := Result.ToUpper;\nend;\n\nfunction TMyObject.SaveObjectWithJSON(const WithJSON: TJsonObject): TJsonObject;\nvar\n  lObj: TObjectWithJSONObject;\nbegin\n  lObj := TUtils.JSONObjectAs<TObjectWithJSONObject>(WithJSON);\n  try\n    LogD(lObj);\n    Result := WithJSON.Clone as TJsonObject;\n  finally\n    lObj.Free;\n  end;\nend;\n\nfunction TMyObject.SavePerson(const Person: TPerson): Integer;\n// var\n// lPerson: TPerson;\nbegin\n  // lPerson := JSONObjectAs<TPerson>(aPerson);\n  // try\n  // // do something with lPerson\n  // finally\n  // lPerson.Free;\n  // end;\n\n  // this maybe the id of the newly created person\n  LogI(Person);\n  Result := Random(1000);\nend;\n\nfunction TMyObject.SavePersonRec(PersonRec: TTestRec): TTestRec;\nbegin\n  Result := PersonRec;\nend;\n\nfunction TMyObject.Subtract(Value1, Value2: Integer): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TMyObjectWithHooks }\n\nprocedure TMyObject.OnBeforeCallHook(const Context: TWebContext; const JSONRequest: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnBeforeCallHook >> ', 'jsonrpc');\n  Log.Info(sLineBreak + JSONRequest.ToJSON(False), 'jsonrpc');\n  Log.Info('TMyObjectWithHooks.OnBeforeCallHook << ', 'jsonrpc');\nend;\n\nprocedure TMyObject.OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnBeforeRoutingHook >> ', 'jsonrpc');\n  Log.Info(sLineBreak + JSON.ToJSON(False), 'jsonrpc');\n  Log.Info('TMyObjectWithHooks.OnBeforeRoutingHook << ', 'jsonrpc');\nend;\n\nprocedure TMyObject.OnAfterCallHook(const Context: TWebContext; const JSONResponse: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnAfterCallHook >> ', 'jsonrpc');\n  if Assigned(JSONResponse) then\n  begin\n    Log.Info(sLineBreak + JSONResponse.ToJSON(False), 'jsonrpc');\n  end;\n  Log.Info('TMyObjectWithHooks.OnAfterCallHook << ', 'jsonrpc');\nend;\n\nend.", "output": "[Flags]\npublic enum TSetTest\n{\n    None = 0,\n    ptEnumValue1 = 1,\n    ptEnumValue2 = 2,\n    ptEnumValue3 = 4,\n    ptEnumValue4 = 8\n}\n\npublic class TTestRec\n{\n    public int Value { get; set; }\n    public TTestRec(int value)\n    {\n        Value = value;\n    }\n}\n\npublic class TTestRecDynArray : List<TTestRec>\n{\n}\n\npublic class TTestRecArray\n{\n    public TTestRec[] Array;\n}\n\npublic class TNestedArraysRec\n{\n    public TTestRec[] ArrayProp1;\n    public TTestRec[] ArrayProp2;\n    public TTestRec TestRecProp;\n}\n\npublic class TMultiDataset\n{\n    public DataTable Customers { get; set; }\n    public DataTable People { get; set; }\n    public TMultiDataset()\n    {\n        Customers = new DataTable();\n        People = new DataTable();\n    }\n}\n\npublic class TMVCStringDictionary : Dictionary<string, string>\n{\n}\n\npublic class TPerson\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public DateTime DOB { get; set; }\n    public bool Married { get; set; }\n}\n\npublic class WebContext\n{\n}\n\npublic class MVCJSONRPCErrorException : Exception\n{\n    public int Code { get; }\n    public MVCJSONRPCErrorException(int code, string message) : base(message)\n    {\n        Code = code;\n    }\n}\n\npublic static class Constants\n{\n    public const int JSONRPC_USER_ERROR = 1000;\n}\n\npublic class MyObject\n{\n    DataTable GetCustomersDataset()\n    {\n        DataTable dt = new DataTable();\n        dt.Columns.Add(\"Code\", typeof(int));\n        dt.Columns.Add(\"Name\", typeof(string));\n        dt.Rows.Add(1, \"Ford\");\n        dt.Rows.Add(2, \"Ferrari\");\n        dt.Rows.Add(3, \"Lotus\");\n        dt.Rows.Add(4, \"FCA\");\n        dt.Rows.Add(5, \"Hyundai\");\n        dt.Rows.Add(6, \"De Tomaso\");\n        dt.Rows.Add(7, \"Dodge\");\n        dt.Rows.Add(8, \"Tesla\");\n        dt.Rows.Add(9, \"Kia\");\n        dt.Rows.Add(10, \"Tata\");\n        dt.Rows.Add(11, \"Volkswagen\");\n        dt.Rows.Add(12, \"Audi\");\n        dt.Rows.Add(13, \"Skoda\");\n        dt.AcceptChanges();\n        return dt;\n    }\n\n    void FillCustomersDataset(DataTable dataSet)\n    {\n        dataSet.Rows.Add(1, \"Ford\");\n        dataSet.Rows.Add(2, \"Ferrari\");\n        dataSet.Rows.Add(3, \"Lotus\");\n        dataSet.Rows.Add(4, \"FCA\");\n        dataSet.Rows.Add(5, \"Hyundai\");\n        dataSet.Rows.Add(6, \"De Tomaso\");\n        dataSet.Rows.Add(7, \"Dodge\");\n        dataSet.Rows.Add(8, \"Tesla\");\n        dataSet.Rows.Add(9, \"Kia\");\n        dataSet.Rows.Add(10, \"Tata\");\n        dataSet.Rows.Add(11, \"Volkswagen\");\n        dataSet.Rows.Add(12, \"Audi\");\n        dataSet.Rows.Add(13, \"Skoda\");\n        dataSet.AcceptChanges();\n    }\n\n    void FillPeopleDataset(DataTable dataSet)\n    {\n        dataSet.Rows.Add(\"Daniele\", \"Teti\");\n        dataSet.Rows.Add(\"Peter\", \"Parker\");\n        dataSet.Rows.Add(\"Bruce\", \"Banner\");\n        dataSet.Rows.Add(\"Scott\", \"Summers\");\n        dataSet.Rows.Add(\"Sue\", \"Storm\");\n        dataSet.AcceptChanges();\n    }\n\n    public void OnBeforeRoutingHook(WebContext context, JObject json)\n    {\n    }\n\n    public void OnBeforeCallHook(WebContext context, JObject jsonRequest)\n    {\n        Console.WriteLine(\"TMyObject.OnBeforeCallHook >>\");\n        Console.WriteLine(jsonRequest.ToString(Formatting.None));\n        Console.WriteLine(\"TMyObject.OnBeforeCallHook <<\");\n    }\n\n    public void OnAfterCallHook(WebContext context, JObject jsonResponse)\n    {\n        Console.WriteLine(\"TMyObject.OnAfterCallHook >>\");\n        if (jsonResponse != null)\n        {\n            Console.WriteLine(jsonResponse.ToString(Formatting.None));\n        }\n        Console.WriteLine(\"TMyObject.OnAfterCallHook <<\");\n    }\n\n    public int Subtract(int value1, int value2)\n    {\n        return value1 - value2;\n    }\n\n    public string ReverseString(string aString, bool aUpperCase)\n    {\n        char[] chars = aString.ToCharArray();\n        Array.Reverse(chars);\n        string result = new string(chars);\n        if (aUpperCase)\n        {\n            result = result.ToUpper();\n        }\n        return result;\n    }\n\n    public DateTime GetNextMonday(DateTime aDate)\n    {\n        DateTime lDate = aDate.AddDays(1);\n        while (lDate.DayOfWeek != DayOfWeek.Monday)\n        {\n            lDate = lDate.AddDays(1);\n        }\n        return lDate;\n    }\n\n    public DateTime PlayWithDatesAndTimes(double aJustAFloat, TimeSpan aTime, DateTime aDate, DateTime aDateAndTime)\n    {\n        return aDateAndTime.Add(aDate.TimeOfDay).Add(aTime).Add(TimeSpan.FromDays(aJustAFloat));\n    }\n\n    public DataTable GetCustomers(string filterString)\n    {\n        DataTable dt = GetCustomersDataset();\n        if (!string.IsNullOrEmpty(filterString))\n        {\n            dt.DefaultView.RowFilter = filterString;\n            dt = dt.DefaultView.ToTable();\n        }\n        dt.AcceptChanges();\n        return dt;\n    }\n\n    public TMultiDataset GetMulti()\n    {\n        TMultiDataset result = new TMultiDataset();\n        FillCustomersDataset(result.Customers);\n        FillPeopleDataset(result.People);\n        return result;\n    }\n\n    public TMVCStringDictionary GetStringDictionary()\n    {\n        var dict = new TMVCStringDictionary();\n        dict.Add(\"key1\", \"value1\");\n        dict.Add(\"key2\", \"value2\");\n        dict.Add(\"key3\", \"value3\");\n        dict.Add(\"key4\", \"value4\");\n        return dict;\n    }\n\n    public TPerson GetUser(string aUserName)\n    {\n        TPerson person = new TPerson();\n        person.FirstName = \"Daniele (a.k.a. \" + aUserName + \")\";\n        person.LastName = \"Teti\";\n        person.DOB = new DateTime(1932, 11, 4);\n        person.Married = true;\n        return person;\n    }\n\n    public int SavePerson(TPerson person)\n    {\n        Console.WriteLine(person.FirstName + \" \" + person.LastName);\n        return new Random().Next(1000);\n    }\n\n    public double FloatsTest(double aDouble, double aExtended)\n    {\n        return aDouble + aExtended;\n    }\n\n    public void DoSomething()\n    {\n    }\n\n    public void RaiseCustomException()\n    {\n        throw new MVCJSONRPCErrorException(Constants.JSONRPC_USER_ERROR + 1, \"This is an exception message\");\n    }\n\n    public int RaiseGenericException(int exceptionType)\n    {\n        switch (exceptionType)\n        {\n            case 1:\n                int l = 0;\n                return 10 / l;\n            case 2:\n                throw new NullReferenceException(\"Fake Invalid Pointer Operation\");\n            default:\n                throw new Exception(\"BOOOOM!\");\n        }\n    }\n\n    public JObject SaveObjectWithJSON(JObject withJSON)\n    {\n        var obj = Utils.JSONObjectAs<ObjectWithJSONObject>(withJSON);\n        Console.WriteLine(obj);\n        return (JObject)withJSON.DeepClone();\n    }\n\n    public TEnumTest PassingEnums(TEnumTest value1, TEnumTest value2)\n    {\n        if (value1 == value2)\n            return TEnumTest.ptEnumValue4;\n        else\n            return TEnumTest.ptEnumValue3;\n    }\n\n    public TSetTest GetSetBySet(TSetTest value)\n    {\n        TSetTest result = TSetTest.None;\n        foreach (TEnumTest item in Enum.GetValues(typeof(TEnumTest)))\n        {\n            if (value.HasFlag((TSetTest)(1 << (int)item)))\n                result &= ~(TSetTest)(1 << (int)item);\n            else\n                result |= (TSetTest)(1 << (int)item);\n        }\n        return result;\n    }\n\n    public TTestRec SavePersonRec(TTestRec personRec)\n    {\n        return personRec;\n    }\n\n    public TTestRecDynArray GetPeopleRecDynArray()\n    {\n        TTestRecDynArray arr = new TTestRecDynArray();\n        arr.Add(new TTestRec(1));\n        arr.Add(new TTestRec(2));\n        return arr;\n    }\n\n    public TTestRecArray GetPeopleRecStaticArray()\n    {\n        TTestRecArray result = new TTestRecArray();\n        result.Array = new TTestRec[2];\n        result.Array[0] = new TTestRec(7);\n        result.Array[1] = new TTestRec(8);\n        return result;\n    }\n\n    public TTestRec GetPersonRec()\n    {\n        return new TTestRec(99);\n    }\n\n    public TNestedArraysRec GetComplex1()\n    {\n        TNestedArraysRec result = new TNestedArraysRec();\n        result.ArrayProp1 = new TTestRec[2];\n        result.ArrayProp2 = new TTestRec[2];\n        result.ArrayProp1[0] = new TTestRec(1234);\n        result.ArrayProp1[1] = new TTestRec(2345);\n        result.ArrayProp2[0] = new TTestRec(3456);\n        result.ArrayProp2[1] = new TTestRec(4567);\n        return result;\n    }\n\n    public TTestRecDynArray EchoComplexArrayOfRecords(TTestRecDynArray peopleList)\n    {\n        return peopleList;\n    }\n\n    public TNestedArraysRec EchoComplexArrayOfRecords2(TNestedArraysRec vendorProxiesAndLinks)\n    {\n        vendorProxiesAndLinks.TestRecProp.Value += 0;\n        return vendorProxiesAndLinks;\n    }\n\n    public void InvalidMethod1(ref int myVarParam)\n    {\n    }\n\n    public void InvalidMethod2(out int myOutParam)\n    {\n        myOutParam = 0;\n    }\n}\n\npublic static class Utils\n{\n    public static T JSONObjectAs<T>(JObject json) where T : class, new()\n    {\n        T obj = new T();\n        string jsonStr = json.ToString(Formatting.None);\n        obj = JsonConvert.DeserializeObject<T>(jsonStr);\n        return obj;\n    }\n}\n\npublic class ObjectWithJSONObject\n{\n    public override string ToString()\n    {\n        return \"ObjectWithJSONObject\";\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file: David Moorhouse (info@moorhouse.net.nz)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Serializer.URLEncoded;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes, System.Rtti,\n  System.TypInfo, Data.DB,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Abstract,\n  MVCFramework.DuckTyping,\n  MVCFramework.Serializer.Commons,\n  System.SysUtils;\n\ntype\n  TMVCURLEncodedSerializer = class(TMVCAbstractSerializer, IMVCSerializer)\n  private\n    procedure DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember; const RawData: string;\n      const AName: string; var AValue: TValue; const AType: TMVCSerializationType; const AIgnored: TMVCIgnoredList;\n      const ACustomAttributes: TArray<TCustomAttribute>); overload;\n  procedure DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n    const RawDataArray: TArray<string>; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n    const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>); overload;\n\n  protected\n    procedure RaiseNotImplemented;\n  protected\n    { IMVCSerializer }\n    procedure RegisterTypeSerializer(const ATypeInfo: PTypeInfo; AInstance: IMVCTypeSerializer);\n\n    function SerializeObject(const AObject: TObject; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeObject(const AObject: IInterface; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeRecord(const ARecord: Pointer; const ARecordTypeInfo: PTypeInfo;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ASerializationAction: TMVCSerializationAction = nil): string; overload;\n\n    function SerializeCollection(const AList: TObject; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeCollection(const AList: IInterface; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeDataSet(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList = [];\n      const ANameCase: TMVCNameCase = ncAsIs; const ASerializationAction: TMVCDatasetSerializationAction = nil): string;\n\n    function SerializeDataSetRecord(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList = [];\n      const ANameCase: TMVCNameCase = ncAsIs; const ASerializationAction: TMVCDatasetSerializationAction = nil): string;\n\n    procedure DeserializeObject(const ASerializedObject: string; const AObject: TObject;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ARootNode: String = ''); overload;\n\n    procedure DeserializeObject(const ASerializedObject: string; const AObject: IInterface;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil); overload;\n\n    procedure DeserializeCollection(const ASerializedList: string; const AList: TObject; const AClazz: TClass;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ARootNode: String = ''); overload;\n\n    procedure DeserializeCollection(const ASerializedList: string; const AList: IInterface; const AClazz: TClass;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil); overload;\n\n    procedure DeserializeDataSet(const ASerializedDataSet: string; const ADataSet: TDataSet;\n      const AIgnoredFields: TMVCIgnoredList = []; const ANameCase: TMVCNameCase = ncAsIs);\n\n    procedure DeserializeDataSetRecord(const ASerializedDataSetRecord: string; const ADataSet: TDataSet;\n      const AIgnoredFields: TMVCIgnoredList = []; const ANameCase: TMVCNameCase = ncAsIs);\n\n    function SerializeArrayOfRecord(\n      var ATValueContainingAnArray: TValue;\n      const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ASerializationAction: TMVCSerializationAction = nil\n      ): string; overload;\n\n  public\n    procedure URLEncodedStringToObject(\n      const Data: TStringList; const AObject: TObject;\n      const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\n\n  end;\n\nimplementation\n\nuses\n  System.NetEncoding, System.Math, JsonDataObjects, MVCFramework.Nullables;\n\n{ TMVCURLEncodedSerializer }\n\nprocedure TMVCURLEncodedSerializer.DeserializeCollection(const ASerializedList: string; const AList: IInterface;\n  const AClazz: TClass; const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeCollection(const ASerializedList: string; const AList: TObject;\n  const AClazz: TClass; const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList; const ARootNode: String);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeDataSet(const ASerializedDataSet: string; const ADataSet: TDataSet;\n  const AIgnoredFields: TMVCIgnoredList; const ANameCase: TMVCNameCase);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeDataSetRecord(const ASerializedDataSetRecord: string; const ADataSet: TDataSet;\n  const AIgnoredFields: TMVCIgnoredList; const ANameCase: TMVCNameCase);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeObject(const ASerializedObject: string; const AObject: IInterface;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nbegin\n  // ??\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeObject(const ASerializedObject: string; const AObject: TObject;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList; const ARootNode: String);\nvar\n  SL: TStringList;\n  lPieces: TArray<string>;\n  I: Integer;\n  lKeyValue: TArray<string>;\nbegin\n  if (ASerializedObject = EmptyStr) then\n    raise EMVCException.Create(HTTP_STATUS.BadRequest, 'Invalid body');\n\n  if not Assigned(AObject) then\n    Exit;\n\n  SL := TStringList.Create;\n  try\n    try\n      lPieces := ASerializedObject.Split(['&']);\n      for I := 0 to High(lPieces) do\n      begin\n        lKeyValue := lPieces[I].Split(['=']);\n        SL.AddPair(lKeyValue[0], URLDecode(lKeyValue[1]));\n      end;\n      if GetTypeSerializers.ContainsKey(AObject.ClassInfo) then\n      begin\n        RaiseNotImplemented;\n        // todo: do we handle custom type serialisers\n        // GetTypeSerializers.Items[AObject.ClassInfo].DeserializeRoot(SelectRootNodeOrWholeObject(ARootNode, JSONObject),\n        // AObject, [])\n      end\n      else\n      begin\n        URLEncodedStringToObject(SL, AObject, GetSerializationType(AObject, AType), AIgnoredAttributes);\n      end;\n    except\n      on E: Exception do\n        raise EMVCException.Create(HTTP_STATUS.BadRequest, E.Message);\n    end;\n  finally\n    SL.Free;\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.RaiseNotImplemented;\nbegin\n  raise EMVCException.Create('Not Implemented');\nend;\n\nprocedure TMVCURLEncodedSerializer.RegisterTypeSerializer(const ATypeInfo: PTypeInfo; AInstance: IMVCTypeSerializer);\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeCollection(const AList: TObject; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeArrayOfRecord(\n  var ATValueContainingAnArray: TValue; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList;\n  const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeCollection(const AList: IInterface; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeDataSet(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList;\n  const ANameCase: TMVCNameCase; const ASerializationAction: TMVCDatasetSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeDataSetRecord(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList;\n  const ANameCase: TMVCNameCase; const ASerializationAction: TMVCDatasetSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeObject(const AObject: IInterface; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeObject(const AObject: TObject; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeRecord(const ARecord: Pointer; const ARecordTypeInfo: PTypeInfo;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList;\n  const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.URLEncodedStringToObject(\n  const Data: TStringList; const AObject: TObject;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nvar\n  lObjType: TRttiType;\n  lProp: TRttiProperty;\n  lFld: TRttiField;\n  lAttributeValue: TValue;\n  lKeyName: string;\n  lErrMsg: string;\n  I: Integer;\n  lArrValues: TArray<String>;\n  lCurrIdx: Integer;\n  lName: string;\n  lTmp: string;\nconst\n  INITIAL_ARRAY_SIZE = 5;\nbegin\n  if AObject = nil then\n  begin\n    Exit;\n  end;\n\n  if TypeInfo(tjsonobject) = AObject.ClassInfo then\n  begin\n    for I := 0 to Data.Count-1 do\n    begin\n      lName := Data.Names[I];\n      if TJsonObject(AObject).IsNull(lName) then\n      begin\n        TJsonObject(AObject).S[lName] := Data.ValueFromIndex[I];\n      end\n      else\n      begin\n        if TJsonObject(AObject).Types[lName] = jdtString then\n        begin\n          lTmp := TJsonObject(AObject).S[lName];\n          TJsonObject(AObject).Remove(lName);\n          TJsonObject(AObject).A[lName].Add(lTmp);\n        end;\n        TJsonObject(AObject).A[lName].Add(Data.ValueFromIndex[I]);\n      end;\n    end;\n    Exit;\n  end;\n\n  lProp := nil;\n  lFld := nil;\n\n  lObjType := GetRttiContext.GetType(AObject.ClassType);\n  case AType of\n    stDefault, stProperties:\n      begin\n        try\n          for lProp in lObjType.GetProperties do\n          begin\n{$IFDEF AUTOREFCOUNT}\n            if TMVCSerializerHelper.IsAPropertyToSkip(lProp.Name) then\n              continue;\n{$ENDIF}\n            if ((not TMVCSerializerHelper.HasAttribute<MVCDoNotDeserializeAttribute>(lProp)) and\n              (not IsIgnoredAttribute(AIgnoredAttributes, lProp.Name)) and (lProp.IsWritable or lProp.GetValue(AObject).IsObject))\n            then\n            begin\n              lAttributeValue := lProp.GetValue(AObject);\n              lKeyName := TMVCSerializerHelper.GetKeyName(lProp, lObjType);\n              if not lAttributeValue.IsArray then\n              begin\n                if Data.IndexOfName(lKeyName) > -1 then\n                begin\n                  DataValueToAttribute(AObject, lProp, Data.Values[lKeyName], lKeyName, lAttributeValue, AType, AIgnoredAttributes,\n                    lProp.GetAttributes);\n                  if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) and lProp.IsWritable then\n                  begin\n                    lProp.SetValue(AObject, lAttributeValue);\n                  end;\n                end;\n              end\n              else\n              begin\n                // there are multiple parameters with the same name\n                if Data.IndexOfName(lKeyName) > -1 then\n                begin\n                  SetLength(lArrValues, INITIAL_ARRAY_SIZE);\n                  lCurrIdx := -1;\n                  for I := 0 to Data.Count - 1 do\n                  begin\n                    if Data.Names[i] = lKeyName then\n                    begin\n                      Inc(lCurrIdx);\n                      if (lCurrIdx >= INITIAL_ARRAY_SIZE) and (lCurrIdx >= Length(lArrValues)) then {does short-circuit make it faster?}\n                      begin\n                        SetLength(lArrValues, Trunc(lCurrIdx * 2));\n                      end;\n                      lArrValues[lCurrIdx] := Data.ValueFromIndex[i];\n                    end;\n                  end;\n                  SetLength(lArrValues, lCurrIdx + 1); //trim\n                  DataValueToAttribute(AObject, lProp, lArrValues, lKeyName,\n                    lAttributeValue, AType, AIgnoredAttributes, lProp.GetAttributes);\n                  if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) and lProp.IsWritable then\n                  begin\n                    lProp.SetValue(AObject, lAttributeValue);\n                  end;\n                end;\n              end;\n            end;\n          end;\n        except\n          on E: EInvalidCast do\n          begin\n            if lProp <> nil then\n            begin\n              lErrMsg := Format('Invalid class typecast for property \"%s\" [Expected: %s, Data: %s]',\n                [lKeyName, lProp.PropertyType.ToString(), Data.Values[lKeyName]]);\n            end\n            else\n            begin\n              lErrMsg := Format('Invalid class typecast for property \"%s\" [Data: %s]', [lKeyName, Data.Values[lKeyName]]);\n            end;\n            raise EMVCException.Create(HTTP_STATUS.BadRequest, lErrMsg);\n          end;\n        end;\n      end;\n    stFields:\n      begin\n        try\n          for lFld in lObjType.GetFields do\n            if (not TMVCSerializerHelper.HasAttribute<MVCDoNotDeserializeAttribute>(lFld)) and\n              (not IsIgnoredAttribute(AIgnoredAttributes, lFld.Name)) then\n            begin\n              lAttributeValue := lFld.GetValue(AObject);\n              lKeyName := TMVCSerializerHelper.GetKeyName(lFld, lObjType);\n              if Data.IndexOfName(lKeyName) > -1 then\n              begin\n                DataValueToAttribute(AObject, lFld, Data.Values[lKeyName], lKeyName, lAttributeValue, AType, AIgnoredAttributes,\n                  lFld.GetAttributes);\n                if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) then\n                  lFld.SetValue(AObject, lAttributeValue);\n              end;\n            end;\n        except\n          on E: EInvalidCast do\n          begin\n            if lFld <> nil then\n            begin\n              lErrMsg := Format('Invalid class typecast for field \"%s\" [Expected: %s, Data: %s]',\n                [lKeyName, lFld.FieldType.ToString(), Data.Values[lKeyName]]);\n            end\n            else\n            begin\n              lErrMsg := Format('Invalid class typecast for field \"%s\" [Data: %s]', [lKeyName, Data.Values[lKeyName]]);\n            end;\n            raise EMVCException.Create(HTTP_STATUS.BadRequest, lErrMsg);\n          end;\n        end;\n      end;\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n  const RawData: string; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n  const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>);\nvar\n  RttiType: TRttiType;\n  lValueTypeInfo: PTypeInfo;\n  lOutInteger: Integer;\n  lOutInteger64: Int64;\n  lOutUInteger64: UInt64;\n  lOutSingle: Double;\n  lOutDouble: Double;\n  lOutExtended: Extended;\n  lOutUInteger: Cardinal;\nbegin\n  RttiType := nil;\n  AValue.Empty;\n  case AType of\n    stUnknown, stDefault, stProperties:\n      RttiType := TRttiProperty(ARttiMember).PropertyType;\n    stFields:\n      RttiType := TRttiField(ARttiMember).FieldType;\n  end;\n\n\n  case RttiType.TypeKind of\n    tkString, tkWideString, tkAnsiString, tkUString:\n      AValue := TNetEncoding.URL.Decode(RawData);\n    tkInteger:\n      AValue := RawData.ToInteger;\n    tkInt64:\n      AValue := RawData.ToInt64;\n    tkFloat:\n      AValue := RawData.ToDouble;\n    tkEnumeration:\n      begin\n        if SameText(RttiType.ToString, 'boolean') then\n          AValue := RawData.ToBoolean;\n      end;\n    tkRecord:\n    begin\n      if String(RttiType.Handle^.Name).StartsWith('Nullable', True) then\n      begin\n        lValueTypeInfo := AValue.TypeInfo;\n        if lValueTypeInfo = TypeInfo(NullableString) then\n        begin\n          AValue := TValue.From<NullableString>(RawData);\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt32) then\n        begin\n          if TryStrToInt(RawData, lOutInteger) then\n            AValue := TValue.From<NullableInt32>(lOutInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt32) then\n        begin\n          if TryStrToUInt(RawData, lOutUInteger) then\n            AValue := TValue.From<NullableUInt32>(lOutUInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt16) then\n        begin\n          if TryStrToInt(RawData, lOutInteger) then\n            AValue := TValue.From<NullableInt16>(lOutInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt16) then\n        begin\n          if TryStrToUInt(RawData, lOutUInteger) then\n            AValue := TValue.From<NullableUInt16>(lOutUInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt64) then\n        begin\n          if TryStrToInt64(RawData, lOutInteger64) then\n            AValue := TValue.From<NullableInt64>(lOutInteger64)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt64) then\n        begin\n          if TryStrToUInt64(RawData, lOutUInteger64) then\n            AValue := TValue.From<NullableUInt64>(lOutUInteger64)\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableSingle)) then\n        begin\n          if TryStrToFloat(RawData, lOutSingle) then\n            AValue := TValue.From<NullableSingle>(lOutSingle)\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableDouble)) then\n        begin\n          if TryStrToFloat(RawData, lOutDouble) then\n            AValue := lOutDouble\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableExtended)) then\n        begin\n          if TryStrToFloat(RawData, lOutExtended) then\n            AValue := lOutExtended\n          else\n            AValue := TValue.Empty;\n        end\n        else\n        begin\n          raise EMVCDeserializationException.Create('(DataValueToAttribute) Cannot deserialize Nullable type ' + String(RttiType.Handle^.Name));\n        end;\n      end\n      else\n      begin\n        raise EMVCDeserializationException.Create('(DataValueToAttribute) Invalid Record Type ' + String(RttiType.Handle^.Name));\n      end;\n    end\n    else\n      raise EMVCDeserializationException.Create('(DataValueToAttribute) Invalid TypeKind: ' + GetEnumName(TypeInfo(TTypeKind), Ord(RttiType.TypeKind)));\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n  const RawDataArray: TArray<string>; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n  const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>);\nvar\n  RttiType: TRttiType;\n  //RttiArray: TRttiDynamicArrayType;\nbegin\n  RttiType := nil;\n  AValue.Empty;\n  case AType of\n    stUnknown, stDefault, stProperties:\n      RttiType := TRttiProperty(ARttiMember).PropertyType;\n    stFields:\n      RttiType := TRttiField(ARttiMember).FieldType;\n  end;\n\n  if RttiType.TypeKind <> tkDynArray then\n  begin\n    raise EMVCDeserializationException.Create('Expected DynArray in deserialization for ' + AName);\n  end;\n\n  //RttiArray := TRttiDynamicArrayType(RttiType);\n  AValue := TValue.From(RawDataArray)\nend;\n\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Web; \n\nnamespace MVCFramework.Serializer.URLEncoded\n{\n    \n    public enum TMVCSerializationType\n    {\n        Default,\n        Properties,\n        Fields,\n        Unknown\n    }\n\n    \n    public enum TMVCNameCase\n    {\n        AsIs,\n        LowerCase,\n        UpperCase\n    }\n\n    \n    public class EMVCException : Exception\n    {\n        public int StatusCode { get; }\n        public EMVCException(int statusCode, string message) : base(message) => StatusCode = statusCode;\n    }\n\n    \n    public class EMVCDeserializationException : Exception\n    {\n        public EMVCDeserializationException(string message) : base(message) { }\n    }\n\n    \n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] customAttributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] customAttributes, Action serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] customAttributes);\n        void DeserializeRoot(object serializerObject, object target, Attribute[] customAttributes);\n    }\n\n    \n    public interface IMVCSerializer\n    {\n        void RegisterTypeSerializer(Type type, IMVCTypeSerializer serializer);\n        string SerializeObject(object obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeObject(IInterface obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeRecord(object record, Type recordType, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeCollection(object list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeCollection(IInterface list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeDataSet(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null);\n        string SerializeDataSetRecord(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null);\n        string SerializeArrayOfRecord(ref object arrayContainer, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n\n        void DeserializeObject(string serializedObject, object target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\");\n        void DeserializeObject(string serializedObject, IInterface target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null);\n        void DeserializeCollection(string serializedList, object list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\");\n        void DeserializeCollection(string serializedList, IInterface list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null);\n        void DeserializeDataSet(string serializedDataSet, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs);\n        void DeserializeDataSetRecord(string serializedDataSetRecord, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs);\n    }\n\n    \n    public interface IInterface { }\n\n    \n    public class MVCURLEncodedSerializer : IMVCSerializer\n    {\n        \n\n        protected void RaiseNotImplemented()\n        {\n            throw new NotImplementedException(\"Not Implemented\");\n        }\n\n        protected Dictionary<string, string> ParseUrlEncodedString(string serializedObject)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            var pairs = serializedObject.Split('&');\n            foreach (var pair in pairs)\n            {\n                var keyValue = pair.Split('=');\n                if (keyValue.Length == 2)\n                {\n                    var key = keyValue[0];\n                    var value = HttpUtility.UrlDecode(keyValue[1]);\n                    dict[key] = value;\n                }\n            }\n            return dict;\n        }\n\n        protected object ConvertRawValue(string rawData, Type targetType)\n        {\n            \n            if (targetType == typeof(string))\n            {\n                return HttpUtility.UrlDecode(rawData);\n            }\n            \n            if (targetType == typeof(int) || targetType == typeof(int?))\n            {\n                if (int.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out int intVal))\n                    return intVal;\n                return null;\n            }\n            if (targetType == typeof(long) || targetType == typeof(long?))\n            {\n                if (long.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out long longVal))\n                    return longVal;\n                return null;\n            }\n            if (targetType == typeof(double) || targetType == typeof(double?))\n            {\n                if (double.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out double doubleVal))\n                    return doubleVal;\n                return null;\n            }\n            if (targetType == typeof(bool) || targetType == typeof(bool?))\n            {\n                if (bool.TryParse(rawData, out bool boolVal))\n                    return boolVal;\n                if (rawData == \"0\") return false;\n                if (rawData == \"1\") return true;\n                return null;\n            }\n            if (targetType == typeof(DateTime) || targetType == typeof(DateTime?))\n            {\n                if (DateTime.TryParse(rawData, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dt))\n                    return dt;\n                return null;\n            }\n            if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(Nullable<>))\n            {\n                Type underlyingType = Nullable.GetUnderlyingType(targetType);\n                return ConvertRawValue(rawData, underlyingType);\n            }\n            throw new EMVCDeserializationException($\"Unsupported type for conversion: {targetType}\");\n        }\n\n        public void DataValueToAttribute(object target, MemberInfo member, string rawData, string name, out object value,\n            TMVCSerializationType serializationType, IList<string> ignoredAttributes, Attribute[] customAttributes)\n        {\n            value = null;\n            Type memberType = null;\n            if (member is PropertyInfo prop)\n            {\n                memberType = prop.PropertyType;\n            }\n            else if (member is FieldInfo fld)\n            {\n                memberType = fld.FieldType;\n            }\n            else\n            {\n                throw new Exception(\"Unsupported member type\");\n            }\n\n            try\n            {\n                value = ConvertRawValue(rawData, memberType);\n            }\n            catch (Exception ex)\n            {\n                throw new EMVCDeserializationException($\"Error converting value '{rawData}' for member '{name}': {ex.Message}\");\n            }\n        }\n\n        public void DataValueToAttribute(object target, MemberInfo member, string[] rawDataArray, string name, out object value,\n            TMVCSerializationType serializationType, IList<string> ignoredAttributes, Attribute[] customAttributes)\n        {\n            value = rawDataArray;\n        }\n\n\n        public void RegisterTypeSerializer(Type type, IMVCTypeSerializer serializer)\n        {\n            RaiseNotImplemented();\n        }\n\n        public string SerializeObject(object obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeObject(IInterface obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeRecord(object record, Type recordType, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeCollection(object list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeCollection(IInterface list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeDataSet(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeDataSetRecord(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeArrayOfRecord(ref object arrayContainer, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public void DeserializeObject(string serializedObject, object target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\")\n        {\n            if (string.IsNullOrEmpty(serializedObject))\n                throw new EMVCException(400, \"Invalid body\");\n\n            if (target == null)\n                return;\n\n            var dict = ParseUrlEncodedString(serializedObject);\n\n            URLEncodedStringToObject(dict, target, GetSerializationType(target, serializationType), ignoredAttributes);\n        }\n\n        public void DeserializeObject(string serializedObject, IInterface target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeCollection(string serializedList, object list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\")\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeCollection(string serializedList, IInterface list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeDataSet(string serializedDataSet, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeDataSetRecord(string serializedDataSetRecord, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void URLEncodedStringToObject(Dictionary<string, string> data, object target, TMVCSerializationType serializationType, IList<string> ignoredAttributes)\n        {\n            if (target == null)\n                return;\n\n            if (target is Newtonsoft.Json.Linq.JObject jObj)\n            {\n                foreach (var kvp in data)\n                {\n                    if (jObj[kvp.Key] == null)\n                    {\n                        jObj[kvp.Key] = kvp.Value;\n                    }\n                    else\n                    {\n                        var current = jObj[kvp.Key];\n                        jObj[kvp.Key] = new Newtonsoft.Json.Linq.JArray(current, kvp.Value);\n                    }\n                }\n                return;\n            }\n\n            Type targetType = target.GetType();\n            var props = targetType.GetProperties(BindingFlags.Public | BindingFlags.Instance);\n            foreach (var prop in props)\n            {\n                if (!prop.CanWrite) continue;\n                if (ignoredAttributes != null && ignoredAttributes.Contains(prop.Name)) continue;\n\n                string key = prop.Name;\n                if (data.ContainsKey(key))\n                {\n                    string rawData = data[key];\n                    object convertedValue;\n                    try\n                    {\n                        DataValueToAttribute(target, prop, rawData, key, out convertedValue, serializationType, ignoredAttributes, prop.GetCustomAttributes().ToArray());\n                        if (convertedValue != null)\n                        {\n                            prop.SetValue(target, convertedValue);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new EMVCException(400, $\"Invalid type conversion for property '{key}': {ex.Message}\");\n                    }\n                }\n            }\n\n            var fields = targetType.GetFields(BindingFlags.Public | BindingFlags.Instance);\n            foreach (var field in fields)\n            {\n                if (ignoredAttributes != null && ignoredAttributes.Contains(field.Name)) continue;\n                string key = field.Name;\n                if (data.ContainsKey(key))\n                {\n                    string rawData = data[key];\n                    object convertedValue;\n                    try\n                    {\n                        DataValueToAttribute(target, field, rawData, key, out convertedValue, serializationType, ignoredAttributes, field.GetCustomAttributes().ToArray());\n                        if (convertedValue != null)\n                        {\n                            field.SetValue(target, convertedValue);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new EMVCException(400, $\"Invalid type conversion for field '{key}': {ex.Message}\");\n                    }\n                }\n            }\n        }\n\n        protected TMVCSerializationType GetSerializationType(object target, TMVCSerializationType type)\n        {\n            return type;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n//\n// ***************************************************************************\n//\n// Sempare Template Engine\n//\n// Copyright (c) 2019-2023 Conrad Vermeulen and Sempare Limited\n//\n// https://github.com/sempare/sempare-delphi-template-engine\n//\n// NOTE: The Sempare Template Engine is available under GPL or commercial license.\n//\n// Free as in speech, NOT Free as in beer.\n//\n// ***************************************************************************\n//\n// This adaptor is licensed under the Apache License.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomSempareHelpersU;\n\ninterface\n\n// For more information on custom functions in the Sempare Template Engine,\n// see https://github.com/sempare/sempare-delphi-template-engine/blob/main/docs/custom-functions.md\n\ntype\n  TMySempareHelpers = class sealed\n  public\n    class function MyHelper1(const Value: string): string; static;\n    class function MyHelper2(const Value: string): string; static;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TMySempareHelpers }\n\nclass function TMySempareHelpers.MyHelper1(const Value: string): string;\nbegin\n  Result := Value + ' (I''m The MyHelper1)';\nend;\n\nclass function TMySempareHelpers.MyHelper2(const Value: string): string;\nbegin\n  Result := Value + ' (I''m The MyHelper2)';\nend;\n\nend.", "output": "using System;\n\nnamespace CustomSempareHelpersU\n{\n    public static class MySempareHelpers\n    {\n        public static string MyHelper1(string value)\n        {\n            return value + \" (I'm The MyHelper1)\";\n        }\n\n        public static string MyHelper2(string value)\n        {\n            return value + \" (I'm The MyHelper2)\";\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MessagingExtensionsTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  MVCFramework.RESTClient,\n  LiveServerTestU;\n{\n  type\n  TMessagingExtensionsTestCase = class(TBaseServerTest)\n  published\n  procedure TestSubscribeOnATopic;\n  procedure TestMultipleSubscribeOnSameTopic;\n  procedure TestMultipleSubscribeAndUnsubscribe;\n  procedure TestMultipleSubscribeAndUnsubscribeHARD;\n  procedure TestSubscribeAndReceive;\n  end;\n\n}\n\nimplementation\n\n{$WARN SYMBOL_DEPRECATED OFF}\n\nuses\n  System.SysUtils,\n\n  {$IF CompilerVersion < 27}\n\n  Data.DBXJSON,\n\n  {$ELSE}\n\n  System.JSON,\n\n  {$ENDIF}\n\n  System.Classes,\n  MVCFramework.Logger, MVCFramework.Commons, Winapi.Windows;\n\n{ TMessagingExtensionsTestCase }\n{\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeAndUnsubscribe;\n  var\n  res: IRESTResponse;\n  x: string;\n  begin\n  RESTClient.ReadTimeout(- 1);\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test01', x);\n\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010']);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test01;/queue/test010', x);\n\n  res := RESTClient.doDELETE('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test010', x);\n\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeAndUnsubscribeHARD;\n  var\n  res: IRESTResponse;\n  x: string;\n  begin\n  RESTClient.ReadTimeout(-1);\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test01']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test0101']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test01010']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010101']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test0101010']);\n\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals\n  ('/queue/test01;/queue/test010;/queue/test0101;/queue/test01010;/queue/test010101;/queue/test0101010',\n  x);\n\n  res := RESTClient.doDELETE('/messages/subscriptions/queue', ['test010']);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals\n  ('/queue/test01;/queue/test0101;/queue/test01010;/queue/test010101;/queue/test0101010', x);\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeOnSameTopic;\n  var\n  res: IRESTResponse;\n  begin\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestSubscribeAndReceive;\n  var\n  res: IRESTResponse;\n  messages: TJSONArray;\n  sid: string;\n  RMessageCount: Integer;\n  I: Integer;\n  o: TJSONObject;\n  J: Integer;\n  LUnique: string;\n  const\n  MSG_COUNT = 10;\n  begin\n  LUnique := GetTickCount.ToString;\n\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-' + LUnique]);\n  RESTClient.doPOST('/messages', ['subscriptions', 'queue', 'test01']);\n  RESTClient.doPOST('/messages', ['subscriptions', 'queue', 'test02']);\n  RESTClient.ReadTimeout(- 1);\n  sid := RESTClient.SessionID;\n  TThread.CreateAnonymousThread(\n  procedure\n  var\n  RESTC: TRESTClient;\n  I: Integer;\n  begin\n  TThread.Sleep(1000);\n  RESTC := TRESTClient.Create(TEST_SERVER_ADDRESS, 9999);\n  try\n  RESTC.doPOST('/messages/clients', ['my-other-unique-' + LUnique]);\n  RESTC.ReadTimeout(60 * 1000 * 30);\n  RESTC.doGET('/login', ['guest']);\n  for I := 1 to MSG_COUNT do\n  begin\n  RESTC.doPOST('/messages/queue/test02', [], TJSONObject.Create(TJSONPair.Create('hello',\n  TJSONNumber.Create(I))));\n  RESTC.doPOST('/messages/queue/test01', [], TJSONObject.Create(TJSONPair.Create('hello',\n  TJSONNumber.Create(I))));\n  end;\n  finally\n  RESTC.Free;\n  end;\n  end).Start;\n\n  RMessageCount := 0;\n  for J := 1 to MSG_COUNT * 2 do\n  begin\n  res := RESTClient.doGET('/messages', []);\n  if res.ResponseCode = HTTP_STATUS.OK then\n  begin\n  CheckIs(res.BodyAsJsonObject.Get('_timeout').JsonValue, TJSONFalse);\n  CheckNotNull(res.BodyAsJsonObject.Get('_timestamp'), '_timestamp is not set');\n  CheckNotNull(res.BodyAsJsonObject.Get('messages'), 'messages is not set');\n  CheckIs(res.BodyAsJsonObject.Get('messages').JsonValue, TJSONArray,\n  'Messages is not a TJSONArray');\n  messages := res.BodyAsJsonObject.Get('messages').JsonValue as TJSONArray;\n  if messages.Size > 0 then\n  for I := 0 to messages.Size - 1 do\n  begin\n  o := messages.Get(I) as TJSONObject;\n  logw(o.Get('message').ToString);\n  end;\n  RMessageCount := RMessageCount + messages.Size;\n  end;\n  if res.ResponseCode = HTTP_STATUS.RequestTimeout then // receive timeout\n  break;\n  end;\n  CheckEquals(MSG_COUNT * 2, RMessageCount, 'message count');\n  res := RESTClient.doGET('/messages', []);\n  CheckIs(res.BodyAsJsonObject.Get('_timeout').JsonValue, TJSONTrue);\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestSubscribeOnATopic;\n  var\n  res: IRESTResponse;\n  begin\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doDELETE('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  DoLogout;\n  end;\n}\ninitialization\n\n{$IFDEF USE_MESSAGING}\n\n  TDUnitX.RegisterTestFixture(TMessagingExtensionsTestCase);\n\n{$ENDIF}\n\nfinalization\n\nend.", "output": "using NUnit.Framework;\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json.Linq;\n\nnamespace MessagingExtensionsTests\n{\n    [TestFixture]\n    public class MessagingExtensionsTestCase\n    {\n        private HttpClient _client;\n        private const string BaseUrl = \"http://localhost:8080\";\n\n        [SetUp]\n        public void Setup()\n        {\n            \n            _client = new HttpClient();\n            _client.Timeout = TimeSpan.FromMinutes(30);\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            _client?.Dispose();\n        }\n\n        #region Helper Methods\n\n        private async Task DoLoginAsync(string username)\n        {\n            \n            var response = await _client.PostAsync($\"{BaseUrl}/login/{username}\", null);\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Login failed\");\n        }\n\n        private async Task DoLogoutAsync()\n        {\n            var response = await _client.PostAsync($\"{BaseUrl}/logout\", null);\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Logout failed\");\n        }\n\n        \n        private async Task<HttpResponseMessage> PostAsync(string url)\n        {\n            return await _client.PostAsync(url, null);\n        }\n\n        #endregion\n\n        #region Tests\n\n        [Test]\n        public async Task TestSubscribeOnATopic()\n        {\n            await DoLoginAsync(\"guest\");\n\n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription failed\");\n\n            \n            response = await _client.DeleteAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Unsubscription failed\");\n\n            await DoLogoutAsync();\n        }\n\n        [Test]\n        public async Task TestMultipleSubscribeOnSameTopic()\n        {\n            \n            await DoLoginAsync(\"guest\");\n\n           \n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"First subscription failed\");\n\n            response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Second subscription failed\");\n\n            \n\n            await DoLogoutAsync();\n        }\n\n        [Test]\n        public async Task TestMultipleSubscribeAndUnsubscribe()\n        {\n            await DoLoginAsync(\"guest\");\n\n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription test01 failed\");\n\n            response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test010\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription test010 failed\");\n\n            response = await _client.GetAsync($\"{BaseUrl}/messages/subscriptions\");\n            string subs = (await response.Content.ReadAsStringAsync()).Trim();\n            Assert.AreEqual(\"/queue/test01;/queue/test010\", subs, \"Subscription list incorrect\");\n\n\n            response = await _client.DeleteAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Unsubscription test01 failed\");\n\n            response = await _client.GetAsync($\"{BaseUrl}/messages/subscriptions\");\n            subs = (await response.Content.ReadAsStringAsync()).Trim();\n            Assert.AreEqual(\"/queue/test010\", subs, \"Subscription list after unsubscription incorrect\");\n\n            await DoLogoutAsync();\n        }\n\n        \n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.NewUnitWizardEx;\n\ninterface\n\nuses\n  ToolsApi,\n  VCL.Graphics,\n  PlatformAPI;\n\ntype\n  TDMVCNewUnitWizard = class\n  public\n    class procedure RegisterDMVCNewUnitWizard(const APersonality: string);\n  end;\n\nimplementation\n\n{$I ..\\sources\\dmvcframework.inc}\n\nuses\n  DMVC.Expert.Forms.NewUnitWizard,\n  DMVC.Expert.CodeGen.NewControllerUnit,\n  VCL.Controls,\n  VCL.Forms,\n  WinApi.Windows,\n  ExpertsRepository, JsonDataObjects;\n\nresourcestring\n  sNewDMVCUnitCaption = 'DelphiMVCFramework Controller';\n  sNewDMVCProjectHint = 'Create New DelphiMVCFramework Controller Unit';\n\nclass procedure TDMVCNewUnitWizard.RegisterDMVCNewUnitWizard(const APersonality: string);\nbegin\n  RegisterPackageWizard(TExpertsRepositoryProjectWizardWithProc.Create(APersonality, sNewDMVCProjectHint,\n    sNewDMVCUnitCaption, 'DMVC.Wizard.NewUnitWizard', // do not localize\n    'DelphiMVCFramework', 'DelphiMVCFramework Team - https://github.com/danieleteti/delphimvcframework', // do not localize\n    procedure\n    var\n      WizardForm: TfrmDMVCNewUnit;\n      ModuleServices: IOTAModuleServices;\n      Project: IOTAProject;\n      ControllerUnit: IOTAModule;\n      lJSON: TJSONObject;\n    begin\n      WizardForm := TfrmDMVCNewUnit.Create(Application);\n      try\n        if WizardForm.ShowModal = mrOk then\n        begin\n          lJSON := WizardForm.GetConfigModel;\n          ModuleServices := (BorlandIDEServices as IOTAModuleServices);\n          Project := GetActiveProject;\n          ControllerUnit := ModuleServices.CreateModule(\n            TNewControllerUnitEx.Create(lJSON, APersonality));\n          if Project <> nil then\n          begin\n            Project.AddFile(ControllerUnit.FileName, true);\n          end;\n        end;\n      finally\n        WizardForm.Free;\n      end;\n    end,\n    function: Cardinal\n    begin\n      Result := LoadIcon(HInstance, 'DMVCNewUnitIcon');\n    end, TArray<string>.Create(cWin32Platform, cWin64Platform\n    {$IF Defined(TOKYOORBETTER)}\n    , cLinux64Platform\n    {$ENDIF}\n    ), nil));\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertNewUnitWizardEx\n{\n\n    public interface IOTAModuleServices\n    {\n        IOTAModule CreateModule(TNewControllerUnitEx unit);\n    }\n    \n    public interface IOTAModule\n    {\n        string FileName { get; }\n    }\n    \n    public interface IOTAProject\n    {\n        void AddFile(string fileName, bool addToProject);\n    }\n    \n    public static class IDEHelper\n    {\n        public static IOTAProject GetActiveProject() => null; \n    }\n    \n    public static class BorlandIDEServices\n    {\n        public static object Instance { get; } = null;\n    }\n    \n    public class TNewControllerUnitEx\n    {\n        public TNewControllerUnitEx(JObject configModel, string personality)\n        {\n            // Initialization logic.\n        }\n        \n        public string FileName { get; } = \"NewControllerUnit.cs\";\n    }\n    \n    public class TfrmDMVCNewUnit : Form\n    {\n        public new DialogResult ShowDialog()\n        {\n            return DialogResult.OK;\n        }\n        \n        public JObject GetConfigModel()\n        {\n            return new JObject();\n        }\n    }\n    \n    public class ExpertsRepositoryProjectWizardWithProc\n    {\n        public ExpertsRepositoryProjectWizardWithProc(\n            string personality,\n            string projectHint,\n            string unitCaption,\n            string wizardId,\n            string vendorName,\n            string vendorDescription,\n            Action executeProc,\n            Func<IntPtr> getIconFunc,\n            string[] platforms,\n            object additionalParam)\n        {\n            // Store parameters as needed.\n        }\n        \n        public static void Register(ExpertsRepositoryProjectWizardWithProc wizard)\n        {\n            \n            Console.WriteLine(\"DMVC New Unit Wizard registered.\");\n        }\n    }\n    \n    public static class IconLoader\n    {\n        public static IntPtr LoadIcon(IntPtr instance, string iconName)\n        {\n            return IntPtr.Zero;\n        }\n    }\n    \n    public static class TDMVCNewUnitWizard\n    {\n        private const string sNewDMVCUnitCaption = \"DelphiMVCFramework Controller\";\n        private const string sNewDMVCProjectHint = \"Create New DelphiMVCFramework Controller Unit\";\n        \n        private static readonly string[] Platforms = { cWin32Platform, cWin64Platform  };\n        private const string cWin32Platform = \"Win32\";\n        private const string cWin64Platform = \"Win64\";\n        \n        private static IntPtr HInstance => IntPtr.Zero; \n        \n        \n        public static void RegisterDMVCNewUnitWizard(string personality)\n        {\n            ExpertsRepositoryProjectWizardWithProc.Register(\n                new ExpertsRepositoryProjectWizardWithProc(\n                    personality,\n                    sNewDMVCProjectHint,\n                    sNewDMVCUnitCaption,\n                    \"DMVC.Wizard.NewUnitWizard\", \n                    \"DelphiMVCFramework\",\n                    \"DelphiMVCFramework Team - https://github.com/danieleteti/delphimvcframework\",\n                    () =>\n                    {\n                        using (var wizardForm = new TfrmDMVCNewUnit())\n                        {\n                            if (wizardForm.ShowDialog() == DialogResult.OK)\n                            {\n                                JObject json = wizardForm.GetConfigModel();\n                                IOTAModuleServices moduleServices = BorlandIDEServices.Instance as IOTAModuleServices;\n                                IOTAProject project = IDEHelper.GetActiveProject();\n                                IOTAModule controllerUnit = moduleServices.CreateModule(new TNewControllerUnitEx(json, personality));\n                                if (project != null)\n                                {\n                                    project.AddFile(controllerUnit.FileName, true);\n                                }\n                            }\n                        }\n                    },\n                    () =>\n                    {\n                        return IconLoader.LoadIcon(HInstance, \"DMVCNewUnitIcon\");\n                    },\n                    Platforms,\n                    null\n                )\n            );\n        }\n    }\n}"}
{"input": "unit Horse.Provider.Console;\n\ninterface\n\n{$IF NOT DEFINED(FPC)}\nuses\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Provider.IOHandleSSL.Contract,\n  Horse.Provider.IOHandleSSL,\n  IdHTTPWebBrokerBridge,\n  IdSSLOpenSSL,\n  IdSSL,\n  IdContext,\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FEvent: TEvent;\n    class var FMaxConnections: Integer;\n    class var FListenQueue: Integer;\n    class var FKeepConnectionAlive: Boolean;\n    class var FIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\n    class var FHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\n    class function GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultEvent: TEvent;\n    class function HTTPWebBrokerIsNil: Boolean;\n    class procedure OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: String; var VUsername, VPassword: String; var VHandled: Boolean);\n    class procedure OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetMaxConnections(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL); static;\n    class procedure SetHost(const AValue: string); static;\n    class procedure SetKeepConnectionAlive(const AValue: Boolean); static;\n    class function GetListenQueue: Integer; static;\n    class function GetMaxConnections: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetIOHandleSSL: IHorseProviderIOHandleSSL; static;\n    class function GetHost: string; static;\n    class function GetKeepConnectionAlive: Boolean; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n    class procedure InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property MaxConnections: Integer read GetMaxConnections write SetMaxConnections;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class property KeepConnectionAlive: Boolean read GetKeepConnectionAlive write SetKeepConnectionAlive;\n    class property IOHandleSSL: IHorseProviderIOHandleSSL read GetIOHandleSSL write SetIOHandleSSL;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n    class destructor UnInitialize;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF NOT DEFINED(FPC)}\nuses\n  Web.WebReq,\n  Horse.WebModule,\n  IdCustomTCPServer;\n\nclass function THorseProvider.GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\nbegin\n  if HTTPWebBrokerIsNil then\n  begin\n    FIdHTTPWebBrokerBridge := TIdHTTPWebBrokerBridge.Create(nil);\n    FIdHTTPWebBrokerBridge.OnParseAuthentication := OnAuthentication;\n    FIdHTTPWebBrokerBridge.OnQuerySSLPort := OnQuerySSLPort;\n  end;\n  Result := FIdHTTPWebBrokerBridge;\nend;\n\nclass function THorseProvider.HTTPWebBrokerIsNil: Boolean;\nbegin\n  Result := FIdHTTPWebBrokerBridge = nil;\nend;\n\nclass procedure THorseProvider.OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\nbegin\n  VUseSSL := (FHorseProviderIOHandleSSL <> nil) and (FHorseProviderIOHandleSSL.Active);\nend;\n\nclass function THorseProvider.GetDefaultEvent: TEvent;\nbegin\n  if FEvent = nil then\n    FEvent := TEvent.Create;\n  Result := FEvent;\nend;\n\nclass function THorseProvider.GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  if FHorseProviderIOHandleSSL = nil then\n    FHorseProviderIOHandleSSL := THorseProviderIOHandleSSL.New;\n  Result := FHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetKeepConnectionAlive: Boolean;\nbegin\n  Result := FKeepConnectionAlive;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.GetIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  Result := GetDefaultHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetMaxConnections: Integer;\nbegin\n  Result := FMaxConnections;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\nvar\n  LIOHandleSSL: TIdServerIOHandlerSSLOpenSSL;\nbegin\n  LIOHandleSSL := TIdServerIOHandlerSSLOpenSSL.Create(AIdHTTPWebBrokerBridge);\n  LIOHandleSSL.SSLOptions.CertFile := AHorseProviderIOHandleSSL.CertFile;\n  LIOHandleSSL.SSLOptions.RootCertFile := AHorseProviderIOHandleSSL.RootCertFile;\n  LIOHandleSSL.SSLOptions.KeyFile := AHorseProviderIOHandleSSL.KeyFile;\n  LIOHandleSSL.SSLOptions.Method := AHorseProviderIOHandleSSL.Method;\n  LIOHandleSSL.SSLOptions.SSLVersions := AHorseProviderIOHandleSSL.SSLVersions;\n  LIOHandleSSL.SSLOptions.CipherList := AHorseProviderIOHandleSSL.CipherList;\n  LIOHandleSSL.SSLOptions.DHParamsFile := AHorseProviderIOHandleSSL.DHParamsFile;\n  LIOHandleSSL.OnGetPassword := AHorseProviderIOHandleSSL.OnGetPassword;\n  AIdHTTPWebBrokerBridge.IOHandler := LIOHandleSSL;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LAttach: string;\n  LIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n\n  LIdHTTPWebBrokerBridge := GetDefaultHTTPWebBroker;\n  WebRequestHandler.WebModuleClass := WebModuleClass;\n  try\n    if FMaxConnections > 0 then\n    begin\n      WebRequestHandler.MaxConnections := FMaxConnections;\n      GetDefaultHTTPWebBroker.MaxConnections := FMaxConnections;\n    end;\n\n    if FListenQueue = 0 then\n      FListenQueue := IdListenQueueDefault;\n\n    if FHorseProviderIOHandleSSL <> nil then\n      InitServerIOHandlerSSLOpenSSL(LIdHTTPWebBrokerBridge, GetDefaultHorseProviderIOHandleSSL);\n    LIdHTTPWebBrokerBridge.ListenQueue := FListenQueue;\n\n    LIdHTTPWebBrokerBridge.Bindings.Clear;\n    if FHost <> GetDefaultHost then\n    begin\n      LIdHTTPWebBrokerBridge.Bindings.Add;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].IP := FHost;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].Port := FPort;\n    end;\n\n    LIdHTTPWebBrokerBridge.KeepAlive := FKeepConnectionAlive;\n    LIdHTTPWebBrokerBridge.DefaultPort := FPort;\n    LIdHTTPWebBrokerBridge.Active := True;\n    LIdHTTPWebBrokerBridge.StartListening;\n    FRunning := True;\n    DoOnListen;\n\n    if IsConsole then\n    begin\n      while FRunning do\n        GetDefaultEvent.WaitFor();\n    end\n  except\n    on E: Exception do\n    begin\n      if IsConsole then\n      begin\n        Writeln(E.ClassName, ': ', E.Message);\n        Read(LAttach);\n      end\n      else\n{$IF CompilerVersion >= 32.0}\n        raise AcquireExceptionObject;\n{$ELSE}\n        raise;\n{$ENDIF}\n    end;\n  end;\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPWebBrokerIsNil then\n  begin\n    GetDefaultHTTPWebBroker.StopListening;\n    GetDefaultHTTPWebBroker.Active := False;\n    DoOnStopListen;\n    FRunning := False;\n    if FEvent <> nil then\n      GetDefaultEvent.SetEvent;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: String; var VUsername, VPassword: String; var VHandled: Boolean);\nbegin\n  VHandled := True;\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue.Trim;\nend;\n\nclass procedure THorseProvider.SetKeepConnectionAlive(const AValue: Boolean);\nbegin\n  FKeepConnectionAlive := AValue;\nend;\n\nclass procedure THorseProvider.SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL);\nbegin\n  FHorseProviderIOHandleSSL := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetMaxConnections(const AValue: Integer);\nbegin\n  FMaxConnections := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FIdHTTPWebBrokerBridge);\n  if FEvent <> nil then\n    FreeAndNil(FEvent);\nend;\n\ninitialization\n  THorseProvider.SetKeepConnectionAlive(True);\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Net;\nusing System.Linq;\n\nnamespace Horse.Provider.Console\n{\n    \n    public class IdHTTPWebBrokerBridge\n    {\n        public int MaxConnections { get; set; }\n        public int ListenQueue { get; set; }\n        public bool KeepAlive { get; set; }\n        public int DefaultPort { get; set; }\n        public bool Active { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n\n        \n        public Action<string, ref string, ref string, ref bool> OnParseAuthentication { get; set; }\n        public Action<ushort, ref bool> OnQuerySSLPort { get; set; }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine(\"Server started listening on port \" + DefaultPort);\n        }\n\n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"Server stopped listening\");\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        string Method { get; }\n        string SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public string Method => \"TLSv1.2\";\n        public string SSLVersions => \"TLSv1.2\";\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n        public class HorseCore\n    {\n        private static HorseCore _instance;\n        public static HorseCore GetInstance() => _instance ?? (_instance = new HorseCore());\n    }\n\n        public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n\n    public class HorseProvider : HorseProviderAbstract\n    {\n        \n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static EventWaitHandle _event;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static IdHTTPWebBrokerBridge _idHTTPWebBrokerBridge;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => GetMaxConnections(); set => SetMaxConnections(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n        public static bool KeepConnectionAlive { get => GetKeepConnectionAlive(); set => SetKeepConnectionAlive(value); }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetIOHandleSSL(); set => SetIOHandleSSL(value); }\n\n        \n        public override void Listen() => InternalListen();\n        public override void StopListen() => InternalStopListen();\n\n        \n        public static void Listen(int aPort, string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(aCallbackListen);\n            SetOnStopListen(aCallbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, aHost, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(aPort, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        \n        private static IdHTTPWebBrokerBridge GetDefaultHTTPWebBroker()\n        {\n            if (_idHTTPWebBrokerBridge == null)\n            {\n                _idHTTPWebBrokerBridge = new IdHTTPWebBrokerBridge();\n                \n            }\n            return _idHTTPWebBrokerBridge;\n        }\n\n        private static bool HTTPWebBrokerIsNil() => _idHTTPWebBrokerBridge == null;\n\n        private static EventWaitHandle GetDefaultEvent()\n        {\n            if (_event == null)\n                _event = new EventWaitHandle(false, EventResetMode.AutoReset);\n            return _event;\n        }\n\n        private static IHorseProviderIOHandleSSL GetDefaultHorseProviderIOHandleSSL()\n        {\n            if (_horseProviderIOHandleSSL == null)\n                _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New;\n            return _horseProviderIOHandleSSL;\n        }\n\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetHost() => _host;\n        private static bool GetKeepConnectionAlive() => _keepConnectionAlive;\n        private static IHorseProviderIOHandleSSL GetIOHandleSSL() => GetDefaultHorseProviderIOHandleSSL();\n        private static int GetListenQueue() => _listenQueue;\n        private static int GetMaxConnections() => _maxConnections;\n        private static int GetPort() => _port;\n\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static void SetMaxConnections(int value) => _maxConnections = value;\n        private static void SetPort(int value) => _port = value;\n        private static void SetIOHandleSSL(IHorseProviderIOHandleSSL value) => _horseProviderIOHandleSSL = value;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static void SetKeepConnectionAlive(bool value) => _keepConnectionAlive = value;\n\n        \n        private static Action _onListen;\n        private static Action _onStopListen;\n        public static void SetOnListen(Action callback) => _onListen = callback;\n        public static void SetOnStopListen(Action callback) => _onStopListen = callback;\n\n        private static void DoOnListen()\n        {\n            _onListen?.Invoke();\n        }\n\n        private static void DoOnStopListen()\n        {\n            _onStopListen?.Invoke();\n        }\n\n        \n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (GetDefaultHorseProviderIOHandleSSL() != null) && GetDefaultHorseProviderIOHandleSSL().Active;\n        }\n\n        \n        private static void OnAuthentication(object aContext, string aAuthType, string aAuthData, ref string vUsername, ref string vPassword, ref bool vHandled)\n        {\n            vHandled = true;\n        }\n\n        \n        private static void InitServerIOHandlerSSLOpenSSL(IdHTTPWebBrokerBridge bridge, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with certificate: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var bridge = GetDefaultHTTPWebBroker();\n\n            \n\n            try\n            {\n                if (_maxConnections > 0)\n                {\n                    WebRequestHandler.MaxConnections = _maxConnections;\n                    bridge.MaxConnections = _maxConnections;\n                }\n\n                if (_listenQueue == 0)\n                    _listenQueue = HorseConstants.IdListenQueueDefault;\n\n                if (_horseProviderIOHandleSSL != null)\n                    InitServerIOHandlerSSLOpenSSL(bridge, GetDefaultHorseProviderIOHandleSSL());\n\n                bridge.ListenQueue = _listenQueue;\n\n                bridge.Bindings.Clear();\n                if (_host != GetDefaultHost())\n                {\n                    bridge.Bindings.Add(new Binding { IP = _host, Port = _port });\n                }\n\n                bridge.KeepAlive = _keepConnectionAlive;\n                bridge.DefaultPort = _port;\n                bridge.Active = true;\n                bridge.StartListening();\n                _running = true;\n                DoOnListen();\n\n                if (IsConsole())\n                {\n                    while (_running)\n                    {\n                        GetDefaultEvent().WaitOne();\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                if (IsConsole())\n                {\n                    Console.WriteLine($\"{ex.GetType().Name}: {ex.Message}\");\n                    Console.ReadLine();\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPWebBrokerIsNil())\n            {\n                GetDefaultHTTPWebBroker().StopListening();\n                GetDefaultHTTPWebBroker().Active = false;\n                DoOnStopListen();\n                _running = false;\n                if (_event != null)\n                    GetDefaultEvent().Set();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static new void StopListen() => InternalStopListen();\n        public static new void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(aCallbackListen);\n            SetOnStopListen(aCallbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, aHost, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(aPort, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        public static void UnInitialize()\n        {\n            _idHTTPWebBrokerBridge = null;\n            if (_event != null)\n            {\n                _event.Dispose();\n                _event = null;\n            }\n        }\n\n        \n        private static bool IsConsole()\n        {\n            \n            return Environment.UserInteractive && Console.WindowHeight > 0;\n        }\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n    }\n}"}
{"input": "unit Tests.Api.Console;\n\ninterface\n\nuses\n  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,\n  Controllers.Api, Horse, Horse.Jhonson, SysUtils;\n\ntype\n  [TestFixture]\n  TApiTest = class(TObject)\n  private\n    FJSONObject: TJSONObject;\n    FJSONArray: TJSONArray;\n\n    procedure CreateApi;\n    procedure StartApiListen;\n    procedure StartApiListenPort;\n    procedure StartApiListenHost;\n    procedure StartApiListens;\n    procedure StartApiPortListens;\n    procedure StopApiListen;\n    procedure StopApi;\n  public\n    [TearDown]\n    procedure TearDown;\n\n    [Test]\n    procedure TestGet;\n    [Test]\n    [TestCase('Test01', 'POST request test')]\n    procedure TestPost(const AValue: string);\n    [Test]\n    [TestCase('Test01', 'PUT request test')]\n    procedure TestPut(const AValue: string);\n    [Test]\n    [TestCase('Test01', '1')]\n    procedure TestDelete(const AValue: string);\n    [Test]\n    procedure TestGStartApiPortListens;\n    [Test]\n    procedure TestCreateApi;\n    [Test]\n    procedure TestToHorse;\n  end;\n\nimplementation\n\n{ TApiTest }\n\nprocedure TApiTest.StartApiListen;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        THorse\n          .Use(Jhonson);\n\n        Controllers.Api.Registry;\n        THorse.MaxConnections := 10;\n        THorse.Listen;\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListenPort;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(9000);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListenHost;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen('0.0.0.0');\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListens;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(\n          procedure(Horse: THorse)\n          begin\n          end,\n          procedure(Horse: THorse)\n          begin\n          end);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiPortListens;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(9000,\n          procedure(Horse: THorse)\n          begin\n          end,\n          procedure(Horse: THorse)\n          begin\n          end);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StopApiListen;\nbegin\n  THorse.StopListen;\nend;\n\nprocedure TApiTest.StopApi;\nbegin\n  // Warnings have been disabled for this segment as the stop has been depreciated.\n  {$WARNINGS OFF}\n  THorse.StopListen;\n  {$WARNINGS ON}\nend;\n\nprocedure TApiTest.TestGStartApiPortListens;\nbegin\n  StartApiPortListens;\n  StopApi;\nend;\n\nprocedure TApiTest.TestGet;\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListen;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .Get;\n\n  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;\n  Assert.AreEqual(9000, THorse.Port);\n  Assert.AreEqual('0.0.0.0', THorse.Host);\n  Assert.AreEqual(10, THorse.MaxConnections);\n  Assert.AreEqual(LResponse.StatusCode, 200);\n  Assert.AreEqual(FJSONArray.Count, 3);\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestPost(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListenPort;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .AddBody('{\"value\": \"' + AValue + '\"}')\n    .Post;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 201);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not without correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestPut(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListenHost;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .AddBody('{\"value\": \"' + AValue + '\"}')\n    .Put;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 200);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not in the correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestDelete(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListens;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)\n    .Accept('application/json')\n    .Delete;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 200);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not in the correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.CreateApi;\nbegin\n  // Warnings have been disabled for this segment as the create has been depreciated.\n  {$WARNINGS OFF}\n  THorse.Create;\n  {$WARNINGS ON}\nend;\n\nprocedure TApiTest.TearDown;\nbegin\n  FreeAndNil(FJSONObject);\n  FreeAndNil(FJSONArray);\nend;\n\nprocedure TApiTest.TestCreateApi;\nbegin\n  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');\nend;\n\nprocedure TApiTest.TestToHorse;\nbegin\n  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');\nend;\n\ninitialization\n  TDUnitX.RegisterTestFixture(TApiTest);\n\nend.", "output": "using NUnit.Framework;\nusing System;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json.Linq;\nusing RESTRequest4D.Request;\nusing Controllers.Api;\nusing Horse;\nusing Horse.Jhonson;\n\nnamespace Tests.Api.Console\n{\n    [TestFixture]\n    public class TApiTest\n    {\n        private JObject FJSONObject;\n        private JArray FJSONArray;\n\n        private void CreateApi()\n        {\n            Horse.Horse.Create();\n        }\n\n        private void StartApiListen()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Horse.Horse.Use(Jhonson.Jhonson);\n                    Controllers.Api.Registry();\n                    Horse.Horse.MaxConnections = 10;\n                    Horse.Horse.Listen();\n                });\n            }\n        }\n\n        private void StartApiListenPort()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(9000);\n                });\n            }\n        }\n\n        private void StartApiListenHost()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(\"0.0.0.0\");\n                });\n            }\n        }\n\n        private void StartApiListens()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(\n                        (horse) => { },\n                        (horse) => { }\n                    );\n                });\n            }\n        }\n\n        private void StartApiPortListens()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(9000,\n                        (horse) => { },\n                        (horse) => { }\n                    );\n                });\n            }\n        }\n\n        private void StopApiListen()\n        {\n            Horse.Horse.StopListen();\n        }\n\n        private void StopApi()\n        {\n            Horse.Horse.StopListen();\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            FJSONObject?.Dispose();\n            FJSONArray?.Dispose();\n        }\n\n        [Test]\n        public void TestGet()\n        {\n            StartApiListen();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\").Get();\n            FJSONArray = JArray.Parse(response.Content);\n            Assert.AreEqual(9000, Horse.Horse.Port);\n            Assert.AreEqual(\"0.0.0.0\", Horse.Horse.Host);\n            Assert.AreEqual(10, Horse.Horse.MaxConnections);\n            Assert.AreEqual(200, response.StatusCode);\n            Assert.AreEqual(3, FJSONArray.Count);\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"POST request test\")]\n        public void TestPost(string AValue)\n        {\n            StartApiListenPort();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\")\n                .AddBody(\"{\\\"value\\\": \\\"\" + AValue + \"\\\"}\").Post();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(201, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not without correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"PUT request test\")]\n        public void TestPut(string AValue)\n        {\n            StartApiListenHost();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\")\n                .AddBody(\"{\\\"value\\\": \\\"\" + AValue + \"\\\"}\").Put();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(200, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not in the correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"1\")]\n        public void TestDelete(string AValue)\n        {\n            StartApiListens();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test/\" + AValue).Accept(\"application/json\").Delete();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(200, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not in the correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        public void TestGStartApiPortListens()\n        {\n            StartApiPortListens();\n            StopApi();\n        }\n\n        [Test]\n        public void TestCreateApi()\n        {\n            Assert.Throws<Exception>(() => CreateApi(), \"The Horse instance has already been created\");\n        }\n\n        [Test]\n        public void TestToHorse()\n        {\n            Assert.IsNotNull(Horse.Horse.ToModule.ToHorse(), \"Module instance must not be null\");\n        }\n    }\n}"}
{"input": "unit TestControllersU;\n\ninterface\n\nuses MVCFramework.Commons,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n\n  [MVCPath('/')]\n  TSimpleController = class(TMVCController)\n  private\n    FCalledActions: TStringList;\n    procedure AddCall(ActionName: string);\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n\n  public\n    [MVCPath('/')]\n    procedure Index(Context: TWebContext);\n\n    [MVCPath('/orders')]\n    [MVCProduces('application/json')]\n    procedure OrdersProduceJSON(Context: TWebContext);\n\n    [MVCPath('/orders')]\n    procedure Orders(Context: TWebContext);\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure OrderNumber(Context: TWebContext);\n\n    [MVCHTTPMethod([httpPOST, httpPUT])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure UpdateOrderNumber(Context: TWebContext);\n\n    [MVCHTTPMethod([httpPATCH])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure PatchOrder(Context: TWebContext);\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/patient/\\$match')]\n    procedure GetOrderIssue513;\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/patient/\\$match/($par1)/($par2)')]\n    procedure GetOrderIssue513WithPars(par1: string; par2: string);\n\n    property CalledActions: TStringList read FCalledActions; // only for tests\n  end;\n\n  TNotSoSimpleController = class(TMVCController)\n  public\n    procedure Method1(CTX: TWebContext);\n  end;\n\nimplementation\n\n{ TSimpleController }\n\nprocedure TSimpleController.AddCall(ActionName: string);\nbegin\n  FCalledActions.Add(ActionName);\nend;\n\nprocedure TSimpleController.GetOrderIssue513;\nbegin\n  AddCall('GetOrderIssue513');\nend;\n\nprocedure TSimpleController.GetOrderIssue513WithPars(par1, par2: string);\nbegin\n  AddCall('GetOrderIssue513WithPars');\nend;\n\nprocedure TSimpleController.Index(Context: TWebContext);\nbegin\n  AddCall('Index');\nend;\n\nprocedure TSimpleController.MVCControllerAfterCreate;\nbegin\n  inherited;\n  FCalledActions := TStringList.Create;\nend;\n\nprocedure TSimpleController.MVCControllerBeforeDestroy;\nbegin\n  FCalledActions.Free;\n  inherited;\n\nend;\n\nprocedure TSimpleController.Orders(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.OrdersProduceJSON(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.PatchOrder(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.UpdateOrderNumber(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.OrderNumber(Context: TWebContext);\nbegin\n\nend;\n\n{ TNotSoSimpleController }\n\nprocedure TNotSoSimpleController.Method1(CTX: TWebContext);\nbegin\n\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\n\nnamespace TestControllers\n{\n    [MVCPath(\"/\")]\n    public class SimpleController : MVCController\n    {\n        private List<string> _calledActions;\n\n        private void AddCall(string actionName)\n        {\n            _calledActions.Add(actionName);\n        }\n\n        protected override void MVCControllerAfterCreate()\n        {\n            base.MVCControllerAfterCreate();\n            _calledActions = new List<string>();\n        }\n\n        protected override void MVCControllerBeforeDestroy()\n        {\n            _calledActions.Clear();\n            base.MVCControllerBeforeDestroy();\n        }\n\n        [MVCPath(\"/\")]\n        public void Index(TWebContext context)\n        {\n            AddCall(\"Index\");\n        }\n\n        [MVCPath(\"/orders\")]\n        [MVCProduces(\"application/json\")]\n        public void OrdersProduceJSON(TWebContext context)\n        {\n        }\n\n        [MVCPath(\"/orders\")]\n        public void Orders(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void OrderNumber(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"POST,PUT\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void UpdateOrderNumber(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"PATCH\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void PatchOrder(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/patient/$match\")]\n        public void GetOrderIssue513()\n        {\n            AddCall(\"GetOrderIssue513\");\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/patient/$match/($par1)/($par2)\")]\n        public void GetOrderIssue513WithPars(string par1, string par2)\n        {\n            AddCall(\"GetOrderIssue513WithPars\");\n        }\n\n        public List<string> CalledActions\n        {\n            get { return _calledActions; }\n        }\n    }\n\n    public class NotSoSimpleController : MVCController\n    {\n        public void Method1(TWebContext ctx)\n        {\n        }\n    }\n}"}
{"input": "unit Horse.Provider.VCL;\n\ninterface\n\n{$IF DEFINED(HORSE_VCL)}\nuses\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Provider.IOHandleSSL.Contract,\n  IdHTTPWebBrokerBridge,\n  IdSSLOpenSSL,\n  IdContext,\n  Horse.Provider.IOHandleSSL,\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FMaxConnections: Integer;\n    class var FListenQueue: Integer;\n    class var FKeepConnectionAlive: Boolean;\n    class var FIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\n    class var FHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\n    class function GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function HTTPWebBrokerIsNil: Boolean;\n    class procedure OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: string; var VUsername, VPassword: string; var VHandled: Boolean);\n    class procedure OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetMaxConnections(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL); static;\n    class procedure SetHost(const AValue: string); static;\n    class procedure SetKeepConnectionAlive(const AValue: Boolean); static;\n    class function GetKeepConnectionAlive: Boolean; static;\n    class function GetListenQueue: Integer; static;\n    class function GetMaxConnections: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetIOHandleSSL: IHorseProviderIOHandleSSL; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n    class procedure InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property MaxConnections: Integer read GetMaxConnections write SetMaxConnections;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class property KeepConnectionAlive: Boolean read GetKeepConnectionAlive write SetKeepConnectionAlive;\n    class property IOHandleSSL: IHorseProviderIOHandleSSL read GetIOHandleSSL write SetIOHandleSSL;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n    class destructor UnInitialize;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_VCL)}\nuses\n  Web.WebReq,\n  Horse.WebModule,\n  IdCustomTCPServer;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\nbegin\n  if HTTPWebBrokerIsNil then\n  begin\n    FIdHTTPWebBrokerBridge := TIdHTTPWebBrokerBridge.Create(nil);\n    FIdHTTPWebBrokerBridge.OnParseAuthentication := OnAuthentication;\n    FIdHTTPWebBrokerBridge.OnQuerySSLPort := OnQuerySSLPort;\n  end;\n  Result := FIdHTTPWebBrokerBridge;\nend;\n\nclass function THorseProvider.GetKeepConnectionAlive: Boolean;\nbegin\n  Result := FKeepConnectionAlive;\nend;\n\nclass procedure THorseProvider.SetKeepConnectionAlive(const AValue: Boolean);\nbegin\n  FKeepConnectionAlive := AValue;\nend;\n\nclass function THorseProvider.HTTPWebBrokerIsNil: Boolean;\nbegin\n  Result := FIdHTTPWebBrokerBridge = nil;\nend;\n\nclass procedure THorseProvider.OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\nbegin\n  VUseSSL := (FHorseProviderIOHandleSSL <> nil) and (FHorseProviderIOHandleSSL.Active);\nend;\n\nclass function THorseProvider.GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  if FHorseProviderIOHandleSSL = nil then\n    FHorseProviderIOHandleSSL := THorseProviderIOHandleSSL.New;\n  Result := FHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  Result := GetDefaultHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetMaxConnections: Integer;\nbegin\n  Result := FMaxConnections;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\nvar\n  LIOHandleSSL: TIdServerIOHandlerSSLOpenSSL;\nbegin\n  LIOHandleSSL := TIdServerIOHandlerSSLOpenSSL.Create(AIdHTTPWebBrokerBridge);\n  LIOHandleSSL.SSLOptions.CertFile := AHorseProviderIOHandleSSL.CertFile;\n  LIOHandleSSL.SSLOptions.RootCertFile := AHorseProviderIOHandleSSL.RootCertFile;\n  LIOHandleSSL.SSLOptions.KeyFile := AHorseProviderIOHandleSSL.KeyFile;\n  LIOHandleSSL.SSLOptions.Method := AHorseProviderIOHandleSSL.Method;\n  LIOHandleSSL.SSLOptions.SSLVersions := AHorseProviderIOHandleSSL.SSLVersions;\n  LIOHandleSSL.OnGetPassword := AHorseProviderIOHandleSSL.OnGetPassword;\n  AIdHTTPWebBrokerBridge.IOHandler := LIOHandleSSL;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n\n  LIdHTTPWebBrokerBridge := GetDefaultHTTPWebBroker;\n  WebRequestHandler.WebModuleClass := WebModuleClass;\n  try\n    if FMaxConnections > 0 then\n    begin\n      WebRequestHandler.MaxConnections := FMaxConnections;\n      GetDefaultHTTPWebBroker.MaxConnections := FMaxConnections;\n    end;\n\n    if FListenQueue = 0 then\n      FListenQueue := IdListenQueueDefault;\n\n    if FHorseProviderIOHandleSSL <> nil then\n      InitServerIOHandlerSSLOpenSSL(LIdHTTPWebBrokerBridge, GetDefaultHorseProviderIOHandleSSL);\n\n    LIdHTTPWebBrokerBridge.ListenQueue := FListenQueue;\n\n    LIdHTTPWebBrokerBridge.Bindings.Clear;\n    if FHost <> GetDefaultHost then\n    begin\n      LIdHTTPWebBrokerBridge.Bindings.Add;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].IP := FHost;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].Port := FPort;\n    end;\n\n    LIdHTTPWebBrokerBridge.KeepAlive := FKeepConnectionAlive;\n    LIdHTTPWebBrokerBridge.DefaultPort := FPort;\n    LIdHTTPWebBrokerBridge.Active := True;\n    LIdHTTPWebBrokerBridge.StartListening;\n    FRunning := True;\n    DoOnListen;\n  except\n    raise;\n  end;\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPWebBrokerIsNil then\n  begin\n    GetDefaultHTTPWebBroker.Active := False;\n    FRunning := False;\n    DoOnStopListen;\n    GetDefaultHTTPWebBroker.StopListening;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: string; var VUsername, VPassword: string; var VHandled: Boolean);\nbegin\n  VHandled := True;\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue.Trim;\nend;\n\nclass procedure THorseProvider.SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL);\nbegin\n  FHorseProviderIOHandleSSL := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetMaxConnections(const AValue: Integer);\nbegin\n  FMaxConnections := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FIdHTTPWebBrokerBridge);\nend;\n\ninitialization\n  THorseProvider.SetKeepConnectionAlive(True);\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Linq;\n\nnamespace Horse.Provider.VCL\n{\n    #region Stub Types\n\n    public class IdHTTPWebBrokerBridge\n    {\n        public int MaxConnections { get; set; }\n        public int ListenQueue { get; set; }\n        public bool KeepAlive { get; set; }\n        public int DefaultPort { get; set; }\n        public bool Active { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n        public object IOHandler { get; set; }\n        public Action OnParseAuthentication { get; set; }\n        public Action<ushort, ref bool> OnQuerySSLPort { get; set; }\n\n        public IdHTTPWebBrokerBridge()\n        {\n            // Initialize default values if needed.\n        }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"HTTP Web Broker Bridge listening on port {DefaultPort}.\");\n        }\n\n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"HTTP Web Broker Bridge stopped listening.\");\n        }\n    }\n\n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    public class HorseWebModule\n    {\n        // Your web module implementation goes here.\n    }\n\n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        TIdSSLVersion Method { get; }\n        TIdSSLVersions SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    public enum TIdSSLVersion { TLSv1, TLSv1_1, TLSv1_2 }\n    [Flags]\n    public enum TIdSSLVersions { TLSv1 = 1, TLSv1_1 = 2, TLSv1_2 = 4 }\n\n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public TIdSSLVersion Method => TIdSSLVersion.TLSv1_2;\n        public TIdSSLVersions SSLVersions => TIdSSLVersions.TLSv1_2;\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    #endregion\n\n    #region Abstract Base Provider\n\n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n\n        protected static void DoOnListen() => OnListenCallback?.Invoke();\n        protected static void DoOnStopListen() => OnStopListenCallback?.Invoke();\n\n        public static void SetOnListen(Action callback) => OnListenCallback = callback;\n        public static void SetOnStopListen(Action callback) => OnStopListenCallback = callback;\n    }\n\n    #endregion\n\n    #region HorseProvider (VCL)\n\n    public static class HorseProvider : HorseProviderAbstract\n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static IdHTTPWebBrokerBridge _httpWebBrokerBridge;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n\n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => GetMaxConnections(); set => SetMaxConnections(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n        public static bool KeepConnectionAlive { get => GetKeepConnectionAlive(); set => SetKeepConnectionAlive(value); }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetIOHandleSSL(); set => SetIOHandleSSL(value); }\n\n        public override void Listen() => InternalListen();\n\n        public override void StopListen() => InternalStopListen();\n\n        public static void Listen(int aPort, string aHost = \"0.0.0.0\", Action callbackListen = null, Action callbackStopListen = null)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(callbackListen);\n            SetOnStopListen(callbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static int GetMaxConnections() => _maxConnections;\n        private static void SetMaxConnections(int value) => _maxConnections = value;\n        private static bool GetKeepConnectionAlive() => _keepConnectionAlive;\n        private static void SetKeepConnectionAlive(bool value) => _keepConnectionAlive = value;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static IHorseProviderIOHandleSSL GetIOHandleSSL() => _horseProviderIOHandleSSL ?? ( _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New);\n\n        private static IdHTTPWebBrokerBridge GetDefaultHTTPWebBroker()\n        {\n            if (HTTPWebBrokerIsNil())\n            {\n                _httpWebBrokerBridge = new IdHTTPWebBrokerBridge();\n                _httpWebBrokerBridge.OnParseAuthentication = () => OnAuthentication(null, null, null, ref dummyUsername, ref dummyPassword, ref dummyHandled);\n                _httpWebBrokerBridge.OnQuerySSLPort = (port, ref boolUseSSL) => OnQuerySSLPort(port, ref boolUseSSL);\n            }\n            return _httpWebBrokerBridge;\n        }\n\n        private static string dummyUsername = \"\";\n        private static string dummyPassword = \"\";\n        private static bool dummyHandled = false;\n\n        private static bool HTTPWebBrokerIsNil() => _httpWebBrokerBridge == null;\n\n        private static void SetOnListen(Action callback) => SetOnListenCallback(callback);\n        private static void SetOnStopListen(Action callback) => SetOnStopListenCallback(callback);\n        private static void SetOnListenCallback(Action callback) => HorseProviderAbstract.SetOnListen(callback);\n        private static void SetOnStopListenCallback(Action callback) => HorseProviderAbstract.SetOnStopListen(callback);\n\n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (_horseProviderIOHandleSSL != null) && GetIOHandleSSL().Active;\n        }\n\n        private static void OnAuthentication(object aContext, string aAuthType, string aAuthData, ref string vUsername, ref string vPassword, ref bool vHandled)\n        {\n            vHandled = true;\n        }\n\n        private static void InitServerIOHandlerSSLOpenSSL(IdHTTPWebBrokerBridge bridge, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with CertFile: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var bridge = GetDefaultHTTPWebBroker();\n            \n            WebRequestHandler.WebModuleClass = typeof(Horse.WebModule.HorseWebModule);\n            try\n            {\n                if (_maxConnections > 0)\n                {\n                    WebRequestHandler.MaxConnections = _maxConnections;\n                    bridge.MaxConnections = _maxConnections;\n                }\n\n                if (_listenQueue == 0)\n                    _listenQueue = HorseConstants.IdListenQueueDefault;\n\n                if (_horseProviderIOHandleSSL != null)\n                    InitServerIOHandlerSSLOpenSSL(bridge, GetIOHandleSSL());\n\n                bridge.ListenQueue = _listenQueue;\n                bridge.Bindings.Clear();\n                if (_host != GetDefaultHost())\n                {\n                    \n                    bridge.Bindings.Add(new Binding { IP = _host, Port = _port });\n                }\n\n                bridge.KeepAlive = _keepConnectionAlive;\n                bridge.DefaultPort = _port;\n                bridge.Active = true;\n                bridge.StartListening();\n                _running = true;\n                HorseProviderAbstract.DoOnListen();\n            }\n            catch (Exception)\n            {\n                throw;\n            }\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPWebBrokerIsNil())\n            {\n                var bridge = GetDefaultHTTPWebBroker();\n                bridge.Active = false;\n                _running = false;\n                HorseProviderAbstract.DoOnStopListen();\n                bridge.StopListening();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(callbackListen);\n            SetOnStopListen(callbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        class destructor UnInitialize()\n        {\n            _httpWebBrokerBridge = null;\n            return;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.OutputDebugStringAppender;\n\ninterface\n\nuses\n  LoggerPro, System.Classes;\n\ntype\n  { @abstract(This appenders sends logs to the @code(OutputDebugString) function on Windows OSes)\n    To learn how to use this appender, check the sample @code(outputdebugstring_appender.dproj)\n  }\n  TLoggerProOutputDebugStringAppender = class(TLoggerProAppenderBase)\n  private\n    {$IFDEF MSWINDOWS}\n    FModuleName: string;\n    {$ENDIF}\n  public\n    constructor Create(aLogItemRenderer: ILogItemRenderer = nil); override;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.IOUtils\n{$IFDEF MSWINDOWS}\n    , Winapi.Windows\n    , Winapi.Messages\n{$ENDIF}\n  ;\n\n{ TLoggerProOutputDebugStringAppender }\n\nconstructor TLoggerProOutputDebugStringAppender.Create(aLogItemRenderer: ILogItemRenderer);\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.Setup;\nbegin\n  inherited;\n{$IFDEF MSWINDOWS}\n  FModuleName := TPath.GetFileName(GetModuleName(HInstance));\n{$ENDIF}\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.TearDown;\nbegin\n  // do nothing\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.WriteLog(const aLogItem : TLogItem);\n{$IFDEF MSWINDOWS}\nvar\n  lLog: string;\n{$ENDIF}\nbegin\n{$IFDEF MSWINDOWS}\n  lLog := '(' + FModuleName + ') ' + FormatLog(aLogItem);\n  OutputDebugString(PChar(lLog));\n{$ENDIF}\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.IO.Path;\nusing LoggerPro; \n\nnamespace LoggerPro.Appenders\n{\n    \n    public class LoggerProOutputDebugStringAppender : LoggerProAppenderBase, ILogAppender\n    {\n#if WINDOWS\n        private string _moduleName;\n#endif\n\n        public LoggerProOutputDebugStringAppender(ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n        }\n\n        public override void Setup()\n        {\n            base.Setup();\n#if WINDOWS\n            \n            try\n            {\n                string fullPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;\n                _moduleName = Path.GetFileName(fullPath);\n            }\n            catch\n            {\n                _moduleName = \"UnknownModule\";\n            }\n#endif\n        }\n\n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        public override void WriteLog(LogItem logItem)\n        {\n#if WINDOWS\n            \n            string logText = $\"({_moduleName}) {FormatLog(logItem)}\";\n            OutputDebugString(logText);\n#endif\n        }\n\n        \n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]\n        private static extern void OutputDebugString(string lpOutputString);\n    }\n}"}
{"input": "unit WSHelperCustomersU;\n\ninterface\n\nuses\n  BOCustomersU;\n\ntype\n  TWSHelperCustomers = class\n  public\n    function GetCustomers: TCustomers; overload;\n  end;\n\nimplementation\n\nuses\n   System.SysUtils;\n\n{ TWSHelperCustomers }\n\nfunction TWSHelperCustomers.GetCustomers: TCustomers;\nvar\n  Customer: TCustomer;\nbegin\n  Result := TCustomers.Create;\n\n  Customer := TCustomer.Create;\n  Customer.FirstName := 'Joe';\n  Customer.MiddleName := 'M';\n  Customer.Surname := 'Bloggs';\n\n  Result.Add(Customer);\n\n  Customer := TCustomer.Create;\n  Customer.FirstName := 'Mary';\n  Customer.MiddleName := 'J';\n  Customer.Surname := 'Jones';\n\n  Result.Add(Customer);\n\nend;\n\n\nend.", "output": "using BOCustomersU;\n\nnamespace YourNamespace\n{\n    public class WSHelperCustomers\n    {\n        public TCustomers GetCustomers()\n        {\n            TCustomers customers = new TCustomers();\n            TCustomer customer = new TCustomer();\n            customer.FirstName = \"Joe\";\n            customer.MiddleName = \"M\";\n            customer.Surname = \"Bloggs\";\n            customers.Add(customer);\n            customer = new TCustomer();\n            customer.FirstName = \"Mary\";\n            customer.MiddleName = \"J\";\n            customer.Surname = \"Jones\";\n            customers.Add(customer);\n            return customers;\n        }\n    }\n}"}
{"input": "unit CustomersControllerU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Commons,\n  System.Generics.Collections,\n  EntitiesU,\n  CustomerServiceU;\n\ntype\n\n  [MVCPath('/api/customers')]\n  TCustomersController = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethods([httpGET])]\n    function GetCustomers(\n      [MVCFromQueryString('rql','')] RQLFilter: String;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/($ID:sqids)')]\n    [MVCHTTPMethods([httpGET])]\n    function GetCustomerByID(\n      const ID: Integer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/($ID:sqids)')]\n    [MVCHTTPMethods([httpPUT])]\n    function UpdateCustomerByID(\n      const ID: Integer;\n      [MVCFromBody] const Customer: TCustomer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath]\n    [MVCHTTPMethods([httpPOST])]\n    function CreateCustomer(\n      [MVCFromBody] const Customer: TCustomer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/_bulk')]\n    [MVCHTTPMethods([httpPOST])]\n    function BulkCreateCustomers(\n      [MVCFromBody] const Customers: TObjectList<TCustomer>;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TCustomersController }\n\nfunction TCustomersController.CreateCustomer(const Customer: TCustomer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  var lID := CustomersService.CreateCustomer(Customer);\n  Result := CreatedResponse('/api/customers/' + lID.ToString);\nend;\n\nfunction TCustomersController.GetCustomerByID(const ID: Integer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  Result := OKResponse(CustomersService.GetByID(ID));\nend;\n\nfunction TCustomersController.GetCustomers(RQLFilter: String; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  Result := OKResponse(CustomersService.GetByRQL(RQLFilter));\nend;\n\nfunction TCustomersController.UpdateCustomerByID(const ID: Integer; const Customer: TCustomer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  CustomersService.UpdateByID(ID, Customer);\n  Result := OKResponse;\nend;\n\nfunction TCustomersController.BulkCreateCustomers(const Customers: TObjectList<TCustomer>; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  CustomersService.CreateCustomers(Customers);\n  Result := CreatedResponse();\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing EntitiesU;          \nusing CustomerServiceU;  \n\nnamespace CustomersControllerU\n{\n    [Route(\"api/customers\")]\n    [ApiController]\n    public class CustomersController : ControllerBase\n    {\n        \n        [HttpGet]\n        public IActionResult GetCustomers(\n            [FromQuery(Name = \"rql\")] string rqlFilter = \"\",\n            [FromServices] ICustomersService customersService)\n        {\n            var result = customersService.GetByRQL(rqlFilter);\n            return Ok(result);\n        }\n\n        \n        [HttpGet(\"{id}\")]\n        public IActionResult GetCustomerByID(\n            int id,\n            [FromServices] ICustomersService customersService)\n        {\n            var customer = customersService.GetByID(id);\n            return Ok(customer);\n        }\n\n        \n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateCustomerByID(\n            int id,\n            [FromBody] TCustomer customer,\n            [FromServices] ICustomersService customersService)\n        {\n            customersService.UpdateByID(id, customer);\n            return Ok();\n        }\n\n        \n        [HttpPost]\n        public IActionResult CreateCustomer(\n            [FromBody] TCustomer customer,\n            [FromServices] ICustomersService customersService)\n        {\n            var newId = customersService.CreateCustomer(customer);\n            return Created($\"/api/customers/{newId}\", null);\n        }\n\n        \n        [HttpPost(\"_bulk\")]\n        public IActionResult BulkCreateCustomers(\n            [FromBody] List<TCustomer> customers,\n            [FromServices] ICustomersService customersService)\n        {\n            customersService.CreateCustomers(customers);\n            return Created(string.Empty, null);\n        }\n    }\n}"}
{"input": "unit VCLAppendersFormU;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls,\n  LoggerPro,\n  Vcl.ComCtrls,\n  System.ImageList,\n  Vcl.ImgList;\n\ntype\n  TMainForm = class(TForm)\n    Button1: TButton;\n    Button2: TButton;\n    Button3: TButton;\n    Button4: TButton;\n    Button5: TButton;\n    PageControl1: TPageControl;\n    tsListViewAppender: TTabSheet;\n    tsMemoAppender: TTabSheet;\n    Memo1: TMemo;\n    ListView1: TListView;\n    Button6: TButton;\n    procedure Button1Click(Sender: TObject);\n    procedure Button2Click(Sender: TObject);\n    procedure Button3Click(Sender: TObject);\n    procedure Button4Click(Sender: TObject);\n    procedure Button5Click(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n    procedure Button6Click(Sender: TObject);\n  private\n    FLog: ILogWriter;\n    { Private declarations }\n  public\n    function Log: ILogWriter;\n  end;\n\nvar\n  MainForm: TMainForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender,\n  LoggerPro.VCLListViewAppender;\n\n{$R *.dfm}\n\nprocedure TMainForm.Button1Click(Sender: TObject);\nbegin\n  Log.Debug('This is a debug message with TAG1', 'TAG1');\n  Log.Debug('This is a debug message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button2Click(Sender: TObject);\nbegin\n  Log.Info('This is a info message with TAG1', 'TAG1');\n  Log.Info('This is a info message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button3Click(Sender: TObject);\nbegin\n  Log.Warn('This is a warning message with TAG1', 'TAG1');\n  Log.Warn('This is a warning message with TAG2', 'TAG2');\n\nend;\n\nprocedure TMainForm.Button4Click(Sender: TObject);\nbegin\n  Log.Error('This is an error message with TAG1', 'TAG1');\n  Log.Error('This is an error message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button5Click(Sender: TObject);\nvar\n  lThreadProc: TProc;\nbegin\n  lThreadProc := procedure\n    var\n      I: Integer;\n      lThreadID: String;\n    begin\n      lThreadID := IntToStr(TThread.CurrentThread.ThreadID);\n      for I := 1 to 50 do\n      begin\n        Log.Debug('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Info('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Warn('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Error('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Fatal('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n      end;\n    end;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\nend;\n\nprocedure TMainForm.Button6Click(Sender: TObject);\nbegin\n  Log.Fatal('This is a fatal message with TAG1', 'TAG1');\n  Log.Fatal('This is a fatal message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.FormCreate(Sender: TObject);\nbegin\n  // Let's create the local loggers for this form\n  FLog := BuildLogWriter([TVCLListViewAppender.Create(ListView1), TVCLMemoLogAppender.Create(Memo1)])\nend;\n\nfunction TMainForm.Log: ILogWriter;\nbegin\n  Result := FLog;\nend;\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Windows.Forms;\nusing LoggerPro;\nusing LoggerPro.VCLMemoAppender;\nusing LoggerPro.VCLListViewAppender;\n\nnamespace VCLAppenders\n{\n    public partial class MainForm : Form\n    {\n        private ILogWriter _log;\n        public MainForm()\n        {\n            InitializeComponent();\n            Load += MainForm_Load;\n        }\n        private void MainForm_Load(object sender, EventArgs e)\n        {\n            _log = BuildLogWriter(new ILogAppender[] { new VCLListViewAppender(ListView1), new VCLMemoLogAppender(Memo1) });\n        }\n        public ILogWriter Log() => _log;\n        private void Button1_Click(object sender, EventArgs e)\n        {\n            Log().Debug(\"This is a debug message with TAG1\", \"TAG1\");\n            Log().Debug(\"This is a debug message with TAG2\", \"TAG2\");\n        }\n        private void Button2_Click(object sender, EventArgs e)\n        {\n            Log().Info(\"This is a info message with TAG1\", \"TAG1\");\n            Log().Info(\"This is a info message with TAG2\", \"TAG2\");\n        }\n        private void Button3_Click(object sender, EventArgs e)\n        {\n            Log().Warn(\"This is a warning message with TAG1\", \"TAG1\");\n            Log().Warn(\"This is a warning message with TAG2\", \"TAG2\");\n        }\n        private void Button4_Click(object sender, EventArgs e)\n        {\n            Log().Error(\"This is an error message with TAG1\", \"TAG1\");\n            Log().Error(\"This is an error message with TAG2\", \"TAG2\");\n        }\n        private void Button5_Click(object sender, EventArgs e)\n        {\n            Action threadProc = () =>\n            {\n                string threadID = Thread.CurrentThread.ManagedThreadId.ToString();\n                for (int i = 1; i <= 50; i++)\n                {\n                    Log().Debug(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Info(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Warn(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Error(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Fatal(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                }\n            };\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n        }\n        private void Button6_Click(object sender, EventArgs e)\n        {\n            Log().Fatal(\"This is a fatal message with TAG1\", \"TAG1\");\n            Log().Fatal(\"This is a fatal message with TAG2\", \"TAG2\");\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerExceptionU;\n\ninterface\n\nuses\n  MVCFramework, System.SysUtils;\n\ntype\n\n  EMyException = class(Exception)\n\n  end;\n\n  [MVCPath('/exception/aftercreate')]\n  TTestServerControllerExceptionAfterCreate = class(TMVCController)\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n  public\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\n  [MVCPath('/exception/beforedestroy')]\n  TTestServerControllerExceptionBeforeDestroy = class(TMVCController)\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n  public\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\n  [MVCPath('/actionfilters/beforeaction')]\n  TTestServerControllerActionFilters = class(TMVCController)\n  protected\n    procedure OnBeforeAction(Context: TWebContext; const aActionName: string;\n      var Handled: Boolean); override;\n  public\n    [MVCPath('/alwayscalled')]\n    procedure AlwaysCalled(CTX: TWebContext);\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Commons;\n\n{ TTestServerControllerException }\n\nprocedure TTestServerControllerExceptionAfterCreate.MVCControllerAfterCreate;\nbegin\n  inherited;\n  raise EMyException.Create('This is an exception raised in the MVCControllerAfterCreate');\nend;\n\nprocedure TTestServerControllerExceptionAfterCreate.MVCControllerBeforeDestroy;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerControllerExceptionAfterCreate.NeverCalled(CTX: TWebContext);\nbegin\n  Render(500, 'This method should not be called...');\nend;\n\n{ TTestServerControllerExceptionBeforeDestroy }\n\nprocedure TTestServerControllerExceptionBeforeDestroy.MVCControllerAfterCreate;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerControllerExceptionBeforeDestroy.MVCControllerBeforeDestroy;\nbegin\n  inherited;\n  raise EMyException.Create('This is an exception raised in the MVCControllerBeforeDestroy');\nend;\n\nprocedure TTestServerControllerExceptionBeforeDestroy.NeverCalled(CTX: TWebContext);\nbegin\n\nend;\n\n{ TTestServerControllerActionFilters }\n\nprocedure TTestServerControllerActionFilters.AlwaysCalled(CTX: TWebContext);\nbegin\n  StatusCode := 200;\nend;\n\nprocedure TTestServerControllerActionFilters.NeverCalled(CTX: TWebContext);\nbegin\n  raise Exception.Create('Should never be called!');\nend;\n\nprocedure TTestServerControllerActionFilters.OnBeforeAction(\n  Context: TWebContext; const aActionName: string; var Handled: Boolean);\nbegin\n  inherited;\n  if SameText(aActionName, 'NeverCalled') then\n  begin\n    Context.Response.StatusCode := 404;\n    Handled := True;\n  end;\nend;\n\nend.", "output": "using System;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace TestServer.Controllers\n{\n    public class EMyException : Exception\n    {\n        public EMyException(string message) : base(message) { }\n    }\n\n    [Route(\"exception/aftercreate\")]\n    public class TestServerControllerExceptionAfterCreate : ControllerBase\n    {\n        public TestServerControllerExceptionAfterCreate()\n        {\n            MVCControllerAfterCreate();\n        }\n\n        protected virtual void MVCControllerAfterCreate()\n        {\n            throw new EMyException(\"This is an exception raised in the MVCControllerAfterCreate\");\n        }\n\n        protected virtual void MVCControllerBeforeDestroy() { }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            return StatusCode(500, \"This method should not be called...\");\n        }\n    }\n\n    [Route(\"exception/beforedestroy\")]\n    public class TestServerControllerExceptionBeforeDestroy : ControllerBase\n    {\n        protected virtual void MVCControllerAfterCreate() { }\n\n        protected virtual void MVCControllerBeforeDestroy()\n        {\n            throw new EMyException(\"This is an exception raised in the MVCControllerBeforeDestroy\");\n        }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            return Ok();\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                MVCControllerBeforeDestroy();\n            }\n            base.Dispose(disposing);\n        }\n    }\n\n    [Route(\"actionfilters/beforeaction\")]\n    public class TestServerControllerActionFilters : ControllerBase\n    {\n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            if (string.Equals(context.ActionDescriptor.RouteValues[\"action\"], \"NeverCalled\", StringComparison.OrdinalIgnoreCase))\n            {\n                context.Result = new StatusCodeResult(404);\n            }\n            base.OnActionExecuting(context);\n        }\n\n        [HttpGet(\"alwayscalled\")]\n        public IActionResult AlwaysCalled()\n        {\n            Response.StatusCode = 200;\n            return Ok();\n        }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            throw new Exception(\"Should never be called!\");\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Swag.Doc.SecurityDefinitionApiKey;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.JSON,\n  Swag.Common.Types,\n  Swag.Doc.SecurityDefinition;\n\ntype\n  TSwagSecurityDefinitionApiKeyInLocation = (kilNotDefined, kilQuery, kilHeader);\n\ntype\n  /// <summary>\n  /// The security scheme object API key (either as a header or as a query parameter)\n  /// </summary>\n  [ASecurityDefinition(ssdApiKey)]\n  TSwagSecurityDefinitionApiKey = class(TSwagSecurityDefinition)\n  private\n    fName: string;\n    fInLocation: TSwagSecurityDefinitionApiKeyInLocation;\n  protected\n    function GetTypeSecurity: TSwagSecurityDefinitionType; override;\n  public\n    function GenerateJsonObject: TJSONObject; override;\n    procedure Load(pJson: TJSONObject); override;\n    /// <summary>\n    /// Required The location of the API key. Valid values are \"query\" or \"header\".\n    /// </summary>\n    property InLocation: TSwagSecurityDefinitionApiKeyInLocation read fInLocation write fInLocation;\n\n    /// <summary>\n    /// Required. The name of the header or query parameter to be used.\n    /// </summary>\n    property Name: string read fName write fName;\n  end;\n\nimplementation\n\nuses\n  System.Classes;\n\nconst\n  c_SwagSecurityDefinitionApiKeyType = 'type';\n  c_SwagSecurityDefinitionApiKeyDescription = 'description';\n  c_SwagSecurityDefinitionApiKeyIn = 'in';\n  c_SwagSecurityDefinitionApiKeyName = 'name';\n\n  c_SwagSecurityDefinitionApiKeyInLocation: array[TSwagSecurityDefinitionApiKeyInLocation] of string =\n    ('', 'query', 'header');\n\n{ TSwagSecurityDefinitionApiKey }\n\nfunction TSwagSecurityDefinitionApiKey.GenerateJsonObject: TJSONObject;\nvar\n  vJsonItem: TJsonObject;\nbegin\n  vJsonItem := TJsonObject.Create;\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyType, ReturnTypeSecurityToString);\n  if fDescription.Length > 0 then\n    vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyDescription, fDescription);\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyIn, c_SwagSecurityDefinitionApiKeyInLocation[fInLocation]);\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyName, fName);\n\n  Result := vJsonItem;\nend;\n\nfunction TSwagSecurityDefinitionApiKey.GetTypeSecurity: TSwagSecurityDefinitionType;\nbegin\n  Result := ssdApiKey;\nend;\n\nprocedure TSwagSecurityDefinitionApiKey.Load(pJson: TJSONObject);\nvar\n  vIn: string;\nbegin\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyDescription]) then\n    fDescription := pJson.Values[c_SwagSecurityDefinitionApiKeyDescription].Value;\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyName]) then\n    fName := pJson.Values[c_SwagSecurityDefinitionApiKeyName].Value;\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyIn]) then\n  begin\n    vIn := pJson.Values[c_SwagSecurityDefinitionApiKeyIn].Value;\n    if vIn.ToLower = c_SwagSecurityDefinitionApiKeyInLocation[kilQuery] then\n      fInLocation := kilQuery\n    else if vIn.ToLower = c_SwagSecurityDefinitionApiKeyInLocation[kilHeader] then\n      fInLocation := kilHeader\n    else\n      fInLocation := kilNotDefined;\n  end;\nend;\n\ninitialization\n  RegisterClass(TSwagSecurityDefinitionApiKey);\n\nend.", "output": "using System;\nusing System.Text.Json.Nodes;\n\nnamespace Swag.Doc\n{\n    public enum SwagSecurityDefinitionApiKeyInLocation\n    {\n        NotDefined,\n        Query,\n        Header\n    }\n\n    [SecurityDefinition(SwagSecurityDefinitionType.ApiKey)]\n    public class SwagSecurityDefinitionApiKey : SwagSecurityDefinition\n    {\n        private string _name;\n        private SwagSecurityDefinitionApiKeyInLocation _inLocation;\n\n        public override SwagSecurityDefinitionType GetTypeSecurity()\n        {\n            return SwagSecurityDefinitionType.ApiKey;\n        }\n\n        public override JsonObject GenerateJsonObject()\n        {\n            var json = new JsonObject();\n            json[\"type\"] = ReturnTypeSecurityToString();\n            if (!string.IsNullOrEmpty(Description))\n                json[\"description\"] = Description;\n            json[\"in\"] = InLocationToString(_inLocation);\n            json[\"name\"] = _name;\n            return json;\n        }\n\n        public override void Load(JsonObject json)\n        {\n            if (json.TryGetPropertyValue(\"description\", out JsonNode desc))\n                Description = desc.ToString();\n            if (json.TryGetPropertyValue(\"name\", out JsonNode name))\n                _name = name.ToString();\n            if (json.TryGetPropertyValue(\"in\", out JsonNode inNode))\n            {\n                string val = inNode.ToString().ToLower();\n                if (val == \"query\")\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.Query;\n                else if (val == \"header\")\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.Header;\n                else\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.NotDefined;\n            }\n        }\n\n        public SwagSecurityDefinitionApiKeyInLocation InLocation\n        {\n            get => _inLocation;\n            set => _inLocation = value;\n        }\n\n        public string Name\n        {\n            get => _name;\n            set => _name = value;\n        }\n\n        private string InLocationToString(SwagSecurityDefinitionApiKeyInLocation location)\n        {\n            return location switch\n            {\n                SwagSecurityDefinitionApiKeyInLocation.Query => \"query\",\n                SwagSecurityDefinitionApiKeyInLocation.Header => \"header\",\n                _ => \"\"\n            };\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit IntfObjectPoolTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework;\n\ntype\n\n  [TestFixture]\n  TTestTIntfObjectPool = class\n  public\n    [Test]\n    procedure TestFixedSize;\n    [Test]\n    procedure TestGrowing;\n    [Test]\n    procedure TestFactory;\n    [Test]\n    procedure TestMultiThreading;\n    [Test]\n    procedure TestRaiseExceptionWhenPoolIsEmpty;\n    [Test]\n    procedure TestNotRaiseExceptionWhenPoolIsEmpty;\n  end;\n\nimplementation\n\nuses\n  System.Generics.Collections, MVCFramework.IntfObjectPool, System.SysUtils, System.Classes, SyncObjs;\n\nvar\n  GNumReleased: integer;\n\ntype\n  IPoolObject = Interface\n    ['{CA1012E7-5639-48A9-B26B-D94218C28508}']\n  End;\n\ntype\n  TPoolObject = class(TInterfacedObject, IPoolObject)\n  strict private\n    FValue: integer;\n  public\n    constructor Create; overload;\n    constructor Create(value: integer); overload;\n    destructor Destroy; override;\n    property value: integer read FValue;\n  end;\n\ntype\n  TCustomInterfaceCreator = TFunc<IInterface>;\n\n  { TTestTObjectPool }\n\nprocedure TTestTIntfObjectPool.TestFixedSize;\nvar\n  i: integer;\n  lObjs: array [1 .. 5] of IPoolObject;\n  lPool: IIntfObjectPool;\n  lRpt: integer;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreatePool(3, 3, 0, lCustomFactory);\n  for lRpt := 1 to 3 do\n  begin\n    for i := Low(lObjs) to High(lObjs) do\n      lObjs[i] := lPool.GetFromPool as IPoolObject;\n\n    for i := 1 to 3 do\n      Assert.IsTrue(nil <> lObjs[i]);\n    for i := 4 to 5 do\n      Assert.IsTrue(nil = lObjs[i]);\n\n    Assert.IsTrue(lObjs[1] <> lObjs[2]);\n    Assert.IsTrue(lObjs[1] <> lObjs[3]);\n    Assert.IsTrue(lObjs[2] <> lObjs[3]);\n\n    GNumReleased := 0;\n\n    for i := 1 to 3 do\n      lPool.ReleaseToPool(lObjs[i]);\n\n    Assert.AreEqual(0, GNumReleased);\n  end;\n\n  // lPool := nil;\n\n  // Assert.AreEqual(3, GNumReleased);\nend;\n\nprocedure TTestTIntfObjectPool.TestGrowing;\nvar\n  i: integer;\n  lObjs: array [1 .. 5] of IPoolObject;\n  lPool: IIntfObjectPool;\n  lRpt: integer;\n  j: integer;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreateUnlimitedPool(0, 0, lCustomFactory);\n\n  for lRpt := 1 to 3 do\n  begin\n    for i := Low(lObjs) to High(lObjs) do\n    begin\n      lObjs[i] := lPool.GetFromPool as IPoolObject;\n    end;\n\n    for i := 1 to 5 do\n    begin\n      Assert.IsTrue(nil <> lObjs[i]);\n      for j := i + 1 to 5 do\n      begin\n        Assert.IsTrue(lObjs[i] <> lObjs[j]);\n      end;\n    end;\n\n    GNumReleased := 0;\n\n    for i := 1 to 5 do\n    begin\n      lPool.ReleaseToPool(lObjs[i]);\n    end;\n\n    Assert.AreEqual(0, GNumReleased);\n  end;\n  // lPool := nil; //actually releases internal instances\n  // Assert.AreEqual(5, GNumReleased);\nend;\n\nprocedure TTestTIntfObjectPool.TestMultiThreading;\nvar\n  lPool: IIntfObjectPool;\n  i: integer;\n  lCount: Int64;\n  lMax: Int64;\n  lCustomFactory: TCustomInterfaceCreator;\nconst\n  POOL_SIZE = 10;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreatePool(POOL_SIZE, 10, 0, lCustomFactory);\n  lCount := 100;\n  lMax := lCount;\n  for i := 1 to lMax do\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      var\n        j: integer;\n        lObj: IPoolObject;\n      begin\n        for j := 1 to 2 do\n        begin\n          repeat\n            Sleep(1);\n            lObj := lPool.GetFromPool as IPoolObject;\n          until Assigned(lObj);\n          try\n            Sleep(1);\n          finally\n            lPool.ReleaseToPool(lObj);\n          end;\n        end;\n        TInterlocked.Decrement(lCount);\n      end).Start;\n  end;\n\n  while TInterlocked.Read(lCount) > 0 do\n  begin\n    TThread.Sleep(100);\n  end;\n\n  Assert.AreEqual(POOL_SIZE, lPool.Size);\n\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestNotRaiseExceptionWhenPoolIsEmpty;\nvar\n  lPool: IIntfObjectPool;\n  lObj1, lObj2: IPoolObject;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lObj1 := nil;\n  lObj2 := nil;\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(2, 0, 0, lCustomFactory);\n  try\n    lObj1 := lPool.GetFromPool(False) as IPoolObject;\n    lObj2 := lPool.GetFromPool(False) as IPoolObject;\n    Assert.IsNull(lPool.GetFromPool(False));\n  finally\n    lPool.ReleaseToPool(lObj1);\n    lPool.ReleaseToPool(lObj2);\n  end;\n\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestRaiseExceptionWhenPoolIsEmpty;\nvar\n  lPool: IIntfObjectPool;\n  lObj1, lObj2: IPoolObject;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lObj1 := nil;\n  lObj2 := nil;\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(2, 0, 0, lCustomFactory);\n  try\n    lObj1 := lPool.GetFromPool(True) as IPoolObject;\n    lObj2 := lPool.GetFromPool(True) as IPoolObject;\n    Assert.WillRaise(\n      procedure\n      begin\n        lPool.GetFromPool(True);\n      end, EObjectPool);\n  finally\n    lPool.ReleaseToPool(lObj1);\n    lPool.ReleaseToPool(lObj2);\n  end;\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestFactory;\nvar\n  lPoolObject: IPoolObject;\n  lPool: TIntfObjectPool;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(0, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(1, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lPool := TIntfObjectPool.Create(3, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(1, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create(79);\n    end;\n\n  lPool := TIntfObjectPool.Create(0, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(79, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lPool := TIntfObjectPool.Create(3, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(79, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\nend;\n\n{ TPoolObject }\n\nconstructor TPoolObject.Create;\nbegin\n  Create(1);\nend;\n\nconstructor TPoolObject.Create(value: integer);\nbegin\n  inherited Create;\n  FValue := value;\nend;\n\ndestructor TPoolObject.Destroy;\nbegin\n  Inc(GNumReleased);\n  inherited;\nend;\n\ninitialization\n\nGObjectPoolSamplingIntervalMS := 1000;\nTDUnitX.RegisterTestFixture(TTestTIntfObjectPool);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace Horse.Request\n{\n    #region Stub Types and Helpers\n\n    public class WebRequest\n    {\n        public string Content { get; set; } = \"\";\n        public byte[] RawContent { get; set; } = new byte[0];\n        public string Host { get; set; } = \"\";\n        public string ContentType { get; set; } = \"\";\n        public string PathInfo { get; set; } = \"\";\n        public List<WebFile> Files { get; set; } = new List<WebFile>();\n        public Dictionary<string, string> ContentFields { get; set; } = new Dictionary<string, string>();\n        public List<string> CookieFields { get; set; } = new List<string>();\n        public List<string> QueryFields { get; set; } = new List<string>();\n\n        public TWebRequestMethod MethodType { get; set; } = TWebRequestMethod.GET;\n        public string Method { get; set; } = \"GET\";\n    }\n\n    public class WebFile\n    {\n        public string FieldName { get; set; }\n        public Stream Stream { get; set; }\n    }\n\n    public enum TWebRequestMethod\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH,\n        OPTIONS\n    }\n\n    public class HorseCoreParam\n    {\n        public Dictionary<string, string> Dictionary { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public HorseCoreParam(List<string> list)\n        {\n            // Optionally use 'list' if needed.\n        }\n\n        public HorseCoreParam Required(bool req)\n        {\n            return this;\n        }\n\n        public void AddStream(string fieldName, Stream stream)\n        {\n            // Implementation depends on your requirements.\n            \n        }\n    }\n\n    public static class HorseCoreParamHeader\n    {\n        public static HorseCoreParam GetHeaders(WebRequest request)\n        {\n            return new HorseCoreParam(new List<string>());\n        }\n    }\n\n    public class HorseSessions\n    {\n        // Implement session handling as needed.\n    }\n\n    #endregion\n\n    public class HorseRequest : IDisposable\n    {\n        private WebRequest _webRequest;\n        private HorseCoreParam _headers;\n        private HorseCoreParam _query;\n        private HorseCoreParam _params;\n        private HorseCoreParam _contentFields;\n        private HorseCoreParam _cookie;\n        private object _body;\n        private object _session;\n        private HorseSessions _sessions;\n\n        public HorseRequest(WebRequest webRequest)\n        {\n            _webRequest = webRequest;\n            _sessions = new HorseSessions();\n        }\n\n        public virtual string Body()\n        {\n            return _webRequest.Content;\n        }\n\n        public T Body<T>() where T : class\n        {\n            return _body as T;\n        }\n\n        public virtual HorseRequest Body(object body)\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _body = body;\n            return this;\n        }\n\n        public virtual string Body(Encoding encoding)\n        {\n            if (_webRequest.RawContent != null && _webRequest.RawContent.Length > 0)\n            {\n                return encoding.GetString(_webRequest.RawContent);\n            }\n            else\n            {\n                return _webRequest.Content;\n            }\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        public virtual HorseCoreParam Headers()\n        {\n            if (_headers == null)\n            {\n                _headers = new HorseCoreParam(HorseCoreParamHeader.GetHeaders(_webRequest).Dictionary.ToList()).Required(false);\n            }\n            return _headers;\n        }\n\n        public virtual HorseCoreParam Query()\n        {\n            if (_query == null)\n                InitializeQuery();\n            return _query;\n        }\n\n        public virtual HorseCoreParam Params()\n        {\n            if (_params == null)\n                InitializeParams();\n            return _params;\n        }\n\n        public virtual HorseCoreParam Cookie()\n        {\n            if (_cookie == null)\n                InitializeCookie();\n            return _cookie;\n        }\n\n        public virtual HorseCoreParam ContentFields()\n        {\n            if (_contentFields == null)\n                InitializeContentFields();\n            return _contentFields;\n        }\n\n        public virtual HorseSessions Sessions()\n        {\n            return _sessions;\n        }\n\n        public virtual TWebRequestMethod MethodType()\n        {\n            return _webRequest.MethodType;\n        }\n\n        public virtual string ContentType()\n        {\n            return _webRequest.ContentType;\n        }\n\n        public virtual string Host()\n        {\n            return _webRequest.Host;\n        }\n\n        public virtual string PathInfo()\n        {\n            string prefix = string.IsNullOrEmpty(_webRequest.PathInfo) ? \"/\" : \"/\";\n            return prefix + _webRequest.PathInfo;\n        }\n\n        public virtual WebRequest RawWebRequest()\n        {\n            return _webRequest;\n        }\n\n        #region Initialization Methods\n\n        private void InitializeQuery()\n        {\n            _query = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var item in _webRequest.QueryFields)\n            {\n                int equalPos = item.IndexOf('=');\n                if (equalPos > 0)\n                {\n                    string key = item.Substring(0, equalPos);\n                    string value = item.Substring(equalPos + 1);\n                    if (!_query.Dictionary.ContainsKey(key))\n                        _query.Dictionary[key] = value;\n                    else\n                        _query.Dictionary[key] = _query.Dictionary[key] + \",\" + value;\n                }\n            }\n        }\n\n        private void InitializeParams()\n        {\n            _params = new HorseCoreParam(new List<string>()).Required(true);\n        }\n\n        private void InitializeContentFields()\n        {\n            _contentFields = new HorseCoreParam(new List<string>()).Required(false);\n            if (!CanLoadContentFields())\n                return;\n\n            foreach (var file in _webRequest.Files)\n            {\n                _contentFields.AddStream(file.FieldName, file.Stream);\n            }\n\n            foreach (var kvp in _webRequest.ContentFields)\n            {\n                string name = kvp.Key;\n                string value = kvp.Value;\n                if (!string.IsNullOrEmpty(name))\n                    _contentFields.Dictionary[name] = value;\n            }\n        }\n\n        private void InitializeCookie()\n        {\n            _cookie = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var cookieField in _webRequest.CookieFields)\n            {\n                var parts = cookieField.Split(new[] { '=' }, 2);\n                if (parts.Length >= 2)\n                    _cookie.Dictionary[parts[0]] = parts[1];\n            }\n        }\n\n        private bool CanLoadContentFields()\n        {\n            return IsMultipartForm() || IsFormURLEncoded();\n        }\n\n        private bool IsFormURLEncoded()\n        {\n            string contentType = _webRequest.ContentType;\n            string formUrlEncoded = \"application/x-www-form-urlencoded\";\n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(formUrlEncoded, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private bool IsMultipartForm()\n        {\n            string contentType = _webRequest.ContentType;\n            string multipart = \"multipart/form-data\";\n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(multipart, StringComparison.OrdinalIgnoreCase);\n        }\n\n        #endregion\n\n        public virtual HorseRequest Body(string body)\n        {\n            _body = body;\n            return this;\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public virtual T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        public override string ToString()\n        {\n            return Body();\n        }\n\n        public void Dispose()\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n        }\n    }\n}"}
{"input": "unit PersonBO;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Commons;\n\ntype\n  [MVCNameCase(ncCamelCase)]\n  TPerson = class\n  private\n    FWORK_PHONE_NUMBER: String;\n    FEMAIL: String;\n    FFIRST_NAME: String;\n    FID: Integer;\n    FMOBILE_PHONE_NUMBER: String;\n    FLAST_NAME: String;\n    procedure SetEMAIL(const Value: String);\n    procedure SetFIRST_NAME(const Value: String);\n    procedure SetID(const Value: Integer);\n    procedure SetLAST_NAME(const Value: String);\n    procedure SetMOBILE_PHONE_NUMBER(const Value: String);\n    procedure SetWORK_PHONE_NUMBER(const Value: String);\n  public\n    property ID: Integer read FID write SetID;\n    property FIRST_NAME: String read FFIRST_NAME write SetFIRST_NAME;\n    property LAST_NAME: String read FLAST_NAME write SetLAST_NAME;\n    property WORK_PHONE_NUMBER: String read FWORK_PHONE_NUMBER write SetWORK_PHONE_NUMBER;\n    property MOBILE_PHONE_NUMBER: String read FMOBILE_PHONE_NUMBER write SetMOBILE_PHONE_NUMBER;\n    property EMAIL: String read FEMAIL write SetEMAIL;\n  end;\n\nimplementation\n\n{ TPerson }\n\nprocedure TPerson.SetEMAIL(const Value: String);\nbegin\n  FEMAIL := Value;\nend;\n\nprocedure TPerson.SetFIRST_NAME(const Value: String);\nbegin\n  FFIRST_NAME := Value;\nend;\n\nprocedure TPerson.SetID(const Value: Integer);\nbegin\n  FID := Value;\nend;\n\nprocedure TPerson.SetLAST_NAME(const Value: String);\nbegin\n  FLAST_NAME := Value;\nend;\n\nprocedure TPerson.SetMOBILE_PHONE_NUMBER(const Value: String);\nbegin\n  FMOBILE_PHONE_NUMBER := Value;\nend;\n\nprocedure TPerson.SetWORK_PHONE_NUMBER(const Value: String);\nbegin\n  FWORK_PHONE_NUMBER := Value;\nend;\n\nend.", "output": "[JsonProperty(\"id\")]\n    public int ID\n    {\n        get => _id;\n        set => _id = value;\n    }\n\n    [JsonProperty(\"firstName\")]\n    public string FIRST_NAME\n    {\n        get => _firstName;\n        set => _firstName = value;\n    }\n\n    [JsonProperty(\"lastName\")]\n    public string LAST_NAME\n    {\n        get => _lastName;\n        set => _lastName = value;\n    }\n\n    [JsonProperty(\"workPhoneNumber\")]\n    public string WORK_PHONE_NUMBER\n    {\n        get => _workPhoneNumber;\n        set => _workPhoneNumber = value;\n    }\n\n    [JsonProperty(\"mobilePhoneNumber\")]\n    public string MOBILE_PHONE_NUMBER\n    {\n        get => _mobilePhoneNumber;\n        set => _mobilePhoneNumber = value;\n    }\n\n    [JsonProperty(\"email\")]\n    public string EMAIL\n    {\n        get => _email;\n        set => _email = value;\n    }\n}"}
{"input": "unit Services.RegistrationU;\n\ninterface\n\nuses\n  MVCFramework.Container;\n\nprocedure RegisterServices(Container: IMVCServiceContainer);\n\nimplementation\n\nuses\n  Services.PeopleU, Services.InterfacesU, Services.ConnectionU;\n\nprocedure RegisterServices(Container: IMVCServiceContainer);\nbegin\n  Container.RegisterType(TPeopleService, IPeopleService);\n  Container.RegisterType(TConnectionService, IConnectionService, TRegistrationType.SingletonPerRequest)\nend;\n\nend.", "output": "using MVCFramework.Container;\nusing Services.PeopleU;\nusing Services.InterfacesU;\nusing Services.ConnectionU;\n\nnamespace Services.RegistrationU\n{\n    public static class ServicesRegistration\n    {\n        public static void RegisterServices(IMVCServiceContainer container)\n        {\n            container.RegisterType<IPeopleService, PeopleService>();\n            container.RegisterType<IConnectionService, ConnectionService>(RegistrationType.SingletonPerRequest);\n        }\n    }\n}"}
{"input": "unit BusinessObjectsU;\n\ninterface\n\ntype\n  TPerson = class\n  private\n    FLastName: String;\n    FDOB: TDate;\n    FFirstName: String;\n    FMarried: boolean;\n    procedure SetDOB(const Value: TDate);\n    procedure SetFirstName(const Value: String);\n    procedure SetLastName(const Value: String);\n    procedure SetMarried(const Value: boolean);\n  public\n    property FirstName: String read FFirstName write SetFirstName;\n    property LastName: String read FLastName write SetLastName;\n    property DOB: TDate read FDOB write SetDOB;\n    property Married: boolean read FMarried write SetMarried;\n  end;\n\nimplementation\n\n{ TPerson }\n\nprocedure TPerson.SetDOB(const Value: TDate);\nbegin\n  FDOB := Value;\nend;\n\nprocedure TPerson.SetFirstName(const Value: String);\nbegin\n  FFirstName := Value;\nend;\n\nprocedure TPerson.SetLastName(const Value: String);\nbegin\n  FLastName := Value;\nend;\n\nprocedure TPerson.SetMarried(const Value: boolean);\nbegin\n  FMarried := Value;\nend;\n\nend.", "output": "using System;\n\nnamespace BusinessObjectsU\n{\n    public class Person\n    {\n        private string _firstName;\n        private string _lastName;\n        private DateTime _dob;\n        private bool _married;\n\n        public string FirstName\n        {\n            get => _firstName;\n            set => SetFirstName(value);\n        }\n\n        public string LastName\n        {\n            get => _lastName;\n            set => SetLastName(value);\n        }\n\n        public DateTime DOB\n        {\n            get => _dob;\n            set => SetDOB(value);\n        }\n\n        public bool Married\n        {\n            get => _married;\n            set => SetMarried(value);\n        }\n\n        private void SetFirstName(string value)\n        {\n            _firstName = value;\n        }\n\n        private void SetLastName(string value)\n        {\n            _lastName = value;\n        }\n\n        private void SetDOB(DateTime value)\n        {\n            _dob = value;\n        }\n\n        private void SetMarried(bool value)\n        {\n            _married = value;\n        }\n    }\n}"}
{"input": "unit Horse.Response;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  fpHTTP,\n  HTTPDefs,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$IF CompilerVersion > 32.0}\n  Web.ReqMulti,\n{$ENDIF}\n{$ENDIF}\n  Horse.Commons,\n  Horse.Core.Files,\n  Horse.Mime;\n\ntype\n  THorseResponse = class\n  private\n    FWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF};\n    FContent: TObject;\n  public\n    function Send(const AContent: string): THorseResponse; overload; virtual;\n    function Send<T{$IF NOT DEFINED(FPC)}: class{$ENDIF}>(AContent: T): THorseResponse; overload;\n    function RedirectTo(const ALocation: string): THorseResponse; overload; virtual;\n    function RedirectTo(const ALocation: string; const AStatus: THTTPStatus): THorseResponse; overload; virtual;\n    function Status(const AStatus: Integer): THorseResponse; overload; virtual;\n    function Status(const AStatus: THTTPStatus): THorseResponse; overload; virtual;\n    function SendFile(const AFileStream: TStream; const AFileName: string = ''; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function SendFile(const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Download(const AFileStream: TStream; const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Download(const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Render(const AFileStream: TStream; const AFileName: string): THorseResponse; overload; virtual;\n    function Render(const AFileName: string): THorseResponse; overload; virtual;\n    function Status: Integer; overload; virtual;\n    function AddHeader(const AName, AValue: string): THorseResponse; virtual;\n    function RemoveHeader(const AName: string): THorseResponse; virtual;\n    function Content: TObject; overload; virtual;\n    function Content(const AContent: TObject): THorseResponse; overload; virtual;\n    function ContentType(const AContentType: string): THorseResponse; virtual;\n    function RawWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; virtual;\n    constructor Create(const AWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF});\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseResponse.AddHeader(const AName, AValue: string): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader(AName, AValue);\n  Result := Self;\nend;\n\nfunction THorseResponse.Content(const AContent: TObject): THorseResponse;\nbegin\n  Result := Self;\n  FContent := AContent;\nend;\n\nfunction THorseResponse.Content: TObject;\nbegin\n  Result := FContent;\nend;\n\nfunction THorseResponse.ContentType(const AContentType: string): THorseResponse;\nbegin\n  FWebResponse.ContentType := AContentType;\n  Result := Self;\nend;\n\nconstructor THorseResponse.Create(const AWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF});\nbegin\n  FWebResponse := AWebResponse;\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := THTTPStatus.Ok.ToInteger;\n{$IF DEFINED(FPC)}\n  FWebResponse.FreeContentStream := True;\n{$ENDIF}\nend;\n\ndestructor THorseResponse.Destroy;\nbegin\n  if Assigned(FContent) then\n    FContent.Free;\n  inherited;\nend;\n\nfunction THorseResponse.RawWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF};\nbegin\n  Result := FWebResponse;\nend;\n\nfunction THorseResponse.Send(const AContent: string): THorseResponse;\nbegin\n  FWebResponse.Content := AContent;\n  Result := Self;\nend;\n\nfunction THorseResponse.Send<T>(AContent: T): THorseResponse;\nbegin\n  FContent := AContent;\n  Result := Self;\nend;\n\nfunction THorseResponse.RedirectTo(const ALocation: string): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader('Location', ALocation);\n  Result := Status(THTTPStatus.SeeOther);\nend;\n\nfunction THorseResponse.RedirectTo(const ALocation: string; const AStatus: THTTPStatus): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader('Location', ALocation);\n  Result := Status(AStatus);\nend;\n\nfunction THorseResponse.RemoveHeader(const AName: string): THorseResponse;\nvar\n  I: Integer;\nbegin\n  I := FWebResponse.CustomHeaders.IndexOfName(AName);\n  if I <> -1 then\n    FWebResponse.CustomHeaders.Delete(I);\n  Result := Self;\nend;\n\nfunction THorseResponse.Status(const AStatus: THTTPStatus): THorseResponse;\nbegin\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := AStatus.ToInteger;\n  Result := Self;\nend;\n\nfunction THorseResponse.SendFile(const AFileStream: TStream; const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFileName: string;\nbegin\n  Result := Self;\n  AFileStream.Position := 0;\n  LFileName := ExtractFileName(AFileName);\n\n  FWebResponse.FreeContentStream := False;\n  FWebResponse.ContentLength := AFileStream.Size;\n  FWebResponse.ContentStream := AFileStream;\n  FWebResponse.SetCustomHeader('Content-Disposition', Format('inline; filename=\"%s\"', [LFileName]));\n\n  FWebResponse.ContentType := AContentType;\n  if (AContentType = EmptyStr) then\n    FWebResponse.ContentType := Horse.Mime.THorseMimeTypes.GetFileType(LFileName);\n\n{$IF DEFINED(FPC)}\n  FWebResponse.SendContent;\n{$ELSE}\n  FWebResponse.SendResponse;\n{$ENDIF}\nend;\n\nfunction THorseResponse.SendFile(const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFile: THorseCoreFile;\n  LContentType: string;\nbegin\n  Result := Self;\n\n  LFile := THorseCoreFile.Create(AFileName);\n  LFile.FreeContentStream := True;\n  try\n    LContentType := AContentType;\n    if (AContentType = EmptyStr) then\n      LContentType := LFile.ContentType;\n    SendFile(LFile.ContentStream, LFile.Name, LContentType);\n  finally\n    LFile.Free;\n  end;\nend;\n\nfunction THorseResponse.Download(const AFileStream: TStream; const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFileName: string;\nbegin\n  Result := Self;\n  AFileStream.Position := 0;\n  LFileName := ExtractFileName(AFileName);\n\n  FWebResponse.FreeContentStream := False;\n  FWebResponse.ContentLength := AFileStream.Size;\n  FWebResponse.ContentStream := AFileStream;\n  FWebResponse.SetCustomHeader('Content-Disposition', Format('attachment; filename=\"%s\"', [LFileName]));\n\n  FWebResponse.ContentType := AContentType;\n  if (AContentType = EmptyStr) then\n    FWebResponse.ContentType := Horse.Mime.THorseMimeTypes.GetFileType(LFileName);\n\n{$IF DEFINED(FPC)}\n  FWebResponse.SendContent;\n{$ELSE}\n  FWebResponse.SendResponse;\n{$ENDIF}\nend;\n\nfunction THorseResponse.Download(const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFile: THorseCoreFile;\n  LContentType: string;\nbegin\n  Result := Self;\n\n  LFile := THorseCoreFile.Create(AFileName);\n  LFile.FreeContentStream := True;\n  try\n    LContentType := AContentType;\n    if (AContentType = EmptyStr) then\n      LContentType := LFile.ContentType;\n    Download(LFile.ContentStream, LFile.Name, LContentType);\n  finally\n    LFile.Free;\n  end;\nend;\n\nfunction THorseResponse.Render(const AFileStream: TStream;\n  const AFileName: string): THorseResponse;\nbegin\n  Result := Self;\n  SendFile(AFileStream, AFileName, Horse.Commons.TMimeTypes.TextHTML.ToString);\nend;\n\nfunction THorseResponse.Render(const AFileName: string): THorseResponse;\nbegin\n  Result := Self;\n  SendFile(AFileName, Horse.Commons.TMimeTypes.TextHTML.ToString);\nend;\n\nfunction THorseResponse.Status: Integer;\nbegin\n  Result := {$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF};\nend;\n\nfunction THorseResponse.Status(const AStatus: Integer): THorseResponse;\nbegin\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := AStatus;\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing Horse.Core.Files;      \nusing Horse.Mime;           \n\nnamespace Horse.Response\n{\n    \n    public class WebResponse\n    {\n        public string Content { get; set; }\n        public int StatusCode { get; set; }\n        public string ContentType { get; set; }\n        public long ContentLength { get; set; }\n        public Stream ContentStream { get; set; }\n        public bool FreeContentStream { get; set; }\n        public Dictionary<string, string> CustomHeaders { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public void SetCustomHeader(string name, string value)\n        {\n            CustomHeaders[name] = value;\n        }\n\n        public void SendResponse()\n        {\n            \n            Console.WriteLine(\"Response sent.\");\n        }\n    }\n\n    \n    public enum THTTPStatus\n    {\n        Ok = 200,\n        SeeOther = 303,\n        \n    }\n\n    public static class THTTPStatusExtensions\n    {\n        public static int ToInteger(this THTTPStatus status) => (int)status;\n    }\n\n    public class HorseResponse : IDisposable\n    {\n        private WebResponse _webResponse;\n        private object _content; \n\n        public HorseResponse(WebResponse webResponse)\n        {\n            _webResponse = webResponse;\n            _webResponse.StatusCode = THTTPStatus.Ok.ToInteger();\n            \n            _webResponse.FreeContentStream = true;\n        }\n\n        \n        public HorseResponse AddHeader(string name, string value)\n        {\n            _webResponse.SetCustomHeader(name, value);\n            return this;\n        }\n\n        \n        public HorseResponse Content(object content)\n        {\n            _content = content;\n            return this;\n        }\n\n        public object Content() => _content;\n\n       \n        public HorseResponse ContentType(string contentType)\n        {\n            _webResponse.ContentType = contentType;\n            return this;\n        }\n\n        \n        public WebResponse RawWebResponse() => _webResponse;\n\n        \n        public HorseResponse Send(string content)\n        {\n            _webResponse.Content = content;\n            return this;\n        }\n\n        \n        public HorseResponse Send<T>(T content) where T : class\n        {\n            _content = content;\n            return this;\n        }\n\n        \n        public HorseResponse RedirectTo(string location)\n        {\n            _webResponse.SetCustomHeader(\"Location\", location);\n            return Status(THTTPStatus.SeeOther);\n        }\n\n        \n        public HorseResponse RedirectTo(string location, THTTPStatus status)\n        {\n            _webResponse.SetCustomHeader(\"Location\", location);\n            return Status(status);\n        }\n\n        \n        public HorseResponse RemoveHeader(string name)\n        {\n            if (_webResponse.CustomHeaders.ContainsKey(name))\n                _webResponse.CustomHeaders.Remove(name);\n            return this;\n        }\n\n        \n        public HorseResponse Status(int status)\n        {\n            _webResponse.StatusCode = status;\n            return this;\n        }\n\n        \n        public HorseResponse Status(THTTPStatus status)\n        {\n            _webResponse.StatusCode = status.ToInteger();\n            return this;\n        }\n\n        \n        public HorseResponse SendFile(Stream fileStream, string fileName, string contentType)\n        {\n            fileStream.Position = 0;\n            string lFileName = System.IO.Path.GetFileName(fileName);\n            _webResponse.FreeContentStream = false;\n            _webResponse.ContentLength = fileStream.Length;\n            _webResponse.ContentStream = fileStream;\n            _webResponse.SetCustomHeader(\"Content-Disposition\", string.Format(\"inline; filename=\\\"{0}\\\"\", lFileName));\n            _webResponse.ContentType = contentType;\n            if (string.IsNullOrEmpty(contentType))\n                _webResponse.ContentType = Horse.Mime.HorseMimeTypes.GetFileType(lFileName);\n            _webResponse.SendResponse();\n            return this;\n        }\n\n        \n        public HorseResponse SendFile(string fileName, string contentType)\n        {\n            using (var file = new HorseCoreFile(fileName))\n            {\n                file.FreeContentStream = true;\n                string lContentType = contentType;\n                if (string.IsNullOrEmpty(contentType))\n                    lContentType = Horse.Mime.HorseMimeTypes.GetFileType(file.Name);\n                return SendFile(file.ContentStream, file.Name, lContentType);\n            }\n        }\n\n        \n        public HorseResponse Download(Stream fileStream, string fileName, string contentType)\n        {\n            fileStream.Position = 0;\n            string lFileName = System.IO.Path.GetFileName(fileName);\n            _webResponse.FreeContentStream = false;\n            _webResponse.ContentLength = fileStream.Length;\n            _webResponse.ContentStream = fileStream;\n            _webResponse.SetCustomHeader(\"Content-Disposition\", string.Format(\"attachment; filename=\\\"{0}\\\"\", lFileName));\n            _webResponse.ContentType = contentType;\n            if (string.IsNullOrEmpty(contentType))\n                _webResponse.ContentType = Horse.Mime.HorseMimeTypes.GetFileType(lFileName);\n            _webResponse.SendResponse();\n            return this;\n        }\n\n        \n        public HorseResponse Download(string fileName, string contentType)\n        {\n            using (var file = new HorseCoreFile(fileName))\n            {\n                file.FreeContentStream = true;\n                string lContentType = contentType;\n                if (string.IsNullOrEmpty(contentType))\n                    lContentType = Horse.Mime.HorseMimeTypes.GetFileType(file.Name);\n                return Download(file.ContentStream, file.Name, lContentType);\n            }\n        }\n\n        \n        public HorseResponse Render(Stream fileStream, string fileName)\n        {\n            return SendFile(fileStream, fileName, Horse.Commons.TMimeTypes.TextHTML.ToString());\n        }\n\n        \n        public HorseResponse Render(string fileName)\n        {\n            return SendFile(fileName, Horse.Commons.TMimeTypes.TextHTML.ToString());\n        }\n\n        \n        public int Status() => _webResponse.StatusCode;\n\n        public void Dispose()\n        {\n            if (_content is IDisposable disposable)\n            {\n                disposable.Dispose();\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Cache;\n\n{$I dmvcframework.inc}\n\ninterface\n\nimplementation\n\nend.", "output": "namespace MVCFramework.View\n{\n    \n    public static class Cache\n    {\n        // No implementation provided.\n    }\n}"}
{"input": "unit SSEControllerU;\n\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.SSEController;\n\ntype\n  [MVCPath('/stocks')]\n  TMySSEController = class(TMVCSSEController)\n  protected\n    function GetServerSentEvents(const LastEventID: String): TMVCSSEMessages; override;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger, System.SysUtils, StorageU, System.DateUtils;\n\n{ TMySSEController }\n\nfunction TMySSEController.GetServerSentEvents(const LastEventID: String): TMVCSSEMessages;\nvar\n  lCurrentEventID: Integer;\n  lSSEMessage: TSSEMessage;\nbegin\n  Sleep(500 + Random(2000));\n  lSSEMessage.Event := 'stockupdate';\n  lSSEMessage.Data := GetNextDataToSend(StrToIntDef(LastEventID, 0), lCurrentEventID);\n  lSSEMessage.Id := lCurrentEventID.ToString;\n  Result := [\n    lSSEMessage\n  ];\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.SSEController;\nusing StorageU;\n\n[Route(\"stocks\")]\npublic class MySSEController : MVCSSEController\n{\n    protected override List<SSEMessage> GetServerSentEvents(string lastEventId)\n    {\n        Thread.Sleep(500 + new Random().Next(2000));\n        int currentEventId;\n        SSEMessage sseMessage = new SSEMessage();\n        sseMessage.Event = \"stockupdate\";\n        sseMessage.Data = Storage.GetNextDataToSend(ParseIntOrDefault(lastEventId, 0), out currentEventId);\n        sseMessage.Id = currentEventId.ToString();\n        return new List<SSEMessage> { sseMessage };\n    }\n\n    private int ParseIntOrDefault(string s, int defaultValue)\n    {\n        return int.TryParse(s, out int result) ? result : defaultValue;\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ActiveRecordController;\n\ninterface\n\nuses\n  System.SysUtils,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.ActiveRecord,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Comp.Client,\n  MVCFramework.RQL.Parser,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Commons, MVCFramework.Swagger.Commons;\n\ntype\n{$SCOPEDENUMS ON}\n  TMVCActiveRecordAction = (Create, Retrieve, Update, Delete);\n  TMVCActiveRecordAuthFunc = TFunc<TWebContext, TMVCActiveRecordClass, TMVCActiveRecordAction, Boolean>;\n\n  TMVCActiveRecordController = class(TMVCController)\n  private\n    fAuthorization: TMVCActiveRecordAuthFunc;\n    fURLSegment: string;\n  protected\n    function GetMaxRecordCount: Integer;\n    function CheckAuthorization(aClass: TMVCActiveRecordClass; aAction: TMVCActiveRecordAction): Boolean; virtual;\n  public\n    constructor Create(\n      const aAuthorization: TMVCActiveRecordAuthFunc = nil;\n      const aURLSegment: String = ''); reintroduce; overload;\n    destructor Destroy; override;\n\n    function GetURLSegment: String;\n\n    [MVCPath('/($entityname)')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Retrieve a list of {singularmodel}', 'Get{pluralmodel}')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntities(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/searches')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Searches through {pluralmodel} and returns a list of {singularmodel}', 'Get{pluralmodel}BySearch')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntitiesByRQL(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/searches')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Searches through {pluralmodel} and returns a list of {singularmodel}', 'Get{pluralmodel}BySearchAsPOST')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntitiesByRQLwithPOST(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Gets a {singularmodel} entity or 404 not found', 'Get{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'One {singularmodel}', SWAGUseDefaultControllerModel)]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    procedure GetEntity(const entityname: string; const id: Integer); virtual;\n\n    [MVCPath('/($entityname)')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Creates a {singularmodel} and returns a new id', 'Create{singularmodel}')]\n    [MVCSwagResponses(HTTP_STATUS.Created, 'One {singularmodel}', '')]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plBody, '{singularmodel}', 'A single entity of type {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, True)]\n    procedure CreateEntity(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Updates a {singularmodel} by id', 'Update{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'One {singularmodel}', SWAGUseDefaultControllerModel)]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plBody, '{singularmodel}', 'A single entity of type {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, True)]\n    procedure UpdateEntity(const entityname: string; const id: Integer); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Deletes a {singularmodel} by id', 'Delete{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.NoContent, '')]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    procedure DeleteEntity(const entityname: string; const id: Integer); virtual;\n\n  end;\n\n  [MVCNameCase(ncLowerCase)]\n  TMVCActiveRecordListResponse = class\n  private\n    FList: TMVCActiveRecordList;\n    FMetadata: TMVCStringDictionary;\n    FOwns: Boolean;\n  public\n    constructor Create(AList: TMVCActiveRecordList; AOwns: Boolean = True); virtual;\n    destructor Destroy; override;\n    [MVCListOf(TMVCActiveRecord)]\n    [MVCNameAs('data')]\n    property Items: TMVCActiveRecordList read FList;\n    [MVCNameAs('meta')]\n    property Metadata: TMVCStringDictionary read FMetadata;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger,\n  JsonDataObjects,\n  Data.DB;\n\nprocedure TMVCActiveRecordController.GetEntities(const entityname: string);\nvar\n  lARClassRef: TMVCActiveRecordClass;\n  lRQL: string;\n  lInstance: TMVCActiveRecord;\n  lMapping: TMVCFieldsMapping;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\n  lARResp: TMVCActiveRecordList;\n  lStrDict : TMVCStringDictionary;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.GetEntities(Context, self, entityname, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClassRef) then\n  begin\n    raise EMVCException.CreateFmt('Cannot find entity nor processor for entity \"%s\"', [entityname]);\n  end;\n  if not CheckAuthorization(lARClassRef, TMVCActiveRecordAction.Retrieve) then\n  begin\n    Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot read ' + entityname));\n    Exit;\n  end;\n\n  lRQL := Context.Request.QueryStringParam('rql');\n  try\n    LogD('[RQL PARSE]: ' + lRQL);\n    lInstance := lARClassRef.Create(True);\n    try\n      lMapping := lInstance.GetMapping;\n    finally\n      lInstance.Free;\n    end;\n\n    lARResp := TMVCActiveRecord.SelectRQL(lARClassRef, lRQL, GetMaxRecordCount);\n    try\n      lStrDict := StrDict(['page_size'],[lARResp.Count.ToString]);\n      try\n        if Context.Request.QueryStringParam('count').ToLower = 'true' then\n        begin\n          lStrDict.Add('count', TMVCActiveRecord.Count(lARClassRef, lRQL).ToString);\n        end;\n        Render(ObjectDict(False)\n          .Add('data', lARResp,\n            procedure(const AObject: TObject; const Links: IMVCLinks)\n            begin\n              //Links.AddRefLink.Add(HATEOAS.HREF, fURLSegment + '/' + )\n              case TMVCActiveRecord(AObject).GetPrimaryKeyFieldType of\n                ftInteger:\n                  Links.AddRefLink.Add(HATEOAS.HREF, fURLSegment + '/' + TMVCActiveRecord(AObject).GetPK.AsInt64.ToString)\n              end;\n            end)\n          .Add('meta', lStrDict));\n      finally\n        lStrDict.Free;\n      end;\n    finally\n      lARResp.Free;\n    end;\n\n  except\n    on E: ERQLCompilerNotFound do\n    begin\n      LogE('RQL Compiler not found. Did you included MVCFramework.RQL.AST2<yourdatabase>.pas?');\n      raise;\n    end;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.GetEntitiesByRQL(const entityname: string);\nbegin\n  GetEntities(entityname);\nend;\n\nprocedure TMVCActiveRecordController.GetEntitiesByRQLwithPOST(const entityname: string);\nvar\n  lRQL: string;\n  lJSON: TJsonObject;\nbegin\n  lJSON := TJsonObject.Parse(Context.Request.Body) as TJsonObject;\n  try\n    if Assigned(lJSON) then\n    begin\n      lRQL := lJSON.s['rql'];\n    end\n    else\n    begin\n      lRQL := '';\n    end;\n  finally\n    lJSON.Free;\n  end;\n  Context.Request.QueryStringParams.Values['rql'] := lRQL;\n  GetEntities(entityname);\nend;\n\n\nprocedure TMVCActiveRecordController.GetEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\n  lResponse: IMVCResponse;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.GetEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Retrieve) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot read ' + entityname));\n      Exit;\n    end;\n\n    if lAR.LoadByPK(id) then\n    begin\n      lResponse := MVCResponseBuilder\n          .StatusCode(HTTP_STATUS.OK)\n          .Body(ObjectDict(false).Add('data', lAR))\n          .Build;\n    end\n    else\n    begin\n      lResponse := MVCResponseBuilder\n          .StatusCode(HTTP_STATUS.NotFound)\n          .Body(entityname.ToLower + ' not found')\n          .Build;\n    end;\n    TMVCRenderer.InternalRenderMVCResponse(Self, TMVCResponse(lResponse));\n  finally\n    lAR.Free;\n  end;\nend;\n\nfunction TMVCActiveRecordController.GetMaxRecordCount: Integer;\nbegin\n  Result := StrToIntDef(Config[TMVCConfigKey.MaxEntitiesRecordCount], 20);\nend;\n\nfunction TMVCActiveRecordController.GetURLSegment: String;\nbegin\n  Result := fURLSegment;\nend;\n\nfunction TMVCActiveRecordController.CheckAuthorization(aClass: TMVCActiveRecordClass;\n  aAction: TMVCActiveRecordAction): Boolean;\nbegin\n  if Assigned(fAuthorization) then\n  begin\n    Result := fAuthorization(Context, aClass, aAction);\n  end\n  else\n  begin\n    Result := True;\n  end;\nend;\n\nconstructor TMVCActiveRecordController.Create(\n  const aAuthorization: TMVCActiveRecordAuthFunc;\n  const aURLSegment: String);\nbegin\n  inherited Create;\n  fURLSegment := aURLSegment;\n  fAuthorization := aAuthorization;\nend;\n\nprocedure TMVCActiveRecordController.CreateEntity(const entityname: string);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.CreateEntity(Context, self, entityname, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Create) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot create ' + entityname));\n      Exit;\n    end;\n\n    Context.Request.BodyFor<TMVCActiveRecord>(lAR);\n    lAR.Insert;\n    Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo + '/' + lAR.GetPK.AsInt64.ToString;\n    if Context.Request.QueryStringParam('refresh').ToLower = 'true' then\n    begin\n      RenderStatusMessage(HTTP_STATUS.Created, entityname.ToLower + ' created', '', lAR, False);\n    end\n    else\n    begin\n      RenderStatusMessage(HTTP_STATUS.Created, entityname.ToLower + ' created');\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.UpdateEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.UpdateEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find class for entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Update) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot update ' + entityname));\n      Exit;\n    end;\n    lAR.CheckAction(TMVCEntityAction.eaUpdate);\n    if not lAR.LoadByPK(id) then\n      raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n    Context.Request.BodyFor<TMVCActiveRecord>(lAR);\n    lAR.SetPK(id);\n    lAR.Update;\n    Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo;\n    if Context.Request.QueryStringParam('refresh').ToLower = 'true' then\n    begin\n      RenderStatusMessage(HTTP_STATUS.OK, entityname.ToLower + ' updated', '', lAR, False);\n    end\n    else\n    begin\n      RenderStatusMessage(HTTP_STATUS.OK, entityname.ToLower + ' updated');\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.DeleteEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.DeleteEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find class for entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType),\n      TMVCActiveRecordAction.Delete) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot delete ' + entityname));\n      Exit;\n    end;\n    {\n      HTTP DELETE is an idempotent operation. Invoking it multiple times consecutively must result in\n      the same behavior as the first. Meaning: you shouldn't return HTTP 404.\n    }\n    if lAR.LoadByPK(id) then\n    begin\n      lAR.SetPK(id);\n      lAR.Delete;\n    end;\n    Render(HTTP_STATUS.OK, entityname.ToLower + ' deleted');\n  finally\n    lAR.Free;\n  end;\nend;\n\ndestructor TMVCActiveRecordController.Destroy;\nbegin\n  inherited;\nend;\n\n{ TObjectListSetHolder }\n\nconstructor TMVCActiveRecordListResponse.Create(AList: TMVCActiveRecordList; AOwns: Boolean = True);\nbegin\n  inherited Create;\n  FOwns := AOwns;\n  FList := AList;\n  FMetadata := TMVCStringDictionary.Create;\nend;\n\ndestructor TMVCActiveRecordListResponse.Destroy;\nbegin\n  if FOwns then\n  begin\n    FList.Free\n  end;\n  FMetadata.Free;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MVCFramework.ActiveRecord; \nusing MVCFramework.Commons;\nusing MVCFramework.Swagger.Commons; \n\nnamespace MVCFramework.ActiveRecordController\n{\n    \n    public delegate bool MVCActiveRecordAuthFunc(\n        WebContext context, \n        Type activeRecordType, \n        MVCActiveRecordAction action);\n\n    \n    public enum MVCActiveRecordAction\n    {\n        Create,\n        Retrieve,\n        Update,\n        Delete\n    }\n\n    \n    [ApiController]\n    [Route(\"[controller]\")]\n    public class MVCActiveRecordController : ControllerBase\n    {\n        private readonly ILogger<MVCActiveRecordController> _logger;\n        private readonly MVCActiveRecordAuthFunc _authorization;\n        private readonly string _urlSegment;\n\n        public MVCActiveRecordController(ILogger<MVCActiveRecordController> logger,\n                                           MVCActiveRecordAuthFunc authorization = null,\n                                           string urlSegment = \"\")\n        {\n            _logger = logger;\n            _authorization = authorization;\n            _urlSegment = urlSegment;\n        }\n\n        protected virtual int GetMaxRecordCount()\n        {\n            \n            return 20;\n        }\n\n        protected virtual bool CheckAuthorization(Type activeRecordType, MVCActiveRecordAction action)\n        {\n            if (_authorization != null)\n            {\n                return _authorization(new WebContext(HttpContext), activeRecordType, action);\n            }\n            return true;\n        }\n\n        [HttpGet(\"{entityname}\")]\n        public IActionResult GetEntities(string entityname)\n        {\n            try\n            {\n                \n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.GetEntities(new WebContext(HttpContext), this, entityname, ref handled);\n                    if (handled)\n                    {\n                        return Ok();\n                    }\n                }\n\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity nor processor for entity '{entityname}'.\");\n                }\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Retrieve))\n                {\n                    return Forbid(\"Not authorized to read \" + entityname);\n                }\n\n                string rql = Request.Query[\"rql\"];\n                _logger.LogDebug(\"[RQL PARSE]: {RQL}\", rql);\n\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType, true);\n                var mapping = arInstance.GetMapping();\n\n                var arList = MVCActiveRecord.SelectRQL(arType, rql, GetMaxRecordCount());\n\n                var meta = new Dictionary<string, string>\n                {\n                    [\"page_size\"] = arList.Count.ToString()\n                };\n                if (Request.Query[\"count\"].ToString().ToLower() == \"true\")\n                {\n                    meta.Add(\"count\", MVCActiveRecord.Count(arType, rql).ToString());\n                }\n\n                var response = new\n                {\n                    data = arList,\n                    meta = meta\n                };\n                return Ok(response);\n            }\n            catch (RQLCompilerNotFoundException ex)\n            {\n                _logger.LogError(ex, \"RQL Compiler not found. Did you include the appropriate RQL parser?\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error retrieving entities for {EntityName}\", entityname);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpGet(\"{entityname}/searches\")]\n        public IActionResult GetEntitiesByRQL(string entityname)\n        {\n            return GetEntities(entityname);\n        }\n\n        [HttpPost(\"{entityname}/searches\")]\n        public IActionResult GetEntitiesByRQLwithPOST(string entityname, [FromBody] dynamic body)\n        {\n            string rql = body?.rql ?? \"\";\n            Request.QueryString = new Microsoft.AspNetCore.Http.QueryString(\"?rql=\" + Uri.EscapeDataString(rql));\n            return GetEntities(entityname);\n        }\n\n        [HttpGet(\"{entityname}/{id:int}\")]\n        public IActionResult GetEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.GetEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Retrieve))\n                {\n                    return Forbid(\"Not authorized to read \" + entityname);\n                }\n                if (arInstance.LoadByPK(id))\n                {\n                    return Ok(new { data = arInstance });\n                }\n                else\n                {\n                    return NotFound($\"{entityname.ToLower()} not found\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error retrieving entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"{entityname}\")]\n        public IActionResult CreateEntity(string entityname)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.CreateEntity(new WebContext(HttpContext), this, entityname, ref handled);\n                    if (handled)\n                        return Created(\"\", null);\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Create))\n                {\n                    return Forbid(\"Not authorized to create \" + entityname);\n                }\n\n                Request.BindBody(arInstance);\n\n                arInstance.Insert();\n                Response.Headers[\"X-REF\"] = $\"{Request.Path}/{arInstance.GetPK().ToString()}\";\n                if (Request.Query[\"refresh\"].ToString().ToLower() == \"true\")\n                {\n                    return Created(Request.Path, arInstance);\n                }\n                else\n                {\n                    return Created(Request.Path, null);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating entity {EntityName}\", entityname);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPut(\"{entityname}/{id:int}\")]\n        public IActionResult UpdateEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.UpdateEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find class for entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Update))\n                {\n                    return Forbid(\"Not authorized to update \" + entityname);\n                }\n                if (!arInstance.LoadByPK(id))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                Request.BindBody(arInstance);\n                arInstance.SetPK(id);\n                arInstance.Update();\n                Response.Headers[\"X-REF\"] = Request.Path;\n                if (Request.Query[\"refresh\"].ToString().ToLower() == \"true\")\n                {\n                    return Ok(new { data = arInstance });\n                }\n                else\n                {\n                    return Ok($\"{entityname.ToLower()} updated\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpDelete(\"{entityname}/{id:int}\")]\n        public IActionResult DeleteEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.DeleteEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find class for entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Delete))\n                {\n                    return Forbid(\"Not authorized to delete \" + entityname);\n                }\n                if (arInstance.LoadByPK(id))\n                {\n                    arInstance.SetPK(id);\n                    arInstance.Delete();\n                }\n                return Ok($\"{entityname.ToLower()} deleted\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n    }\n\n    \n    public class MVCActiveRecordListResponse\n    {\n        public TMVCActiveRecordList Items { get; }\n        public Dictionary<string, string> Metadata { get; }\n        public bool Owns { get; }\n\n        public MVCActiveRecordListResponse(TMVCActiveRecordList list, bool owns = true)\n        {\n            Items = list;\n            Owns = owns;\n            Metadata = new Dictionary<string, string>();\n        }\n    }\n\n    #region Stub Types and Extensions\n\n    \n    public class WebContext\n    {\n        public Microsoft.AspNetCore.Http.HttpContext HttpContext { get; }\n        public WebContext(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            HttpContext = httpContext;\n        }\n    }\n\n    \n    public class ActiveRecordMappingRegistry\n    {\n        private static readonly ActiveRecordMappingRegistry _instance = new ActiveRecordMappingRegistry();\n        public static ActiveRecordMappingRegistry Instance => _instance;\n\n        private readonly Dictionary<string, Type> _entityMap = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private readonly Dictionary<string, IMVCEntityProcessor> _processorMap = new Dictionary<string, IMVCEntityProcessor>(StringComparer.OrdinalIgnoreCase);\n\n        public bool TryGetEntityClass(string urlSegment, out Type activeRecordType)\n        {\n            return _entityMap.TryGetValue(urlSegment.ToLower(), out activeRecordType);\n        }\n\n        public bool TryGetProcessor(string urlSegment, out IMVCEntityProcessor processor)\n        {\n            return _processorMap.TryGetValue(urlSegment.ToLower(), out processor);\n        }\n\n        \n    }\n\n    \n    public class TMVCActiveRecordList : List<MVCActiveRecord>\n    {\n    }\n\n    \n    public static class RequestExtensions\n    {\n        public static void BindBody<T>(this Microsoft.AspNetCore.Http.HttpRequest request, T instance)\n        {\n            \n            // This is just a stub.\n        }\n    }\n\n    #endregion\n}"}
{"input": "unit MainWMU;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TMyWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMyWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  LogsCollectorControllerU,\n  System.IOUtils,\n  MVCFramework.Commons;\n\nprocedure TMyWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      Config[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'false';\n    end);\n  FMVC.AddController(TLogsCollectorController);\nend;\n\nprocedure TMyWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing System;\n\nnamespace MyWebModuleApp\n{\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            \n            var builder = WebApplication.CreateBuilder(args);\n\n            \n            builder.Services.AddControllersWithViews();\n\n            \n            var app = builder.Build();\n\n            if (!app.Environment.IsDevelopment())\n            {\n                app.UseExceptionHandler(\"/Home/Error\");\n            }\n\n            app.UseStaticFiles();\n\n            app.UseRouting();\n\n            app.MapControllerRoute(\n                name: \"default\",\n                pattern: \"{controller=LogsCollector}/{action=Index}/{id?}\");\n\n            app.MapGet(\"/\", () => \"Welcome to the Municipal Logs Collector API\");\n\n            Console.WriteLine(\"Web module started on: \");\n            foreach (var url in app.Urls)\n            {\n                Console.WriteLine(url);\n            }\n\n            app.Run();\n        }\n    }\n}"}
{"input": "unit Horse.Request;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  fpHTTP,\n  HTTPDefs,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$IF CompilerVersion > 32.0}\n  Web.ReqMulti,\n{$ENDIF}\n{$ENDIF}\n  Horse.Core.Param,\n  Horse.Core.Param.Header,\n  Horse.Commons,\n  Horse.Session;\n\ntype\n  THorseRequest = class\n  private\n    FWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\n    FHeaders: THorseCoreParam;\n    FQuery: THorseCoreParam;\n    FParams: THorseCoreParam;\n    FContentFields: THorseCoreParam;\n    FCookie: THorseCoreParam;\n    FBody: TObject;\n    FSession: TObject;\n    FSessions: THorseSessions;\n    procedure InitializeQuery;\n    procedure InitializeParams;\n    procedure InitializeContentFields;\n    procedure InitializeCookie;\n    function IsMultipartForm: Boolean;\n    function IsFormURLEncoded: Boolean;\n    function CanLoadContentFields: Boolean;\n  public\n    function Body: string; overload; virtual;\n    function Body<T: class>: T; overload;\n    function Body(const ABody: TObject): THorseRequest; overload; virtual;\n    function Body(const Encoding: TEncoding): string; overload; virtual;\n    function Session<T: class>: T; overload;\n    function Session(const ASession: TObject): THorseRequest; overload; virtual;\n    function Headers: THorseCoreParam; virtual;\n    function Query: THorseCoreParam; virtual;\n    function Params: THorseCoreParam; virtual;\n    function Cookie: THorseCoreParam; virtual;\n    function ContentFields: THorseCoreParam; virtual;\n    function Sessions: THorseSessions; virtual;\n    function MethodType: TMethodType; virtual;\n    function ContentType: string; virtual;\n    function Host: string; virtual;\n    function PathInfo: string; virtual;\n    function RawWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}; virtual;\n    constructor Create(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF});\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseRequest.Body: string;\nbegin\n  Result := FWebRequest.Content;\nend;\n\nfunction THorseRequest.Body(const ABody: TObject): THorseRequest;\nbegin\n  Result := Self;\n  if Assigned(FBody) then\n    FBody.Free;\n  FBody := ABody;\nend;\n\nfunction THorseRequest.Body(const Encoding: TEncoding): string;\n{$IF DEFINED(FPC)}\nvar\n  lContent: TStringStream;\n{$ENDIF}\nbegin\n  {$IF DEFINED(FPC)}\n  try\n    lContent := TStringStream.Create(FWebRequest.Content, Encoding);\n    Result   := lContent.DataString;\n  finally\n    lContent.Free;\n  end;\n  {$ELSE}\n  {$IF CompilerVersion <= 31.0}\n  Result := Encoding.GetString(BytesOf(FWebRequest.RawContent));\n  {$ELSE}\n  Result := Encoding.GetString(FWebRequest.RawContent);\n  {$ENDIF}\n  {$ENDIF}\nend;\n\nfunction THorseRequest.Body<T>: T;\nbegin\n  Result := T(FBody);\nend;\n\nfunction THorseRequest.CanLoadContentFields: Boolean;\nbegin\n  Result := IsMultipartForm or IsFormURLEncoded;\nend;\n\nfunction THorseRequest.ContentFields: THorseCoreParam;\nbegin\n  if not Assigned(FContentFields) then\n    InitializeContentFields;\n  Result := FContentFields;\nend;\n\nfunction THorseRequest.Cookie: THorseCoreParam;\nbegin\n  if not Assigned(FCookie) then\n    InitializeCookie;\n  Result := FCookie;\nend;\n\nconstructor THorseRequest.Create(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF});\nbegin\n  FWebRequest := AWebRequest;\n  FSessions := THorseSessions.Create;\nend;\n\ndestructor THorseRequest.Destroy;\nbegin\n  if Assigned(FHeaders) then\n    FreeAndNil(FHeaders);\n  if Assigned(FQuery) then\n    FreeAndNil(FQuery);\n  if Assigned(FParams) then\n    FreeAndNil(FParams);\n  if Assigned(FContentFields) then\n    FreeAndNil(FContentFields);\n  if Assigned(FCookie) then\n    FreeAndNil(FCookie);\n  if Assigned(FBody) then\n    FBody.Free;\n  if Assigned(FSessions) then\n    FSessions.Free;\n  inherited;\nend;\n\nfunction THorseRequest.Headers: THorseCoreParam;\nvar\n  LParam: THorseList;\nbegin\n  if not Assigned(FHeaders) then\n  begin\n    LParam := THorseCoreParamHeader.GetHeaders(FWebRequest);\n    FHeaders := THorseCoreParam.Create(LParam).Required(False);\n  end;\n  Result := FHeaders;\nend;\n\nfunction THorseRequest.Host: string;\nbegin\n  Result := FWebRequest.Host;\nend;\n\nfunction THorseRequest.ContentType: string;\nbegin\n  Result := FWebRequest.ContentType;\nend;\n\nfunction THorseRequest.PathInfo: string;\nvar\n  LPrefix: string;\nbegin\n  LPrefix := EmptyStr;\n  if FWebRequest.PathInfo = EmptyStr then\n    LPrefix := '/';\n  Result := LPrefix + FWebRequest.PathInfo;\nend;\n\nprocedure THorseRequest.InitializeContentFields;\n{$IF NOT DEFINED(FPC)}\nconst\n  CONTENT_DISPOSITION = 'Content-Disposition: form-data; name=';\n{$ENDIF}\nvar\n  I: Integer;\n  LName: String;\n  LValue: String;\nbegin\n  FContentFields := THorseCoreParam.Create(THorseList.Create).Required(False);\n  if (not CanLoadContentFields) then\n    Exit;\n\n  for I := 0 to Pred(FWebRequest.Files.Count) do\n    FContentFields.AddStream(FWebRequest.Files[I].FieldName, FWebRequest.Files[I].Stream);\n\n  for I := 0 to Pred(FWebRequest.ContentFields.Count) do\n  begin\n    if IsMultipartForm then\n    begin\n{$IF DEFINED(FPC)}\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n{$ELSE}\n{$IF CompilerVersion <= 31.0}\n      if FWebRequest.ContentFields[I].StartsWith(CONTENT_DISPOSITION) then\n      begin\n        LName := FWebRequest.ContentFields[I]\n          .Replace(CONTENT_DISPOSITION, EmptyStr)\n          .Replace('\"', EmptyStr);\n        LValue := FWebRequest.ContentFields[I + 1];\n      end;\n{$ELSE}\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n{$ENDIF}\n{$ENDIF}\n    end\n    else\n    begin\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n    end;\n\n    if LName <> EmptyStr then\n      FContentFields.Dictionary.AddOrSetValue(LName, LValue);\n\n    LName := EmptyStr;\n    LValue := EmptyStr;\n  end;\nend;\n\nprocedure THorseRequest.InitializeCookie;\nconst\n  KEY = 0;\n  VALUE = 1;\nvar\n  LParam: TArray<string>;\n  LItem: string;\nbegin\n  FCookie := THorseCoreParam.Create(THorseList.Create).Required(False);\n  for LItem in FWebRequest.CookieFields do\n  begin\n    LParam := LItem.Split(['=']);\n    FCookie.Dictionary.AddOrSetValue(LParam[KEY], LParam[VALUE]);\n  end;\nend;\n\nprocedure THorseRequest.InitializeParams;\nbegin\n  FParams := THorseCoreParam.Create(THorseList.Create).Required(True);\nend;\n\nprocedure THorseRequest.InitializeQuery;\nvar\n  LItem, LKey, LValue: string;\n  LEqualFirstPos: Integer;\nbegin\n  FQuery := THorseCoreParam.Create(THorseList.Create).Required(False);\n  for LItem in FWebRequest.QueryFields do\n  begin\n    LEqualFirstPos := Pos('=', LItem);\n    LKey := Copy(LItem, 1, LEqualFirstPos - 1);\n    LValue := Copy(LItem, LEqualFirstPos + 1, Length(LItem));\n    if not FQuery.Dictionary.ContainsKey(LKey) then\n      FQuery.Dictionary.AddOrSetValue(LKey, LValue)\n    else\n      FQuery.Dictionary[LKey] := FQuery.Dictionary[LKey] +','+ LValue;\n  end;\nend;\n\nfunction THorseRequest.IsFormURLEncoded: Boolean;\nvar\n  LContentType, LFormUrlEncoded: string;\nbegin\n  LContentType := FWebRequest.ContentType;\n  LFormUrlEncoded := TMimeTypes.ApplicationXWWWFormURLEncoded.ToString;\n{$IF DEFINED(FPC)}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormUrlEncoded), Length(LFormUrlEncoded)) = 0;\n{$ELSE}\n{$IF CompilerVersion <= 30}\n  Result := LContentType = PChar(LFormUrlEncoded);\n{$ELSE}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormUrlEncoded), Length(LFormUrlEncoded)) = 0;\n{$IFEND}\n{$ENDIF}\nend;\n\nfunction THorseRequest.IsMultipartForm: Boolean;\nvar\n  LContentType, LFormData: string;\nbegin\n  LContentType := FWebRequest.ContentType;\n  LFormData := TMimeTypes.MultiPartFormData.ToString;\n{$IF DEFINED(FPC)}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormData), Length(PChar(LFormData))) = 0;\n{$ELSE}\n{$IF CompilerVersion <= 30}\n  Result := LContentType = PChar(LFormData);\n{$ELSE}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormData), Length(PChar(LFormData))) = 0;\n{$IFEND}\n{$ENDIF}\nend;\n\nfunction THorseRequest.MethodType: TMethodType;\nbegin\n  Result := {$IF DEFINED(FPC)}StringCommandToMethodType(FWebRequest.Method); {$ELSE}FWebRequest.MethodType; {$ENDIF}\nend;\n\nfunction THorseRequest.Params: THorseCoreParam;\nbegin\n  if not Assigned(FParams) then\n    InitializeParams;\n  Result := FParams;\nend;\n\nfunction THorseRequest.Query: THorseCoreParam;\nbegin\n  if not Assigned(FQuery) then\n    InitializeQuery;\n  Result := FQuery;\nend;\n\nfunction THorseRequest.RawWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\nbegin\n  Result := FWebRequest;\nend;\n\nfunction THorseRequest.Session(const ASession: TObject): THorseRequest;\nbegin\n  Result := Self;\n  FSession := ASession;\nend;\n\nfunction THorseRequest.Session<T>: T;\nbegin\n  Result := T(FSession);\nend;\n\nfunction THorseRequest.Sessions: THorseSessions;\nbegin\n  Result := FSessions;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace Horse.Request\n{\n    #region Stub Types and Helpers\n\n    \n    public class WebRequest\n    {\n        public string Content { get; set; } = \"\";\n        public byte[] RawContent { get; set; }\n        public string Host { get; set; } = \"\";\n        public string ContentType { get; set; } = \"\";\n        public string PathInfo { get; set; } = \"\";\n        \n        public List<WebFile> Files { get; set; } = new List<WebFile>();\n        public List<KeyValuePair<string, string>> ContentFields { get; set; } = new List<KeyValuePair<string, string>>();\n        public List<string> CookieFields { get; set; } = new List<string>();\n        public List<string> QueryFields { get; set; } = new List<string>();\n#if !FPC\n        public TWebRequestMethod MethodType { get; set; } = TWebRequestMethod.GET;\n#endif\n        public string Method { get; set; } = \"GET\";\n    }\n\n    \n    public class WebFile\n    {\n        public string FieldName { get; set; }\n        public Stream Stream { get; set; }\n    }\n\n    \n    public enum TWebRequestMethod\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH,\n        OPTIONS\n    }\n\n    \n    public class HorseCoreParam\n    {\n        public Dictionary<string, string> Dictionary { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public HorseCoreParam(List<string> list)\n        {\n            // In a real implementation, 'list' may be used.\n        }\n\n        \n        public HorseCoreParam Required(bool req)\n        {\n            // You can store the required flag if needed.\n            return this;\n        }\n\n        \n        public void AddStream(string fieldName, Stream stream)\n        {\n            // Implementation depends on your requirements.\n           \n        }\n    }\n\n    \n    public static class HorseCoreParamHeader\n    {\n        public static HorseCoreParam GetHeaders(WebRequest request)\n        {\n            \n            return new HorseCoreParam(new List<string>());\n        }\n    }\n\n    \n    public class HorseSessions\n    {\n        // Implement session handling as needed.\n    }\n\n    #endregion\n\n    public class HorseRequest : IDisposable\n    {\n        private WebRequest _webRequest;\n        private HorseCoreParam _headers;\n        private HorseCoreParam _query;\n        private HorseCoreParam _params;\n        private HorseCoreParam _contentFields;\n        private HorseCoreParam _cookie;\n        private object _body;\n        private object _session;\n        private HorseSessions _sessions;\n\n        \n        public HorseRequest(WebRequest webRequest)\n        {\n            _webRequest = webRequest;\n            _sessions = new HorseSessions();\n        }\n\n        \n        public void Dispose()\n        {\n            \n            _headers = null;\n            _query = null;\n            _params = null;\n            _contentFields = null;\n            _cookie = null;\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _sessions = null;\n        }\n\n        #region Body Methods\n\n        \n        public virtual string Body()\n        {\n            return _webRequest.Content;\n        }\n\n        \n        public T Body<T>() where T : class\n        {\n            return _body as T;\n        }\n\n        \n        public virtual HorseRequest Body(object body)\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _body = body;\n            return this;\n        }\n\n        \n        public virtual string Body(Encoding encoding)\n        {\n            if (_webRequest.RawContent != null && _webRequest.RawContent.Length > 0)\n            {\n                return encoding.GetString(_webRequest.RawContent);\n            }\n            else\n            {\n                return _webRequest.Content;\n            }\n        }\n\n        #endregion\n\n        #region Session Methods\n\n        \n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n       \n        public T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        #endregion\n\n        #region Parameter Accessors\n\n        \n        public virtual HorseCoreParam Headers()\n        {\n            if (_headers == null)\n            {\n                _headers = new HorseCoreParam(HorseCoreParamHeader.GetHeaders(_webRequest).Dictionary).Required(false);\n            }\n            return _headers;\n        }\n\n                public virtual HorseCoreParam Query()\n        {\n            if (_query == null)\n                InitializeQuery();\n            return _query;\n        }\n\n        \n        public virtual HorseCoreParam Params()\n        {\n            if (_params == null)\n                InitializeParams();\n            return _params;\n        }\n\n        \n        public virtual HorseCoreParam Cookie()\n        {\n            if (_cookie == null)\n                InitializeCookie();\n            return _cookie;\n        }\n\n        \n        public virtual HorseCoreParam ContentFields()\n        {\n            if (_contentFields == null)\n                InitializeContentFields();\n            return _contentFields;\n        }\n\n        \n        public virtual HorseSessions Sessions()\n        {\n            return _sessions;\n        }\n\n        #endregion\n\n        #region Request Information\n\n        \n        public virtual TWebRequestMethod MethodType()\n        {\n#if FPC\n            return StringCommandToMethodType(_webRequest.Method);\n#else\n            return _webRequest.MethodType;\n#endif\n        }\n\n        \n        public virtual string ContentType()\n        {\n            return _webRequest.ContentType;\n        }\n\n        \n        public virtual string Host()\n        {\n            return _webRequest.Host;\n        }\n\n        \n        public virtual string PathInfo()\n        {\n            string prefix = string.IsNullOrEmpty(_webRequest.PathInfo) ? \"/\" : \"/\";\n            return prefix + _webRequest.PathInfo;\n        }\n\n        \n        public virtual WebRequest RawWebRequest()\n        {\n            return _webRequest;\n        }\n\n        #endregion\n\n        #region Initialization Methods\n\n        \n        private void InitializeQuery()\n        {\n            _query = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var item in _webRequest.QueryFields)\n            {\n                int equalPos = item.IndexOf('=');\n                if (equalPos > 0)\n                {\n                    string key = item.Substring(0, equalPos);\n                    string value = item.Substring(equalPos + 1);\n                    if (!_query.Dictionary.ContainsKey(key))\n                        _query.Dictionary[key] = value;\n                    else\n                        _query.Dictionary[key] = _query.Dictionary[key] + \",\" + value;\n                }\n            }\n        }\n\n        \n        private void InitializeParams()\n        {\n            _params = new HorseCoreParam(new List<string>()).Required(true);\n        }\n\n        \n        private void InitializeContentFields()\n        {\n            _contentFields = new HorseCoreParam(new List<string>()).Required(false);\n            if (!CanLoadContentFields())\n                return;\n\n            \n            foreach (var file in _webRequest.Files)\n            {\n                _contentFields.AddStream(file.FieldName, file.Stream);\n            }\n\n            \n            foreach (var kvp in _webRequest.ContentFields)\n            {\n                string lName = kvp.Key;\n                string lValue = kvp.Value;\n                if (!string.IsNullOrEmpty(lName))\n                    _contentFields.Dictionary[lName] = lValue;\n            }\n        }\n\n        \n        private void InitializeCookie()\n        {\n            _cookie = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var cookieField in _webRequest.CookieFields)\n            {\n                var parts = cookieField.Split('=');\n                if (parts.Length >= 2)\n                    _cookie.Dictionary[parts[0]] = parts[1];\n            }\n        }\n\n        \n        private bool CanLoadContentFields()\n        {\n            return IsMultipartForm() || IsFormURLEncoded();\n        }\n\n        \n        private bool IsFormURLEncoded()\n        {\n            string contentType = _webRequest.ContentType;\n            string formUrlEncoded = \"application/x-www-form-urlencoded\"; \n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(formUrlEncoded, StringComparison.OrdinalIgnoreCase);\n        }\n\n        \n        private bool IsMultipartForm()\n        {\n            string contentType = _webRequest.ContentType;\n            string multipart = \"multipart/form-data\"; \n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(multipart, StringComparison.OrdinalIgnoreCase);\n        }\n\n        \n        private TWebRequestMethod StringCommandToMethodType(string method)\n        {\n            if (Enum.TryParse<TWebRequestMethod>(method, true, out var result))\n                return result;\n            return TWebRequestMethod.GET;\n        }\n\n        #endregion\n\n        #region Overloads for Session and Body\n\n        public virtual HorseRequest Session<T>() where T : class\n        {\n            return Session(_session);\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public virtual HorseRequest Body(string body)\n        {\n            _body = body;\n            return this;\n        }\n\n        #endregion\n\n        \n        public override string ToString()\n        {\n            return Body();\n        }\n\n        #region Additional Overloads\n\n\n        #endregion\n    }\n}"}
{"input": "unit Horse.Exception.Interrupted;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils;\n{$ELSE}\n  System.SysUtils;\n{$ENDIF}\n\ntype\n  EHorseCallbackInterrupted = class(Exception)\n    constructor Create; reintroduce; overload;\n    constructor Create(const AMessage: string); reintroduce; overload;\n  end;\n\nimplementation\n\nconstructor EHorseCallbackInterrupted.Create;\nbegin\n  inherited Create(EmptyStr);\nend;\n\nconstructor EHorseCallbackInterrupted.Create(const AMessage: string);\nbegin\n  inherited Create(AMessage);\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Exception.Interrupted\n{\n    public class HorseCallbackInterruptedException : Exception\n    {\n        public HorseCallbackInterruptedException() : base(string.Empty)\n        {\n        }\n\n        public HorseCallbackInterruptedException(string message) : base(message)\n        {\n        }\n    }\n}"}
{"input": "unit OtherControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n  TOtherController = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethods([httpGET])]\n    function GetSomethings: String;\n    [MVCPath('/else')]\n    [MVCHTTPMethods([httpGET])]\n    function GetSomethingElse: String;\n  end;\n\nimplementation\n\n{ TCustomController }\n\nfunction TOtherController.GetSomethingElse: String;\nbegin\n  Result := 'Hello There, it''s \"GetSomethingElse\" here';\nend;\n\nfunction TOtherController.GetSomethings: String;\nbegin\n  Result := 'Hello There, it''s \"GetSomethings\" here';\nend;\n\nend.", "output": "[HttpGet]\n[Route(\"else\")]\npublic string GetSomethingElse()\n{\n    return \"Hello There, it's \\\"GetSomethingElse\\\" here\";\n}"}
{"input": "unit WebModuleUnit1;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Commons;\n\ntype\n  TWebModule1 = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n\n  private\n    MVC: TMVCEngine;\n\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TWebModule1;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  AppControllerU,\n  System.Generics.Collections,\n  AuthenticationU,\n  MVCFramework.Middleware.JWT,\n  MVCFramework.JWT,\n  MVCFramework.HMAC,\n  MVCFramework.Middleware.StaticFiles,\n  System.DateUtils;\n\nprocedure TWebModule1.WebModuleCreate(Sender: TObject);\nvar\n  lClaimsSetup: TJWTClaimsSetup;\nbegin\n  lClaimsSetup := procedure(const JWT: TJWT)\n    begin\n      JWT.Claims.Issuer := 'Delphi MVC Framework JWT Middleware Sample';\n      JWT.Claims.NotBefore := Now - OneMinute * 5; // valid since 5 minutes ago\n      JWT.Claims.IssuedAt := Now;\n      JWT.Claims.ExpirationTime := Now + OneSecond * 30;\n      JWT.CustomClaims['mycustomvalue'] := 'THIS IS A CUSTOM CLAIM!';\n      // Here we dont use a fixed ExpirationTime but a LiveValidityWindowInSeconds\n      // to make the ExpirationTime dynamic, incrementing the\n      // ExpirationTime by LiveValidityWindowInSeconds seconds at each request\n      JWT.LiveValidityWindowInSeconds := 10; // 60 * 60;\n    end;\n\n  MVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      Config[TMVCConfigKey.DefaultContentType] := 'text/html';\n    end);\n  MVC\n    .AddController(TApp1MainController)\n    .AddController(TAdminController)\n    .AddMiddleware(TMVCJWTAuthenticationMiddleware.Create(\n      TAuthenticationSample.Create,\n      lClaimsSetup,\n      'mys3cr37',\n      '/login',\n      [TJWTCheckableClaim.ExpirationTime, TJWTCheckableClaim.NotBefore, TJWTCheckableClaim.IssuedAt],\n      0,\n      HMAC_HS512\n    // just for test, Leeway seconds is zero.\n    ));\nend;\n\nend.", "output": "using System;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing AppControllerU;\nusing AuthenticationU;\nusing MVCFramework.Middleware.JWT;\nusing MVCFramework.JWT;\nusing MVCFramework.HMAC;\nusing MVCFramework.Middleware.StaticFiles;\n\nnamespace WebModuleUnit1\n{\n    public class WebModule1 : WebModule\n    {\n        private TMVCEngine MVC;\n\n        public void WebModuleCreate(object sender)\n        {\n            Action<TJWT> lClaimsSetup = (JWT) =>\n            {\n                JWT.Claims.Issuer = \"Delphi MVC Framework JWT Middleware Sample\";\n                JWT.Claims.NotBefore = DateTime.Now.AddMinutes(-5);\n                JWT.Claims.IssuedAt = DateTime.Now;\n                JWT.Claims.ExpirationTime = DateTime.Now.AddSeconds(30);\n                JWT.CustomClaims[\"mycustomvalue\"] = \"THIS IS A CUSTOM CLAIM!\";\n                JWT.LiveValidityWindowInSeconds = 10;\n            };\n\n            MVC = new TMVCEngine(this, config =>\n            {\n                config[TMVCConfigKey.DefaultContentType] = \"text/html\";\n            });\n            MVC.AddController(typeof(TApp1MainController))\n               .AddController(typeof(TAdminController))\n               .AddMiddleware(new TMVCJWTAuthenticationMiddleware(\n                   new TAuthenticationSample(),\n                   lClaimsSetup,\n                   \"mys3cr37\",\n                   \"/login\",\n                   new TJWTCheckableClaim[] { TJWTCheckableClaim.ExpirationTime, TJWTCheckableClaim.NotBefore, TJWTCheckableClaim.IssuedAt },\n                   0,\n                   HMAC_HS512\n               ));\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.SourceFile;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  JsonDataObjects,\n  ToolsAPI,\n  DMVC.Expert.CodeGen.Executor;\n\ntype\n  TSourceFile = class(TInterfacedObject, IOTAFile)\n  private\n    fGeneratorCallback: TProc<TMVCCodeGenerator>;\n    fJSON: TJsonObject;\n  public\n    function GetSource: string;\n    function GetAge: TDateTime;\n    constructor Create(const GeneratorCallback: TProc<TMVCCodeGenerator>; const Args: TJsonObject);\n    destructor Destroy; override;\n  end;\n\nimplementation\n\n{ TSourceFile }\n\nconstructor TSourceFile.Create(const GeneratorCallback: TProc<TMVCCodeGenerator>; const Args: TJsonObject);\nbegin\n  inherited Create;\n  fGeneratorCallback := GeneratorCallback;\n  fJSON := Args.Clone as TJsonObject;\nend;\n\ndestructor TSourceFile.Destroy;\nbegin\n  fJSON.Free;\n  inherited;\nend;\n\nfunction TSourceFile.GetAge: TDateTime;\nbegin\n  Result := Now;\nend;\n\nfunction TSourceFile.GetSource: string;\nbegin\n  Result := TMVCCodeGenerator.GenerateSource(fJSON,\n                        procedure (Gen: TMVCCodeGenerator)\n                        begin\n                          fGeneratorCallback(Gen)\n                        end);\nend;\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\nusing DMVC.Expert.CodeGen.Executor;  \n\nnamespace DMVCExpertCodeGenSourceFile\n{\n    public interface IOTAFile\n    {\n        string GetSource();\n        DateTime GetAge();\n    }\n\n    public class TSourceFile : IOTAFile, IDisposable\n    {\n        private readonly Action<TMVCCodeGenerator> _generatorCallback;\n        private JObject _json;\n        private bool _disposed;\n\n        public TSourceFile(Action<TMVCCodeGenerator> generatorCallback, JObject args)\n        {\n            _generatorCallback = generatorCallback;\n            _json = (JObject)args.DeepClone();\n        }\n\n        public string GetSource()\n        {\n            return TMVCCodeGenerator.GenerateSource(_json, gen => _generatorCallback(gen));\n        }\n\n        public DateTime GetAge()\n        {\n            return DateTime.Now;\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    \n                    _json = null;\n                }\n                _disposed = true;\n            }\n        }\n\n        ~TSourceFile()\n        {\n            Dispose(false);\n        }\n    }\n}"}
{"input": "unit Commands.TemplatesU;\n\ninterface\n\nuses\n  System.Generics.Collections, CommonsU, ProjectGeneratorU;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\n\nimplementation\n\nuses CommandsU;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitProgramCommand.Create,\n    TUnitRunServerProcBody.Create,\n    TUnitMainBeginEndCommand.Create\n  ]);\nend;\n\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerCommand.Create,\n    TUnitControllerEntityDeclarationCommand.Create,\n    TUnitControllerControllerDeclarationCommand.Create,\n    TUnitFooterCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebModuleDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitJSONRPCDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TWebModuleDFMCommand.Create\n    ]);\nend;\n\n\nend.", "output": "using System.Collections.Generic;\nusing CommonsU;\nusing ProjectGeneratorU;\nusing CommandsU;\n\nnamespace CommandsTemplatesU\n{\n    public static class CommandsTemplates\n    {\n        public static void FillProgramTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitProgramCommand(),\n                new TUnitRunServerProcBody(),\n                new TUnitMainBeginEndCommand()\n            });\n        }\n\n        public static void FillControllerTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitControllerCommand(),\n                new TUnitControllerEntityDeclarationCommand(),\n                new TUnitControllerControllerDeclarationCommand(),\n                new TUnitFooterCommand()\n            });\n        }\n\n        public static void FillWebModuleTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitWebModuleDeclarationCommand()\n            });\n        }\n\n        public static void FillJSONRPCTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitJSONRPCDeclarationCommand()\n            });\n        }\n\n        public static void FillWebModuleDFMTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TWebModuleDFMCommand()\n            });\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.Daemon;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(HORSE_DAEMON) AND DEFINED(FPC)}\nuses\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fphttpserver,\n  Horse.Request,\n  Horse.Response,\n  Horse.Core,\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Proc,\n  Horse.Commons;\n\ntype\n  THTTPServerThread = class(TThread)\n  private\n    FStartServer: Boolean;\n    FHost: string;\n    FPort: Integer;\n    FListenQueue: Word;\n    FServer: TFPHTTPServer;\n    FHorse: THorseCore;\n  public\n    constructor Create(const ACreateSuspended: Boolean; const AStackSize: SizeUInt = DefaultStackSize);\n    destructor Destroy; override;\n    procedure StartServer;\n    procedure StopServer;\n    property Port: Integer read FPort write FPort;\n    property Host: String read FHost write FHost;\n    property ListenQueue: Word read FListenQueue write FListenQueue;\n    procedure Execute; override;\n    procedure OnRequest(Sender: TObject; var ARequest: TFPHTTPConnectionRequest; var AResponse: TFPHTTPConnectionResponse);\n  end;\n\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FListenQueue: Integer;\n    class var FHTTPServerThread: THTTPServerThread;\n    class function GetDefaultHTTPServerThread: THTTPServerThread;\n    class function HTTPServerThreadIsNil: Boolean;\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetHost(const AValue: string); static;\n    class function GetListenQueue: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class destructor UnInitialize;\n    class function IsRunning: Boolean;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_DAEMON) AND DEFINED(FPC)}\nuses\n  Horse.WebModule,\n  Horse.Exception.Interrupted;\n\nclass function THorseProvider.GetDefaultHTTPServerThread: THTTPServerThread;\nbegin\n  if HTTPServerThreadIsNil then\n    FHTTPServerThread := THTTPServerThread.Create(True);\n  Result := FHTTPServerThread;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.HTTPServerThreadIsNil: Boolean;\nbegin\n  Result := FHTTPServerThread = nil;\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LHTTPServerThread: THTTPServerThread;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n  if FListenQueue = 0 then\n    FListenQueue := 15;\n  LHTTPServerThread := GetDefaultHTTPServerThread;\n  LHTTPServerThread.Port := FPort;\n  LHTTPServerThread.Host := FHost;\n  LHTTPServerThread.ListenQueue := FListenQueue;\n  LHTTPServerThread.StartServer;\n  FRunning := True;\n  DoOnListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FHTTPServerThread);\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPServerThreadIsNil then\n  begin\n    GetDefaultHTTPServerThread.StopServer;\n    DoOnStopListen;\n    FRunning := False;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nprocedure THTTPServerThread.OnRequest(Sender: TObject; var ARequest: TFPHTTPConnectionRequest; var AResponse: TFPHTTPConnectionResponse);\nvar\n  LRequest: THorseRequest;\n  LResponse: THorseResponse;\nbegin\n  LRequest := THorseRequest.Create(ARequest);\n  LResponse := THorseResponse.Create(AResponse);\n  try\n    try\n      if not FHorse.Routes.Execute(LRequest, LResponse) then\n      begin\n        AResponse.Content := 'Not Found';\n        AResponse.Code := THTTPStatus.NotFound.ToInteger;\n      end;\n    except\n      on E: Exception do\n        if not E.InheritsFrom(EHorseCallbackInterrupted) then\n          raise;\n    end;\n  finally\n    if LRequest.Body<TObject> = LResponse.Content then\n      LResponse.Content(nil);\n    LRequest.Free;\n    LResponse.Free;\n  end;\nend;\n\nconstructor THTTPServerThread.Create(const ACreateSuspended: Boolean; const AStackSize: SizeUInt = DefaultStackSize);\nbegin\n  inherited Create(ACreateSuspended, AStackSize);\n  FreeOnTerminate := True;\n  FStartServer := False;\n  FServer := TFPHTTPServer.Create(Nil);\n  FServer.OnRequest := OnRequest;\n  FHorse := THorseCore.GetInstance;\nend;\n\ndestructor THTTPServerThread.Destroy;\nbegin\n  if Assigned(FServer) then\n    FServer.Active := False;\n  FreeAndNil(FServer);\n  inherited Destroy;\nend;\n\nprocedure THTTPServerThread.StartServer;\nbegin\n  Start;\n  FStartServer := True;\nend;\n\nprocedure THTTPServerThread.StopServer;\nbegin\n  FStartServer := False;\n  FServer.Active := FStartServer;\nend;\n\nprocedure THTTPServerThread.Execute;\nbegin\n  while not Terminated do\n  begin\n    if FStartServer then\n    begin\n      FServer.HostName := FHost;\n      FServer.Port := FPort;\n      FServer.Threaded := True;\n      FServer.QueueSize := FListenQueue;\n      FServer.Active := True;\n    end;\n  end;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\n\nnamespace Horse.Provider.FPC.Daemon\n{\n    #region Stub Classes and Interfaces\n\n    \n    public class FPHTTPServer\n    {\n        public string HostName { get; set; }\n        public int Port { get; set; }\n        public bool Threaded { get; set; }\n        public int QueueSize { get; set; }\n        public bool Active { get; set; }\n\n        \n        public event Action<object, FPHTTPConnectionRequest, FPHTTPConnectionResponse> OnRequest;\n\n        \n        public List<Binding> Bindings { get; } = new List<Binding>();\n\n        public FPHTTPServer()\n        {\n            // Initialize as needed.\n        }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"FPHTTPServer listening on {HostName}:{Port} with queue size {QueueSize}.\");\n            Active = true;\n        }\n\n        public void StopListening()\n        {\n           \n            Console.WriteLine(\"FPHTTPServer stopped listening.\");\n            Active = false;\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public class FPHTTPConnectionRequest\n    {\n        public string Content { get; set; }\n    }\n\n    \n    public class FPHTTPConnectionResponse\n    {\n        public string Content { get; set; }\n        public int Code { get; set; }\n    }\n\n    \n    public class THorseRequest : IDisposable\n    {\n        public THorseRequest(FPHTTPConnectionRequest req)\n        {\n            // Wrap the request.\n        }\n        public void Dispose()\n        {\n            // Clean up.\n        }\n    }\n\n    public class THorseResponse : IDisposable\n    {\n        public THorseResponse(FPHTTPConnectionResponse resp)\n        {\n            // Wrap the response.\n        }\n        public void Send(string content)\n        {\n            Console.WriteLine(\"Response sent: \" + content);\n        }\n        public void Status(int code)\n        {\n            Console.WriteLine(\"Response status: \" + code);\n        }\n        public void Dispose()\n        {\n            // Clean up.\n        }\n    }\n\n    \n    public class HorseCore\n    {\n        private static HorseCore _instance;\n        public static HorseCore GetInstance() => _instance ?? (_instance = new HorseCore());\n        public RoutesCollection Routes { get; } = new RoutesCollection();\n    }\n\n    \n    public class RoutesCollection\n    {\n        \n        public bool Execute(THorseRequest request, THorseResponse response)\n        {\n            \n            return false;\n        }\n    }\n\n    \n    public static class HTTPStatus\n    {\n        public static int NotFound => 404;\n    }\n\n    #endregion\n\n    #region HTTPServerThread\n\n    \n    public class HTTPServerThread\n    {\n        private Thread _thread;\n        private volatile bool _startServer;\n        private readonly FPHTTPServer _server;\n        private readonly HorseCore _horse;\n        public string Host { get; set; }\n        public int Port { get; set; }\n        public ushort ListenQueue { get; set; }\n\n        public HTTPServerThread(bool createSuspended)\n        {\n            _server = new FPHTTPServer();\n            \n            _server.OnRequest += OnRequest;\n            _horse = HorseCore.GetInstance();\n            _startServer = false;\n\n            \n            _thread = new Thread(Execute) { IsBackground = true };\n            if (!createSuspended)\n            {\n                _thread.Start();\n            }\n        }\n\n        \n        public void StartServer()\n        {\n            _startServer = true;\n            if (!_thread.IsAlive)\n                _thread.Start();\n        }\n\n        \n        public void StopServer()\n        {\n            _startServer = false;\n            _server.Active = _startServer;\n        }\n\n        \n        private void Execute()\n        {\n            while (true)\n            {\n                if (_startServer)\n                {\n                    _server.HostName = Host;\n                    _server.Port = Port;\n                    _server.Threaded = true;\n                    _server.QueueSize = ListenQueue;\n                    _server.Active = true;\n                    _server.StartListening();\n                }\n                \n                Thread.Sleep(100);\n            }\n        }\n\n        \n        private void OnRequest(object sender, FPHTTPConnectionRequest req, FPHTTPConnectionResponse resp)\n        {\n            using (var horseReq = new THorseRequest(req))\n            using (var horseResp = new THorseResponse(resp))\n            {\n                try\n                {\n                    if (!_horse.Routes.Execute(horseReq, horseResp))\n                    {\n                        resp.Content = \"Not Found\";\n                        resp.Code = HTTPStatus.NotFound;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    \n                    Console.WriteLine(\"Exception in OnRequest: \" + ex.Message);\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region HorseProvider\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n    }\n\n    \n    public static class HorseProvider : HorseProviderAbstract\n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _listenQueue;\n        private static HTTPServerThread _httpServerThread;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int ListenQueue { get => _listenQueue; set => _listenQueue = value; }\n\n        public override void Listen() => InternalListen();\n\n        public override void StopListen() => InternalStopListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            \n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value;\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = DEFAULT_PORT;\n            if (string.IsNullOrEmpty(_host))\n                _host = DEFAULT_HOST;\n            if (_listenQueue == 0)\n                _listenQueue = 15;\n\n            if (_httpServerThread == null)\n            {\n                _httpServerThread = new HTTPServerThread(createSuspended: true);\n            }\n            _httpServerThread.Port = _port;\n            _httpServerThread.Host = _host;\n            _httpServerThread.ListenQueue = (ushort)_listenQueue;\n            _httpServerThread.StartServer();\n            _running = true;\n            \n        }\n\n        private static void InternalStopListen()\n        {\n            if (_httpServerThread != null)\n            {\n                _httpServerThread.StopServer();\n                _running = false;\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static void UnInitialize()\n        {\n            _httpServerThread = null;\n        }\n\n        \n        private const string DEFAULT_HOST = \"0.0.0.0\";\n        private const int DEFAULT_PORT = 8080;\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Session;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Session,\n  MVCFramework.Middleware.Session.Internal\n  ;\n\n  function UseMemorySessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\n  function UseFileSessionMiddleware(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'): TMVCSessionMiddleware;\n  function UseDatabaseSessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\n\nimplementation\n\nuses\n  MVCFramework.Session.Database;\n\n\nfunction UseMemorySessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(TMVCWebSessionMemoryFactory.Create(aTimeoutInMinutes));\nend;\n\nfunction UseFileSessionMiddleware(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(TMVCWebSessionFileFactory.Create(aTimeoutInMinutes, aSessionFolder));\nend;\n\nfunction UseDatabaseSessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(\n    TMVCWebSessionDatabaseFactory.Create(aTimeoutInMinutes, 'notused'));\nend;\n\n\n\n\nend.", "output": "using System;\nusing MVCFramework.Session;\nusing MVCFramework.Middleware.Session.Internal;\nusing MVCFramework.Session.Database; \n\nnamespace MVCFramework.Middleware.Session\n{\n    public static class SessionMiddlewareExtensions\n    {\n        \n        public static SessionMiddleware UseMemorySessionMiddleware(int timeoutInMinutes = 0)\n        {\n            return new SessionMiddleware(MVCWebSessionMemoryFactory.Create(timeoutInMinutes));\n        }\n\n        \n        public static SessionMiddleware UseFileSessionMiddleware(int timeoutInMinutes = 0, string sessionFolder = \"dmvc_sessions\")\n        {\n            \n            return new SessionMiddleware(MVCWebSessionFileFactory.Create(timeoutInMinutes, sessionFolder));\n        }\n\n        \n        public static SessionMiddleware UseDatabaseSessionMiddleware(int timeoutInMinutes = 0)\n        {\n            \n            return new SessionMiddleware(MVCWebSessionDatabaseFactory.Create(timeoutInMinutes, \"notused\"));\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file:\n// Jo\ufffdo Ant\ufffdnio Duarte (https://github.com/joaoduarte19)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.StaticFiles;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  System.Generics.Collections;\n\ntype\n  TMVCStaticFilesDefaults = class sealed\n  public const\n    /// <summary>\n    /// URL segment that represents the path to static files\n    /// </summary>\n    STATIC_FILES_PATH = '/static';\n\n    /// <summary>\n    /// Physical path of the root folder that contains the static files\n    /// </summary>\n    DOCUMENT_ROOT = '.\\www';\n\n    /// <summary>\n    /// Default static file\n    /// </summary>\n    INDEX_DOCUMENT = 'index.html';\n\n    /// <summary>\n    /// Charset of static files\n    /// </summary>\n    STATIC_FILES_CONTENT_CHARSET = TMVCConstants.DEFAULT_CONTENT_CHARSET;\n  end;\n\n  TMVCStaticFileRulesProc = reference to procedure(const Context: TWebContext; var PathInfo: String; var Handled: Boolean);\n  TMVCStaticFileMediaTypesCustomizer = reference to procedure(const MediaTypes: TMVCStringDictionary);\n  TMVCStaticFilesMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fSanityCheckOK: Boolean;\n    fMediaTypes: TMVCStringDictionary;\n    fStaticFilesPath: string;\n    fDocumentRoot: string;\n    fIndexDocument: string;\n    fStaticFilesCharset: string;\n    fSPAWebAppSupport: Boolean;\n    fRules: TMVCStaticFileRulesProc;\n    procedure AddMediaTypes;\n    // function IsStaticFileRequest(const APathInfo: string; out AFileName: string;\n    // out AIsDirectoryTraversalAttach: Boolean): Boolean;\n    function SendStaticFileIfPresent(const AContext: TWebContext; const AFileName: string): Boolean;\n    procedure DoSanityCheck;\n  public\n    constructor Create(\n      const AStaticFilesPath: string = TMVCStaticFilesDefaults.STATIC_FILES_PATH;\n      const ADocumentRoot: string = TMVCStaticFilesDefaults.DOCUMENT_ROOT;\n      const AIndexDocument: string = TMVCStaticFilesDefaults.INDEX_DOCUMENT;\n      const ASPAWebAppSupport: Boolean = True;\n      const AStaticFilesCharset: string = TMVCStaticFilesDefaults.STATIC_FILES_CONTENT_CHARSET;\n      const ARules: TMVCStaticFileRulesProc = nil;\n      const AMediaTypesCustomizer: TMVCStaticFileMediaTypesCustomizer = nil);\n    destructor Destroy; override;\n\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName: string;\n      const AActionName: string; var AHandled: Boolean);\n\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger,\n  System.SysUtils,\n  System.NetEncoding,\n  System.IOUtils,\n  System.Classes;\n\n{ TMVCStaticFilesMiddleware }\n\nprocedure TMVCStaticFilesMiddleware.AddMediaTypes;\nbegin\n  fMediaTypes.Add('.html', TMVCMediaType.TEXT_HTML);\n  fMediaTypes.Add('.htm', TMVCMediaType.TEXT_HTML);\n  fMediaTypes.Add('.txt', TMVCMediaType.TEXT_PLAIN);\n  fMediaTypes.Add('.text', TMVCMediaType.TEXT_PLAIN);\n  fMediaTypes.Add('.csv', TMVCMediaType.TEXT_CSV);\n  fMediaTypes.Add('.css', TMVCMediaType.TEXT_CSS);\n  fMediaTypes.Add('.js', TMVCMediaType.TEXT_JAVASCRIPT);\n  fMediaTypes.Add('.json', TMVCMediaType.APPLICATION_JSON);\n  fMediaTypes.Add('.jpg', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.jpeg', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.jpe', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.png', TMVCMediaType.IMAGE_PNG);\n  fMediaTypes.Add('.ico', TMVCMediaType.IMAGE_X_ICON);\n  fMediaTypes.Add('.appcache', TMVCMediaType.TEXT_CACHEMANIFEST);\n  fMediaTypes.Add('.svg', TMVCMediaType.IMAGE_SVG_XML);\n  fMediaTypes.Add('.xml', TMVCMediaType.TEXT_XML);\n  fMediaTypes.Add('.pdf', TMVCMediaType.APPLICATION_PDF);\n  fMediaTypes.Add('.svgz', TMVCMediaType.IMAGE_SVG_XML);\n  fMediaTypes.Add('.gif', TMVCMediaType.IMAGE_GIF);\nend;\n\nconstructor TMVCStaticFilesMiddleware.Create(\n      const AStaticFilesPath: string;\n      const ADocumentRoot: string;\n      const AIndexDocument: string;\n      const ASPAWebAppSupport: Boolean;\n      const AStaticFilesCharset: string;\n      const ARules: TMVCStaticFileRulesProc;\n      const AMediaTypesCustomizer: TMVCStaticFileMediaTypesCustomizer);\nbegin\n  inherited Create;\n  fSanityCheckOK := False;\n  fStaticFilesPath := AStaticFilesPath.Trim;\n  if not fStaticFilesPath.EndsWith('/') then\n    fStaticFilesPath := fStaticFilesPath + '/';\n\n  if TDirectory.Exists(ADocumentRoot) then\n  begin\n    fDocumentRoot := TPath.GetFullPath(ADocumentRoot);\n  end\n  else\n  begin\n    fDocumentRoot := TPath.Combine(AppPath, ADocumentRoot);\n  end;\n  fIndexDocument := AIndexDocument;\n  fStaticFilesCharset := AStaticFilesCharset;\n  fSPAWebAppSupport := ASPAWebAppSupport;\n  fMediaTypes := TMVCStringDictionary.Create;\n  fRules := ARules;\n  AddMediaTypes;\n  if Assigned(AMediaTypesCustomizer) then\n  begin\n    AMediaTypesCustomizer(fMediaTypes);\n  end;\nend;\n\ndestructor TMVCStaticFilesMiddleware.Destroy;\nbegin\n  fMediaTypes.Free;\n\n  inherited Destroy;\nend;\n\nprocedure TMVCStaticFilesMiddleware.DoSanityCheck;\nbegin\n  if not fStaticFilesPath.StartsWith('/') then\n  begin\n    raise EMVCException.Create('StaticFilePath must begin with \"/\" and cannot be empty');\n  end;\n  if not TDirectory.Exists(fDocumentRoot) then\n  begin\n    raise EMVCException.CreateFmt('TMVCStaticFilesMiddleware Error: DocumentRoot [%s] is not a valid directory', [fDocumentRoot]);\n  end;\n  fSanityCheckOK := True;\nend;\n\n// function TMVCStaticFilesMiddleware.IsStaticFileRequest(const APathInfo: string; out AFileName: string;\n// out AIsDirectoryTraversalAttach: Boolean): Boolean;\n// begin\n// Result := TMVCStaticContents.IsStaticFile(fDocumentRoot, APathInfo, AFileName,\n// AIsDirectoryTraversalAttach);\n// end;\n\nprocedure TMVCStaticFilesMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  lPathInfo: string;\n  lFileName: string;\n  lIsDirectoryTraversalAttach: Boolean;\n  lFullPathInfo: string;\n  lRealFileName: string;\n  lAllow: Boolean;\nbegin\n//  if not fSanityCheckOK then\n//  begin\n//    DoSanityCheck;\n//  end;\n\n  lPathInfo := AContext.Request.PathInfo;\n\n  if not lPathInfo.StartsWith(fStaticFilesPath, True) then\n  begin\n    { In case of folder request without the trailing \"/\" }\n    if not lPathInfo.EndsWith('/') then\n    begin\n      lPathInfo := lPathInfo + '/';\n      if not lPathInfo.StartsWith(fStaticFilesPath, True) then\n      begin\n        AHandled := False;\n        Exit;\n      end;\n    end\n    else\n    begin\n      AHandled := False;\n      Exit;\n    end;\n  end;\n\n  if Assigned(fRules) then\n  begin\n    lAllow := True;\n    fRules(AContext, lPathInfo, lAllow);\n    if not lAllow then\n    begin\n      AHandled := True;\n      Exit;\n    end;\n  end;\n\n  // calculate the actual requested path\n  if lPathInfo.StartsWith(fStaticFilesPath, True) then\n  begin\n    lPathInfo := lPathInfo.Remove(0, fStaticFilesPath.Length);\n  end;\n  lPathInfo := lPathInfo.Replace('/', PathDelim, [rfReplaceAll]);\n  if lPathInfo.StartsWith(PathDelim) then\n  begin\n    lPathInfo := lPathInfo.Remove(0, 1);\n  end;\n  lFullPathInfo := TPath.Combine(fDocumentRoot, lPathInfo);\n\n  { Now the actual requested path is in lFullPathInfo }\n\n  if not fSanityCheckOK then\n  begin\n    DoSanityCheck;\n  end;\n\n  if TMVCStaticContents.IsStaticFile(fDocumentRoot, lPathInfo, lRealFileName,\n    lIsDirectoryTraversalAttach) then\n  begin\n    // check if it's a direct file request\n    // lIsFileRequest := TMVCStaticContents.IsStaticFile(fDocumentRoot, lPathInfo, lRealFileName,\n    // lIsDirectoryTraversalAttach);\n    if lIsDirectoryTraversalAttach then\n    begin\n      AContext.Response.StatusCode := HTTP_STATUS.NotFound;\n      AHandled := True;\n      Exit;\n    end;\n\n    AHandled := SendStaticFileIfPresent(AContext, lRealFileName);\n    if AHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  // check if a directory request\n  if TDirectory.Exists(lFullPathInfo) then\n  begin\n    if not AContext.Request.PathInfo.EndsWith('/') then\n    begin\n      AContext.Response.StatusCode := HTTP_STATUS.MovedPermanently;\n      AContext.Response.CustomHeaders.Values['Location'] := AContext.Request.PathInfo + '/';\n      AHandled := True;\n      Exit;\n    end;\n\n    if not fIndexDocument.IsEmpty then\n    begin\n      AHandled := SendStaticFileIfPresent(AContext, TPath.Combine(lFullPathInfo, fIndexDocument));\n      Exit;\n    end;\n  end;\n\n  // if SPA support is enabled, return the first index.html found in the path.\n  // This allows to host multiple SPA application in subfolders\n  if (not AHandled) and fSPAWebAppSupport and (not fIndexDocument.IsEmpty) then\n  begin\n    while (not lFullPathInfo.IsEmpty) and (not TDirectory.Exists(lFullPathInfo)) do\n    begin\n      lFullPathInfo := TDirectory.GetParent(lFullPathInfo);\n    end;\n    lFileName := TPath.GetFullPath(TPath.Combine(lFullPathInfo, fIndexDocument));\n    AHandled := SendStaticFileIfPresent(AContext, lFileName);\n  end;\nend;\n\nfunction TMVCStaticFilesMiddleware.SendStaticFileIfPresent(const AContext: TWebContext;\n  const AFileName: string): Boolean;\nvar\n  lContentType: string;\nbegin\n  Result := False;\n  if TFile.Exists(AFileName) then\n  begin\n    if fMediaTypes.TryGetValue(LowerCase(ExtractFileExt(AFileName)), lContentType) then\n    begin\n      lContentType := BuildContentType(lContentType, fStaticFilesCharset);\n    end\n    else\n    begin\n      lContentType := BuildContentType(TMVCMediaType.APPLICATION_OCTETSTREAM, '');\n    end;\n    TMVCStaticContents.SendFile(AFileName, lContentType, AContext);\n    Result := True;\n    LogI(AContext.Request.HTTPMethodAsString + ':' +\n      AContext.Request.PathInfo + ' [' + AContext.Request.ClientIp + '] -> ' +\n      ClassName + ' - ' + IntToStr(AContext.Response.StatusCode) + ' ' +\n      AContext.Response.ReasonString);\n  end;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;   \nusing MVCFramework.Logger;    \n\nnamespace MVCFramework.Middleware\n{\n    \n    public static class MvcStaticFilesDefaults\n    {\n        \n        public const string StaticFilesPath = \"/static\";\n\n        \n        public const string DocumentRoot = @\".\\www\";\n\n        \n        public const string IndexDocument = \"index.html\";\n\n        \n        public const string StaticFilesContentCharset = MVCConstants.DefaultContentCharset;\n    }\n\n    \n    public delegate void MvcStaticFileRulesProc(IWebContext context, ref string pathInfo, ref bool handled);\n\n    \n    public delegate void MvcStaticFileMediaTypesCustomizer(Dictionary<string, string> mediaTypes);\n\n    \n    public class MvcStaticFilesMiddleware : IMiddleware\n    {\n        private bool sanityCheckOK;\n        private readonly Dictionary<string, string> mediaTypes;\n        private readonly string staticFilesPath;\n        private readonly string documentRoot;\n        private readonly string indexDocument;\n        private readonly string staticFilesCharset;\n        private readonly bool spaWebAppSupport;\n        private readonly MvcStaticFileRulesProc rules;\n\n        \n        public MvcStaticFilesMiddleware(\n            string staticFilesPath = MvcStaticFilesDefaults.StaticFilesPath,\n            string documentRoot = MvcStaticFilesDefaults.DocumentRoot,\n            string indexDocument = MvcStaticFilesDefaults.IndexDocument,\n            bool spaWebAppSupport = true,\n            string staticFilesCharset = MvcStaticFilesDefaults.StaticFilesContentCharset,\n            MvcStaticFileRulesProc rules = null,\n            MvcStaticFileMediaTypesCustomizer mediaTypesCustomizer = null)\n        {\n            sanityCheckOK = false;\n            this.staticFilesPath = staticFilesPath.Trim();\n            if (!this.staticFilesPath.EndsWith(\"/\"))\n            {\n                this.staticFilesPath += \"/\";\n            }\n\n            \n            if (Directory.Exists(documentRoot))\n            {\n                this.documentRoot = Path.GetFullPath(documentRoot);\n            }\n            else\n            {\n                \n                this.documentRoot = Path.Combine(MVCConstants.AppPath, documentRoot);\n            }\n\n            this.indexDocument = indexDocument;\n            this.staticFilesCharset = staticFilesCharset;\n            this.spaWebAppSupport = spaWebAppSupport;\n            this.rules = rules;\n\n            mediaTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            AddMediaTypes();\n            mediaTypesCustomizer?.Invoke(mediaTypes);\n        }\n\n        private void AddMediaTypes()\n        {\n            mediaTypes[\".html\"] = MVCMediaType.TextHtml;\n            mediaTypes[\".htm\"] = MVCMediaType.TextHtml;\n            mediaTypes[\".txt\"] = MVCMediaType.TextPlain;\n            mediaTypes[\".text\"] = MVCMediaType.TextPlain;\n            mediaTypes[\".csv\"] = MVCMediaType.TextCsv;\n            mediaTypes[\".css\"] = MVCMediaType.TextCss;\n            mediaTypes[\".js\"] = MVCMediaType.TextJavascript;\n            mediaTypes[\".json\"] = MVCMediaType.ApplicationJson;\n            mediaTypes[\".jpg\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".jpeg\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".jpe\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".png\"] = MVCMediaType.ImagePng;\n            mediaTypes[\".ico\"] = MVCMediaType.ImageXIcon;\n            mediaTypes[\".appcache\"] = MVCMediaType.TextCacheManifest;\n            mediaTypes[\".svg\"] = MVCMediaType.ImageSvgXml;\n            mediaTypes[\".xml\"] = MVCMediaType.TextXml;\n            mediaTypes[\".pdf\"] = MVCMediaType.ApplicationPdf;\n            mediaTypes[\".svgz\"] = MVCMediaType.ImageSvgXml;\n            mediaTypes[\".gif\"] = MVCMediaType.ImageGif;\n        }\n\n        private void DoSanityCheck()\n        {\n            if (!staticFilesPath.StartsWith(\"/\"))\n            {\n                throw new Exception(\"StaticFilePath must begin with '/' and cannot be empty\");\n            }\n            if (!Directory.Exists(documentRoot))\n            {\n                throw new Exception($\"MvcStaticFilesMiddleware Error: DocumentRoot [{documentRoot}] is not a valid directory\");\n            }\n            sanityCheckOK = true;\n        }\n\n        \n        private bool SendStaticFileIfPresent(IWebContext context, string fileName)\n        {\n            if (File.Exists(fileName))\n            {\n                string contentType;\n                string ext = Path.GetExtension(fileName).ToLower();\n                if (!mediaTypes.TryGetValue(ext, out contentType))\n                {\n                    contentType = BuildContentType(MVCMediaType.ApplicationOctetStream, \"\");\n                }\n                else\n                {\n                    contentType = BuildContentType(contentType, staticFilesCharset);\n                }\n                \n                MvcStaticContents.SendFile(fileName, contentType, context);\n                Log.Info($\"{context.Request.HttpMethod}:{context.Request.PathInfo} [{context.Request.ClientIp}] -> {GetType().Name} - {context.Response.StatusCode} {context.Response.ReasonPhrase}\");\n                return true;\n            }\n            return false;\n        }\n\n        \n        private string BuildContentType(string baseContentType, string charset)\n        {\n            if (string.IsNullOrEmpty(charset))\n            {\n                return baseContentType;\n            }\n            return $\"{baseContentType}; charset={charset}\";\n        }\n\n        public void OnBeforeRouting(IWebContext context, ref bool handled)\n        {\n            \n            string pathInfo = context.Request.PathInfo;\n\n            \n            if (!pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n            {\n                if (!pathInfo.EndsWith(\"/\"))\n                {\n                    \n                    pathInfo += \"/\";\n                    if (!pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n                    {\n                        handled = false;\n                        return;\n                    }\n                }\n                else\n                {\n                    handled = false;\n                    return;\n                }\n            }\n\n            \n            if (rules != null)\n            {\n                bool allow = true;\n                rules(context, ref pathInfo, ref allow);\n                if (!allow)\n                {\n                    handled = true;\n                    return;\n                }\n            }\n\n            \n            if (pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n            {\n                pathInfo = pathInfo.Substring(staticFilesPath.Length);\n            }\n            \n            pathInfo = pathInfo.Replace(\"/\", Path.DirectorySeparatorChar.ToString());\n            if (pathInfo.StartsWith(Path.DirectorySeparatorChar.ToString()))\n            {\n                pathInfo = pathInfo.Substring(1);\n            }\n            \n            string fullPathInfo = Path.Combine(documentRoot, pathInfo);\n\n            if (!sanityCheckOK)\n            {\n                DoSanityCheck();\n            }\n\n            \n            bool isDirTraversal;\n            string realFileName = MvcStaticContents.IsStaticFile(documentRoot, pathInfo, out isDirTraversal);\n            if (!string.IsNullOrEmpty(realFileName))\n            {\n                if (isDirTraversal)\n                {\n                    context.Response.StatusCode = (int)System.Net.HttpStatusCode.NotFound;\n                    handled = true;\n                    return;\n                }\n                handled = SendStaticFileIfPresent(context, realFileName);\n                if (handled)\n                {\n                    return;\n                }\n            }\n\n            \n            if (Directory.Exists(fullPathInfo))\n            {\n                \n                if (!context.Request.PathInfo.EndsWith(\"/\"))\n                {\n                    context.Response.StatusCode = (int)System.Net.HttpStatusCode.MovedPermanently;\n                    context.Response.CustomHeaders[\"Location\"] = context.Request.PathInfo + \"/\";\n                    handled = true;\n                    return;\n                }\n                \n                if (!string.IsNullOrEmpty(indexDocument))\n                {\n                    handled = SendStaticFileIfPresent(context, Path.Combine(fullPathInfo, indexDocument));\n                    return;\n                }\n            }\n\n            \n            if (!handled && spaWebAppSupport && !string.IsNullOrEmpty(indexDocument))\n            {\n                while (!string.IsNullOrEmpty(fullPathInfo) && !Directory.Exists(fullPathInfo))\n                {\n                    DirectoryInfo parent = Directory.GetParent(fullPathInfo);\n                    fullPathInfo = parent?.FullName ?? \"\";\n                }\n                string fileName = Path.GetFullPath(Path.Combine(fullPathInfo, indexDocument));\n                handled = SendStaticFileIfPresent(context, fileName);\n            }\n        }\n\n        public void OnBeforeControllerAction(IWebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // No action needed here.\n        }\n\n        public void OnAfterControllerAction(IWebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No action needed here.\n        }\n\n        public void OnAfterRouting(IWebContext context, bool handled)\n        {\n            // No action needed here.\n        }\n    }\n}"}
{"input": "unit frmGenerate;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  System.Json,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls;\n\ntype\n  TForm1 = class(TForm)\n    Memo1: TMemo;\n    btnGenerate: TButton;\n    procedure btnGenerateClick(Sender: TObject);\n  private\n    function CreateJsonSomeSubType: TJsonObject;\n    function CreateJsonSomeType(pJsonObjectSubType: TJsonObject): TJsonObject;\n  public\n    { Public declarations }\n  end;\n\nvar\n  Form1: TForm1;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  Json.Common.Helpers,\n  Swag.Common.Types,\n  Swag.Doc.Path,\n  Swag.Doc.Path.Operation,\n  Swag.Doc.Path.Operation.RequestParameter,\n  Swag.Doc.Path.Operation.Response,\n  Swag.Doc.Path.Operation.ResponseHeaders,\n  Swag.Doc.Definition,\n  Swag.Doc;\n\nprocedure TForm1.btnGenerateClick(Sender: TObject);\nvar\n  vSwagDoc: TSwagDoc;\n  vPath: TSwagPath;\n  vOperation: TSwagPathOperation;\n  vParam: TSwagRequestParameter;\n  vResponse: TSwagResponse;\n  vDefinitionSomeType: TSwagDefinition;\n  vDefinitionResponseSomeType: TSwagDefinition;\n  vDefinitionSomeSubType: TSwagDefinition;\n  vResponseHeader: TSwagHeaders;\nbegin\n  vSwagDoc := TSwagDoc.Create;\n  try\n    vSwagDoc.Info.Title := 'Sample API';\n    vSwagDoc.Info.Version := 'v1.2';\n    vSwagDoc.Info.TermsOfService := 'https://example.com/someurl/tos';\n    vSwagDoc.Info.Description := 'Sample API Description';\n    vSwagDoc.Info.Contact.Name := 'John Smith';\n    vSwagDoc.Info.Contact.Email := 'jsmith@example.com';\n    vSwagDoc.Info.Contact.Url := 'https://example.com/contact';\n    vSwagDoc.Info.License.Name := 'Some License';\n    vSwagDoc.Info.License.Url := 'https://example.com/license';\n\n    vSwagDoc.Host := 'example.com';\n    vSwagDoc.BasePath := '/basepath';\n\n    vSwagDoc.Consumes.Add('application/json');\n\n    vSwagDoc.Produces.Add('text/xml');\n    vSwagDoc.Produces.Add('application/json');\n\n    vSwagDoc.Schemes := [tpsHttps];\n\n    vDefinitionSomeSubType := TSwagDefinition.Create;\n    vDefinitionSomeSubType.Name := 'SomeSubType';\n    vDefinitionSomeSubType.JsonSchema := CreateJsonSomeSubType;\n    vSwagDoc.Definitions.Add(vDefinitionSomeSubType);\n\n    vDefinitionSomeType := TSwagDefinition.Create;\n    vDefinitionSomeType.Name := 'SomeType';\n    vDefinitionSomeType.JsonSchema := CreateJsonSomeType(vDefinitionSomeSubType.GenerateJsonRefDefinition);\n    vSwagDoc.Definitions.Add(vDefinitionSomeType);\n\n    vPath := TSwagPath.Create;\n    vPath.Uri := '/path/request/{param1}';\n\n    vOperation := TSwagPathOperation.Create;\n    vOperation.Operation := ohvPost;\n    vOperation.OperationId := 'RequestData';\n    vOperation.Description := 'Requests some data';\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param1';\n    vParam.InLocation := rpiPath;\n    vParam.Description := 'A param required';\n    vParam.Required := True;\n    vParam.TypeParameter := stpString;\n    vOperation.Parameters.Add(vParam);\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param2';\n    vParam.InLocation := rpiQuery;\n    vParam.Description := 'A param that is not required';\n    vParam.Required := False;\n    vParam.TypeParameter := stpString;\n    vOperation.Parameters.Add(vParam);\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param3';\n    vParam.InLocation := rpiBody;\n    vParam.Required := True;\n    vParam.Schema.Name := 'SomeType';\n    vOperation.Parameters.Add(vParam);\n\n    vResponse := TSwagResponse.Create;\n    vResponse.StatusCode := '200';\n    vResponse.Description := 'Successfully retrieved data';\n    vResponse.Schema.Name := 'SomeType';\n    vOperation.Responses.Add('200', vResponse);\n\n    vResponseHeader := TSwagHeaders.Create;\n    vResponseHeader.Name := 'X-Rate-Limit-Limit';\n    vResponseHeader.Description := 'The number of allowed requests in the current period';\n    vResponseHeader.ValueType := 'integer';\n    vResponse.Headers.Add(vResponseHeader);\n    \n    vResponse := TSwagResponse.Create;\n    vResponse.StatusCode := 'default';\n    vResponse.Description := 'Error occured';\n\n    vOperation.Responses.Add('default',vResponse);\n\n    vOperation.Tags.Add('TagName');\n        \n    vPath.Operations.Add(vOperation);\n    vSwagDoc.Paths.Add(vPath);\n\n    vSwagDoc.GenerateSwaggerJson;\n    Memo1.Lines.Add(vSwagDoc.SwaggerJson.Format);\n  finally\n    FreeAndNil(vSwagDoc);\n  end;\nend;\n\nfunction TForm1.CreateJsonSomeSubType: TJsonObject;\nvar\n  vJsonType: TJsonObject;\n  vJsonProperities: TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n\n  Result.AddPair('type','object');\n\n  vJsonType := TJsonObject.Create;\n  vJsonType.AddPair('type', 'string');\n\n  vJsonProperities := TJsonObject.Create;\n  vJsonProperities.AddPair('id', vJsonType);\n\n  Result.AddPair('properties', vJsonProperities);\nend;\n\nfunction TForm1.CreateJsonSomeType(pJsonObjectSubType: TJsonObject): TJsonObject;\nvar\n  vJsonId: TJsonObject;\n  vJsonCost: TJsonObject;\n  vJsonProperities: TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.AddPair('type', 'object');\n\n  vJsonId := TJsonObject.Create;\n  vJsonId.AddPair('type', 'integer');\n  vJsonId.AddPair('format', 'int64');\n\n  vJsonProperities := TJsonObject.Create;\n  vJsonProperities.AddPair('id', vJsonId);\n\n  vJsonProperities.AddPair('subType', pJsonObjectSubType);\n\n  vJsonCost := TJsonObject.Create;\n  vJsonCost.AddPair('type', 'string');\n  vJsonCost.AddPair('format', 'decimel');\n  vJsonCost.AddPair('multipleOf', TJsonNumber.Create(0.01));\n  vJsonCost.AddPair('minimum', TJsonNumber.Create(-9999999999.99));\n  vJsonCost.AddPair('maximum', TJsonNumber.Create(9999999999.99));\n  vJsonCost.AddPair('title', 'Total Cost');\n  vJsonCost.AddPair('description', 'Total Cost');\n  vJsonCost.AddPair('example', TJsonNumber.Create(9999999999.99));\n  vJsonProperities.AddPair('cost', vJsonCost);\n\n  Result.AddPair('properties', vJsonProperities);\nend;\n\ninitialization\n  ReportMemoryLeaksOnShutdown := True;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing System.Net;\n\nnamespace frmGenerate\n{\n\n    public class SwagDoc\n    {\n        public SwagInfo Info { get; set; } = new SwagInfo();\n        public string Host { get; set; }\n        public string BasePath { get; set; }\n        public List<string> Consumes { get; set; } = new List<string>();\n        public List<string> Produces { get; set; } = new List<string>();\n        public List<string> Schemes { get; set; } = new List<string>();\n        public List<SwagDefinition> Definitions { get; set; } = new List<SwagDefinition>();\n        public List<SwagPath> Paths { get; set; } = new List<SwagPath>();\n        public JObject SwaggerJson { get; set; }\n\n        public void GenerateSwaggerJson()\n        {\n            \n            var doc = new JObject\n            {\n                [\"swagger\"] = \"2.0\",\n                [\"info\"] = Info.ToJObject(),\n                [\"host\"] = Host,\n                [\"basePath\"] = BasePath,\n                [\"consumes\"] = new JArray(Consumes),\n                [\"produces\"] = new JArray(Produces),\n                [\"schemes\"] = new JArray(Schemes)\n            };\n\n            var defs = new JObject();\n            foreach (var def in Definitions)\n            {\n                defs[def.Name] = def.JsonSchema;\n            }\n            doc[\"definitions\"] = defs;\n\n            var paths = new JObject();\n            foreach (var path in Paths)\n            {\n                paths[path.Uri] = path.ToJObject();\n            }\n            doc[\"paths\"] = paths;\n\n            SwaggerJson = doc;\n        }\n    }\n\n    public class SwagInfo\n    {\n        public string Title { get; set; }\n        public string Version { get; set; }\n        public string TermsOfService { get; set; }\n        public string Description { get; set; }\n        public SwagContact Contact { get; set; } = new SwagContact();\n        public SwagLicense License { get; set; } = new SwagLicense();\n\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"title\"] = Title,\n                [\"version\"] = Version,\n                [\"termsOfService\"] = TermsOfService,\n                [\"description\"] = Description,\n                [\"contact\"] = Contact.ToJObject(),\n                [\"license\"] = License.ToJObject()\n            };\n        }\n    }\n\n    public class SwagContact\n    {\n        public string Name { get; set; }\n        public string Email { get; set; }\n        public string Url { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"name\"] = Name,\n                [\"email\"] = Email,\n                [\"url\"] = Url\n            };\n        }\n    }\n\n    public class SwagLicense\n    {\n        public string Name { get; set; }\n        public string Url { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"name\"] = Name,\n                [\"url\"] = Url\n            };\n        }\n    }\n\n    public class SwagDefinition\n    {\n        public string Name { get; set; }\n        public JObject JsonSchema { get; set; }\n        public JObject GenerateJsonRefDefinition()\n        {\n            return new JObject(new JProperty(\"$ref\", \"#/definitions/\" + Name));\n        }\n    }\n\n    public class SwagPath\n    {\n        public string Uri { get; set; }\n        public List<SwagPathOperation> Operations { get; set; } = new List<SwagPathOperation>();\n        public JObject ToJObject()\n        {\n            var obj = new JObject();\n            foreach (var op in Operations)\n            {\n                obj[op.Operation.ToLower()] = op.ToJObject();\n            }\n            return obj;\n        }\n    }\n\n    public class SwagPathOperation\n    {\n        public string Operation { get; set; } \n        public string OperationId { get; set; }\n        public string Description { get; set; }\n        public List<SwagRequestParameter> Parameters { get; set; } = new List<SwagRequestParameter>();\n        public Dictionary<string, SwagResponse> Responses { get; set; } = new Dictionary<string, SwagResponse>();\n        public List<string> Tags { get; set; } = new List<string>();\n\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"operationId\"] = OperationId,\n                [\"description\"] = Description,\n                [\"tags\"] = new JArray(Tags)\n            };\n\n            var jParams = new JArray();\n            foreach (var param in Parameters)\n            {\n                jParams.Add(param.ToJObject());\n            }\n            obj[\"parameters\"] = jParams;\n\n            var jResponses = new JObject();\n            foreach (var kvp in Responses)\n            {\n                jResponses[kvp.Key] = kvp.Value.ToJObject();\n            }\n            obj[\"responses\"] = jResponses;\n\n            return obj;\n        }\n    }\n\n    public class SwagRequestParameter\n    {\n        public string Name { get; set; }\n        public string InLocation { get; set; }   \n        public string Description { get; set; }\n        public bool Required { get; set; }\n        public string TypeParameter { get; set; }  \n        public SwagSchema Schema { get; set; } = new SwagSchema();\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"name\"] = Name,\n                [\"in\"] = InLocation,\n                [\"description\"] = Description,\n                [\"required\"] = Required\n            };\n\n            if (!string.IsNullOrEmpty(TypeParameter))\n            {\n                obj[\"type\"] = TypeParameter;\n            }\n            if (!string.IsNullOrEmpty(Schema.Name))\n            {\n                obj[\"schema\"] = new JObject { [\"$ref\"] = \"#/definitions/\" + Schema.Name };\n            }\n            return obj;\n        }\n    }\n\n    public class SwagSchema\n    {\n        public string Name { get; set; }\n    }\n\n    public class SwagResponse\n    {\n        public string StatusCode { get; set; }\n        public string Description { get; set; }\n        public SwagSchema Schema { get; set; } = new SwagSchema();\n        public List<SwagHeaders> Headers { get; set; } = new List<SwagHeaders>();\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"description\"] = Description\n            };\n\n            if (!string.IsNullOrEmpty(Schema.Name))\n            {\n                obj[\"schema\"] = new JObject { [\"$ref\"] = \"#/definitions/\" + Schema.Name };\n            }\n\n            if (Headers.Count > 0)\n            {\n                var jHeaders = new JObject();\n                foreach (var header in Headers)\n                {\n                    jHeaders[header.Name] = header.ToJObject();\n                }\n                obj[\"headers\"] = jHeaders;\n            }\n            return obj;\n        }\n    }\n\n    public class SwagHeaders\n    {\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public string ValueType { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"description\"] = Description,\n                [\"type\"] = ValueType\n            };\n        }\n    }\n\n    public class Form1 : Form\n    {\n        private TextBox memo1;\n        private Button btnGenerate;\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            this.memo1 = new TextBox();\n            this.btnGenerate = new Button();\n            \n            this.memo1.Multiline = true;\n            this.memo1.ScrollBars = ScrollBars.Both;\n            this.memo1.Location = new Point(12, 12);\n            this.memo1.Size = new Size(760, 400);\n            this.memo1.Font = new Font(\"Consolas\", 10);\n            \n            this.btnGenerate.Location = new Point(12, 420);\n            this.btnGenerate.Size = new Size(150, 30);\n            this.btnGenerate.Text = \"Generate\";\n            this.btnGenerate.Click += new EventHandler(this.btnGenerate_Click);\n             \n            this.ClientSize = new Size(784, 461);\n            this.Controls.Add(this.memo1);\n            this.Controls.Add(this.btnGenerate);\n            this.Text = \"Swagger Generator\";\n        }\n\n        private void btnGenerate_Click(object sender, EventArgs e)\n        {\n            \n            SwagDoc swagDoc = new SwagDoc();\n\n            \n            swagDoc.Info.Title = \"Sample API\";\n            swagDoc.Info.Version = \"v1.2\";\n            swagDoc.Info.TermsOfService = \"https://example.com/someurl/tos\";\n            swagDoc.Info.Description = \"Sample API Description\";\n            swagDoc.Info.Contact.Name = \"John Smith\";\n            swagDoc.Info.Contact.Email = \"jsmith@example.com\";\n            swagDoc.Info.Contact.Url = \"https://example.com/contact\";\n            swagDoc.Info.License.Name = \"Some License\";\n            swagDoc.Info.License.Url = \"https://example.com/license\";\n\n            \n            swagDoc.Host = \"example.com\";\n            swagDoc.BasePath = \"/basepath\";\n\n            \n            swagDoc.Consumes.Add(\"application/json\");\n            swagDoc.Produces.Add(\"text/xml\");\n            swagDoc.Produces.Add(\"application/json\");\n\n            \n            swagDoc.Schemes.Add(\"https\");\n\n            \n            SwagDefinition defSomeSubType = new SwagDefinition\n            {\n                Name = \"SomeSubType\",\n                JsonSchema = CreateJsonSomeSubType()\n            };\n            swagDoc.Definitions.Add(defSomeSubType);\n\n            SwagDefinition defSomeType = new SwagDefinition\n            {\n                Name = \"SomeType\",\n                JsonSchema = CreateJsonSomeType(defSomeSubType.GenerateJsonRefDefinition())\n            };\n            swagDoc.Definitions.Add(defSomeType);\n\n            \n            SwagPath path = new SwagPath\n            {\n                Uri = \"/path/request/{param1}\"\n            };\n\n            \n            SwagPathOperation operation = new SwagPathOperation\n            {\n                Operation = \"post\",\n                OperationId = \"RequestData\",\n                Description = \"Requests some data\"\n            };\n\n            \n            SwagRequestParameter param1 = new SwagRequestParameter\n            {\n                Name = \"param1\",\n                InLocation = \"path\",\n                Description = \"A param required\",\n                Required = true,\n                TypeParameter = \"string\"\n            };\n            operation.Parameters.Add(param1);\n\n            \n            SwagRequestParameter param2 = new SwagRequestParameter\n            {\n                Name = \"param2\",\n                InLocation = \"query\",\n                Description = \"A param that is not required\",\n                Required = false,\n                TypeParameter = \"string\"\n            };\n            operation.Parameters.Add(param2);\n\n           \n            SwagRequestParameter param3 = new SwagRequestParameter\n            {\n                Name = \"param3\",\n                InLocation = \"body\",\n                Required = true\n            };\n            param3.Schema.Name = \"SomeType\";\n            operation.Parameters.Add(param3);\n\n            SwagResponse response200 = new SwagResponse\n            {\n                StatusCode = \"200\",\n                Description = \"Successfully retrieved data\"\n            };\n            response200.Schema.Name = \"SomeType\";\n\n            SwagHeaders header = new SwagHeaders\n            {\n                Name = \"X-Rate-Limit-Limit\",\n                Description = \"The number of allowed requests in the current period\",\n                ValueType = \"integer\"\n            };\n            response200.Headers.Add(header);\n            operation.Responses.Add(\"200\", response200);\n\n            SwagResponse responseDefault = new SwagResponse\n            {\n                StatusCode = \""}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit PublicControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/')]\n  TPublicController = class(TMVCController)\n  public\n    [MVCPath('/')]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n\n  end;\n\nimplementation\n\nprocedure TPublicController.Index;\nbegin\n  // use Context property to access to the HTTP request and response\n  Render('Hello World');\n\nend;\n\nend.", "output": "namespace MyApp.Controllers { \n    [RoutePrefix(\"\")] \n    public class PublicController : ApiController { [HttpGet] [Route(\"\")] \n        public IHttpActionResult Index() { \n        \n            return Ok(\"Hello World\"); \n        } \n    } \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerJSONRPCU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.JSONRPC, JsonDataObjects,\n  BusinessObjectsU;\n\ntype\n  TTestJSONRPCController = class(TMVCJSONRPCController)\n  public\n    [MVCInheritable]\n    function Subtract(Value1, Value2: Int64): Integer;\n    [MVCInheritable]\n    procedure MyNotify;\n    [MVCInheritable]\n    function MyRequest: Boolean;\n    [MVCInheritable]\n    function Add(Value1, Value2, Value3: Int64): TJsonObject;\n    [MVCInheritable]\n    function GetListFromTo(aFrom, aTo: Int64): TJsonArray;\n    [MVCInheritable]\n    function MultiplyString(aString: string; Multiplier: Int64): string;\n\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCControllerWithGet = class(TTestJSONRPCController)\n\n  end;\n\n  TTestJSONRPCClass = class(TObject)\n  public\n    [MVCInheritable]\n    function Subtract(Value1, Value2: Int64): Integer;\n    [MVCInheritable]\n    procedure MyNotify;\n    [MVCInheritable]\n    function Add(Value1, Value2, Value3: Int64): TJsonObject;\n    [MVCInheritable]\n    function GetListFromTo(aFrom, aTo: Int64): TJsonArray;\n    [MVCInheritable]\n    function MultiplyString(aString: string; Multiplier: Int64): string;\n    [MVCInheritable]\n    function AddTimeToDateTime(aDateTime: TDateTime; aTime: TTime): TDateTime;\n\n    //exceptions\n    [MVCInheritable]\n    function DoError(MyObj: TPerson): TPerson;\n\n    //objects support\n    [MVCInheritable]\n    function HandlingObjects(MyObj: TPerson): TPerson;\n\n\n    //enums support\n    [MVCInheritable]\n    function ProcessEnums(Value1: TEnumTest; Value2: TEnumTest): TEnumTest;\n\n    //sets support\n    [MVCInheritable]\n    function ProcessSets(Value1: TSetOfEnumTest; Value2: TEnumTest): TSetOfEnumTest;\n\n    //records support\n    [MVCInheritable]\n    function GetSingleRecord: TSimpleRecord;\n    [MVCInheritable]\n    function GetArrayOfRecords: TArray<TSimpleRecord>;\n    [MVCInheritable]\n    function EchoSingleRecord(const SimpleRecord: TSimpleRecord): TSimpleRecord;\n    [MVCInheritable]\n    function GetSingleComplexRecord: TComplexRecord;\n    [MVCInheritable]\n    function EchoSingleComplexRecord(const ComplexRecord: TComplexRecord): TComplexRecord;\n    [MVCInheritable]\n    function EchoArrayOfRecords(const ComplexRecordArray: TComplexRecordArray): TComplexRecordArray;\n\n    //issues\n    [MVCInheritable]\n    function GetTCustomer_ISSUE648: TCustomerIssue648;\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCClassWithGET = class(TTestJSONRPCClass)\n\n  end;\n\n  TTestJSONRPCHookClass = class(TObject)\n  private\n    fJSONReq: TJsonObject;\n    fHistory: string;\n    fJSONRPCKind: TJSONRPCRequestType;\n  public\n    procedure OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJsonObject);\n    procedure OnBeforeCallHook(const Context: TWebContext; const JSON: TJsonObject);\n    procedure OnAfterCallHook(const Context: TWebContext; const JSON: TJsonObject);\n    [MVCInheritable]\n    function error_OnBeforeRoutingHook: Boolean;\n    [MVCInheritable]\n    function error_OnBeforeCallHook: Boolean;\n    [MVCInheritable]\n    function error_OnAfterCallHook: Boolean;\n    [MVCInheritable]\n    procedure Notif1;\n    [MVCInheritable]\n    procedure NotifWithError;\n    [MVCInheritable]\n    function Request1: string;\n    [MVCInheritable]\n    function RequestWithError: string;\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCHookClassWithGet = class(TTestJSONRPCHookClass)\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\n{ TTestJSONRPCController }\n\nfunction TTestJSONRPCController.Add(Value1, Value2, Value3: Int64): TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.I['res'] := Value1 + Value2 + Value3;\nend;\n\nfunction TTestJSONRPCController.GetListFromTo(aFrom, aTo: Int64): TJsonArray;\nvar\n  I: Cardinal;\nbegin\n  Result := TJsonArray.Create;\n  for I := aFrom to aTo do\n    Result.Add(I);\nend;\n\nfunction TTestJSONRPCClass.GetSingleComplexRecord: TComplexRecord;\nbegin\n  Result := TComplexRecord.Create;\nend;\n\nfunction TTestJSONRPCClass.GetSingleRecord: TSimpleRecord;\nbegin\n  Result := TSimpleRecord.Create;\nend;\n\nfunction TTestJSONRPCClass.GetTCustomer_ISSUE648: TCustomerIssue648;\nbegin\n  Result.Id := 155;\n  Result.Added := Now;\n  Result.Name := 'Daniele Teti';\n  Result.ExpirationDate := Now + 7;\n  Result.MaxUpdateDate.Clear;\n  Result.AppVersion.Clear;\n  Result.Activated.Clear;\nend;\n\nfunction TTestJSONRPCClass.HandlingObjects(MyObj: TPerson): TPerson;\nbegin\n  Result := TPerson.Create;\n  Result.ID := MyObj.ID;\n  Result.FirstName := MyObj.FirstName;\n  Result.LastName := MyObj.LastName;\n  Result.DOB := MyObj.DOB;\n  Result.Married := MyObj.Married;\nend;\n\nfunction TTestJSONRPCController.MultiplyString(aString: string; Multiplier: Int64): string;\nvar\n  I: Integer;\nbegin\n  Result := aString;\n  for I := 2 to Multiplier do\n  begin\n    Result := Result + aString;\n  end;\nend;\n\nprocedure TTestJSONRPCController.MyNotify;\nbegin\n  // this is a notify with no parameters and no result code\n  Self.ClassName;\nend;\n\nfunction TTestJSONRPCController.MyRequest: Boolean;\nbegin\n  Result := True;\nend;\n\nfunction TTestJSONRPCController.Subtract(Value1, Value2: Int64): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TTestJSONRPCClass }\n\nfunction TTestJSONRPCClass.Add(Value1, Value2, Value3: Int64): TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.I['res'] := Value1 + Value2 + Value3;\nend;\n\nfunction TTestJSONRPCClass.AddTimeToDateTime(aDateTime: TDateTime; aTime: TTime): TDateTime;\nbegin\n  Result := aDateTime + aTime;\nend;\n\nfunction TTestJSONRPCClass.DoError(MyObj: TPerson): TPerson;\nbegin\n  raise Exception.Create('BOOOM!! (TTestJSONRPCClass.DoError)');\nend;\n\nfunction TTestJSONRPCClass.EchoArrayOfRecords(\n  const ComplexRecordArray: TComplexRecordArray): TComplexRecordArray;\nbegin\n  Result := ComplexRecordArray;\nend;\n\nfunction TTestJSONRPCClass.EchoSingleComplexRecord(\n  const ComplexRecord: TComplexRecord): TComplexRecord;\nbegin\n  Result := ComplexRecord;\nend;\n\nfunction TTestJSONRPCClass.EchoSingleRecord(\n  const SimpleRecord: TSimpleRecord): TSimpleRecord;\nbegin\n  Result := SimpleRecord;\nend;\n\nfunction TTestJSONRPCClass.GetArrayOfRecords: TArray<TSimpleRecord>;\nbegin\n  SetLength(Result, 3);\n  Result[0] := TSimpleRecord.Create;\n  Result[1] := TSimpleRecord.Create;\n  Result[2] := TSimpleRecord.Create;\n\n  Result[0].IntegerProperty := 0;\n  Result[1].IntegerProperty := 1;\n  Result[2].IntegerProperty := 2;\nend;\n\nfunction TTestJSONRPCClass.GetListFromTo(aFrom, aTo: Int64): TJsonArray;\nvar\n  I: Cardinal;\nbegin\n  Result := TJsonArray.Create;\n  for I := aFrom to aTo do\n    Result.Add(I);\nend;\n\nfunction TTestJSONRPCClass.MultiplyString(aString: string; Multiplier: Int64): string;\nvar\n  I: Integer;\nbegin\n  Result := aString;\n  for I := 2 to Multiplier do\n  begin\n    Result := Result + aString;\n  end;\nend;\n\nprocedure TTestJSONRPCClass.MyNotify;\nbegin\n  // this is a notify with no parameters and no result code\n  Self.ClassName;\nend;\n\nfunction TTestJSONRPCClass.ProcessEnums(Value1, Value2: TEnumTest): TEnumTest;\nbegin\n  Result := TEnumTest((Ord(Value1) + Ord(Value2)) mod 3);\nend;\n\nfunction TTestJSONRPCClass.ProcessSets(Value1: TSetOfEnumTest;\n  Value2: TEnumTest): TSetOfEnumTest;\nbegin\n  Include(Value1, Value2);\n  Result := Value1;\nend;\n\nfunction TTestJSONRPCClass.Subtract(Value1, Value2: Int64): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TTestJSONRPCHookClass }\n\nfunction TTestJSONRPCHookClass.error_OnAfterCallHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nfunction TTestJSONRPCHookClass.error_OnBeforeCallHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nfunction TTestJSONRPCHookClass.error_OnBeforeRoutingHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nprocedure TTestJSONRPCHookClass.Notif1;\nbegin\n  // do nothing\nend;\n\nprocedure TTestJSONRPCHookClass.NotifWithError;\nbegin\n  raise Exception.Create('BOOM NOTIF');\nend;\n\nprocedure TTestJSONRPCHookClass.OnAfterCallHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  try\n    if SameText(fJSONReq.S['method'], 'error_OnAfterCallHook') then\n      raise Exception.Create('error_OnAfterCallHook');\n\n    fHistory := fHistory + '|OnAfterCallHook';\n\n    // do nothing\n    if fJSONRPCKind = TJSONRPCRequestType.Request then\n    begin\n      Assert(Assigned(JSON));\n      LogD('TTestJSONRPCHookClass.OnAfterCallHook: ' + JSON.ToJSON());\n    end\n    else\n    begin\n      if Assigned(JSON) then\n        Assert(JSON.Contains('error'), 'ERROR! Notification has a response but is not an error');\n      LogD('TTestJSONRPCHookClass.OnAfterCallHook: Param is nil');\n    end;\n    if Assigned(JSON) then\n      if JSON.Contains('error') then\n        fHistory := fHistory + '|error';\n    Context.Response.CustomHeaders.Values['x-history'] := fHistory;\n  finally\n    FreeAndNil(fJSONReq);\n  end;\nend;\n\nprocedure TTestJSONRPCHookClass.OnBeforeCallHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  if SameText(JSON.S['method'], 'error_OnBeforeCallHook') then\n    raise Exception.Create('error_OnBeforeCallHook');\n\n  fHistory := fHistory + '|OnBeforeCallHook';\n  Assert(Assigned(JSON), 'JSON not assigned in OnBeforeCallHook');\n  LogD('TTestJSONRPCHookClass.OnBeforeCallHook: ' + JSON.ToJSON());\nend;\n\nprocedure TTestJSONRPCHookClass.OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  fJSONReq := JSON.Clone as TJsonObject;\n\n  if SameText(JSON.S['method'], 'error_OnBeforeRoutingHook') then\n    raise Exception.Create('error_OnBeforeRoutingHook');\n\n  fHistory := 'OnBeforeRoutingHook';\n  // do nothing\n  Assert(Assigned(JSON), 'JSON not assigned in OnBeforeRoutingHook');\n  LogD('TTestJSONRPCHookClass.OnBeforeRoutingHook: ' + JSON.ToJSON());\n  if JSON.Contains('id') then\n    fJSONRPCKind := TJSONRPCRequestType.Request\n  else\n    fJSONRPCKind := TJSONRPCRequestType.Notification;\nend;\n\nfunction TTestJSONRPCHookClass.Request1: string;\nbegin\n  Result := 'empty';\nend;\n\nfunction TTestJSONRPCHookClass.RequestWithError: string;\nbegin\n  raise Exception.Create('BOOM REQUEST');\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Newtonsoft.Json.Linq;\n\nnamespace TestServer.JSONRPC\n{\n    public enum TEnumTest\n    {\n        ptEnumValue0,\n        ptEnumValue1,\n        ptEnumValue2,\n        ptEnumValue3\n    }\n\n    public class TSetOfEnumTest : HashSet<TEnumTest>\n    {\n    }\n\n    public class TSimpleRecord\n    {\n        public int IntegerProperty { get; set; }\n    }\n\n    public class TComplexRecord\n    {\n        public TComplexRecord() { }\n    }\n\n    public class TCustomerIssue648\n    {\n        public int Id { get; set; }\n        public DateTime Added { get; set; }\n        public string Name { get; set; }\n        public DateTime ExpirationDate { get; set; }\n        public DateTime? MaxUpdateDate { get; set; }\n        public string AppVersion { get; set; }\n        public string Activated { get; set; }\n    }\n\n    public class TPerson\n    {\n        public int ID { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        public DateTime DOB { get; set; }\n        public bool Married { get; set; }\n    }\n\n    public enum JSONRPCRequestType\n    {\n        Request,\n        Notification\n    }\n\n    [Route(\"api/jsonrpc\")]\n    [ApiController]\n    public class TestJsonRpcController : ControllerBase\n    {\n        [HttpPost(\"subtract\")]\n        [MVCInheritable]\n        public ActionResult<int> Subtract(long value1, long value2)\n        {\n            return (int)(value1 - value2);\n        }\n\n        [HttpPost(\"mynotify\")]\n        [MVCInheritable]\n        public IActionResult MyNotify()\n        {\n            var _ = GetType().Name;\n            return Ok();\n        }\n\n        [HttpPost(\"myrequest\")]\n        [MVCInheritable]\n        public ActionResult<bool> MyRequest()\n        {\n            return true;\n        }\n\n        [HttpPost(\"add\")]\n        [MVCInheritable]\n        public ActionResult<JObject> Add(long value1, long value2, long value3)\n        {\n            var obj = new JObject();\n            obj[\"res\"] = value1 + value2 + value3;\n            return obj;\n        }\n\n        [HttpPost(\"getlistfromto\")]\n        [MVCInheritable]\n        public ActionResult<JArray> GetListFromTo(long aFrom, long aTo)\n        {\n            var arr = new JArray();\n            for (long i = aFrom; i <= aTo; i++)\n                arr.Add(i);\n            return arr;\n        }\n\n        [HttpPost(\"multiplystring\")]\n        [MVCInheritable]\n        public ActionResult<string> MultiplyString(string aString, long multiplier)\n        {\n            var result = aString;\n            for (int i = 2; i <= multiplier; i++)\n                result += aString;\n            return result;\n        }\n    }\n\n    [Route(\"api/jsonrpcwithget\")]\n    [ApiController]\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcControllerWithGet : TestJsonRpcController\n    {\n    }\n\n    public class TestJsonRpcClass\n    {\n        [MVCInheritable]\n        public int Subtract(long value1, long value2)\n        {\n            return (int)(value1 - value2);\n        }\n\n        [MVCInheritable]\n        public void MyNotify()\n        {\n            var _ = GetType().Name;\n        }\n\n        [MVCInheritable]\n        public JObject Add(long value1, long value2, long value3)\n        {\n            var obj = new JObject();\n            obj[\"res\"] = value1 + value2 + value3;\n            return obj;\n        }\n\n        [MVCInheritable]\n        public JArray GetListFromTo(long aFrom, long aTo)\n        {\n            var arr = new JArray();\n            for (long i = aFrom; i <= aTo; i++)\n                arr.Add(i);\n            return arr;\n        }\n\n        [MVCInheritable]\n        public string MultiplyString(string aString, long multiplier)\n        {\n            var result = aString;\n            for (int i = 2; i <= multiplier; i++)\n                result += aString;\n            return result;\n        }\n\n        [MVCInheritable]\n        public DateTime AddTimeToDateTime(DateTime aDateTime, TimeSpan aTime)\n        {\n            return aDateTime + aTime;\n        }\n\n        [MVCInheritable]\n        public TPerson DoError(TPerson myObj)\n        {\n            throw new Exception(\"BOOOM!! (TestJsonRpcClass.DoError)\");\n        }\n\n        [MVCInheritable]\n        public TPerson HandlingObjects(TPerson myObj)\n        {\n            return new TPerson\n            {\n                ID = myObj.ID,\n                FirstName = myObj.FirstName,\n                LastName = myObj.LastName,\n                DOB = myObj.DOB,\n                Married = myObj.Married\n            };\n        }\n\n        [MVCInheritable]\n        public TEnumTest ProcessEnums(TEnumTest value1, TEnumTest value2)\n        {\n            return (TEnumTest)(((int)value1 + (int)value2) % 3);\n        }\n\n        [MVCInheritable]\n        public TSetOfEnumTest ProcessSets(TSetOfEnumTest value1, TEnumTest value2)\n        {\n            value1.Add(value2);\n            return value1;\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord GetSingleRecord()\n        {\n            return new TSimpleRecord();\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord[] GetArrayOfRecords()\n        {\n            return new TSimpleRecord[] { new TSimpleRecord(), new TSimpleRecord(), new TSimpleRecord() };\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord EchoSingleRecord(TSimpleRecord simpleRecord)\n        {\n            return simpleRecord;\n        }\n\n        [MVCInheritable]\n        public TComplexRecord GetSingleComplexRecord()\n        {\n            return new TComplexRecord();\n        }\n\n        [MVCInheritable]\n        public TComplexRecord EchoSingleComplexRecord(TComplexRecord complexRecord)\n        {\n            return complexRecord;\n        }\n\n        [MVCInheritable]\n        public TComplexRecord[] EchoArrayOfRecords(TComplexRecord[] complexRecordArray)\n        {\n            return complexRecordArray;\n        }\n\n        [MVCInheritable]\n        public TCustomerIssue648 GetTCustomer_ISSUE648()\n        {\n            return new TCustomerIssue648\n            {\n                Id = 155,\n                Added = DateTime.Now,\n                Name = \"Daniele Teti\",\n                ExpirationDate = DateTime.Now.AddDays(7),\n                MaxUpdateDate = null,\n                AppVersion = null,\n                Activated = null\n            };\n        }\n    }\n\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcClassWithGet : TestJsonRpcClass\n    {\n    }\n\n    public class TestJsonRpcHookClass\n    {\n        private JObject fJSONReq;\n        private string fHistory;\n        private JSONRPCRequestType fJSONRPCKind;\n        public void OnBeforeRoutingHook(WebContext context, JObject json)\n        {\n            fJSONReq = (JObject)json.DeepClone();\n            if (string.Equals(json.Value<string>(\"method\"), \"error_OnBeforeRoutingHook\", StringComparison.OrdinalIgnoreCase))\n                throw new Exception(\"error_OnBeforeRoutingHook\");\n            fHistory = \"OnBeforeRoutingHook\";\n            if (json.ContainsKey(\"id\"))\n                fJSONRPCKind = JSONRPCRequestType.Request;\n            else\n                fJSONRPCKind = JSONRPCRequestType.Notification;\n        }\n        public void OnBeforeCallHook(WebContext context, JObject json)\n        {\n            if (string.Equals(json.Value<string>(\"method\"), \"error_OnBeforeCallHook\", StringComparison.OrdinalIgnoreCase))\n                throw new Exception(\"error_OnBeforeCallHook\");\n            fHistory += \"|OnBeforeCallHook\";\n        }\n        public void OnAfterCallHook(WebContext context, JObject json)\n        {\n            try\n            {\n                if (string.Equals(fJSONReq.Value<string>(\"method\"), \"error_OnAfterCallHook\", StringComparison.OrdinalIgnoreCase))\n                    throw new Exception(\"error_OnAfterCallHook\");\n                fHistory += \"|OnAfterCallHook\";\n                if (fJSONRPCKind == JSONRPCRequestType.Request)\n                {\n                    if (json == null)\n                        throw new Exception(\"JSON is null\");\n                }\n                else\n                {\n                    if (json != null)\n                        if (!json.ContainsKey(\"error\"))\n                            throw new Exception(\"ERROR! Notification has a response but is not an error\");\n                }\n                if (json != null && json.ContainsKey(\"error\"))\n                    fHistory += \"|error\";\n                context.Response.Headers[\"x-history\"] = fHistory;\n            }\n            finally\n            {\n                fJSONReq = null;\n            }\n        }\n        [MVCInheritable]\n        public bool error_OnBeforeRoutingHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public bool error_OnBeforeCallHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public bool error_OnAfterCallHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public void Notif1()\n        {\n        }\n        [MVCInheritable]\n        public void NotifWithError()\n        {\n            throw new Exception(\"BOOM NOTIF\");\n        }\n        [MVCInheritable]\n        public string Request1()\n        {\n            return \"empty\";\n        }\n        [MVCInheritable]\n        public string RequestWithError()\n        {\n            throw new Exception(\"BOOM REQUEST\");\n        }\n    }\n\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcHookClassWithGet : TestJsonRpcHookClass\n    {\n    }\n}"}
{"input": "unit BOCustomersU;\n\ninterface\n\nuses MVCFramework.Serializer.Commons, System.Generics.Collections;\n\ntype\n\n  {$M+}\n\n  [MVCNameCase(ncLowerCase)]\n  TCustomer = class\n  private\n    FSurname: string;\n    FMiddleName: string;\n    FFirstName: string;\n    procedure SetFirstName(const Value: string);\n    procedure SetMiddleName(const Value: string);\n    procedure SetSurname(const Value: string);\n  published\n    property FirstName: string read FFirstName write SetFirstName;\n    property MiddleName: string read FMiddleName write SetMiddleName;\n    property Surname: string read FSurname write SetSurname;\n\n  end;\n\ntype\n  TCustomers = TObjectList<TCustomer>;\n\nimplementation\n\n{ TCustomer }\n\nprocedure TCustomer.SetFirstName(const Value: string);\nbegin\n  FFirstName := Value;\nend;\n\nprocedure TCustomer.SetMiddleName(const Value: string);\nbegin\n  FMiddleName := Value;\nend;\n\nprocedure TCustomer.SetSurname(const Value: string);\nbegin\n  FSurname := Value;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace BOCustersU\n{\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCNameCaseAttribute : Attribute\n    {\n        public string NameCase { get; }\n        public MVCNameCaseAttribute(string nameCase)\n        {\n            NameCase = nameCase;\n        }\n    }\n\n   \n    [MVCNameCase(\"lowercase\")]\n    public class Customer\n    {\n        private string _firstName;\n        private string _middleName;\n        private string _surname;\n\n        public string FirstName\n        {\n            get { return _firstName; }\n            set { _firstName = value; }\n        }\n\n        public string MiddleName\n        {\n            get { return _middleName; }\n            set { _middleName = value; }\n        }\n\n        public string Surname\n        {\n            get { return _surname; }\n            set { _surname = value; }\n        }\n    }\n\n        public class Customers : List<Customer>\n    {\n    }\n}"}
{"input": "unit frmLoadSwaggerJson;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls,\n  Swag.Common.Types,\n  Swag.Doc,\n  Swag.Doc.Definition,\n  Swag.Doc.Path,\n  Swag.Doc.Path.Operation;\n\ntype\n  TfrmSimpleSwaggerDocDemo = class(TForm)\n    Memo1: TMemo;\n    btnLoadJSON: TButton;\n    lblApiDescription: TLabel;\n    procedure btnLoadJSONClick(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nvar\n  frmSimpleSwaggerDocDemo: TfrmSimpleSwaggerDocDemo;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  Json.Common.Helpers,\n  System.IOUtils;\n\nprocedure TfrmSimpleSwaggerDocDemo.btnLoadJSONClick(Sender: TObject);\nvar\n  vSwagDoc: TSwagDoc;\nbegin\n  vSwagDoc := TSwagDoc.Create;\n  try\n    vSwagDoc.LoadFromFile('swagger.json');\n    lblApiDescription.Caption := vSwagDoc.Info.Description;\n    vSwagDoc.GenerateSwaggerJson;\n    Memo1.Lines.Clear;\n    Memo1.Lines.Add(vSwagDoc.SwaggerJson.Format);\n  finally\n    FreeAndNil(vSwagDoc);\n  end;\nend;\n\ninitialization\n  ReportMemoryLeaksOnShutdown := True;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.IO;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace frmLoadSwaggerJson\n{\n    public class SwagInfo\n    {\n        public string Title { get; set; } = \"\";\n        public string Version { get; set; } = \"\";\n        public string TermsOfService { get; set; } = \"\";\n        public string Description { get; set; } = \"\";\n    }\n\n    public class SwagDoc\n    {\n        public SwagInfo Info { get; set; } = new SwagInfo();\n        public string Host { get; set; } = \"\";\n        public string BasePath { get; set; } = \"\";\n        public List<string> Consumes { get; set; } = new List<string>();\n        public List<string> Produces { get; set; } = new List<string>();\n        public List<string> Schemes { get; set; } = new List<string>();\n        public List<object> Definitions { get; set; } = new List<object>();\n        public List<object> Paths { get; set; } = new List<object>();\n\n        public JObject SwaggerJson { get; set; }\n\n        \n        public void LoadFromFile(string filename)\n        {\n            string content = File.ReadAllText(filename);\n            \n            SwaggerJson = JObject.Parse(content);\n            \n            if (SwaggerJson[\"info\"] is JObject infoObj)\n            {\n                Info = new SwagInfo\n                {\n                    Title = infoObj.Value<string>(\"title\") ?? \"\",\n                    Version = infoObj.Value<string>(\"version\") ?? \"\",\n                    TermsOfService = infoObj.Value<string>(\"termsOfService\") ?? \"\",\n                    Description = infoObj.Value<string>(\"description\") ?? \"\"\n                };\n            }\n        }\n\n        \n        public void GenerateSwaggerJson()\n        {\n            var doc = new JObject\n            {\n                [\"swagger\"] = \"2.0\",\n                [\"info\"] = new JObject\n                {\n                    [\"title\"] = Info.Title,\n                    [\"version\"] = Info.Version,\n                    [\"termsOfService\"] = Info.TermsOfService,\n                    [\"description\"] = Info.Description\n                },\n                [\"host\"] = Host,\n                [\"basePath\"] = BasePath,\n                [\"consumes\"] = new JArray(Consumes),\n                [\"produces\"] = new JArray(Produces),\n                [\"schemes\"] = new JArray(Schemes),\n                [\"definitions\"] = new JObject(), \n                [\"paths\"] = new JObject()        \n            };\n\n            SwaggerJson = doc;\n        }\n    }\n    public class SimpleSwaggerDocDemoForm : Form\n    {\n        private TextBox memo1;\n        private Button btnLoadJSON;\n        private Label lblApiDescription;\n\n        public SimpleSwaggerDocDemoForm()\n        {\n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            this.memo1 = new TextBox();\n            this.btnLoadJSON = new Button();\n            this.lblApiDescription = new Label();\n            \n            this.memo1.Multiline = true;\n            this.memo1.ScrollBars = ScrollBars.Both;\n            this.memo1.Location = new Point(12, 50);\n            this.memo1.Size = new Size(760, 400);\n            this.memo1.Font = new Font(\"Consolas\", 10);\n             \n            this.btnLoadJSON.Location = new Point(12, 10);\n            this.btnLoadJSON.Size = new Size(120, 30);\n            this.btnLoadJSON.Text = \"Load JSON\";\n            this.btnLoadJSON.Click += new EventHandler(this.btnLoadJSON_Click);\n             \n            this.lblApiDescription.Location = new Point(150, 10);\n            this.lblApiDescription.Size = new Size(400, 30);\n            this.lblApiDescription.Text = \"API Description\";\n            \n            this.ClientSize = new Size(784, 461);\n            this.Controls.Add(this.memo1);\n            this.Controls.Add(this.btnLoadJSON);\n            this.Controls.Add(this.lblApiDescription);\n            this.Text = \"Swagger JSON Loader\";\n        }\n\n        private void btnLoadJSON_Click(object sender, EventArgs e)\n        {\n            try\n            {\n                SwagDoc swagDoc = new SwagDoc();\n                swagDoc.LoadFromFile(\"swagger.json\");\n                lblApiDescription.Text = swagDoc.Info.Description;\n                swagDoc.GenerateSwaggerJson();\n                memo1.Text = swagDoc.SwaggerJson.ToString(Formatting.Indented);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(\"Error loading JSON: \" + ex.Message);\n            }\n        }\n    }\n    static class Program\n    {\n        [STAThread]\n        static void Main()\n        {\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new SimpleSwaggerDocDemoForm());\n        }\n    }\n}"}
{"input": "unit ActionFiltersControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/')]\n  TActionFiltersController = class(TMVCController)\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n\n    procedure OnBeforeAction(Context: TWebContext; const AActionNAme: string;\n      var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionNAme: string);\n      override;\n\n  public\n    [MVCHTTPMethod([httpGet])]\n    [MVCPath('/people/($id)')]\n    [MVCProduces('application/json')]\n    { This action cannot be called by a browser address bar because requires the\n      ACCEPT header to be application/json. Use Postman or RAD Studio's RESTDebugger. }\n    procedure GetPerson(id: Integer);\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, BusinessObjectsU, Data.DBXJSON, MVCFramework.Logger;\n\n{ TActionFiltersController }\n\nprocedure TActionFiltersController.GetPerson(id: Integer);\nvar\n  P: TPerson;\nbegin\n  {\n    Use ID to load the person from a database...\n    In this example, we're creating a fake person\n  }\n  P := TPerson.Create;\n  P.FirstName := 'Daniele';\n  P.LastName := 'Teti';\n  P.DOB := EncodeDate(1975, 5, 2);\n  P.Married := True;\n  Render(P);\nend;\n\nprocedure TActionFiltersController.MVCControllerAfterCreate;\nbegin\n  inherited;\n  // raise Exception.Create('Error Message');\n  Log.Info('MVCControllerAfterCreate', 'ACTIONFILTERS');\nend;\n\nprocedure TActionFiltersController.MVCControllerBeforeDestroy;\nbegin\n  inherited;\nend;\n\nprocedure TActionFiltersController.OnAfterAction(Context: TWebContext;\n  const AActionNAme: string);\nbegin\n  inherited;\n  Log.Info('ACTION CALLED: ' + AActionNAme +\n    ' mapped to ' + Context.Request.PathInfo +\n    ' from ' + Context.Request.ClientIP, 'ACTIONFILTERS');\nend;\n\nprocedure TActionFiltersController.OnBeforeAction(Context: TWebContext;\n  const AActionNAme: string; var Handled: Boolean);\nbegin\n  inherited;\n  if DayOfWeek(date) in [1, 7] then\n    raise Exception.Create('You cannot use this service in the WeekEnd');\n  // if handled = true (or exception raised) then actual action will not be called\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ActionFiltersControllerU\n{\n    [Route(\"/\")]\n    [ApiController]\n    public class ActionFiltersController : ControllerBase\n    {\n        private readonly ILogger<ActionFiltersController> _logger;\n\n        public ActionFiltersController(ILogger<ActionFiltersController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"MVCControllerAfterCreate\");\n        }\n\n        public override async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)\n        {\n            if (DateTime.Now.DayOfWeek == DayOfWeek.Saturday || DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\n            {\n                \n                context.Result = BadRequest(\"You cannot use this service in the Weekend\");\n                return;\n            }\n\n            var resultContext = await next();\n\n            var actionName = context.ActionDescriptor.DisplayName;\n            var path = context.HttpContext.Request.Path;\n            var clientIp = context.HttpContext.Connection.RemoteIpAddress?.ToString();\n            _logger.LogInformation($\"ACTION CALLED: {actionName} mapped to {path} from {clientIp}\");\n        }\n\n\n        [HttpGet(\"people/{id}\")]\n        [Produces(\"application/json\")]\n        public IActionResult GetPerson(int id)\n        {\n            var person = new Person\n            {\n                Id = id,\n                FirstName = \"Daniele\",\n                LastName = \"Teti\",\n                DOB = new DateTime(1975, 5, 2),\n                Married = true\n            };\n\n            return Ok(person);\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            base.Dispose(disposing);\n        }\n    }\n\n    public class Person\n    {\n        public int Id { get; set; } \n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        public DateTime DOB { get; set; }\n        public bool Married { get; set; }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ObjectPool;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  System.DateUtils;\n\n\nconst\n  AVG_SAMPLES_COUNT = 10;\ntype\n  EObjectPool = class(Exception)\n\n  end;\n\n  IObjectPool<T: class, constructor> = interface\n    ['{0E79863D-D6F9-4426-9D80-F4C215233582}']\n    function GetFromPool(const RaiseExceptionIfNotAvailable: Boolean = False): T;\n    procedure ReleaseToPool(const Obj: T);\n    function Size: UInt32;\n  end;\n\n\n  TCleanupThread<T: class, constructor> = class;\n  TObjectPool<T: class, constructor> = class(TInterfacedObject, IObjectPool<T>)\n  private\n    fFactory: TFunc<T>;\n    fMaxSize: Integer;\n    fPool: TStack<T>;\n    fSize: Integer;\n    fShrinkTargetSize: Integer;\n    fShrinkTriggerSize: Integer;\n    fCleanupThread: TCleanupThread<T>;\n    fLastGetFromPool: TDateTime;\n    fOnResetState: TProc<T>;\n  protected\n    procedure Lock;\n    procedure UnLock;\n    procedure ShrinkPoolTo(const TargetSize: Integer);\n  public\n    constructor Create(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil);\n    destructor Destroy; override;\n    function GetFromPool(const RaiseExceptionIfNotAvailable: Boolean = False): T;\n    procedure ReleaseToPool(const Obj: T);\n    function Size: UInt32;\n    property OnResetState: TProc<T> read fOnResetState write fOnResetState;\n  end;\n\n  TCleanupThread<T: class, constructor> = class(TThread)\n  private\n    fObjectPool: TObjectPool<T>;\n    type\n      TPoolSizeSamples = array [0..AVG_SAMPLES_COUNT-1] of Integer;\n    function GetAveragePoolSize(var SizeSamples: TPoolSizeSamples): Integer;\n  protected\n    procedure Execute; override;\n  public\n    constructor Create(ObjectPool: TObjectPool<T>);\n  end;\n\n  TPoolFactory = class\n  public\n    class function CreatePool<T: class, constructor>(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil): IObjectPool<T>;\n    class function CreateUnlimitedPool<T: class, constructor>(ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil): IObjectPool<T>;\n  end;\n\n\nvar\n  GObjectPoolSamplingIntervalMS: UInt32 = 10000;\n\nimplementation\n\n{ TObjectPool<T> }\n\nconstructor TObjectPool<T>.Create(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T>);\nbegin\n  inherited Create;\n  fOnResetState := nil;\n  fLastGetFromPool := 0;\n  fFactory := Factory;\n  fMaxSize := MaxSize;\n  fShrinkTargetSize := ShrinkTargetSize;\n  fShrinkTriggerSize := ShrinkTriggerSize;\n  fPool := TStack<T>.Create;\n  fCleanupThread := nil;\n  if fShrinkTriggerSize > 0 then\n  begin\n    fCleanupThread := TCleanupThread<T>.Create(Self);\n  end;\nend;\n\ndestructor TObjectPool<T>.Destroy;\nbegin\n  if Assigned(fCleanupThread) then\n  begin\n    fCleanupThread.Terminate;\n    fCleanupThread.Free;\n  end;\n  while fPool.Count > 0 do\n    fPool.Pop.Free;\n  FreeAndNil(fPool);\n  inherited;\nend;\n\nfunction TObjectPool<T>.GetFromPool(const RaiseExceptionIfNotAvailable: Boolean): T;\nbegin\n  MonitorEnter(Self);\n  try\n    fLastGetFromPool := Now();\n    if fPool.Count > 0 then\n    begin\n      Exit(fPool.Pop);\n    end;\n\n    if (fMaxSize > 0) and (fSize >= fMaxSize) then\n    begin\n      if RaiseExceptionIfNotAvailable then\n        raise EObjectPool.CreateFmt('Pool cannot provide an instance of %s', [T.ClassName]);\n      Exit(nil);\n    end;\n\n    if Assigned(fFactory) then\n    begin\n      Result := fFactory()\n    end\n    else\n    begin\n      Result := T.Create;\n    end;\n\n    Inc(fSize);\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.Lock;\nbegin\n  MonitorEnter(Self);\nend;\n\nprocedure TObjectPool<T>.ReleaseToPool(const Obj: T);\nbegin\n  if Assigned(fOnResetState) then\n  begin\n    fOnResetState(Obj);\n  end;\n  MonitorEnter(Self);\n  try\n    fPool.Push(Obj);\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.ShrinkPoolTo(const TargetSize: Integer);\nbegin\n  MonitorEnter(Self);\n  try\n    while fSize > TargetSize do\n    begin\n      fPool.Pop.Free;\n      Dec(fSize);\n    end;\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nfunction TObjectPool<T>.Size: UInt32;\nbegin\n  MonitorEnter(Self);\n  try\n    Result := fPool.Count;\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.UnLock;\nbegin\n  MonitorExit(Self);\nend;\n\nconstructor TCleanupThread<T>.Create(ObjectPool: TObjectPool<T>);\nbegin\n  fObjectPool := ObjectPool;\n  inherited Create(False);\nend;\n\nprocedure TCleanupThread<T>.Execute;\nvar\n  lAvgSize: TPoolSizeSamples;\n  lArrIndex: Integer;\n  lSampleTick: Integer;\nbegin\n  lSampleTick := 0;\n  while not Terminated do\n  begin\n    Inc(lSampleTick);\n    lArrIndex := lSampleTick mod AVG_SAMPLES_COUNT;\n    lAvgSize[lArrIndex] := fObjectPool.Size;\n    if (lAvgSize[lArrIndex] > 0) and (GetAveragePoolSize(lAvgSize) >= fObjectPool.fShrinkTriggerSize) then\n    begin\n      fObjectPool.Lock;\n      try\n        fObjectPool.ShrinkPoolTo(fObjectPool.fShrinkTargetSize);\n        FillChar(lAvgSize, SizeOf(lAvgSize), 0);\n      finally\n        fObjectPool.UnLock;\n      end;\n    end\n    else\n    begin\n      Sleep(GObjectPoolSamplingIntervalMS);\n      if lSampleTick = MaxInt  then\n      begin\n        lSampleTick := 0;\n      end;\n    end;\n  end;\nend;\n\nfunction TCleanupThread<T>.GetAveragePoolSize(\n  var SizeSamples: TPoolSizeSamples): Integer;\nvar\n  I: Integer;\nbegin\n  Result := 0;\n  for I := Low(TPoolSizeSamples) to High(TPoolSizeSamples) do\n  begin\n    Inc(Result, SizeSamples[I]);\n  end;\n  Result := Result div Length(SizeSamples);\nend;\n\n{ TPoolFactory }\n\nclass function TPoolFactory.CreatePool<T>(MaxSize, ShrinkTriggerSize,\n  ShrinkTargetSize: Integer; const Factory: TFunc<T>): IObjectPool<T>;\nbegin\n  Result := TObjectPool<T>.Create(MaxSize, ShrinkTriggerSize,\n    ShrinkTargetSize, Factory);\nend;\n\nclass function TPoolFactory.CreateUnlimitedPool<T>(ShrinkTriggerSize,\n  ShrinkTargetSize: Integer; const Factory: TFunc<T>): IObjectPool<T>;\nbegin\n  Result := CreatePool<T>(0, ShrinkTriggerSize,\n    ShrinkTargetSize, Factory);\nend;\n\nend.", "output": "using System;\nusing System.Globalization;\n\nnamespace MVCFramework.Nullables\n{\n   \n    public class EMVCNullable : Exception\n    {\n        public EMVCNullable(string message) : base(message) { }\n    }\n\n    \n    public struct NullableString\n    {\n        private string _value;\n        private bool _hasValue;\n\n        \n        public bool HasValue => _hasValue;\n\n        \n        public bool IsNull => !_hasValue;\n\n        \n        public string Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableString value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        \n        public void Clear() => SetNull();\n\n        \n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n\n        \n        public string ValueOrDefault() => HasValue ? _value : default;\n\n        \n        public string ValueOrElse(string elseValue) => HasValue ? _value : elseValue;\n\n        \n        public bool TryHasValue(out string value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n\n        public override bool Equals(object obj) =>\n            obj is NullableString other && Equals(other);\n\n        public bool Equals(NullableString other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableString(string value) =>\n            new NullableString { _value = value, _hasValue = true };\n\n        public static implicit operator string(NullableString ns) => ns.Value;\n\n        public static bool operator ==(NullableString left, NullableString right) =>\n            left.Equals(right);\n\n        public static bool operator !=(NullableString left, NullableString right) =>\n            !left.Equals(right);\n\n        public override string ToString() => HasValue ? _value : \"\";\n    }\n\n    \n    public struct NullableCurrency\n    {\n        private decimal _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public decimal Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableCurrency value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public decimal ValueOrDefault() => HasValue ? _value : default;\n        public decimal ValueOrElse(decimal elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out decimal value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableCurrency other && Equals(other);\n        public bool Equals(NullableCurrency other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableCurrency(decimal value) =>\n            new NullableCurrency { _value = value, _hasValue = true };\n        public static implicit operator decimal(NullableCurrency nc) => nc.Value;\n\n        public static bool operator ==(NullableCurrency left, NullableCurrency right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableCurrency left, NullableCurrency right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableBoolean\n    {\n        private bool _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public bool Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableBoolean value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public bool ValueOrDefault() => HasValue ? _value : default;\n        public bool ValueOrElse(bool elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out bool value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableBoolean other && Equals(other);\n        public bool Equals(NullableBoolean other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableBoolean(bool value) =>\n            new NullableBoolean { _value = value, _hasValue = true };\n        public static implicit operator bool(NullableBoolean nb) => nb.Value;\n\n        public static bool operator ==(NullableBoolean left, NullableBoolean right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableBoolean left, NullableBoolean right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDate\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        \n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDate value is null\");\n                return _value.Date;\n            }\n            set\n            {\n                _value = value.Date;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value.Date : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value.Date : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value.Date;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDate other && Equals(other);\n        public bool Equals(NullableTDate other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Date.Equals(other._value.Date));\n        public override int GetHashCode() => HasValue ? _value.Date.GetHashCode() : 0;\n\n        public static implicit operator NullableTDate(DateTime value) =>\n            new NullableTDate { _value = value.Date, _hasValue = true };\n        public static implicit operator DateTime(NullableTDate ntd) => ntd.Value;\n\n        public static bool operator ==(NullableTDate left, NullableTDate right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDate left, NullableTDate right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTTime\n    {\n        private TimeSpan _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public TimeSpan Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public TimeSpan ValueOrDefault() => HasValue ? _value : default;\n        public TimeSpan ValueOrElse(TimeSpan elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out TimeSpan value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTTime other && Equals(other);\n        public bool Equals(NullableTTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTTime(TimeSpan value) =>\n            new NullableTTime { _value = value, _hasValue = true };\n        public static implicit operator TimeSpan(NullableTTime ntt) => ntt.Value;\n\n        public static bool operator ==(NullableTTime left, NullableTTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTTime left, NullableTTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDateTime\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDateTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDateTime other && Equals(other);\n        public bool Equals(NullableTDateTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTDateTime(DateTime value) =>\n            new NullableTDateTime { _value = value, _hasValue = true };\n        public static implicit operator DateTime(NullableTDateTime ntdt) => ntdt.Value;\n\n        public static bool operator ==(NullableTDateTime left, NullableTDateTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDateTime left, NullableTDateTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableSingle\n    {\n        private float _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public float Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableSingle value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public float ValueOrDefault() => HasValue ? _value : default;\n        public float ValueOrElse(float elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out float value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableSingle other && Equals(other);\n        public bool Equals(NullableSingle other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-6);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableSingle(float value) =>\n            new NullableSingle { _value = value, _hasValue = true };\n        public static implicit operator float(NullableSingle ns) => ns.Value;\n\n        public static bool operator ==(NullableSingle left, NullableSingle right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableSingle left, NullableSingle right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableDouble\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableDouble value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableDouble other && Equals(other);\n        public bool Equals(NullableDouble other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableDouble(double value) =>\n            new NullableDouble { _value = value, _hasValue = true };\n        public static implicit operator double(NullableDouble nd) => nd.Value;\n\n        public static bool operator ==(NullableDouble left, NullableDouble right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableDouble left, NullableDouble right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableExtended\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableExtended value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableExtended other && Equals(other);\n        public bool Equals(NullableExtended other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableExtended(double value) =>\n            new NullableExtended { _value = value, _hasValue = true };\n        public static implicit operator double(NullableExtended ne) => ne.Value;\n\n        public static bool operator ==(NullableExtended left, NullableExtended right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableExtended left, NullableExtended right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt16\n    {\n        private short _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public short Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public short ValueOrDefault() => HasValue ? _value : default;\n        public short ValueOrElse(short elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out short value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt16 other && Equals(other);\n        public bool Equals(NullableInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt16(short value) =>\n            new NullableInt16 { _value = value, _hasValue = true };\n        public static implicit operator short(NullableInt16 ni16) => ni16.Value;\n\n        public static bool operator ==(NullableInt16 left, NullableInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt16 left, NullableInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt16\n    {\n        private ushort _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ushort Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ushort ValueOrDefault() => HasValue ? _value : default;\n        public ushort ValueOrElse(ushort elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ushort value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt16 other && Equals(other);\n        public bool Equals(NullableUInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt16(ushort value) =>\n            new NullableUInt16 { _value = value, _hasValue = true };\n        public static implicit operator ushort(NullableUInt16 nu16) => nu16.Value;\n\n        public static bool operator ==(NullableUInt16 left, NullableUInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt16 left, NullableUInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt32\n    {\n        private int _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public int Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public int ValueOrDefault() => HasValue ? _value : default;\n        public int ValueOrElse(int elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out int value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt32 other && Equals(other);\n        public bool Equals(NullableInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt32(int value) =>\n            new NullableInt32 { _value = value, _hasValue = true };\n        public static implicit operator int(NullableInt32 ni32) => ni32.Value;\n\n        public static bool operator ==(NullableInt32 left, NullableInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt32 left, NullableInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt32\n    {\n        private uint _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public uint Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public uint ValueOrDefault() => HasValue ? _value : default;\n        public uint ValueOrElse(uint elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out uint value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt32 other && Equals(other);\n        public bool Equals(NullableUInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt32(uint value) =>\n            new NullableUInt32 { _value = value, _hasValue = true };\n        public static implicit operator uint(NullableUInt32 nu32) => nu32.Value;\n\n        public static bool operator ==(NullableUInt32 left, NullableUInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt32 left, NullableUInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt64\n    {\n        private long _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public long Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public long ValueOrDefault() => HasValue ? _value : default;\n        public long ValueOrElse(long elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out long value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt64 other && Equals(other);\n        public bool Equals(NullableInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt64(long value) =>\n            new NullableInt64 { _value = value, _hasValue = true };\n        public static implicit operator long(NullableInt64 ni64) => ni64.Value;\n\n        public static bool operator ==(NullableInt64 left, NullableInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt64 left, NullableInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt64\n    {\n        private ulong _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ulong Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ulong ValueOrDefault() => HasValue ? _value : default;\n        public ulong ValueOrElse(ulong elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ulong value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt64 other && Equals(other);\n        public bool Equals(NullableUInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt64(ulong value) =>\n            new NullableUInt64 { _value = value, _hasValue = true };\n        public static implicit operator ulong(NullableUInt64 nu64) => nu64.Value;\n\n        public static bool operator ==(NullableUInt64 left, NullableUInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt64 left, NullableUInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTGUID\n    {\n        private Guid _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public Guid Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTGUID value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public Guid ValueOrDefault() => HasValue ? _value : default;\n        public Guid ValueOrElse(Guid elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out Guid value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTGUID other && Equals(other);\n        public bool Equals(NullableTGUID other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTGUID(Guid value) =>\n            new NullableTGUID { _value = value, _hasValue = true };\n        public static implicit operator Guid(NullableTGUID ntguid) => ntguid.Value;\n\n        public static bool operator ==(NullableTGUID left, NullableTGUID right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTGUID left, NullableTGUID right) =>\n            !left.Equals(right);\n    }\n\n    \n    public enum NullableType\n    {\n        InvalidNullableType,\n        NullableString,\n        NullableCurrency,\n        NullableBoolean,\n        NullableTDate,\n        NullableTTime,\n        NullableTDateTime,\n        NullableSingle,\n        NullableDouble,\n        NullableExtended,\n        NullableInt16,\n        NullableUInt16,\n        NullableInt32,\n        NullableUInt32,\n        NullableInt64,\n        NullableUInt64,\n        NullableTGUID\n    }\n\n    \n    public static class NullableHelper\n    {\n        public static NullableType GetNullableType(Type type)\n        {\n            if (type == typeof(NullableString)) return NullableType.NullableString;\n            if (type == typeof(NullableCurrency)) return NullableType.NullableCurrency;\n            if (type == typeof(NullableBoolean)) return NullableType.NullableBoolean;\n            if (type == typeof(NullableTDate)) return NullableType.NullableTDate;\n            if (type == typeof(NullableTTime)) return NullableType.NullableTTime;\n            if (type == typeof(NullableTDateTime)) return NullableType.NullableTDateTime;\n            if (type == typeof(NullableSingle)) return NullableType.NullableSingle;\n            if (type == typeof(NullableDouble)) return NullableType.NullableDouble;\n            if (type == typeof(NullableExtended)) return NullableType.NullableExtended;\n            if (type == typeof(NullableInt16)) return NullableType.NullableInt16;\n            if (type == typeof(NullableUInt16)) return NullableType.NullableUInt16;\n            if (type == typeof(NullableInt32)) return NullableType.NullableInt32;\n            if (type == typeof(NullableUInt32)) return NullableType.NullableUInt32;\n            if (type == typeof(NullableInt64)) return NullableType.NullableInt64;\n            if (type == typeof(NullableUInt64)) return NullableType.NullableUInt64;\n            if (type == typeof(NullableTGUID)) return NullableType.NullableTGUID;\n            return NullableType.InvalidNullableType;\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file:\n// Jo\ufffdo Ant\ufffdnio Duarte (https://github.com/joaoduarte19)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.RESTClient;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes,\n  System.SysUtils,\n  System.Net.HttpClient,\n  System.Net.Mime,\n  System.Net.URLClient,\n  System.Generics.Collections,\n  System.Rtti,\n  System.TypInfo,\n  MVCFramework.Commons,\n  MVCFramework.RESTClient.Indy,\n  MVCFramework.RESTClient.Intf,\n  MVCFramework.RESTClient.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  Data.DB,\n  JsonDataObjects;\n\ntype\n  /// <summary>\n  /// Alias for the Indy-based TRESTClient. The implementation of TRESTClient has been discontinued, it remains for\n  /// compatibility only.\n  /// </summary>\n  TRESTClient = MVCFramework.RESTClient.Indy.TRESTClient deprecated\n    'Moved to the MVCFramework.RESTClient.Indy unit. It is highly recommended to migrate to the TMVCRESTClient implementation.';\n\n  IRESTResponse = MVCFramework.RESTClient.Indy.IRESTResponse deprecated\n    'Moved to the MVCFramework.RESTClient.Indy unit. It is highly recommended to migrate to the TMVCRESTClient implementation.';\n\n  IMVCRESTClient = MVCFramework.RESTClient.Intf.IMVCRESTClient;\n  IMVCRESTResponse = MVCFramework.RESTClient.Intf.IMVCRESTResponse;\n\n  TCookie = System.Net.HttpClient.TCookie;\n  TCookies = System.Net.HttpClient.TCookies;\n  TURLRequest = System.Net.URLClient.TURLRequest;\n  TCertificate = System.Net.URLClient.TCertificate;\n  TCertificateList = System.Net.URLClient.TCertificateList;\n  TNameValuePair = System.Net.URLClient.TNameValuePair;\n  TNameValueArray = System.Net.URLClient.TNameValueArray;\n  IHTTPRequest = System.Net.HttpClient.IHTTPRequest;\n  IHTTPResponse = System.Net.HttpClient.IHTTPResponse;\n\n{$IF defined(TOKYOORBETTER)}\n  THTTPSecureProtocol = System.Net.HttpClient.THTTPSecureProtocol;\n  THTTPSecureProtocols = System.Net.HttpClient.THTTPSecureProtocols;\n{$ENDIF}\n\n  TMVCRESTClient = class(TInterfacedObject, IMVCRESTClient)\n  private\n    fLock: TObject;\n    fHTTPClient: THTTPClient;\n    fBaseURL: string;\n    fResource: string;\n    fProxySettings: TProxySettings;\n    fParameters: TList<TMVCRESTParam>;\n    fRawBody: TMemoryStream;\n    fBodyFormData: TMultipartFormData;\n    fSerializer: IMVCSerializer;\n    fRttiContext: TRttiContext;\n    fNextRequestIsAsync: Boolean;\n    fAsyncCompletionHandler: TProc<IMVCRESTResponse>;\n    fAsyncCompletionHandlerWithError: TProc<Exception>;\n    fAsyncSynchronized: Boolean;\n    fNeedClientCertificate: TNeedClientCertificateProc;\n    fValidateServerCertificate: TValidateServerCertificateProc;\n    fBeforeRequestProc: TBeforeRequestProc;\n    fRequestCompletedProc: TRequestCompletedProc;\n    fResponseCompletedProc: TResponseCompletedProc;\n    fSendDataProc: TSendDataProc;\n    [Weak] fClientCertificate: TStream;\n    fClientCertPassword: string;\n    fClientCertPath: string;\n    procedure DoNeedClientCertificate(const aSender: TObject; const aRequest: TURLRequest;\n      const aCertificateList: TCertificateList; var aIndex: Integer);\n    procedure DoValidateServerCertificate(const aSender: TObject; const aRequest: TURLRequest;\n      const aCertificate: TCertificate; var aAccepted: Boolean);\n    procedure DoBeforeRequest(aRequest: IHTTPRequest);\n    procedure DoRequestCompleted(aResponse: IHTTPResponse; var aHandled: Boolean);\n    procedure DoResponseCompleted(aMVCRESTResponse: IMVCRESTResponse);\n{$IF defined(SYDNEYORBETTER)}\n    procedure DoOnSendDataEvent(const Sender: TObject; AContentLength, AWriteCount: Int64; var AAbort: Boolean);\n{$ENDIF}\n    function GetBodyFormData: TMultipartFormData;\n    function ObjectIsList(aObject: TObject): Boolean;\n    function SerializeObject(aObject: TObject): string;\n    procedure SetContentType(const aContentType: string);\n    procedure SetParameter(const aParamType: TMVCRESTParamType; const aName, aValue: string);\n    procedure ClearParameters(const aParamType: TMVCRESTParamType);\n    function InsertHTTPSchema(const aURL: string): string;\n    function GetFullURL: string;\n    function HTTPMethodName(const aHTTPMethod: TMVCHTTPMethodType): string;\n    /// <summary>\n    /// Convert path parameters of type ($xxx) to {xxx}\n    /// </summary>\n    procedure DoConvertMVCPathParamsToRESTParams(var aURL: string);\n    procedure DoApplyPathParams(var aURL: string);\n    procedure DoApplyQueryParams(var aURL: string);\n    procedure DoApplyCookies(const aURL: string);\n    procedure DoApplyHeaders;\n    procedure DoEncodeURL(var aURL: string);\n    procedure DoPrepareBodyRequest(var aBodyStream: TStream);\n\n    procedure ExecuteAsyncRequest(const aMethod: TMVCHTTPMethodType);\n    function InternalExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\n    function ExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\n  public\n    constructor Create;\n    destructor Destroy; override;\n\n    class function New: IMVCRESTClient;\n\n    { IMVCRESTClient }\n\n    function BaseURL(const aBaseURL: string): IMVCRESTClient; overload;\n    function BaseURL(const aHost: string; const aPort: Integer): IMVCRESTClient; overload;\n    function BaseURL: string; overload;\n\n    function ProxyServer(const aProxyServer: string): IMVCRESTClient; overload;\n    function ProxyServer: string; overload;\n    function ProxyPort(const aProxyPort: Integer): IMVCRESTClient; overload;\n    function ProxyPort: Integer; overload;\n    function ProxyUsername(const aProxyUsername: string): IMVCRESTClient; overload;\n    function ProxyUsername: string; overload;\n    function ProxyPassword(const aProxyPassword: string): IMVCRESTClient; overload;\n    function ProxyPassword: string; overload;\n    function ProxyScheme(const aProxyScheme: string): IMVCRESTClient; overload;\n    function ProxyScheme: string; overload;\n\n{$IF defined(TOKYOORBETTER)}\n    function SecureProtocols(const aSecureProtocols: THTTPSecureProtocols): IMVCRESTClient; overload;\n    function SecureProtocols: THTTPSecureProtocols; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Method called when a ClientCertificate is needed.\n    /// </summary>\n    function SetNeedClientCertificateProc(aNeedClientCertificateProc: TNeedClientCertificateProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Add a custom SSL certificate validation. By default all certificates are accepted.\n    /// </summary>\n    function SetValidateServerCertificateProc(aValidateCertificateProc: TValidateServerCertificateProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes before send the request\n    /// </summary>\n    function SetBeforeRequestProc(aBeforeRequestProc: TBeforeRequestProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes after send the request\n    /// </summary>\n    function SetRequestCompletedProc(aRequestCompletedProc: TRequestCompletedProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes after the response is processed.\n    /// </summary>\n    function SetResponseCompletedProc(aResponseCompletedProc: TResponseCompletedProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes while sending data\n    /// </summary>\n    {$IF defined(SYDNEYORBETTER)}\n    function SetSendDataProc(aSendDataProc: TSendDataProc): IMVCRESTClient;\n    {$ENDIF}\n\n    ///<summary>\n    /// Set the client certificate for the request</summary>\n    /// </summary>\n    function SetClientCertificate(const aCertStream: TStream; const aPassword: string): IMVCRESTClient; overload;\n\n{$IF defined(TOKYOORBETTER)}\n    /// <summary>\n    /// Set the path containing a client certificate for the request (iOS, Linux, Windows, Android).\n    /// Note, on Android the Path is certificate fingerprint or imported name, not a file path.\n    /// Password is not used.\n    /// </summary>\n    function SetClientCertificate(const aCertPath, aPassword: string): IMVCRESTClient; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Clears all parameters (headers, body, path params and query params). This method is executed after each\n    /// request is completed.\n    /// </summary>\n    /// <remarks>\n    /// Cookies and authorization set in SetBasicAuthorization or SetBearerAuthorization is not removed\n    /// </remarks>\n    function ClearAllParams: IMVCRESTClient;\n\n{$IF defined(BERLINORBETTER)}\n    /// <summary>\n    /// Connection timeout in milliseconds to be used for the requests.\n    /// </summary>\n    function ConnectTimeout(const aConnectTimeout: Integer): IMVCRESTClient; overload;\n    function ConnectTimeout: Integer; overload;\n\n    /// <summary>\n    /// Response reading timeout in milliseconds to be used for the requests.\n    /// </summary>\n    function ReadTimeout(const aReadTimeout: Integer): IMVCRESTClient; overload;\n    function ReadTimeout: Integer; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Add basic authorization header. Authorization = Basic &lt;Username:Password&gt; (encoded in Base64)\n    /// </summary>\n    function SetBasicAuthorization(const aUsername, aPassword: string): IMVCRESTClient;\n\n    /// <summary>\n    /// Add bearer authorization header. Authorization = Bearer &lt;Token&gt;\n    /// </summary>\n    function SetBearerAuthorization(const aAccessToken: string): IMVCRESTClient;\n\n    /// <summary>\n    /// Returns the stored authorization. Includes Basic or Bearer prefix\n    /// </summary>\n    function Authorization: string;\n\n    /// <summary>\n    /// Removes the authorization header defined in <see cref=\"MVCFramework.RESTClient.Intf|IMVCRESTClient.SetBasicAuthorization(string,string)\">\n    /// SetBasicAuthorization</see> or <see cref=\"MVCFramework.RESTClient.Intf|IMVCRESTClient.SetBearerAuthorization(string)\">\n    /// SetBearerAuthorization</see>\n    /// </summary>\n    function ClearAuthorization: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a header.\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Header name\n    /// </param>\n    /// <param name=\"aValue\">\n    /// Header value\n    /// </param>\n    /// <param name=\"aDoNotEncode\">\n    /// Indicates whether the value of this header should be used as is (True), or encoded by the component (False)\n    /// </param>\n    function AddHeader(const aName, aValue: string): IMVCRESTClient; overload;\n    function HeaderValue(const aName: string): string;\n    function Headers: TNameValueArray;\n\n    /// <summary>\n    /// Clears all headers.\n    /// </summary>\n    function ClearHeaders: IMVCRESTClient;\n\n    function AllowCookies(const aAllowCookies: Boolean): IMVCRESTClient; overload;\n    function AllowCookies: Boolean; overload;\n\n    /// <summary>\n    /// Add DMVC session cookie\n    /// </summary>\n    function SessionId(const aSessionId: string): IMVCRESTClient; overload;\n    function SessionId: string; overload;\n\n    /// <summary>\n    /// Add a cookie header.\n    /// </summary>\n    function AddCookie(const aName, aValue: string): IMVCRESTClient;\n    /// <summary>\n    /// Clear all cookie headers.\n    /// </summary>\n    function ClearCookies: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a URL segment parameter. The parameters of your url path may be enclosed in braces or in\n    /// parentheses starting with a money sign. <c>/api/{param1}/($param2)</c>\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Parameter name\n    /// </param>\n    /// <param name=\"aValue\">\n    /// Parameter value\n    /// </param>\n    function AddPathParam(const aName, aValue: string): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Integer): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Int64): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TGUID): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TDateTime): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TDate): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TTime): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Double): IMVCRESTClient; overload;\n    function ClearPathParams: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a QueryString parameter. <c>/api/person?para1=value&amp;param2=value</c>\n    /// </summary>\n    function AddQueryStringParam(const aName, aValue: string): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Integer): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Int64): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TGUID): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TDateTime): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TDate): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TTime): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Double): IMVCRESTClient; overload;\n    function ClearQueryParams: IMVCRESTClient;\n\n    function Accept(const aAccept: string): IMVCRESTClient; overload;\n    function Accept: string; overload;\n    function AcceptCharset(const aAcceptCharset: string): IMVCRESTClient; overload;\n    function AcceptCharset: string; overload;\n    function AcceptEncoding(const aAcceptEncoding: string): IMVCRESTClient; overload;\n    function AcceptEncoding: string; overload;\n    function HandleRedirects(const aHandleRedirects: Boolean): IMVCRESTClient; overload;\n    function HandleRedirects: Boolean; overload;\n    function MaxRedirects(const aMaxRedirects: Integer): IMVCRESTClient; overload;\n    function MaxRedirects: Integer; overload;\n    function UserAgent(const aUserAgent: string): IMVCRESTClient; overload;\n    function UserAgent: string; overload;\n\n    function Resource(const aResource: string): IMVCRESTClient; overload;\n    function Resource: string; overload;\n\n    /// <summary>\n    /// Add a body to the requisition.\n    /// </summary>\n    /// <param name=\"aBody\">\n    /// Body in string format.\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// Body content type.\n    /// </param>\n    function AddBody(const aBody: string; const aContentType: string = ''): IMVCRESTClient; overload;\n    /// <summary>\n    /// Add a body to the requisition\n    /// </summary>\n    /// <param name=\"aBodyStream\">\n    /// Body in Stream format\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// Body content type\n    /// </param>\n    /// <param name=\"aOwnsStream\">\n    /// If OwnsStream is true, Stream will be destroyed by IMVCRESTClient.\n    /// </param>\n    function AddBody(aBodyStream: TStream; const aOwnsStream: Boolean = True;\n      const aContentType: string = ''): IMVCRESTClient; overload;\n    /// <summary>\n    /// Add a body to the requisition\n    /// </summary>\n    /// <param name=\"aBodyObject\">\n    /// Body in Object format. The object will be serialized to a JSON string.\n    /// </param>\n    /// <param name=\"aOwnsObject\">\n    /// If OwnsObject is true, BodyObject will be destroyed by IMVCRESTClient.\n    /// </param>\n    function AddBody(aBodyObject: TObject; const aOwnsObject: Boolean = True): IMVCRESTClient; overload;\n\n    /// <summary>\n    /// Adds a file as the request body. Several files can be added in the same request. In this case the request\n    /// will be of the multipart/form-data type\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Field name\n    /// </param>\n    /// <param name=\"aFileName\">\n    /// File path\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// File content type\n    /// </param>\n    function AddFile(const aName, aFileName: string; const aContentType: string = ''): IMVCRESTClient; overload;\n    function AddFile(const aFileName: string; const aContentType: string = ''): IMVCRESTClient; overload;\n{$IF defined(RIOORBETTER)}\n    function AddFile(const aName: string; aFileStreamValue: TStream; const aFileName: string = '';\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n{$IF defined(ATHENSORBETTER)}\n    function AddFile(const aName: string; aFileStreamValue: TStream; aOwnsStream: Boolean; const aFileName: string = '';\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n\n    function AddBodyFieldFormData(const aName, aValue: string): IMVCRESTClient; overload;\n{$IF defined(RIOORBETTER)}\n    function AddBodyFieldFormData(const aName: string; aStreamValue: TStream;\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n    /// <summary>\n    /// Add a field to the x-www-form-urlencoded body. You must set ContentType to application/x-www-form-urlencoded\n    /// </summary>\n    function AddBodyFieldURLEncoded(const aName, aValue: string): IMVCRESTClient;\n\n    function ClearBody: IMVCRESTClient;\n\n    /// <summary>\n    /// Executes the next request asynchronously.\n    /// </summary>\n    /// <param name=\"aCompletionHandler\">\n    /// An anonymous method that will be run after the execution completed.\n    /// </param>\n    /// <param name=\"aSynchronized\">\n    /// Specifies if aCompletioHandler will be run in the main thread's (True) or execution thread's (False) context.\n    /// </param>\n    /// <param name=\"aCompletionHandlerWithError\">\n    /// An anonymous method that will be run if an exception is raised during execution.\n    /// </param>\n    function Async(aCompletionHandler: TProc<IMVCRESTResponse>; aCompletionHandlerWithError: TProc<Exception> = nil;\n      const aSynchronized: Boolean = False): IMVCRESTClient;\n\n    /// <summary>\n    /// Execute a Get request.\n    /// </summary>\n    function Get(const aResource: string): IMVCRESTResponse; overload;\n    function Get: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Head request.\n    /// </summary>\n    function Head(const aResource: string): IMVCRESTResponse; overload;\n    function Head: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Options request.\n    /// </summary>\n    function Options(const aResource: string): IMVCRESTResponse; overload;\n    function Options: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Post request.\n    /// </summary>\n    /// <param name=\"aResource\">\n    /// Resource path\n    /// </param>\n    /// <param name=\"aBody\">\n    /// Object to be serialized. It can be a simple object or a list of objects (TObjectList &lt;T&gt;)\n    /// </param>\n    /// <param name=\"aOwnsBody\">\n    /// If OwnsBody is true, Body will be destroyed by IMVCRESTClient. <br />\n    /// </param>\n    function Post(const aResource: string; aBody: TObject; const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Post(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Post: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Patch request.\n    /// </summary>\n    function Patch(const aResource: string; aBody: TObject;\n      const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Patch(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Patch: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Put request.\n    /// </summary>\n    function Put(const aResource: string; aBody: TObject; const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Put(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Put: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Delete request.\n    /// </summary>\n    function Delete(const aResource: string): IMVCRESTResponse; overload;\n    function Delete: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Executes any type of HTTP request\n    /// </summary>\n    function Execute(const aMethod: TMVCHTTPMethodType; const aResource: string): IMVCRESTResponse; overload;\n    function Execute(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Serialize the current dataset record and execute a POST request.\n    /// </summary>\n    function DataSetInsert(const aResource: string; aDataSet: TDataSet; const aIgnoredFields: TMVCIgnoredList = [];\n      const aNameCase: TMVCNameCase = ncAsIs): IMVCRESTResponse;\n    /// <summary>\n    /// Serialize the current dataset record and execute a PUT request.\n    /// </summary>\n    function DataSetUpdate(const aResource, aKeyValue: string; aDataSet: TDataSet;\n      const aIgnoredFields: TMVCIgnoredList = []; const aNameCase: TMVCNameCase = ncAsIs): IMVCRESTResponse;\n    /// <summary>\n    /// Delete the current dataset record by executing a delete request.\n    /// </summary>\n    function DataSetDelete(const aResource, aKeyValue: string): IMVCRESTResponse;\n\n    /// <summary>\n    /// Access the RESTClient serializer\n    /// </summary>\n    function Serializer: IMVCSerializer; overload;\n    /// <summary>\n    /// Add a serializer to the RESTClient\n    /// </summary>\n    function Serializer(const aSerializer: IMVCSerializer): IMVCRESTClient; overload;\n\n    /// <summary>\n    /// Register a custom serializer to the RESTClient serializer.\n    /// </summary>\n    function RegisterTypeSerializer(const aTypeInfo: PTypeInfo; aInstance: IMVCTypeSerializer): IMVCRESTClient;\n  end;\n\n  /// <summary>\n  /// Provides access to the REST request response.\n  /// </summary>\n  TMVCRESTResponse = class(TInterfacedObject, IMVCRESTResponse)\n  private\n    fRESTClient: IMVCRESTClient;\n    fSuccess: Boolean;\n    fStatusCode: Integer;\n    fStatusText: string;\n    fHeaders: TStrings;\n    fCookies: TCookies;\n    fServer: string;\n    fContentType: string;\n    fContentEncoding: string;\n    fContentLength: Integer;\n    fContent: string;\n    fContentRawBytes: TBytes;\n    fContentAvailableAsString: Boolean;\n\n    procedure FillResponse(const aHTTPResponse: IHTTPResponse);\n  public\n    constructor Create(const aRESTClient: IMVCRESTClient; const aHTTPResponse: IHTTPResponse);\n    destructor Destroy; override;\n\n    { IMVCRESTResponse }\n    function Success: Boolean;\n    function StatusCode: Integer;\n    function StatusText: string;\n    function Headers: TStrings;\n    function HeaderValue(const aName: string): string;\n    function Cookies: TCookies;\n    function CookieByName(const aName: string; const RaiseExceptionIfNotFound: Boolean = False): TCookie;\n    function Server: string;\n    function ContentType: string;\n    function ContentEncoding: string;\n    function ContentLength: Integer;\n    function Content: string;\n    function ContentRawBytes: TBytes;\n    procedure SaveContentToStream(aStream: TStream);\n    procedure SaveContentToFile(const aFileName: string);\n    function ToJSONObject: TJDOJsonObject;\n    function ToJSONArray: TJDOJsonArray;\n    procedure BodyFor(const aObject: TObject; const aRootNode: string = '');\n    procedure BodyForListOf(const aObjectList: TObject; const aObjectClass: TClass; const aRootNode: string = '');\n  end;\n\nimplementation\n\nuses\n  System.NetConsts,\n  System.NetEncoding,\n  MVCFra", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\n\nnamespace MVCFramework.RESTClient\n{\n    \n    public interface IMVCRESTClient : IDisposable\n    {\n        string BaseURL { get; set; }\n        string Resource { get; set; }\n        IDictionary<string, string> Headers { get; }\n        IMVCRESTClient AddHeader(string name, string value);\n        IMVCRESTClient SetBasicAuthorization(string username, string password);\n        IMVCRESTClient SetBearerAuthorization(string token);\n        IMVCRESTClient ClearAuthorization();\n        \n\n        Task<IMVCRESTResponse> GetAsync(string resource = null);\n        Task<IMVCRESTResponse> PostAsync(string resource, object body);\n        Task<IMVCRESTResponse> PutAsync(string resource, object body);\n        Task<IMVCRESTResponse> DeleteAsync(string resource);\n    }\n\n    \n    public interface IMVCRESTResponse\n    {\n        bool Success { get; }\n        int StatusCode { get; }\n        string StatusText { get; }\n        string Content { get; }\n        T ToObject<T>();\n        \n    }\n\n\n    public class MVCRESTClient : IMVCRESTClient\n    {\n        private readonly HttpClient _httpClient;\n        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>();\n        public string BaseURL { get; set; }\n        public string Resource { get; set; }\n\n        public IDictionary<string, string> Headers => _headers;\n\n        public MVCRESTClient()\n        {\n            _httpClient = new HttpClient();\n        }\n\n        public IMVCRESTClient AddHeader(string name, string value)\n        {\n            if (_headers.ContainsKey(name))\n                _headers[name] = value;\n            else\n                _headers.Add(name, value);\n            return this;\n        }\n\n        public IMVCRESTClient SetBasicAuthorization(string username, string password)\n        {\n            string credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes($\"{username}:{password}\"));\n            return AddHeader(\"Authorization\", \"Basic \" + credentials);\n        }\n\n        public IMVCRESTClient SetBearerAuthorization(string token)\n        {\n            return AddHeader(\"Authorization\", \"Bearer \" + token);\n        }\n\n        public IMVCRESTClient ClearAuthorization()\n        {\n            if (_headers.ContainsKey(\"Authorization\"))\n                _headers.Remove(\"Authorization\");\n            return this;\n        }\n\n        private HttpRequestMessage CreateRequest(HttpMethod method, string resource)\n        {\n            var url = new Uri(new Uri(BaseURL), resource ?? Resource);\n            var request = new HttpRequestMessage(method, url);\n            foreach (var header in _headers)\n            {\n                request.Headers.TryAddWithoutValidation(header.Key, header.Value);\n            }\n            return request;\n        }\n\n        public async Task<IMVCRESTResponse> GetAsync(string resource = null)\n        {\n            var request = CreateRequest(HttpMethod.Get, resource);\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> PostAsync(string resource, object body)\n        {\n            var request = CreateRequest(HttpMethod.Post, resource);\n            string json = JsonConvert.SerializeObject(body);\n            request.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> PutAsync(string resource, object body)\n        {\n            var request = CreateRequest(HttpMethod.Put, resource);\n            string json = JsonConvert.SerializeObject(body);\n            request.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> DeleteAsync(string resource)\n        {\n            var request = CreateRequest(HttpMethod.Delete, resource);\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public void Dispose()\n        {\n            _httpClient?.Dispose();\n        }\n    }\n\n    \n    public class MVCRESTResponse : IMVCRESTResponse\n    {\n        private readonly HttpResponseMessage _response;\n        private string _content;\n\n        public bool Success => _response.IsSuccessStatusCode;\n        public int StatusCode => (int)_response.StatusCode;\n        public string StatusText => _response.ReasonPhrase;\n\n        public string Content\n        {\n            get\n            {\n                if (_content == null)\n                {\n                    _content = _response.Content.ReadAsStringAsync().Result;\n                }\n                return _content;\n            }\n        }\n\n        public MVCRESTResponse(HttpResponseMessage response)\n        {\n            _response = response;\n        }\n\n        public T ToObject<T>()\n        {\n            return JsonConvert.DeserializeObject<T>(Content);\n        }\n    }\n}"}
{"input": "/// Framework Core Low-Level Cross-Compiler RTTI Definitions\n// - this unit is a part of the Open Source Synopse mORMot framework 2,\n// licensed under a MPL/GPL/LGPL three license - see LICENSE.md\nunit mormot.core.rtti;\n\n{\n  *****************************************************************************\n\n   Cross-Compiler RTTI Definitions shared by all framework units\n    - Low-Level Cross-Compiler RTTI Definitions\n    - Enumerations RTTI\n    - Published Class Properties and Methods RTTI\n    - IInvokable Interface RTTI\n    - Efficient Dynamic Arrays and Records Process\n    - Managed Types Finalization, Random or Copy\n    - RTTI Value Types used for JSON Parsing\n    - RTTI-based Registration for Custom JSON Parsing\n    - High Level TObjectWithID and TObjectWithCustomCreate Class Types\n    - Redirect Most Used FPC RTL Functions to Optimized x86_64 Assembly\n\n     Purpose of this unit is to avoid any direct use of TypInfo.pas RTL unit,\n    which is not exactly compatible between compilers, and lack of direct\n    RTTI access with no memory allocation. We define pointers to RTTI\n    record/object to access TypeInfo() via a set of explicit methods.\n     Here fake record/objects are just wrappers around pointers defined in\n    Delphi/FPC RTL's TypInfo.pas with the magic of inlining.\n     We redefined all RTTI definitions as TRtti* types to avoid confusion\n    with type names as published by the TypInfo unit.\n     TRttiCustom class is the main cached entry of our customizable RTTI,\n    accessible from the global Rtti.* methods.\n\n    See mormot.core.rtti.fpc.inc and mormot.core.rtti.delphi.inc for\n    compiler-specific code.\n\n  *****************************************************************************\n}\n\n\ninterface\n\n{$I mormot.defines.inc}\n\nuses\n  sysutils,\n  classes,\n  contnrs,\n  typinfo,  // use official RTL for accurate layouts (especially FPC unaligned)\n  mormot.core.base,\n  mormot.core.os,\n  mormot.core.unicode,\n  mormot.core.text; // ESynException, and text process (e.g. for enums)\n\n\n{ ************* Low-Level Cross-Compiler RTTI Definitions }\n\ntype\n  /// the kind of Exception raised by this unit\n  ERttiException = class(ESynException);\n\n  /// map TOrdType, to specify ordinal (rkInteger and rkEnumeration) storage size and sign\n  // - note: on FPC, Int64 is stored as its own TRttiKind, not as rkInteger\n  TRttiOrd = (\n    roSByte,\n    roUByte,\n    roSWord,\n    roUWord,\n    roSLong,\n    roULong\n    {$ifdef FPC_NEWRTTI} ,\n    roSQWord,\n    roUQWord\n    {$endif FPC_NEWRTTI});\n\n  /// map TFloatType, to specify floating point (ftFloat) storage size and precision\n  TRttiFloat = (\n    rfSingle,\n    rfDouble,\n    rfExtended,\n    rfComp,\n    rfCurr);\n\n{$ifdef FPC}\n\n  /// map TTypeKind, to specify available type families for FPC RTTI values\n  // - FPC types differs from Delphi, and are taken from FPC typinfo.pp unit\n  // - here below,  we defined rkLString instead of rkAString to match Delphi -\n  // see https://lists.freepascal.org/pipermail/fpc-devel/2013-June/032360.html\n  // \"Compiler uses internally some LongStrings which is not possible to use\n  // for variable declarations\" so rkLStringOld seems never used in practice\n  TRttiKind = (\n    rkUnknown,\n    rkInteger,\n    rkChar,\n    rkEnumeration,\n    rkFloat,\n    rkSet,\n    rkMethod,\n    rkSString,\n    rkLStringOld {=rkLString},\n    rkLString    {=rkAString},\n    rkWString,\n    rkVariant,\n    rkArray,\n    rkRecord,\n    rkInterface,\n    rkClass,\n    rkObject,\n    rkWChar,\n    rkBool,\n    rkInt64,\n    rkQWord,\n    rkDynArray,\n    rkInterfaceRaw,\n    rkProcVar,\n    rkUString,\n    rkUChar,\n    rkHelper,\n    rkFile,\n    rkClassRef,\n    rkPointer);\n\nconst\n  /// potentially managed types in TRttiKind enumerates\n  rkManagedTypes = [rkLStringOld,\n                    rkLString,\n                    rkWString,\n                    rkUString,\n                    rkArray,\n                    rkObject,\n                    rkRecord,\n                    rkDynArray,\n                    rkInterface,\n                    rkVariant];\n\n  /// maps record or object in TRttiKind enumerates\n  rkRecordTypes = [rkObject,\n                   rkRecord];\n\ntype\n  ///  TTypeKind enumerate as defined in Delphi 6 and up\n  // - dkUString and following appear only since Delphi 2009\n  TDelphiType = (\n    dkUnknown,\n    dkInteger,\n    dkChar,\n    dkEnumeration,\n    dkFloat,\n    dkString,\n    dkSet,\n    dkClass,\n    dkMethod,\n    dkWChar,\n    dkLString,\n    dkWString,\n    dkVariant,\n    dkArray,\n    dkRecord,\n    dkInterface,\n    dkInt64,\n    dkDynArray,\n    dkUString,\n    dkClassRef,\n    dkPointer,\n    dkProcedure,\n    dkMRecord);\n\nconst\n  /// convert our TRttiKind to Delphi's TTypeKind enumerate\n  // - used internally for cross-compiler TDynArray binary serialization\n  FPCTODELPHI: array[TRttiKind] of TDelphiType = (\n    dkUnknown,\n    dkInteger,\n    dkChar,\n    dkEnumeration,\n    dkFloat,\n    dkSet,\n    dkMethod,\n    dkString,\n    dkLString,\n    dkLString,\n    dkWString,\n    dkVariant,\n    dkArray,\n    dkRecord,\n    dkInterface,\n    dkClass,\n    dkRecord,\n    dkWChar,\n    dkEnumeration,\n    dkInt64,\n    dkInt64,\n    dkDynArray,\n    dkInterface,\n    dkProcedure,\n    dkUString,\n    dkWChar,\n    dkPointer,\n    dkPointer,\n    dkClassRef,\n    dkPointer);\n\n  /// convert Delphi's TTypeKind to our TRttiKind enumerate\n  DELPHITOFPC: array[TDelphiType] of TRttiKind = (\n    rkUnknown,     //  dkUnknown\n    rkInteger,     //  dkInteger\n    rkChar,        //  dkChar\n    rkEnumeration, //  dkEnumeration\n    rkFloat,       //  dkFloat\n    rkSString,     //  dkString\n    rkSet,         //  dkSet\n    rkClass,       //  dkClass\n    rkMethod,      //  dkMethod\n    rkWChar,       //  dkWChar\n    rkLString,     //  dkLString\n    rkWString,     //  dkWString\n    rkVariant,     //  dkVariant\n    rkArray,       //  dkArray\n    rkRecord,      //  dkRecord\n    rkInterface,   //  dkInterface\n    rkInt64,       //  dkInt64\n    rkDynArray,    //  dkDynArray\n    rkUString,     //  dkUString\n    rkClassRef,    //  dkClassRef\n    rkPointer,     //  dkPointer\n    rkProcVar,     //  dkProcedure\n    rkRecord);     //  dkMRecord\n\n{$else}\n\n  /// available type families for Delphi 6 and up, similar to typinfo.pas\n  // - redefined here to leverage FPC and Delphi compatibility as much as possible\n  TRttiKind = (\n    rkUnknown,\n    rkInteger,\n    rkChar,\n    rkEnumeration,\n    rkFloat,\n    rkSString,\n    rkSet,\n    rkClass,\n    rkMethod,\n    rkWChar,\n    rkLString,\n    rkWString,\n    rkVariant,\n    rkArray,\n    rkRecord,\n    rkInterface,\n    rkInt64,\n    rkDynArray\n    {$ifdef UNICODE},\n    rkUString,\n    rkClassRef,\n    rkPointer,\n    rkProcedure,\n    rkMRecord // managed records from newest Delphi are partially supported\n    {$endif UNICODE});\n\nconst\n  /// potentially managed types in TRttiKind enumerates\n  rkManagedTypes = [rkLString,\n                    rkWstring,\n                    {$ifdef UNICODE}\n                    rkUstring,\n                    rkMRecord,\n                    {$endif UNICODE}\n                    rkArray,\n                    rkRecord,\n                    rkDynArray,\n                    rkInterface,\n                    rkVariant\n                   ];\n  /// maps record or object in TTypeKind RTTI enumerates\n  rkRecordTypes = [rkRecord\n                   {$ifdef UNICODE},\n                   rkMRecord\n                   {$endif UNICODE}];\n\n{$endif FPC}\n\n  /// maps string/text types in TRttiKind RTTI enumerates, excluding shortstring\n  rkStringTypes =\n    [rkLString,\n     {$ifdef FPC}\n     rkLStringOld,\n     {$endif FPC}\n     {$ifdef HASVARUSTRING}\n     rkUString,\n     {$endif HASVARUSTRING}\n     rkWString\n    ];\n\n  /// maps UTF-16 string in TRttiKind RTTI enumerates\n  rkWideStringTypes =\n    [{$ifdef HASVARUSTRING}\n     rkUString,\n     {$endif HASVARUSTRING}\n     rkWString\n    ];\n\n  /// maps types with proper TRttiProp.RttiOrd field\n  // - i.e. rkOrdinalTypes excluding the 64-bit values\n  rkHasRttiOrdTypes =\n    [rkInteger,\n     rkChar,\n     rkWChar,\n     {$ifdef FPC}\n     rkBool,\n     rkUChar,\n     {$endif FPC}\n     rkEnumeration,\n     rkSet\n    ];\n\n  /// types which are considerated as non-simple values\n  rkComplexTypes = [rkClass, rkDynArray, rkInterface];\n\n  /// types which are stored as pointers so are always accessed by reference\n  rkPerReference = rkStringTypes + rkComplexTypes;\n\n  /// maps 1, 8, 16, 32 and 64-bit ordinal in TRttiKind RTTI enumerates\n  rkOrdinalTypes =\n    rkHasRttiOrdTypes + [ {$ifdef FPC} rkQWord, {$endif} rkInt64 ];\n\n  /// maps integer and floating point types in TRttiKind RTTI enumerates\n  rkNumberTypes = rkOrdinalTypes + [ rkFloat ];\n\n  /// maps enumeration types in TRttiKind RTTI\n  rkEnumerationTypes = [rkEnumeration {$ifdef FPC}, rkBool {$endif}];\n\n  /// maps values which expect TRttiProp.GetOrdProp/SetOrdProp\n  // - includes 32-bit ordinals and pointers\n  rkGetOrdPropTypes = rkHasRttiOrdTypes + rkComplexTypes;\n\n  /// maps ordinal values which expect TRttiProp.GetInt64Prop/SetInt64Prop\n  // - includes 64-bit ordinals\n  rkGetInt64PropTypes =\n     [rkInt64 {$ifdef FPC} , rkQWord {$endif} ];\n\n  /// maps value which are integer or Int64/QWord, but not ordinal char/enum/set\n  rkGetIntegerPropTypes = rkGetInt64PropTypes + [rkInteger];\n\n  /// maps records or dynamic arrays\n  rkRecordOrDynArrayTypes = rkRecordTypes + [rkDynArray];\n\n  /// maps records or static arrays\n  rkRecordOrArrayTypes = rkRecordTypes + [rkArray];\n\n  /// all recognized TRttiKind enumerates, i.e. all but rkUnknown\n  rkAllTypes = [succ(low(TRttiKind))..high(TRttiKind)];\n\n  /// quick retrieve how many bytes an ordinal consist in\n  ORDTYPE_SIZE: array[TRttiOrd] of byte = (\n    1,                                      // roSByte\n    1,                                      // roUByte\n    2,                                      // roSWord\n    2,                                      // roUWord\n    4,                                      // roSLong\n    4                                       // roULong\n    {$ifdef FPC_NEWRTTI} , 8, 8 {$endif} ); // roSQWord, roUQWord\n\n  /// quick retrieve how many bytes a floating-point consist in\n  FLOATTYPE_SIZE: array[TRttiFloat] of byte = (\n    4,                                             // rfSingle\n    8,                                             // rfDouble\n    {$ifdef TSYNEXTENDED80} 10 {$else} 8 {$endif}, // rfExtended\n    8,                                             // rfComp\n    8 );                                           // rfCurr\n\n\ntype\n  PRttiKind = ^TRttiKind;\n  TRttiKinds = set of TRttiKind;\n  PRttiOrd = ^TRttiOrd;\n  PRttiFloat = ^TRttiFloat;\n\ntype\n  /// pointer to low-level RTTI of a type definition, as returned by TypeInfo()\n  // system function\n  // - equivalency to PTypeInfo as defined in TypInfo RTL unit and old mORMot.pas\n  // - this is the main entry point of all the information exposed by this unit\n  PRttiInfo = ^TRttiInfo;\n\n  /// double-reference to RTTI type definition\n  // - Delphi and newer FPC do store all nested TTypeInfo as pointer to pointer,\n  // to ease linking of the executable\n  PPRttiInfo = ^PRttiInfo;\n\n  /// dynamic array of low-level RTTI type definitions\n  PRttiInfoDynArray = array of PRttiInfo;\n\n  /// pointer to a RTTI class property definition as stored in PRttiProps.PropList\n  // - equivalency to PPropInfo as defined in TypInfo RTL unit and old mORMot.pas\n  PRttiProp = ^TRttiProp;\n\n  /// used to store a chain of properties RTTI\n  // - could be used e.g. by TOrmPropInfo to handled flattened properties\n  PRttiPropDynArray = array of PRttiProp;\n\n  /// pointer to all RTTI class properties definitions\n  // - as returned by PRttiInfo.RttiProps() or GetRttiProps()\n  PRttiProps = ^TRttiProps;\n\n  /// a wrapper to published properties of a class, as defined by compiler RTTI\n  // - access properties for only a given class level, not inherited properties\n  // - start enumeration by getting a PRttiProps with PRttiInfo.RttiProps(), then\n  // use P := PropList to get the first PRttiProp, and iterate with P^.Next\n  // - this enumeration is very fast and doesn't require any temporary memory,\n  //  as in the TypInfo.GetPropInfos() PPropList usage\n  // - for TOrm, you should better use the Properties.Fields[] array,\n  // which is faster and contains the properties published in parent classes\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiProps = record\n  {$else}\n  TRttiProps = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// number of published properties in this object\n    function PropCount: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// point to a TPropInfo packed array\n    // - layout is as such, with variable TPropInfo storage size:\n    // ! PropList: array[1..PropCount] of TPropInfo\n    // - use TPropInfo.Next to get the next one:\n    // ! P := PropList;\n    // ! for i := 1 to PropCount do\n    // ! begin\n    // !   // ... do something with P\n    // !   P := P^.Next;\n    // ! end;\n    function PropList: PRttiProp;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// retrieve a Field property RTTI information from a Property Name\n    function FieldProp(const PropName: ShortString): PRttiProp;\n  end;\n\n  /// pointer to TClassType, as returned by PRttiInfo.RttiClass()\n  // - as returned by PRttiInfo.RttiClass() or GetRttiClass()\n  // - equivalency to PClassData/PClassType as defined in old mORMot.pas\n  PRttiClass = ^TRttiClass;\n\n  /// a wrapper to class type information, as defined by the compiler RTTI\n  // - get a PRttiClass with PRttiInfo.RttiClass() or GetRttiClass()\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiClass = record\n  {$else}\n  TRttiClass = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// the class type\n    function RttiClass: TClass;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the parent class type information\n    function ParentInfo: PRttiInfo;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the number of published properties of this class and all parents\n    // - use RttiProps if you want to properties only published in this class \n    function PropCount: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the name (without .pas extension) of the unit were the class was defined\n    // - then the PRttiProps information follows: use the method\n    // RttiProps to retrieve its address\n    function UnitName: PShortString;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the information about the published properties of this class\n    // - stored after UnitName memory\n    function RttiProps: PRttiProps;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// fast and easy find if this class inherits from a specific class type\n    // - you should rather consider using TRttiInfo.InheritsFrom directly\n    function InheritsFrom(AClass: TClass): boolean;\n  end;\n\n  /// pointer to TEnumType, as returned by PRttiInfo.EnumBaseType/SetEnumType\n  // - equivalency to PEnumType as defined in old mORMot.pas\n  PRttiEnumType = ^TRttiEnumType;\n\n  /// a wrapper to enumeration type information, as defined by the compiler RTTI\n  // and returned by PRttiInfo.EnumBaseType/SetEnumType\n  // - we use this to store the enumeration values as integer, but easily provide\n  // a text equivalent, translated if necessary, from the enumeration type\n  // definition itself\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiEnumType = record\n  {$else}\n  TRttiEnumType = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    // as used by TRttiInfo.EnumBaseType/SetBaseType\n    function EnumBaseType: PRttiEnumType;\n      {$ifdef HASINLINE}inline;{$endif}\n    function SetBaseType: PRttiEnumType;\n      {$ifdef HASINLINE}inline;{$endif}\n  public\n    /// specify ordinal storage size and sign\n    // - is prefered to MaxValue to identify the number of stored bytes\n    function RttiOrd: TRttiOrd;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// first value of enumeration type, typicaly 0\n    // - may be < 0 e.g. for boolean\n    function MinValue: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// same as ord(high(type)): not the enumeration count, but the highest index\n    function MaxValue: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// a concatenation of shortstrings, containing the enumeration names\n    // - those shortstrings are not aligned whatsoever (even if\n    // FPC_REQUIRES_PROPER_ALIGNMENT is set)\n    function NameList: PShortString;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration name\n    // - return a void '' ShortString if Value is invalid (>MaxValue)\n    function GetEnumNameOrd(Value: cardinal): PShortString;\n      {$ifdef FPC} inline; {$endif}\n    /// get the corresponding enumeration name\n    // - return the first one if Value is invalid (>MaxValue)\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetEnumName(const Value): PShortString;\n    /// get the caption text corresponding to a enumeration name\n    // - return the first one if Value is invalid (>MaxValue)\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetCaption(const Value): string;\n    /// get all caption names, ready to be display, as lines separated by #13#10\n    // - return \"string\" type, i.e. UnicodeString for Delphi 2009+\n    // - if UsedValuesBits is not nil, only the corresponding bits set are added\n    function GetCaptionStrings(UsedValuesBits: pointer = nil): string;\n    /// add caption names, ready to be display, to a TStrings class\n    // - add pointer(ord(element)) as Objects[] value\n    // - if UsedValuesBits is not nil, only the corresponding bits set are added\n    // - can be used e.g. to populate a combo box as such:\n    // ! PTypeInfo(TypeInfo(TMyEnum))^.EnumBaseType^.AddCaptionStrings(ComboBox.Items);\n    procedure AddCaptionStrings(Strings: TStrings;\n      UsedValuesBits: pointer = nil);\n    /// retrieve all element names as a dynamic array of RawUtf8\n    // - names could be optionally trimmed left from their initial lower chars\n    procedure GetEnumNameAll(var result: TRawUtf8DynArray;\n      TrimLeftLowerCase: boolean); overload;\n    /// retrieve all element names as CSV, with optional quotes\n    procedure GetEnumNameAll(out result: RawUtf8; const Prefix: RawUtf8 = '';\n      quotedValues: boolean = false; const Suffix: RawUtf8 = '';\n      trimedValues: boolean = false; unCamelCased: boolean = false); overload;\n    /// retrieve all trimed element names as CSV\n    procedure GetEnumNameTrimedAll(var result: RawUtf8; const Prefix: RawUtf8 = '';\n      quotedValues: boolean = false; const Suffix: RawUtf8 = '');\n    /// get all enumeration names as a JSON array of strings\n    function GetEnumNameAllAsJsonArray(TrimLeftLowerCase: boolean;\n      UnCamelCased: boolean = false): RawUtf8;\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if EnumName does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if Value does not start with lowercases 'a'..'z', they will be ignored:\n    // e.g. GetEnumNameValue('Warning') will find sllWarning item\n    // - return -1 if not found (don't use directly this value to avoid any GPF)\n    function GetEnumNameValue(const EnumName: ShortString): integer; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if Value does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if Value does not start with lowercases 'a'..'z', they will be ignored:\n    // e.g. GetEnumNameValue('Warning') will find sllWarning item\n    // - return -1 if not found (don't use directly this value to avoid any GPF)\n    function GetEnumNameValue(Value: PUtf8Char): integer; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if Value does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if AlsoTrimLowerCase is TRUE, and EnumName does not start with\n    // lowercases 'a'..'z', they will be ignored: e.g. GetEnumNameValue('Warning')\n    // will find sllWarning item\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameValue(Value: PUtf8Char; ValueLen: integer;\n      AlsoTrimLowerCase: boolean = true): integer; overload;\n    /// get the corresponding enumeration ordinal value, from its trimmed name\n    function GetEnumNameValueTrimmed(Value: PUtf8Char; ValueLen: integer;\n      CaseSensitive: boolean): integer;\n    /// get the corresponding enumeration name, without the first lowercase chars\n    // (otDone -> 'Done')\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetEnumNameTrimed(const Value): RawUtf8;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the enumeration names corresponding to a set value as CSV\n    function GetSetName(const value; trimmed: boolean = false;\n      const sep: RawUtf8 = ','): RawUtf8;\n    /// get the enumeration names corresponding to a set value as JSON array\n    function GetSetNameJsonArray(Value: cardinal; SepChar: AnsiChar = ',';\n      FullSetsAsStar: boolean = false): RawUtf8; overload;\n    /// write the enumeration names corresponding to a set value as a JSON array\n    procedure GetSetNameJsonArray(W: TTextWriter; Value: cardinal;\n      SepChar: AnsiChar = ','; QuoteChar: AnsiChar = #0;\n      FullSetsAsStar: boolean = false; ForceTrim: boolean = false); overload;\n    /// get the corresponding enumeration ordinal value, from its name without\n    // its first lowercase chars ('Done' will find otDone e.g.)\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameTrimedValue(const EnumName: ShortString): integer; overload;\n    /// get the corresponding enumeration ordinal value, from its name without\n    // its first lowercase chars ('Done' will find otDone e.g.)\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameTrimedValue(Value: PUtf8Char; ValueLen: integer = 0): integer; overload;\n    /// compute how many bytes this type will use to be stored as a enumerate\n    function SizeInStorageAsEnum: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// compute how many bytes (1, 2, 4) this type will use to be stored as a set\n    // - consider using TRttiInfo.SetEnumSize if ISFPC32 conditional is defined\n    function SizeInStorageAsSet: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// store an enumeration value from its ordinal representation\n    procedure SetEnumFromOrdinal(out Value; Ordinal: PtrUInt);\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n  end;\n\n  /// RTTI of a record/object type definition (managed) field\n  // - defined here since this structure is not available in oldest\n  // Delphi's TypInfo.pas\n  // - maps TRecordElement in FPC rtti.inc or TManagedField in TypInfo\n  TRttiRecordField = record\n    /// the RTTI of this managed field\n    {$ifdef HASDIRECTTYPEINFO}\n    TypeInfo: PRttiInfo;\n    {$else}\n    TypeInfoRef: PPRttiInfo;\n    {$endif HASDIRECTTYPEINFO}\n    /// where this managed field starts in the record memory layout\n    Offset: PtrUInt;\n  end;\n  /// pointer to the RTTI of a record/object type definition (managed) field\n  PRttiRecordField = ^TRttiRecordField;\n\n  /// define the interface abilities\n  TRttiIntfFlag = (\n    ifHasGuid,\n    ifDispInterface,\n    ifDispatch\n    {$ifdef FPC} ,\n    ifHasStrGUID {$endif});\n\n  /// define the set of interface abilities\n  TRttiIntfFlags = set of TRttiIntfFlag;\n\n  /// a wrapper to interface type information, as defined by the the compiler RTTI\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiInterfaceTypeData = record\n  {$else}\n  TRttiInterfaceTypeData = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// ancestor interface type\n    function IntfParent: PRttiInfo;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// interface abilitie", "output": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\nnamespace Synopse.Rtti\n{\n    \n    public enum RttiKind\n    {\n        Unknown,\n        Integer,\n        Float,\n        String,\n        Record,\n        Array,\n        Class,\n        Variant,\n        \n    }\n\n    \n    public class RttiInfo\n    {\n        public RttiKind Kind { get; private set; }\n        public string RawName { get; private set; }\n        public Type Type { get; private set; }\n\n        public RttiInfo(Type type)\n        {\n            Type = type;\n            RawName = type.Name;\n            Kind = DetermineKind(type);\n        }\n\n        static RttiKind DetermineKind(Type t)\n        {\n            \n            if (t.IsEnum)\n                return RttiKind.Integer; \n            else if (t == typeof(int) || t == typeof(uint) || t == typeof(short) || t == typeof(ushort)\n                  || t == typeof(byte) || t == typeof(sbyte))\n                return RttiKind.Integer;\n            else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))\n                return RttiKind.Float;\n            else if (t == typeof(string))\n                return RttiKind.String;\n            else if (t.IsArray)\n                return RttiKind.Array;\n            else if (t.IsClass)\n                return RttiKind.Class;\n            else if (t.IsValueType)\n                return RttiKind.Record;\n            else if (t == typeof(object))\n                return RttiKind.Variant;\n            else\n                return RttiKind.Unknown;\n        }\n\n        public int RttiSize\n        {\n            get\n            {\n                try\n                {\n                    return Marshal.SizeOf(Type);\n                }\n                catch\n                {\n                    return 0;\n                }\n            }\n        }\n\n        \n        public void Clear(object instance)\n        {\n            \n            // If you need to \u201cclear\u201d fields, you could set them to default.\n        }\n\n        \n        public void Copy(object destination, object source)\n        {\n            if (destination == null || source == null)\n                throw new ArgumentNullException();\n            foreach (var prop in Type.GetProperties(BindingFlags.Public | BindingFlags.Instance))\n            {\n                if (prop.CanRead && prop.CanWrite)\n                {\n                    object value = prop.GetValue(source);\n                    prop.SetValue(destination, value);\n                }\n            }\n        }\n    }\n\n   \n    public class RttiCustom\n    {\n        public RttiInfo Info { get; private set; }\n        public Type ValueClass { get; private set; }\n\n        \n        public Dictionary<string, PropertyInfo> Properties { get; private set; }\n\n        \n        public RttiCustom(Type type)\n        {\n            ValueClass = type;\n            Info = new RttiInfo(type);\n            Properties = new Dictionary<string, PropertyInfo>(StringComparer.OrdinalIgnoreCase);\n            \n            foreach (var pi in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))\n            {\n                Properties[pi.Name] = pi;\n            }\n        }\n\n        \n        public object GetValue(object instance, string propertyName)\n        {\n            if (Properties.TryGetValue(propertyName, out PropertyInfo pi))\n            {\n                return pi.GetValue(instance);\n            }\n            throw new Exception($\"Property '{propertyName}' not found in {ValueClass.Name}\");\n        }\n\n        \n        public void SetValue(object instance, string propertyName, object value)\n        {\n            if (Properties.TryGetValue(propertyName, out PropertyInfo pi))\n            {\n                pi.SetValue(instance, value);\n            }\n            else\n            {\n                throw new Exception($\"Property '{propertyName}' not found in {ValueClass.Name}\");\n            }\n        }\n\n       \n        public void CopyProperties(object destination, object source)\n        {\n            foreach (var pi in Properties.Values)\n            {\n                if (pi.CanRead && pi.CanWrite)\n                {\n                    object value = pi.GetValue(source);\n                    pi.SetValue(destination, value);\n                }\n            }\n        }\n    }\n\n    \n    public class RttiCustomList\n    {\n       \n        private readonly ConcurrentDictionary<Type, RttiCustom> _registeredTypes =\n            new ConcurrentDictionary<Type, RttiCustom>();\n\n        \n        public RttiCustom RegisterType(Type type)\n        {\n            return _registeredTypes.GetOrAdd(type, t => new RttiCustom(t));\n        }\n\n        \n        public RttiCustom FindType(Type type)\n        {\n            _registeredTypes.TryGetValue(type, out RttiCustom result);\n            return result;\n        }\n    }\n\n    \n    public static class Rtti\n    {\n        \n        public static readonly RttiCustomList Global = new RttiCustomList();\n\n        \n        public static string ToText(RttiKind kind)\n        {\n            return kind.ToString();\n        }\n    }\n\n    \n    public class ObjectWithCustomCreate\n    {\n        \n        public ObjectWithCustomCreate()\n        {\n            \n            Rtti.Global.RegisterType(GetType());\n        }\n\n       \n        public static T CreateInstance<T>() where T : ObjectWithCustomCreate\n        {\n            return (T)Activator.CreateInstance(typeof(T));\n        }\n    }\n\n    \n    public class ObjectWithID : ObjectWithCustomCreate\n    {\n        public long ID { get; set; }\n\n        public ObjectWithID() : base() { }\n\n        public ObjectWithID(long id) : this()\n        {\n            ID = id;\n        }\n    }\n    public static class ObjectCopyHelper\n    {\n        \n        public static void CopyObject(object source, object destination)\n        {\n            if (source == null || destination == null)\n                throw new ArgumentNullException();\n            if (source.GetType() != destination.GetType())\n                throw new ArgumentException(\"Source and destination must be of the same type.\");\n\n            var custom = Rtti.Global.RegisterType(source.GetType());\n            custom.CopyProperties(destination, source);\n        }\n\n        \n        public static T CopyObject<T>(T source) where T : ObjectWithCustomCreate\n        {\n            if (source == null) return null;\n            T newObj = ObjectWithCustomCreate.CreateInstance<T>();\n            CopyObject(source, newObj);\n            return newObj;\n        }\n    }\n\n}"}
{"input": "unit ServicesInterfaceU;\n\ninterface\n\ntype\n  IUsersService = interface\n    ['{D54AF728-7688-40DE-B10C-E6D63949531E}']\n    function GetUserNameByID(const ID: Integer): String;\n  end;\n\n  ICustomersService = interface\n    ['{DC94C34E-13A2-4406-8961-6A407B792DD3}']\n    function GetCustomerNameByID(const ID: Integer): String;\n  end;\n\n  ICommonService = interface\n    ['{EAA26199-4142-4698-9C17-5D241D9984AA}']\n    function GetID: String;\n  end;\n\nimplementation\n\nend.", "output": "using System.Runtime.InteropServices;\n\nnamespace ServicesInterfaceU\n{\n    [Guid(\"D54AF728-7688-40DE-B10C-E6D63949531E\")]\n    public interface IUsersService\n    {\n        string GetUserNameByID(int id);\n    }\n\n    [Guid(\"DC94C34E-13A2-4406-8961-6A407B792DD3\")]\n    public interface ICustomersService\n    {\n        string GetCustomerNameByID(int id);\n    }\n\n    [Guid(\"EAA26199-4142-4698-9C17-5D241D9984AA\")]\n    public interface ICommonService\n    {\n        string GetID();\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Renderers.Mustache;\n\n{$IFDEF LINUX}\nThis unit is not compatible with Linux\n{$ENDIF}\ninterface\n\nuses\n  MVCFramework, System.SysUtils, System.Generics.Collections,\n  MVCFramework.Commons, System.IOUtils, System.RTTI,\n  System.Classes, Data.DB, MVCFramework.IntfObjectPool,\n  mormot.core.mustache, mormot.core.unicode;\n\ntype\n  { This class implements the mustache view engine for server side views }\n  TMVCMustacheViewEngine = class(TMVCBaseViewEngine)\n  strict private\n    procedure PrepareModels;\n  private\n    fModelPrepared: Boolean;\n    class var fPartials: TSynMustachePartials;\n    class var fHelpers: TSynMustacheHelpers;\n    class var fSerializerPool: IIntfObjectPool;\n    var FJSONModelAsString: string;\n    procedure LoadPartials;\n    procedure LoadHelpers;\n  protected\n    function RenderJSON(lViewEngine: TSynMustache; const JSON: UTF8String; Partials: TSynMustachePartials;\n      Helpers: TSynMustacheHelpers; OnTranslate: TOnStringTranslate; EscapeInvert: boolean): UTF8String; virtual;\n  public\n    procedure Execute(const ViewName: string; const Builder: TStringBuilder); override;\n    constructor Create(const AEngine: TMVCEngine; const AWebContext: TWebContext;\n      const AController: TMVCController;\n      const AViewModel: TMVCViewDataObject;\n      const AContentType: string); override;\n    class destructor Destroy;\n    class constructor Create;\n  end;\n\n  TLoadCustomHelpersProc = reference to procedure(var MustacheHelpers: TSynMustacheHelpers);\n\n  TMVCMustacheHelpers = class sealed\n  private\n    class var fOnLoadCustomHelpers: TLoadCustomHelpersProc;\n  protected\n    class procedure RegisterHandlers(var MustacheHelpers: TSynMustacheHelpers);\n    class procedure ToLowerCase(const Value: variant; out Result: variant);\n    class procedure ToUpperCase(const Value: variant; out Result: variant);\n    class procedure Capitalize(const Value: variant; out Result: variant);\n    class procedure SnakeCase(const Value: variant; out Result: variant);\n  public\n    class property OnLoadCustomHelpers: TLoadCustomHelpersProc read fOnLoadCustomHelpers write fOnLoadCustomHelpers;\n  end;\n\nimplementation\n\nuses\n  Types,\n  JsonDataObjects,\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.DuckTyping,\n  MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes,\n  MVCFramework.Serializer.JsonDataObjects;\n\n{$WARNINGS OFF}\n\n\ntype\n  TSynMustacheAccess = class(TSynMustache)\n  end;\n\nvar\n  gPartialsLoaded : Boolean = False;\n  gHelpersLoaded : Boolean = False;\n\nconstructor TMVCMustacheViewEngine.Create(const AEngine: TMVCEngine;\n  const AWebContext: TWebContext; const AController: TMVCController;\n  const AViewModel: TMVCViewDataObject; const AContentType: string);\nbegin\n  inherited;\n  fModelPrepared := False;\n  LoadPartials;\n  LoadHelpers;\nend;\n\nclass constructor TMVCMustacheViewEngine.Create;\nbegin\n  fSerializerPool := MVCFramework.IntfObjectPool.TIntfObjectPool.Create(10000, 10,1,\n    function: IInterface\n    begin\n      Result := TMVCJsonDataObjectsSerializer.Create(nil);\n      RegisterOptionalCustomTypesSerializers(Result as IMVCSerializer);\n    end);\nend;\n\nclass destructor TMVCMustacheViewEngine.Destroy;\nbegin\n  fPartials.Free;\nend;\n\nfunction TMVCMustacheViewEngine.RenderJSON(lViewEngine: TSynMustache; const JSON: UTF8String; Partials: TSynMustachePartials;\n  Helpers: TSynMustacheHelpers; OnTranslate: TOnStringTranslate; EscapeInvert: boolean): UTF8String;\nbegin\n  Result := lViewEngine.RenderJSON(JSON, Partials, Helpers, OnTranslate, EscapeInvert);\nend;\n\nprocedure TMVCMustacheViewEngine.Execute(const ViewName: string; const Builder: TStringBuilder);\nvar\n  lViewFileName: string;\n  lViewTemplate: UTF8String;\n  lViewEngine: TSynMustache;\nbegin\n  PrepareModels;\n  lViewFileName := GetRealFileName(ViewName);\n  if lViewFileName.IsEmpty then\n    raise EMVCSSVException.CreateFmt('View [%s] not found', [ViewName]);\n  lViewTemplate := StringToUTF8(TFile.ReadAllText(lViewFileName, TEncoding.UTF8));\n  lViewEngine := TSynMustache.Parse(lViewTemplate);\n  Builder.Append(UTF8Tostring(RenderJSON(lViewEngine, FJSONModelAsString, fPartials, fHelpers, nil, false)));\nend;\n\nprocedure TMVCMustacheViewEngine.LoadHelpers;\nbegin\n  if gHelpersLoaded then\n  begin\n    Exit\n  end\n  else\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if not gHelpersLoaded then\n      begin\n        fHelpers := TSynMustache.HelpersGetStandardList;\n        TMVCMustacheHelpers.RegisterHandlers(fHelpers); {dmvcframework specific helpers}\n        gHelpersLoaded := True;\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\nend;\n\nprocedure TMVCMustacheViewEngine.LoadPartials;\nvar\n  lViewsExtension: string;\n  lViewPath: string;\n  lPartialName: String;\n  lPartialFileNames: TStringDynArray;\n  I: Integer;\nbegin\n  if gPartialsLoaded then\n  begin\n    Exit\n  end\n  else\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if not gPartialsLoaded then\n      begin\n        lViewsExtension := Config[TMVCConfigKey.DefaultViewFileExtension];\n        lViewPath := Config[TMVCConfigKey.ViewPath];\n        lPartialFileNames := TDirectory.GetFiles(lViewPath, '*.' + lViewsExtension, TSearchOption.soAllDirectories);\n        FreeAndNil(fPartials);\n        fPartials := TSynMustachePartials.Create;\n        for I := 0 to High(lPartialFileNames) do\n        begin\n          lPartialName := lPartialFileNames[i]\n            .Remove(lPartialFileNames[i].Length - lViewsExtension.Length - 1)\n            .Replace(TPath.DirectorySeparatorChar, '/');\n          lPartialName := lPartialName.Remove(0, lViewPath.Length + 1);\n          fPartials.Add(lPartialName, TFile.ReadAllText(lPartialFileNames[i]));\n        end;\n        gPartialsLoaded := SameText(Config[TMVCConfigKey.ViewCache], 'true');\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\nend;\n\n{$WARNINGS ON}\n\n\nprocedure TMVCMustacheViewEngine.PrepareModels;\nvar\n  DataObj: TPair<string, TValue>;\n  lSer: IMVCSerializer;\n  lJSONModel: TJsonObject;\nbegin\n  if fModelPrepared then\n  begin\n    Exit;\n  end;\n\n  lSer := fSerializerPool.GetFromPool(True) as IMVCSerializer;\n  try\n    lJSONModel := TJsonObject.Create;\n    try\n      if Assigned(ViewModel) then\n      begin\n        for DataObj in ViewModel do\n        begin\n          TMVCJsonDataObjectsSerializer(lSer).TValueToJSONObjectProperty(lJSONModel, DataObj.Key, DataObj.Value, TMVCSerializationType.stDefault, nil, nil);\n        end;\n      end;\n      FJSONModelAsString := lJSONModel.ToJSON(False);\n    finally\n      lJSONModel.Free;\n    end;\n  finally\n    fSerializerPool.ReleaseToPool(lSer)\n  end;\n  fModelPrepared := True;\nend;\n\n{ dmvcframework specific helpers}\n\nclass procedure TMVCMustacheHelpers.Capitalize(const Value: variant;\n  out Result: variant);\nbegin\n  Result := MVCFramework.Commons.CamelCase(Value, True);\nend;\n\nclass procedure TMVCMustacheHelpers.RegisterHandlers(var MustacheHelpers: TSynMustacheHelpers);\nbegin\n  TSynMustache.HelperAdd(MustacheHelpers, 'UpperCase', TMVCMustacheHelpers.ToUpperCase);\n  TSynMustache.HelperAdd(MustacheHelpers, 'LowerCase', TMVCMustacheHelpers.ToLowerCase);\n  TSynMustache.HelperAdd(MustacheHelpers, 'Capitalize', TMVCMustacheHelpers.Capitalize);\n  TSynMustache.HelperAdd(MustacheHelpers, 'SnakeCase', TMVCMustacheHelpers.SnakeCase);\n  if Assigned(fOnLoadCustomHelpers) then\n  begin\n    fOnLoadCustomHelpers(MustacheHelpers);\n  end;\nend;\n\nclass procedure TMVCMustacheHelpers.SnakeCase(const Value: variant;\n  out Result: variant);\nbegin\n  Result := MVCFramework.Commons.SnakeCase(Value);\nend;\n\nclass procedure TMVCMustacheHelpers.ToLowerCase(const Value: variant;\n  out Result: variant);\nbegin\n  Result := System.SysUtils.LowerCase(Value);\nend;\n\nclass procedure TMVCMustacheHelpers.ToUpperCase(const Value: variant; out Result: variant);\nbegin\n  Result := System.SysUtils.UpperCase(Value);\nend;\n\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.IntfObjectPool;\nusing mORMot.Core.Mustache;\nusing mORMot.Core.Unicode;\n\nnamespace MVCFramework.View.Renderers\n{\n    \n    public class MVCMustacheViewEngine : MVCBaseViewEngine\n    {\n        private bool modelPrepared;\n        private string jsonModelAsString;\n\n        private static TSynMustachePartials partials;\n        private static TSynMustacheHelpers helpers;\n        private static IIntfObjectPool serializerPool;\n        private static readonly object globalLock = new object();\n        private static bool gPartialsLoaded = false;\n        private static bool gHelpersLoaded = false;\n\n        \n        public MVCMustacheViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller,\n            MVCViewDataObject viewModel, string contentType)\n            : base(engine, webContext, controller, viewModel, contentType)\n        {\n            modelPrepared = false;\n            LoadPartials();\n            LoadHelpers();\n        }\n\n        static MVCMustacheViewEngine()\n        {\n            serializerPool = TIntfObjectPool.Create(10000, 10, 1, () =>\n            {\n                var serializer = new MVCJsonDataObjectsSerializer();\n                MVCSerializerOptionalCustomTypes.RegisterOptionalCustomTypesSerializers(serializer);\n                return serializer;\n            });\n        }\n\n        \n        protected virtual string RenderJSON(TSynMustache viewEngine, string json, TSynMustachePartials partials,\n            TSynMustacheHelpers helpers, TOnStringTranslate onTranslate, bool escapeInvert)\n        {\n            return viewEngine.RenderJSON(json, partials, helpers, onTranslate, escapeInvert);\n        }\n\n        \n        public override void Execute(string viewName, StringBuilder builder)\n        {\n            PrepareModels();\n\n            string viewFileName = GetRealFileName(viewName);\n            if (string.IsNullOrEmpty(viewFileName))\n                throw new EMVCSSVException($\"View [{viewName}] not found\");\n\n            string viewTemplate = File.ReadAllText(viewFileName, Encoding.UTF8);\n            TSynMustache viewEngine = TSynMustache.Parse(viewTemplate);\n            string rendered = RenderJSON(viewEngine, jsonModelAsString, partials, helpers, null, false);\n            builder.Append(rendered);\n        }\n\n        \n        private void PrepareModels()\n        {\n            if (modelPrepared)\n                return;\n\n            var serializer = (IMVCSerializer)serializerPool.GetFromPool(true);\n            try\n            {\n                var jsonModel = new JsonObject();\n                if (ViewModel != null)\n                {\n                    foreach (var dataPair in ViewModel)\n                    {\n                        ((MVCJsonDataObjectsSerializer)serializer).TValueToJSONObjectProperty(jsonModel, dataPair.Key,\n                            dataPair.Value, TMVCSerializationType.stDefault, null, null);\n                    }\n                }\n                jsonModelAsString = jsonModel.ToJSON();\n            }\n            finally\n            {\n                serializerPool.ReleaseToPool(serializer);\n            }\n            modelPrepared = true;\n        }\n\n        private void LoadPartials()\n        {\n            if (gPartialsLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gPartialsLoaded)\n                {\n                    string viewsExtension = Config[TMVCConfigKey.DefaultViewFileExtension];\n                    string viewPath = Config[TMVCConfigKey.ViewPath];\n                    string[] partialFiles = Directory.GetFiles(viewPath, \"*.\" + viewsExtension, SearchOption.AllDirectories);\n\n                    partials?.Dispose();\n                    partials = new TSynMustachePartials();\n\n                    foreach (string file in partialFiles)\n                    {\n                        string partialName = file.Substring(0, file.Length - (viewsExtension.Length + 1))\n                            .Replace(Path.DirectorySeparatorChar, '/');\n                        partialName = partialName.Substring(viewPath.Length + 1);\n                        string content = File.ReadAllText(file);\n                        partials.Add(partialName, content);\n                    }\n                    gPartialsLoaded = string.Equals(Config[TMVCConfigKey.ViewCache], \"true\", StringComparison.OrdinalIgnoreCase);\n                }\n            }\n        }\n\n        private void LoadHelpers()\n        {\n            if (gHelpersLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gHelpersLoaded)\n                {\n                    helpers = TSynMustache.HelpersGetStandardList();\n                    MVCMustacheHelpers.RegisterHandlers(ref helpers);\n                    gHelpersLoaded = true;\n                }\n            }\n        }\n    }\n\n    \n    public static class MVCMustacheHelpers\n    {\n        public delegate void TLoadCustomHelpersProc(ref TSynMustacheHelpers mustacheHelpers);\n\n        private static TLoadCustomHelpersProc onLoadCustomHelpers;\n        public static TLoadCustomHelpersProc OnLoadCustomHelpers\n        {\n            get { return onLoadCustomHelpers; }\n            set { onLoadCustomHelpers = value; }\n        }\n\n        \n        public static void RegisterHandlers(ref TSynMustacheHelpers mustacheHelpers)\n        {\n            TSynMustache.HelperAdd(mustacheHelpers, \"UpperCase\", new TSynMustacheHelperDelegate(ToUpperCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"LowerCase\", new TSynMustacheHelperDelegate(ToLowerCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"Capitalize\", new TSynMustacheHelperDelegate(Capitalize));\n            TSynMustache.HelperAdd(mustacheHelpers, \"SnakeCase\", new TSynMustacheHelperDelegate(SnakeCase));\n\n            onLoadCustomHelpers?.Invoke(ref mustacheHelpers);\n        }\n\n        public static void ToLowerCase(object value, out object result)\n        {\n            result = value?.ToString().ToLower();\n        }\n\n        public static void ToUpperCase(object value, out object result)\n        {\n            result = value?.ToString().ToUpper();\n        }\n\n        public static void Capitalize(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (!string.IsNullOrEmpty(s))\n                result = char.ToUpper(s[0]) + s.Substring(1).ToLower();\n            else\n                result = s;\n        }\n\n        public static void SnakeCase(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (string.IsNullOrEmpty(s))\n            {\n                result = s;\n                return;\n            }\n            var sb = new StringBuilder();\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (char.IsUpper(s[i]))\n                {\n                    if (i > 0)\n                        sb.Append('_');\n                    sb.Append(char.ToLower(s[i]));\n                }\n                else\n                {\n                    sb.Append(s[i]);\n                }\n            }\n            result = sb.ToString();\n        }\n    }\n}"}
{"input": "unit MainDMU;\n\ninterface\n\nuses\n  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,\n  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,\n  FireDAC.DApt.Intf, FireDAC.Stan.StorageBin, Data.DB, FireDAC.Comp.DataSet,\n  FireDAC.Comp.Client;\n\ntype\n  TdmMain = class(TDataModule)\n    dsPeople: TFDMemTable;\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{%CLASSGROUP 'System.Classes.TPersistent'}\n\n{$R *.dfm}\n\nend.", "output": "using System;\nusing System.ComponentModel;\nusing System.Data;\n\nnamespace MyApp.Data\n{\n    \n    public class TdmMain : Component\n    {\n        private DataTable _dsPeople;\n\n        public TdmMain()\n        {\n            \n            _dsPeople = new DataTable(\"People\");\n            \n            \n        }\n\n        \n        public DataTable DsPeople\n        {\n            get { return _dsPeople; }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.SecurityHeaders;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework;\n\ntype\n  TMVCSecurityHeadersMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  public\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      var AHandled: Boolean);\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  end;\n\nimplementation\n\n{ TMVCSecurityHeadersMiddleware }\n\nprocedure TMVCSecurityHeadersMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnBeforeRouting(AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  AContext.Response.SetCustomHeader('X-XSS-Protection', '1; mode = block');\n  AContext.Response.SetCustomHeader('X-Content-Type-Options', 'nosniff');\nend;\n\nend.", "output": "using System;\nusing MVCFramework;\n\nnamespace MVCFramework.Middleware\n{\n    \n    public class MVCSecurityHeadersMiddleware : IMVCMiddleware\n    {\n        \n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            context.Response.SetCustomHeader(\"X-XSS-Protection\", \"1; mode=block\");\n            context.Response.SetCustomHeader(\"X-Content-Type-Options\", \"nosniff\");\n        }\n\n        \n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Do nothing.\n        }\n\n        \n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Do nothing.\n        }\n\n        \n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Do nothing.\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Compression;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Logger;\n\ntype\n  TMVCCompressionMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fCompressionThreshold: Integer;\n  protected\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionNAme: string;\n      var AHandled: Boolean);\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  public\n    constructor Create(aCompressionThreshold: Integer = 1024); virtual;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.ZLib,\n  System.Classes,\n  MVCFramework.Commons;\n\n{ TMVCSalutationMiddleware }\n\nconstructor TMVCCompressionMiddleware.Create(aCompressionThreshold: Integer);\nbegin\n  inherited Create;\n  fCompressionThreshold := aCompressionThreshold;\nend;\n\nprocedure TMVCCompressionMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCCompressionMiddleware.OnAfterRouting(AContext: TWebContext;\n  const AHandled: Boolean);\nvar\n  lMemStream: TMemoryStream;\n  lContentStream: TStream;\n  lAcceptEncoding: string;\n  lEncodings: TArray<string>;\n  lItem: string;\n  lRespCompressionType: TMVCCompressionType;\n  lTmpItem: string;\n{.$IF not Defined(ALEXANDRIAORBETTER)}\n  lZStream: TZCompressionStream;\n{.$ENDIF}\nbegin\n  if IsLibrary then\n  begin\n    Exit;\n  end;\n  lContentStream := AContext.Response.RawWebResponse.ContentStream;\n  if (lContentStream = nil) or (lContentStream.Size <= fCompressionThreshold)\n  then\n    Exit;\n\n  lAcceptEncoding := AContext.Request.Headers['Accept-Encoding'];\n  if lAcceptEncoding.IsEmpty then\n  begin\n    Exit;\n  end;\n  lAcceptEncoding := lAcceptEncoding.Trim.ToLower;\n\n  lRespCompressionType := TMVCCompressionType.ctNone;\n  lEncodings := lAcceptEncoding.Split([',']);\n  for lItem in lEncodings do\n  begin\n    lTmpItem := lItem.Trim;\n    if lTmpItem = 'gzip' then\n    begin\n{.$IF Defined(ALEXANDRIAORBETTER)}\n      {\n        There is a bug in 11 Alexandria with TZCompressionStream, so the gzip compression\n        is not available until the fix.\n        The issue has been created on https://quality.embarcadero.com/browse/RSP-35516\n      }\n{.$ELSE}\n      lRespCompressionType := TMVCCompressionType.ctGZIP;\n      break;\n{.$ENDIF}\n    end\n    else if lTmpItem = 'deflate' then\n    begin\n      lRespCompressionType := TMVCCompressionType.ctDeflate;\n      break;\n    end;\n  end;\n\n  if lRespCompressionType = TMVCCompressionType.ctNone then\n    Exit;\n\n  { When it is a TFileStream copy it to a TMemoryStream, as TFileStream is read only }\n  // if lContentStream is TFileStream then\n  // begin\n  lMemStream := TMemoryStream.Create;\n  try\n{.$IF Defined(ALEXANDRIAORBETTER)}\n    //ZCompressStream(lContentStream, lMemStream);\n    // use it only for deflate, ZCompressStream (Delphi 11.0) cannot\n    // create gzip compliant streams\n{.$ELSE}\n    lZStream := TZCompressionStream.Create(lMemStream,\n      TZCompressionLevel.zcMax, MVC_COMPRESSION_ZLIB_WINDOW_BITS\n      [lRespCompressionType]);\n    try\n      lContentStream.Position := 0;\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n//    There is a bug in 11 Alexandria with TZCompressionStream, this bug\n//    raises an exception here and the debugger catches it, but it its \"normal\" behavior.\n//    The gzip stream is correctly created. Please, vote for its resolution.\n//    https://quality.embarcadero.com/browse/RSP-35516\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n      lZStream.CopyFrom(lContentStream, 0);\n    finally\n      lZStream.Free;\n    end;\n{.$ENDIF}\n  except\n    lMemStream.Free;\n    raise;\n  end;\n  lMemStream.Position := 0;\n  AContext.Response.RawWebResponse.ContentStream := lMemStream;\n{$IF Defined(SeattleOrBetter)}\n  AContext.Response.RawWebResponse.ContentEncoding :=\n    MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType];\n{$ELSE}\n  AContext.Response.RawWebResponse.ContentEncoding :=\n    AnsiString(MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType]);\n{$ENDIF}\n  // end;\n  //\n  // lContentStream.Position := 0;\n  // lMemStream := TMemoryStream.Create;\n  // try\n  // ZCompressStream(lContentStream, lMemStream, TZCompressionLevel.zcDefault);\n  // except\n  // lMemStream.Free;\n  // raise;\n  // end;\n  //\n  // { TODO -oDanieleT -cGeneral : Use directly lContentStreamHelper? }\n  // // lZStream := TZCompressionStream.Create(lMemStream, TZCompressionLevel.zcMax,\n  // // MVC_COMPRESSION_ZLIB_WINDOW_BITS[lRespCompressionType]);\n  // // try\n  // // lZStream.CopyFrom(lContentStreamHelper, 0);\n  // // finally\n  // // lZStream.Free;\n  // // end;\n  // lMemStream.Position := 0;\n  //\n  // // AContext.Response.Content := '';\n  // // lContentStreamHelper.Size := 0;\n  // // lContentStreamHelper.CopyFrom(lMemStream, 0);\n  // AContext.Response.RawWebResponse.ContentStream := lMemStream;\n  // {$IF Defined(SeattleOrBetter)}\n  // AContext.Response.RawWebResponse.ContentEncoding :=\n  // MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType];\n  // {$ELSE}\n  // AContext.Response.RawWebResponse.ContentEncoding :=\n  // AnsiString(MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType]);\n  // {$ENDIF}\n  // // finally\n  // // lMemStream.Free;\n  // // end;\nend;\n\nprocedure TMVCCompressionMiddleware.OnBeforeControllerAction\n  (AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionNAme: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCCompressionMiddleware.OnBeforeRouting(AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing MVCFramework; \nusing MVCFramework.Commons; \nusing MVCFramework.Logger;\n\nnamespace MVCFramework.Middleware.Compression\n{\n    \n    public class MVCCompressionMiddleware : IMVCMiddleware\n    {\n        private readonly int _compressionThreshold;\n\n        \n        public MVCCompressionMiddleware(int compressionThreshold = 1024)\n        {\n            _compressionThreshold = compressionThreshold;\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            // No routing-time actions required.\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Nothing to do before controller action.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Nothing to do after controller action.\n        }\n\n       \n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            \n            if (WebContext.IsLibrary)\n            {\n                return;\n            }\n\n            \n            Stream contentStream = context.Response.RawWebResponse.ContentStream;\n            if (contentStream == null || contentStream.Length <= _compressionThreshold)\n            {\n                return;\n            }\n\n            \n            string acceptEncoding = context.Request.Headers[\"Accept-Encoding\"];\n            if (string.IsNullOrWhiteSpace(acceptEncoding))\n            {\n                return;\n            }\n            acceptEncoding = acceptEncoding.Trim().ToLowerInvariant();\n\n            \n            CompressionType respCompressionType = CompressionType.None;\n            \n            var encodings = acceptEncoding.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                                          .Select(e => e.Trim());\n            foreach (var encoding in encodings)\n            {\n                if (encoding == \"gzip\")\n                {\n                    respCompressionType = CompressionType.GZip;\n                    break;\n                }\n                else if (encoding == \"deflate\")\n                {\n                    respCompressionType = CompressionType.Deflate;\n                    break;\n                }\n            }\n            if (respCompressionType == CompressionType.None)\n            {\n                return;\n            }\n\n            \n            MemoryStream originalContent;\n            if (contentStream is MemoryStream memStream)\n            {\n                originalContent = memStream;\n            }\n            else\n            {\n                originalContent = new MemoryStream();\n                contentStream.CopyTo(originalContent);\n            }\n            originalContent.Position = 0;\n\n            \n            var compressedStream = new MemoryStream();\n            try\n            {\n                \n                if (respCompressionType == CompressionType.GZip)\n                {\n                    using (var gzip = new GZipStream(compressedStream, CompressionLevel.Optimal, leaveOpen: true))\n                    {\n                        originalContent.CopyTo(gzip);\n                    }\n                }\n                else if (respCompressionType == CompressionType.Deflate)\n                {\n                    using (var deflate = new DeflateStream(compressedStream, CompressionLevel.Optimal, leaveOpen: true))\n                    {\n                        originalContent.CopyTo(deflate);\n                    }\n                }\n                \n                compressedStream.Position = 0;\n                \n                context.Response.RawWebResponse.ContentStream = compressedStream;\n                \n                context.Response.RawWebResponse.ContentEncoding = \n                    respCompressionType == CompressionType.GZip ? \"gzip\" : \"deflate\";\n            }\n            catch (Exception ex)\n            {\n                \n                Logger.LogError(\"Compression failed: \" + ex.Message);\n                compressedStream.Dispose();\n                throw;\n            }\n        }\n\n       \n        private enum CompressionType\n        {\n            None,\n            GZip,\n            Deflate\n        }\n    }\n}"}
{"input": "unit BusinessObjects;\n\n// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\ninterface\n\nuses\n  MVCFramework.Serializer.Commons,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Nullables,\n  MVCFramework.Rtti.Utils,\n  System.Generics.Collections,\n  System.Classes;\n\ntype\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('articles')]\n  TArticles = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: Int64;\n    [MVCTableField('description')]\n    fDescription: String;\n    [MVCTableField('price')]\n    fPrice: Integer;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    property ID: Int64 read fID write fID;\n    property Description: String read fDescription write fDescription;\n    property Price: Integer read fPrice write fPrice;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('order_details')]\n  TOrderDetail = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: NullableInt64;\n    [MVCTableField('id_order')]\n    fIDOrder: Int64;\n    [MVCTableField('id_article')]\n    fIDArticle: Int64;\n    [MVCTableField('unit_price')]\n    fUnitPrice: Currency;\n    [MVCTableField('discount')]\n    fDiscount: Integer;\n    [MVCTableField('quantity')]\n    fQuantity: Integer;\n    [MVCTableField('description')]\n    fDescription: String;\n    [MVCTableField('total')]\n    fTotal: Currency;\n    procedure SetDescription(const Value: String);\n    procedure SetDiscount(const Value: Integer);\n    procedure SetQuantity(const Value: Integer);\n    procedure SetUnitPrice(const Value: Currency);\n  protected\n    procedure OnBeforeInsertOrUpdate; override;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure RecalcTotal;\n    function Clone: TOrderDetail;\n    procedure Assign(Value: TMVCActiveRecord); override;\n    property ID: NullableInt64 read fID write fID;\n    [MVCDoNotSerialize]\n    property IDOrder: Int64 read fIDOrder write fIDOrder;\n    property IDArticle: Int64 read fIDArticle write fIDArticle;\n    property UnitPrice: Currency read fUnitPrice write SetUnitPrice;\n    property Discount: Integer read fDiscount write SetDiscount;\n    property Quantity: Integer read fQuantity write SetQuantity;\n    property Description: String read fDescription write SetDescription;\n    property Total: Currency read fTotal;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('orders')]\n  TOrder = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: NullableUInt64;\n    [MVCTableField('id_customer')]\n    fIDCustomer: Integer;\n    [MVCTableField('order_date')]\n    fOrderDate: TDate;\n    [MVCTableField('total')]\n    fTotal: Currency;\n    [MVCOwned]\n    fDetails: TObjectList<TOrderDetail>;\n  protected\n    procedure OnAfterLoad; override;\n    procedure OnAfterInsertOrUpdate; override;\n    procedure OnBeforeInsertOrUpdate; override;\n    procedure RecalcTotals;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure AddOrderItem(const OrderItem: TOrderDetail);\n    procedure UpdateOrderItemByID(const OrderItemID: Integer; const OrderItem: TOrderDetail);\n    function GetOrderDetailByID(const Value: Int64): TOrderDetail;\n    property ID: NullableUInt64 read fID write fID;\n    [MVCNameAs('idCustomer')]\n    property IDCustomer: Integer read fIDCustomer write fIDCustomer;\n    property OrderDate: TDate read fOrderDate write fOrderDate;\n    property Total: Currency read fTotal write fTotal;\n    property OrderItems: TObjectList<TOrderDetail> read fDetails;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  TOrderIn = class\n  private\n    fID: NullableUInt64;\n    fIDCustomer: NullableUInt64;\n    fOrderDate: NullableTDate;\n    fTotal: NullableCurrency;\n    [MVCOwned(TOrderDetail)]\n    fDetails: TObjectList<TOrderDetail>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    property ID: NullableUInt64 read fID write fID;\n    [MVCNameAs('idCustomer')]\n    property IDCustomer: NullableUInt64 read fIDCustomer write fIDCustomer;\n    property OrderDate: NullableTDate read fOrderDate write fOrderDate;\n    property Total: NullableCurrency read fTotal write fTotal;\n    property OrderItems: TObjectList<TOrderDetail> read fDetails;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nconstructor TArticles.Create;\nbegin\n  inherited Create;\nend;\n\ndestructor TArticles.Destroy;\nbegin\n  inherited;\nend;\n\nprocedure TOrderDetail.Assign(Value: TMVCActiveRecord);\nvar\n  lObj: TOrderDetail;\nbegin\n  if Value is TOrderDetail then\n  begin\n    lObj := TOrderDetail(Value);\n    self.ID := lObj.ID;\n    self.IDOrder := lObj.IDOrder;\n    self.IDArticle := lObj.IDArticle;\n    self.UnitPrice := lObj.UnitPrice;\n    self.Discount := lObj.Discount;\n    self.Quantity := lObj.Quantity;\n    self.Description := lObj.Description;\n  end\n  else\n  begin\n    inherited;\n  end;\nend;\n\nfunction TOrderDetail.Clone: TOrderDetail;\nbegin\n  Result := TOrderDetail.Create;\n  Result.Assign(Self);\nend;\n\nconstructor TOrderDetail.Create;\nbegin\n  inherited Create;\nend;\n\ndestructor TOrderDetail.Destroy;\nbegin\n  inherited;\nend;\n\nprocedure TOrderDetail.OnBeforeInsertOrUpdate;\nbegin\n  inherited;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.RecalcTotal;\nbegin\n  fTotal := fUnitPrice * fQuantity * (1 - fDiscount / 100);\nend;\n\nprocedure TOrderDetail.SetDescription(const Value: String);\nbegin\n  fDescription := Value;\nend;\n\nprocedure TOrderDetail.SetDiscount(const Value: Integer);\nbegin\n  fDiscount := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.SetQuantity(const Value: Integer);\nbegin\n  fQuantity := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.SetUnitPrice(const Value: Currency);\nbegin\n  fUnitPrice := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrder.AddOrderItem(const OrderItem: TOrderDetail);\nbegin\n  OrderItem.IDOrder := ID;\n  OrderItems.Add(OrderItem);\nend;\n\nconstructor TOrder.Create;\nbegin\n  inherited Create;\n  fDetails := TObjectList<TOrderDetail>.Create(true);\nend;\n\ndestructor TOrder.Destroy;\nbegin\n  fDetails.Free;\n  inherited;\nend;\n\nfunction TOrder.GetOrderDetailByID(const Value: Int64): TOrderDetail;\nvar\n  lOrderDetail: TOrderDetail;\nbegin\n  inherited;\n  for lOrderDetail in fDetails do\n  begin\n    if lOrderDetail.ID.Value = Value then\n    begin\n      Exit(lOrderDetail);\n    end;\n  end;\n  raise EMVCActiveRecord.Create('Item not found');\nend;\n\nprocedure TOrder.OnAfterInsertOrUpdate;\nbegin\n  inherited;\n  for var lOrderItem in OrderItems do\n  begin\n    lOrderItem.IDOrder := ID;\n    lOrderItem.Store;\n  end;\nend;\n\nprocedure TOrder.OnBeforeInsertOrUpdate;\nbegin\n  inherited;\n  RecalcTotals;\nend;\n\nprocedure TOrder.RecalcTotals;\nbegin\n  fTotal := 0;\n  for var lOrderItem in fDetails do\n  begin\n    fTotal := fTotal + lOrderItem.Total;\n  end;\nend;\n\nprocedure TOrder.UpdateOrderItemByID(const OrderItemID: Integer;\n  const OrderItem: TOrderDetail);\nbegin\n  var lObj := GetOrderDetailByID(OrderItemID);\n  lObj.Assign(OrderItem);\n  lObj.IDOrder := ID;\nend;\n\nprocedure TOrder.OnAfterLoad;\nvar\n  lList: TObjectList<TOrderDetail>;\nbegin\n  inherited;\n  lList := TMVCActiveRecord.SelectRQL<TOrderDetail>(Format('eq(idOrder,%d)',[ID.Value]), 1000);\n  try\n    fDetails.Clear;\n    fDetails.AddRange(lList);\n    lList.OwnsObjects := False;\n  finally\n    lList.Free;\n  end;\nend;\n\n\n{ TOrderIn }\n\nconstructor TOrderIn.Create;\nbegin\n  inherited;\n  fDetails := TObjectList<TOrderDetail>.Create(true);\nend;\n\ndestructor TOrderIn.Destroy;\nbegin\n  fDetails.Free;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BusinessObjects\n{\n    #region Custom Attributes\n\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCNameCaseAttribute : Attribute\n    {\n        public string NameCase { get; }\n        public MVCNameCaseAttribute(string nameCase)\n        {\n            NameCase = nameCase;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCTableAttribute : Attribute\n    {\n        public string TableName { get; }\n        public MVCTableAttribute(string tableName)\n        {\n            TableName = tableName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCTableFieldAttribute : Attribute\n    {\n        public string FieldName { get; }\n        \n        public MVCTableFieldAttribute(string fieldName)\n        {\n            FieldName = fieldName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCOwnedAttribute : Attribute\n    {\n        public Type OwnedType { get; }\n        public MVCOwnedAttribute() { }\n        public MVCOwnedAttribute(Type ownedType)\n        {\n            OwnedType = ownedType;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCNameAsAttribute : Attribute\n    {\n        public string Name { get; }\n        public MVCNameAsAttribute(string name)\n        {\n            Name = name;\n        }\n    }\n\n    #endregion\n\n    #region Base ActiveRecord Class\n\n    public abstract class MVCActiveRecord\n    {\n        public virtual void OnBeforeInsertOrUpdate() { }\n        public virtual void OnAfterInsertOrUpdate() { }\n        public virtual void OnAfterLoad() { }\n        public virtual void Store() { /* Stub: persist changes */ }\n        \n        public virtual void Assign(MVCActiveRecord value)\n        {\n            // Optionally implement a generic assignment if needed.\n        }\n\n        public static List<T> SelectRQL<T>(string query, int limit) where T : MVCActiveRecord, new()\n        {\n            \n            return new List<T>();\n        }\n    }\n\n    #endregion\n\n    #region Business Objects\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"articles\")]\n    public class Articles : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public long ID { get; set; }\n\n        [MVCTableField(\"description\")]\n        public string Description { get; set; }\n\n        [MVCTableField(\"price\")]\n        public int Price { get; set; }\n\n        public Articles() : base() { }\n        ~Articles() { }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"order_details\")]\n    public class OrderDetail : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public long? ID { get; set; }\n\n        [MVCTableField(\"id_order\")]\n        public long IDOrder { get; set; }\n\n        [MVCTableField(\"id_article\")]\n        public long IDArticle { get; set; }\n\n        private decimal _unitPrice;\n        [MVCTableField(\"unit_price\")]\n        public decimal UnitPrice\n        {\n            get => _unitPrice;\n            set { _unitPrice = value; RecalcTotal(); }\n        }\n\n        private int _discount;\n        [MVCTableField(\"discount\")]\n        public int Discount\n        {\n            get => _discount;\n            set { _discount = value; RecalcTotal(); }\n        }\n\n        private int _quantity;\n        [MVCTableField(\"quantity\")]\n        public int Quantity\n        {\n            get => _quantity;\n            set { _quantity = value; RecalcTotal(); }\n        }\n\n        private string _description;\n        [MVCTableField(\"description\")]\n        public string Description\n        {\n            get => _description;\n            set => _description = value;\n        }\n\n        [MVCTableField(\"total\")]\n        public decimal Total { get; private set; }\n\n        public OrderDetail() : base() { }\n        ~OrderDetail() { }\n\n        public override void OnBeforeInsertOrUpdate()\n        {\n            base.OnBeforeInsertOrUpdate();\n            RecalcTotal();\n        }\n\n        public void RecalcTotal()\n        {\n            \n            Total = UnitPrice * Quantity * (1 - Discount / 100m);\n        }\n\n        public OrderDetail Clone()\n        {\n            var clone = new OrderDetail();\n            clone.Assign(this);\n            return clone;\n        }\n\n        public override void Assign(MVCActiveRecord value)\n        {\n            if (value is OrderDetail other)\n            {\n                this.ID = other.ID;\n                this.IDOrder = other.IDOrder;\n                this.IDArticle = other.IDArticle;\n                this.UnitPrice = other.UnitPrice;\n                this.Discount = other.Discount;\n                this.Quantity = other.Quantity;\n                this.Description = other.Description;\n                \n            }\n            else\n            {\n                base.Assign(value);\n            }\n        }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"orders\")]\n    public class Order : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public ulong? ID { get; set; }\n\n        [MVCTableField(\"id_customer\")]\n        public int IDCustomer { get; set; }\n\n        [MVCTableField(\"order_date\")]\n        public DateTime OrderDate { get; set; }\n\n        [MVCTableField(\"total\")]\n        public decimal Total { get; set; }\n\n        [MVCOwned]\n        public List<OrderDetail> OrderItems { get; private set; }\n\n        public Order() : base()\n        {\n            OrderItems = new List<OrderDetail>();\n        }\n\n        ~Order() { }\n\n        public void AddOrderItem(OrderDetail orderItem)\n        {\n            if (ID.HasValue)\n            {\n                orderItem.IDOrder = (long)ID.Value;\n            }\n            OrderItems.Add(orderItem);\n        }\n\n        public void UpdateOrderItemByID(long orderItemID, OrderDetail orderItem)\n        {\n            var existing = GetOrderDetailByID(orderItemID);\n            existing.Assign(orderItem);\n            if (ID.HasValue)\n            {\n                existing.IDOrder = (long)ID.Value;\n            }\n        }\n\n        public OrderDetail GetOrderDetailByID(long value)\n        {\n            foreach (var orderDetail in OrderItems)\n            {\n                if (orderDetail.ID.HasValue && orderDetail.ID.Value == value)\n                {\n                    return orderDetail;\n                }\n            }\n            throw new Exception(\"Item not found\");\n        }\n\n        public override void OnAfterInsertOrUpdate()\n        {\n            base.OnAfterInsertOrUpdate();\n            foreach (var orderItem in OrderItems)\n            {\n                if (ID.HasValue)\n                {\n                    orderItem.IDOrder = (long)ID.Value;\n                }\n                orderItem.Store();\n            }\n        }\n\n        public override void OnBeforeInsertOrUpdate()\n        {\n            base.OnBeforeInsertOrUpdate();\n            RecalcTotals();\n        }\n\n        public void RecalcTotals()\n        {\n            Total = OrderItems.Sum(item => item.Total);\n        }\n\n        public override void OnAfterLoad()\n        {\n            base.OnAfterLoad();\n            if (ID.HasValue)\n            {\n                \n                var query = $\"eq(idOrder,{ID.Value})\";\n                var list = SelectRQL<OrderDetail>(query, 1000);\n                OrderItems.Clear();\n                OrderItems.AddRange(list);\n            }\n        }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    public class OrderIn\n    {\n        public ulong? ID { get; set; }\n        [MVCNameAs(\"idCustomer\")]\n        public ulong? IDCustomer { get; set; }\n        public DateTime? OrderDate { get; set; }\n        public decimal? Total { get; set; }\n        [MVCOwned(typeof(OrderDetail))]\n        public List<OrderDetail> OrderItems { get; private set; }\n\n        public OrderIn()\n        {\n            OrderItems = new List<OrderDetail>();\n        }\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit RESTAdapterTestsU;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework.RESTAdapter,\n  DUnitX.TestFramework,\n  BusinessObjectsU,\n  Generics.Collections,\n  JsonDataObjects,\n  MVCFramework.RESTClient,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.RESTClient.Intf;\n\ntype\n\n  [Headers('User-Agent', 'RESTAdapter-Test')]\n  ITESTService = interface(IInvokable)\n    ['{58B9FA23-92F4-4B8E-814B-05232F32A41F}']\n\n    [RESTResource(HttpGet, '/people')]\n    [MVCListOf(TPerson)]\n    function GetPeople: TObjectList<TPerson>;\n\n    [RESTResource(HttpGet, '/people')]\n    [MVCListOf(TPerson)]\n    [Mapping(TPeople)]\n    procedure GetPeopleAsynch(AAsynchRequest: IAsynchRequest);\n\n    [RESTResource(HttpGet, '/people/1')]\n    function GetTonyStark: TPerson;\n\n    [RESTResource(HttpGet, '/people/1')]\n    [Mapping(TPerson)]\n    procedure GetTonyStarkAsynch(AAsynchRequest: IAsynchRequest);\n\n    [RESTResource(HttpGet, '/people/{personid}')]\n    function GetPersonByID([Param('personid')] APersonID: integer): TPerson;\n\n    [RESTResource(httpPOST, '/people')]\n    function SendPerson([Body] ABody: TPerson): TPerson;\n\n    [RESTResource(HttpGet, '/people')]\n    function GetPersonInJSONArray: TJSONArray;\n\n    [Headers('Accept', 'application/json')]\n    [Headers('ContentType', 'application/json')]\n    [RESTResource(HttpGet, '/adapter/testconsumejson')]\n    function HeadersApplicationJSON: TJsonBaseObject;\n\n    [Headers('Accept', 'text/plain')]\n    [Headers('ContentType', 'text/plain')]\n    [RESTResource(HttpGet, '/testconsumes')]\n    function HeadersTextPlain: string;\n\n    [Headers('Accept', 'text/plain')]\n    [Headers('ContentType', 'text/plain')]\n    [RESTResource(HttpGet, '/adapter/testconsumejson')]\n    function ApplicationJSONWithTextPlainHeader: IMVCRESTResponse;\n\n  end;\n\n  [TestFixture]\n  TTestRESTAdapter = class(TObject)\n  private\n    RESTAdapter: TRESTAdapter<ITESTService>;\n    TESTService: ITESTService;\n  public\n    [SetUp]\n    procedure SetUp;\n    [Test]\n    procedure TestGetPeople;\n    [Test]\n    procedure TestGetPeopleAsynch;\n    [Test]\n    procedure TestGetTonyStark;\n    [Test]\n    procedure TestGetTonyStarkAsynch;\n    [Test]\n    procedure TestPostPerson;\n    [Test]\n    procedure TestGetPersonByID;\n    [Test]\n    procedure TestHeadersApplicationJSON;\n    [Test]\n    procedure TestHeadersTextPlain;\n    [Test]\n    procedure TestApplicationJSONWithHeaderTextPlain;\n    [Test]\n    procedure TestGetPersonInJSONArray;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.Rtti,\n  System.SyncObjs,\n  LiveServerTestU,\n  TestConstsU;\n\n{ TTestRESTAdapter }\n\nprocedure TTestRESTAdapter.SetUp;\nbegin\n  inherited;\n  RESTAdapter := TRESTAdapter<ITESTService>.Create;\n  TESTService := RESTAdapter.Build(TEST_SERVER_ADDRESS, 8888);\nend;\n\nprocedure TTestRESTAdapter.TestGetPersonByID;\nvar\n  Person: TPerson;\nbegin;\n  Person := TESTService.GetPersonByID(1);\n  try\n    Assert.AreEqual('Tony', Person.FirstName);\n    Assert.AreEqual('Stark', Person.LastName);\n    Assert.isTrue(Person.Married);\n  finally\n    Person.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetPersonInJSONArray;\nvar\n  JSONArray: TJSONArray;\nbegin\n  JSONArray := TESTService.GetPersonInJSONArray;\n  try\n    Assert.isTrue(JSONArray.ToString.Contains('Tony'));\n    Assert.isTrue(JSONArray.ToString.Contains('Stark'));\n    Assert.isTrue(JSONArray.ToString.Contains('Bruce'));\n    Assert.isTrue(JSONArray.ToString.Contains('Banner'));\n  finally\n    JSONArray.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetTonyStark;\nvar\n  Person: TPerson;\nbegin;\n  Person := TESTService.GetTonyStark;\n  try\n    Assert.AreEqual('Tony', Person.FirstName);\n    Assert.AreEqual('Stark', Person.LastName);\n    Assert.isTrue(Person.Married);\n  finally\n    Person.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetTonyStarkAsynch;\nvar\n  AsynchRequest: IAsynchRequest;\n  Person: TPerson;\n  LEvt: TEvent;\nbegin\n  LEvt := TEvent.Create;\n  try\n    AsynchRequest := TAsynchRequest.Create(\n      procedure(AValue: TValue)\n      begin\n        Person := AValue.AsType<TPerson>;\n        LEvt.SetEvent;\n      end);\n    TESTService.GetTonyStarkAsynch(AsynchRequest);\n    // attend for max 5 seconds\n    Assert.isTrue(TWaitResult.wrSignaled = LEvt.WaitFor(5000), 'Timeout request');\n    Assert.IsNotNull(Person);\n    try\n      Assert.AreEqual('Tony', Person.FirstName);\n      Assert.AreEqual('Stark', Person.LastName);\n      Assert.isTrue(Person.Married);\n    finally\n      Person.Free;\n    end;\n  finally\n    LEvt.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestHeadersApplicationJSON;\nvar\n  Res: TJSONObject;\nbegin\n  Res := TESTService.HeadersApplicationJSON as TJSONObject;\n  try\n    Assert.AreEqual('Hello World', Res.S['key']);\n  finally\n    Res.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestHeadersTextPlain;\nvar\n  Res: string;\nbegin\n  Res := TESTService.HeadersTextPlain;\n  Assert.AreEqual('Hello World', Res);\nend;\n\nprocedure TTestRESTAdapter.TestPostPerson;\nvar\n  Person: TPerson;\n  RetPerson: TPerson;\nbegin\n  Person := TPerson.GetNew('Peter', 'Parker', 0, false);\n  RetPerson := TESTService.SendPerson(Person);\n  try\n    Assert.AreEqual('Peter', RetPerson.FirstName);\n    Assert.AreEqual('Parker', RetPerson.LastName);\n    Assert.IsFalse(RetPerson.Married);\n  finally\n    RetPerson.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestApplicationJSONWithHeaderTextPlain;\nvar\n  Resp: IMVCRESTResponse;\nbegin\n  // expected 404 because is not consumed text/plain\n  Resp := TESTService.ApplicationJSONWithTextPlainHeader;\n  Assert.AreEqual<Integer>(404, Resp.StatusCode);\nend;\n\nprocedure TTestRESTAdapter.TestGetPeople;\nvar\n  ListPerson: TObjectList<TPerson>;\nbegin\n  ListPerson := TESTService.GetPeople;\n  try\n    ListPerson.OwnsObjects := True;\n    Assert.isTrue(ListPerson.Count > 0);\n    Assert.AreEqual('Tony', ListPerson[0].FirstName);\n    Assert.AreEqual('Stark', ListPerson[0].LastName);\n  finally\n    ListPerson.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetPeopleAsynch;\nvar\n  AsynchRequest: IAsynchRequest;\n  People: TPeople;\n  LEvt: TEvent;\nbegin\n  LEvt := TEvent.Create;\n  try\n    AsynchRequest := TAsynchRequest.Create(\n      procedure(AValue: TValue)\n      begin\n        People := AValue.AsType<TPeople>;\n        LEvt.SetEvent;\n      end);\n    TESTService.GetPeopleAsynch(AsynchRequest);\n\n    // wait for max 5 seconds\n    Assert.isTrue(TWaitResult.wrSignaled = LEvt.WaitFor(5000), 'Timeout request');\n    Assert.IsNotNull(People);\n    try\n      People.OwnsObjects := True;\n      Assert.isTrue(People.Count > 0);\n      Assert.AreEqual('Tony', People[0].FirstName);\n      Assert.AreEqual('Stark', People[0].LastName);\n    finally\n      People.Free;\n    end;\n  finally\n    LEvt.Free;\n  end;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestRESTAdapter);\n\nfinalization\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing NUnit.Framework;\nusing MVCFramework.RESTAdapter;\nusing MVCFramework.RESTClient.Intf;\nusing MVCFramework.Commons;\nusing JsonDataObjects;\nusing BusinessObjectsU;\n\nnamespace REST\n{\n    [Headers(\"User-Agent\", \"RESTAdapter-Test\")]\n    public interface ITestService : IInvokable\n    {\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        [MVCListOf(typeof(TPerson))]\n        List<TPerson> GetPeople();\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        [MVCListOf(typeof(TPerson))]\n        [Mapping(typeof(TPeople))]\n        void GetPeopleAsynch(IAsynchRequest asynchRequest);\n        [RESTResource(HttpMethod.Get, \"/people/1\")]\n        TPerson GetTonyStark();\n        [RESTResource(HttpMethod.Get, \"/people/1\")]\n        [Mapping(typeof(TPerson))]\n        void GetTonyStarkAsynch(IAsynchRequest asynchRequest);\n        [RESTResource(HttpMethod.Get, \"/people/{personid}\")]\n        TPerson GetPersonByID([Param(\"personid\")] int personId);\n        [RESTResource(HttpMethod.Post, \"/people\")]\n        TPerson SendPerson([Body] TPerson body);\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        TJSONArray GetPersonInJSONArray();\n        [Headers(\"Accept\", \"application/json\")]\n        [Headers(\"ContentType\", \"application/json\")]\n        [RESTResource(HttpMethod.Get, \"/adapter/testconsumejson\")]\n        TJsonBaseObject HeadersApplicationJSON();\n        [Headers(\"Accept\", \"text/plain\")]\n        [Headers(\"ContentType\", \"text/plain\")]\n        [RESTResource(HttpMethod.Get, \"/testconsumes\")]\n        string HeadersTextPlain();\n        [Headers(\"Accept\", \"text/plain\")]\n        [Headers(\"ContentType\", \"text/plain\")]\n        [RESTResource(HttpMethod.Get, \"/adapter/testconsumejson\")]\n        IMVCRESTResponse ApplicationJSONWithTextPlainHeader();\n    }\n\n    [TestFixture]\n    public class TestRESTAdapter\n    {\n        private TRESTAdapter<ITestService> restAdapter;\n        private ITestService testService;\n\n        [SetUp]\n        public void SetUp()\n        {\n            restAdapter = new TRESTAdapter<ITestService>();\n            testService = restAdapter.Build(TestConsts.TEST_SERVER_ADDRESS, 8888);\n        }\n\n        [Test]\n        public void TestGetPeople()\n        {\n            List<TPerson> listPerson = testService.GetPeople();\n            Assert.IsTrue(listPerson.Count > 0);\n            Assert.AreEqual(\"Tony\", listPerson[0].FirstName);\n            Assert.AreEqual(\"Stark\", listPerson[0].LastName);\n        }\n\n        [Test]\n        public void TestGetPeopleAsynch()\n        {\n            var evt = new EventWaitHandle(false, EventResetMode.AutoReset);\n            TPeople people = null;\n            IAsynchRequest asynchRequest = new TAsynchRequest(value => { people = value.AsType<TPeople>(); evt.Set(); });\n            testService.GetPeopleAsynch(asynchRequest);\n            Assert.IsTrue(evt.WaitOne(5000));\n            Assert.IsNotNull(people);\n            people.OwnsObjects = true;\n            Assert.IsTrue(people.Count > 0);\n            Assert.AreEqual(\"Tony\", people[0].FirstName);\n            Assert.AreEqual(\"Stark\", people[0].LastName);\n        }\n\n        [Test]\n        public void TestGetTonyStark()\n        {\n            TPerson person = testService.GetTonyStark();\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestGetTonyStarkAsynch()\n        {\n            var evt = new EventWaitHandle(false, EventResetMode.AutoReset);\n            TPerson person = null;\n            IAsynchRequest asynchRequest = new TAsynchRequest(value => { person = value.AsType<TPerson>(); evt.Set(); });\n            testService.GetTonyStarkAsynch(asynchRequest);\n            Assert.IsTrue(evt.WaitOne(5000));\n            Assert.IsNotNull(person);\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestPostPerson()\n        {\n            TPerson person = TPerson.GetNew(\"Peter\", \"Parker\", 0, false);\n            TPerson retPerson = testService.SendPerson(person);\n            Assert.AreEqual(\"Peter\", retPerson.FirstName);\n            Assert.AreEqual(\"Parker\", retPerson.LastName);\n            Assert.IsFalse(retPerson.Married);\n        }\n\n        [Test]\n        public void TestGetPersonByID()\n        {\n            TPerson person = testService.GetPersonByID(1);\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestHeadersApplicationJSON()\n        {\n            TJSONObject res = testService.HeadersApplicationJSON() as TJSONObject;\n            Assert.AreEqual(\"Hello World\", res.S[\"key\"]);\n        }\n\n        [Test]\n        public void TestHeadersTextPlain()\n        {\n            string res = testService.HeadersTextPlain();\n            Assert.AreEqual(\"Hello World\", res);\n        }\n\n        [Test]\n        public void TestApplicationJSONWithHeaderTextPlain()\n        {\n            IMVCRESTResponse resp = testService.ApplicationJSONWithTextPlainHeader();\n            Assert.AreEqual(404, resp.StatusCode);\n        }\n\n        [Test]\n        public void TestGetPersonInJSONArray()\n        {\n            TJSONArray jsonArray = testService.GetPersonInJSONArray();\n            string jsonStr = jsonArray.ToString();\n            Assert.IsTrue(jsonStr.Contains(\"Tony\"));\n            Assert.IsTrue(jsonStr.Contains(\"Stark\"));\n            Assert.IsTrue(jsonStr.Contains(\"Bruce\"));\n            Assert.IsTrue(jsonStr.Contains(\"Banner\"));\n        }\n    }\n}"}
{"input": "unit StandaloneServerTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  System.Classes,\n  System.SysUtils,\n  System.Generics.Collections,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Server,\n  MVCFramework.Server.Impl;\n\ntype\n\n  [MVCPath('/')]\n  TTestController = class(TMVCController)\n  public\n    [MVCPath('/hello')]\n    [MVCHTTPMethod([httpGET])]\n    procedure HelloWorld(ctx: TWebContext);\n  end;\n\n  [TestFixture]\n  TTestServerContainer = class(TObject)\n  protected\n    [SetUp]\n    procedure SetUp;\n    [TearDown]\n    procedure TearDown;\n  public\n    [Test]\n    procedure TestListener;\n    [Test]\n    procedure TestListenerContext;\n    [Test]\n    procedure TestServerListenerAndClient;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.RESTClient,\n  MVCFramework.RESTClient.Intf,\n  StandAloneServerWebModuleTest;\n\n{ TTestServerContainer }\n\nprocedure TTestServerContainer.SetUp;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerContainer.TearDown;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerContainer.TestListener;\nvar\n  lListener: IMVCListener;\nbegin\n  lListener := TMVCListener.Create(TMVCListenerProperties.New.SetName('Listener1').SetPort(5000).SetMaxConnections(512)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  Assert.IsTrue(Assigned(lListener));\n\n  lListener.Start;\n  Assert.IsTrue(lListener.Active);\n\n  lListener.Stop;\n  Assert.IsFalse(lListener.Active);\nend;\n\nprocedure TTestServerContainer.TestServerListenerAndClient;\nvar\n  lListener: IMVCListener;\n  LClient: IMVCRESTClient;\nbegin\n  lListener := TMVCListener.Create(TMVCListenerProperties.New.SetName('Listener1').SetPort(6000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  Assert.IsTrue(Assigned(lListener));\n\n  lListener.Start;\n  Assert.IsTrue(lListener.Active);\n\n  LClient := TMVCRESTClient.New.BaseURL('localhost', 6000);\n  LClient.SetBasicAuthorization('dmvc', '123');\n  Assert.AreEqual('Hello World called with GET', LClient.Get('/hello').Content);\n\n  lListener.Stop;\n  Assert.IsFalse(lListener.Active);\nend;\n\nprocedure TTestServerContainer.TestListenerContext;\nvar\n  LListenerCtx: IMVCListenersContext;\nbegin\n  LListenerCtx := TMVCListenersContext.Create;\n\n  LListenerCtx.Add(TMVCListenerProperties.New.SetName('Listener2').SetPort(6000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  LListenerCtx.Add(TMVCListenerProperties.New.SetName('Listener3').SetPort(7000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass2));\n\n  Assert.IsTrue(Assigned(LListenerCtx.FindByName('Listener2')));\n  Assert.IsTrue(Assigned(LListenerCtx.FindByName('Listener3')));\n\n  LListenerCtx.StartAll;\n\n  Assert.IsTrue(LListenerCtx.Count = 2);\n  Assert.IsTrue(LListenerCtx.FindByName('Listener2').Active);\n  Assert.IsTrue(LListenerCtx.FindByName('Listener3').Active);\n\n  LListenerCtx.StopAll;\n\n  Assert.IsFalse(LListenerCtx.FindByName('Listener2').Active);\n  Assert.IsFalse(LListenerCtx.FindByName('Listener3').Active);\n\n  LListenerCtx.Remove('Listener2').Remove('Listener3');\n\n  Assert.IsTrue(LListenerCtx.Count = 0);\nend;\n\n{ TTestController }\n\nprocedure TTestController.HelloWorld(ctx: TWebContext);\nbegin\n  Render('Hello World called with GET');\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestServerContainer);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Server;\nusing MVCFramework.Server.Impl;\nusing MVCFramework.RESTClient;\nusing MVCFramework.RESTClient.Intf;\nusing NUnit.Framework;\nusing StandAloneServerWebModuleTest;\n\nnamespace StandaloneServerTest\n{\n    [Route(\"/\")]\n    public class TestController : MVCController\n    {\n        [Route(\"hello\")]\n        [HttpGet]\n        public void HelloWorld(WebContext ctx)\n        {\n            Render(\"Hello World called with GET\");\n        }\n    }\n\n    [TestFixture]\n    public class TestServerContainer\n    {\n        [SetUp]\n        public void SetUp() { }\n        [TearDown]\n        public void TearDown() { }\n\n        [Test]\n        public void TestListener()\n        {\n            IMVCListener listener = MVCListener.Create(\n                MVCListenerProperties.New()\n                .SetName(\"Listener1\")\n                .SetPort(5000)\n                .SetMaxConnections(512)\n                .SetWebModuleClass(TestWebModuleClass));\n            Assert.IsNotNull(listener);\n            listener.Start();\n            Assert.IsTrue(listener.Active);\n            listener.Stop();\n            Assert.IsFalse(listener.Active);\n        }\n\n        [Test]\n        public void TestServerListenerAndClient()\n        {\n            IMVCListener listener = MVCListener.Create(\n                MVCListenerProperties.New()\n                .SetName(\"Listener1\")\n                .SetPort(6000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass));\n            Assert.IsNotNull(listener);\n            listener.Start();\n            Assert.IsTrue(listener.Active);\n            IMVCRESTClient client = RESTClient.New().BaseURL(\"localhost\", 6000);\n            client.SetBasicAuthorization(\"dmvc\", \"123\");\n            Assert.AreEqual(\"Hello World called with GET\", client.Get(\"/hello\").Content);\n            listener.Stop();\n            Assert.IsFalse(listener.Active);\n        }\n\n        [Test]\n        public void TestListenerContext()\n        {\n            IMVCListenersContext listenerContext = MVCListenersContext.Create();\n            listenerContext.Add(\n                MVCListenerProperties.New()\n                .SetName(\"Listener2\")\n                .SetPort(6000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass));\n            listenerContext.Add(\n                MVCListenerProperties.New()\n                .SetName(\"Listener3\")\n                .SetPort(7000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass2));\n            Assert.IsNotNull(listenerContext.FindByName(\"Listener2\"));\n            Assert.IsNotNull(listenerContext.FindByName(\"Listener3\"));\n            listenerContext.StartAll();\n            Assert.AreEqual(2, listenerContext.Count);\n            Assert.IsTrue(listenerContext.FindByName(\"Listener2\").Active);\n            Assert.IsTrue(listenerContext.FindByName(\"Listener3\").Active);\n            listenerContext.StopAll();\n            Assert.IsFalse(listenerContext.FindByName(\"Listener2\").Active);\n            Assert.IsFalse(listenerContext.FindByName(\"Listener3\").Active);\n            listenerContext.Remove(\"Listener2\").Remove(\"Listener3\");\n            Assert.AreEqual(0, listenerContext.Count);\n        }\n    }\n}"}
{"input": "unit ControllersU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Swagger.Commons,\n  BaseControllerU,\n  EntitiesU;\n\ntype\n  [MVCPath('/mypeople')]\n  [MVCSWAGDefaultModel(TPersonModel, 'MyPerson', 'MyPeople')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('MyPeople')] {commenting this line you get an exception}\n  TMyPeopleController = class(TBaseController<TPerson, TPersonRec>)\n  end;\n\n\n  [MVCPath('/people')]\n  [MVCSWAGDefaultModel(TPersonModel, 'Person', 'People')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('People')] {commenting this line you get an exception}\n  TPeopleController = class(TBaseController<TPerson, TPersonRec>)\n  public\n    {this action is defined only in the child controller but uses the \"DefaultModel\"}\n    [MVCPath('/all2')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all ' + TSwaggerConst.PLURAL_MODEL_NAME +\n      ' (using route /all2, with model specified in controller)',\n      'getAll2' + TSwaggerConst.PLURAL_MODEL_NAME)]\n    [MVCSwagResponses(200, 'Success', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll2; virtual;\n\n    {this action is defined only in the child controller but doesn't use the \"DefaultModel\"}\n    [MVCPath('/all3')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all PersonWithNickNameModel (using route /all3, custom model specified on action)',\n      'getAllPeopleWithNickName')]\n    [MVCSwagResponses(200, 'Success', TPersonWithNickNameModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll3; virtual;\n  end;\n\n\n  [MVCPath('/tallpeople')]\n  [MVCPath('/tallpeoplexxx')]\n  [MVCSWAGDefaultModel(TTallPersonModel, 'TallPerson', 'TallPeople')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('Tall People')] {commenting this line you get an exception}\n  TTallPeopleController = class(TPeopleController)\n  public\n    {this action is defined only in the child controller but uses the \"DefaultModel\"}\n    [MVCPath('/all2')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all ' + TSwaggerConst.PLURAL_MODEL_NAME +\n      ' (child controller, default controller model)', 'getAll2' + TSwaggerConst.PLURAL_MODEL_NAME)]\n    [MVCSwagResponses(200, 'Success', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll2; override;\n\n    [MVCPath('/all3')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'List all PersonWithNickNameModel', 'getAllPersonWithNickNameModel')]\n    [MVCSwagResponses(200, 'Success', TPersonWithNickNameModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll3; override;\n  end;\n\nimplementation\n\nuses\n  JsonDataObjects,\n  System.SysUtils,\n  System.DateUtils,\n  MVCFramework.Controllers.Register;\n\n{ TPeopleController }\n\nprocedure TPeopleController.GetAll2;\nbegin\n\nend;\n\nprocedure TPeopleController.GetAll3;\nbegin\n\nend;\n\n{ TTallPeopleController }\n\nprocedure TTallPeopleController.GetAll2;\nbegin\n  inherited;\n\nend;\n//\nprocedure TTallPeopleController.GetAll3;\nbegin\n  inherited;\n\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Controllers.Base;    \nusing EntitiesU;          \nusing System;\n\npublic static class TSwaggerConst\n{\n    public const string USE_DEFAULT_SUMMARY_TAGS = \"USE_DEFAULT_SUMMARY_TAGS\";\n    public const string PLURAL_MODEL_NAME = \"People\"; \n}\n\npublic class SWAGUseDefaultControllerModel { }\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class MVCSwagDefaultModelAttribute : Attribute\n{\n    public Type ModelType { get; }\n    public string SingularName { get; }\n    public string PluralName { get; }\n    public MVCSwagDefaultModelAttribute(Type modelType, string singularName, string pluralName)\n    {\n        ModelType = modelType;\n        SingularName = singularName;\n        PluralName = pluralName;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class MVCSwagDefaultSummaryTagsAttribute : Attribute\n{\n    public string Tags { get; }\n    public MVCSwagDefaultSummaryTagsAttribute(string tags)\n    {\n        Tags = tags;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\npublic class MVCSwagSummaryAttribute : Attribute\n{\n    public string UseDefaultSummaryTags { get; }\n    public string Description { get; }\n    public string OperationId { get; }\n    public MVCSwagSummaryAttribute(string useDefaultSummaryTags, string description, string operationId)\n    {\n        UseDefaultSummaryTags = useDefaultSummaryTags;\n        Description = description;\n        OperationId = operationId;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\npublic class MVCSwagResponsesAttribute : Attribute\n{\n    public int StatusCode { get; }\n    public string Description { get; }\n    public object ResponseModel { get; }\n    public bool UseDefault { get; }\n    public MVCSwagResponsesAttribute(int statusCode, string description)\n    {\n        StatusCode = statusCode;\n        Description = description;\n    }\n    public MVCSwagResponsesAttribute(int statusCode, string description, object responseModel, bool useDefault)\n    {\n        StatusCode = statusCode;\n        Description = description;\n        ResponseModel = responseModel;\n        UseDefault = useDefault;\n    }\n}\n\nnamespace ControllersU\n{\n    \n    [Route(\"mypeople\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(PersonModel), \"MyPerson\", \"MyPeople\")]\n    [MVCSwagDefaultSummaryTags(\"MyPeople\")]\n    public class MyPeopleController : BaseController<TPerson, TPersonRec>\n    {\n        // No additional actions are defined.\n    }\n\n    \n    [Route(\"people\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(PersonModel), \"Person\", \"People\")]\n    [MVCSwagDefaultSummaryTags(\"People\")]\n    public class PeopleController : BaseController<TPerson, TPersonRec>\n    {\n        \n        [HttpGet(\"all2\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all \" + TSwaggerConst.PLURAL_MODEL_NAME + \" (using route /all2, with model specified in controller)\",\n            \"getAll2\" + TSwaggerConst.PLURAL_MODEL_NAME)]\n        [MVCSwagResponses(200, \"Success\", typeof(SWAGUseDefaultControllerModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public virtual IActionResult GetAll2()\n        {\n            \n            return Ok();\n        }\n\n        \n        [HttpGet(\"all3\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all PersonWithNickNameModel (using route /all3, custom model specified on action)\",\n            \"getAllPeopleWithNickName\")]\n        [MVCSwagResponses(200, \"Success\", typeof(PersonWithNickNameModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public virtual IActionResult GetAll3()\n        {\n            \n            return Ok();\n        }\n    }\n\n    \n    [Route(\"tallpeople\")]\n    [Route(\"tallpeoplexxx\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(TallPersonModel), \"TallPerson\", \"TallPeople\")]\n    [MVCSwagDefaultSummaryTags(\"Tall People\")]\n    public class TallPeopleController : PeopleController\n    {\n        \n        [HttpGet(\"all2\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all \" + TSwaggerConst.PLURAL_MODEL_NAME + \" (child controller, default controller model)\",\n            \"getAll2\" + TSwaggerConst.PLURAL_MODEL_NAME)]\n        [MVCSwagResponses(200, \"Success\", typeof(SWAGUseDefaultControllerModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public override IActionResult GetAll2()\n        {\n            \n            return base.GetAll2();\n        }\n\n        \n        [HttpGet(\"all3\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all PersonWithNickNameModel\", \"getAllPersonWithNickNameModel\")]\n        [MVCSwagResponses(200, \"Success\", typeof(PersonWithNickNameModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public override IActionResult GetAll3()\n        {\n            \n            return base.GetAll3();\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Json.Schema.Field.DateTimes;\n\ninterface\n\nuses\n  System.Json,\n  Json.Schema.Field,\n  Json.Schema.Common.Types;\n\ntype\n  [ASchemaType(skDateTime)]\n  TJsonFieldDateTime = class(TJsonField)\n  strict protected\n    const c_DateFormat = 'yyyy-MM-dd';\n    const c_TimeFormat = 'HH:mm:ss';\n    const c_DateTimeFormat = c_DateFormat + 'T' + c_TimeFormat;\n\n    function GetFormat: string; virtual;\n  public\n    function ToJsonSchema: TJsonObject; override;\n    property Format: string read GetFormat;\n  end;\n\n  [ASchemaType(skDate)]\n  TJsonFieldDate = class(TJsonFieldDateTime)\n  strict protected\n    function GetFormat: string; override;\n  end;\n\n  [ASchemaType(skTime)]\n  TJsonFieldTime = class(TJsonFieldDateTime)\n  strict protected\n    function GetFormat: string; override;\n  end;\n\nimplementation\n\nuses\n  System.Classes;\n\n{ TJsonFieldDateTime }\n\nfunction TJsonFieldDateTime.GetFormat: string;\nbegin\n  Result := c_DateTimeFormat;\nend;\n\nfunction TJsonFieldDateTime.ToJsonSchema: TJsonObject;\nbegin\n  Result := inherited ToJsonSchema;\n  Result.AddPair('format', GetFormat);\nend;\n\n{ TJsonFieldDate }\n\nfunction TJsonFieldDate.GetFormat: string;\nbegin\n  Result := c_DateFormat;\nend;\n\n{ TJsonFieldTime }\n\nfunction TJsonFieldTime.GetFormat: string;\nbegin\n  Result := c_TimeFormat;\nend;\n\ninitialization\n  RegisterClass(TJsonFieldDateTime);\n  RegisterClass(TJsonFieldDate);\n  RegisterClass(TJsonFieldTime);\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\nusing Json.Schema.Common.Types;\n\nnamespace Json.Schema.Field.DateTimes\n{\n    \n    public abstract class JsonField\n    {\n        \n        public virtual JObject ToJsonSchema()\n        {\n            return new JObject\n            {\n                // Other common schema properties can be added here.\n            };\n        }\n    }\n\n    [SchemaType(SchemaKind.DateTime)]\n    public class JsonFieldDateTime : JsonField\n    {\n        protected const string DateFormat = \"yyyy-MM-dd\";\n        protected const string TimeFormat = \"HH:mm:ss\";\n        protected const string DateTimeFormat = DateFormat + \"T\" + TimeFormat;\n\n        \n        protected virtual string GetFormat()\n        {\n            return DateTimeFormat;\n        }\n\n        public override JObject ToJsonSchema()\n        {\n            var schema = base.ToJsonSchema();\n            schema[\"format\"] = GetFormat();\n            return schema;\n        }\n\n        \n        public string Format => GetFormat();\n    }\n\n    [SchemaType(SchemaKind.Date)]\n    public class JsonFieldDate : JsonFieldDateTime\n    {\n        \n        protected override string GetFormat()\n        {\n            return DateFormat;\n        }\n    }\n\n    [SchemaType(SchemaKind.Time)]\n    public class JsonFieldTime : JsonFieldDateTime\n    {\n        \n        protected override string GetFormat()\n        {\n            return TimeFormat;\n        }\n    }\n\n    \n    public static class JsonFieldRegistration\n    {\n        static JsonFieldRegistration()\n        {\n           \n            // SchemaRegistry.Register(typeof(JsonFieldDateTime));\n            // SchemaRegistry.Register(typeof(JsonFieldDate));\n            // SchemaRegistry.Register(typeof(JsonFieldTime));\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit InjectorTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework, MVCFramework.Container,\n  MVCFramework.Serializer.JsonDataObjects;\n\ntype\n\n  [TestFixture]\n  TTestContainer = class\n  public\n    [Test]\n    procedure TestNotBuiltContainer;\n    [Test]\n    procedure TestUnknownService;\n    [Test]\n    procedure TestTransient;\n    [Test]\n    procedure TestTransientWithDelegate;\n    [Test]\n    procedure TestSingleton;\n    [Test]\n    procedure TestSingletonWithDelegate;\n    [Test]\n    procedure TestSingletonPerRequest;\n    [Test]\n    procedure TestSingletonPerRequestWithDelegate;\n    [Test]\n    procedure TestCascadeConstructorInjection;\n  end;\n\n\n  IServiceA = interface\n    ['{B6C5EAD8-9008-4200-BF33-E3DE5C8A2320}']\n  end;\n\n  IServiceB = interface\n    ['{8418244D-8AEC-4567-A21E-3F4ECD07E227}']\n  end;\n\n  IServiceC = interface\n    ['{A9E5FD77-87FD-4C9C-91BA-79556252DAAD}']\n    function GetServiceA: IServiceA;\n    function GetServiceB: IServiceB;\n  end;\n\n  TServiceA = class(TInterfacedObject, IServiceA)\n\n  end;\n\n  TServiceB = class(TInterfacedObject, IServiceB)\n\n  end;\n\n  TServiceAB = class(TInterfacedObject, IServiceA, IServiceB)\n\n  end;\n\n  TServiceC = class(TInterfacedObject, IServiceC)\n  private\n    fServiceA: IServiceA;\n    fServiceB: IServiceB;\n  protected\n    function GetServiceA: IServiceA;\n    function GetServiceB: IServiceB;\n  public\n    constructor Create(ServiceA: IServiceA; ServiceB: IServiceB);\n  end;\n\nimplementation\n\nuses\n  System.Generics.Collections, MVCFramework.IntfObjectPool, System.SysUtils, System.Classes, SyncObjs,\n  MVCFramework.Serializer.Intf;\n\n{ TTestContainer }\n\nprocedure TTestContainer.TestCascadeConstructorInjection;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  lCont.RegisterType(TServiceB, IServiceB, TRegistrationType.SingletonPerRequest);\n  lCont.RegisterType(TServiceC, IServiceC);\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n\n  // resolve another \"IServiceC\" in the same request - ServiceB is rtSingletonPerRequest\n  var l01 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n  Assert.AreNotEqual(l0.GetServiceA, l01.GetServiceA);\n  Assert.AreEqual(l0.GetServiceB, l01.GetServiceB);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l1 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n  Assert.AreNotEqual(l0.GetServiceA, l1.GetServiceA);\n  Assert.AreNotEqual(l0.GetServiceB, l1.GetServiceB);\nend;\n\nprocedure TTestContainer.TestNotBuiltContainer;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  var lResolver := NewServiceContainerResolver(lCont);\n  Assert.WillRaise(\n    procedure\n    begin\n      var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n    end, EMVCContainerError);\nend;\n\nprocedure TTestContainer.TestSingleton;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Singleton);\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Singleton, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd Request\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd Request\n  lResolver := NewServiceContainerResolver(lCont);\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l11 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l10, l11);\n  Assert.AreEqual(l0, l10);\n  Assert.AreEqual(l1, l11);\nend;\n\nprocedure TTestContainer.TestSingletonPerRequest;\nbegin\n  var lCont := NewMVCServiceContainer\n          .RegisterType(TServiceA, IServiceA, TRegistrationType.SingletonPerRequest)\n          .RegisterType(TServiceA, IServiceA, TRegistrationType.SingletonPerRequest, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l00 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l00, l10);\n  Assert.AreNotEqual(l0, l00);\n  Assert.AreNotEqual(l1, l10);\nend;\n\n\nprocedure TTestContainer.TestSingletonPerRequestWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer\n          .RegisterType(function : TInterfacedObject\n                        begin\n                          Result := TServiceA.Create\n                        end, IServiceA, TRegistrationType.SingletonPerRequest)\n          .RegisterType(function : TInterfacedObject\n                        begin\n                          Result := TServiceA.Create\n                        end, IServiceA, TRegistrationType.SingletonPerRequest, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l00 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l00, l10);\n  Assert.AreNotEqual(l0, l00);\n  Assert.AreNotEqual(l1, l10);\nend;\n\nprocedure TTestContainer.TestSingletonWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Singleton);\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Singleton, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd Request\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd Request\n  lResolver := NewServiceContainerResolver(lCont);\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l11 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l10, l11);\n  Assert.AreEqual(l0, l10);\n  Assert.AreEqual(l1, l11);\nend;\n\nprocedure TTestContainer.TestTransient;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Transient, 'Svc1');\n  lCont.Build;\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreNotEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreNotEqual(l2, l3);\nend;\n\nprocedure TTestContainer.TestTransientWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA);\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Transient, 'Svc1');\n  lCont.Build;\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreNotEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreNotEqual(l2, l3);\nend;\n\nprocedure TTestContainer.TestUnknownService;\nbegin\n  var lCont := NewMVCServiceContainer;\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TServiceA, IServiceB);\n    end, EMVCContainerErrorUnknownService);\n\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TMVCJsonDataObjectsSerializer, IServiceB);\n    end, EMVCContainerErrorUnknownService);\n\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TServiceA, IMVCSerializer);\n    end, EMVCContainerErrorUnknownService);\nend;\n\n{ TServiceC }\n\nconstructor TServiceC.Create(ServiceA: IServiceA; ServiceB: IServiceB);\nbegin\n  inherited Create;\n  fServiceA := ServiceA;\n  fServiceB := ServiceB;\nend;\n\nfunction TServiceC.GetServiceA: IServiceA;\nbegin\n  Result := fServiceA;\nend;\n\nfunction TServiceC.GetServiceB: IServiceB;\nbegin\n  Result := fServiceB;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestContainer);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing NUnit.Framework;\n\nnamespace InjectorTest\n{\n    #region Service Interfaces and Implementations\n\n    public interface IServiceA { }\n    public interface IServiceB { }\n    public interface IServiceC\n    {\n        IServiceA GetServiceA();\n        IServiceB GetServiceB();\n    }\n\n    public class ServiceA : IServiceA\n    {\n        \n    }\n\n    public class ServiceB : IServiceB\n    {\n        \n\n    \n    public class ServiceAB : IServiceA, IServiceB\n    {\n        // Implementation details...\n    }\n\n    public class ServiceC : IServiceC\n    {\n        private readonly IServiceA _serviceA;\n        private readonly IServiceB _serviceB;\n\n        public ServiceC(IServiceA serviceA, IServiceB serviceB)\n        {\n            _serviceA = serviceA;\n            _serviceB = serviceB;\n        }\n\n        public IServiceA GetServiceA() => _serviceA;\n        public IServiceB GetServiceB() => _serviceB;\n    }\n\n    #endregion\n\n    #region Container and Resolver Stubs\n\n    \n    public enum RegistrationType\n    {\n        Transient,\n        Singleton,\n        SingletonPerRequest\n    }\n\n    \n    public class MVCContainerErrorUnknownServiceException : Exception\n    {\n        public MVCContainerErrorUnknownServiceException(string message) : base(message) { }\n    }\n\n        public class MVCServiceContainer\n    {\n        private readonly Dictionary<(Type serviceType, string key), Func<object>> _registrations = new Dictionary<(Type, string), Func<object>>();\n        private bool _built = false;\n\n        \n        public MVCServiceContainer RegisterType<TImplementation, TService>(RegistrationType regType = RegistrationType.Transient, string key = null)\n            where TImplementation : TService, new()\n        {\n            \n            _registrations[(typeof(TService), key ?? string.Empty)] = () => new TImplementation();\n            return this;\n        }\n\n                public MVCServiceContainer RegisterType<TService>(Func<object> factory, RegistrationType regType = RegistrationType.Transient, string key = null)\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = factory;\n            return this;\n        }\n\n        \n        public MVCServiceContainer Build()\n        {\n            _built = true;\n            return this;\n        }\n\n        public bool IsBuilt => _built;\n    }\n\n    \n    public class ServiceContainerResolver\n    {\n        private readonly MVCServiceContainer _container;\n        private readonly Dictionary<(Type serviceType, string key), object> _perRequestInstances = new Dictionary<(Type, string), object>();\n\n        public ServiceContainerResolver(MVCServiceContainer container)\n        {\n            _container = container;\n        }\n\n        \n        public object Resolve(Type serviceType, string key = \"\")\n        {\n            \n            if (_container == null)\n                throw new Exception(\"Container not built\");\n\n            if (!_container.IsBuilt)\n                throw new Exception(\"Container not built\");\n\n            var regKey = (serviceType, key ?? string.Empty);\n            if (_container._registrations.TryGetValue(regKey, out Func<object> factory))\n            {\n                \n                if (key == string.Empty) \n                {\n                    \n                    if (!_perRequestInstances.ContainsKey(regKey))\n                        _perRequestInstances[regKey] = factory();\n                    return _perRequestInstances[regKey];\n                }\n                else\n                {\n                    \n                    if (!_perRequestInstances.ContainsKey(regKey))\n                        _perRequestInstances[regKey] = factory();\n                    return _perRequestInstances[regKey];\n                }\n            }\n            else\n            {\n                throw new MVCContainerErrorUnknownServiceException(\"Unknown service\");\n            }\n        }\n\n        \n        public T Resolve<T>(string key = null) where T : class\n        {\n            return Resolve(typeof(T), key) as T;\n        }\n    }\n\n    #endregion\n\n    [TestFixture]\n    public class TestContainer\n    {\n        \n        [Test]\n        public void TestNotBuiltContainer()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            var resolver = new ServiceContainerResolver(container);\n            Assert.Throws<Exception>(() => resolver.Resolve(typeof(IServiceA)));\n        }\n\n        \n        [Test]\n        public void TestUnknownService()\n        {\n            var container = new MVCServiceContainer();\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IServiceB>(); \n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType(() => new MVCJsonDataObjectsSerializer(), typeof(IServiceB));\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IMVCSerializer>(); \n            });\n        }\n\n        \n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var s1 = resolver.Resolve<IServiceA>();\n            var s2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(s1, s2);\n\n            var s1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(s1a, s2a);\n        }\n\n        \n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var s1 = resolver.Resolve<IServiceA>();\n            var s2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(s1, s2);\n\n            var s1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(s1a, s2a);\n        }\n\n        \n        [Test]\n        public void TestSingleton()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Singleton);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreEqual(a1, b1);\n            Assert.AreEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonPerRequest()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreNotEqual(a1, b1);\n            Assert.AreNotEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonPerRequestWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.SingletonPerRequest);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreNotEqual(a1, b1);\n            Assert.AreNotEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Singleton);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreEqual(a1, b1);\n            Assert.AreEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        \n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        \n        [Test]\n        public void TestCascadeConstructorInjection()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            container.RegisterType<ServiceB, IServiceB>(RegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceC, IServiceC>();\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var serviceC1 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n\n            \n            var serviceC1b = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n            Assert.AreNotEqual(serviceC1.GetServiceA(), serviceC1b.GetServiceA());\n            Assert.AreEqual(serviceC1.GetServiceB(), serviceC1b.GetServiceB());\n\n            \n            resolver1 = new ServiceContainerResolver(container);\n            var serviceC2 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n            Assert.AreNotEqual(serviceC1.GetServiceA(), serviceC2.GetServiceA());\n            Assert.AreNotEqual(serviceC1.GetServiceB(), serviceC2.GetServiceB());\n        }\n    }\n\n    #region Additional Types for Testing\n\n   \n    public class MVCJsonDataObjectsSerializer { }\n\n    public class MVCContainerErrorUnknownServiceException : Exception\n    {\n        public MVCContainerErrorUnknownServiceException(string message) : base(message) { }\n    }\n\n    public interface IMVCSerializer { }\n\n    public enum TRegistrationType\n    {\n        Transient,\n        Singleton,\n        SingletonPerRequest\n    }\n\n    public class MVCServiceContainer\n    {\n        internal readonly Dictionary<(Type, string), Func<object>> _registrations = new Dictionary<(Type, string), Func<object>>();\n        private bool _built = false;\n\n        public MVCServiceContainer RegisterType<TImplementation, TService>(TRegistrationType regType = TRegistrationType.Transient, string key = \"\")\n            where TImplementation : TService, new()\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = () => new TImplementation();\n            return this;\n        }\n\n        public MVCServiceContainer RegisterType<TService>(Func<object> factory, TRegistrationType regType = TRegistrationType.Transient, string key = \"\")\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = factory;\n            return this;\n        }\n\n        public MVCServiceContainer Build()\n        {\n            _built = true;\n            return this;\n        }\n\n        public bool IsBuilt => _built;\n    }\n\n    public class ServiceContainerResolver\n    {\n        private readonly MVCServiceContainer _container;\n        private readonly Dictionary<(Type, string), object> _instances = new Dictionary<(Type, string), object>();\n\n        public ServiceContainerResolver(MVCServiceContainer container)\n        {\n            _container = container;\n        }\n\n        public object Resolve(Type serviceType, string key = \"\")\n        {\n            var regKey = (serviceType, key ?? string.Empty);\n            if (!_container._registrations.ContainsKey(regKey))\n                throw new MVCContainerErrorUnknownServiceException(\"Unknown service\");\n            if (!_instances.ContainsKey(regKey))\n                _instances[regKey] = _container._registrations[regKey]();\n            return _instances[regKey];\n        }\n\n        public T Resolve<T>(string key = null) where T : class\n        {\n            return Resolve(typeof(T), key) as T;\n        }\n    }\n\n    public class ServiceA : IServiceA\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceB : IServiceB\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceAB : IServiceA, IServiceB\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceC : IServiceC\n    {\n        private readonly IServiceA _serviceA;\n        private readonly IServiceB _serviceB;\n        public ServiceC(IServiceA serviceA, IServiceB serviceB)\n        {\n            _serviceA = serviceA;\n            _serviceB = serviceB;\n        }\n\n        public IServiceA GetServiceA() => _serviceA;\n        public IServiceB GetServiceB() => _serviceB;\n    }\n\n    public interface IServiceA { }\n    public interface IServiceB { }\n    public interface IServiceC\n    {\n        IServiceA GetServiceA();\n        IServiceB GetServiceB();\n    }\n\n    #endregion\n\n    [TestFixture]\n    public class TestContainer\n    {\n        [Test]\n        public void TestNotBuiltContainer()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            var resolver = new ServiceContainerResolver(container);\n            Assert.Throws<Exception>(() => resolver.Resolve(typeof(IServiceA)));\n        }\n\n        [Test]\n        public void TestUnknownService()\n        {\n            var container = new MVCServiceContainer();\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IServiceB>();\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType(() => new MVCJsonDataObjectsSerializer(), typeof(IServiceB));\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IMVCSerializer>();\n            });\n        }\n\n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        [Test]\n        public void TestSingleton()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Singleton);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s10 = resolver2.Resolve<IServiceA>();\n            var s11 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s10, s11);\n            Assert.AreEqual(s1, s10);\n            Assert.AreEqual(s2, s11);\n        }\n\n        [Test]\n        public void TestSingletonPerRequest()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s00 = resolver2.Resolve<IServiceA>();\n            var s10 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s00, s10);\n            Assert.AreNotEqual(s1, s00);\n            Assert.AreNotEqual(s2, s10);\n        }\n\n        [Test]\n        public void TestSingletonPerRequestWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.SingletonPerRequest);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s00 = resolver2.Resolve<IServiceA>();\n            var s10 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s00, s10);\n            Assert.AreNotEqual(s1, s00);\n            Assert.AreNotEqual(s2, s10);\n        }\n\n        [Test]\n        public void TestSingletonWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Singleton);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s10 = resolver2.Resolve<IServiceA>();\n            var s11 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s10, s11);\n            Assert.AreEqual(s1, s10);\n            Assert.AreEqual(s2, s11);\n        }\n\n        [Test]\n        public void TestCascadeConstructorInjection()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            container.RegisterType<ServiceB, IServiceB>(TRegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceC, IServiceC>();\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var c1 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c1.GetServiceA());\n            Assert.IsNotNull(c1.GetServiceB());\n\n            var c1b = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c1b.GetServiceA());\n            Assert.IsNotNull(c1b.GetServiceB());\n            Assert.AreNotEqual(c1.GetServiceA(), c1b.GetServiceA());\n            Assert.AreEqual(c1.GetServiceB(), c1b.GetServiceB());\n\n            resolver1 = new ServiceContainerResolver(container);\n            var c2 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c2.GetServiceA());\n            Assert.IsNotNull(c2.GetServiceB());\n            Assert.AreNotEqual(c1.GetServiceA(), c2.GetServiceA());\n            Assert.AreNotEqual(c1.GetServiceB(), c2.GetServiceB());\n        }\n    }\n}"}
{"input": "unit MainWM;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TTMunicipalLibraryWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TTMunicipalLibraryWebModule;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  CustomersControllerU,\n  MVCFramework.Middleware.ActiveRecord,\n  System.IOUtils,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.Compression;\n\nprocedure TTMunicipalLibraryWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      \n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Max Record Count for automatic Entities CRUD\n      Config[TMVCConfigKey.MaxEntitiesRecordCount] := '20';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n      // Max request size in bytes\n      Config[TMVCConfigKey.MaxRequestSize] := IntToStr(TMVCConstants.DEFAULT_MAX_REQUEST_SIZE);\n    end);\n  FMVC.AddController(TCustomersController);\n  // To enable compression (deflate, gzip) just add this middleware as the last one\n  FMVC.AddMiddleware(TMVCActiveRecordMiddleware.Create('activerecorddb'));\n  FMVC.AddMiddleware(TMVCCompressionMiddleware.Create);\nend;\n\nprocedure TTMunicipalLibraryWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.ResponseCompression;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing System;\nusing System.IO;\nusing System.Linq;\n\nnamespace MunicipalLibraryApp\n{\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            \n            builder.Services.AddControllersWithViews();\n\n            \n            builder.Services.AddResponseCompression(options =>\n            {\n                \n                options.EnableForHttps = true;\n                \n                options.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(new[] { \"application/json\" });\n            });\n\n            \n            var app = builder.Build();\n\n           \n            app.UseResponseCompression();\n\n            \n            app.Use(async (context, next) =>\n            {\n               \n                await next.Invoke();\n            });\n\n            \n            var wwwFolder = Path.Combine(Directory.GetCurrentDirectory(), \"www\");\n            if (Directory.Exists(wwwFolder))\n            {\n                app.UseStaticFiles(new StaticFileOptions\n                {\n                    \n                    RequestPath = \"/app\",\n                    FileProvider = new Microsoft.Extensions.FileProviders.PhysicalFileProvider(Path.GetFullPath(wwwFolder))\n                });\n            }\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"Hello from Municipal Library API\");\n\n            \n            Console.WriteLine(\"Municipal Library API is running on the following URLs:\");\n            foreach (var url in app.Urls)\n            {\n                Console.WriteLine(url);\n            }\n            app.Run();\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file: David Moorhouse (info@moorhouse.net.nz)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.HTMX;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, System.Rtti, JsonDataObjects, System.StrUtils;\n\ntype\n  THTMXRequestHeaderType = record\n  public const\n    CurrentUrl = 'HX-Current-URL';\n    HistoryRestoreRequest = 'HX-History-Restore-Request';\n    Prompt = 'HX-Prompt';\n    Request = 'HX-Request';\n    Target = 'HX-Target';\n    TriggerName = 'HX-Trigger-Name';\n    Trigger = 'HX-Trigger';\n    Boosted = 'HX-Boosted';\n    TriggeringEvent = 'Triggering-Event';\n  end;\n\n  ///<summary>Helper class to expose HTMX headers as native functions on WebRequest objects</summary>\n  THTMXRequestHelper = class helper for TMVCWebRequest\n  private\n    function GetHtmxHeader(Header: string): string;\n    function GetHtmxHeaderToBool(Header: string): Boolean;\n    function HasHeader(Header: string): Boolean;\n  public\n    /// <summary>Indicates that the request is triggered by HTMX.</summary>\n    function IsHTMX: Boolean;\n\n    /// <summary>Indicates that the request is via an element using hx-boost.</summary>\n    function HXIsBoosted: Boolean;\n\n    /// <summary>True if the request is for history restoration after a miss in the local history cache</summary>\n    function HXIsHistoryRestoreRequest: Boolean;\n\n    /// <summary>The current URL of the browser.</summary>\n    function HXGetCurrentUrl: string;\n\n    /// <summary>The user response to an hx-prompt.</summary>\n    function HXGetPrompt: string;\n\n    /// <summary>The id of the target element if it exists.</summary>\n    function HXGetTarget: string;\n\n    /// <summary>The id of the triggered element if it exists.</summary>\n    function HXGetTrigger: string;\n\n    /// <summary>The name of the triggered element if it exists.</summary>\n    function HXGetTriggerName: string;\n\n    /// <summary>The value of the header is a JSON serialized</summary>\n    /// <remarks>Requires the event-header extension to be installed and loaded on the page </remarks>\n    /// <see>https://htmx.org/extensions/event-header/ </see>\n    function HXGetTriggeringEvent: TArray<string>;\n\n    /// <summary>The value of the header is a JSON serialized</summary>\n    /// <remarks>Requires the event-header extension to be installed and loaded on the page </remarks>\n    /// <see>https://htmx.org/extensions/event-header/ </see>\n    function HXGetTriggeringEventAsJSON: TJsonObject;\n  end;\n\n  THTMXResponseHeaderType = record\n  public const\n    Location = 'HX-Location';\n    Refresh = 'HX-Refresh';\n    PushURL = 'HX-Push-Url';\n    Redirect = 'HX-Redirect';\n    ReplaceURL = 'HX-Replace-Url';\n    Reselect = 'HX-Reselect';\n    Reswap = 'HX-Reswap';\n    Retarget = 'HX-Retarget';\n    Trigger = 'HX-Trigger';\n    TriggerAfterSettle = 'HX-Trigger-After-Settle';\n    TriggerAfterSwap = 'HX-Trigger-After-Swap';\n  end;\n\n\n  ///<summary>Helper class to expose HTMX options as native functions on WebResponse objects</summary>\n  THTMXResponseHelper = class helper for TMVCWebResponse\n  public type\n    TClientEventType = (etReceived, etSettled, etSwapped);\n    TSwapOption = (soInnerHTML, soOuterHTML, soBeforeBegin, soAfterBegin, soBeforeEnd, soAfterEnd, soDelete, soNone);\n    TShowScrollType = (ssNone, ssShow, ssScroll);\n    TSwapScrollTo = (sstTop, sstBottom);\n  private const\n    ClientEventTypes: array [TClientEventType] of string = (THTMXResponseHeaderType.Trigger,\n      THTMXResponseHeaderType.TriggerAfterSettle, THTMXResponseHeaderType.TriggerAfterSwap);\n    SwapOptions: array [TSwapOption] of string = ('innerHTML', 'outerHTML', 'beforebegin', 'afterbegin', 'beforeend', 'afterend',\n      'delete', 'none');\n    ShowScrollTypes: array [TShowScrollType] of string = ('', 'show', 'scroll');\n    SwapScrollTo: array [TSwapScrollTo] of string = ('top', 'bottom');\n  public\n    /// <summary> Pushes a new url into the browser history history.</summary>\n    /// <remarks>This creates a new history entry, allowing navigation with the browser\ufffds back and forward buttons.\n    /// This is similar to the hx-push-url attribute.\n    /// If present, this header overrides any behavior defined with attributes.</remarks>\n    /// <param name=\"URL\">A URL to be pushed into the location bar.\n    /// This may be relative or absolute, as per history.pushState().\n    /// If omitted, the header will output \"false\", which prevents the browser\ufffds history from being updated.</param>\n    function HXSetPushUrl(URL: string = ''): TMVCWebResponse;\n\n    /// <summary>Replaces the current URL in the browser location history.</summary>\n    /// <remarks>This does not create a new history entry; in effect, it removes the previous current URL from the browser\ufffds history.\n    /// This is similar to the hx-replace-url attribute.\n    /// If present, this header overrides any behavior defined with attributes.</remarks>\n    /// <param name=\"URL\">A URL to replace the current URL in the location bar.\n    /// This may be relative or absolute, as per history.replaceState(), but must have the same origin as the current URL.\n    /// If omitted, the header will output \"false\", which prevents the browser\ufffds current URL from being updated.</param>\n    function HXSetReplaceUrl(URL: string = ''): TMVCWebResponse;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// Check if transition: true works ?\n    function HXSetReswap(Option: TSwapOption): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// <remarks>You can modify the timing of the browser update to synchronize htmx with the timing of CSS transition effects.</remarks>\n    /// <param name=\"SwapDelay\">The amount of time that htmx will wait after receiving a response to swap the content (in milliseconds) default is 0</param>\n    /// <param name=\"SettleDelay\">The amount of time between the swap and the settle logic(in milliseconds) default is 20mS</param>\n    function HXSetReswap(Option: TSwapOption; SwapDelay: Integer; SettleDelay: Integer = 20): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// <remarks>You can modify nature of the browser update to show or scroll to the top or bottom of a target.</remarks>\n    /// <param name=\"Option\">The target for the swap</param>\n    /// <param name=\"ShowScroll\">Whether to set the display to the target, or to scroll to the target</param>\n    /// <param name=\"To\">Either top or bottom</param>\n    /// <param name=\"Selector\">Allows targetting of a different element for scrolling or showing</param>\n    function HXSetReswap(Option: TSwapOption; ShowScroll: TShowScrollType; &To: TSwapScrollTo; Selector: string = '')\n      : TMVCWebResponse; overload;\n\n    /// <summary>A CSS selector that updates the target of the content to a different element on the page</summary>\n    function HXSetRetarget(Selector: string): TMVCWebResponse;\n\n    /// <summary>Allows you to trigger a client side event.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Name\">The name of the javscript event to be triggered</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvent(Name: string; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a collection of client side events.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Names\">A collection of the names of the javscript events to be triggered</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvents(Names: TArray<string>; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a collection of client side events.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"EventsDescriptors\">A JSON object with events descriptors (https://htmx.org/headers/hx-trigger/)</param>\n    function HXTriggerClientEvents(EventsDescriptors: TJSONObject; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a client side event with parameters.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Name\">The name of the javscript event to be triggered</param>\n    /// <param name=\"Params\">An object containing the parameters to be sent to the event</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvent(Name: string; Params: TValue; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>if set to \ufffdtrue\ufffd the client side will do a a full refresh of the page</summary>\n    function HXSetPageRefresh(Refresh: Boolean = true): TMVCWebResponse;\n\n    /// <summary>Allows you to do a client-side redirect that does not do a full page reload</summary>\n    /// <remarks>Instead of changing the page\ufffds location it will act like following a hx-boost link, creating a new history entry,\n    /// issuing an ajax request to the value of the header and pushing the path into history. </remarks>\n    function HXSetLocation(Path: string): TMVCWebResponse; overload;\n\n    /// <summary>Used to do a client-side redirect to a new location</summary>\n    function HXSetRedirect(Path: string): TMVCWebResponse;\n\n    /// <summary>Sends an error response bcack to client.</summary>\n    function HXSetErrorResponse(ErrorCode: Integer; ErrorMessage: string): TMVCWebResponse;\n\n    /// <summary>A CSS selector that allows you to choose which part of the response is used to be swapped in.</summary>\n    /// <remarks> Overrides an existing hx-select on the triggering element</remarks>\n    /// <param name=\"Selector\">A CSS selector </param>\n    function HXSetReSelect(Selector: string): TMVCWebResponse;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Utils, MVCFramework.Serializer.JsonDataObjects, MVCFramework.Serializer.Commons;\n\n{ THTMXRequestHelper }\n\nfunction THTMXRequestHelper.HXGetCurrentUrl: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.CurrentUrl);\nend;\n\nfunction THTMXRequestHelper.GetHtmxHeader(Header: string): string;\nbegin\n  Result := Headers[Header];\nend;\n\nfunction THTMXRequestHelper.GetHtmxHeaderToBool(Header: string): Boolean;\nbegin\n  Result := SameText('true', Headers[Header]);\nend;\n\nfunction THTMXRequestHelper.HXGetPrompt: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Prompt);\nend;\n\nfunction THTMXRequestHelper.HXGetTarget: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Target);\nend;\n\nfunction THTMXRequestHelper.HXGetTrigger: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Trigger);\nend;\n\nfunction THTMXRequestHelper.HXGetTriggeringEvent: TArray<string>;\nbegin\n  Result := nil;\n  if HasHeader(THTMXRequestHeaderType.TriggeringEvent) then\n    Result := GetHtmxHeader(THTMXRequestHeaderType.TriggeringEvent).Split([',']);\nend;\n\nfunction THTMXRequestHelper.HXGetTriggeringEventAsJSON: TJsonObject;\nbegin\n  Result := nil;\n  if HasHeader(THTMXRequestHeaderType.TriggeringEvent) then\n    Result := TJsonBaseObject.Parse(GetHtmxHeader(THTMXRequestHeaderType.TriggeringEvent)) as TJsonObject;\nend;\n\nfunction THTMXRequestHelper.HXGetTriggerName: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.TriggerName);\nend;\n\nfunction THTMXRequestHelper.HasHeader(Header: string): Boolean;\nbegin\n  Result := not Headers[Header].IsEmpty;\nend;\n\nfunction THTMXRequestHelper.HXIsBoosted: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.Boosted);\nend;\n\nfunction THTMXRequestHelper.HXIsHistoryRestoreRequest: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.HistoryRestoreRequest);\nend;\n\nfunction THTMXRequestHelper.IsHTMX: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.Request);\nend;\n\n{ THTMXResponseHelper }\n\nfunction THTMXResponseHelper.HXSetErrorResponse(ErrorCode: Integer; ErrorMessage: string): TMVCWebResponse;\nbegin\n  Self.StatusCode := ErrorCode;\n  Self.Content := '{\"error\":\"' + ErrorMessage + '\"}';\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetLocation(Path: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Location, Path);\n  Result := Self;\n\n  (* todo:\n    This response header can be used to trigger a client side redirection without reloading the whole page. Instead of changing the page\ufffds location it will act like following a hx-boost link, creating a new history entry, issuing an ajax request to the value of the header and pushing the path into history.\n\n    A sample response would be:\n    HX-Location: /test\n    Which would push the client to test as if the user had clicked on <a href=\"/test\" hx-boost=\"true\">\n\n    If you want to redirect to a specific target on the page rather than the default of document.body, you can pass more details along with the event, by using JSON for the value of the header:\n    HX-Location: {\"path\":\"/test2\", \"target\":\"#testdiv\"}\n    Path is required and is url to load the response from. The rest of the data mirrors the ajax api context, which is:\n    source - the source element of the request\n    event - an event that \ufffdtriggered\ufffd the request\n    handler - a callback that will handle the response HTML\n    target - the target to swap the response into\n    swap - how the response will be swapped in relative to the target\n    values - values to submit with the request\n    headers - headers to submit with the request\n  *)\nend;\n\nfunction THTMXResponseHelper.HXSetPageRefresh(Refresh: Boolean): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Refresh, ifthen(Refresh, 'true','false')); //must be lowercase\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetPushUrl(URL: string): TMVCWebResponse;\nbegin\n  if URL.IsEmpty then\n    URL := 'false';\n  SetCustomHeader(THTMXResponseHeaderType.PushURL, URL);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetRedirect(Path: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Redirect, Path);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReplaceUrl(URL: string): TMVCWebResponse;\nbegin\n  if URL.IsEmpty then\n    URL := 'false';\n  SetCustomHeader(THTMXResponseHeaderType.ReplaceURL, URL);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReSelect(Selector: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Reselect, Selector);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption; ShowScroll: TShowScrollType; &To: TSwapScrollTo;\n  Selector: string = ''): TMVCWebResponse;\nvar\n  Modifiers: string;\nbegin\n  if (ShowScroll <> ssNone) then\n  begin\n    Modifiers := Format(' %s', [ShowScrollTypes[ShowScroll]]);\n    if not Selector.IsEmpty then\n      Modifiers := Format('%s:%s', [Modifiers, Selector]);\n    Modifiers := Format('%s:%s', [Modifiers, SwapScrollTo[&To]]);\n  end;\n  SetCustomHeader(THTMXResponseHeaderType.Reswap, SwapOptions[Option] + Modifiers);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption; SwapDelay, SettleDelay: Integer): TMVCWebResponse;\nvar\n  Modifiers: string;\nbegin\n  if SwapDelay > 0 then\n    Modifiers := Format('swap:%dms ', [SwapDelay]);\n  if (SettleDelay > 0) and (SettleDelay <> 20) then\n    Modifiers := Modifiers + Format('settle:%dms', [SettleDelay]);\n  if not Modifiers.IsEmpty then\n    Modifiers := ' ' + Modifiers.Trim;\n  SetCustomHeader(THTMXResponseHeaderType.Reswap, SwapOptions[Option] + Modifiers);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption): TMVCWebResponse;\nbegin\n  // todo: support Focus scroll ?\n  Result := HXSetReswap(Option, 0, 0);\nend;\n\nfunction THTMXResponseHelper.HXSetRetarget(Selector: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Retarget, Selector);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvent(Name: string; After: TClientEventType): TMVCWebResponse;\nbegin\n  Result := HXTriggerClientEvent(Name, TValue.Empty, After);\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvent(Name: string; Params: TValue; After: TClientEventType): TMVCWebResponse;\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lData: TJsonObject;\nbegin\n  if not Params.IsEmpty then\n  begin\n    lData := TJsonObject.Create;\n    lSer := TMVCJsonDataObjectsSerializer.Create;\n    try\n      lSer.TValueToJSONObjectProperty(lData, Name, Params, stdefault, [], []);\n      SetCustomHeader(ClientEventTypes[After], lData.ToJSON);\n    finally\n      lSer.Free;\n      lData.Free;\n    end;\n  end\n  else\n    SetCustomHeader(ClientEventTypes[After], Name);\n\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvents(EventsDescriptors: TJSONObject;\n  After: TClientEventType): TMVCWebResponse;\nbegin\n  if EventsDescriptors = nil then\n  begin\n    Exit(Self);\n  end;\n\n  SetCustomHeader(ClientEventTypes[After], EventsDescriptors.ToJSON(true));\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvents(Names: TArray<string>; After: TClientEventType): TMVCWebResponse;\nvar\n  Value: string;\n  I: Integer;\nbegin\n  if Length(Names) = 0 then\n    Exit(Self);\n\n  Value := Names[0];\n  for I := Low(Names) + 1 to High(Names) do\n    Value := Value + ', ' + Names[I];\n\n  SetCustomHeader(ClientEventTypes[After], Value);\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Globalization;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.HTMX\n{\n    #region Enums\n\n    public enum TClientEventType\n    {\n        Received,\n        Settled,\n        Swapped\n    }\n\n    public enum TSwapOption\n    {\n        InnerHTML,\n        OuterHTML,\n        BeforeBegin,\n        AfterBegin,\n        BeforeEnd,\n        AfterEnd,\n        Delete,\n        None\n    }\n\n    public enum TShowScrollType\n    {\n        None,\n        Show,\n        Scroll\n    }\n\n    public enum TSwapScrollTo\n    {\n        Top,\n        Bottom\n    }\n\n    #endregion\n\n    #region Header Constant Helpers\n\n    public static class HTMXRequestHeaders\n    {\n        public const string CurrentUrl = \"HX-Current-URL\";\n        public const string HistoryRestoreRequest = \"HX-History-Restore-Request\";\n        public const string Prompt = \"HX-Prompt\";\n        public const string Request = \"HX-Request\";\n        public const string Target = \"HX-Target\";\n        public const string TriggerName = \"HX-Trigger-Name\";\n        public const string Trigger = \"HX-Trigger\";\n        public const string Boosted = \"HX-Boosted\";\n        public const string TriggeringEvent = \"Triggering-Event\";\n    }\n\n    public static class HTMXResponseHeaders\n    {\n        public const string Location = \"HX-Location\";\n        public const string Refresh = \"HX-Refresh\";\n        public const string PushURL = \"HX-Push-Url\";\n        public const string Redirect = \"HX-Redirect\";\n        public const string ReplaceURL = \"HX-Replace-Url\";\n        public const string Reselect = \"HX-Reselect\";\n        public const string Reswap = \"HX-Reswap\";\n        public const string Retarget = \"HX-Retarget\";\n        public const string Trigger = \"HX-Trigger\";\n        public const string TriggerAfterSettle = \"HX-Trigger-After-Settle\";\n        public const string TriggerAfterSwap = \"HX-Trigger-After-Swap\";\n    }\n\n    #endregion\n\n    #region WebRequest Extensions\n\n    public static class HTMXRequestExtensions\n    {\n        public static string GetHtmxHeader(this TMVCWebRequest req, string header)\n        {\n            return req.Headers.ContainsKey(header) ? req.Headers[header] : string.Empty;\n        }\n\n        public static bool GetHtmxHeaderToBool(this TMVCWebRequest req, string header)\n        {\n            return string.Equals(req.GetHtmxHeader(header), \"true\", StringComparison.OrdinalIgnoreCase);\n        }\n\n        public static bool HasHeader(this TMVCWebRequest req, string header)\n        {\n            return !string.IsNullOrEmpty(req.GetHtmxHeader(header));\n        }\n\n        public static bool IsHTMX(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.Request);\n        }\n\n        public static bool HXIsBoosted(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.Boosted);\n        }\n\n        public static bool HXIsHistoryRestoreRequest(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.HistoryRestoreRequest);\n        }\n\n        public static string HXGetCurrentUrl(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.CurrentUrl);\n        }\n\n        public static string HXGetPrompt(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Prompt);\n        }\n\n        public static string HXGetTarget(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Target);\n        }\n\n        public static string HXGetTrigger(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Trigger);\n        }\n\n        public static string HXGetTriggerName(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.TriggerName);\n        }\n\n        public static string[] HXGetTriggeringEvent(this TMVCWebRequest req)\n        {\n            if (req.HasHeader(HTMXRequestHeaders.TriggeringEvent))\n            {\n                return req.GetHtmxHeader(HTMXRequestHeaders.TriggeringEvent)\n                          .Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                          .Select(s => s.Trim())\n                          .ToArray();\n            }\n            return new string[0];\n        }\n\n        public static JObject HXGetTriggeringEventAsJSON(this TMVCWebRequest req)\n        {\n            if (req.HasHeader(HTMXRequestHeaders.TriggeringEvent))\n            {\n                return JObject.Parse(req.GetHtmxHeader(HTMXRequestHeaders.TriggeringEvent));\n            }\n            return null;\n        }\n    }\n\n    #endregion\n\n    #region WebResponse Extensions\n\n    public static class HTMXResponseExtensions\n    {\n        private static readonly Dictionary<TClientEventType, string> ClientEventTypes = new Dictionary<TClientEventType, string>\n        {\n            { TClientEventType.Received, HTMXResponseHeaders.Trigger },\n            { TClientEventType.Settled, HTMXResponseHeaders.TriggerAfterSettle },\n            { TClientEventType.Swapped, HTMXResponseHeaders.TriggerAfterSwap }\n        };\n\n        private static readonly Dictionary<TSwapOption, string> SwapOptions = new Dictionary<TSwapOption, string>\n        {\n            { TSwapOption.InnerHTML, \"innerHTML\" },\n            { TSwapOption.OuterHTML, \"outerHTML\" },\n            { TSwapOption.BeforeBegin, \"beforebegin\" },\n            { TSwapOption.AfterBegin, \"afterbegin\" },\n            { TSwapOption.BeforeEnd, \"beforeend\" },\n            { TSwapOption.AfterEnd, \"afterend\" },\n            { TSwapOption.Delete, \"delete\" },\n            { TSwapOption.None, \"none\" }\n        };\n\n        private static readonly Dictionary<TShowScrollType, string> ShowScrollTypes = new Dictionary<TShowScrollType, string>\n        {\n            { TShowScrollType.None, \"\" },\n            { TShowScrollType.Show, \"show\" },\n            { TShowScrollType.Scroll, \"scroll\" }\n        };\n\n        private static readonly Dictionary<TSwapScrollTo, string> SwapScrollTo = new Dictionary<TSwapScrollTo, string>\n        {\n            { TSwapScrollTo.Top, \"top\" },\n            { TSwapScrollTo.Bottom, \"bottom\" }\n        };\n\n        public static TMVCWebResponse HXSetPushUrl(this TMVCWebResponse resp, string URL = \"\")\n        {\n            if (string.IsNullOrEmpty(URL))\n                URL = \"false\";\n            resp.SetCustomHeader(HTMXResponseHeaders.PushURL, URL);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReplaceUrl(this TMVCWebResponse resp, string URL = \"\")\n        {\n            if (string.IsNullOrEmpty(URL))\n                URL = \"false\";\n            resp.SetCustomHeader(HTMXResponseHeaders.ReplaceURL, URL);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option)\n        {\n            return resp.HXSetReswap(option, 0, 0);\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option, int swapDelay, int settleDelay = 20)\n        {\n            string modifiers = \"\";\n            if (swapDelay > 0)\n                modifiers = string.Format(CultureInfo.InvariantCulture, \"swap:{0}ms \", swapDelay);\n            if (settleDelay > 0 && settleDelay != 20)\n                modifiers += string.Format(CultureInfo.InvariantCulture, \"settle:{0}ms\", settleDelay);\n            if (!string.IsNullOrWhiteSpace(modifiers))\n                modifiers = \" \" + modifiers.Trim();\n            resp.SetCustomHeader(HTMXResponseHeaders.Reswap, SwapOptions[option] + modifiers);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option, TShowScrollType showScroll, TSwapScrollTo to, string selector = \"\")\n        {\n            string modifiers = \"\";\n            if (showScroll != TShowScrollType.None)\n            {\n                modifiers = ShowScrollTypes[showScroll];\n                if (!string.IsNullOrEmpty(selector))\n                    modifiers = $\"{modifiers}:{selector}\";\n                modifiers = $\"{modifiers}:{SwapScrollTo[to]}\";\n            }\n            resp.SetCustomHeader(HTMXResponseHeaders.Reswap, SwapOptions[option] + (string.IsNullOrEmpty(modifiers) ? \"\" : \" \" + modifiers));\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetRetarget(this TMVCWebResponse resp, string selector)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Retarget, selector);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvent(this TMVCWebResponse resp, string name, TClientEventType after = TClientEventType.Received)\n        {\n            return resp.HXTriggerClientEvent(name, null, after);\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvent(this TMVCWebResponse resp, string name, object parameters, TClientEventType after = TClientEventType.Received)\n        {\n            if (parameters != null)\n            {\n                var dict = new Dictionary<string, object> { { name, parameters } };\n                string json = Newtonsoft.Json.JsonConvert.SerializeObject(dict);\n                resp.SetCustomHeader(ClientEventTypes[after], json);\n            }\n            else\n            {\n                resp.SetCustomHeader(ClientEventTypes[after], name);\n            }\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvents(this TMVCWebResponse resp, string[] names, TClientEventType after = TClientEventType.Received)\n        {\n            if (names == null || names.Length == 0)\n                return resp;\n            string value = string.Join(\", \", names);\n            resp.SetCustomHeader(ClientEventTypes[after], value);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvents(this TMVCWebResponse resp, JObject eventsDescriptors, TClientEventType after = TClientEventType.Received)\n        {\n            if (eventsDescriptors == null)\n                return resp;\n            resp.SetCustomHeader(ClientEventTypes[after], eventsDescriptors.ToString());\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetPageRefresh(this TMVCWebResponse resp, bool refresh = true)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Refresh, refresh ? \"true\" : \"false\");\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetRedirect(this TMVCWebResponse resp, string path)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Redirect, path);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetLocation(this TMVCWebResponse resp, string path)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Location, path);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReSelect(this TMVCWebResponse resp, string selector)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Reselect, selector);\n            return resp;\n        }\n    }\n\n    #endregion\n\n    #region Stub MVCFramework Classes\n\n    \n    public class TMVCWebRequest\n    {\n        public Dictionary<string, string> Headers { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n    }\n\n    public class TMVCWebResponse\n    {\n        public int StatusCode { get; set; }\n        public string Content { get; set; }\n        public Dictionary<string, string> CustomHeaders { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public void SetCustomHeader(string name, string value)\n        {\n            CustomHeaders[name] = value;\n        }\n    }\n\n    #endregion\n}"}
