{"input": "unit uBase.Controller;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.Serializer.Commons, JsonDataObjects,\n  uServices;\n\ntype\n\n  [MVCPath('/')]\n  TBaseController = class(TMVCController)\n  protected\n    PageData: TJsonObject;\n    procedure OnBeforeAction(AContext: TWebContext; const AActionName: string; var AHandled: Boolean); override;\n    procedure OnAfterAction(AContext: TWebContext; const AActionName: string); override;\n  private\n    FGenreService: TGenreService;\n    FMovieService: TMovieService;\n  strict protected\n    function GetGenreService: TGenreService;\n    function GetMovieService: TMovieService;\n  public\n    destructor Destroy; override;\n  public\n    [MVCPath(''), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    function Index: String;\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\ndestructor TBaseController.Destroy;\nbegin\n  if FGenreService <> nil then\n    FGenreService.Free;\n  if FMovieService <> nil then\n    FMovieService.Free;\n\n  inherited;\nend;\n\nfunction TBaseController.GetMovieService: TMovieService;\nbegin\n  if FMovieService = nil then\n    FMovieService := TMovieService.Create;\n  Result := FMovieService;\nend;\n\nfunction TBaseController.GetGenreService: TGenreService;\nbegin\n  if FGenreService = nil then\n    FGenreService := TGenreService.Create;\n  Result := FGenreService;\nend;\n\nfunction TBaseController.Index: String;\nbegin\n  Result := RenderViews(['header', 'index', 'footer']);\nend;\n\nprocedure TBaseController.OnAfterAction(AContext: TWebContext; const AActionName: string);\nbegin\n  PageData.Free;\n  inherited;\nend;\n\nprocedure TBaseController.OnBeforeAction(AContext: TWebContext; const AActionName: string; var AHandled: Boolean);\nbegin\n  inherited;\n  PageData := TJsonObject.Create;\n  ViewData['page'] := PageData;\n  PageData.S['copyright'] := Format('Copyright %s', [FormatDateTime('yyyy', Now)]);\n  PageData.S['version'] := Format('Version %d', [GetFileVersion(ParamStr(0))]);\nend;\n\nend.", "output": "using System;\nusing System.Globalization;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Commons;\nusing JsonDataObjects;\nusing uServices;\n\nnamespace uBase.Controller\n{\n    [MVCPath(\"/\")]\n    public class BaseController : MVCController\n    {\n        protected JsonObject PageData;\n        private TGenreService _genreService;\n        private TMovieService _movieService;\n\n        protected override void OnBeforeAction(TWebContext context, string actionName, ref bool handled)\n        {\n            base.OnBeforeAction(context, actionName, ref handled);\n            PageData = new JsonObject();\n            ViewData[\"page\"] = PageData;\n            PageData[\"copyright\"] = string.Format(\"Copyright {0}\", DateTime.Now.ToString(\"yyyy\", CultureInfo.InvariantCulture));\n            PageData[\"version\"] = string.Format(\"Version {0}\", GetFileVersion(ParamStr(0)));\n        }\n\n        protected override void OnAfterAction(TWebContext context, string actionName)\n        {\n            PageData.Dispose();\n            base.OnAfterAction(context, actionName);\n        }\n\n        public override void Dispose()\n        {\n            if (_genreService != null)\n            {\n                _genreService.Dispose();\n                _genreService = null;\n            }\n            if (_movieService != null)\n            {\n                _movieService.Dispose();\n                _movieService = null;\n            }\n            base.Dispose();\n        }\n\n        protected TMovieService GetMovieService()\n        {\n            if (_movieService == null)\n                _movieService = new TMovieService();\n            return _movieService;\n        }\n\n        protected TGenreService GetGenreService()\n        {\n            if (_genreService == null)\n                _genreService = new TGenreService();\n            return _genreService;\n        }\n\n        [MVCPath(\"\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public string Index()\n        {\n            return RenderViews(new string[] { \"header\", \"index\", \"footer\" });\n        }\n\n        private int GetFileVersion(string fileName)\n        {\n            return 1;\n        }\n\n        private string ParamStr(int index)\n        {\n            return AppDomain.CurrentDomain.FriendlyName;\n        }\n    }\n}"}
{"input": "unit Horse.Rtti;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils, RTTI,\n{$ELSE}\n  System.SysUtils,\n  System.Rtti,\n{$ENDIF}\n  Horse.Commons;\n\ntype\n  THorseRtti = class\n  private\n    class var FHorseRtti: THorseRtti;\n    FContext: TRttiContext;\n  protected\n    class function GetDefaultHorseRtti: THorseRtti;\n  public\n    function GetType(const AClass: TClass): TRttiType;\n    constructor Create; virtual;\n    class destructor UnInitialize; {$IFNDEF FPC}virtual;{$ENDIF}\n    class function GetInstance: THorseRtti;\n  end;\n\nimplementation\n\nconstructor THorseRtti.Create;\nbegin\n  if FHorseRtti <> nil then\n    raise Exception.Create('The Horse Rtti instance has already been created');\n  FContext := TRttiContext.Create;\n  FHorseRtti := Self;\nend;\n\nclass function THorseRtti.GetDefaultHorseRtti: THorseRtti;\nbegin\n  if FHorseRtti = nil then\n    FHorseRtti := THorseRtti.Create;\n  Result := FHorseRtti;\nend;\n\nclass function THorseRtti.GetInstance: THorseRtti;\nbegin\n  Result := GetDefaultHorseRtti;\nend;\n\nfunction THorseRtti.GetType(const AClass: TClass): TRttiType;\nbegin\n  Result := FContext.GetType(AClass);\nend;\n\nclass destructor THorseRtti.UnInitialize;\nbegin\n  if FHorseRtti <> nil then\n    FreeAndNil(FHorseRtti);\nend;\n\nend.", "output": "using System;\nusing System.Reflection;\n\nnamespace Horse.Rtti\n{\n    public class HorseRtti\n    {\n        private static HorseRtti _instance;\n\n        \n        private HorseRtti()\n        {\n            if (_instance != null)\n                throw new Exception(\"The Horse Rtti instance has already been created\");\n            _instance = this;\n        }\n        \n        \n        public Type GetType(Type aClass)\n        {\n            \n            return aClass;\n        }\n        \n        \n        public static HorseRtti GetInstance()\n        {\n            if (_instance == null)\n                _instance = new HorseRtti();\n            return _instance;\n        }\n        \n        \n        public static void UnInitialize()\n        {\n            _instance = null;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit WaitingFormU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls;\n\ntype\n  TWaitingForm = class(TForm)\n    lblMessage: TLabel;\n    Shape1: TShape;\n    lblRunningRequests: TLabel;\n    TimerWaiting: TTimer;\n    procedure TimerWaitingTimer(Sender: TObject);\n    procedure FormDestroy(Sender: TObject);\n  private\n    FWaitingCount: Integer;\n    fPoints: Integer;\n    procedure SetWaitingCount(const Value: Integer);\n    { Private declarations }\n  public\n    property WaitingCount: Integer read FWaitingCount write SetWaitingCount;\n    procedure IncreaseWaitingCount;\n    procedure DecreaseWaitingCount;\n\n  end;\n\nimplementation\n\nuses\n  System.Math, System.StrUtils;\n\n{$R *.dfm}\n{ TWaitingForm }\n\nprocedure TWaitingForm.DecreaseWaitingCount;\nbegin\n  WaitingCount := WaitingCount - 1;\nend;\n\nprocedure TWaitingForm.FormDestroy(Sender: TObject);\nbegin\n  Screen.Cursor := crDefault;\nend;\n\nprocedure TWaitingForm.IncreaseWaitingCount;\nbegin\n  WaitingCount := WaitingCount + 1;\nend;\n\nprocedure TWaitingForm.SetWaitingCount(const Value: Integer);\nbegin\n  FWaitingCount := Max(0, Value);\n  if FWaitingCount = 0 then\n  begin\n    TimerWaiting.Enabled := False;\n    Hide;\n    Screen.Cursor := crDefault;\n  end\n  else\n  begin\n    if not Visible then\n    begin\n      Screen.Cursor := crHourGlass;\n      fPoints := 0;\n      TimerWaiting.Enabled := True;\n      Show;\n    end;\n    lblRunningRequests.Caption := FWaitingCount.ToString + ' running request' + ifthen(FWaitingCount > 1, 's');\n    lblRunningRequests.Update;\n  end;\nend;\n\nprocedure TWaitingForm.TimerWaitingTimer(Sender: TObject);\nbegin\n  if fPoints = 3 then\n  begin\n    fPoints := 0;\n  end\n  else\n  begin\n    Inc(fPoints);\n  end;\n  lblMessage.Caption := 'Please wait' + StringOfChar('.', fPoints);\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace YourNamespace\n{\n    public class WaitingForm : Form\n    {\n        private Label lblMessage;\n        private Label lblRunningRequests;\n        private Timer TimerWaiting;\n        private Panel Shape1;\n        private int FWaitingCount;\n        private int fPoints;\n\n        public int WaitingCount\n        {\n            get { return FWaitingCount; }\n            set { SetWaitingCount(value); }\n        }\n\n        public WaitingForm()\n        {\n            lblMessage = new Label();\n            lblRunningRequests = new Label();\n            TimerWaiting = new Timer();\n            Shape1 = new Panel();\n            TimerWaiting.Interval = 1000;\n            TimerWaiting.Tick += TimerWaiting_Tick;\n            this.FormClosed += WaitingForm_FormClosed;\n            lblMessage.AutoSize = true;\n            lblMessage.Location = new Point(10, 10);\n            lblRunningRequests.AutoSize = true;\n            lblRunningRequests.Location = new Point(10, 40);\n            Shape1.Size = new Size(100, 10);\n            Shape1.Location = new Point(10, 70);\n            Shape1.BackColor = Color.Black;\n            this.Controls.Add(lblMessage);\n            this.Controls.Add(lblRunningRequests);\n            this.Controls.Add(Shape1);\n        }\n\n        private void SetWaitingCount(int value)\n        {\n            FWaitingCount = Math.Max(0, value);\n            if (FWaitingCount == 0)\n            {\n                TimerWaiting.Enabled = false;\n                this.Hide();\n                Cursor = Cursors.Default;\n            }\n            else\n            {\n                if (!this.Visible)\n                {\n                    Cursor = Cursors.WaitCursor;\n                    fPoints = 0;\n                    TimerWaiting.Enabled = true;\n                    this.Show();\n                }\n                lblRunningRequests.Text = FWaitingCount.ToString() + \" running request\" + (FWaitingCount > 1 ? \"s\" : \"\");\n                lblRunningRequests.Refresh();\n            }\n        }\n\n        public void IncreaseWaitingCount()\n        {\n            WaitingCount = WaitingCount + 1;\n        }\n\n        public void DecreaseWaitingCount()\n        {\n            WaitingCount = WaitingCount - 1;\n        }\n\n        private void TimerWaiting_Tick(object sender, EventArgs e)\n        {\n            if (fPoints == 3)\n                fPoints = 0;\n            else\n                fPoints++;\n            lblMessage.Text = \"Please wait\" + new string('.', fPoints);\n        }\n\n        private void WaitingForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            Cursor = Cursors.Default;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.Proxy;\n\ninterface\n\nuses Classes, System.SysUtils, LoggerPro;\n\ntype\n  ILogAppenderProxy=interface\n    ['{34816F83-9FBF-461E-8913-F10F9460D712}']\n    function GetInternalAppender: ILogAppender;\n    property InternalAppender: ILogAppender read GetInternalAppender;\n  end;\n\n  TLoggerProFilter = class abstract\n    class function Build(Appender: ILogAppender; Filter: TFunc<TLogItem, boolean>): ILogAppender;\n  end;\n\n  TLogWriterPredicate = reference to function (const aType: TLogType; const aMessage, aTag: string): Boolean;\n\n  TLogWriterDecorator = class(TInterfacedObject, ILogWriter)\n  private\n    fDecoratedLogWriter: ILogWriter;\n    fFilter: TLogWriterPredicate;\n  protected\n    { ILogWriter }\n    procedure Debug(const aMessage: string; const aTag: string); overload;\n    procedure Debug(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Info(const aMessage: string; const aTag: string); overload;\n    procedure Info(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Warn(const aMessage: string; const aTag: string); overload;\n    procedure Warn(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Error(const aMessage: string; const aTag: string); overload;\n    procedure Error(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Fatal(const aMessage: string; const aTag: string); overload;\n    procedure Fatal(const aMessage: string; const aParams: array of TVarRec; const aTag: string); overload;\n\n    procedure Log(const aType: TLogType; const aMessage: string; const aTag: string); overload;\n    procedure Log(const aType: TLogType; const aMessage: string; const aParams: array of const; const aTag: string); overload;\n\n    { ICustomLogWriter}\n    function GetAppendersClassNames: TArray<string>;\n    function GetAppenders(const aIndex: Integer): ILogAppender;\n    property Appenders[const aIndex: Integer]: ILogAppender read GetAppenders;\n    procedure AddAppender(const aAppender: ILogAppender);\n    procedure DelAppender(const aAppender: ILogAppender);\n    function AppendersCount(): Integer;\n\n\n    ///\n    constructor Create(LogWriter: ILogWriter; Filter: TLogWriterPredicate);\n  public\n    class function Build(LogWriter: ILogWriter; Filter: TLogWriterPredicate): ILogWriter;\n  end;\n\n\nimplementation\n\ntype\n  TLoggerProAppenderFilterImpl = class(TLoggerProAppenderBase, ILogAppender, ILogAppenderProxy)\n  private\n    FAppender: ILogAppender;\n    FFilter: TFunc<TLogItem, boolean>;\n    function GetInternalAppender: ILogAppender;\n  public\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    property InternalAppender: ILogAppender read GetInternalAppender;\n    constructor Create(Appender: ILogAppender; Filter: TFunc<TLogItem, boolean>);  reintroduce;\n  end;\n\n{ TLoggerProAppenderFilterImpl }\n\nconstructor TLoggerProAppenderFilterImpl.Create(Appender: ILogAppender;\n  Filter: TFunc<TLogItem, boolean>);\nbegin\n  inherited Create;\n  self.FFilter := Filter;\n  self.FAppender := Appender;\nend;\n\nfunction TLoggerProAppenderFilterImpl.GetInternalAppender: ILogAppender;\nbegin\n  result := FAppender;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.Setup;\nbegin\n  FAppender.Setup;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.TearDown;\nbegin\n  FAppender.TearDown;\nend;\n\nprocedure TLoggerProAppenderFilterImpl.WriteLog(const aLogItem: TLogItem);\nbegin\n  if FFilter(aLogItem) then\n    FAppender.WriteLog(aLogItem);\nend;\n\n\nclass function TLoggerProFilter.Build(Appender: ILogAppender;\n  Filter: TFunc<TLogItem, boolean>): ILogAppender;\nbegin\n  Result := TLoggerProAppenderFilterImpl.Create(Appender, Filter);\nend;\n\n\n{ TLogWriterDecorator }\n\nclass function TLogWriterDecorator.Build(LogWriter: ILogWriter;\n  Filter: TLogWriterPredicate): ILogWriter;\nbegin\n  Result := TLogWriterDecorator.Create(LogWriter, Filter);\nend;\n\nconstructor TLogWriterDecorator.Create(LogWriter: ILogWriter; Filter: TLogWriterPredicate);\nbegin\n  inherited Create;\n  fDecoratedLogWriter := LogWriter;\n  fFilter := Filter;\nend;\n\nprocedure TLogWriterDecorator.AddAppender(const aAppender: ILogAppender);\nbegin\n  fDecoratedLogWriter.AddAppender(aAppender);\nend;\n\nfunction TLogWriterDecorator.AppendersCount: Integer;\nbegin\n  Result := fDecoratedLogWriter.AppendersCount;\nend;\n\nfunction TLogWriterDecorator.GetAppenders(const aIndex: Integer): ILogAppender;\nbegin\n  Result := fDecoratedLogWriter.GetAppenders(aIndex);\nend;\n\nfunction TLogWriterDecorator.GetAppendersClassNames: TArray<string>;\nbegin\n  Result := fDecoratedLogWriter.GetAppendersClassNames;\nend;\n\n// ILogWriter\n\nprocedure TLogWriterDecorator.Debug(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Debug, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Debug(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Debug, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.DelAppender(const aAppender: ILogAppender);\nbegin\n  fDecoratedLogWriter.DelAppender(aAppender);\nend;\n\nprocedure TLogWriterDecorator.Error(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Error, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Error(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Error, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Fatal(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Fatal, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Fatal(const aMessage: string;\n  const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Fatal, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Info(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Info, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Info(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Info, aMessage, aParams, aTag);\nend;\n\nprocedure TLogWriterDecorator.Log(const aType: TLogType; const aMessage, aTag: string);\nbegin\n  if fFilter(aType, aMessage, aTag) then\n  begin\n    fDecoratedLogWriter.Log(aType, aMessage, aTag);\n  end;\nend;\n\nprocedure TLogWriterDecorator.Log(const aType: TLogType; const aMessage: string; const aParams: array of const; const aTag: string);\nbegin\n  Log(aType, Format(aMessage, aParams), aTag);\nend;\n\nprocedure TLogWriterDecorator.Warn(const aMessage, aTag: string);\nbegin\n  Log(TLogType.Warning, aMessage, aTag);\nend;\n\nprocedure TLogWriterDecorator.Warn(const aMessage: string; const aParams: array of TVarRec; const aTag: string);\nbegin\n  Log(TLogType.Warning, aMessage, aParams, aTag);\nend;\n\n\nend.", "output": "using System;\nusing LoggerPro; \n\nnamespace LoggerPro.Proxy\n{\n    \n    public interface ILogAppenderProxy\n    {\n        ILogAppender InternalAppender { get; }\n    }\n\n    \n    public static class LoggerProFilter\n    {\n        \n        public static ILogAppender Build(ILogAppender appender, Func<LogItem, bool> filter)\n        {\n            return new LoggerProAppenderFilterImpl(appender, filter);\n        }\n    }\n\n    \n    public delegate bool LogWriterPredicate(LogType logType, string message, string tag);\n\n    \n    public class LogWriterDecorator : ILogWriter\n    {\n        private readonly ILogWriter _decoratedLogWriter;\n        private readonly LogWriterPredicate _filter;\n\n        \n        protected LogWriterDecorator(ILogWriter logWriter, LogWriterPredicate filter)\n        {\n            _decoratedLogWriter = logWriter;\n            _filter = filter;\n        }\n\n        \n        public static ILogWriter Build(ILogWriter logWriter, LogWriterPredicate filter)\n        {\n            return new LogWriterDecorator(logWriter, filter);\n        }\n\n        \n        public void Debug(string message, string tag)\n        {\n            Log(LogType.Debug, message, tag);\n        }\n\n        public void Debug(string message, object[] args, string tag)\n        {\n            Log(LogType.Debug, string.Format(message, args), tag);\n        }\n\n        public void Info(string message, string tag)\n        {\n            Log(LogType.Info, message, tag);\n        }\n\n        public void Info(string message, object[] args, string tag)\n        {\n            Log(LogType.Info, string.Format(message, args), tag);\n        }\n\n        public void Warn(string message, string tag)\n        {\n            Log(LogType.Warning, message, tag);\n        }\n\n        public void Warn(string message, object[] args, string tag)\n        {\n            Log(LogType.Warning, string.Format(message, args), tag);\n        }\n\n        public void Error(string message, string tag)\n        {\n            Log(LogType.Error, message, tag);\n        }\n\n        public void Error(string message, object[] args, string tag)\n        {\n            Log(LogType.Error, string.Format(message, args), tag);\n        }\n\n        public void Fatal(string message, string tag)\n        {\n            Log(LogType.Fatal, message, tag);\n        }\n\n        public void Fatal(string message, object[] args, string tag)\n        {\n            Log(LogType.Fatal, string.Format(message, args), tag);\n        }\n\n        public void Log(LogType type, string message, string tag)\n        {\n            if (_filter(type, message, tag))\n            {\n                _decoratedLogWriter.Log(type, message, tag);\n            }\n        }\n\n        public void Log(LogType type, string message, object[] args, string tag)\n        {\n            Log(type, string.Format(message, args), tag);\n        }\n\n        \n        public string[] GetAppendersClassNames() => _decoratedLogWriter.GetAppendersClassNames();\n\n        public ILogAppender GetAppender(int index) => _decoratedLogWriter.GetAppender(index);\n\n        public void AddAppender(ILogAppender appender) => _decoratedLogWriter.AddAppender(appender);\n\n        public void DelAppender(ILogAppender appender) => _decoratedLogWriter.DelAppender(appender);\n\n        public int AppendersCount() => _decoratedLogWriter.AppendersCount();\n    }\n\n    \n    internal class LoggerProAppenderFilterImpl : LoggerProAppenderBase, ILogAppender, ILogAppenderProxy\n    {\n        private readonly ILogAppender _internalAppender;\n        private readonly Func<LogItem, bool> _filter;\n\n        public LoggerProAppenderFilterImpl(ILogAppender appender, Func<LogItem, bool> filter)\n        {\n            _filter = filter;\n            _internalAppender = appender;\n        }\n\n        public ILogAppender InternalAppender => _internalAppender;\n\n        public override void Setup()\n        {\n            _internalAppender.Setup();\n        }\n\n        public override void TearDown()\n        {\n            _internalAppender.TearDown();\n        }\n\n        public override void WriteLog(LogItem logItem)\n        {\n            if (_filter(logItem))\n            {\n                _internalAppender.WriteLog(logItem);\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerPrivateU;\n\ninterface\n\nuses\n  MVCFramework;\n\ntype\n\n  [MVCPath('/privatecustom')]\n  TTestPrivateServerControllerCustomAuth = class(TMVCController)\n  public\n    [MVCPath('/role1')]\n    procedure OnlyRole1;\n    [MVCPath('/role2')]\n    procedure OnlyRole2;\n  end;\n\nimplementation\n\n\n{ TTestPrivateServerControllerCustomAuth }\n\nprocedure TTestPrivateServerControllerCustomAuth.OnlyRole1;\nbegin\n  Render('Here''s Action1 from the private controller');\nend;\n\nprocedure TTestPrivateServerControllerCustomAuth.OnlyRole2;\nbegin\n  Render('Here''s Action2 from the private controller');\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\n\nnamespace TestServer.Controllers\n{\n    [Route(\"privatecustom\")]\n    [ApiController]\n    public class TestPrivateServerControllerCustomAuth : ControllerBase\n    {\n        [HttpGet(\"role1\")]\n        public IActionResult OnlyRole1()\n        {\n            return Ok(\"Here's Action1 from the private controller\");\n        }\n\n        [HttpGet(\"role2\")]\n        public IActionResult OnlyRole2()\n        {\n            return Ok(\"Here's Action2 from the private controller\");\n        }\n    }\n}"}
{"input": "(*****************************************************************************\nThe MIT License (MIT)\n\nCopyright (c) 2015-2016 Andreas Hausladen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*****************************************************************************)\n\n{$A8,B-,C+,E-,F-,G+,H+,I+,J-,K-,M-,N-,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Z1}\n{$WARN WIDECHAR_REDUCED OFF} // All sets only use ASCII chars (<=#127) and the compiler generates the >=#128 check itself\n{$STRINGCHECKS OFF} // It only slows down Delphi strings, doesn't help C++Builder migration and is finally gone in XE+\n{$WARN SYMBOL_DEPRECATED OFF} // for StrLen/StrLComp\n{$POINTERMATH ON}\n\nunit JsonDataObjects;\n\n{$IFDEF VER200}\n  // Delphi 2009's ErrorInsight parser uses the CompilerVersion's memory address instead of 20.0, failing all the\n  // IF CompilerVersion compiler directives\n  {$DEFINE CPUX86}\n{$ELSE}\n  {$IF CompilerVersion >= 24.0} // XE3 or newer\n    {$LEGACYIFEND ON}\n    {$IF CompilerVersion >= 35.0} // 11.0 or newer\n      {$DEFINE STREAM_USES_NATIVEINT}\n    {$IFEND}\n  {$IFEND}\n  {$IF CompilerVersion >= 23.0}\n    {$DEFINE HAS_UNIT_SCOPE}\n    {$DEFINE HAS_RETURN_ADDRESS}\n  {$IFEND}\n  {$IF CompilerVersion <= 22.0} // XE or older\n    {$DEFINE CPUX86}\n  {$IFEND}\n{$ENDIF VER200}\n\n{$IFDEF NEXTGEN}\n  {$IF CompilerVersion >= 31.0} // 10.1 Berlin or newer\n    {$DEFINE SUPPORTS_UTF8STRING} // Delphi 10.1 Berlin supports UTF8String for mobile compilers\n  {$IFEND}\n{$ELSE}\n  {$DEFINE SUPPORTS_UTF8STRING}\n{$ENDIF}\n\n{$IFDEF CPUX64}\n  {$IFNDEF LINUX64} // Linux 64 compiler doesn't support ASM for x64 code => LLVM\n    {$DEFINE ASMSUPPORT}\n  {$ENDIF ~LINUX64}\n{$ENDIF CPUX64}\n{$IFDEF CPUX86}\n  {$DEFINE ASMSUPPORT}\n{$ENDIF CPUX86}\n{$IFDEF EXTERNALLINKER} // implicates LLVM\n  {$UNDEF ASMSUPPORT}\n{$ENDIF EXTERNALLINKER}\n\n// Sanity checks all array index accesses and raise an EListError exception.\n{$DEFINE CHECK_ARRAY_INDEX}\n\n// JSON allows the slash to be escaped. This is only necessary if you plan to put the JSON string\n// into a <script>-Tag because then \"</\" can't be used and must be escaped to \"<\\/\". This switch\n// enables the special handling for \"</\" but makes the parser slightly slower.\n{.$DEFINE ESCAPE_SLASH_AFTER_LESSTHAN}\n\n// When parsing a JSON string the pair names are interned to reduce the memory foot print. This\n// slightly slows down the parser but saves a lot of memory if the JSON string contains repeating\n// pair names. The interning uses a hashset to store the strings.\n{$DEFINE USE_STRINGINTERN_FOR_NAMES}\n\n// Use an optimized NewInstance implementation. It skips the initialization of the interface table.\n// and seals the TJsonArray and TJsonObject classes because it isn't safe to derive from them.\n{$DEFINE USE_FAST_NEWINSTANCE}\n\n//{$IF CompilerVersion < 28.0} // XE6 or older\n  // The XE7 compiler is broken. It doesn't collapse duplicate string literals anymore. (RSP-10015)\n  // But if the string literals are used in loops this optimization still helps.\n\n  // Optimizes the following pattern:\n  //   O['Name'][MyPropStr]\n  //   O['Name']['MyProp'].\n  // where the second O['Name'] is handled very fast by caching the pointer to the 'Name' string literal.\n  {$DEFINE USE_LAST_NAME_STRING_LITERAL_CACHE}\n//{$IFEND}\n\n// When parsing the JSON string, the UStrAsg calls are skipped for internal strings what eliminates\n// the CPU locks for those string assignments.\n{$DEFINE USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n\n{$IFDEF AUTOREFCOUNT}\n  // Delphi's ARC is slow (RSP-9712). This switch enables a faster ARC handling and even skips memory\n  // barrier were possible.\n  {$DEFINE USE_FAST_AUTOREFCOUNT}\n{$ENDIF AUTOREFCOUNT}\n\n{$IFDEF MSWINDOWS}\n  // When adding JSON object properties with string literals, the string literals are stored directly\n  // in the \"Name\" field instead of using UStrAsg that creates a new heap string. This improves the\n  // performance as no string is copied and it slighly reduces the memory usage.\n  // The string literals are only used if they are in the main instance or the DLL that contains the\n  // JsonDataObjects unit. Other string literals are copied using UStrAsg because unloading the DLL\n  // that holds them would cause access violations.\n  // This has no effect when parsing JSON strings because then there are no string literals.\n  {$DEFINE USE_NAME_STRING_LITERAL}\n\n  // Reading a large file >64 MB from a network drive in Windows 2003 Server or older can lead to\n  // an INSUFFICIENT RESOURCES error. By enabling this switch, large files are read in 20 MB blocks.\n  {$DEFINE WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\n\n  // If defined, the TzSpecificLocalTimeToSystemTime is imported with GetProcAddress and if it is\n  // not available (Windows 2000) an alternative implementation is used.\n  {$DEFINE SUPPORT_WINDOWS2000}\n\n{$ENDIF MSWINDOWS}\n\ninterface\n\nuses\n  {$IFDEF HAS_UNIT_SCOPE}\n  System.SysUtils, System.Classes;\n  {$ELSE}\n  SysUtils, Classes;\n  {$ENDIF HAS_UNIT_SCOPE}\n\n{$HPPEMIT '#pragma link \"Jsondataobjects\"'}\n\ntype\n  TJsonBaseObject = class;\n  TJsonObject = class;\n  TJsonArray = class;\n\n  {$IFDEF NEXTGEN}\n  // Mobile compilers have PAnsiChar but it is hidden and then published under a new name. This alias\n  // allows us to remove some IFDEFs.\n  PAnsiChar = MarshaledAString;\n  {$ENDIF NEXTGEN}\n\n  EJsonException = class(Exception);\n  EJsonCastException = class(EJsonException);\n  EJsonPathException = class(EJsonException);\n\n  EJsonParserException = class(EJsonException)\n  private\n    FColumn: NativeInt;\n    FPosition: NativeInt;\n    FLineNum: NativeInt;\n  public\n    constructor CreateResFmt(ResStringRec: PResStringRec; const Args: array of const; ALineNum, AColumn, APosition: NativeInt);\n    constructor CreateRes(ResStringRec: PResStringRec; ALineNum, AColumn, APosition: NativeInt);\n\n    property LineNum: NativeInt read FLineNum;   // base 1\n    property Column: NativeInt read FColumn;     // base 1\n    property Position: NativeInt read FPosition; // base 0  Utf8Char/WideChar index\n  end;\n\n  TJsonSerializationConfig = record\n  public\n    // LineBreak specifies what characters are used for line breaks in \"Compact=False\" mode.\n    // Default: #10\n    LineBreak: string;\n    // IndentChar specifies what characters are used to indent lines in \"Compact=False\" mode.\n    // Default: #9\n    IndentChar: string;\n    // If UseUtcTime is True, all TDateTime values will written in UTC timezone converted from the\n    // local timezone in the JSON string. Otherwise the timezone offset to the local timezone will\n    // be included.\n    // Default: True\n    UseUtcTime: Boolean;\n    // If EscapeAllNonASCIIChars is True, all characters >=#128 will be escaped when generating\n    // the JSON string.\n    // Default: False\n    EscapeAllNonASCIIChars: Boolean;\n\n    procedure InitDefaults;\n    class function Default: TJsonSerializationConfig; static;\n  public\n    // If NullConvertsToValueTypes is True and an object is nil/null, a convertion to String, Int,\n    // Long, Float, DateTime, Boolean will return ''/0/False\n    // Default: False\n    NullConvertsToValueTypes: Boolean; // Isn't use for serialization. Should default to True and be deprecated.\n  end;\n\n  TJsonReaderProgressProc = procedure(Data: Pointer; Percentage: Integer; Position, Size: NativeInt);\n\n  PJsonReaderProgressRec = ^TJsonReaderProgressRec;\n  TJsonReaderProgressRec = record\n    Data: Pointer;        // used for the first Progress() parameter\n    Threshold: NativeInt; // 0: Call only if percentage changed; greater than 0: call after n processed bytes\n    Progress: TJsonReaderProgressProc;\n\n    function Init(AProgress: TJsonReaderProgressProc; AData: Pointer = nil; AThreshold: NativeInt = 0): PJsonReaderProgressRec;\n  end;\n\n  // TJsonOutputWriter is used to write the JSON data to a string, stream or TStrings in a compact\n  // or human readable format.\n  PJsonOutputWriter = ^TJsonOutputWriter;\n  TJsonOutputWriter = record\n  private type\n    TLastType = (ltInitial, ltIndent, ltUnindent, ltIntro, ltValue, ltSeparator);\n\n    PJsonStringArray = ^TJsonStringArray;\n    TJsonStringArray = array[0..MaxInt div SizeOf(string) - 1] of string;\n\n    PJsonStringBuilder = ^TJsonStringBuilder;\n    TJsonStringBuilder = record\n    private\n      FData: PChar;\n      FCapacity: Integer;\n      FLen: Integer;\n      procedure Grow(MinLen: Integer);\n    public\n      procedure Init;\n      procedure Done;\n      procedure DoneConvertToString(var S: string);\n      function FlushToBytes(var Bytes: PByte; var Size: NativeInt; Encoding: TEncoding): NativeInt;\n      procedure FlushToMemoryStream(Stream: TMemoryStream; Encoding: TEncoding);\n      procedure FlushToStringBuffer(var Buffer: TJsonStringBuilder);\n      procedure FlushToString(var S: string);\n\n      function Append(const S: string): PJsonStringBuilder; overload;\n      procedure Append(P: PChar; Len: Integer); overload;\n      function Append2(const S1: string; S2: PChar; S2Len: Integer): PJsonStringBuilder; overload;\n      procedure Append2(Ch1: Char; Ch2: Char); overload;\n      procedure Append3(Ch1: Char; const S2, S3: string); overload;\n      procedure Append3(Ch1: Char; const S2: string; Ch3: Char); overload; inline;\n      procedure Append3(Ch1: Char; const P2: PChar; P2Len: Integer; Ch3: Char); overload;\n\n      property Len: Integer read FLen;\n      property Data: PChar read FData;\n    end;\n  private\n    FLastType: TLastType;\n    FCompact: Boolean;\n    FStringBuffer: TJsonStringBuilder;\n    FLines: TStrings;\n    FLastLine: TJsonStringBuilder;\n    FConfig: TJsonSerializationConfig;\n\n    FStreamEncodingBuffer: PByte;\n    FStreamEncodingBufferLen: NativeInt;\n    FStream: TStream;                // used when writing to a stream\n    FEncoding: TEncoding;            // used when writing to a stream\n\n    FIndents: PJsonStringArray;      // buffer for line indention strings\n    FIndentsLen: Integer;\n    FIndent: Integer;                // current indention level\n\n    procedure StreamFlushPossible; inline; // checks if StreamFlush must be called\n    procedure StreamFlush;                 // writes the buffer to the stream\n    procedure ExpandIndents;\n    procedure AppendLine(AppendOn: TLastType; const S: string); overload; inline;\n    procedure AppendLine(AppendOn: TLastType; P: PChar; Len: Integer); overload; inline;\n    procedure FlushLastLine;\n  private // unit private\n    procedure Init(ACompact: Boolean; AStream: TStream; AEncoding: TEncoding; ALines: TStrings;\n      const Config: TJsonSerializationConfig);\n    function Done: string;\n    procedure StreamDone;\n    procedure LinesDone;\n\n    procedure Indent(const S: string);\n    procedure Unindent(const S: string);\n    procedure AppendIntro(P: PChar; Len: Integer);\n    procedure AppendValue(const S: string); overload;\n    procedure AppendValue(P: PChar; Len: Integer); overload;\n    procedure AppendStrValue(P: PChar; Len: Integer);\n    procedure AppendSeparator(const S: string);\n    procedure FreeIndents;\n  end;\n\n  TJsonDataType = (\n    jdtNone, jdtString, jdtInt, jdtLong, jdtULong, jdtFloat, jdtDateTime, jdtUtcDateTime, jdtBool, jdtArray, jdtObject\n  );\n\n  // TJsonDataValue holds the actual value\n  PJsonDataValue = ^TJsonDataValue;\n  TJsonDataValue = packed record\n  private type\n    TJsonDataValueRec = record\n      case TJsonDataType of\n        jdtNone: (P: PChar);     // helps when debugging\n        jdtString: (S: Pointer); // We manage the string ourself. Delphi doesn't allow \"string\" in a\n                                 // variant record and if we have no string, we don't need to clean\n                                 // it up, anyway.\n        jdtInt: (I: Integer);\n        jdtLong: (L: Int64);\n        jdtULong: (U: UInt64);\n        jdtFloat: (F: Double);\n        jdtDateTime, jdtUtcDateTime: (D: TDateTime);\n        jdtBool: (B: Boolean);\n        jdtArray: (A: Pointer);  // owned by TJsonDataValue\n        jdtObject: (O: Pointer); // owned by TJsonDataValue\n    end;\n  private\n    FValue: TJsonDataValueRec;\n    FTyp: TJsonDataType;\n    function GetValue: string;\n    function GetIntValue: Integer;\n    function GetLongValue: Int64;\n    function GetULongValue: UInt64;\n    function GetFloatValue: Double;\n    function GetDateTimeValue: TDateTime;\n    function GetUtcDateTimeValue: TDateTime;\n    function GetBoolValue: Boolean;\n    function GetArrayValue: TJsonArray;\n    function GetObjectValue: TJsonObject;\n    function GetVariantValue: Variant;\n\n    procedure SetValue(const AValue: string);\n    procedure SetIntValue(const AValue: Integer);\n    procedure SetLongValue(const AValue: Int64);\n    procedure SetULongValue(const AValue: UInt64);\n    procedure SetFloatValue(const AValue: Double);\n    procedure SetDateTimeValue(const AValue: TDateTime);\n    procedure SetUtcDateTimeValue(const AValue: TDateTime);\n    procedure SetBoolValue(const AValue: Boolean);\n    procedure SetArrayValue(const AValue: TJsonArray);\n    procedure SetObjectValue(const AValue: TJsonObject);\n    procedure SetVariantValue(const AValue: Variant);\n\n    procedure InternToJSON(var Writer: TJsonOutputWriter);\n    procedure InternSetValue(const AValue: string); // skips the call to Clear()\n    procedure InternSetValueTransfer(var AValue: string); // skips the call to Clear() and transfers the string without going through UStrAsg+UStrClr\n    procedure InternSetArrayValue(const AValue: TJsonArray);\n    procedure InternSetObjectValue(const AValue: TJsonObject);\n    procedure Clear;\n    procedure TypeCastError(ExpectedType: TJsonDataType);\n  public\n    function IsNull: Boolean;\n\n    property Typ: TJsonDataType read FTyp;\n    property Value: string read GetValue write SetValue;\n    property IntValue: Integer read GetIntValue write SetIntValue;\n    property LongValue: Int64 read GetLongValue write SetLongValue;\n    property ULongValue: UInt64 read GetULongValue write SetULongValue;\n    property FloatValue: Double read GetFloatValue write SetFloatValue;\n    property DateTimeValue: TDateTime read GetDateTimeValue write SetDateTimeValue;\n    property UtcDateTimeValue: TDateTime read GetUtcDateTimeValue write SetUtcDateTimeValue;\n    property BoolValue: Boolean read GetBoolValue write SetBoolValue;\n    property ArrayValue: TJsonArray read GetArrayValue write SetArrayValue;\n    property ObjectValue: TJsonObject read GetObjectValue write SetObjectValue;\n    property VariantValue: Variant read GetVariantValue write SetVariantValue;\n  end;\n\n  // TJsonDataValueHelper is used to implement the \"easy access\" functionality. It is\n  // slightly slower than using the direct indexed properties.\n  TJsonDataValueHelper = record\n  private\n    function GetValue: string; inline;\n    function GetIntValue: Integer; inline;\n    function GetLongValue: Int64; inline;\n    function GetULongValue: UInt64; //inline;  no implicit operator due to conflict with Int64\n    function GetFloatValue: Double; inline;\n    function GetDateTimeValue: TDateTime; inline;\n    function GetUtcDateTimeValue: TDateTime;\n    function GetBoolValue: Boolean; inline;\n    function GetArrayValue: TJsonArray; inline;\n    function GetObjectValue: TJsonObject; inline;\n    function GetVariantValue: Variant; inline;\n\n    procedure SetValue(const Value: string);\n    procedure SetIntValue(const Value: Integer);\n    procedure SetLongValue(const Value: Int64);\n    procedure SetULongValue(const Value: UInt64);\n    procedure SetFloatValue(const Value: Double);\n    procedure SetDateTimeValue(const Value: TDateTime);\n    procedure SetUtcDateTimeValue(const Value: TDateTime);\n    procedure SetBoolValue(const Value: Boolean);\n    procedure SetArrayValue(const Value: TJsonArray);\n    procedure SetObjectValue(const Value: TJsonObject);\n    procedure SetVariantValue(const Value: Variant);\n\n    function GetArrayItem(Index: Integer): TJsonDataValueHelper; inline;\n    function GetArrayCount: Integer; inline;\n\n    function GetObjectString(const Name: string): string; inline;\n    function GetObjectInt(const Name: string): Integer; inline;\n    function GetObjectLong(const Name: string): Int64; inline;\n    function GetObjectULong(const Name: string): UInt64; inline;\n    function GetObjectFloat(const Name: string): Double; inline;\n    function GetObjectDateTime(const Name: string): TDateTime; inline;\n    function GetObjectUtcDateTime(const Name: string): TDateTime; inline;\n    function GetObjectBool(const Name: string): Boolean; inline;\n    function GetArray(const Name: string): TJsonArray; inline;\n    {$IFDEF BCB}\n    function GetObj(const Name: string): TJsonDataValueHelper; inline; // work around C++Builder Windows.h::GetObject macro\n    {$ELSE}\n    function GetObject(const Name: string): TJsonDataValueHelper; inline;\n    {$ENDIF BCB}\n    function GetObjectVariant(const Name: string): Variant; inline;\n    procedure SetObjectString(const Name, Value: string); inline;\n    procedure SetObjectInt(const Name: string; const Value: Integer); inline;\n    procedure SetObjectLong(const Name: string; const Value: Int64); inline;\n    procedure SetObjectULong(const Name: string; const Value: UInt64); inline;\n    procedure SetObjectFloat(const Name: string; const Value: Double); inline;\n    procedure SetObjectDateTime(const Name: string; const Value: TDateTime); inline;\n    procedure SetObjectUtcDateTime(const Name: string; const Value: TDateTime); inline;\n    procedure SetObjectBool(const Name: string; const Value: Boolean); inline;\n    procedure SetArray(const Name: string; const Value: TJsonArray); inline;\n    procedure SetObject(const Name: string; const Value: TJsonDataValueHelper); inline;\n    procedure SetObjectVariant(const Name: string; const Value: Variant); inline;\n\n    function GetObjectPath(const Name: string): TJsonDataValueHelper; inline;\n    procedure SetObjectPath(const Name: string; const Value: TJsonDataValueHelper); inline;\n\n    function GetTyp: TJsonDataType;\n    procedure ResolveName;\n    class procedure SetInternValue(Item: PJsonDataValue; const Value: TJsonDataValueHelper); static;\n  public\n    class operator Implicit(const Value: string): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): string; overload;\n    class operator Implicit(const Value: Integer): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Integer; overload;\n    class operator Implicit(const Value: Int64): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Int64; overload;\n    //class operator Implicit(const Value: UInt64): TJsonDataValueHelper; overload;  conflicts with Int64 operator\n    //class operator Implicit(const Value: TJsonDataValueHelper): UInt64; overload;  conflicts with Int64 operator\n    class operator Implicit(const Value: Double): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Double; overload;\n    class operator Implicit(const Value: Extended): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Extended; overload;\n    class operator Implicit(const Value: TDateTime): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TDateTime; overload;\n    class operator Implicit(const Value: Boolean): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Boolean; overload;\n    class operator Implicit(const Value: TJsonArray): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TJsonArray; overload;\n    class operator Implicit(const Value: TJsonObject): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): TJsonObject; overload;\n    class operator Implicit(const Value: Pointer): TJsonDataValueHelper; overload;\n    class operator Implicit(const Value: TJsonDataValueHelper): Variant; overload;\n    class operator Implicit(const Value: Variant): TJsonDataValueHelper; overload;\n\n    function IsNull: Boolean;\n    \n    property Typ: TJsonDataType read GetTyp;\n    property Value: string read GetValue write SetValue;\n    property IntValue: Integer read GetIntValue write SetIntValue;\n    property LongValue: Int64 read GetLongValue write SetLongValue;\n    property ULongValue: UInt64 read GetULongValue write SetULongValue;\n    property FloatValue: Double read GetFloatValue write SetFloatValue;\n    property DateTimeValue: TDateTime read GetDateTimeValue write SetDateTimeValue;\n    property UtcDateTimeValue: TDateTime read GetUtcDateTimeValue write SetUtcDateTimeValue;\n    property BoolValue: Boolean read GetBoolValue write SetBoolValue;\n    property ArrayValue: TJsonArray read GetArrayValue write SetArrayValue;\n    property ObjectValue: TJsonObject read GetObjectValue write SetObjectValue;\n    property VariantValue: Variant read GetVariantValue write SetVariantValue;\n\n    // Access to array item count\n    property Count: Integer read GetArrayCount;\n    // Access to array items\n    property Items[Index: Integer]: TJsonDataValueHelper read GetArrayItem;\n\n    property S[const Name: string]: string read GetObjectString write SetObjectString;        // returns '' if property doesn't exist, auto type-cast except for array/object\n    property I[const Name: string]: Integer read GetObjectInt write SetObjectInt;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property L[const Name: string]: Int64 read GetObjectLong write SetObjectLong;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property U[const Name: string]: UInt64 read GetObjectULong write SetObjectULong;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property F[const Name: string]: Double read GetObjectFloat write SetObjectFloat;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property D[const Name: string]: TDateTime read GetObjectDateTime write SetObjectDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property DUtc[const Name: string]: TDateTime read GetObjectUtcDateTime write SetObjectUtcDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property B[const Name: string]: Boolean read GetObjectBool write SetObjectBool;           // returns false if property doesn't exist, auto type-cast with \"<>'true'\" and \"<>0\" except for array/object\n    // Used to auto create arrays\n    property A[const Name: string]: TJsonArray read GetArray write SetArray;\n    // Used to auto create objects and as default property where no Implicit operator matches\n    property O[const Name: string]: TJsonDataValueHelper read {$IFDEF BCB}GetObj{$ELSE}GetObject{$ENDIF} write SetObject; default;\n    property V[const Name: string]: Variant read GetObjectVariant write SetObjectVariant;\n\n    property Path[const Name: string]: TJsonDataValueHelper read GetObjectPath write SetObjectPath;\n  private\n    FData: record // hide the data from CodeInsight (bug in CodeInsight)\n      FIntern: PJsonDataValue;\n      FName: string;\n      FNameResolver: TJsonObject;\n      FValue: string; // must be managed by Delphi otherwise we have a memory leak\n      {$IFDEF AUTOREFCOUNT}\n      FObj: TJsonBaseObject;\n      {$ENDIF AUTOREFCOUNT}\n      case FTyp: TJsonDataType of\n        jdtInt: (FIntValue: Integer);\n        jdtLong: (FLongValue: Int64);\n        jdtULong: (FULongValue: UInt64);\n        jdtFloat: (FFloatValue: Double);\n        jdtDateTime, jdtUtcDateTime: (FDateTimeValue: TDateTime);\n        jdtBool: (FBoolValue: Boolean);\n        {$IFNDEF AUTOREFCOUNT}\n        jdtObject: (FObj: TJsonBaseObject); // used for both Array and Object\n        //jdtArray: (FArrayValue: TJsonArray);\n        //jdtObject: (FObjectValue: TJsonObject);\n        {$ENDIF AUTOREFCOUNT}\n    end;\n  end;\n\n  // TJsonBaseObject is the base class for TJsonArray and TJsonObject\n  TJsonBaseObject = class abstract(TObject)\n  private type\n    TWriterAppendMethod = procedure(P: PChar; Len: Integer) of object;\n    TStreamInfo = record\n      Buffer: PByte;\n      Size: NativeInt;\n      AllocationBase: Pointer;\n    end;\n  private\n    class procedure StrToJSONStr(const AppendMethod: TWriterAppendMethod; const S: string); static;\n    class procedure EscapeStrToJSONStr(F, P, EndP: PChar; const AppendMethod: TWriterAppendMethod); static;\n    class procedure DateTimeToJSONStr(const AppendMethod: TWriterAppendMethod; const Value: TDateTime); static;\n    class procedure UtcDateTimeToJSONStr(const AppendMethod: TWriterAppendMethod; const Value: TDateTime); static;\n    class procedure InternInitAndAssignItem(Dest, Source: PJsonDataValue); static;\n    class procedure GetStreamBytes(Stream: TStream; var Encoding: TEncoding; Utf8WithoutBOM: Boolean;\n      var StreamInfo: TStreamInfo); static;\n\n    {$IFDEF USE_FAST_AUTOREFCOUNT}\n    function ARCObjRelease: Integer; inline;\n    function ARCObjAddRef: Integer; inline;\n    {$ENDIF USE_FAST_AUTOREFCOUNT}\n  protected\n    procedure InternToJSON(var Writer: TJsonOutputWriter); virtual; abstract;\n  public\n    const DataTypeNames: array[TJsonDataType] of string = (\n      'null', 'String', 'Integer', 'Long', 'ULong', 'Float', 'DateTime', 'UTC-DateTime', 'Bool', 'Array', 'Object'\n    );\n\n    {$IFDEF USE_FAST_NEWINSTANCE}\n    class function NewInstance: TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF}; override;\n    {$ENDIF USE_FAST_NEWINSTANCE}\n\n    // ParseXxx returns nil if the JSON string is empty or consists only of white chars.\n    // If the JSON string starts with a \"[\" then the returned object is a TJsonArray otherwise\n    // it is a TJsonObject.\n    class function ParseUtf8(S: PAnsiChar; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; overload; static; inline;\n    {$IFDEF SUPPORTS_UTF8STRING}\n    class function ParseUtf8(const S: UTF8String; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; overload; static; inline;\n    {$ENDIF SUPPORTS_UTF8STRING}\n    class function ParseUtf8Bytes(S: PByte; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; static;\n    class function Parse(S: PWideChar; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; overload; static;\n    class function Parse(const S: UnicodeString; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; overload; static; inline;\n    class function Parse(const Bytes: TBytes; Encoding: TEncoding = nil; ByteIndex: Integer = 0;\n      ByteCount: Integer = -1; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; overload; static;\n    class function ParseFromFile(const FileName: string; Utf8WithoutBOM: Boolean = True; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; static;\n    class function ParseFromStream(Stream: TStream; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True; AProgress: PJsonReaderProgressRec = nil): TJsonBaseObject; static;\n\n    procedure LoadFromFile(const FileName: string; Utf8WithoutBOM: Boolean = True; AProgress: PJsonReaderProgressRec = nil);\n    procedure LoadFromStream(Stream: TStream; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True; AProgress: PJsonReaderProgressRec = nil);\n    procedure SaveToFile(const FileName: string; Compact: Boolean = True; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True); overload; inline;\n    procedure SaveToFile(const FileName: string; const Config: TJsonSerializationConfig; Compact: Boolean = True; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True); overload;\n    procedure SaveToStream(Stream: TStream; Compact: Boolean = True; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True); overload; inline;\n    procedure SaveToStream(Stream: TStream; const Config: TJsonSerializationConfig; Compact: Boolean = True; Encoding: TEncoding = nil; Utf8WithoutBOM: Boolean = True); overload;\n    procedure SaveToLines(Lines: TStrings); overload; inline;\n    procedure SaveToLines(Lines: TStrings; const Config: TJsonSerializationConfig); overload;\n\n    // FromXxxJSON() raises an EJsonParserException if you try to parse an array JSON string into a\n    // TJsonObject or a object JSON string into a TJsonArray.\n    {$IFDEF SUPPORTS_UTF8STRING}\n    procedure FromUtf8JSON(const S: UTF8String; AProgress: PJsonReaderProgressRec = nil); overload; inline;\n    {$ENDIF SUPPORTS_UTF8STRING}\n    procedure FromUtf8JSON(S: PAnsiChar; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil); overload; inline;\n    procedure FromUtf8JSON(S: PByte; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil); overload;\n    procedure FromJSON(const S: UnicodeString; AProgress: PJsonReaderProgressRec = nil); overload;\n    procedure FromJSON(S: PWideChar; Len: Integer = -1; AProgress: PJsonReaderProgressRec = nil); overload;\n\n    function ToJSON(Compact: Boolean = True): string; overload; inline;\n    function ToJSON(const Config: TJsonSerializationConfig; Compact: Boolean = True): string; overload;\n    {$IFDEF SUPPORTS_UTF8STRING}\n    function ToUtf8JSON(Compact: Boolean = True): UTF8String; overload; inline;\n    function ToUtf8JSON(const Config: TJsonSerializationConfig; Compact: Boolean = True): UTF8String; overload;\n    {$ENDIF SUPPORTS_UTF8STRING}\n    procedure ToUtf8JSON(var Bytes: TBytes; Compact: Boolean = True); overload; inline;\n    procedure ToUtf8JSON(var Bytes: TBytes; const Config: TJsonSerializationConfig; Compact: Boolean = True); overload;\n    // ToString() returns a compact JSON string\n    function ToString: string; override;\n\n    function Clone: TJsonBaseObject;\n\n    class function JSONToDateTime(const Value: string; ConvertToLocalTime: Boolean = True): TDateTime; static;\n    class function DateTimeToJSON(const Value: TDateTime; UseUtcTime: Boolean): string; static;\n    class function UtcDateTimeToJSON(const UtcDateTime: TDateTime): string; static;\n  end;\n\n  PJsonDataValueArray = ^TJsonDataValueArray;\n  TJsonDataValueArray = array[0..MaxInt div SizeOf(TJsonDataValue) - 1] of TJsonDataValue;\n\n  TJsonArrayEnumerator = record\n  private\n    FIndex: Integer;\n    FArray: TJsonArray;\n  public\n    constructor Create(AArray: TJsonArray);\n\n    function GetCurrent: TJsonDataValueHelper; inline;\n    function MoveNext: Boolean;\n    property Current: TJsonDataValueHelper read GetCurrent;\n  end;\n\n  // TJsonArray hold a JSON array and manages the array elements.\n  TJsonArray = class {$IFDEF USE_FAST_NEWINSTANCE}sealed{$ENDIF}(TJsonBaseObject)\n  private\n    FItems: PJsonDataValueArray;\n    FCapacity: Integer;\n    FCount: Integer;\n    function GetString(Index: Integer): string; inline;\n    function GetInt(Index: Integer): Integer; inline;\n    function GetLong(Index: Integer): Int64; inline;\n    function GetULong(Index: Integer): UInt64; inline;\n    function GetFloat(Index: Integer): Double; inline;\n    function GetDateTime(Index: Integer): TDateTime; inline;\n    function GetUtcDateTime(Index: Integer): TDateTime; inline;\n    function GetBool(Index: Integer): Boolean; inline;\n    function GetArray(Index: Integer): TJsonArray; inline;\n    {$IFDEF BCB}\n    function GetObj(Index: Integer): TJsonObject; inline;\n    {$ELSE}\n    function GetObject(Index: Integer): TJsonObject; inline;\n    {$ENDIF BCB}\n    function GetVariant(Index: Integer): Variant; inline;\n\n    procedure SetString(Index: Integer; const Value: string); inline;\n    procedure SetInt(Index: Integer; const Value: Integer); inline;\n    procedure SetLong(Index: Integer; const Value: Int64); inline;\n    procedure SetULong(Index: Integer; const Value: UInt64); inline;\n    procedure SetFloat(Index: Integer; const Value: Double); inline;\n    procedure SetDateTime(Index: Integer; const Value: TDateTime); inline;\n    procedure SetUtcDateTime(Index: Integer; const Value: TDateTime); inline;\n    procedure SetBool(Index: Integer; const Value: Boolean); inline;\n    procedure SetArray(Index: Integer; const Value: TJsonArray); inline;\n    procedure SetObject(Index: Integer; const Value: TJsonObject); inline;\n    procedure SetVariant(Index: Integer; const Value: Variant); inline;\n\n    function GetItem(Index: Integer): PJsonDataValue; inline;\n    function GetType(Index: Integer): TJsonDataType; inline;\n    function GetValue(Index: Integer): TJsonDataValueHelper;\n\n    procedure SetValue(Index: Integer; const Value: TJsonDataValueHelper);\n    function AddItem: PJsonDataValue;\n    function InsertItem(Index: Integer): PJsonDataValue;\n\n    procedure Grow;\n    procedure InternApplyCapacity; inline;\n    procedure SetCapacity(const Value: Integer);\n    procedure SetCount(const Value: Integer);\n  protected\n    procedure InternToJSON(var Writer: TJsonOutputWriter); override;\n    class procedure RaiseListError(Index: Integer); static;\n  public\n    destructor Destroy; override;\n\n    procedure Clear;\n    procedure Delete(Index: Integer);\n    // Extract removes the object/array from the array and transfers the ownership to the caller.\n    function Extract(Index: Integer): TJsonBaseObject;\n    function ExtractArray(Index: Integer): TJsonArray;\n    function ExtractObject(Index: Integer): TJsonObject;\n    procedure Assign(ASource: TJsonArray);\n    function Clone: TJsonArray;\n\n    procedure Add(const AValue: string); overload;\n    procedure Add(const AValue: Integer); overload;\n    procedure Add(const AValue: Int64); overload;\n    procedure Add(const AValue: UInt64); overload;\n    procedure Add(const AValue: Double); overload;\n    procedure Add(const AValue: TDateTime); overload;\n    procedure AddUtcDateTime(const AValue: TDateTime);\n    procedure Add(const AValue: Boolean); overload;\n    procedure Add(const AValue: TJsonArray); overload;\n    procedure Add(const AValue: TJsonObject); overload;\n    procedure Add(const AValue: Variant); overload;\n    function AddArray: TJsonArray;\n    function AddObject: TJsonObject; overload;\n    procedure AddObject(const Value: TJsonObject); overload; inline; // makes it easier to add \"null\"\n\n    procedure Insert(Index: Integer; const AValue: string); overload;\n    procedure Insert(Index: Integer; const AValue: Integer); overload;\n    procedure Insert(Index: Integer; const AValue: Int64); overload;\n    procedure Insert(Index: Integer; const AValue: UInt64); overload;\n    procedure Insert(Index: Integer; const AValue: Double); overload;\n    procedure Insert(Index: Integer; const AValue: TDateTime); overload;\n    procedure InsertUtcDateTime(Index: Integer; const AValue: TDateTime);\n    procedure Insert(Index: Integer; const AValue: Boolean); overload;\n    procedure Insert(Index: Integer; const AValue: TJsonArray); overload;\n    procedure Insert(Index: Integer; const AValue: TJsonObject); overload;\n    procedure Insert(Index: Integer; const AValue: Variant); overload;\n    function InsertArray(Index: Integer): TJsonArray;\n    function InsertObject(Index: Integer): TJsonObject; overload;\n    procedure InsertObject(Index: Integer; const Value: TJsonObject); overload; inline; // makes it easier to insert \"null\"\n\n    function GetEnumerator: TJsonArrayEnumerator;\n    function IsNull(Index: Integer): Boolean;\n\n    property Types[Index: Integer]: TJsonDataType read GetType;\n    property Values[Index: Integer]: TJsonDataValueHelper read GetValue write SetValue; default;\n\n    // Short names\n    property S[Index: Integer]: string read GetString write SetString;\n    property I[Index: Integer]: Integer read GetInt write SetInt;\n    property L[Index: Integer]: Int64 read GetLong write SetLong;\n    property U[Index: Integer]: UInt64 read GetULong write SetULong;\n    property F[Index: Integer]: Double read GetFloat write SetFloat;\n    property D[Index: Integer]: TDateTime read GetDateTime write SetDateTime;\n    property DUtc[Index: Integer]: TDateTime read GetUtcDateTime write SetUtcDateTime;\n    property B[Index: Integer]: Boolean read GetBool write SetBool;\n    property A[Index: Integer]: TJsonArray read GetArray write SetArray;\n    property O[Index: Integer]: TJsonObject read {$IFDEF BCB}GetObj{$ELSE}GetObject{$ENDIF} write SetObject;\n    property V[Index: Integer]: Variant read GetVariant write SetVariant;\n\n    property Items[Index: Integer]: PJsonDataValue read GetItem;\n    property Count: Integer read FCount write SetCount;\n    property Capacity: Integer read FCapacity write SetCapacity;\n  end;\n\n  TJsonNameValuePair = record\n    Name: string;\n    Value: TJsonDataValueHelper;\n  end;\n\n  TJsonObjectEnumerator = record\n  private\n    FIndex: Integer;\n    FObject: TJsonObject;\n  public\n    constructor Create(AObject: TJsonObject);\n\n    function GetCurrent: TJsonNameValuePair; inline;\n    function MoveNext: Boolean;\n    property Current: TJsonNameValuePair read GetCurrent;\n  end;\n\n  // TJsonObject hold a JSON object and manages the JSON object properties\n  TJsonObject = class {$IFDEF USE_FAST_NEWINSTANCE}sealed{$ENDIF}(TJsonBaseObject)\n  private type\n    PJsonStringArray = ^TJsonStringArray;\n    TJsonStringArray = array[0..MaxInt div SizeOf(string) - 1] of string;\n  private\n    FItems: PJsonDataValueArray;\n    FNames: PJsonStringArray;\n    FCapacity: Integer;\n    FCount: Integer;\n    {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    FLastValueItem: PJsonDataValue;\n    FLastValueItemNamePtr: Pointer;\n    procedure UpdateLastValueItem(const Name: string; Item: PJsonDataValue);\n    {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    function FindItem(const Name: string; var Item: PJsonDataValue): Boolean;\n    function RequireItem(const Name: string): PJsonDataValue;\n\n    function GetString(const Name: string): string;\n    function GetBool(const Name: string): Boolean;\n    function GetInt(const Name: string): Integer;\n    function GetLong(const Name: string): Int64;\n    function GetULong(const Name: string): UInt64;\n    function GetFloat(const Name: string): Double;\n    function GetDateTime(const Name: string): TDateTime;\n    function GetUtcDateTime(const Name: string): TDateTime;\n    {$IFDEF BCB}\n    function GetObj(const Name: string): TJsonObject;\n    {$ELSE}\n    function GetObject(const Name: string): TJsonObject;\n    {$ENDIF BCB}\n    function GetArray(const Name: string): TJsonArray;\n    procedure SetString(const Name, Value: string);\n    procedure SetBool(const Name: string; const Value: Boolean);\n    procedure SetInt(const Name: string; const Value: Integer);\n    procedure SetLong(const Name: string; const Value: Int64);\n    procedure SetULong(const Name: string; const Value: UInt64);\n    procedure SetFloat(const Name: string; const Value: Double);\n    procedure SetDateTime(const Name: string; const Value: TDateTime);\n    procedure SetUtcDateTime(const Name: string; const Value: TDateTime);\n    procedure SetObject(const Name: string; const Value: TJsonObject);\n    procedure SetArray(const Name: string; const Value: TJsonArray);\n\n    function GetType(const Name: string): TJsonDataType;\n    function GetName(Index: Integer): string; inline;\n    function GetItem(Index: Integer): PJsonDataValue; inline;\n    procedure SetValue(const Name: string; const Value: TJsonDataValueHelper);\n    function GetValue(const Name: string): TJsonDataValueHelper;\n\n    { Used from the reader, never every use them outside the reader, they may crash your strings }\n    procedure InternAdd(var AName: string; const AValue: string); overload;\n    procedure InternAdd(var AName: string; const AValue: Integer); overload;\n    procedure InternAdd(var AName: string; const AValue: Int64); overload;\n    procedure InternAdd(var AName: string; const AValue: UInt64); overload;\n    procedure InternAdd(var AName: string; const AValue: Double); overload;\n    procedure InternAdd(var AName: string; const AValue: TDateTime); overload;\n    procedure InternAdd(var AName: string; const AValue: Boolean); overload;\n    procedure InternAdd(var AName: string; const AValue: TJsonArray); overload;\n    procedure InternAdd(var AName: string; const AValue: TJsonObject); overload;\n    function InternAddArray(var AName: string): TJsonArray;\n    function InternAddObject(var AName: string): TJsonObject;\n\n    function InternAddItem(var Name: string): PJsonDataValue;\n    function AddItem(const Name: string): PJsonDataValue;\n\n    procedure Grow;\n    procedure InternApplyCapacity;\n    procedure SetCapacity(const Value: Integer);\n    function GetPath(const NamePath: string): TJsonDataValueHelper;\n    procedure SetPath(const NamePath: string; const Value: TJsonDataValueHelper);\n    function IndexOfPChar(S: PChar; Len: Integer): Integer;\n    procedure PathError(P, EndP: PChar);\n    procedure PathNullError(P, EndP: PChar);\n    procedure PathIndexError(P, EndP: PChar; Count: Integer);\n  protected\n    procedure InternToJSON(var Writer: TJsonOutputWriter); override;\n    function FindCaseInsensitiveItem(const ACaseInsensitiveName: string): PJsonDataValue;\n  public\n    destructor Destroy; override;\n    procedure Assign(ASource: TJsonObject);\n    function Clone: TJsonObject;\n\n    // ToSimpleObject() maps the JSON object properties to the Delphi object by using the object's\n    // TypeInfo.\n    // The object's class must be compiled with the $M+ compiler switch or derive from TPersistent.\n    procedure ToSimpleObject(AObject: TObject; ACaseSensitive: Boolean = True);\n    // FromSimpleObject() clears the JSON object and adds the Delphi object's properties.\n    // The object's class must be compiled with the $M+ compiler switch or derive from TPersistent.\n    procedure FromSimpleObject(AObject: TObject; ALowerCamelCase: Boolean = False);\n\n    procedure Clear;\n    procedure Remove(const Name: string);\n    procedure Delete(Index: Integer);\n    function IndexOf(const Name: string): Integer;\n    function Contains(const Name: string): Boolean;\n    // Extract removes the object/array from the object and transfers the ownership to the caller.\n    function Extract(const Name: string): TJsonBaseObject;\n    function ExtractArray(const Name: string): TJsonArray;\n    function ExtractObject(const Name: string): TJsonObject;\n\n    function GetEnumerator: TJsonObjectEnumerator;\n    function IsNull(const Name: string): Boolean;\n\n    property Types[const Name: string]: TJsonDataType read GetType;\n    property Values[const Name: string]: TJsonDataValueHelper read GetValue write SetValue; default;\n\n    // Short names\n    property S[const Name: string]: string read GetString write SetString;        // returns '' if property doesn't exist, auto type-cast except for array/object\n    property I[const Name: string]: Integer read GetInt write SetInt;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property L[const Name: string]: Int64 read GetLong write SetLong;             // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property U[const Name: string]: UInt64 read GetULong write SetULong;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property F[const Name: string]: Double read GetFloat write SetFloat;          // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property D[const Name: string]: TDateTime read GetDateTime write SetDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property DUtc[const Name: string]: TDateTime read GetUtcDateTime write SetUtcDateTime; // returns 0 if property doesn't exist, auto type-cast except for array/object\n    property B[const Name: string]: Boolean read GetBool write SetBool;           // returns false if property doesn't exist, auto type-cast with \"<>'true'\" and \"<>0\" except for array/object\n    property A[const Name: string]: TJsonArray read GetArray write SetArray;      // auto creates array on first access\n    property O[const Name: string]: TJsonObject read {$IFDEF BCB}GetObj{$ELSE}GetObject{$ENDIF} write SetObject;   // auto creates object on first access\n\n    property Path[const NamePath: string]: TJsonDataValueHelper read GetPath write SetPath;\n\n    // Indexed access to the named properties\n    property Names[Index: Integer]: string read GetName;\n    property Items[Index: Integer]: PJsonDataValue read GetItem;\n    property Count: Integer read FCount;\n    property Capacity: Integer read FCapacity write SetCapacity;\n  end;\n\n  // Rename classes because RTL classes have the same name\n  TJDOJsonBaseObject = TJsonBaseObject;\n  TJDOJsonObject = TJsonObject;\n  TJDOJsonArray = TJsonArray;\n\nvar\n  JsonSerializationConfig: TJsonSerializationConfig = ( // not thread-safe\n    LineBreak: #10;\n    IndentChar: #9;\n    UseUtcTime: True;\n    EscapeAllNonASCIIChars: False;  // If True all characters >= #128 will be escaped when generating the JSON string\n    NullConvertsToValueTypes: False;  // If True and an object is nil/null, a convertion to String, Int, Long, Float, DateTime, Boolean will return ''/0/False\n  );\n\nimplementation\n\nuses\n  {$IFDEF HAS_UNIT_SCOPE}\n    {$IFDEF MSWINDOWS}\n  Winapi.Windows,\n    {$ELSE}\n  System.DateUtils,\n    {$ENDIF MSWINDOWS}\n  System.Variants, System.RTLConsts, System.TypInfo, System.Math, System.SysConst;\n\n  {$ELSE}\n\n    {$IFDEF MSWINDOWS}\n  Windows,\n    {$ELSE}\n  DateUtils,\n    {$ENDIF MSWINDOWS}\n  Variants, RTLConsts, TypInfo, Math, SysConst;\n  {$ENDIF HAS_UNIT_SCOPE}\n\n{$IF SizeOf(LongWord) <> 4}\n// Make LongWord on all platforms a UInt32.\ntype\n  LongWord = UInt32;\n  PLongWord = ^LongWord;\n{$IFEND}\n\nresourcestring\n  RsUnsupportedFileEncoding = 'File encoding is not supported';\n  RsUnexpectedEndOfFile = 'Unexpected end of file where %s was expected';\n  RsUnexpectedToken = 'Expected %s but found %s';\n  RsInvalidStringCharacter = 'Invalid character in string';\n  RsStringNotClosed = 'String not closed';\n  RsInvalidHexNumber = 'Invalid hex number \"%s\"';\n  RsTypeCastError = 'Cannot cast %s into %s';\n  RsMissingClassInfo = 'Class \"%s\" doesn''t have type information. {$M+} was not specified';\n  RsInvalidJsonPath = 'Invalid JSON path \"%s\"';\n  RsJsonPathContainsNullValue = 'JSON path contains null value (\"%s\")';\n  RsJsonPathIndexError = 'JSON path index out of bounds (%d) \"%s\"';\n  RsVarTypeNotSupported = 'VarType %d is not supported';\n  {$IFDEF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n    {$IFDEF DEBUG}\n  //RsInternAsgStringUsageError = 'InternAsgString was called on a string literal';\n    {$ENDIF DEBUG}\n  {$ENDIF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n\ntype\n  TJsonTokenKind = (\n    jtkEof, jtkInvalidSymbol,\n    jtkLBrace, jtkRBrace, jtkLBracket, jtkRBracket, jtkComma, jtkColon,\n    jtkIdent,\n    jtkValue, jtkString, jtkInt, jtkLong, jtkULong, jtkFloat, jtkTrue, jtkFalse, jtkNull\n  );\n\nconst\n  JsonTokenKindToStr: array[TJsonTokenKind] of string = (\n    'end of file', 'invalid symbol',\n    '\"{\"', '\"}\"', '\"[\"', '\"]\"', '\",\"', '\":\"',\n    'identifier',\n    'value', 'value', 'value', 'value', 'value', 'value', 'value', 'value', 'value'\n  );\n\n  Power10: array[0..18] of Double = (\n    1E0, 1E1, 1E2, 1E3, 1E4, 1E5, 1E6, 1E7, 1E8, 1E9,\n    1E10, 1E11, 1E12, 1E13, 1E14, 1E15, 1E16, 1E17, 1E18\n  );\n\n  // XE7 broke string literal collapsing\nvar\n  sTrue: string = 'true';\n  sFalse: string = 'false';\nconst\n  sNull = 'null';\n  sQuoteChar = '\"';\n\n  {$IF not declared(varObject)}\n  varObject = $0049;\n  {$IFEND}\n\ntype\n  PStrRec = ^TStrRec;\n  TStrRec = packed record\n    {$IF defined(CPUX64) or defined(CPU64BITS)} // XE2-XE7 (CPUX64), XE8+ (CPU64BITS)\n    _Padding: Integer;\n    {$IFEND}\n    CodePage: Word;\n    ElemSize: Word;\n    RefCnt: Integer;\n    Length: Integer;\n  end;\n\n  // TEncodingStrictAccess gives us access to the strict protected functions which are much easier\n  // to use with TJsonStringBuilder than converting FData to a dynamic TCharArray.\n  TEncodingStrictAccess = class(TEncoding)\n  public\n    function GetByteCountEx(Chars: PChar; CharCount: Integer): Integer; inline;\n    function GetBytesEx(Chars: PChar; CharCount: Integer; Bytes: PByte; ByteCount: Integer): Integer; inline;\n    function GetCharCountEx(Bytes: PByte; ByteCount: Integer): Integer; inline;\n    function GetCharsEx(Bytes: PByte; ByteCount: Integer; Chars: PChar; CharCount: Integer): Integer; inline;\n  end;\n\n  {$IFDEF USE_STRINGINTERN_FOR_NAMES}\n  TStringIntern = record\n  private type\n    PJsonStringEntry = ^TJsonStringEntry;\n    TJsonStringEntry = record\n      Next: Integer;\n      Hash: Integer;\n      Name: string;\n    end;\n\n    PJsonStringEntryArray = ^TJsonStringEntryArray;\n    TJsonStringEntryArray = array[0..MaxInt div SizeOf(TJsonStringEntry) - 1] of TJsonStringEntry;\n\n    PJsonIntegerArray = ^TJsonIntegerArray;\n    TJsonIntegerArray = array[0..MaxInt div SizeOf(Integer) - 1] of Integer;\n  private\n    FStrings: PJsonStringEntryArray;\n    FBuckets: PJsonIntegerArray;\n    FCapacity: Integer;\n    FCount: Integer;\n    class function GetHash(const Name: string): Integer; static;\n    procedure Grow;\n    function Find(Hash: Integer; const S: string): Integer;\n    procedure InternAdd(AHash: Integer; const S: string);\n  public\n    procedure Init;\n    procedure Done;\n    procedure Intern(var S: string; var PropName: string);\n  end;\n  {$ENDIF USE_STRINGINTERN_FOR_NAMES}\n\n  TJsonToken = record\n    Kind: TJsonTokenKind;\n    S: string; // jtkIdent/jtkString\n    case Integer of\n      0: (I: Integer; HI: Integer);\n      1: (L: Int64);\n      2: (U: UInt64);\n      3: (F: Double);\n  end;\n\n  TJsonReader = class(TObject)\n  private\n    {$IFDEF USE_STRINGINTERN_FOR_NAMES}\n    FIdents: TStringIntern;\n    {$ENDIF USE_STRINGINTERN_FOR_NAMES}\n    FPropName: string;\n    procedure Accept(TokenKind: TJsonTokenKind);\n    procedure ParseObjectBody(const Data: TJsonObject);\n    procedure ParseObjectProperty(const Data: TJsonObject);\n    procedure ParseObjectPropertyValue(const Data: TJsonObject);\n    procedure ParseArrayBody(const Data: TJsonArray);\n    procedure ParseArrayPropertyValue(const Data: TJsonArray);\n    procedure AcceptFailed(TokenKind: TJsonTokenKind);\n  protected\n    FLook: TJsonToken;\n    FLineNum: Integer;\n    FStart: Pointer;\n    FLineStart: Pointer;\n    FLastProgressValue: NativeInt;\n    FSize: NativeInt;\n    FProgress: PJsonReaderProgressRec;\n    procedure CheckProgress(Position: Pointer);\n    function GetLineColumn: NativeInt;\n    function GetPosition: NativeInt;\n    function GetCharOffset(StartPos: Pointer): NativeInt; virtual; abstract;\n    function Next: Boolean; virtual; abstract;\n\n    class procedure InvalidStringCharacterError(const Reader: TJsonReader); static;\n    class procedure StringNotClosedError(const Reader: TJsonReader); static;\n    class procedure JSONStrToStr(P, EndP: PChar; FirstEscapeIndex: Integer; var S: string;\n      const Reader: TJsonReader); static;\n    class procedure JSONUtf8StrToStr(P, EndP: PByte; FirstEscapeIndex: Integer; var S: string;\n      const Reader: TJsonReader); static;\n  public\n    {$IFDEF USE_FAST_NEWINSTANCE}\n    class function NewInstance: TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF}; override;\n    procedure FreeInstance; override;\n    {$ENDIF USE_FAST_NEWINSTANCE}\n\n    constructor Create(AStart: Pointer; ASize: NativeInt; AProgress: PJsonReaderProgressRec);\n    destructor Destroy; override;\n    procedure Parse(Data: TJsonBaseObject);\n  end;\n\n  TUtf8JsonReader = class sealed(TJsonReader)\n  private\n    FText: PByte;\n    FTextEnd: PByte;\n  protected\n    function GetCharOffset(StartPos: Pointer): NativeInt; override; final;\n    function Next: Boolean; override; final;\n    // ARM optimization: Next() already has EndP in a local variable so don't use the slow indirect\n    // access to FTextEnd.\n    procedure LexString(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\n    procedure LexNumber(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\n    procedure LexIdent(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\n  public\n    constructor Create(S: PByte; Len: NativeInt; AProgress: PJsonReaderProgressRec);\n  end;\n\n  TStringJsonReader = class sealed(TJsonReader)\n  private\n    FText: PChar;\n    FTextEnd: PChar;\n  protected\n    function GetCharOffset(StartPos: Pointer): NativeInt; override; final;\n    function Next: Boolean; override; final;\n    // ARM optimization: Next() already has EndP in a local variable so don't use the slow indirect\n    // access to FTextEnd.\n    procedure LexString(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\n    procedure LexNumber(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\n    procedure LexIdent(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\n  public\n    constructor Create(S: PChar; Len: Integer; AProgress: PJsonReaderProgressRec);\n  end;\n\n  TMemoryStreamAccess = class(TMemoryStream);\n\n  {$IFDEF SUPPORTS_UTF8STRING}\n  TJsonUTF8StringStream = class(TMemoryStream)\n  private\n    FDataString: UTF8String;\n  protected\n    function Realloc(var NewCapacity: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND}): Pointer; override;\n  public\n    constructor Create;\n    property DataString: UTF8String read FDataString;\n  end;\n  {$ENDIF SUPPORTS_UTF8STRING}\n\n  TJsonBytesStream = class(TMemoryStream)\n  private\n    FBytes: TBytes;\n  protected\n    function Realloc(var NewCapacity: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND}): Pointer; override;\n  public\n    constructor Create;\n    property Bytes: TBytes read FBytes;\n  end;\n\nvar\n  JSONFormatSettings: TFormatSettings;\n  {$IFDEF USE_NAME_STRING_LITERAL}\n  JsonMemInfoInitialized: Boolean = False;\n  JsonMemInfoBlockStart: PByte = nil;\n  JsonMemInfoBlockEnd: PByte = nil;\n  JsonMemInfoMainBlockStart: PByte = nil;\n  JsonMemInfoMainBlockEnd: PByte = nil;\n  {$ENDIF USE_NAME_STRING_LITERAL}\n\n{$IFDEF MSWINDOWS}\n\n  {$IFDEF SUPPORT_WINDOWS2000}\nvar\n  TzSpecificLocalTimeToSystemTime: function(lpTimeZoneInformation: PTimeZoneInformation;\n    var lpLocalTime, lpUniversalTime: TSystemTime): BOOL; stdcall;\n\nfunction TzSpecificLocalTimeToSystemTimeWin2000(lpTimeZoneInformation: PTimeZoneInformation;\n  var lpLocalTime, lpUniversalTime: TSystemTime): BOOL; stdcall;\nvar\n  TimeZoneInfo: TTimeZoneInformation;\nbegin\n  if lpTimeZoneInformation <> nil then\n    TimeZoneInfo := lpTimeZoneInformation^\n  else\n    GetTimeZoneInformation(TimeZoneInfo);\n\n  // Reverse the bias so that SystemTimeToTzSpecificLocalTime becomes TzSpecificLocalTimeToSystemTime\n  TimeZoneInfo.Bias := -TimeZoneInfo.Bias;\n  TimeZoneInfo.StandardBias := -TimeZoneInfo.StandardBias;\n  TimeZoneInfo.DaylightBias := -TimeZoneInfo.DaylightBias;\n\n  Result := SystemTimeToTzSpecificLocalTime(@TimeZoneInfo, lpLocalTime, lpUniversalTime);\nend;\n  {$ELSE}\nfunction TzSpecificLocalTimeToSystemTime(lpTimeZoneInformation: PTimeZoneInformation;\n  var lpLocalTime, lpUniversalTime: TSystemTime): BOOL; stdcall;\n  external kernel32 name 'TzSpecificLocalTimeToSystemTime';\n  {$ENDIF SUPPORT_WINDOWS2000}\n\n{$ENDIF MSWINDOWS}\n\n{$IFDEF USE_NAME_STRING_LITERAL}\nprocedure InitializeJsonMemInfo;\nvar\n  MemInfo: TMemoryBasicInformation;\nbegin\n  JsonMemInfoInitialized := True;\n  if VirtualQuery(PByte(HInstance + $1000), MemInfo, SizeOf(MemInfo)) = SizeOf(MemInfo) then\n  begin\n    JsonMemInfoBlockStart := MemInfo.AllocationBase;\n    JsonMemInfoBlockEnd := JsonMemInfoBlockStart + MemInfo.RegionSize;\n  end;\n  if HInstance <> MainInstance then\n  begin\n    if VirtualQuery(PByte(MainInstance + $1000), MemInfo, SizeOf(MemInfo)) = SizeOf(MemInfo) then\n    begin\n      JsonMemInfoMainBlockStart := MemInfo.AllocationBase;\n      JsonMemInfoMainBlockEnd := JsonMemInfoMainBlockStart + MemInfo.RegionSize;\n    end;\n  end;\nend;\n{$ENDIF USE_NAME_STRING_LITERAL}\n\ntype\n  PDynArrayRec = ^TDynArrayRec;\n  TDynArrayRec = packed record\n    {$IF defined(CPUX64) or defined(CPU64BITS)} // XE2-XE7 (CPUX64), XE8+ (CPU64BITS)\n    _Padding: Integer;\n    {$IFEND}\n    RefCnt: Integer;\n    Length: NativeInt;\n    Data: record end;\n  end;\n\nprocedure ByteArraySetLengthUninit(var A: TBytes; Count: Integer);\nvar\n  P: PDynArrayRec;\nbegin\n  if A = nil then\n  begin\n    if Count > 0 then\n    begin\n      GetMem(Pointer(P), SizeOf(TDynArrayRec) + Count * SizeOf(Byte));\n      P.RefCnt := 1;\n      P.Length := Count;\n      Pointer(A) := @P.Data;\n    end;\n  end\n  else if Count <= 0 then\n  begin\n    P := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec));\n    //if InterlockedDecrement(P.RefCnt) = 0 then\n    Dec(P.RefCnt);\n    if P.RefCnt = 0 then\n      FreeMem(P);\n    Pointer(A) := nil;\n  end\n  else\n  begin\n    P := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec));\n    if P.RefCnt = 1 then\n    begin\n      ReallocMem(Pointer(P), SizeOf(TDynArrayRec) + Count * SizeOf(Byte));\n      P.Length := Count;\n      Pointer(A) := @P.Data;\n    end\n    else\n    begin\n      GetMem(Pointer(P), SizeOf(TDynArrayRec) + Count * SizeOf(Integer));\n      Move(A[0], P.Data, PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec)).Length * SizeOf(Byte));\n      P.RefCnt := 1;\n      P.Length := Count;\n      Pointer(A) := @P.Data;\n    end;\n  end;\nend;\n\n{ EJsonParserSyntaxException }\n\nconstructor EJsonParserException.CreateResFmt(ResStringRec: PResStringRec; const Args: array of const;\n  ALineNum, AColumn, APosition: NativeInt);\nbegin\n  inherited CreateResFmt(ResStringRec, Args);\n  FLineNum := ALineNum;\n  FColumn := AColumn;\n  FPosition := APosition;\n  if FLineNum > 0 then\n    Message := Format('%s (%d, %d)', [Message, FLineNum, FColumn]);\nend;\n\nconstructor EJsonParserException.CreateRes(ResStringRec: PResStringRec; ALineNum, AColumn, APosition: NativeInt);\nbegin\n  inherited CreateRes(ResStringRec);\n  FLineNum := ALineNum;\n  FColumn := AColumn;\n  FPosition := APosition;\n  if FLineNum > 0 then\n    Message := Format('%s (%d, %d)', [Message, FLineNum, FColumn]);\nend;\n\nprocedure ListError(Msg: PResStringRec; Data: Integer);\nbegin\n  raise EStringListError.CreateFmt(LoadResString(Msg), [Data])\n        {$IFDEF HAS_RETURN_ADDRESS} at ReturnAddress{$ENDIF};\nend;\n\nprocedure ErrorNoMappingForUnicodeCharacter;\nbegin\n  {$IF not declared(SNoMappingForUnicodeCharacter)}\n  RaiseLastOSError;\n  {$ELSE}\n  raise EEncodingError.CreateRes(@SNoMappingForUnicodeCharacter)\n        {$IFDEF HAS_RETURN_ADDRESS} at ReturnAddress{$ENDIF};\n  {$IFEND}\nend;\n\nprocedure ErrorUnsupportedVariantType(VarType: TVarType);\nbegin\n  raise EJsonCastException.CreateResFmt(@RsVarTypeNotSupported, [VarType]);\nend;\n\n{$IFDEF USE_NAME_STRING_LITERAL}\nprocedure AsgString(var Dest: string; const Source: string);\nbegin\n  if (Pointer(Source) <> nil) and (PInteger(@PByte(Source)[-8])^ = -1) and // string literal\n     (((PByte(Source) < JsonMemInfoBlockEnd) and (PByte(Source) >= JsonMemInfoBlockStart)) or\n      ((PByte(Source) < JsonMemInfoMainBlockEnd) and (PByte(Source) >= JsonMemInfoMainBlockStart))) then\n  begin\n    // Save memory by just using the string literal but only if it is in the EXE's or this DLL's\n    // code segment. Otherwise the memory could be released by a FreeLibrary call without us knowning.\n    Pointer(Dest) := Pointer(Source);\n  end\n  else\n    Dest := Source;\nend;\n{$ENDIF USE_NAME_STRING_LITERAL}\n\n{$IFDEF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n  {$IFDEF DEBUG}\n//procedure InternAsgStringUsageError;\n//begin\n//  raise EJsonException.CreateRes(@RsInternAsgStringUsageError);\n//end;\n  {$ENDIF DEBUG}\n{$ENDIF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n\nprocedure AnsiLowerCamelCaseString(var S: string);\nbegin\n  S := AnsiLowerCase(PChar(S)^) + Copy(S, 2);\nend;\n\n{$IF not declared(TryStrToUInt64)}\nfunction TryStrToUInt64(const S: string; out Value: UInt64): Boolean;\nvar\n  P, EndP: PChar;\n  V: UInt64;\n  Digit: Integer;\nbegin\n  // No support for hexadecimal strings\n\n  P := PChar(S);\n  EndP := P + Length(S);\n  // skip spaces\n  while (P < EndP) and (P^ = ' ') do\n    Inc(P);\n  if P^ = '-' then\n    Result := False // UInt64 cannot be negative\n  else\n  begin\n    V := 0;\n    while P < EndP do\n    begin\n      Digit := Integer(Ord(P^)) - Ord('0');\n      if (Cardinal(Digit) >= 10) or (V > High(UInt64) div 10) then\n        Break;\n      //V := V * 10 + Digit;\n      V := (V shl 3) + (V shl 1) + Digit;\n      Inc(P);\n    end;\n\n    Result := P = EndP;\n    if Result then\n      Value := V;\n  end;\nend;\n{$IFEND}\n\nfunction GetHexDigitsUtf8(P: PByte; Count: Integer; const Reader: TJsonReader): LongWord;\nvar\n  Ch: Byte;\nbegin\n  Result := 0;\n  while Count > 0 do\n  begin\n    Ch := P^;\n    case P^ of\n      Ord('0')..Ord('9'): Result := (Result shl 4) or LongWord(Ch - Ord('0'));\n      Ord('A')..Ord('F'): Result := (Result shl 4) or LongWord(Ch - (Ord('A') - 10));\n      Ord('a')..Ord('f'): Result := (Result shl 4) or LongWord(Ch - (Ord('a') - 10));\n    else\n      Break;\n    end;\n    Inc(P);\n    Dec(Count);\n  end;\n  if Count > 0 then\n    raise EJsonParserException.CreateResFmt(@RsInvalidHexNumber, [P^], Reader.FLineNum, Reader.GetLineColumn, Reader.GetPosition);\nend;\n\nfunction GetHexDigits(P: PChar; Count: Integer; const Reader: TJsonReader): LongWord;\nvar\n  Ch: Char;\nbegin\n  Result := 0;\n  while Count > 0 do\n  begin\n    Ch := P^;\n    case P^ of\n      '0'..'9': Result := (Result shl 4) or LongWord(Ord(Ch) - Ord('0'));\n      'A'..'F': Result := (Result shl 4) or LongWord(Ord(Ch) - (Ord('A') - 10));\n      'a'..'f': Result := (Result shl 4) or LongWord(Ord(Ch) - (Ord('a') - 10));\n    else\n      Break;\n    end;\n    Inc(P);\n    Dec(Count);\n  end;\n  if Count > 0 then\n    raise EJsonParserException.CreateResFmt(@RsInvalidHexNumber, [P^], Reader.FLineNum, Reader.GetLineColumn, Reader.GetPosition);\nend;\n\nfunction UtcDateTimeToLocalDateTime(UtcDateTime: TDateTime): TDateTime;\n{$IFDEF MSWINDOWS}\nvar\n  UtcTime, LocalTime: TSystemTime;\nbegin\n  DateTimeToSystemTime(UtcDateTime, UtcTime);\n  if SystemTimeToTzSpecificLocalTime(nil, UtcTime, LocalTime) then\n    Result := SystemTimeToDateTime(LocalTime)\n  else\n    Result := UtcDateTime;\nend;\n{$ELSE}\nbegin\n  Result := TTimeZone.Local.ToLocalTime(UtcDateTime);\nend;\n{$ENDIF MSWINDOWS}\n\nfunction LocalDateTimeToUtcDateTime(DateTime: TDateTime): TDateTime;\n{$IFDEF MSWINDOWS}\nvar\n  UtcTime, LocalTime: TSystemTime;\nbegin\n  DateTimeToSystemTime(DateTime, LocalTime);\n  if TzSpecificLocalTimeToSystemTime(nil, LocalTime, UtcTime) then\n    Result := SystemTimeToDateTime(UtcTime)\n  else\n    Result := DateTime;\nend;\n{$ELSE}\nbegin\n  Result := TTimeZone.Local.ToUniversalTime(DateTime);\nend;\n{$ENDIF MSWINDOWS}\n\nfunction DateTimeToISO8601(Value: TDateTime): string;\n{$IFDEF MSWINDOWS}\nvar\n  LocalTime, UtcTime: TSystemTime;\n  Offset: TDateTime;\n  Hour, Min, Sec, MSec: Word;\nbegin\n  DateTimeToSystemTime(Value, LocalTime);\n  Result := Format('%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%d',\n    [LocalTime.wYear, LocalTime.wMonth, LocalTime.wDay,\n     LocalTime.wHour, LocalTime.wMinute, LocalTime.wSecond, LocalTime.wMilliseconds]);\n  if TzSpecificLocalTimeToSystemTime(nil, LocalTime, UtcTime) then\n  begin\n    Offset := Value - SystemTimeToDateTime(UtcTime);\n    DecodeTime(Offset, Hour, Min, Sec, MSec);\n    if Offset < 0 then\n      Result := Format('%s-%.2d:%.2d', [Result, Hour, Min])\n    else if Offset > 0 then\n      Result := Format('%s+%.2d:%.2d', [Result, Hour, Min])\n    else\n      Result := Result + 'Z';\n  end;\nend;\n{$ELSE}\nvar\n  Offset: TDateTime;\n  Year, Month, Day, Hour, Minute, Second, Milliseconds: Word;\nbegin\n  DecodeDate(Value, Year, Month, Day);\n  DecodeTime(Value, Hour, Minute, Second, MilliSeconds);\n  Result := Format('%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%d', [Year, Month, Day, Hour, Minute, Second, Milliseconds]);\n  Offset := Value - TTimeZone.Local.ToUniversalTime(Value);\n  DecodeTime(Offset, Hour, Minute, Second, MilliSeconds);\n  if Offset < 0 then\n    Result := Format('%s-%.2d:%.2d', [Result, Hour, Minute])\n  else if Offset > 0 then\n    Result := Format('%s+%.2d:%.2d', [Result, Hour, Minute])\n  else\n    Result := Result + 'Z';\nend;\n{$ENDIF MSWINDOWS}\n\nfunction ParseDateTimePart(P: PChar; var Value: Integer; MaxLen: Integer): PChar;\nvar\n  V: Integer;\nbegin\n  Result := P;\n  V := 0;\n  while (Result^ in ['0'..'9']) and (MaxLen > 0) do\n  begin\n    V := V * 10 + (Ord(Result^) - Ord('0'));\n    Inc(Result);\n    Dec(MaxLen);\n  end;\n  Value := V;\nend;\n\nfunction VarTypeToJsonDataType(AVarType: TVarType): TJsonDataType;\nbegin\n  case AVarType of\n    varNull:\n      Result := jdtObject;\n    varOleStr, varString, varUString:\n      Result := jdtString;\n    varSmallInt, varInteger, varShortInt, varByte, varWord, varLongWord:\n      Result := jdtInt;\n    varInt64:\n      Result := jdtLong;\n    varUInt64:\n      Result := jdtULong;\n    varSingle, varDouble, varCurrency:\n      Result := jdtFloat;\n    varDate:\n      Result := jdtDateTime;\n    varBoolean:\n      Result := jdtBool;\n  else\n    ErrorUnsupportedVariantType(AVarType);\n    Result := jdtNone;\n  end;\nend;\n\n{$IFDEF NEXTGEN}\nfunction Utf8StrLen(P: PByte): Integer;\nbegin\n  Result := 0;\n  if P <> nil then\n    while P[Result] <> 0 do\n      Inc(Result);\nend;\n{$ENDIF NEXTGEN}\n\nprocedure SetStringUtf8(var S: string; P: PByte; Len: Integer);\nvar\n  L: Integer;\nbegin\n  if S <> '' then\n    S := '';\n  if (P = nil) or (Len = 0) then\n    Exit;\n  SetLength(S, Len);\n\n  L := Utf8ToUnicode(PWideChar(Pointer(S)), Len + 1, PAnsiChar(P), Len);\n  if L > 0 then\n  begin\n    if L - 1 <> Len then\n      SetLength(S, L - 1);\n  end\n  else\n    S := '';\nend;\n\nprocedure AppendString(var S: string; P: PChar; Len: Integer);\nvar\n  OldLen: Integer;\nbegin\n  if (P = nil) or (Len = 0) then\n    Exit;\n  OldLen := Length(S);\n  SetLength(S, OldLen + Len);\n  Move(P^, PChar(Pointer(S))[OldLen], Len * SizeOf(Char));\nend;\n\nprocedure AppendStringUtf8(var S: string; P: PByte; Len: Integer);\nvar\n  L, OldLen: Integer;\nbegin\n  if (P = nil) or (Len = 0) then\n    Exit;\n  OldLen := Length(S);\n  SetLength(S, OldLen + Len);\n\n  L := Utf8ToUnicode(PWideChar(Pointer(S)) + OldLen, Len + 1, PAnsiChar(P), Len);\n  if L > 0 then\n  begin\n    if L - 1 <> Len then\n      SetLength(S, OldLen + L - 1);\n  end\n  else\n    SetLength(S, OldLen);\nend;\n\n{ TJsonSerializationConfig }\n\nprocedure TJsonSerializationConfig.InitDefaults;\nbegin\n  LineBreak := #10;\n  IndentChar := #9;\n  UseUtcTime := True;\n  EscapeAllNonASCIIChars := False;\n  NullConvertsToValueTypes := False;\nend;\n\nclass function TJsonSerializationConfig.Default: TJsonSerializationConfig;\nbegin\n  Result.InitDefaults;\nend;\n\n{ TJsonReaderProgressRec }\n\nfunction TJsonReaderProgressRec.Init(AProgress: TJsonReaderProgressProc; AData: Pointer = nil; AThreshold: NativeInt = 0): PJsonReaderProgressRec;\nbegin\n  Self.Data := AData;\n  Self.Threshold := AThreshold;\n  Self.Progress := AProgress;\n  Result := @Self;\nend;\n\n{ TJsonReader }\n\n{$IFDEF USE_FAST_NEWINSTANCE}\nclass function TJsonReader.NewInstance: TObject;\nbegin\n  GetMem(Pointer(Result), InstanceSize);\n  PPointer(Result)^ := Self;\n  {$IFDEF AUTOREFCOUNT}\n  TJsonReader(Result).FRefCount := 1;\n  {$ENDIF AUTOREFCOUNT}\nend;\n\nprocedure TJsonReader.FreeInstance;\nbegin\n  // We have no WeakRef => faster cleanup\n  FreeMem(Pointer(Self));\nend;\n{$ENDIF ~USE_FAST_NEWINSTANCE}\n\nconstructor TJsonReader.Create(AStart: Pointer; ASize: NativeInt; AProgress: PJsonReaderProgressRec);\nbegin\n  //inherited Create;\n  {$IFDEF USE_FAST_NEWINSTANCE}\n  Pointer(FPropName) := nil;\n  Pointer(FLook.S) := nil;\n  {$ENDIF USE_FAST_NEWINSTANCE}\n  {$IFDEF USE_STRINGINTERN_FOR_NAMES}\n  FIdents.Init;\n  {$ENDIF USE_STRINGINTERN_FOR_NAMES}\n\n  FStart := AStart;\n  FLineNum := 1; // base 1\n  FLineStart := nil;\n\n  FSize := ASize;\n  FProgress := AProgress;\n  FLastProgressValue := 0; // class is not zero-filled\n  if (FProgress <> nil) and Assigned(FProgress.Progress) then\n    FProgress.Progress(FProgress.Data, 0, 0, FSize);\nend;\n\ndestructor TJsonReader.Destroy;\nbegin\n  {$IFDEF USE_FAST_NEWINSTANCE}\n  FPropName := '';\n  FLook.S := '';\n  {$ENDIF USE_FAST_NEWINSTANCE}\n  {$IFDEF USE_STRINGINTERN_FOR_NAMES}\n  FIdents.Done;\n  {$ENDIF USE_STRINGINTERN_FOR_NAMES}\n\n  if (FLook.Kind = jtkEof) and (FProgress <> nil) and Assigned(FProgress.Progress) then\n    FProgress.Progress(FProgress.Data, 100, FSize, FSize);\n  //inherited Destroy;\nend;\n\nprocedure TJsonReader.CheckProgress(Position: Pointer);\nvar\n  NewPercentage: NativeInt;\n  Ps: NativeInt;\nbegin\n  if {(FProgress <> nil) and} Assigned(FProgress.Progress) then\n  begin\n    Ps := PByte(Position) - PByte(FStart);\n    if FProgress.Threshold = 0 then\n    begin\n      NewPercentage := Ps * 100 div FSize;\n      if NewPercentage <> FLastProgressValue then\n      begin\n        FLastProgressValue := NewPercentage;\n        FProgress.Progress(FProgress.Data, NewPercentage, Ps, FSize);\n      end;\n    end\n    else if FProgress.Threshold > 0 then\n    begin\n      if Ps - FLastProgressValue >= FProgress.Threshold then\n      begin\n        FLastProgressValue := Ps;\n        NewPercentage := 0;\n        if FSize > 0 then\n          NewPercentage := Ps * 100 div FSize;\n        FProgress.Progress(FProgress.Data, NewPercentage, Ps, FSize);\n      end;\n    end;\n  end;\nend;\n\nfunction TJsonReader.GetLineColumn: NativeInt;\nbegin\n  if FLineStart = nil then\n    FLineStart := FStart;\n  Result := GetCharOffset(FLineStart) + 1; // base 1\nend;\n\nfunction TJsonReader.GetPosition: NativeInt;\nbegin\n  Result := GetCharOffset(FStart);\nend;\n\nclass procedure TJsonReader.InvalidStringCharacterError(const Reader: TJsonReader);\nbegin\n  raise EJsonParserException.CreateRes(@RsInvalidStringCharacter,\n    Reader.FLineNum, Reader.GetLineColumn, Reader.GetPosition);\nend;\n\nclass procedure TJsonReader.StringNotClosedError(const Reader: TJsonReader);\nbegin\n  raise EJsonParserException.CreateRes(@RsStringNotClosed,\n    Reader.FLineNum, Reader.GetLineColumn, Reader.GetPosition);\nend;\n\nclass procedure TJsonReader.JSONStrToStr(P, EndP: PChar; FirstEscapeIndex: Integer; var S: string;\n  const Reader: TJsonReader);\nconst\n  MaxBufPos = 127;\nvar\n  Buf: array[0..MaxBufPos] of Char;\n  F: PChar;\n  BufPos, Len: Integer;\nbegin\n  Dec(FirstEscapeIndex);\n\n  if FirstEscapeIndex > 0 then\n  begin\n    SetString(S, P, FirstEscapeIndex);\n    Inc(P, FirstEscapeIndex);\n  end\n  else\n    S := '';\n\n  while True do\n  begin\n    BufPos := 0;\n    while (P < EndP) and (P^ = '\\') do\n    begin\n      Inc(P);\n      if P = EndP then // broken escaped character\n        Break;\n      case P^ of\n        '\"': Buf[BufPos] := '\"';\n        '\\': Buf[BufPos] := '\\';\n        '/': Buf[BufPos] := '/';\n        'b': Buf[BufPos] := #8;\n        'f': Buf[BufPos] := #12;\n        'n': Buf[BufPos] := #10;\n        'r': Buf[BufPos] := #13;\n        't': Buf[BufPos] := #9;\n        'u':\n          begin\n            Inc(P);\n            if P + 3 >= EndP then\n              Break;\n            Buf[BufPos] := Char(GetHexDigits(P, 4, TJsonReader(Reader)));\n            Inc(P, 3);\n          end;\n      else\n        Break;\n      end;\n      Inc(P);\n\n      Inc(BufPos);\n      if BufPos > MaxBufPos then\n      begin\n        Len := Length(S);\n        SetLength(S, Len + BufPos);\n        Move(Buf[0], PChar(Pointer(S))[Len], BufPos * SizeOf(Char));\n        BufPos := 0;\n      end;\n    end;\n    // append remaining buffer\n    if BufPos > 0 then\n    begin\n      Len := Length(S);\n      SetLength(S, Len + BufPos);\n      Move(Buf[0], PChar(Pointer(S))[Len], BufPos * SizeOf(Char));\n    end;\n\n    // fast forward\n    F := P;\n    while (P < EndP) and (P^ <> '\\') do\n      Inc(P);\n    if P > F then\n      AppendString(S, F, P - F);\n    if P >= EndP then\n      Break;\n  end;\nend;\n\nclass procedure TJsonReader.JSONUtf8StrToStr(P, EndP: PByte; FirstEscapeIndex: Integer; var S: string;\n  const Reader: TJsonReader);\nconst\n  MaxBufPos = 127;\nvar\n  Buf: array[0..MaxBufPos] of Char;\n  F: PByte;\n  BufPos, Len: Integer;\nbegin\n  Dec(FirstEscapeIndex);\n\n  if FirstEscapeIndex > 0 then\n  begin\n    SetStringUtf8(S, P, FirstEscapeIndex);\n    Inc(P, FirstEscapeIndex);\n  end\n  else\n    S := '';\n\n  while True do\n  begin\n    BufPos := 0;\n    while (P < EndP) and (P^ = Byte(Ord('\\'))) do\n    begin\n      Inc(P);\n      if P = EndP then // broken escaped character\n        Break;\n      case P^ of\n        Ord('\"'): Buf[BufPos] := '\"';\n        Ord('\\'): Buf[BufPos] := '\\';\n        Ord('/'): Buf[BufPos] := '/';\n        Ord('b'): Buf[BufPos] := #8;\n        Ord('f'): Buf[BufPos] := #12;\n        Ord('n'): Buf[BufPos] := #10;\n        Ord('r'): Buf[BufPos] := #13;\n        Ord('t'): Buf[BufPos] := #9;\n        Ord('u'):\n          begin\n            Inc(P);\n            if P + 3 >= EndP then\n              Break;\n            Buf[BufPos] := Char(GetHexDigitsUtf8(P, 4, TJsonReader(Reader)));\n            Inc(P, 3);\n          end;\n      else\n        Break;\n      end;\n      Inc(P);\n\n      Inc(BufPos);\n      if BufPos > MaxBufPos then\n      begin\n        Len := Length(S);\n        SetLength(S, Len + BufPos);\n        Move(Buf[0], PChar(Pointer(S))[Len], BufPos * SizeOf(Char));\n        BufPos := 0;\n      end;\n    end;\n    // append remaining buffer\n    if BufPos > 0 then\n    begin\n      Len := Length(S);\n      SetLength(S, Len + BufPos);\n      Move(Buf[0], PChar(Pointer(S))[Len], BufPos * SizeOf(Char));\n    end;\n\n    // fast forward\n    F := P;\n    while (P < EndP) and (P^ <> Byte(Ord('\\'))) do\n      Inc(P);\n    if P > F then\n      AppendStringUtf8(S, F, P - F);\n    if P >= EndP then\n      Break;\n  end;\nend;\n\nprocedure TJsonReader.Parse(Data: TJsonBaseObject);\nbegin\n  if Data is TJsonObject then\n  begin\n    TJsonObject(Data).Clear;\n    Next; // initialize Lexer\n    Accept(jtkLBrace);\n    ParseObjectBody(TJsonObject(Data));\n    Accept(jtkRBrace);\n  end\n  else if Data is TJsonArray then\n  begin\n    TJsonArray(Data).Clear;\n    Next; // initialize Lexer\n    Accept(jtkLBracket);\n    ParseArrayBody(TJsonArray(Data));\n    Accept(jtkRBracket)\n  end;\nend;\n\nprocedure TJsonReader.ParseObjectBody(const Data: TJsonObject);\n// ObjectBody ::= [ ObjectProperty [ \",\" ObjectProperty ]* ]\nbegin\n  if FLook.Kind <> jtkRBrace then\n  begin\n    while FLook.Kind <> jtkEof do\n    begin\n      ParseObjectProperty(Data);\n      if FLook.Kind = jtkRBrace then\n        Break;\n      Accept(jtkComma);\n    end;\n  end;\nend;\n\nprocedure TJsonReader.ParseObjectProperty(const Data: TJsonObject);\n// Property ::= IDENT \":\" ObjectPropertyValue\nbegin\n  if FLook.Kind >= jtkIdent then // correct JSON would be \"tkString\" only\n  begin\n    {$IFDEF USE_STRINGINTERN_FOR_NAMES}\n    FIdents.Intern(FLook.S, FPropName);\n    {$ELSE}\n    FPropName := '';\n    // transfer the string without going through UStrAsg and UStrClr\n    Pointer(FPropName) := Pointer(FLook.S);\n    Pointer(FLook.S) := nil;\n    {$ENDIF USE_STRINGINTERN_FOR_NAMES}\n    Next;\n  end\n  else\n    Accept(jtkString);\n\n  Accept(jtkColon);\n  ParseObjectPropertyValue(Data);\nend;\n\nprocedure TJsonReader.ParseObjectPropertyValue(const Data: TJsonObject);\n// ObjectPropertyValue ::= Object | Array | Value\nbegin\n  case FLook.Kind of\n    jtkLBrace:\n      begin\n        Accept(jtkLBrace);\n        ParseObjectBody(Data.InternAddObject(FPropName));\n        Accept(jtkRBrace);\n      end;\n\n    jtkLBracket:\n      begin\n        Accept(jtkLBracket);\n        ParseArrayBody(Data.InternAddArray(FPropName));\n        Accept(jtkRBracket);\n      end;\n\n    jtkNull:\n      begin\n        Data.InternAdd(FPropName, TJsonObject(nil));\n        Next;\n      end;\n\n    jtkIdent,\n    jtkString:\n      begin\n        Data.InternAddItem(FPropName).InternSetValueTransfer(FLook.S);\n        Next;\n      end;\n\n    jtkInt:\n      begin\n        Data.InternAdd(FPropName, FLook.I);\n        Next;\n      end;\n\n    jtkLong:\n      begin\n        Data.InternAdd(FPropName, FLook.L);\n        Next;\n      end;\n\n    jtkULong:\n      begin\n        Data.InternAdd(FPropName, FLook.U);\n        Next;\n      end;\n\n    jtkFloat:\n      begin\n        Data.InternAdd(FPropName, FLook.F);\n        Next;\n      end;\n\n    jtkTrue:\n      begin\n        Data.InternAdd(FPropName, True);\n        Next;\n      end;\n\n    jtkFalse:\n      begin\n        Data.InternAdd(FPropName, False);\n        Next;\n      end\n  else\n    Accept(jtkValue);\n  end;\nend;\n\nprocedure TJsonReader.ParseArrayBody(const Data: TJsonArray);\n// ArrayBody ::= [ ArrayPropertyValue [ \",\" ArrayPropertyValue ]* ]\nbegin\n  if FLook.Kind <> jtkRBracket then\n  begin\n    while FLook.Kind <> jtkEof do\n    begin\n      ParseArrayPropertyValue(Data);\n      if FLook.Kind = jtkRBracket then\n        Break;\n      Accept(jtkComma);\n    end;\n  end;\nend;\n\nprocedure TJsonReader.ParseArrayPropertyValue(const Data: TJsonArray);\n// ArrayPropertyValue ::= Object | Array | Value\nbegin\n  case FLook.Kind of\n    jtkLBrace:\n      begin\n        Accept(jtkLBrace);\n        ParseObjectBody(Data.AddObject);\n        Accept(jtkRBrace);\n      end;\n\n    jtkLBracket:\n      begin\n        Accept(jtkLBracket);\n        ParseArrayBody(Data.AddArray);\n        Accept(jtkRBracket);\n      end;\n\n    jtkNull:\n      begin\n        Data.Add(TJsonObject(nil));\n        Next;\n      end;\n\n    jtkIdent,\n    jtkString:\n      begin\n        Data.Add(FLook.S);\n        Next;\n      end;\n\n    jtkInt:\n      begin\n        Data.Add(FLook.I);\n        Next;\n      end;\n\n    jtkLong:\n      begin\n        Data.Add(FLook.L);\n        Next;\n      end;\n\n    jtkULong:\n      begin\n        Data.Add(FLook.U);\n        Next;\n      end;\n\n    jtkFloat:\n      begin\n        Data.Add(FLook.F);\n        Next;\n      end;\n\n    jtkTrue:\n      begin\n        Data.Add(True);\n        Next;\n      end;\n\n    jtkFalse:\n      begin\n        Data.Add(False);\n        Next;\n      end;\n  else\n    Accept(jtkValue);\n  end;\nend;\n\nprocedure TJsonReader.AcceptFailed(TokenKind: TJsonTokenKind);\nvar\n  Col, Position: NativeInt;\nbegin\n  Col := GetLineColumn;\n  Position := GetPosition;\n  if FLook.Kind = jtkEof then\n    raise EJsonParserException.CreateResFmt(@RsUnexpectedEndOfFile, [JsonTokenKindToStr[TokenKind]], FLineNum, Col, Position);\n  raise EJsonParserException.CreateResFmt(@RsUnexpectedToken, [JsonTokenKindToStr[TokenKind], JsonTokenKindToStr[FLook.Kind]], FLineNum, Col, Position);\nend;\n\nprocedure TJsonReader.Accept(TokenKind: TJsonTokenKind);\nbegin\n  if FLook.Kind <> TokenKind then\n    AcceptFailed(TokenKind);\n  Next;\nend;\n\n{ TJsonDataValue }\n\nprocedure TJsonDataValue.Clear;\n{$IFDEF USE_FAST_AUTOREFCOUNT}\nvar\n  P: Pointer;\n{$ENDIF USE_FAST_AUTOREFCOUNT}\nbegin\n  // All types must clear their value because if a value changes the type we need a zero-ed value\n  case FTyp of\n    jdtString:\n      string(FValue.S) := '';\n    jdtInt:\n      FValue.I := 0;\n    jdtLong:\n      FValue.L := 0;\n    jdtULong:\n      FValue.U := 0;\n    jdtFloat:\n      FValue.F := 0;\n    jdtDateTime, jdtUtcDateTime:\n      FValue.D := 0;\n    jdtBool:\n      FValue.B := False;\n    jdtArray,\n    jdtObject:\n      begin\n        {$IFDEF USE_FAST_AUTOREFCOUNT}\n        P := FValue.O;\n        if P <> nil then\n        begin\n          FValue.O := nil;\n          TJsonBaseObject(P).ARCObjRelease;\n        end;\n        {$ELSE}\n          {$IFNDEF AUTOREFCOUNT}\n        TJsonBaseObject(FValue.O).Free;\n          {$ENDIF ~AUTOREFCOUNT}\n        TJsonBaseObject(FValue.O) := nil;\n        {$ENDIF USE_FAST_AUTOREFCOUNT}\n      end;\n  end;\n  FTyp := jdtNone;\nend;\n\nfunction TJsonDataValue.IsNull: Boolean;\nbegin\n  case FTyp of\n    jdtObject:\n      Result := FValue.O = nil;\n    jdtNone:\n      Result := True;\n  else\n    Result := False;\n  end;\nend;\n\nfunction TJsonDataValue.GetArrayValue: TJsonArray;\nbegin\n  if FTyp = jdtArray then\n    Result := TJsonArray(FValue.A)\n  else if FTyp = jdtNone then\n    Result := nil\n  else\n  begin\n    TypeCastError(jdtArray);\n    Result := nil;\n  end;\nend;\n\nprocedure TJsonDataValue.SetArrayValue(const AValue: TJsonArray);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtArray) or (AValue <> FValue.A) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtArray;\n    {$IFDEF USE_FAST_AUTOREFCOUNT}\n    // Assert(FValue.A = nil);\n    if AValue <> nil then\n      AValue.ARCObjAddRef;\n    FValue.A := Pointer(AValue);\n    {$ELSE}\n    TJsonArray(FValue.A) := AValue;\n    {$ENDIF USE_FAST_AUTOREFCOUNT}\n  end;\nend;\n\nfunction TJsonDataValue.GetObjectValue: TJsonObject;\nbegin\n  if FTyp = jdtObject then\n    Result := TJsonObject(FValue.O)\n  else if FTyp = jdtNone then\n    Result := nil\n  else\n  begin\n    TypeCastError(jdtObject);\n    Result := nil;\n  end;\nend;\n\nprocedure TJsonDataValue.SetObjectValue(const AValue: TJsonObject);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtObject) or (AValue <> FValue.O) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtObject;\n    {$IFDEF USE_FAST_AUTOREFCOUNT}\n    // Assert(FValue.O = nil);\n    if AValue <> nil then\n      AValue.ARCObjAddRef;\n    FValue.O := Pointer(AValue);\n    {$ELSE}\n    TJsonObject(FValue.O) := AValue;\n    {$ENDIF USE_FAST_AUTOREFCOUNT}\n  end;\nend;\n\nfunction TJsonDataValue.GetVariantValue: Variant;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := Unassigned;\n    jdtString:\n      Result := string(FValue.S);\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := FValue.F;\n    jdtDateTime:\n      Result := FValue.D;\n    jdtUtcDateTime:\n      Result := UtcDateTimeToLocalDateTime(FValue.D); // Variant is local time\n    jdtBool:\n      Result := FValue.B;\n    jdtArray:\n      ErrorUnsupportedVariantType(varArray);\n    jdtObject:\n      if FValue.O = nil then\n        Result := Null // special handling for \"null\"\n      else\n        ErrorUnsupportedVariantType(varObject);\n  else\n    ErrorUnsupportedVariantType(varAny);\n  end;\nend;\n\nprocedure TJsonDataValue.SetVariantValue(const AValue: Variant);\nvar\n  LTyp: TJsonDataType;\nbegin\n  if FTyp <> jdtNone then\n    Clear;\n  LTyp := VarTypeToJsonDataType(VarType(AValue));\n  if LTyp <> jdtNone then\n  begin\n    FTyp := LTyp;\n    case LTyp of\n      jdtString:\n        string(FValue.S) := AValue;\n      jdtInt:\n        FValue.I := AValue;\n      jdtLong:\n        FValue.L := AValue;\n      jdtULong:\n        FValue.U := AValue;\n      jdtFloat:\n        FValue.F := AValue;\n      jdtDateTime:\n        FValue.D := AValue;\n      jdtBool:\n        FValue.B := AValue;\n//    else\n//      ErrorUnsupportedVariantType; handled by VarTypeToJsonDataType\n    end;\n  end;\nend;\n\nprocedure TJsonDataValue.InternSetArrayValue(const AValue: TJsonArray);\nbegin\n  FTyp := jdtArray;\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  // Assert(FValue.A = nil);\n  if AValue <> nil then\n    Inc(AValue.FRefCount); // AValue.ARCObjAddRef;   no other thread knows about this object right now\n  FValue.A := Pointer(AValue);\n  {$ELSE}\n  TJsonArray(FValue.A) := AValue;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\nend;\n\nprocedure TJsonDataValue.InternSetObjectValue(const AValue: TJsonObject);\nbegin\n  FTyp := jdtObject;\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  // Assert(FValue.O = nil);\n  if AValue <> nil then\n    Inc(AValue.FRefCount); // AValue.ARCObjAddRef;   no other thread knows about this object right now\n  FValue.O := Pointer(AValue);\n  {$ELSE}\n  TJsonObject(FValue.O) := AValue;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\nend;\n\nfunction TJsonDataValue.GetValue: string;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := '';\n    jdtString:\n      Result := string(FValue.S);\n    jdtInt:\n      Result := IntToStr(FValue.I);\n    jdtLong:\n      Result := IntToStr(FValue.L);\n    jdtULong:\n      Result := UIntToStr(FValue.U);\n    jdtFloat:\n      Result := FloatToStr(FValue.F, JSONFormatSettings);\n    jdtDateTime:\n      Result := TJsonBaseObject.DateTimeToJSON(FValue.F, JsonSerializationConfig.UseUtcTime);\n    jdtUtcDateTime:\n      Result := TJsonBaseObject.UtcDateTimeToJSON(FValue.F);\n    jdtBool:\n      if FValue.B then\n        Result := sTrue\n      else\n        Result := sFalse;\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtString);\n        Result := '';\n      end;\n  else\n    TypeCastError(jdtString);\n    Result := '';\n  end;\nend;\n\nprocedure TJsonDataValue.SetValue(const AValue: string);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtString) or (AValue <> string(FValue.S)) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtString;\n    string(FValue.S) := AValue;\n  end;\nend;\n\nprocedure TJsonDataValue.InternSetValue(const AValue: string);\nbegin\n  FTyp := jdtString;\n  string(FValue.S) := AValue;\nend;\n\nprocedure TJsonDataValue.InternSetValueTransfer(var AValue: string);\nbegin\n  FTyp := jdtString;\n  // transfer the string without going through UStrAsg and UStrClr\n  FValue.S := Pointer(AValue);\n  Pointer(AValue) := nil;\nend;\n\nfunction TJsonDataValue.GetIntValue: Integer;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      if not TryStrToInt(string(FValue.S), Result) then\n        Result := Trunc(StrToFloat(string(FValue.S), JSONFormatSettings));\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := Trunc(FValue.F);\n    jdtDateTime, jdtUtcDateTime:\n      Result := Trunc(FValue.D);\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtInt);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtInt);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetIntValue(const AValue: Integer);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtInt) or (AValue <> FValue.I) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtInt;\n    FValue.I := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetLongValue: Int64;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      if not TryStrToInt64(string(FValue.S), Result) then\n        Result := Trunc(StrToFloat(string(FValue.S), JSONFormatSettings));\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := Trunc(FValue.F);\n    jdtDateTime, jdtUtcDateTime:\n      Result := Trunc(FValue.D);\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtLong);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtLong);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetLongValue(const AValue: Int64);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtLong) or (AValue <> FValue.L) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtLong;\n    FValue.L := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetULongValue: UInt64;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      if not TryStrToUInt64(string(FValue.S), Result) then\n        Result := Trunc(StrToFloat(string(FValue.S), JSONFormatSettings));\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := Trunc(FValue.F);\n    jdtDateTime, jdtUtcDateTime:\n      Result := Trunc(FValue.D);\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtULong);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtULong);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetULongValue(const AValue: UInt64);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtULong) or (AValue <> FValue.U) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtULong;\n    FValue.U := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetFloatValue: Double;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      Result := StrToFloat(string(FValue.S), JSONFormatSettings);\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := FValue.F;\n    jdtDateTime, jdtUtcDateTime:\n      Result := FValue.D;\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtFloat);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtFloat);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetFloatValue(const AValue: Double);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtFloat) or (AValue <> FValue.F) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtFloat;\n    FValue.F := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetDateTimeValue: TDateTime;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      Result := TJsonBaseObject.JSONToDateTime(string(FValue.S));\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := FValue.F;\n    jdtDateTime:\n      Result := FValue.D;\n    jdtUtcDateTime:\n      Result := UtcDateTimeToLocalDateTime(FValue.D);\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtDateTime);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtDateTime);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetDateTimeValue(const AValue: TDateTime);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtDateTime) or (AValue <> FValue.D) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtDateTime;\n    FValue.D := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetUtcDateTimeValue: TDateTime;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := 0;\n    jdtString:\n      Result := TJsonBaseObject.JSONToDateTime(string(FValue.S), False);\n    jdtInt:\n      Result := FValue.I;\n    jdtLong:\n      Result := FValue.L;\n    jdtULong:\n      Result := FValue.U;\n    jdtFloat:\n      Result := FValue.F;\n    jdtDateTime:\n      Result := LocalDateTimeToUtcDateTime(FValue.D);\n    jdtUtcDateTime:\n      Result := FValue.D;\n    jdtBool:\n      Result := Ord(FValue.B);\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtDateTime);\n        Result := 0;\n      end;\n  else\n    TypeCastError(jdtUtcDateTime);\n    Result := 0;\n  end;\nend;\n\nprocedure TJsonDataValue.SetUtcDateTimeValue(const AValue: TDateTime);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtUtcDateTime) or (AValue <> FValue.D) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtUtcDateTime;\n    FValue.D := AValue;\n  end;\nend;\n\nfunction TJsonDataValue.GetBoolValue: Boolean;\nbegin\n  case FTyp of\n    jdtNone:\n      Result := False;\n    jdtString:\n      Result := string(FValue.S) = 'true';\n    jdtInt:\n      Result := FValue.I <> 0;\n    jdtLong:\n      Result := FValue.L <> 0;\n    jdtULong:\n      Result := FValue.U <> 0;\n    jdtFloat:\n      Result := FValue.F <> 0;\n    jdtDateTime, jdtUtcDateTime:\n      Result := FValue.D <> 0;\n    jdtBool:\n      Result := FValue.B;\n    jdtObject:\n      begin\n        if not JsonSerializationConfig.NullConvertsToValueTypes or (FValue.O <> nil) then\n          TypeCastError(jdtBool);\n        Result := False;\n      end;\n  else\n    TypeCastError(jdtBool);\n    Result := False;\n  end;\nend;\n\nprocedure TJsonDataValue.SetBoolValue(const AValue: Boolean);\nvar\n  LTyp: TJsonDataType;\nbegin\n  LTyp := FTyp;\n  if (LTyp <> jdtBool) or (AValue <> FValue.B) then\n  begin\n    if LTyp <> jdtNone then\n      Clear;\n    FTyp := jdtBool;\n    FValue.B := AValue;\n  end;\nend;\n\nfunction DoubleToText(Buffer: PChar; const Value: Extended): Integer; {inline;}\nvar\n  I: Integer;\nbegin\n  Result := FloatToText(Buffer, Value, fvExtended, ffGeneral, 15, 0, JSONFormatSettings);\n\n  // Add the decimal separator if FloatToText didn't add it, so that the data type of\n  // the property doesn't change to Integer/Int64 if it is read again.\n  for I := Result - 1 downto 0 do\n    if Buffer[I] in ['.', 'E', 'e'] then\n      Exit;\n  Buffer[Result] := '.';\n  Buffer[Result + 1] := '0';\n  Inc(Result, 2);\nend;\n\nconst\n  DoubleDigits: array[0..99] of array[0..1] of Char = (\n    '00', '01', '02', '03', '04', '05', '06', '07', '08', '09',\n    '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',\n    '20', '21', '22', '23', '24', '25', '26', '27', '28', '29',\n    '30', '31', '32', '33', '34', '35', '36', '37', '38', '39',\n    '40', '41', '42', '43', '44', '45', '46', '47', '48', '49',\n    '50', '51', '52', '53', '54', '55', '56', '57', '58', '59',\n    '60', '61', '62', '63', '64', '65', '66', '67', '68', '69',\n    '70', '71', '72', '73', '74', '75', '76', '77', '78', '79',\n    '80', '81', '82', '83', '84', '85', '86', '87', '88', '89',\n    '90', '91', '92', '93', '94', '95', '96', '97', '98', '99'\n  );\n\nfunction InternIntToText(Value: Cardinal; Negative: Boolean; EndP: PChar): PChar;\nvar\n  I, Quotient, K: Cardinal;\nbegin\n  I := Value;\n  Result := EndP;\n  while I >= 100 do\n  begin\n    Quotient := I div 100;\n    K := Quotient * 100;\n    K := I - K;\n    I := Quotient;\n    Dec(Result, 2);\n    PLongWord(Result)^ := LongWord(DoubleDigits[K]);\n  end;\n  if I >= 10 then\n  begin\n    Dec(Result, 2);\n    PLongWord(Result)^ := LongWord(DoubleDigits[I]);\n  end\n  else\n  begin\n    Dec(Result);\n    Result^ := Char(I or Ord('0'));\n  end;\n\n  if Negative then\n  begin\n    Dec(Result);\n    Result^ := '-';\n  end;\nend;\n\nfunction IntToText(Value: Integer; EndP: PChar): PChar; inline;\nbegin\n  if Value < 0 then\n    Result := InternIntToText(Cardinal(-Value), True, EndP)\n  else\n    Result := InternIntToText(Cardinal(Value), False, EndP);\nend;\n\nfunction UInt64ToText(Value: UInt64; EndP: PChar): PChar;\nvar\n  Quotient: UInt64;\n  Remainder: Cardinal;\nbegin\n  Result := EndP;\n\n  while Value > High(Integer) do\n  begin\n    Quotient := Value div 100;\n    //Remainder := Value - (Quotient * 100);\n    Remainder := Value - (Quotient shl 6 + Quotient shl 5 + Quotient shl 2);\n    Value := Quotient;\n\n    Dec(Result, 2);\n    PLongWord(Result)^ := LongWord(DoubleDigits[Remainder]);\n  end;\n\n  Result := InternIntToText(Cardinal(Value), False, Result);\nend;\n\nfunction Int64ToText(Value: Int64; EndP: PChar): PChar;\nvar\n  Neg: Boolean;\nbegin\n  Neg := Value < 0;\n  if Neg then\n    Value := -Value;\n\n  Result := UInt64ToText(UInt64(Value), EndP);\n\n  if Neg then\n  begin\n    Dec(Result);\n    Result^ := '-';\n  end;\nend;\n\nprocedure TJsonDataValue.InternToJSON(var Writer: TJsonOutputWriter);\nvar\n  Buffer: array[0..63 + 2] of Char;\n  P, BufEnd: PChar;\nbegin\n  case FTyp of\n    jdtNone:\n      Writer.AppendValue(sNull);\n    jdtString:\n      TJsonBaseObject.StrToJSONStr(Writer.AppendStrValue, string(FValue.S));\n    jdtInt:\n      begin\n        BufEnd := @PChar(@Buffer[0])[Length(Buffer)]; // extra typecast to work around a compiler bug (fixed in XE3)\n        P := IntToText(FValue.I, BufEnd);\n        Writer.AppendValue(P, BufEnd - P);\n      end;\n    jdtLong:\n      begin\n        BufEnd := @PChar(@Buffer[0])[Length(Buffer)]; // extra typecast to work around a compiler bug (fixed in XE3)\n        P := Int64ToText(FValue.L, BufEnd);\n        Writer.AppendValue(P, BufEnd - P);\n      end;\n    jdtULong:\n      begin\n        BufEnd := @PChar(@Buffer[0])[Length(Buffer)]; // extra typecast to work around a compiler bug (fixed in XE3)\n        P := UInt64ToText(FValue.U, BufEnd);\n        Writer.AppendValue(P, BufEnd - P);\n      end;\n    jdtFloat:\n      Writer.AppendValue(Buffer, DoubleToText(Buffer, FValue.F));\n    jdtDateTime:\n      TJsonBaseObject.DateTimeToJSONStr(Writer.AppendStrValue, FValue.D); // do the conversion in a function to prevent the compiler from creating a string intermediate in this method\n    jdtUtcDateTime:\n      TJsonBaseObject.UtcDateTimeToJSONStr(Writer.AppendStrValue, FValue.D); // do the conversion in a function to prevent the compiler from creating a string intermediate in this method\n    jdtBool:\n      if FValue.B then\n        Writer.AppendValue(sTrue)\n      else\n        Writer.AppendValue(sFalse);\n    jdtArray:\n      if (FValue.A = nil) or (TJsonArray(FValue.A).Count = 0) then\n        Writer.AppendValue('[]')\n      else\n        TJsonArray(FValue.A).InternToJSON(Writer);\n    jdtObject:\n      if FValue.O = nil then\n        Writer.AppendValue(sNull)\n      else\n        TJsonObject(FValue.O).InternToJSON(Writer);\n  end;\nend;\n\n{ TJsonBaseObject }\n\n{$IFDEF USE_FAST_NEWINSTANCE}\nclass function TJsonBaseObject.NewInstance: TObject;\nbegin\n  Result := AllocMem(InstanceSize); // zeroes the new memory\n  PPointer(Result)^ := Self; // VMT\n  {$IFDEF AUTOREFCOUNT}\n  TJsonBaseObject(Result).FRefCount := 1;\n  {$ENDIF AUTOREFCOUNT}\nend;\n{$ENDIF ~USE_FAST_NEWINSTANCE}\n\n{$IFDEF USE_FAST_AUTOREFCOUNT}\nfunction TJsonBaseObject.ARCObjRelease: Integer;\nbegin\n  // Use a static call instead of the virtual method call\n  Result := inherited __ObjRelease;\nend;\n\nfunction TJsonBaseObject.ARCObjAddRef: Integer;\nbegin\n  // Inline __ObjAddRef to skip the virtual method call\n  Result := AtomicIncrement(FRefCount);\n  //Result := inherited __ObjAddRef;\nend;\n{$ENDIF USE_FAST_AUTOREFCOUNT}\n\nclass function TJsonBaseObject.UtcDateTimeToJSON(const UtcDateTime: TDateTime): string;\nvar\n  Year, Month, Day, Hour, Minute, Second, Milliseconds: Word;\nbegin\n  DecodeDate(UtcDateTime, Year, Month, Day);\n  DecodeTime(UtcDateTime, Hour, Minute, Second, MilliSeconds);\n  Result := Format('%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%dZ',\n    [Year, Month, Day, Hour, Minute, Second, Milliseconds]);\nend;\n\nfunction TJsonBaseObject.Clone: TJsonBaseObject;\nbegin\n  if Self is TJsonArray then\n    Result := TJsonArray(Self).Clone\n  else\n    Result := TJsonObject(Self).Clone;\nend;\n\nclass function TJsonBaseObject.DateTimeToJSON(const Value: TDateTime; UseUtcTime: Boolean): string;\n{$IFDEF MSWINDOWS}\nvar\n  LocalTime, UtcTime: TSystemTime;\nbegin\n  if UseUtcTime then\n  begin\n    DateTimeToSystemTime(Value, LocalTime);\n    if not TzSpecificLocalTimeToSystemTime(nil, LocalTime, UtcTime) then\n      UtcTime := LocalTime;\n    Result := Format('%.4d-%.2d-%.2dT%.2d:%.2d:%.2d.%dZ',\n      [UtcTime.wYear, UtcTime.wMonth, UtcTime.wDay,\n       UtcTime.wHour, UtcTime.wMinute, UtcTime.wSecond, UtcTime.wMilliseconds]);\n  end\n  else\n    Result := DateTimeToISO8601(Value);\nend;\n{$ELSE}\nbegin\n  if UseUtcTime then\n    Result := UtcDateTimeToJSON(TTimeZone.Local.ToUniversalTime(Value))\n  else\n    Result := DateTimeToISO8601(Value);\nend;\n{$ENDIF MSWINDOWS}\n\nclass function TJsonBaseObject.JSONToDateTime(const Value: string; ConvertToLocalTime: Boolean): TDateTime;\nvar\n  P: PChar;\n  MSecsSince1970: Int64;\n  Year, Month, Day, Hour, Min, Sec, MSec: Integer;\n  OffsetHour, OffsetMin: Integer;\n  Sign: Double;\nbegin\n  Result := 0;\n  if Value = '' then\n    Exit;\n\n  P := PChar(Value);\n  if (P^ = '/') and (StrLComp('Date(', P + 1, 5) = 0) then  // .NET: milliseconds since 1970-01-01\n  begin\n    Inc(P, 6);\n    MSecsSince1970 := 0;\n    while (P^ <> #0) and (P^ in ['0'..'9']) do\n    begin\n      MSecsSince1970 := MSecsSince1970 * 10 + (Ord(P^) - Ord('0'));\n      Inc(P);\n    end;\n    if (P^ = '+') or (P^ = '-') then // timezone information\n    begin\n      Inc(P);\n      while (P^ <> #0) and (P^ in ['0'..'9']) do\n        Inc(P);\n    end;\n    if (P[0] = ')') and (P[1] = '/') and (P[2] = #0) then\n    begin\n      Result := UnixDateDelta + (MSecsSince1970 / MSecsPerDay);\n      if ConvertToLocalTime then\n        Result := UtcDateTimeToLocalDateTime(Result);\n    end\n    else\n      Result := 0; // invalid format\n  end\n  else\n  begin\n    // \"2015-02-01T16:08:19.202Z\"\n    if P^ = '-' then // negative year\n      Inc(P);\n    P := ParseDateTimePart(P, Year, 4);\n    if P^ <> '-' then\n      Exit; // invalid format\n    P := ParseDateTimePart(P + 1, Month, 2);\n    if P^ <> '-' then\n      Exit; // invalid format\n    P := ParseDateTimePart(P + 1, Day, 2);\n\n    Hour := 0;\n    Min := 0;\n    Sec := 0;\n    MSec := 0;\n    Result := EncodeDate(Year, Month, Day);\n\n    if P^ = 'T' then\n    begin\n      P := ParseDateTimePart(P + 1, Hour, 2);\n      if P^ <> ':' then\n        Exit; // invalid format\n      P := ParseDateTimePart(P + 1, Min, 2);\n      if P^ = ':' then\n      begin\n        P := ParseDateTimePart(P + 1, Sec, 2);\n        if P^ = '.' then\n          P := ParseDateTimePart(P + 1, MSec, 3);\n      end;\n      Result := Result + EncodeTime(Hour, Min, Sec, MSec);\n      if (P^ <> 'Z') and (P^ <> #0) then\n      begin\n        if (P^ = '+') or (P^ = '-') then\n        begin\n          if P^ = '+' then\n            Sign := -1 //  +0100 means that the time is 1 hour later than UTC\n          else\n            Sign := 1;\n\n          P := ParseDateTimePart(P + 1, OffsetHour, 2);\n          if P^ = ':' then\n            Inc(P);\n          ParseDateTimePart(P, OffsetMin, 2);\n\n          Result := Result + (EncodeTime(OffsetHour, OffsetMin, 0, 0) * Sign);\n        end\n        else\n        begin\n          Result := 0; // invalid format\n          Exit;\n        end;\n      end;\n\n      if ConvertToLocalTime then\n        Result := UtcDateTimeToLocalDateTime(Result);\n    end;\n  end;\nend;\n\nclass procedure TJsonBaseObject.StrToJSONStr(const AppendMethod: TWriterAppendMethod; const S: string);\nvar\n  P, EndP, F: PChar;\nbegin\n  P := PChar(Pointer(S));\n  if P <> nil then\n  begin\n    //EndP := P + Length(S);  inlined Length introduces too much unnecessary code\n    EndP := P + PInteger(@PByte(S)[-4])^;\n\n    // find the first char that must be escaped\n    F := P;\n//    DCC64 generates \"bt mem,reg\" code\n//    while (P < EndP) and not (P^ in [#0..#31, '\\', '\"' {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, '/'{$ENDIF}]) do\n//      Inc(P);\n\n    if PJsonOutputWriter(TMethod(AppendMethod).Data).FConfig.EscapeAllNonASCIIChars then\n    begin\n      while P < EndP do\n        case Ord(P^) of\n          0..31, Ord('\\'), Ord('\"') {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, Ord('/'){$ENDIF}, $0080..$FFFF: Break;\n        else\n          Inc(P);\n        end;\n    end\n    else\n    begin\n      while P < EndP do\n        case P^ of\n          #0..#31, '\\', '\"' {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, '/'{$ENDIF}: Break;\n        else\n          Inc(P);\n        end;\n    end;\n\n    // nothing found, than it is easy\n    if P = EndP then\n      AppendMethod(PChar(S), Length(S))\n    else\n      EscapeStrToJSONStr(F, P, EndP, AppendMethod);\n  end\n  else\n    AppendMethod(nil, 0);\nend;\n\nclass procedure TJsonBaseObject.DateTimeToJSONStr(const AppendMethod: TWriterAppendMethod; const Value: TDateTime);\nvar\n  S: string;\nbegin\n  S := TJsonBaseObject.DateTimeToJSON(Value, PJsonOutputWriter(TMethod(AppendMethod).Data).FConfig.UseUtcTime);\n  // StrToJSONStr isn't necessary because the date-time string doesn't contain any char\n  // that must be escaped.\n  AppendMethod(PChar(S), Length(S));\nend;\n\nclass procedure TJsonBaseObject.UtcDateTimeToJSONStr(const AppendMethod: TWriterAppendMethod; const Value: TDateTime);\nvar\n  S: string;\nbegin\n  S := TJsonBaseObject.UtcDateTimeToJSON(Value);\n  // StrToJSONStr isn't necessary because the date-time string doesn't contain any char\n  // that must be escaped.\n  AppendMethod(PChar(S), Length(S));\nend;\n\nclass procedure TJsonBaseObject.EscapeStrToJSONStr(F, P, EndP: PChar; const AppendMethod: TWriterAppendMethod);\nconst\n  HexChars: array[0..15] of Char = '0123456789abcdef';\nvar\n  Buf: TJsonOutputWriter.TJsonStringBuilder;\n  Ch: Char;\n  {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}\n  StartP: PChar;\n  {$ENDIF ESCAPE_SLASH_AFTER_LESSTHAN}\n  EscapeAllNonASCIIChars: Boolean;\nbegin\n  {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}\n  StartP := F;\n  {$ENDIF ESCAPE_SLASH_AFTER_LESSTHAN}\n\n  EscapeAllNonASCIIChars := PJsonOutputWriter(TMethod(AppendMethod).Data).FConfig.EscapeAllNonASCIIChars;\n\n  Buf.Init;\n  try\n    repeat\n      if P <> F then\n        Buf.Append(F, P - F); // append the string part that doesn't need an escape sequence\n      if P < EndP then\n      begin\n        Ch := P^;\n        case Ch of\n          #0..#7, #11, #14..#31:\n            begin\n              Buf.Append('\\u00', 4);\n              Buf.Append2(HexChars[Word(Ch) shr 4], HexChars[Word(Ch) and $F]);\n            end;\n          #8: Buf.Append('\\b', 2);\n          #9: Buf.Append('\\t', 2);\n          #10: Buf.Append('\\n', 2);\n          #12: Buf.Append('\\f', 2);\n          #13: Buf.Append('\\r', 2);\n          '\\': Buf.Append('\\\\', 2);\n          '\"': Buf.Append('\\\"', 2);\n          {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}\n          '/':\n            begin\n              if (P > StartP) and (P[-1] = '<') then // escape '/' only if we have '</' to support HTML <script>-Tag\n                Buf.Append('\\/', 2)\n              else\n                Buf.Append('/', 1);\n            end;\n          {$ENDIF ESCAPE_SLASH_AFTER_LESSTHAN}\n        end;\n        if (Ord(Ch) >= $0080) and EscapeAllNonASCIIChars then\n        begin\n          Buf.Append('\\u', 2);\n          Buf.Append2(HexChars[(Word(Ch) shr 12) and $F], HexChars[(Word(Ch) shr 8) and $F]);\n          Buf.Append2(HexChars[(Word(Ch) shr 4) and $F], HexChars[Word(Ch) and $F]);\n        end;\n\n        Inc(P);\n        F := P;\n        if EscapeAllNonASCIIChars then\n        begin\n          while P < EndP do\n            case Ord(P^) of\n              0..31, Ord('\\'), Ord('\"') {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, Ord('/'){$ENDIF}, $80..$FFFF: Break;\n            else\n              Inc(P);\n            end;\n        end\n        else\n        begin\n  //        DCC64 generates \"bt mem,reg\" code\n  //        while (P < EndP) and not (P^ in [#0..#31, '\\', '\"' {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, '/'{$ENDIF}]) do\n  //          Inc(P);\n          while P < EndP do\n            case P^ of\n              #0..#31, '\\', '\"' {$IFDEF ESCAPE_SLASH_AFTER_LESSTHAN}, '/'{$ENDIF}: Break;\n            else\n              Inc(P);\n            end;\n        end;\n      end\n      else\n        Break;\n    until False;\n    AppendMethod(Buf.Data, Buf.Len);\n  finally\n    Buf.Done;\n  end;\nend;\n\nclass function TJsonBaseObject.ParseUtf8(S: PAnsiChar; Len: Integer; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nbegin\n  Result := ParseUtf8Bytes(PByte(S), Len, AProgress);\nend;\n\n{$IFDEF SUPPORTS_UTF8STRING}\nclass function TJsonBaseObject.ParseUtf8(const S: UTF8String; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nbegin\n  Result := ParseUtf8Bytes(PByte(S), Length(S), AProgress);\nend;\n{$ENDIF SUPPORTS_UTF8STRING}\n\nclass function TJsonBaseObject.ParseUtf8Bytes(S: PByte; Len: Integer; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nvar\n  P: PByte;\n  L: Integer;\nbegin\n  if (S = nil) or (Len = 0) then\n    Result := nil\n  else\n  begin\n    if Len < 0 then\n    begin\n      {$IFDEF NEXTGEN}\n      Len := Utf8StrLen(S);\n      {$ELSE}\n      Len := StrLen(PAnsiChar(S));\n      {$ENDIF NEXTGEN}\n    end;\n    P := S;\n    L := Len;\n    while (L > 0) and (P^ <= 32) do\n    begin\n      Inc(P);\n      Dec(L);\n    end;\n    if L = 0 then\n      Result := nil\n    else\n    begin\n      if (L > 0) and (P^ = Byte(Ord('['))) then\n        Result := TJsonArray.Create\n      else\n        Result := TJsonObject.Create;\n\n      {$IFDEF AUTOREFCOUNT}\n      Result.FromUtf8JSON(S, Len, AProgress);\n      {$ELSE}\n      try\n        Result.FromUtf8JSON(S, Len, AProgress);\n      except\n        Result.Free;\n        raise;\n      end;\n      {$ENDIF AUTOREFCOUNT}\n    end;\n  end;\nend;\n\nclass function TJsonBaseObject.Parse(const S: UnicodeString; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nbegin\n  Result := Parse(PWideChar(Pointer(S)), Length(S), AProgress);\nend;\n\nclass function TJsonBaseObject.Parse(S: PWideChar; Len: Integer; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nvar\n  P: PWideChar;\n  L: Integer;\nbegin\n  if (S = nil) or (Len = 0) then\n    Result := nil\n  else\n  begin\n    if Len < 0 then\n      Len := StrLen(S);\n    P := S;\n    L := Len;\n    while (L > 0) and (P^ <= #32) do\n    begin\n      Inc(P);\n      Dec(L);\n    end;\n    if L = 0 then\n      Result := nil\n    else\n    begin\n      if (L > 0) and (P^ = '[') then\n        Result := TJsonArray.Create\n      else\n        Result := TJsonObject.Create;\n\n      {$IFDEF AUTOREFCOUNT}\n      Result.FromJSON(S, Len, AProgress);\n      {$ELSE}\n      try\n        Result.FromJSON(S, Len, AProgress);\n      except\n        Result.Free;\n        raise;\n      end;\n      {$ENDIF AUTOREFCOUNT}\n    end;\n  end;\nend;\n\nclass function TJsonBaseObject.Parse(const Bytes: TBytes; Encoding: TEncoding; ByteIndex: Integer;\n  ByteCount: Integer; AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nvar\n  L: Integer;\nbegin\n  L := Length(Bytes);\n  if ByteCount = -1 then\n    ByteCount := L - ByteIndex;\n  if (ByteCount <= 0) or (ByteIndex + ByteCount > L) then\n    Result := nil\n  else\n  begin\n    if (Encoding = TEncoding.UTF8) or (Encoding = nil) then\n      Result := ParseUtf8Bytes(PByte(@Bytes[ByteIndex]), ByteCount, AProgress)\n    else if Encoding = TEncoding.Unicode then\n      Result := Parse(PWideChar(@Bytes[ByteIndex]), ByteCount div SizeOf(WideChar), AProgress)\n    else\n      Result := Parse(Encoding.GetString(Bytes, ByteIndex, ByteCount), AProgress);\n  end;\nend;\n\nclass function TJsonBaseObject.ParseFromFile(const FileName: string; Utf8WithoutBOM: Boolean;\n  AProgress: PJsonReaderProgressRec): TJsonBaseObject;\nvar\n  Stream: TFileStream;\nbegin\n  Stream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);\n  try\n    Result := ParseFromStream(Stream, nil, Utf8WithoutBOM, AProgress);\n  finally\n    Stream.Free;\n  end;\nend;\n\nclass function TJsonBaseObject.ParseFromStream(Stream: TStream; Encoding: TEncoding;\n  Utf8WithoutBOM: Boolean; AProgress: PJsonReaderProgressRec\n): TJsonBaseObject;\nvar\n  StreamInfo: TStreamInfo;\n  S: string;\n  L: Integer;\nbegin\n  GetStreamBytes(Stream, Encoding, Utf8WithoutBOM, StreamInfo);\n  try\n    if Encoding = TEncoding.UTF8 then\n      Result := ParseUtf8Bytes(StreamInfo.Buffer, StreamInfo.Size, AProgress)\n    else if Encoding = TEncoding.Unicode then\n      Result := Parse(PWideChar(Pointer(StreamInfo.Buffer)), StreamInfo.Size div SizeOf(WideChar), AProgress)\n    else\n    begin\n      L := TEncodingStrictAccess(Encoding).GetCharCountEx(StreamInfo.Buffer, StreamInfo.Size);\n      SetLength(S, L);\n      if L > 0 then\n        TEncodingStrictAccess(Encoding).GetCharsEx(StreamInfo.Buffer, StreamInfo.Size, PChar(Pointer(S)), L)\n      else if StreamInfo.Size > 0 then\n        ErrorNoMappingForUnicodeCharacter;\n\n      // release memory\n      FreeMem(StreamInfo.AllocationBase);\n      StreamInfo.AllocationBase := nil;\n\n      Result := Parse(S, AProgress);\n    end;\n  finally\n    FreeMem(StreamInfo.AllocationBase);\n  end;\nend;\n\n{$IFDEF SUPPORTS_UTF8STRING}\nprocedure TJsonBaseObject.FromUtf8JSON(const S: UTF8String; AProgress: PJsonReaderProgressRec);\nbegin\n  FromUtf8JSON(PAnsiChar(Pointer(S)), Length(S), AProgress);\nend;\n{$ENDIF SUPPORTS_UTF8STRING}\n\nprocedure TJsonBaseObject.FromUtf8JSON(S: PAnsiChar; Len: Integer; AProgress: PJsonReaderProgressRec);\nbegin\n  FromUtf8JSON(PByte(S), Len, AProgress);\nend;\n\nprocedure TJsonBaseObject.FromUtf8JSON(S: PByte; Len: Integer; AProgress: PJsonReaderProgressRec);\nvar\n  Reader: TJsonReader;\nbegin\n  if Len < 0 then\n  begin\n    {$IFDEF NEXTGEN}\n    Len := Utf8StrLen(S);\n    {$ELSE}\n    Len := StrLen(PAnsiChar(S));\n    {$ENDIF NEXTGEN}\n  end;\n  Reader := TUtf8JsonReader.Create(S, Len, AProgress);\n  try\n    Reader.Parse(Self);\n  finally\n    Reader.Free;\n  end;\nend;\n\nprocedure TJsonBaseObject.FromJSON(const S: UnicodeString; AProgress: PJsonReaderProgressRec);\nbegin\n  FromJSON(PWideChar(S), Length(S), AProgress);\nend;\n\nprocedure TJsonBaseObject.FromJSON(S: PWideChar; Len: Integer; AProgress: PJsonReaderProgressRec);\nvar\n  Reader: TJsonReader;\nbegin\n  if Len < 0 then\n    Len := StrLen(S);\n  Reader := TStringJsonReader.Create(S, Len, AProgress);\n  try\n    Reader.Parse(Self);\n  finally\n    Reader.Free;\n  end;\nend;\n\nprocedure TJsonBaseObject.LoadFromFile(const FileName: string; Utf8WithoutBOM: Boolean; AProgress: PJsonReaderProgressRec);\nvar\n  Stream: TFileStream;\nbegin\n  Stream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);\n  try\n    LoadFromStream(Stream, nil, Utf8WithoutBOM, AProgress);\n  finally\n    Stream.Free;\n  end;\nend;\n\nclass procedure TJsonBaseObject.GetStreamBytes(Stream: TStream; var Encoding: TEncoding; Utf8WithoutBOM: Boolean;\n  var StreamInfo: TStreamInfo);\n{$IFDEF WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\nconst\n  MaxBufSize = 20 * 1024 * 1024;\nvar\n  ReadCount, ReadBufSize: NativeInt;\n{$ENDIF WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\nvar\n  Position: Int64;\n  Size: NativeInt;\n  Bytes: PByte;\n  BufStart: Integer;\nbegin\n  BufStart := 0;\n  Position := Stream.Position;\n  Size := Stream.Size - Position;\n\n  StreamInfo.Buffer := nil;\n  StreamInfo.Size := 0;\n  StreamInfo.AllocationBase := nil;\n  try\n    Bytes := nil;\n    if Size > 0 then\n    begin\n      if Stream is TCustomMemoryStream then\n      begin\n        Bytes := TCustomMemoryStream(Stream).Memory;\n        TCustomMemoryStream(Stream).Position := Position + Size;\n        Inc(Bytes, Position);\n      end\n      else\n      begin\n        GetMem(StreamInfo.AllocationBase, Size);\n        Bytes := StreamInfo.AllocationBase;\n        {$IFDEF WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\n        if (Stream is THandleStream) and (Size > MaxBufSize) then\n        begin\n          ReadCount := Size;\n          // Read in 20 MB blocks to work around a network limitation in Windows 2003 or older (INSUFFICIENT RESOURCES)\n          while ReadCount > 0 do\n          begin\n            ReadBufSize := ReadCount;\n            if ReadBufSize > MaxBufSize then\n              ReadBufSize := MaxBufSize;\n            Stream.ReadBuffer(Bytes[Size - ReadCount], ReadBufSize);\n            Dec(ReadCount, ReadBufSize);\n          end;\n        end\n        else\n        {$ENDIF WORKAROUND_NETWORK_FILE_INSUFFICIENT_RESOURCES}\n          Stream.ReadBuffer(StreamInfo.AllocationBase^, Size);\n      end;\n    end;\n\n    if Encoding = nil then\n    begin\n      // Determine the encoding from the BOM\n      if Utf8WithoutBOM then\n        Encoding := TEncoding.UTF8\n      else\n        Encoding := TEncoding.Default;\n\n      if Size >= 2 then\n      begin\n        if (Bytes[0] = $EF) and (Bytes[1] = $BB) then\n        begin\n          if Bytes[2] = $BF then\n          begin\n            Encoding := TEncoding.UTF8;\n            BufStart := 3;\n          end;\n        end\n        else if (Bytes[0] = $FF) and (Bytes[1] = $FE) then\n        begin\n          if (Bytes[2] = 0) and (Bytes[3] = 0) then\n          begin\n            raise EJsonException.CreateRes(@RsUnsupportedFileEncoding);\n            //Result := bomUtf32LE;\n            //BufStart := 4;\n          end\n          else\n          begin\n            Encoding := TEncoding.Unicode;\n            BufStart := 2;\n          end;\n        end\n        else if (Bytes[0] = $FE) and (Bytes[1] = $FF) then\n        begin\n          Encoding := TEncoding.BigEndianUnicode;\n          BufStart := 2;\n        end\n        else if (Bytes[0] = 0) and (Bytes[1] = 0) and (Size >= 4) then\n        begin\n          if (Bytes[2] = $FE) and (Bytes[3] = $FF) then\n          begin\n            raise EJsonException.CreateRes(@RsUnsupportedFileEncoding);\n            //Result := bomUtf32BE;\n            //BufStart := 4;\n          end;\n        end;\n      end;\n    end;\n    Inc(Bytes, BufStart);\n    StreamInfo.Buffer := Bytes;\n    StreamInfo.Size := Size - BufStart;\n  except\n    FreeMem(StreamInfo.AllocationBase);\n    raise;\n  end;\nend;\n\nprocedure TJsonBaseObject.LoadFromStream(Stream: TStream; Encoding: TEncoding; Utf8WithoutBOM: Boolean;\n  AProgress: PJsonReaderProgressRec);\nvar\n  StreamInfo: TStreamInfo;\n  S: string;\n  L: Integer;\nbegin\n  GetStreamBytes(Stream, Encoding, Utf8WithoutBOM, StreamInfo);\n  try\n    if Encoding = TEncoding.UTF8 then\n      FromUtf8JSON(StreamInfo.Buffer, StreamInfo.Size, AProgress)\n    else if Encoding = TEncoding.Unicode then\n      FromJSON(PWideChar(Pointer(StreamInfo.Buffer)), StreamInfo.Size div SizeOf(WideChar), AProgress)\n    else\n    begin\n      L := TEncodingStrictAccess(Encoding).GetCharCountEx(StreamInfo.Buffer, StreamInfo.Size);\n      SetLength(S, L);\n      if L > 0 then\n        TEncodingStrictAccess(Encoding).GetCharsEx(StreamInfo.Buffer, StreamInfo.Size, PChar(Pointer(S)), L)\n      else if StreamInfo.Size > 0 then\n        ErrorNoMappingForUnicodeCharacter;\n\n      // release memory\n      FreeMem(StreamInfo.AllocationBase);\n      StreamInfo.AllocationBase := nil;\n\n      FromJSON(S, AProgress);\n    end;\n  finally\n    FreeMem(StreamInfo.AllocationBase);\n  end;\nend;\n\nprocedure TJsonBaseObject.SaveToFile(const FileName: string; Compact: Boolean; Encoding: TEncoding;\n  Utf8WithoutBOM: Boolean);\nbegin\n  SaveToFile(FileName, JsonSerializationConfig, Compact, Encoding, Utf8WithoutBOM);\nend;\n\nprocedure TJsonBaseObject.SaveToFile(const FileName: string; const Config: TJsonSerializationConfig;\n  Compact: Boolean; Encoding: TEncoding; Utf8WithoutBOM: Boolean);\nvar\n  Stream: TStream;\nbegin\n  Stream := TFileStream.Create(FileName, fmCreate or fmShareDenyWrite);\n  try\n    SaveToStream(Stream, Config, Compact, Encoding, Utf8WithoutBOM);\n  finally\n    Stream.Free;\n  end;\nend;\n\nprocedure TJsonBaseObject.SaveToStream(Stream: TStream; Compact: Boolean; Encoding: TEncoding;\n  Utf8WithoutBOM: Boolean);\nbegin\n  SaveToStream(Stream, JsonSerializationConfig, Compact, Encoding, Utf8WithoutBOM);\nend;\n\nprocedure TJsonBaseObject.SaveToStream(Stream: TStream; const Config: TJsonSerializationConfig;\n  Compact: Boolean; Encoding: TEncoding; Utf8WithoutBOM: Boolean);\nvar\n  Preamble: TBytes;\n  Writer: TJsonOutputWriter;\nbegin\n  if Utf8WithoutBOM and ((Encoding = TEncoding.UTF8) or (Encoding = nil)) then\n    Encoding := TEncoding.UTF8\n  else\n  begin\n    if Encoding = nil then\n      Encoding := TEncoding.Default;\n\n    Preamble := Encoding.GetPreamble;\n    if Preamble <> nil then\n      Stream.Write(Preamble[0], Length(Preamble));\n  end;\n\n  Writer.Init(Compact, Stream, Encoding, nil, Config);\n  try\n    InternToJSON(Writer);\n  finally\n    Writer.StreamDone;\n  end;\nend;\n\nprocedure TJsonBaseObject.SaveToLines(Lines: TStrings);\nbegin\n  SaveToLines(Lines, JsonSerializationConfig);\nend;\n\nprocedure TJsonBaseObject.SaveToLines(Lines: TStrings; const Config: TJsonSerializationConfig);\nvar\n  Writer: TJsonOutputWriter;\nbegin\n  Writer.Init(False, nil, nil, Lines, Config);\n  try\n    InternToJSON(Writer);\n  finally\n    Writer.LinesDone;\n  end;\nend;\n\nfunction TJsonBaseObject.ToJSON(Compact: Boolean): string;\nbegin\n  Result := ToJSON(JsonSerializationConfig, Compact);\nend;\n\nfunction TJsonBaseObject.ToJSON(const Config: TJsonSerializationConfig; Compact: Boolean): string;\nvar\n  Writer: TJsonOutputWriter;\nbegin\n  Writer.Init(Compact, nil, nil, nil, Config);\n  try\n    InternToJSON(Writer);\n  finally\n    Result := Writer.Done;\n  end;\nend;\n\n{$IFDEF SUPPORTS_UTF8STRING}\nfunction TJsonBaseObject.ToUtf8JSON(Compact: Boolean): UTF8String;\nbegin\n  Result := ToUtf8JSON(JsonSerializationConfig, Compact);\nend;\n\nfunction TJsonBaseObject.ToUtf8JSON(const Config: TJsonSerializationConfig; Compact: Boolean): UTF8String;\nvar\n  Stream: TJsonUtf8StringStream;\n  Size: NativeInt;\nbegin\n  Stream := TJsonUtf8StringStream.Create;\n  try\n    SaveToStream(Stream, Config, Compact, nil, True);\n    Result := Stream.DataString;\n    Size := Stream.Size;\n  finally\n    Stream.Free;\n  end;\n  if Length(Result) <> Size then\n    SetLength(Result, Size);\nend;\n{$ENDIF SUPPORTS_UTF8STRING}\n\nprocedure TJsonBaseObject.ToUtf8JSON(var Bytes: TBytes; Compact: Boolean);\nbegin\n  ToUtf8JSON(Bytes, JsonSerializationConfig, Compact);\nend;\n\nprocedure TJsonBaseObject.ToUtf8JSON(var Bytes: TBytes; const Config: TJsonSerializationConfig;\n  Compact: Boolean);\nvar\n  Stream: TJsonBytesStream;\n  Size: NativeInt;\nbegin\n  Stream := TJsonBytesStream.Create;\n  try\n    SaveToStream(Stream, Config, Compact, nil, True);\n    Size := Stream.Size;\n    Bytes := Stream.Bytes;\n  finally\n    Stream.Free;\n  end;\n  if Length(Bytes) <> Size then\n    ByteArraySetLengthUninit(Bytes, Size);\nend;\n\nfunction TJsonBaseObject.ToString: string;\nbegin\n  Result := ToJSON;\nend;\n\nclass procedure TJsonBaseObject.InternInitAndAssignItem(Dest, Source: PJsonDataValue);\nbegin\n  Dest.FTyp := Source.FTyp;\n  case Source.Typ of\n    jdtString:\n      begin\n        Dest.FValue.P := nil;\n        string(Dest.FValue.S) := string(Source.FValue.S);\n      end;\n    jdtInt:\n      Dest.FValue.I := Source.FValue.I;\n    jdtLong:\n      Dest.FValue.L := Source.FValue.L;\n    jdtULong:\n      Dest.FValue.U := Source.FValue.U;\n    jdtFloat:\n      Dest.FValue.F := Source.FValue.F;\n    jdtDateTime, jdtUtcDateTime:\n      Dest.FValue.D := Source.FValue.D;\n    jdtBool:\n      Dest.FValue.B := Source.FValue.B;\n    jdtArray:\n      begin\n        {$IFDEF AUTOREFCOUNT}\n        Dest.FValue.A := nil;\n        {$ENDIF AUTOREFCOUNT}\n        if Source.FValue.A <> nil then\n        begin\n          {$IFDEF USE_FAST_AUTOREFCOUNT}\n          Dest.FValue.A := TJsonArray.Create;\n          TJsonArray(Dest.FValue.A).ARCObjAddRef;\n          {$ELSE}\n          TJsonArray(Dest.FValue.A) := TJsonArray.Create;\n          {$ENDIF USE_FAST_AUTOREFCOUNT}\n          TJsonArray(Dest.FValue.A).Assign(TJsonArray(Source.FValue.A));\n        end\n        {$IFNDEF AUTOREFCOUNT}\n        else\n          Dest.FValue.A := nil;\n        {$ENDIF ~AUTOREFCOUNT}\n      end;\n    jdtObject:\n      begin\n        {$IFDEF AUTOREFCOUNT}\n        Dest.FValue.O := nil;\n        {$ENDIF AUTOREFCOUNT}\n        if Source.FValue.O <> nil then\n        begin\n          {$IFDEF USE_FAST_AUTOREFCOUNT}\n          Dest.FValue.O := TJsonObject.Create;\n          TJsonObject(Dest.FValue.O).ARCObjAddRef;\n          {$ELSE}\n          TJsonObject(Dest.FValue.O) := TJsonObject.Create;\n          {$ENDIF USE_FAST_AUTOREFCOUNT}\n          TJsonObject(Dest.FValue.O).Assign(TJsonObject(Source.FValue.O));\n        end\n        {$IFNDEF AUTOREFCOUNT}\n        else\n          Dest.FValue.O := nil;\n        {$ENDIF ~AUTOREFCOUNT}\n      end;\n  end;\nend;\n\nprocedure TJsonDataValue.TypeCastError(ExpectedType: TJsonDataType);\nbegin\n  raise EJsonCastException.CreateResFmt(@RsTypeCastError,\n    [TJsonBaseObject.DataTypeNames[FTyp], TJsonBaseObject.DataTypeNames[ExpectedType]])\n    {$IFDEF HAS_RETURN_ADDRESS} at ReturnAddress{$ENDIF};\nend;\n\n{ TJsonArrayEnumerator }\n\nconstructor TJsonArrayEnumerator.Create(AArray: TJSonArray);\nbegin\n  FIndex := -1;\n  FArray := AArray;\nend;\n\nfunction TJsonArrayEnumerator.GetCurrent: TJsonDataValueHelper;\nbegin\n  Result := FArray[FIndex];\nend;\n\nfunction TJsonArrayEnumerator.MoveNext: Boolean;\nbegin\n  Result := FIndex < FArray.Count - 1;\n  if Result then\n    Inc(FIndex);\nend;\n\n{ TJsonArray }\n\ndestructor TJsonArray.Destroy;\nbegin\n  Clear;\n  FreeMem(FItems);\n  FItems := nil;\n  //inherited Destroy;\nend;\n\nprocedure TJsonArray.Clear;\nvar\n  I: Integer;\nbegin\n  for I := 0 to FCount - 1 do\n    FItems[I].Clear;\n  FCount := 0;\nend;\n\nprocedure TJsonArray.Delete(Index: Integer);\nbegin\n  if (Index < 0) or (Index >= FCount) then\n    ListError(@SListIndexError, Index);\n  FItems[Index].Clear;\n  Dec(FCount);\n  if Index < FCount then\n    Move(FItems[Index + 1], FItems[Index], (FCount - Index) * SizeOf(TJsonDataValue));\nend;\n\nfunction TJsonArray.AddItem: PJsonDataValue;\nbegin\n  if FCount = FCapacity then\n    Grow;\n  Result := @FItems[FCount];\n  Result.FTyp := jdtNone;\n  Result.FValue.P := nil;\n  Inc(FCount);\nend;\n\nfunction TJsonArray.InsertItem(Index: Integer): PJsonDataValue;\nbegin\n  if Cardinal(Index) > Cardinal(FCount) then\n    RaiseListError(Index);\n\n  if FCount = FCapacity then\n    Grow;\n  Result := @FItems[Index];\n  if Index < FCount then\n    Move(Result^, FItems[Index + 1], (FCount - Index) * SizeOf(TJsonDataValue));\n  Result.FTyp := jdtNone;\n  Result.FValue.P := nil;\n  Inc(FCount);\nend;\n\nprocedure TJsonArray.Grow;\nvar\n  C, Delta: Integer;\nbegin\n  C := FCapacity;\n  if C > 64 then\n    Delta := C div 4\n  else if C > 8 then\n    Delta := 16\n  else\n    Delta := 4;\n  FCapacity := C + Delta;\n  InternApplyCapacity;\nend;\n\nprocedure TJsonArray.InternApplyCapacity;\nbegin\n  ReallocMem(Pointer(FItems), FCapacity * SizeOf(TJsonDataValue));\nend;\n\nprocedure TJsonArray.SetCapacity(const Value: Integer);\nvar\n  I: Integer;\nbegin\n  if Value <> FCapacity then\n  begin\n    if FCapacity < FCount then\n    begin\n      // delete all overlapping items\n      for I := FCapacity to FCount - 1 do\n        FItems[I].Clear;\n      FCount := FCapacity;\n    end;\n    FCapacity := Value;\n    InternApplyCapacity;\n  end;\nend;\n\nfunction TJsonArray.Extract(Index: Integer): TJsonBaseObject;\nbegin\n  if Items[Index].FTyp in [jdtNone, jdtArray, jdtObject] then\n  begin\n    Result := TJsonBaseObject(FItems[Index].FValue.O);\n    TJsonBaseObject(FItems[Index].FValue.O) := nil;\n  end\n  else\n    Result := nil;\n  Delete(Index);\nend;\n\nfunction TJsonArray.ExtractArray(Index: Integer): TJsonArray;\nbegin\n  Result := Extract(Index) as TJsonArray;\nend;\n\nfunction TJsonArray.ExtractObject(Index: Integer): TJsonObject;\nbegin\n  Result := Extract(Index) as TJsonObject;\nend;\n\nfunction TJsonArray.GetArray(Index: Integer): TJsonArray;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].ArrayValue;\nend;\n\nfunction TJsonArray.GetBool(Index: Integer): Boolean;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].BoolValue;\nend;\n\n{$IFDEF BCB}\nfunction TJsonArray.GetObj(Index: Integer): TJsonObject;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].ObjectValue;\nend;\n{$ELSE}\nfunction TJsonArray.GetObject(Index: Integer): TJsonObject;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].ObjectValue;\nend;\n{$ENDIF BCB}\n\nfunction TJsonArray.GetVariant(Index: Integer): Variant;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].VariantValue;\nend;\n\nfunction TJsonArray.GetInt(Index: Integer): Integer;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].IntValue;\nend;\n\nfunction TJsonArray.GetLong(Index: Integer): Int64;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].LongValue;\nend;\n\nfunction TJsonArray.GetULong(Index: Integer): UInt64;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].ULongValue;\nend;\n\nfunction TJsonArray.GetFloat(Index: Integer): Double;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].FloatValue;\nend;\n\nfunction TJsonArray.GetDateTime(Index: Integer): TDateTime;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].DateTimeValue;\nend;\n\nfunction TJsonArray.GetUtcDateTime(Index: Integer): TDateTime;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].UtcDateTimeValue;\nend;\n\nfunction TJsonArray.GetItem(Index: Integer): PJsonDataValue;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := @FItems[Index];\nend;\n\nfunction TJsonArray.GetString(Index: Integer): string;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].Value;\nend;\n\nprocedure TJsonArray.Add(const AValue: TJsonObject);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.ObjectValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: TJsonArray);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.ArrayValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: Boolean);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.BoolValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: Integer);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.IntValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: Int64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.LongValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: UInt64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.ULongValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: Double);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.FloatValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: TDateTime);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.DateTimeValue := AValue;\nend;\n\nprocedure TJsonArray.AddUtcDateTime(const AValue: TDateTime);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.UtcDateTimeValue := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: string);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := AddItem;\n  Data.Value := AValue;\nend;\n\nprocedure TJsonArray.Add(const AValue: Variant);\nvar\n  Data: PJsonDataValue;\nbegin\n  VarTypeToJsonDataType(VarType(AValue)); // Handle type-check exception before adding the item\n  Data := AddItem;\n  Data.VariantValue := AValue;\nend;\n\nfunction TJsonArray.AddArray: TJsonArray;\nbegin\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  if Result <> nil then\n    Result.ARCObjRelease;\n  Pointer(Result) := TJsonArray.Create;\n  Result.ARCObjAddRef;\n  {$ELSE}\n  Result := TJsonArray.Create;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\n  Add(Result);\nend;\n\nfunction TJsonArray.AddObject: TJsonObject;\nbegin\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  if Result <> nil then\n    Result.ARCObjRelease;\n  Pointer(Result) := TJsonObject.Create;\n  Result.ARCObjAddRef;\n  {$ELSE}\n  Result := TJsonObject.Create;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\n  Add(Result);\nend;\n\nprocedure TJsonArray.AddObject(const Value: TJsonObject);\nbegin\n  Add(Value);\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: TJsonObject);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.ObjectValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: TJsonArray);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.ArrayValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: Boolean);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.BoolValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: Integer);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.IntValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: Int64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.LongValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: UInt64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.ULongValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: Double);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.FloatValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: TDateTime);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.DateTimeValue := AValue;\nend;\n\nprocedure TJsonArray.InsertUtcDateTime(Index: Integer; const AValue: TDateTime);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.UtcDateTimeValue := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: string);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InsertItem(Index);\n  Data.Value := AValue;\nend;\n\nprocedure TJsonArray.Insert(Index: Integer; const AValue: Variant);\nvar\n  Data: PJsonDataValue;\nbegin\n  VarTypeToJsonDataType(VarType(AValue)); // Handle type-check exception before inserting the item\n  Data := InsertItem(Index);\n  Data.VariantValue := AValue;\nend;\n\nfunction TJsonArray.InsertArray(Index: Integer): TJsonArray;\nbegin\n  Result := TJsonArray.Create;\n  {$IFDEF AUTOREFCOUNT}\n  Insert(Index, Result);\n  {$ELSE}\n  try\n    Insert(Index, Result);\n  except\n    Result.Free;\n    raise;\n  end;\n  {$ENDIF AUTOREFCOUNT}\nend;\n\nfunction TJsonArray.InsertObject(Index: Integer): TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  {$IFDEF AUTOREFCOUNT}\n  Insert(Index, Result);\n  {$ELSE}\n  try\n    Insert(Index, Result);\n  except\n    Result.Free;\n    raise;\n  end;\n  {$ENDIF AUTOREFCOUNT}\nend;\n\nprocedure TJsonArray.InsertObject(Index: Integer; const Value: TJsonObject);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Insert(Index, Value);\nend;\n\nfunction TJsonArray.GetEnumerator: TJsonArrayEnumerator;\nbegin\n  Result := TJsonArrayEnumerator.Create(Self);\nend;\n\nfunction TJsonArray.IsNull(Index: Integer): Boolean;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].IsNull\nend;\n\nprocedure TJsonArray.SetString(Index: Integer; const Value: string);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].Value := Value;\nend;\n\nprocedure TJsonArray.SetInt(Index: Integer; const Value: Integer);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].IntValue := Value;\nend;\n\nprocedure TJsonArray.SetLong(Index: Integer; const Value: Int64);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].LongValue := Value;\nend;\n\nprocedure TJsonArray.SetULong(Index: Integer; const Value: UInt64);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].ULongValue := Value;\nend;\n\nprocedure TJsonArray.SetFloat(Index: Integer; const Value: Double);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].FloatValue := Value;\nend;\n\nprocedure TJsonArray.SetDateTime(Index: Integer; const Value: TDateTime);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].DateTimeValue := Value;\nend;\n\nprocedure TJsonArray.SetUtcDateTime(Index: Integer; const Value: TDateTime);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].UtcDateTimeValue := Value;\nend;\n\nprocedure TJsonArray.SetBool(Index: Integer; const Value: Boolean);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].BoolValue := Value;\nend;\n\nprocedure TJsonArray.SetArray(Index: Integer; const Value: TJsonArray);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].ArrayValue := Value;\nend;\n\nprocedure TJsonArray.SetObject(Index: Integer; const Value: TJsonObject);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].ObjectValue := Value;\nend;\n\nprocedure TJsonArray.SetVariant(Index: Integer; const Value: Variant);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  FItems[Index].VariantValue := Value;\nend;\n\nfunction TJsonArray.GetType(Index: Integer): TJsonDataType;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result := FItems[Index].Typ;\nend;\n\nfunction TJsonArray.GetValue(Index: Integer): TJsonDataValueHelper;\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  Result.FData.FIntern := @FItems[Index];\n  Result.FData.FTyp := jdtNone;\nend;\n\nprocedure TJsonArray.SetValue(Index: Integer; const Value: TJsonDataValueHelper);\nbegin\n  {$IFDEF CHECK_ARRAY_INDEX}\n  if Cardinal(Index) >= Cardinal(FCount) then\n    RaiseListError(Index);\n  {$ENDIF CHECK_ARRAY_INDEX}\n  TJsonDataValueHelper.SetInternValue(@FItems[Index], Value);\nend;\n\nprocedure TJsonArray.InternToJSON(var Writer: TJsonOutputWriter);\nvar\n  I: Integer;\nbegin\n  if FCount = 0 then\n    Writer.AppendValue('[]')\n  else\n  begin\n    Writer.Indent('[');\n    FItems[0].InternToJSON(Writer);\n    for I := 1 to FCount - 1 do\n    begin\n      Writer.AppendSeparator(',');\n      FItems[I].InternToJSON(Writer);\n    end;\n    Writer.Unindent(']');\n  end;\nend;\n\nprocedure TJsonArray.Assign(ASource: TJsonArray);\nvar\n  I: Integer;\nbegin\n  Clear;\n  if ASource <> nil then\n  begin\n    if FCapacity < ASource.Count then\n    begin\n      FCapacity := ASource.Count;\n      ReallocMem(FItems, ASource.Count * SizeOf(TJsonDataValue));\n    end;\n    FCount := ASource.Count;\n    for I := 0 to ASource.Count - 1 do\n      InternInitAndAssignItem(@FItems[I], @ASource.FItems[I]);\n  end\n  else\n  begin\n    FreeMem(FItems);\n    FCapacity := 0;\n  end;\nend;\n\nfunction TJsonArray.Clone: TJsonArray;\nbegin\n  Result := TJsonArray.Create;\n  try\n    TJsonArray(Result).Assign(Self);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass procedure TJsonArray.RaiseListError(Index: Integer);\nbegin\n  ListError(@SListIndexError, Index);\nend;\n\nprocedure TJsonArray.SetCount(const Value: Integer);\nvar\n  I: Integer;\nbegin\n  if Value <> FCount then\n  begin\n    SetCapacity(Value);\n    // Initialize new Items to \"null\"\n    for I := FCount to Value - 1 do\n    begin\n      FItems[I].FTyp := jdtObject;\n      FItems[I].FValue.P := nil;\n    end;\n    FCount := Value;\n  end;\nend;\n\n{ TJsonObjectEnumerator }\n\nconstructor TJsonObjectEnumerator.Create(AObject: TJsonObject);\nbegin\n  FIndex := -1;\n  FObject := AObject;\nend;\n\nfunction TJsonObjectEnumerator.MoveNext: Boolean;\nbegin\n  Result := FIndex < FObject.Count - 1;\n  if Result then\n    Inc(FIndex);\nend;\n\nfunction TJsonObjectEnumerator.GetCurrent: TJsonNameValuePair;\nbegin\n  Result.Name := FObject.Names[FIndex];\n  Result.Value.FData.FIntern := FObject.Items[FIndex];\n  Result.Value.FData.FTyp := jdtNone;\nend;\n\n{ TJsonObject }\n\ndestructor TJsonObject.Destroy;\nbegin\n  Clear;\n  FreeMem(FItems);\n  FreeMem(FNames);\n  //inherited Destroy;\nend;\n\n{$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\nprocedure TJsonObject.UpdateLastValueItem(const Name: string; Item: PJsonDataValue);\nbegin\n  if (Pointer(Name) <> nil) and (PInteger(@PByte(Name)[-8])^ = -1) then // string literal\n  begin\n    FLastValueItem := Item;\n    FLastValueItemNamePtr := Pointer(Name);\n  end\n  else\n    FLastValueItem := nil;\nend;\n{$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n\nprocedure TJsonObject.Grow;\nvar\n  C, Delta: Integer;\nbegin\n  C := FCapacity;\n  if C > 64 then\n    Delta := C div 4\n  else if C > 8 then\n    Delta := 16\n  else\n    Delta := 4;\n  FCapacity := C + Delta;\n  InternApplyCapacity;\nend;\n\nprocedure TJsonObject.InternApplyCapacity;\nbegin\n  {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  FLastValueItem := nil;\n  {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  ReallocMem(Pointer(FItems), FCapacity * SizeOf(FItems[0]));\n  ReallocMem(Pointer(FNames), FCapacity * SizeOf(FNames[0]));\nend;\n\nprocedure TJsonObject.SetCapacity(const Value: Integer);\nvar\n  I: Integer;\nbegin\n  if Value <> FCapacity then\n  begin\n    if FCapacity < FCount then\n    begin\n      // delete all overlapping items\n      for I := FCapacity to FCount - 1 do\n      begin\n        FNames[I] := '';\n        FItems[I].Clear;\n      end;\n      FCount := FCapacity;\n    end;\n    FCapacity := Value;\n    InternApplyCapacity;\n  end;\nend;\n\nprocedure TJsonObject.Clear;\nvar\n  I: Integer;\nbegin\n  {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  FLastValueItem := nil;\n  {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  for I := 0 to FCount - 1 do\n  begin\n    FNames[I] := '';\n    FItems[I].Clear;\n  end;\n  FCount := 0;\nend;\n\nprocedure TJsonObject.Remove(const Name: string);\nvar\n  Idx: Integer;\nbegin\n  Idx := IndexOf(Name);\n  if Idx <> -1 then\n    Delete(Idx);\nend;\n\nfunction TJsonObject.Extract(const Name: string): TJsonBaseObject;\nvar\n  Index: Integer;\nbegin\n  Index := IndexOf(Name);\n  if Index <> -1 then\n  begin\n    if FItems[Index].FTyp in [jdtNone, jdtArray, jdtObject] then\n    begin\n      Result := TJsonBaseObject(FItems[Index].FValue.O);\n      TJsonBaseObject(FItems[Index].FValue.O) := nil;\n    end\n    else\n      Result := nil;\n    Delete(Index);\n  end\n  else\n    Result := nil;\nend;\n\nfunction TJsonObject.ExtractArray(const Name: string): TJsonArray;\nbegin\n  Result := Extract(Name) as TJsonArray;\nend;\n\nfunction TJsonObject.ExtractObject(const Name: string): TJsonObject;\nbegin\n  Result := Extract(Name) as TJsonObject;\nend;\n\nfunction TJsonObject.GetEnumerator: TJsonObjectEnumerator;\nbegin\n  Result := TJsonObjectEnumerator.Create(Self);\nend;\n\nfunction TJsonObject.IsNull(const Name: string): Boolean;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.IsNull\n  else\n    Result := True;\nend;\n\nfunction TJsonObject.AddItem(const Name: string): PJsonDataValue;\nvar\n  P: PString;\nbegin\n  if FCount = FCapacity then\n    Grow;\n  Result := @FItems[FCount];\n  P := @FNames[FCount];\n  Inc(FCount);\n  Pointer(P^) := nil; // initialize the string\n  {$IFDEF USE_NAME_STRING_LITERAL}\n  AsgString(P^, Name);\n  {$ELSE}\n  P^ := Name;\n  {$ENDIF USE_NAME_STRING_LITERAL}\n\n  Result.FValue.P := nil;\n  Result.FTyp := jdtNone;\nend;\n\nfunction TJsonObject.InternAddItem(var Name: string): PJsonDataValue;\nvar\n  P: PString;\nbegin\n  if FCount = FCapacity then\n    Grow;\n  Result := @FItems[FCount];\n  P := @FNames[FCount];\n  Inc(FCount);\n  // Transfer the string without going through UStrAsg and UStrClr\n  Pointer(P^) := Pointer(Name);\n  Pointer(Name) := nil;\n\n  Result.FValue.P := nil;\n  Result.FTyp := jdtNone;\nend;\n\nfunction TJsonObject.GetArray(const Name: string): TJsonArray;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.ArrayValue\n  else\n  begin\n    Result := TJsonArray.Create;\n    AddItem(Name).ArrayValue := Result;\n    {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    UpdateLastValueItem(Name, Item);\n    {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  end;\nend;\n\nfunction TJsonObject.GetBool(const Name: string): Boolean;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.BoolValue\n  else\n    Result := False;\nend;\n\nfunction TJsonObject.GetInt(const Name: string): Integer;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.IntValue\n  else\n    Result := 0;\nend;\n\nfunction TJsonObject.GetLong(const Name: string): Int64;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.LongValue\n  else\n    Result := 0;\nend;\n\nfunction TJsonObject.GetULong(const Name: string): UInt64;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.ULongValue\n  else\n    Result := 0;\nend;\n\nfunction TJsonObject.GetFloat(const Name: string): Double;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.FloatValue\n  else\n    Result := 0;\nend;\n\nfunction TJsonObject.GetDateTime(const Name: string): TDateTime;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.DateTimeValue\n  else\n    Result := 0;\nend;\n\nfunction TJsonObject.GetUtcDateTime(const Name: string): TDateTime;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.UtcDateTimeValue\n  else\n    Result := 0;\nend;\n\n{$IFDEF BCB}\nfunction TJsonObject.GetObj(const Name: string): TJsonObject;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.ObjectValue\n  else\n  begin\n    Result := TJsonObject.Create;\n    AddItem(Name).ObjectValue := Result;\n    {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    UpdateLastValueItem(Name, Item);\n    {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  end;\nend;\n{$ELSE}\nfunction TJsonObject.GetObject(const Name: string): TJsonObject;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.ObjectValue\n  else\n  begin\n    Result := TJsonObject.Create;\n    AddItem(Name).ObjectValue := Result;\n    {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    UpdateLastValueItem(Name, Item);\n    {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  end;\nend;\n{$ENDIF BCB}\n\nfunction TJsonObject.GetString(const Name: string): string;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.Value\n  else\n    Result := '';\nend;\n\nprocedure TJsonObject.SetArray(const Name: string; const Value: TJsonArray);\nbegin\n  RequireItem(Name).ArrayValue := Value;\nend;\n\nprocedure TJsonObject.SetBool(const Name: string; const Value: Boolean);\nbegin\n  RequireItem(Name).BoolValue := Value;\nend;\n\nprocedure TJsonObject.SetInt(const Name: string; const Value: Integer);\nbegin\n  RequireItem(Name).IntValue := Value;\nend;\n\nprocedure TJsonObject.SetLong(const Name: string; const Value: Int64);\nbegin\n  RequireItem(Name).LongValue := Value;\nend;\n\nprocedure TJsonObject.SetULong(const Name: string; const Value: UInt64);\nbegin\n  RequireItem(Name).ULongValue := Value;\nend;\n\nprocedure TJsonObject.SetFloat(const Name: string; const Value: Double);\nbegin\n  RequireItem(Name).FloatValue := Value;\nend;\n\nprocedure TJsonObject.SetDateTime(const Name: string; const Value: TDateTime);\nbegin\n  RequireItem(Name).DateTimeValue := Value;\nend;\n\nprocedure TJsonObject.SetUtcDateTime(const Name: string; const Value: TDateTime);\nbegin\n  RequireItem(Name).UtcDateTimeValue := Value;\nend;\n\nprocedure TJsonObject.SetObject(const Name: string; const Value: TJsonObject);\nbegin\n  RequireItem(Name).ObjectValue := Value;\nend;\n\nprocedure TJsonObject.SetString(const Name, Value: string);\nbegin\n  RequireItem(Name).Value := Value;\nend;\n\nfunction TJsonObject.GetType(const Name: string): TJsonDataType;\nvar\n  Item: PJsonDataValue;\nbegin\n  if FindItem(Name, Item) then\n    Result := Item.Typ\n  else\n    Result := jdtNone;\nend;\n\nfunction TJsonObject.Contains(const Name: string): Boolean;\n{$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\nvar\n  Item: PJsonDataValue;\n{$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\nbegin\n  {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  Result := FindItem(Name, Item);\n  {$ELSE}\n  Result := IndexOf(Name) <> -1;\n  {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\nend;\n\nfunction TJsonObject.IndexOfPChar(S: PChar; Len: Integer): Integer;\nvar\n  P: PJsonStringArray;\nbegin\n  P := FNames;\n  if Len = 0 then\n  begin\n    for Result := 0 to FCount - 1 do\n      if P[Result] = '' then\n        Exit;\n  end\n  else\n  begin\n    for Result := 0 to FCount - 1 do\n      if (Length(P[Result]) = Len) and CompareMem(S, Pointer(P[Result]), Len * SizeOf(Char)) then\n        Exit;\n  end;\n  Result := -1;\nend;\n\nfunction TJsonObject.IndexOf(const Name: string): Integer;\nvar\n  P: PJsonStringArray;\nbegin\n  P := FNames;\n  for Result := 0 to FCount - 1 do\n    if {(Pointer(Name) = Pointer(P[Result])) or} (Name = P[Result]) then\n      Exit;\n  Result := -1;\nend;\n\nfunction TJsonObject.FindItem(const Name: string; var Item: PJsonDataValue): Boolean;\nvar\n  Idx: Integer;\nbegin\n  {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  { If \"Name\" is a string literal we can compare the pointer of the last stored value instead of\n    searching the list. }\n  if (FLastValueItem <> nil) and (Pointer(Name) = FLastValueItemNamePtr) then\n  begin\n    Item := FLastValueItem;\n    Result := True;\n  end\n  else\n  {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  begin\n    Idx := IndexOf(Name);\n    Result := Idx <> -1;\n    if Result then\n    begin\n      Item := @FItems[Idx];\n      {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n      UpdateLastValueItem(Name, Item);\n      {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    end\n    else\n      Item := nil;\n  end;\nend;\n\nfunction TJsonObject.RequireItem(const Name: string): PJsonDataValue;\nbegin\n  if not FindItem(Name, Result) then\n  begin\n    Result := AddItem(Name);\n    {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n    UpdateLastValueItem(Name, Result);\n    {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  end;\nend;\n\nprocedure TJsonObject.InternToJSON(var Writer: TJsonOutputWriter);\nvar\n  I: Integer;\nbegin\n  if Count = 0 then\n    Writer.AppendValue('{}')\n  else\n  begin\n    Writer.Indent('{');\n    TJsonBaseObject.StrToJSONStr(Writer.AppendIntro, FNames[0]);\n    FItems[0].InternToJSON(Writer);\n    for I := 1 to FCount - 1 do\n    begin\n      Writer.AppendSeparator(',');\n      TJsonBaseObject.StrToJSONStr(Writer.AppendIntro, FNames[I]);\n      FItems[I].InternToJSON(Writer);\n    end;\n    Writer.Unindent('}');\n  end;\nend;\n\nfunction TJsonObject.GetName(Index: Integer): string;\nbegin\n  Result := FNames[Index];\nend;\n\nfunction TJsonObject.GetItem(Index: Integer): PJsonDataValue;\nbegin\n  Result := @FItems[Index];\nend;\n\nprocedure TJsonObject.Delete(Index: Integer);\nbegin\n  if (Index < 0) or (Index >= FCount) then\n    ListError(@SListIndexError, Index);\n\n  {$IFDEF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  if @FItems[Index] = FLastValueItem then\n  begin\n    FLastValueItem := nil;\n    //FLastValueItemNamePtr := nil;\n  end;\n  {$ENDIF USE_LAST_NAME_STRING_LITERAL_CACHE}\n  FNames[Index] := '';\n  FItems[Index].Clear;\n  Dec(FCount);\n  if Index < FCount then\n  begin\n    Move(FItems[Index + 1], FItems[Index], (FCount - Index) * SizeOf(FItems[0]));\n    Move(FNames[Index + 1], FNames[Index], (FCount - Index) * SizeOf(FNames[0]));\n  end;\nend;\n\nfunction TJsonObject.GetValue(const Name: string): TJsonDataValueHelper;\nbegin\n  if not FindItem(Name, Result.FData.FIntern) then\n  begin\n    Result.FData.FIntern := nil;\n    Result.FData.FNameResolver := Self;\n    Result.FData.FName := Name;\n  end;\n  Result.FData.FTyp := jdtNone;\nend;\n\nprocedure TJsonObject.SetValue(const Name: string; const Value: TJsonDataValueHelper);\nvar\n  Item: PJsonDataValue;\nbegin\n  Item := RequireItem(Name);\n  TJsonDataValueHelper.SetInternValue(Item, Value);\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: TJsonArray);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.InternSetArrayValue(AValue);\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: TJsonObject);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.InternSetObjectValue(AValue);\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: Boolean);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.BoolValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: Integer);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.IntValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: Int64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.LongValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: UInt64);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.ULongValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: Double);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.FloatValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: TDateTime);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.DateTimeValue := AValue;\nend;\n\nprocedure TJsonObject.InternAdd(var AName: string; const AValue: string);\nvar\n  Data: PJsonDataValue;\nbegin\n  Data := InternAddItem(AName);\n  Data.InternSetValue(AValue);\nend;\n\nfunction TJsonObject.InternAddArray(var AName: string): TJsonArray;\nbegin\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  if Result <> nil then\n    Result.ARCObjRelease;\n  Pointer(Result) := TJsonArray.Create;\n  Inc(Result.FRefCount); //Result.ARCObjAddRef;\n  {$ELSE}\n  Result := TJsonArray.Create;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\n  InternAdd(AName, Result);\nend;\n\nfunction TJsonObject.InternAddObject(var AName: string): TJsonObject;\nbegin\n  {$IFDEF USE_FAST_AUTOREFCOUNT}\n  if Result <> nil then\n    Result.ARCObjRelease;\n  Pointer(Result) := TJsonObject.Create;\n  Inc(Result.FRefCount); //Result.ARCObjAddRef;\n  {$ELSE}\n  Result := TJsonObject.Create;\n  {$ENDIF USE_FAST_AUTOREFCOUNT}\n  InternAdd(AName, Result);\nend;\n\nprocedure TJsonObject.ToSimpleObject(AObject: TObject; ACaseSensitive: Boolean);\nvar\n  Index, Count: Integer;\n  PropList: PPropList;\n  PropType: PTypeInfo;\n  PropName: string;\n  Item: PJsonDataValue;\n  V: Variant;\nbegin\n  if AObject = nil then\n    Exit;\n  if AObject.ClassInfo = nil then\n    raise EJsonException.CreateResFmt(@RsMissingClassInfo, [AObject.ClassName]);\n\n  Count := GetPropList(AObject, PropList);\n  if Count > 0 then\n  begin\n    try\n      for Index := 0 to Count - 1 do\n      begin\n        if (PropList[Index].StoredProc = Pointer($1)) or IsStoredProp(AObject, PropList[Index]) then\n        begin\n          PropName := UTF8ToString(PropList[Index].Name);\n          if not ACaseSensitive then\n            Item := FindCaseInsensitiveItem(PropName)\n          else if not FindItem(PropName, Item) then\n            Item := nil;\n\n          if Item <> nil then\n          begin\n            case PropList[Index].PropType^.Kind of\n              tkInteger, tkChar, tkWChar:\n                SetOrdProp(AObject, PropList[Index], Item.IntValue);\n\n              tkEnumeration:\n                SetOrdProp(AObject, PropList[Index], Item.IntValue);\n\n              tkFloat:\n                begin\n                  PropType := PropList[Index].PropType^;\n                  if (PropType = TypeInfo(TDateTime)) or (PropType = TypeInfo(TDate)) or (PropType = TypeInfo(TTime)) then\n                    SetFloatProp(AObject, PropList[Index], Item.DateTimeValue)\n                  else\n                    SetFloatProp(AObject, PropList[Index], Item.FloatValue);\n                end;\n\n              tkInt64:\n                SetInt64Prop(AObject, PropList[Index], Item.LongValue);\n\n              tkString, tkLString, tkWString, tkUString:\n                SetStrProp(AObject, PropList[Index], Item.Value);\n\n              tkSet:\n                SetSetProp(AObject, PropList[Index], Item.Value);\n\n              tkVariant:\n                begin\n                  case Types[PropName] of\n                    jdtObject, jdtArray:\n                      V := Null;\n                    jdtInt:\n                      V := Item.IntValue;\n                    jdtLong:\n                      V := Item.LongValue;\n                    jdtULong:\n                      V := Item.ULongValue;\n                    jdtFloat:\n                      V := Item.FloatValue;\n                    jdtDateTime:\n                      V := Item.DateTimeValue;\n                    jdtUtcDateTime:\n                      V := Item.UtcDateTimeValue;\n                    jdtBool:\n                      V := Item.BoolValue;\n                  else\n                    V := Item.Value;\n                  end;\n                  SetVariantProp(AObject, PropList[Index], V);\n                end;\n            end;\n          end;\n        end;\n      end;\n    finally\n      FreeMem(PropList);\n    end;\n  end;\nend;\n\nprocedure TJsonObject.FromSimpleObject(AObject: TObject; ALowerCamelCase: Boolean);\nvar\n  Index, Count: Integer;\n  PropList: PPropList;\n  PropType: PTypeInfo;\n  PropName: string;\n  V: Variant;\n  D: Double;\n  Ch: Char;\nbegin\n  Clear;\n  if AObject = nil then\n    Exit;\n  if AObject.ClassInfo = nil then\n    raise EJsonException.CreateResFmt(@RsMissingClassInfo, [AObject.ClassName]);\n\n  Count := GetPropList(AObject, PropList);\n  if Count > 0 then\n  begin\n    try\n      for Index := 0 to Count - 1 do\n      begin\n        if (PropList[Index].StoredProc = Pointer($1)) or IsStoredProp(AObject, PropList[Index]) then\n        begin\n          PropName := UTF8ToString(PropList[Index].Name);\n          if ALowerCamelCase and (PropName <> '') then\n          begin\n            Ch := PChar(Pointer(PropName))^;\n            if Ord(Ch) < 128 then\n            begin\n              case Ch of\n                'A'..'Z':\n                  PChar(Pointer(PropName))^ := Char(Ord(Ch) xor $20);\n              end;\n            end\n            else // Delphi 2005+ compilers allow unicode identifiers, even if that is a very bad idea\n              AnsiLowerCamelCaseString(PropName);\n          end;\n\n          case PropList[Index].PropType^.Kind of\n            tkInteger, tkChar, tkWChar:\n              InternAdd(PropName, GetOrdProp(AObject, PropList[Index]));\n\n            tkEnumeration:\n              begin\n                PropType := PropList[Index].PropType^;\n                if (PropType = TypeInfo(Boolean)) or (PropType = TypeInfo(ByteBool)) or\n                   (PropType = TypeInfo(WordBool)) or (PropType = TypeInfo(LongBool)) then\n                  InternAdd(PropName, GetOrdProp(AObject, PropList[Index]) <> 0)\n                else\n                  InternAdd(PropName, GetOrdProp(AObject, PropList[Index]));\n              end;\n\n            tkFloat:\n              begin\n                PropType := PropList[Index].PropType^;\n                D := GetFloatProp(AObject, PropList[Index]);\n                if (PropType = TypeInfo(TDateTime)) or (PropType = TypeInfo(TDate)) or (PropType = TypeInfo(TTime)) then\n                  InternAdd(PropName, TDateTime(D))\n                else\n                  InternAdd(PropName, D);\n              end;\n\n            tkInt64:\n              InternAdd(PropName, GetInt64Prop(AObject, PropList[Index]));\n\n            tkString, tkLString, tkWString, tkUString:\n              InternAdd(PropName, GetStrProp(AObject, PropList[Index]));\n\n            tkSet:\n              InternAdd(PropName, GetSetProp(AObject, PropList[Index]));\n\n            tkVariant:\n              begin\n                V := GetVariantProp(AObject, PropList[Index]);\n                if VarIsNull(V) or VarIsEmpty(V) then\n                  InternAdd(PropName, TJsonObject(nil))\n                else\n                begin\n                  case VarType(V) and varTypeMask of\n                    varSingle, varDouble, varCurrency:\n                      InternAdd(PropName, Double(V));\n                    varShortInt, varSmallint, varInteger, varByte, varWord:\n                      InternAdd(PropName, Integer(V));\n                    varLongWord:\n                      InternAdd(PropName, Int64(LongWord(V)));\n                    {$IF CompilerVersion >= 23.0} // XE2+\n                    varInt64:\n                      InternAdd(PropName, Int64(V));\n                    {$IFEND}\n                    varBoolean:\n                      InternAdd(PropName, Boolean(V));\n                  else\n                    InternAdd(PropName, VarToStr(V));\n                  end;\n                end;\n              end;\n          end;\n        end;\n      end;\n    finally\n      FreeMem(PropList);\n    end;\n  end;\nend;\n\nfunction TJsonObject.FindCaseInsensitiveItem(const ACaseInsensitiveName: string): PJsonDataValue;\nvar\n  I: Integer;\nbegin\n  for I := 0 to Count - 1 do\n  begin\n    if AnsiSameText(FNames[I], ACaseInsensitiveName) then\n    begin\n      Result := @FItems[I];\n      Exit;\n    end;\n  end;\n  Result := nil;\nend;\n\nprocedure TJsonObject.Assign(ASource: TJsonObject);\nvar\n  I: Integer;\nbegin\n  Clear;\n  if ASource <> nil then\n  begin\n    FCapacity := ASource.Count;\n    InternApplyCapacity;\n\n    FCount := ASource.Count;\n    for I := 0 to ASource.Count - 1 do\n    begin\n      Pointer(FNames[I]) := nil;\n      {$IFDEF USE_NAME_STRING_LITERAL}\n      AsgString(FNames[I], ASource.FNames[I]);\n      {$ELSE}\n      FNames[I] := ASource.FNames[I];\n      {$ENDIF USE_NAME_STRING_LITERAL}\n      InternInitAndAssignItem(@FItems[I], @ASource.FItems[I]);\n    end;\n  end\n  else\n  begin\n    FreeMem(FItems);\n    FreeMem(FNames);\n    FCapacity := 0;\n  end;\nend;\n\nfunction TJsonObject.Clone: TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  try\n    TJsonObject(Result).Assign(Self);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nprocedure TJsonObject.PathError(P, EndP: PChar);\nvar\n  S: string;\nbegin\n  System.SetString(S, P, EndP - P);\n  raise EJsonPathException.CreateResFmt(@RsInvalidJsonPath, [S]);\nend;\n\nprocedure TJsonObject.PathNullError(P, EndP: PChar);\nvar\n  S: string;\nbegin\n  System.SetString(S, P, EndP - P);\n  raise EJsonPathException.CreateResFmt(@RsJsonPathContainsNullValue, [S]);\nend;\n\nprocedure TJsonObject.PathIndexError(P, EndP: PChar; Count: Integer);\nvar\n  S: string;\nbegin\n  System.SetString(S, P, EndP - P);\n  raise EJsonPathException.CreateResFmt(@RsJsonPathIndexError, [Count, S]);\nend;\n\nfunction TJsonObject.GetPath(const NamePath: string): TJsonDataValueHelper;\nvar\n  F, P, EndF, LastEndF: PChar;\n  Ch: Char;\n  Idx: Integer;\n  Obj: TJsonObject;\n  Arr: TJsonArray;\n  Item: PJsonDataValue;\n  S: string;\nbegin\n  P := PChar(NamePath);\n  // empty string => Self\n  if P^ = #0 then\n  begin\n    Result := Self;\n    Exit;\n  end;\n\n  Result.FData.FIntern := nil;\n  Result.FData.FTyp := jdtNone;\n\n  Obj := Self;\n  Item := nil;\n  LastEndF := nil;\n  while True do\n  begin\n    F := P;\n\n    // fast forward\n    Ch := P^;\n//    DCC64 generates \"bt mem,reg\" code\n//    while not (Ch in [#0, '[', '.']) do\n//    begin\n//      Inc(P);\n//      Ch := P^;\n//    end;\n    while True do\n      case Ch of\n        #0, '[', '.': Break;\n      else\n        Inc(P);\n        Ch := P^;\n      end;\n\n    EndF := P;\n    if F = EndF then\n      PathError(PChar(Pointer(NamePath)), P + 1);\n\n    Inc(P);\n    case Ch of\n      #0:\n        begin\n          if Obj <> nil then\n          begin\n            Idx := Obj.IndexOfPChar(F, EndF - F);\n            if Idx <> -1 then\n              Result.FData.FIntern := @Obj.FItems[Idx]\n            else\n            begin\n              Result.FData.FNameResolver := Obj;\n              System.SetString(Result.FData.FName, F, EndF - F);\n            end;\n          end\n          else\n            Result.FData.FIntern := Item;\n          Break;\n        end;\n\n      '.': // object access\n        begin\n          if Obj = nil then\n            PathNullError(PChar(Pointer(NamePath)), LastEndF);\n\n          Idx := Obj.IndexOfPChar(F, EndF - F);\n          if Idx <> -1 then\n            Obj := Obj.FItems[Idx].ObjectValue\n          else\n          begin\n            // auto create object\n            System.SetString(S, F, EndF - F);\n            Obj := Obj.InternAddObject(S);\n          end;\n        end;\n\n      '[': // array access\n        begin\n          if Obj = nil then\n            PathNullError(PChar(Pointer(NamePath)), LastEndF);\n\n          Idx := Obj.IndexOfPChar(F, EndF - F);\n          if Idx <> -1 then\n          begin\n            Arr := Obj.FItems[Idx].ArrayValue;\n            if Arr = nil then\n            begin\n              // Shouldn't happen => auto create array\n              Arr := TJsonArray.Create;\n              Obj.FItems[Idx].ArrayValue := Arr;\n            end;\n          end\n          else\n          begin\n            // auto create array\n            System.SetString(S, F, EndF - F);\n            Arr := Obj.InternAddArray(S);\n          end;\n          Ch := P^;\n          // parse array index\n          Idx := 0;\n          while Ch in ['0'..'9'] do\n          begin\n            Idx := Idx * 10 + (Word(Ch) - Ord('0'));\n            Inc(P);\n            Ch := P^;\n          end;\n\n          if P^ <> ']' then\n            PathError(PChar(Pointer(NamePath)), P + 1);\n          Inc(P);\n\n          if Idx >= Arr.Count then\n            PathIndexError(PChar(Pointer(NamePath)), P, Arr.Count); // P is already incremented\n          Item := @Arr.FItems[Idx];\n\n          if P^ = '.' then\n          begin\n            Inc(P);\n            Obj := Item.ObjectValue;\n            Item := nil;\n          end\n          else if P^ = #0 then\n          begin\n            // return array element\n            Result.FData.FIntern := Item;\n            Break;\n          end;\n        end;\n    end;\n    LastEndF := EndF;\n  end;\nend;\n\nprocedure TJsonObject.SetPath(const NamePath: string; const Value: TJsonDataValueHelper);\nvar\n  PathValue: TJsonDataValueHelper;\nbegin\n  PathValue := Path[NamePath];\n  PathValue.ResolveName;\n  TJsonDataValueHelper.SetInternValue(PathValue.FData.FIntern, Value);\nend;\n\n{ TStringIntern }\n\n{$IFDEF USE_STRINGINTERN_FOR_NAMES}\nprocedure TStringIntern.Init;\nbegin\n  FCount := 0;\n  FCapacity := 17;\n  GetMem(FStrings, FCapacity * SizeOf(FStrings[0]));\n  GetMem(FBuckets, FCapacity * SizeOf(FBuckets[0]));\n  FillChar(FBuckets[0], FCapacity * SizeOf(FBuckets[0]), $FF);\nend;\n\nprocedure TStringIntern.Done;\nvar\n  I: Integer;\nbegin\n  for I := 0 to FCount - 1 do\n    FStrings[I].Name := '';\n  FreeMem(FStrings);\n  FreeMem(FBuckets);\nend;\n\nprocedure TStringIntern.Intern(var S: string; var PropName: string);\nvar\n  Index: Integer;\n  Hash: Integer;\n  {$IFDEF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n  Source: Pointer;\n  {$ENDIF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\nbegin\n  if PropName <> '' then\n    PropName := ''; // guarantee that Pointer(FPropName) = nil because InternTransfer steals FLook.S and overwrites FPropName\n  if S <> '' then\n  begin\n    Hash := GetHash(S);\n    Index := Find(Hash, S);\n    if Index <> -1 then\n    begin\n      {$IFDEF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n      Source := Pointer(FStrings[Index].Name);\n      if Source <> nil then\n      begin\n        {$IFDEF DEBUG}\n        //if PInteger(@PByte(Source)[-8])^ = -1 then\n        //  InternAsgStringUsageError;\n        {$ENDIF DEBUG}\n        Pointer(PropName) := Source;\n        // We are parsing JSON, no other thread knowns about the string => skip the CPU lock\n        Inc(PInteger(@PByte(Source)[-8])^);\n      end;\n      {$ELSE}\n      PropName := FStrings[Index].Name;\n      {$ENDIF USE_FAST_STRASG_FOR_INTERNAL_STRINGS}\n      S := '';\n    end\n    else\n    begin\n      // Transfer the string without going through UStrAsg and UStrClr\n      Pointer(PropName) := Pointer(S);\n      Pointer(S) := nil;\n      InternAdd(Hash, PropName);\n    end;\n  end;\nend;\n\nclass function TStringIntern.GetHash(const Name: string): Integer;\nvar\n  P: PChar;\n  Ch: Word;\nbegin\n  // Only used to reduce memory when parsing large JSON strings\n  Result := 0;\n  P := PChar(Pointer(Name));\n  if P <> nil then\n  begin\n    Result := PInteger(@PByte(Name)[-4])^;\n    while True do\n    begin\n      Ch := Word(P[0]);\n      if Ch = 0 then\n        Break;\n      Result := Result + Ch;\n\n      Ch := Word(P[1]);\n      if Ch = 0 then\n        Break;\n      Result := Result + Ch;\n\n      Ch := Word(P[2]);\n      if Ch = 0 then\n        Break;\n      Result := Result + Ch;\n\n      Ch := Word(P[3]);\n      if Ch = 0 then\n        Break;\n      Result := Result + Ch;\n\n      Result := (Result shl 6) or ((Result shr 26) and $3F);\n      Inc(P, 4);\n    end;\n  end;\nend;\n\nprocedure TStringIntern.InternAdd(AHash: Integer; const S: string);\nvar\n  Index: Integer;\n  Bucket: PInteger;\nbegin\n  if FCount = FCapacity then\n    Grow;\n  Index := FCount;\n  Inc(FCount);\n\n  Bucket := @FBuckets[(AHash and $7FFFFFFF) mod FCapacity];\n  with FStrings[Index] do\n  begin\n    Next := Bucket^;\n    Hash := AHash;\n    Pointer(Name) := Pointer(S);\n    Inc(PInteger(@PByte(Name)[-8])^);\n  end;\n  Bucket^ := Index;\nend;\n\nprocedure TStringIntern.Grow;\nvar\n  I: Integer;\n  Index: Integer;\n  Len: Integer;\nbegin\n  Len := FCapacity;\n  // Some prime numbers\n  case Len of\n      17: Len := 37;\n      37: Len := 59;\n      59: Len := 83;\n      83: Len := 127;\n     127: Len := 353;\n     353: Len := 739;\n     739: Len := 1597;\n    1597: Len := 2221;\n  else\n    Len := Len * 2 + 1;\n  end;\n  FCapacity := Len;\n\n  ReallocMem(FStrings, Len * SizeOf(FStrings[0]));\n  ReallocMem(FBuckets, Len * SizeOf(FBuckets[0]));\n  FillChar(FBuckets[0], Len * SizeOf(FBuckets[0]), $FF);\n\n  // Rehash\n  for I := 0 to FCount - 1 do\n  begin\n    Index := (FStrings[I].Hash and $7FFFFFFF) mod Len;\n    FStrings[I].Next := FBuckets[Index];\n    FBuckets[Index] := I;\n  end;\nend;\n\nfunction TStringIntern.Find(Hash: Integer; const S: string): Integer;\nvar\n  Strs: PJsonStringEntryArray;\nbegin\n  Result := -1;\n  if FCount <> 0 then\n  begin\n    Result := FBuckets[(Hash and $7FFFFFFF) mod FCapacity];\n    if Result <> -1 then\n    begin\n      Strs := FStrings;\n      while True do\n      begin\n        if (Strs[Result].Hash = Hash) and (Strs[Result].Name = S) then\n          Break;\n        Result := Strs[Result].Next;\n        if Result = -1 then\n          Break;\n      end;\n    end;\n  end;\nend;\n{$ENDIF USE_STRINGINTERN_FOR_NAMES}\n\n{ TJsonOutputWriter }\n\nprocedure TJsonOutputWriter.Init(ACompact: Boolean; AStream: TStream; AEncoding: TEncoding;\n  ALines: TStrings; const Config: TJsonSerializationConfig);\nbegin\n  FCompact := ACompact;\n  FStream := AStream;\n  FEncoding := AEncoding;\n  FConfig := Config;\n\n  if ALines <> nil then\n  begin\n    FCompact := False; // there is no compact version for TStrings\n    FLines := ALines;\n  end\n  else\n  begin\n    FStreamEncodingBuffer := nil;\n    FStreamEncodingBufferLen := 0;\n    FLines := nil;\n    FStringBuffer.Init;\n  end;\n\n  if not ACompact then\n  begin\n    FLastLine.Init;\n\n    FIndent := 0;\n    FLastType := ltInitial;\n\n    // Set up some initial indention levels\n    // TODO change to one buffer with #0 vs. IndentChar\n    FIndents := AllocMem(5 * SizeOf(string));\n    FIndentsLen := 5;\n    //FIndents[0] := '';\n    FIndents[1] := FConfig.IndentChar;\n    FIndents[2] := FIndents[1] + FIndents[1];\n    FIndents[3] := FIndents[2] + FIndents[1];\n    FIndents[4] := FIndents[3] + FIndents[1];\n  end;\nend;\n\nprocedure TJsonOutputWriter.FreeIndents;\nvar\n  I: Integer;\nbegin\n  for I := 0 to FIndentsLen - 1 do\n    FIndents[I] := '';\n  FreeMem(FIndents);\nend;\n\nfunction TJsonOutputWriter.Done: string;\nbegin\n  if not FCompact then\n  begin\n    FlushLastLine;\n    FreeIndents;\n    FLastLine.Done;\n  end;\n\n  if FLines = nil then\n    FStringBuffer.DoneConvertToString(Result);\nend;\n\nprocedure TJsonOutputWriter.LinesDone;\nbegin\n  FreeIndents;\n  FlushLastLine;\n  FLastLine.Done;\nend;\n\nprocedure TJsonOutputWriter.StreamDone;\nbegin\n  if not FCompact then\n  begin\n    FlushLastLine;\n    FreeIndents;\n    FLastLine.Done;\n  end;\n\n  if FStream <> nil then\n    StreamFlush;\n  if FStreamEncodingBuffer <> nil then\n    FreeMem(FStreamEncodingBuffer);\n  FStringBuffer.Done;\nend;\n\nprocedure TJsonOutputWriter.FlushLastLine;\nvar\n  S: Pointer;\nbegin\n  if FLastLine.Len > 0 then\n  begin\n    if FLines = nil then\n    begin\n      FLastLine.FlushToStringBuffer(FStringBuffer);\n      FStringBuffer.Append(FConfig.LineBreak);\n    end\n    else\n    begin\n      S := nil;\n      try\n        FLastLine.FlushToString(string(S));\n        FLines.Add(string(S));\n      finally\n        string(S) := '';\n      end;\n    end\n  end;\nend;\n\nprocedure TJsonOutputWriter.StreamFlush;\nvar\n  Size: NativeInt;\nbegin\n  if FStringBuffer.Len > 0 then\n  begin\n    if FEncoding = TEncoding.Unicode then\n    begin\n      FStream.Write(FStringBuffer.Data[0], FStringBuffer.Len);\n      FStringBuffer.FLen := 0;\n    end\n    else if FStream is TMemoryStream then\n      FStringBuffer.FlushToMemoryStream(TMemoryStream(FStream), FEncoding)\n    else\n    begin\n      Size := FStringBuffer.FlushToBytes(FStreamEncodingBuffer, FStreamEncodingBufferLen, FEncoding);\n      if Size > 0 then\n        FStream.Write(FStreamEncodingBuffer[0], Size);\n    end;\n  end;\nend;\n\nprocedure TJsonOutputWriter.StreamFlushPossible;\nconst\n  MinFlushBufferLen = 1024 * 1024;\nbegin\n  if (FStream <> nil) and (FStringBuffer.Len >= MinFlushBufferLen) then\n    StreamFlush;\nend;\n\nprocedure TJsonOutputWriter.ExpandIndents;\nbegin\n  Inc(FIndentsLen);\n  ReallocMem(Pointer(FIndents), FIndentsLen * SizeOf(string));\n  Pointer(FIndents[FIndent]) := nil;\n  FIndents[FIndent] := FIndents[FIndent - 1] + FConfig.IndentChar;\nend;\n\nprocedure TJsonOutputWriter.AppendLine(AppendOn: TLastType; const S: string);\nbegin\n  if FLastType = AppendOn then\n    FLastLine.Append(S)\n  else\n  begin\n    FlushLastLine;\n    StreamFlushPossible;\n    FLastLine.Append2(FIndents[FIndent], PChar(Pointer(S)), Length(S));\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendLine(AppendOn: TLastType; P: PChar; Len: Integer);\nbegin\n  if FLastType = AppendOn then\n    FLastLine.Append(P, Len)\n  else\n  begin\n    FlushLastLine;\n    StreamFlushPossible;\n    FLastLine.Append2(FIndents[FIndent], P, Len);\n  end;\nend;\n\nprocedure TJsonOutputWriter.Indent(const S: string);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append(S);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    This.AppendLine(ltIntro, S); // inlined\n    Inc(This.FIndent);\n    if This.FIndent >= This.FIndentsLen then // this is a new indention level\n      ExpandIndents;\n    This.FLastType := ltIndent;\n  end;\nend;\n\nprocedure TJsonOutputWriter.Unindent(const S: string);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append(S);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    Dec(This.FIndent);\n    //Assert(FIndent >= 0);\n    This.AppendLine(ltIndent, S); // inlined\n    This.FLastType := ltUnindent;\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendIntro(P: PChar; Len: Integer);\nconst\n  sQuoteCharColon = '\":';\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append2(sQuoteChar, P, Len).Append(sQuoteCharColon, 2);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    FlushLastLine;\n    This.StreamFlushPossible; // inlined\n    This.FLastLine.Append(This.FIndents[This.FIndent]).Append2(sQuoteChar, P, Len).Append('\": ', 3);\n    This.FLastType := ltIntro;\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendValue(P: PChar; Len: Integer);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append(P, Len);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    This.AppendLine(ltIntro, P, Len); // inlined\n    This.FLastType := ltValue;\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendValue(const S: string);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append(S);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    This.AppendLine(ltIntro, S); // inlined\n    This.FLastType := ltValue;\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendStrValue(P: PChar; Len: Integer);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append3(sQuoteChar, P, Len, sQuoteChar);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    if This.FLastType = ltIntro then\n      This.FLastLine.Append3(sQuoteChar, P, Len, sQuoteChar)\n    else\n    begin\n      FlushLastLine;\n      This.StreamFlushPossible; // inlined\n      This.FLastLine.Append(This.FIndents[This.FIndent]).Append3(sQuoteChar, P, Len, sQuoteChar);\n    end;\n    This.FLastType := ltValue;\n  end;\nend;\n\nprocedure TJsonOutputWriter.AppendSeparator(const S: string);\nvar\n  This: ^TJsonOutputWriter;\nbegin\n  This := @Self;\n  if This.FCompact then\n  begin\n    This.FStringBuffer.Append(S);\n    This.StreamFlushPossible; // inlined\n  end\n  else\n  begin\n    if This.FLastType in [ltValue, ltUnindent] then\n      This.FLastLine.Append(S)\n    else\n    begin\n      FlushLastLine;\n      This.StreamFlushPossible; // inlined\n      This.FLastLine.Append2(This.FIndents[This.FIndent], PChar(Pointer(S)), Length(S));\n    end;\n    This.FLastType := ltSeparator;\n  end;\nend;\n\n{ TUtf8JsonReader }\n\nconstructor TUtf8JsonReader.Create(S: PByte; Len: NativeInt; AProgress: PJsonReaderProgressRec);\nbegin\n  inherited Create(S, Len * SizeOf(Byte), AProgress);\n  FText := S;\n  FTextEnd := S + Len;\nend;\n\nfunction TUtf8JsonReader.GetCharOffset(StartPos: Pointer): NativeInt;\nbegin\n  Result := FText - PByte(StartPos);\nend;\n\nfunction TUtf8JsonReader.Next: Boolean;\nlabel\n  EndReached;\nvar\n  P, EndP: PByte;\n  Ch: Byte;\nbegin\n  P := FText;\n  EndP := FTextEnd;\n  {$IF CompilerVersion <= 30.0} // Delphi 10 Seattle or older\n    {$IFNDEF CPUX64}\n  Ch := 0; // silence compiler warning\n    {$ENDIF ~CPUX64}\n  {$IFEND}\n  while True do\n  begin\n    while True do\n    begin\n      if P = EndP then\n        goto EndReached; // use GOTO to eliminate doing the \"P = EndP\", \"P < EndP\" 3 times - wish there was a \"Break loop-label;\"\n      Ch := P^;\n      if Ch > 32 then\n        Break;\n      if not (Ch in [9, 32]) then\n        Break;\n      Inc(P);\n    end;\n\n    case Ch of\n      10:\n        begin\n          FLineStart := P + 1;\n          Inc(FLineNum);\n        end;\n      13:\n        begin\n          Inc(FLineNum);\n          if (P + 1 < EndP) and (P[1] = 10) then\n            Inc(P);\n          FLineStart := P + 1;\n        end;\n    else\n      Break;\n    end;\n    Inc(P);\n  end;\n\nEndReached:\n  if P < EndP then\n  begin\n    case P^ of\n      Ord('{'):\n        begin\n          FLook.Kind := jtkLBrace;\n          FText := P + 1;\n        end;\n      Ord('}'):\n        begin\n          FLook.Kind := jtkRBrace;\n          FText := P + 1;\n        end;\n      Ord('['):\n        begin\n          FLook.Kind := jtkLBracket;\n          FText := P + 1;\n        end;\n      Ord(']'):\n        begin\n          FLook.Kind := jtkRBracket;\n          FText := P + 1;\n        end;\n      Ord(':'):\n        begin\n          FLook.Kind := jtkColon;\n          FText := P + 1;\n        end;\n      Ord(','):\n        begin\n          FLook.Kind := jtkComma;\n          FText := P + 1;\n        end;\n      Ord('\"'): // String\n        begin\n          LexString(P{$IFDEF CPUARM}, EndP{$ENDIF});\n          if FProgress <> nil then\n            CheckProgress(FText);\n        end;\n      Ord('-'), Ord('0')..Ord('9'), Ord('.'): // Number\n        begin\n          LexNumber(P{$IFDEF CPUARM}, EndP{$ENDIF});\n          if FProgress <> nil then\n            CheckProgress(FText);\n        end\n    else\n      LexIdent(P{$IFDEF CPUARM}, EndP{$ENDIF}); // Ident/Bool/NULL\n      if FProgress <> nil then\n        CheckProgress(FText);\n    end;\n    Result := True;\n  end\n  else\n  begin\n    FText := EndP;\n    FLook.Kind := jtkEof;\n    Result := False;\n  end;\nend;\n\nprocedure TUtf8JsonReader.LexString(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\nvar\n  {$IFNDEF CPUARM}\n  EndP: PByte;\n  {$ENDIF ~CPUARM}\n  EscapeSequences: PByte;\n  Ch: Byte;\n  Idx: Integer;\nbegin\n  Inc(P); // skip initiating '\"'\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  EscapeSequences := nil;\n  Ch := 0;\n  Idx := P - EndP;\n\n  // find the string end\n  repeat\n    if Idx = 0 then\n      Break;\n    Ch := EndP[Idx];\n    if (Ch = Byte(Ord('\"'))) or (Ch = 10) or (Ch = 13) then\n      Break;\n    Inc(Idx);\n    if Ch <> Byte(Ord('\\')) then\n      Continue;\n    if Idx = 0 then // Eof reached in an escaped char => broken JSON string\n      Break;\n    if EscapeSequences = nil then\n      EscapeSequences := @EndP[Idx];\n    Inc(Idx);\n  until False;\n\n  if Idx = 0 then\n  begin\n    FText := P - 1;\n    TJsonReader.StringNotClosedError(Self);\n  end;\n\n  EndP := @EndP[Idx];\n  if EscapeSequences = nil then\n    SetStringUtf8(FLook.S, P, EndP - P)\n  else\n    TUtf8JsonReader.JSONUtf8StrToStr(P, EndP, EscapeSequences - P, FLook.S, Self);\n\n  if Ch = Byte(Ord('\"')) then\n    Inc(EndP);\n  FLook.Kind := jtkString;\n  FText := EndP;\n\n  if Ch in [10, 13] then\n    TJsonReader.InvalidStringCharacterError(Self);\nend;\n\n{$IFDEF ASMSUPPORT}\n  {$IFDEF CPUX64}\nfunction ParseUInt64Utf8(P, EndP: PByte): UInt64;\n// RCX = P\n// RDX = EndP\nasm\n  cmp rcx, rdx\n  jge @@LeaveFail\n\n  mov r8, rdx\n  sub rcx, r8\n  // r8+rcx = EndP + NegOffset = P => NegOffset can be incremented and checked for zero\n\n  movzx rax, BYTE PTR [r8+rcx]\n  sub al, '0'\n  add rcx, 1\n  jz @@Leave\n\n@@Loop:\n  add rax, rax\n  // rax = 2*Result\n  lea rax, [rax+rax*4]\n  // rax = (2*Result)*4 + (2*Result) = 10*Result\n\n  movzx rdx, BYTE PTR [r8+rcx]\n  sub dl, '0'\n  add rax, rdx\n\n  add rcx, 1\n  jnz @@Loop\n\n@@Leave:\n  ret\n@@LeaveFail:\n  xor rax, rax\nend;\n  {$ENDIF CPUX64}\n  {$IFDEF CPUX86}\nfunction ParseUInt64Utf8(P, EndP: PByte): UInt64;\nasm\n  cmp eax, edx\n  jge @@LeaveFail\n\n  push esi\n  push edi\n  push ebx\n\n  mov esi, edx\n  mov edi, eax\n  sub edi, edx\n  // esi+edi = EndP + NegOffset = P => NegOffset can be incremented and checked for zero\n\n  xor edx, edx\n  movzx eax, BYTE PTR [esi+edi]\n  sub al, '0'\n  add edi, 1\n  jz @@PopLeave\n\n@@Loop:\n  add eax, eax\n  adc edx, edx\n  // eax:edx = 2*Result\n  mov ebx, eax\n  mov ecx, edx\n  // ebx:ecx = 2*Result\n  shld edx, eax, 2\n  shl eax, 2\n  // eax:edx = (2*Result)*4\n  add eax, ebx\n  adc edx, ecx\n  // eax:edx = (2*Result)*4 + (2*Result) = 10*Result\n\n  movzx ecx, BYTE PTR [esi+edi]\n  sub cl, '0'\n  add eax, ecx\n  adc edx, 0\n\n  add edi, 1\n  jnz @@Loop\n\n@@PopLeave:\n  pop ebx\n  pop edi\n  pop esi\n@@Leave:\n  ret\n@@LeaveFail:\n  xor eax, eax\n  xor edx, edx\nend;\n  {$ENDIF CPUX86}\n{$ELSE}\nfunction ParseUInt64Utf8(P, EndP: PByte): UInt64;\nbegin\n  if P = EndP then\n    Result := 0\n  else\n  begin\n    Result := P^ - Byte(Ord('0'));\n    Inc(P);\n    while P < EndP do\n    begin\n      Result := Result * 10 + Byte(P^ - Byte(Ord('0')));\n      Inc(P);\n    end;\n  end;\nend;\n{$ENDIF ASMSUPPORT}\n\nfunction ParseAsDoubleUtf8(F, P: PByte): Double;\nbegin\n  Result := 0.0;\n  while F < P do\n  begin\n    Result := Result * 10 + (F^ - Byte(Ord('0')));\n    Inc(F);\n  end;\nend;\n\nprocedure TUtf8JsonReader.LexNumber(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\nvar\n  F: PByte;\n  {$IFNDEF CPUARM}\n  EndP: PByte;\n  {$ENDIF ~CPUARM}\n  EndInt64P: PByte;\n  Ch: Byte;\n  Value, Scale: Double;\n  Exponent, IntValue: Integer;\n  Neg, NegE: Boolean;\n  DigitCount: Integer;\nbegin\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  Neg := False;\n\n  Ch := P^;\n  if Ch = Byte(Ord('-')) then\n  begin\n    Inc(P);\n    if P >= EndP then\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n    Neg := True;\n    Ch := P^;\n  end;\n  F := P;\n\n  Inc(P);\n  if Ch <> Byte(Ord('0')) then\n  begin\n    if Ch in [Ord('1')..Ord('9')] then\n    begin\n      while (P < EndP) and (P^ in [Ord('0')..Ord('9')]) do\n        Inc(P);\n    end\n    else\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n  end;\n\n  DigitCount := P - F;\n  if DigitCount <= 9 then // Int32 fits 9 digits\n  begin\n    IntValue := 0;\n    while F < P do\n    begin\n      IntValue := IntValue * 10 + (F^ - Byte(Ord('0')));\n      Inc(F);\n    end;\n    FLook.HI := 0;\n    FLook.I := IntValue;\n    FLook.Kind := jtkInt;\n    if not (P^ in [Ord('.'), Ord('E'), Ord('e')]) then\n    begin\n      // just an integer\n      if Neg then\n        FLook.I := -FLook.I;\n      FText := P;\n      Exit;\n    end;\n    Value := FLook.I;\n  end\n  else if DigitCount <= 20 then // UInt64 fits 20 digits (not all)\n  begin\n    FLook.U := ParseUInt64Utf8(F, P);\n    if (DigitCount = 20) and (FLook.U mod 10 <> PByte(P - 1)^ - Byte(Ord('0'))) then // overflow => too large\n      Value := ParseAsDoubleUtf8(F, P)\n    else if Neg and ((DigitCount = 20) or ((DigitCount = 19) and (FLook.HI and $80000000 <> 0))) then\n      // \"negative UInt64\" doesn't fit into UInt64/Int64 => use Double\n      Value := FLook.U\n    else\n    begin\n      FLook.Kind := jtkLong;\n      case DigitCount of\n        19:\n         if FLook.HI and $80000000 <> 0 then // can't be negative because we cached that case already\n           FLook.Kind := jtkULong;\n        20:\n          FLook.Kind := jtkULong;\n      end;\n\n      if not (P^ in [Ord('.'), Ord('E'), Ord('e')]) then\n      begin\n        // just an integer\n        if Neg then\n        begin\n          if (FLook.HI = 0) and (FLook.I >= 0) then // 32bit Integer\n          begin\n            FLook.I := -FLook.I;\n            FLook.Kind := jtkInt;\n          end\n          else                 // 64bit Integer\n            FLook.L := -FLook.L;\n        end;\n        FText := P;\n        Exit;\n      end;\n      Value := FLook.U;\n    end;\n  end\n  else\n    Value := ParseAsDoubleUtf8(F, P);\n\n  // decimal digits\n  if (P + 1 < EndP) and (P^ = Byte(Ord('.'))) then\n  begin\n    Inc(P);\n    F := P;\n    EndInt64P := F + 18;\n    if EndInt64P > EndP then\n      EndInt64P := EndP;\n    while (P < EndInt64P) and (P^ in [Ord('0')..Ord('9')]) do\n      Inc(P);\n    Value := Value + ParseUInt64Utf8(F, P) / Power10[P - F];\n\n    // \"Double\" can't handle that many digits\n    while (P < EndP) and (P^ in [Ord('0')..Ord('9')]) do\n      Inc(P);\n  end;\n\n  // exponent\n  if (P < EndP) and (P^ in [Ord('e'), Ord('E')]) then\n  begin\n    Inc(P);\n    NegE := False;\n    if (P < EndP) then\n    begin\n      case P^ of\n        Ord('-'):\n          begin\n            NegE := True;\n            Inc(P);\n          end;\n        Ord('+'):\n          Inc(P);\n      end;\n      Exponent := 0;\n      F := P;\n      while (P < EndP) and (P^ in [Ord('0')..Ord('9')]) do\n      begin\n        Exponent := Exponent * 10 + (P^ - Byte(Ord('0')));\n        Inc(P);\n      end;\n      if P = F then\n      begin\n        // no exponent\n        FLook.Kind := jtkInvalidSymbol;\n        FText := P;\n        Exit;\n      end;\n\n      if Exponent > 308 then\n        Exponent := 308;\n\n      Scale := 1.0;\n      while Exponent >= 50 do\n      begin\n        Scale := Scale * 1E50;\n        Dec(Exponent, 50);\n      end;\n      while Exponent >= 18 do\n      begin\n        Scale := Scale * 1E18;\n        Dec(Exponent, 18);\n      end;\n      Scale := Scale * Power10[Exponent];\n\n      if NegE then\n        Value := Value / Scale\n      else\n        Value := Value * Scale;\n    end\n    else\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n  end;\n\n  if Neg then\n    FLook.F := -Value\n  else\n    FLook.F := Value;\n  FLook.Kind := jtkFloat;\n  FText := P;\nend;\n\nprocedure TUtf8JsonReader.LexIdent(P: PByte{$IFDEF CPUARM}; EndP: PByte{$ENDIF});\nconst\n  {$IFDEF BIGENDIAN}\n  // Big Endian\n  NullStr = LongWord((Ord('n') shl 24) or (Ord('u') shl 16) or (Ord('l') shl 8) or Ord('l'));\n  TrueStr = LongWord((Ord('t') shl 24) or (Ord('r') shl 16) or (Ord('u') shl 8) or Ord('e'));\n  FalseStr = LongWord((Ord('a') shl 24) or (Ord('l') shl 16) or (Ord('s') shl 8) or Ord('e'));\n  {$ELSE}\n  // Little Endian\n  NullStr = LongWord(Ord('n') or (Ord('u') shl 8) or (Ord('l') shl 16) or (Ord('l') shl 24));\n  TrueStr = LongWord(Ord('t') or (Ord('r') shl 8) or (Ord('u') shl 16) or (Ord('e') shl 24));\n  FalseStr = LongWord(Ord('a') or (Ord('l') shl 8) or (Ord('s') shl 16) or (Ord('e') shl 24));\n  {$ENDIF BIGENDIAN}\nvar\n  F: PByte;\n  {$IFNDEF CPUARM}\n  EndP: PByte;\n  {$ENDIF ~CPUARM}\n  L: LongWord;\nbegin\n  F := P;\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  case P^ of\n    Ord('A')..Ord('Z'), Ord('a')..Ord('z'), Ord('_'), Ord('$'):\n      begin\n        Inc(P);\n//        DCC64 generates \"bt mem,reg\" code\n//        while (P < EndP) and (P^ in [Ord('A')..Ord('Z'), Ord('a')..Ord('z'), Ord('_'), Ord('0')..Ord('9')]) do\n//          Inc(P);\n        while P < EndP do\n          case P^ of\n            Ord('A')..Ord('Z'), Ord('a')..Ord('z'), Ord('_'), Ord('0')..Ord('9'): Inc(P);\n          else\n            Break;\n          end;\n\n        L := P - F;\n        if L = 4 then\n        begin\n          L := PLongWord(F)^;\n          if L = NullStr then\n            FLook.Kind := jtkNull\n          else if L = TrueStr then\n            FLook.Kind := jtkTrue\n          else\n          begin\n            SetStringUtf8(FLook.S, F, P - F);\n            FLook.Kind := jtkIdent;\n          end;\n        end\n        else if (L = 5) and (F^ = Ord('f')) and (PLongWord(F + 1)^ = FalseStr) then\n          FLook.Kind := jtkFalse\n        else\n        begin\n          SetStringUtf8(FLook.S, F, P - F);\n          FLook.Kind := jtkIdent;\n        end;\n      end;\n  else\n    FLook.Kind := jtkInvalidSymbol;\n    Inc(P);\n  end;\n  FText := P;\nend;\n\n{ TStringJsonReader }\n\nconstructor TStringJsonReader.Create(S: PChar; Len: Integer; AProgress: PJsonReaderProgressRec);\nbegin\n  inherited Create(S, Len * SizeOf(WideChar), AProgress);\n  FText := S;\n  FTextEnd := S + Len;\nend;\n\nfunction TStringJsonReader.GetCharOffset(StartPos: Pointer): NativeInt;\nbegin\n  Result := FText - PChar(StartPos);\nend;\n\nfunction TStringJsonReader.Next: Boolean;\nvar\n  P, EndP: PChar;\nbegin\n  P := FText;\n  EndP := FTextEnd;\n  while (P < EndP) and (P^ <= #32) do\n    Inc(P);\n\n  if P < EndP then\n  begin\n    case P^ of\n      '{':\n        begin\n          FLook.Kind := jtkLBrace;\n          FText := P + 1;\n        end;\n      '}':\n        begin\n          FLook.Kind := jtkRBrace;\n          FText := P + 1;\n        end;\n      '[':\n        begin\n          FLook.Kind := jtkLBracket;\n          FText := P + 1;\n        end;\n      ']':\n        begin\n          FLook.Kind := jtkRBracket;\n          FText := P + 1;\n        end;\n      ':':\n        begin\n          FLook.Kind := jtkColon;\n          FText := P + 1;\n        end;\n      ',':\n        begin\n          FLook.Kind := jtkComma;\n          FText := P + 1;\n        end;\n      '\"': // String\n        begin\n          LexString(P{$IFDEF CPUARM}, EndP{$ENDIF});\n          if FProgress <> nil then\n            CheckProgress(FText);\n        end;\n      '-', '0'..'9', '.': // Number\n        begin\n          LexNumber(P{$IFDEF CPUARM}, EndP{$ENDIF});\n          if FProgress <> nil then\n            CheckProgress(FText);\n        end\n    else\n      LexIdent(P{$IFDEF CPUARM}, EndP{$ENDIF}); // Ident/Bool/NULL\n      if FProgress <> nil then\n        CheckProgress(FText);\n    end;\n    Result := True;\n  end\n  else\n  begin\n    FText := EndP;\n    FLook.Kind := jtkEof;\n    Result := False;\n  end;\nend;\n\nprocedure TStringJsonReader.LexString(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\nvar\n  {$IFNDEF CPUARM}\n  EndP: PChar;\n  {$ENDIF ~CPUARM}\n  EscapeSequences: PChar;\n  Ch: Char;\n  Idx: Integer;\nbegin\n  Inc(P); // skip initiating '\"'\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  EscapeSequences := nil;\n  Ch := #0;\n  Idx := P - EndP;\n\n  // find the string end\n  repeat\n    if Idx = 0 then\n      Break;\n    Ch := EndP[Idx];\n    if (Ch = '\"') or (Ch = #10) or (Ch = #13) then\n      Break;\n    Inc(Idx);\n    if Ch <> '\\' then\n      Continue;\n    if Idx = 0 then // Eof reached in an escaped char => broken JSON string\n      Break;\n    if EscapeSequences = nil then\n      EscapeSequences := @EndP[Idx];\n    Inc(Idx);\n  until False;\n\n  if Idx = 0 then\n  begin\n    FText := P - 1;\n    TJsonReader.StringNotClosedError(Self);\n  end;\n\n  EndP := @EndP[Idx];\n  if EscapeSequences = nil then\n    SetString(FLook.S, P, EndP - P)\n  else\n    TJsonReader.JSONStrToStr(P, EndP, EscapeSequences - P, FLook.S, Self);\n\n  if Ch = '\"' then\n    Inc(EndP);\n  FLook.Kind := jtkString;\n  FText := EndP;\n\n  if Ch in [#10, #13] then\n    TJsonReader.InvalidStringCharacterError(Self);\nend;\n\n{$IFDEF ASMSUPPORT}\n  {$IFDEF CPUX64}\nfunction ParseUInt64(P, EndP: PWideChar): UInt64;\n// RCX = P\n// RDX = EndP\nasm\n  cmp rcx, rdx\n  jge @@LeaveFail\n\n  mov r8, rdx\n  sub rcx, r8\n  // r8+rcx = EndP + NegOffset = P => NegOffset can be incremented and checked for zero\n\n  movzx rax, WORD PTR [r8+rcx]\n  sub ax, '0'\n  add rcx, 2\n  jz @@Leave\n\n@@Loop:\n  add rax, rax\n  // rax = 2*Result\n  lea rax, [rax+rax*4]\n  // rax = (2*Result)*4 + (2*Result) = 10*Result\n\n  movzx rdx, WORD PTR [r8+rcx]\n  sub dx, '0'\n  add rax, rdx\n\n  add rcx, 2\n  jnz @@Loop\n\n@@Leave:\n  ret\n@@LeaveFail:\n  xor rax, rax\nend;\n  {$ENDIF CPUX64}\n  {$IFDEF CPUX86}\nfunction ParseUInt64(P, EndP: PWideChar): UInt64;\nasm\n  cmp eax, edx\n  jge @@LeaveFail\n\n  push esi\n  push edi\n  push ebx\n\n  mov esi, edx\n  mov edi, eax\n  sub edi, edx\n  // esi+edi = EndP + NegOffset = P => NegOffset can be incremented and checked for zero\n\n  xor edx, edx\n  movzx eax, WORD PTR [esi+edi]\n  sub ax, '0'\n  add edi, 2\n  jz @@PopLeave\n\n@@Loop:\n  add eax, eax\n  adc edx, edx\n  // eax:edx = 2*Result\n  mov ebx, eax\n  mov ecx, edx\n  // ebx:ecx = 2*Result\n  shld edx, eax, 2\n  shl eax, 2\n  // eax:edx = (2*Result)*4\n  add eax, ebx\n  adc edx, ecx\n  // eax:edx = (2*Result)*4 + (2*Result) = 10*Result\n\n  movzx ecx, WORD PTR [esi+edi]\n  sub cx, '0'\n  add eax, ecx\n  adc edx, 0\n\n  add edi, 2\n  jnz @@Loop\n\n@@PopLeave:\n  pop ebx\n  pop edi\n  pop esi\n@@Leave:\n  ret\n@@LeaveFail:\n  xor eax, eax\n  xor edx, edx\nend;\n  {$ENDIF CPUX86}\n{$ELSE}\nfunction ParseUInt64(P, EndP: PWideChar): UInt64;\nbegin\n  if P = EndP then\n    Result := 0\n  else\n  begin\n    Result := Ord(P^) - Ord('0');\n    Inc(P);\n    while P < EndP do\n    begin\n      Result := Result * 10 + Byte(Ord(P^) - Ord('0'));\n      Inc(P);\n    end;\n  end;\nend;\n{$ENDIF ASMSUPPORT}\n\nfunction ParseAsDouble(F, P: PWideChar): Double;\nbegin\n  Result := 0.0;\n  while F < P do\n  begin\n    Result := Result * 10 + (Ord(F^) - Ord('0'));\n    Inc(F);\n  end;\nend;\n\nprocedure TStringJsonReader.LexNumber(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\nvar\n  F: PChar;\n  {$IFNDEF CPUARM}\n  EndP: PChar;\n  {$ENDIF ~CPUARM}\n  EndInt64P: PChar;\n  Ch: Char;\n  Value, Scale: Double;\n  Exponent, IntValue: Integer;\n  Neg, NegE: Boolean;\n  DigitCount: Integer;\nbegin\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  Neg := False;\n\n  Ch := P^;\n  if Ch = '-' then\n  begin\n    Inc(P);\n    if P >= EndP then\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n    Neg := True;\n    Ch := P^;\n  end;\n  F := P;\n\n  Inc(P);\n  if Ch <> '0' then\n  begin\n    if Ch in ['1'..'9'] then\n    begin\n      while (P < EndP) and (P^ in ['0'..'9']) do\n        Inc(P);\n    end\n    else\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n  end;\n\n  DigitCount := P - F;\n  if DigitCount <= 9 then // Int32 fits 9 digits\n  begin\n    IntValue := 0;\n    while F < P do\n    begin\n      IntValue := IntValue * 10 + (Ord(F^) - Ord('0'));\n      Inc(F);\n    end;\n    FLook.HI := 0;\n    FLook.I := IntValue;\n    FLook.Kind := jtkInt;\n    if not (P^ in ['.', 'E', 'e']) then\n    begin\n      // just an integer\n      if Neg then\n        FLook.I := -FLook.I;\n      FText := P;\n      Exit;\n    end;\n    Value := FLook.I;\n  end\n  else if DigitCount <= 20 then // UInt64 fits 20 digits (not all)\n  begin\n    FLook.U := ParseUInt64(F, P);\n    if (DigitCount = 20) and (FLook.U mod 10 <> Ord(PWideChar(P - 1)^) - Ord('0')) then // overflow => too large\n      Value := ParseAsDouble(F, P)\n    else if Neg and ((DigitCount = 20) or ((DigitCount = 19) and (FLook.HI and $80000000 <> 0))) then\n      // \"negative UInt64\" doesn't fit into UInt64/Int64 => use Double\n      Value := FLook.U\n    else\n    begin\n      FLook.Kind := jtkLong;\n      case DigitCount of\n        19:\n         if FLook.HI and $80000000 <> 0 then // can't be negative because we cached that case already\n           FLook.Kind := jtkULong;\n        20:\n          FLook.Kind := jtkULong;\n      end;\n\n      if not (P^ in ['.', 'E', 'e']) then\n      begin\n        // just an integer\n        if Neg then\n        begin\n          if (FLook.HI = 0) and (FLook.I >= 0) then // 32bit Integer\n          begin\n            FLook.I := -FLook.I;\n            FLook.Kind := jtkInt;\n          end\n          else                 // 64bit Integer\n            FLook.L := -FLook.L;\n        end;\n        FText := P;\n        Exit;\n      end;\n      Value := FLook.U;\n    end;\n  end\n  else\n    Value := ParseAsDouble(F, P);\n\n  // decimal digits\n  if (P + 1 < EndP) and (P^ = '.') then\n  begin\n    Inc(P);\n    F := P;\n    EndInt64P := F + 18;\n    if EndInt64P > EndP then\n      EndInt64P := EndP;\n    while (P < EndInt64P) and (P^ in ['0'..'9']) do\n      Inc(P);\n    Value := Value + ParseUInt64(F, P) / Power10[P - F];\n\n    // \"Double\" can't handle that many digits\n    while (P < EndP) and (P^ in ['0'..'9']) do\n      Inc(P);\n  end;\n\n  // exponent\n  if (P < EndP) and ((P^ = 'e') or (P^ = 'E')) then\n  begin\n    Inc(P);\n    NegE := False;\n    if (P < EndP) then\n    begin\n      case P^ of\n        '-':\n          begin\n            NegE := True;\n            Inc(P);\n          end;\n        '+':\n          Inc(P);\n      end;\n      Exponent := 0;\n      F := P;\n      while (P < EndP) and (P^ in ['0'..'9']) do\n      begin\n        Exponent := Exponent * 10 + (Ord(P^) - Ord('0'));\n        Inc(P);\n      end;\n      if P = F then\n      begin\n        // no exponent\n        FLook.Kind := jtkInvalidSymbol;\n        FText := P;\n        Exit;\n      end;\n\n      if Exponent > 308 then\n        Exponent := 308;\n\n      Scale := 1.0;\n      while Exponent >= 50 do\n      begin\n        Scale := Scale * 1E50;\n        Dec(Exponent, 50);\n      end;\n      while Exponent >= 18 do\n      begin\n        Scale := Scale * 1E18;\n        Dec(Exponent, 18);\n      end;\n      Scale := Scale * Power10[Exponent];\n\n      if NegE then\n        Value := Value / Scale\n      else\n        Value := Value * Scale;\n    end\n    else\n    begin\n      FLook.Kind := jtkInvalidSymbol;\n      FText := P;\n      Exit;\n    end;\n  end;\n\n  if Neg then\n    FLook.F := -Value\n  else\n    FLook.F := Value;\n  FLook.Kind := jtkFloat;\n  FText := P;\nend;\n\nprocedure TStringJsonReader.LexIdent(P: PChar{$IFDEF CPUARM}; EndP: PChar{$ENDIF});\nconst\n  {$IFDEF BIGENDIAN}\n  // Big Endian\n  NullStr1 = LongWord((Ord('n') shl 16) or Ord('u'));\n  NullStr2 = LongWord((Ord('l') shl 16) or Ord('l'));\n  TrueStr1 = LongWord((Ord('t') shl 16) or Ord('r'));\n  TrueStr2 = LongWord((Ord('u') shl 16) or Ord('e'));\n  FalseStr1 = LongWord((Ord('a') shl 16) or Ord('l'));\n  FalseStr2 = LongWord((Ord('s') shl 16) or Ord('e'));\n  {$ELSE}\n  // Little Endian\n  NullStr1 = LongWord(Ord('n') or (Ord('u') shl 16));\n  NullStr2 = LongWord(Ord('l') or (Ord('l') shl 16));\n  TrueStr1 = LongWord(Ord('t') or (Ord('r') shl 16));\n  TrueStr2 = LongWord(Ord('u') or (Ord('e') shl 16));\n  FalseStr1 = LongWord(Ord('a') or (Ord('l') shl 16));\n  FalseStr2 = LongWord(Ord('s') or (Ord('e') shl 16));\n  {$ENDIF BIGENDIAN}\nvar\n  F: PChar;\n  {$IFNDEF CPUARM}\n  EndP: PChar;\n  {$ENDIF ~CPUARM}\n  L: LongWord;\nbegin\n  F := P;\n  {$IFNDEF CPUARM}\n  EndP := FTextEnd;\n  {$ENDIF ~CPUARM}\n  case P^ of\n    'A'..'Z', 'a'..'z', '_', '$':\n      begin\n        Inc(P);\n//        DCC64 generates \"bt mem,reg\" code\n//        while (P < EndP) and (P^ in ['A'..'Z', 'a'..'z', '_', '0'..'9']) do\n//          Inc(P);\n        while P < EndP do\n          case P^ of\n            'A'..'Z', 'a'..'z', '_', '0'..'9': Inc(P);\n          else\n            Break;\n          end;\n\n        L := P - F;\n        if L = 4 then\n        begin\n          L := PLongWord(F)^;\n          if (L = NullStr1) and (PLongWord(F + 2)^ = NullStr2) then\n            FLook.Kind := jtkNull\n          else if (L = TrueStr1) and (PLongWord(F + 2)^ = TrueStr2) then\n            FLook.Kind := jtkTrue\n          else\n          begin\n            SetString(FLook.S, F, P - F);\n            FLook.Kind := jtkIdent;\n          end;\n        end\n        else if (L = 5) and (F^ = 'f') and (PLongWord(F + 1)^ = FalseStr1) and (PLongWord(F + 3)^ = FalseStr2) then\n          FLook.Kind := jtkFalse\n        else\n        begin\n          SetString(FLook.S, F, P - F);\n          FLook.Kind := jtkIdent;\n        end;\n      end;\n  else\n    FLook.Kind := jtkInvalidSymbol;\n    Inc(P);\n  end;\n  FText := P;\nend;\n\n{ TJsonDataValueHelper }\n\nclass operator TJsonDataValueHelper.Implicit(const Value: string): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtString;\n  Result.FData.FValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): string;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.Value\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := Value.FData.FValue;\n      jdtInt:\n        Result := IntToStr(Value.FData.FIntValue);\n      jdtLong:\n        Result := IntToStr(Value.FData.FLongValue);\n      jdtULong:\n        Result := UIntToStr(Value.FData.FULongValue);\n      jdtFloat:\n        Result := FloatToStr(Value.FData.FFloatValue, JSONFormatSettings);\n      jdtDateTime:\n        Result := TJsonBaseObject.DateTimeToJSON(Value.FData.FDateTimeValue, JsonSerializationConfig.UseUtcTime);\n      jdtUtcDateTime:\n        Result := TJsonBaseObject.UtcDateTimeToJSON(Value.FData.FDateTimeValue);\n      jdtBool:\n        if Value.FData.FBoolValue then\n          Result := sTrue\n        else\n          Result := sFalse;\n    else\n      Result := '';\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Integer): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtInt;\n  Result.FData.FIntValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Integer;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.IntValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := StrToIntDef(Value.FData.FValue, 0);\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Trunc(Value.FData.FFloatValue);\n      jdtDateTime, jdtUtcDateTime:\n        Result := Trunc(Value.FData.FDateTimeValue);\n      jdtBool:\n        Result := Ord(Value.FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Int64): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtLong;\n  Result.FData.FLongValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Int64;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.LongValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := StrToInt64Def(Value.FData.FValue, 0);\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Trunc(Value.FData.FFloatValue);\n      jdtDateTime, jdtUtcDateTime:\n        Result := Trunc(Value.FData.FDateTimeValue);\n      jdtBool:\n        Result := Ord(Value.FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\n//class operator TJsonDataValueHelper.Implicit(const Value: UInt64): TJsonDataValueHelper;\n//begin\n//  Result.FData.FName := '';\n//  Result.FData.FNameResolver := nil;\n//  Result.FData.FIntern := nil;\n//  if Result.FData.FValue <> '' then\n//    Result.FData.FValue := '';\n//  {$IFDEF AUTOREFCOUNT}\n//  if Result.FData.FObj <> nil then\n//    Result.FData.FObj := nil;\n//  {$ENDIF AUTOREFCOUNT}\n//  Result.FData.FTyp := jdtULong;\n//  Result.FData.FULongValue := Value;\n//end;\n//\n//class operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): UInt64;\n//begin\n//  if Value.FData.FIntern <> nil then\n//    Result := Value.FData.FIntern.LongValue\n//  else\n//    case Value.FData.FTyp of\n//      jdtString:\n//        Result := StrToInt64Def(Value.FData.FValue, 0);\n//      jdtInt:\n//        Result := Value.FData.FIntValue;\n//      jdtLong:\n//        Result := Value.FData.FLongValue;\n//      jdtULong:\n//        Result := Value.FData.FULongValue;\n//      jdtFloat:\n//        Result := Trunc(Value.FData.FFloatValue);\n//      jdtDateTime, jdtUtcDateTime:\n//        Result := Trunc(Value.FData.FDateTimeValue);\n//      jdtBool:\n//        Result := Ord(Value.FData.FBoolValue);\n//    else\n//      Result := 0;\n//    end;\n//end;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Double): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtFloat;\n  Result.FData.FFloatValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Double;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.FloatValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := StrToFloat(Value.FData.FValue, JSONFormatSettings);\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Value.FData.FFloatValue;\n      jdtDateTime, jdtUtcDateTime:\n        Result := Value.FData.FDateTimeValue;\n      jdtBool:\n        Result := Ord(Value.FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Extended): TJsonDataValueHelper;  // same that double\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtFloat;\n  Result.FData.FFloatValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Extended;  // same that double\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.FloatValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := StrToFloat(Value.FData.FValue, JSONFormatSettings);\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Value.FData.FFloatValue;\n      jdtDateTime, jdtUtcDateTime:\n        Result := Value.FData.FDateTimeValue;\n      jdtBool:\n        Result := Ord(Value.FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TDateTime): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtDateTime;\n  Result.FData.FDateTimeValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): TDateTime;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.DateTimeValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := TJsonBaseObject.JSONToDateTime(Value.FData.FValue);\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Value.FData.FFloatValue;\n      jdtDateTime:\n        Result := Value.FData.FDateTimeValue;\n      jdtUtcDateTime:\n        Result := UtcDateTimeToLocalDateTime(Value.FData.FDateTimeValue);\n      jdtBool:\n        Result := Ord(Value.FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Boolean): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n  Result.FData.FTyp := jdtBool;\n  Result.FData.FBoolValue := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Boolean;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.BoolValue\n  else\n    case Value.FData.FTyp of\n      jdtString:\n        Result := Value.FData.FValue = 'true';\n      jdtInt:\n        Result := Value.FData.FIntValue <> 0;\n      jdtLong:\n        Result := Value.FData.FLongValue <> 0;\n      jdtULong:\n        Result := Value.FData.FULongValue <> 0;\n      jdtFloat:\n        Result := Value.FData.FFloatValue <> 0;\n      jdtDateTime, jdtUtcDateTime:\n        Result := Value.FData.FDateTimeValue <> 0;\n      jdtBool:\n        Result := Value.FData.FBoolValue;\n    else\n      Result := False;\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonArray): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  Result.FData.FTyp := jdtArray;\n  Result.FData.FObj := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): TJsonArray;\nbegin\n  Value.ResolveName;\n  if Value.FData.FIntern <> nil then\n  begin\n    if Value.FData.FIntern.FTyp = jdtNone then\n      Value.FData.FIntern.ArrayValue := TJsonArray.Create;\n    Result := Value.FData.FIntern.ArrayValue;\n  end\n  else if Value.FData.FTyp = jdtArray then\n    Result := TJsonArray(Value.FData.FObj)\n  else\n    Result := nil;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonObject): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  Result.FData.FTyp := jdtObject;\n  Result.FData.FObj := Value;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): TJsonObject;\nbegin\n  Value.ResolveName;\n  if Value.FData.FIntern <> nil then\n  begin\n    if Value.FData.FIntern.FTyp = jdtNone then\n      Value.FData.FIntern.ObjectValue := TJsonObject.Create;\n    Result := Value.FData.FIntern.ObjectValue;\n  end\n  else if Value.FData.FTyp = jdtObject then\n    Result := TJsonObject(Value.FData.FObj)\n  else\n    Result := nil;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Pointer): TJsonDataValueHelper;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  Result.FData.FTyp := jdtObject;\n  Result.FData.FObj := nil;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: TJsonDataValueHelper): Variant;\nbegin\n  if Value.FData.FIntern <> nil then\n    Result := Value.FData.FIntern.VariantValue\n  else\n    case Value.FData.FTyp of\n      jdtNone:\n        Result := Unassigned;\n      jdtString:\n        Result := Value.FData.FValue;\n      jdtInt:\n        Result := Value.FData.FIntValue;\n      jdtLong:\n        Result := Value.FData.FLongValue;\n      jdtULong:\n        Result := Value.FData.FULongValue;\n      jdtFloat:\n        Result := Value.FData.FFloatValue;\n      jdtDateTime:\n        Result := Value.FData.FDateTimeValue;\n      jdtUtcDateTime:\n        Result := UtcDateTimeToLocalDateTime(Value.FData.FDateTimeValue); // Variant is local time\n      jdtBool:\n        Result := Value.FData.FBoolValue;\n      jdtArray:\n        ErrorUnsupportedVariantType(varArray);\n      jdtObject:\n        if Value.FData.FObj = nil then\n          Result := Null\n        else\n          ErrorUnsupportedVariantType(varObject);\n    else\n      ErrorUnsupportedVariantType(varAny);\n    end;\nend;\n\nclass operator TJsonDataValueHelper.Implicit(const Value: Variant): TJsonDataValueHelper;\nvar\n  LTyp: TJsonDataType;\nbegin\n  Result.FData.FName := '';\n  Result.FData.FNameResolver := nil;\n  Result.FData.FIntern := nil;\n  if Result.FData.FValue <> '' then\n    Result.FData.FValue := '';\n  {$IFDEF AUTOREFCOUNT}\n  if Result.FData.FObj <> nil then\n    Result.FData.FObj := nil;\n  {$ENDIF AUTOREFCOUNT}\n\n  LTyp := VarTypeToJsonDataType(VarType(Value));\n  if LTyp <> jdtNone then\n  begin\n    Result.FData.FTyp := LTyp;\n    case LTyp of\n      jdtString:\n        Result.FData.FValue := Value;\n      jdtInt:\n        Result.FData.FIntValue := Value;\n      jdtLong:\n        Result.FData.FLongValue := Value;\n      jdtULong:\n        Result.FData.FULongValue := Value;\n      jdtFloat:\n        Result.FData.FFloatValue := Value;\n      jdtDateTime:\n        Result.FData.FDateTimeValue := Value;\n      jdtBool:\n        Result.FData.FBoolValue := Value;\n      {$IFNDEF AUTOREFCOUNT}\n      jdtObject:\n        Result.FData.FObj := nil;\n      {$ENDIF ~AUTOREFCOUNT}\n    end;\n  end;\nend;\n\nfunction TJsonDataValueHelper.GetValue: string;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetValue(const Value: string);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.Value := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetIntValue: Integer;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetIntValue(const Value: Integer);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.IntValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetLongValue: Int64;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetLongValue(const Value: Int64);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.LongValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetULongValue: UInt64;\nbegin\n//  Result := Self;\n  // copied from UInt64 implicit operator\n  if FData.FIntern <> nil then\n    Result := FData.FIntern.LongValue\n  else\n    case FData.FTyp of\n      jdtString:\n        Result := StrToInt64Def(FData.FValue, 0);\n      jdtInt:\n        Result := FData.FIntValue;\n      jdtLong:\n        Result := FData.FLongValue;\n      jdtULong:\n        Result := FData.FULongValue;\n      jdtFloat:\n        Result := Trunc(FData.FFloatValue);\n      jdtDateTime, jdtUtcDateTime:\n        Result := Trunc(FData.FDateTimeValue);\n      jdtBool:\n        Result := Ord(FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nprocedure TJsonDataValueHelper.SetULongValue(const Value: UInt64);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.ULongValue := Value\n  else\n  begin\n    //Self := Value;\n    // copied from UInt64 implicit operator\n    FData.FName := '';\n    FData.FNameResolver := nil;\n    FData.FIntern := nil;\n    if FData.FValue <> '' then\n      FData.FValue := '';\n    {$IFDEF AUTOREFCOUNT}\n    if FData.FObj <> nil then\n      FData.FObj := nil;\n    {$ENDIF AUTOREFCOUNT}\n    FData.FTyp := jdtLong;\n    FData.FLongValue := Value;\n  end;\nend;\n\nfunction TJsonDataValueHelper.GetFloatValue: Double;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetFloatValue(const Value: Double);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.FloatValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetDateTimeValue: TDateTime;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetDateTimeValue(const Value: TDateTime);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.DateTimeValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetUtcDateTimeValue: TDateTime;\nbegin\n  if FData.FIntern <> nil then\n    Result := FData.FIntern.UtcDateTimeValue\n  else\n    case FData.FTyp of\n      jdtString:\n        Result := TJsonBaseObject.JSONToDateTime(FData.FValue, False);\n      jdtInt:\n        Result := FData.FIntValue;\n      jdtLong:\n        Result := FData.FLongValue;\n      jdtULong:\n        Result := FData.FULongValue;\n      jdtFloat:\n        Result := FData.FFloatValue;\n      jdtDateTime:\n        Result := LocalDateTimeToUtcDateTime(FData.FDateTimeValue);\n      jdtUtcDateTime:\n        Result := FData.FDateTimeValue;\n      jdtBool:\n        Result := Ord(FData.FBoolValue);\n    else\n      Result := 0;\n    end;\nend;\n\nprocedure TJsonDataValueHelper.SetUtcDateTimeValue(const Value: TDateTime);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.UtcDateTimeValue := Value\n  else\n  begin\n    FData.FName := '';\n    FData.FNameResolver := nil;\n    FData.FIntern := nil;\n    if FData.FValue <> '' then\n      FData.FValue := '';\n    {$IFDEF AUTOREFCOUNT}\n    if FData.FObj <> nil then\n      FData.FObj := nil;\n    {$ENDIF AUTOREFCOUNT}\n    FData.FTyp := jdtUtcDateTime;\n    FData.FDateTimeValue := Value;\n  end;\nend;\n\nfunction TJsonDataValueHelper.GetBoolValue: Boolean;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetBoolValue(const Value: Boolean);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.BoolValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetArrayValue: TJsonArray;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetArrayValue(const Value: TJsonArray);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.ArrayValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetObjectValue: TJsonObject;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectValue(const Value: TJsonObject);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.ObjectValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetVariantValue: Variant;\nbegin\n  Result := Self;\nend;\n\nprocedure TJsonDataValueHelper.SetVariantValue(const Value: Variant);\nbegin\n  ResolveName;\n  if FData.FIntern <> nil then\n    FData.FIntern.VariantValue := Value\n  else\n    Self := Value;\nend;\n\nfunction TJsonDataValueHelper.GetTyp: TJsonDataType;\nbegin\n  if FData.FIntern <> nil then\n    Result := FData.FIntern.Typ\n  else\n    Result := FData.FTyp;\nend;\n\nfunction TJsonDataValueHelper.IsNull: Boolean;\nbegin\n  if FData.FIntern <> nil then\n    Result := FData.FIntern.IsNull\n  else\n  begin\n    case FData.FTyp of\n      jdtNone:\n        Result := True;\n      jdtObject:\n        Result := FData.FObj = nil;\n    else\n      Result := False;\n    end;\n  end;\nend;\n\nclass procedure TJsonDataValueHelper.SetInternValue(Item: PJsonDataValue;\n  const Value: TJsonDataValueHelper);\nbegin\n  Value.ResolveName;\n  if Value.FData.FIntern <> nil then\n  begin\n    Item.Clear;\n    TJsonBaseObject.InternInitAndAssignItem(Item, Value.FData.FIntern); // clones arrays and objects\n  end\n  else\n  begin\n    case Value.FData.FTyp of\n      jdtString:\n        Item.Value := Value.FData.FValue;\n      jdtInt:\n        Item.IntValue := Value.FData.FIntValue;\n      jdtLong:\n        Item.LongValue := Value.FData.FLongValue;\n      jdtULong:\n        Item.ULongValue := Value.FData.FULongValue;\n      jdtFloat:\n        Item.FloatValue := Value.FData.FFloatValue;\n      jdtDateTime, jdtUtcDateTime:\n        Item.DateTimeValue := Value.FData.FDateTimeValue;\n      jdtBool:\n        Item.BoolValue := Value.FData.FBoolValue;\n      jdtArray:\n        Item.ArrayValue := TJsonArray(Value.FData.FObj);\n      jdtObject:\n        Item.ObjectValue := TJsonObject(Value.FData.FObj);\n    else\n      Item.Clear;\n    end;\n  end;\nend;\n\nfunction TJsonDataValueHelper.GetArrayItem(Index: Integer): TJsonDataValueHelper;\nbegin\n  Result := ArrayValue.Values[Index];\nend;\n\nfunction TJsonDataValueHelper.GetArrayCount: Integer;\nbegin\n  Result := ArrayValue.Count;\nend;\n\nprocedure TJsonDataValueHelper.ResolveName;\nbegin\n  if (FData.FIntern = nil) and (FData.FNameResolver <> nil) then\n  begin\n    FData.FIntern := FData.FNameResolver.RequireItem(FData.FName);\n    FData.FNameResolver := nil;\n    FData.FName := '';\n  end;\nend;\n\nfunction TJsonDataValueHelper.GetObjectString(const Name: string): string;\nbegin\n  Result := ObjectValue.S[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectInt(const Name: string): Integer;\nbegin\n  Result := ObjectValue.I[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectLong(const Name: string): Int64;\nbegin\n  Result := ObjectValue.L[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectULong(const Name: string): UInt64;\nbegin\n  Result := ObjectValue.U[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectFloat(const Name: string): Double;\nbegin\n  Result := ObjectValue.F[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectDateTime(const Name: string): TDateTime;\nbegin\n  Result := ObjectValue.D[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectUtcDateTime(const Name: string): TDateTime;\nbegin\n  Result := ObjectValue.DUtc[Name];\nend;\n\nfunction TJsonDataValueHelper.GetObjectBool(const Name: string): Boolean;\nbegin\n  Result := ObjectValue.B[Name];\nend;\n\nfunction TJsonDataValueHelper.GetArray(const Name: string): TJsonArray;\nbegin\n  Result := ObjectValue.A[Name];\nend;\n\n{$IFDEF BCB}\nfunction TJsonDataValueHelper.GetObj(const Name: string): TJsonDataValueHelper;\nbegin\n  Result := ObjectValue.Values[Name];\nend;\n{$ELSE}\nfunction TJsonDataValueHelper.GetObject(const Name: string): TJsonDataValueHelper;\nbegin\n  Result := ObjectValue.Values[Name];\nend;\n{$ENDIF BCB}\n\nfunction TJsonDataValueHelper.GetObjectVariant(const Name: string): Variant;\nbegin\n  Result := ObjectValue.Values[Name];\nend;\n\nprocedure TJsonDataValueHelper.SetObjectString(const Name, Value: string);\nbegin\n  ObjectValue.S[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectInt(const Name: string; const Value: Integer);\nbegin\n  ObjectValue.I[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectLong(const Name: string; const Value: Int64);\nbegin\n  ObjectValue.L[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectULong(const Name: string; const Value: UInt64);\nbegin\n  ObjectValue.U[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectFloat(const Name: string; const Value: Double);\nbegin\n  ObjectValue.F[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectDateTime(const Name: string; const Value: TDateTime);\nbegin\n  ObjectValue.D[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectUtcDateTime(const Name: string; const Value: TDateTime);\nbegin\n  ObjectValue.DUtc[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectBool(const Name: string; const Value: Boolean);\nbegin\n  ObjectValue.B[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetArray(const Name: string; const Value: TJsonArray);\nbegin\n  ObjectValue.A[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObject(const Name: string; const Value: TJsonDataValueHelper);\nbegin\n  ObjectValue.Values[Name] := Value;\nend;\n\nprocedure TJsonDataValueHelper.SetObjectVariant(const Name: string; const Value: Variant);\nbegin\n  ObjectValue.Values[Name] := Value;\nend;\n\nfunction TJsonDataValueHelper.GetObjectPath(const Name: string): TJsonDataValueHelper;\nbegin\n  Result := ObjectValue.Path[Name];\nend;\n\nprocedure TJsonDataValueHelper.SetObjectPath(const Name: string; const Value: TJsonDataValueHelper);\nbegin\n  ObjectValue.Path[Name] := Value;\nend;\n\n{ TEncodingStrictAccess }\n\nfunction TEncodingStrictAccess.GetByteCountEx(Chars: PChar; CharCount: Integer): Integer;\nbegin\n  Result := GetByteCount(Chars, CharCount);\nend;\n\nfunction TEncodingStrictAccess.GetBytesEx(Chars: PChar; CharCount: Integer; Bytes: PByte; ByteCount: Integer): Integer;\nbegin\n  Result := GetBytes(Chars, CharCount, Bytes, ByteCount);\nend;\n\nfunction TEncodingStrictAccess.GetCharCountEx(Bytes: PByte; ByteCount: Integer): Integer;\nbegin\n  Result := GetCharCount(Bytes, ByteCount);\nend;\n\nfunction TEncodingStrictAccess.GetCharsEx(Bytes: PByte; ByteCount: Integer; Chars: PChar; CharCount: Integer): Integer;\nbegin\n  Result := GetChars(Bytes, ByteCount, Chars, CharCount);\nend;\n\n{ TJsonOutputWriter.TJsonStringBuilder }\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Init;\nbegin\n  FLen := 0;\n  FCapacity := 0;\n  FData := nil;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Done;\nvar\n  P: PStrRec;\nbegin\n  if FData <> nil then\n  begin\n    P := PStrRec(PByte(FData) - SizeOf(TStrRec));\n    FreeMem(P);\n  end;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.DoneConvertToString(var S: string);\nvar\n  StrP: PStrRec;\n  P: PChar;\nbegin\n  S := '';\n  if FData <> nil then\n  begin\n    // Release the unused memory and terminate the string with a #0. The result is that we have a\n    // native string that is exactly the same as if it was allocated by System.@NewUnicodeString.\n    StrP := PStrRec(PByte(FData) - SizeOf(TStrRec));\n    if Len = 0 then\n      FreeMem(StrP)\n    else\n    begin\n      if Len <> FCapacity then\n        ReallocMem(Pointer(StrP), SizeOf(TStrRec) + (Len + 1) * SizeOf(Char)); // allocate +1 char for the #0\n      // Set the string's length\n      StrP.Length := Len;\n      P := PChar(PByte(StrP) + SizeOf(TStrRec));\n      P[Len] := #0;\n      Pointer(S) := P; // keep the RefCnt=1\n    end;\n  end;\nend;\n\nfunction TJsonOutputWriter.TJsonStringBuilder.FlushToBytes(var Bytes: PByte; var Size: NativeInt; Encoding: TEncoding): NativeInt;\nbegin\n  if FLen > 0 then\n  begin\n    // Use the \"strict protected\" methods that use PChar instead of TCharArray what allows us to\n    // use FData directly without converting it to a dynamic TCharArray (and skipping the sanity\n    // checks)\n    Result := TEncodingStrictAccess(Encoding).GetByteCountEx(FData, FLen);\n    if Result > 0 then\n    begin\n      if Result > Size then\n      begin\n        Size := (Result + 4095) and not 4095;\n        ReallocMem(Bytes, Size);\n      end;\n      TEncodingStrictAccess(Encoding).GetBytesEx(FData, FLen, Bytes, Result);\n    end;\n    FLen := 0; // \"clear\" the buffer but don't release the memory\n  end\n  else\n    Result := 0;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.FlushToMemoryStream(Stream: TMemoryStream; Encoding: TEncoding);\nvar\n  L: Integer;\n  Idx, NewSize: NativeInt;\nbegin\n  if FLen > 0 then\n  begin\n    // Use the \"strict protected\" methods that use PChar instead of TCharArray what allows us to\n    // use FData directly without converting it to a dynamic TCharArray (and skipping the sanity\n    // checks)\n    L := TEncodingStrictAccess(Encoding).GetByteCountEx(FData, FLen);\n    if L > 0 then\n    begin\n      // Directly convert into the TMemoryStream.Memory buffer\n      Idx := Stream.Position;\n      NewSize := Idx + L;\n      if NewSize > TMemoryStreamAccess(Stream).Capacity then\n        TMemoryStreamAccess(Stream).Capacity := NewSize;\n\n      TEncodingStrictAccess(Encoding).GetBytesEx(FData, FLen, @PByte(Stream.Memory)[Idx], L);\n      TMemoryStreamAccess(Stream).SetPointer(Stream.Memory, NewSize);\n      Stream.Position := NewSize;\n    end;\n  end;\n  FLen := 0; // \"clear\" the buffer but don't release the memory\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Grow(MinLen: Integer);\nvar\n  C: Integer;\n  StrP: PStrRec;\nbegin\n  C := FCapacity;\n  C := C * 2;\n  if MinLen < 256 then // begin with a 256 char buffer\n    MinLen := 256;\n  {$IFNDEF CPUX64}\n  if C > 256 * 1024 * 1024 then\n  begin\n    // Memory fragmentation can become a problem, so allocate only the amount of memory that\n    // is needed\n    C := FCapacity;\n    C := C + (C div 3);\n    if C < MinLen then\n      C := MinLen;\n  end\n  else\n  {$ENDIF ~CPUX64}\n  if C < MinLen then\n    C := MinLen;\n  FCapacity := C;\n  if FData <> nil then\n  begin\n    StrP := Pointer(PByte(FData) - SizeOf(TStrRec));\n    ReallocMem(StrP, SizeOf(TStrRec) + (C + 1) * SizeOf(Char)); // allocate +1 char for the #0 that DoneToString() adds\n  end\n  else\n  begin\n    // Build the buffer with the StrRec header so it can be easily mapped to a \"native string\" in\n    // DoneToString.\n    GetMem(Pointer(StrP), SizeOf(TStrRec) + (C + 1) * SizeOf(Char)); // allocate +1 char for the #0 that DoneToString() adds\n    StrP.CodePage := Word(DefaultUnicodeCodePage);\n    StrP.ElemSize := SizeOf(Char);\n    StrP.RefCnt := 1;\n    StrP.Length := 0; // DoneToString set the correct value\n  end;\n  FData := PChar(PByte(StrP) + SizeOf(TStrRec));\nend;\n\nfunction TJsonOutputWriter.TJsonStringBuilder.Append(const S: string): PJsonStringBuilder;\nvar\n  L, LLen: Integer;\nbegin\n  LLen := FLen;\n  L := Length(S);\n  if L > 0 then\n  begin\n    if LLen + L >= FCapacity then\n      Grow(LLen + L);\n    case L of\n      1: FData[LLen] := PChar(Pointer(S))^;\n      2: PLongWord(@FData[LLen])^ := PLongWord(Pointer(S))^;\n    else\n      Move(PChar(Pointer(S))[0], FData[LLen], L * SizeOf(Char));\n    end;\n    FLen := LLen + L;\n  end;\n  Result := @Self;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Append(P: PChar; Len: Integer);\nvar\n  LLen: Integer;\nbegin\n  LLen := FLen;\n  if Len > 0 then\n  begin\n    if LLen + Len >= FCapacity then\n      Grow(LLen + Len);\n    case Len of\n      1: FData[LLen] := P^;\n      2: PLongWord(@FData[LLen])^ := PLongWord(P)^;\n    else\n      Move(P[0], FData[LLen], Len * SizeOf(Char));\n    end;\n    FLen := LLen + Len;\n  end;\nend;\n\nfunction TJsonOutputWriter.TJsonStringBuilder.Append2(const S1: string; S2: PChar; S2Len: Integer): PJsonStringBuilder;\nvar\n  L, S1Len, LLen: Integer;\nbegin\n  LLen := FLen;\n  S1Len := Length(S1);\n  L := S1Len + S2Len;\n  if LLen + L >= FCapacity then\n    Grow(LLen + L);\n\n  case S1Len of\n    0: ;\n    1: FData[LLen] := PChar(Pointer(S1))^;\n    2: PLongWord(@FData[LLen])^ := PLongWord(Pointer(S1))^;\n  else\n    Move(PChar(Pointer(S1))[0], FData[LLen], S1Len * SizeOf(Char));\n  end;\n  Inc(LLen, S1Len);\n\n  case S2Len of\n    0: ;\n    1: FData[LLen] := S2^;\n    2: PLongWord(@FData[LLen])^ := PLongWord(Pointer(S2))^;\n  else\n    Move(S2[0], FData[LLen], S2Len * SizeOf(Char));\n  end;\n  FLen := LLen + S2Len;\n  Result := @Self;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Append2(Ch1: Char; Ch2: Char);\nvar\n  LLen: Integer;\nbegin\n  LLen := FLen;\n  if LLen + 2 >= FCapacity then\n    Grow(2);\n  FData[LLen] := Ch1;\n  FData[LLen + 1] := Ch2;\n  FLen := LLen + 2;\nend;\n\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Append3(Ch1: Char; const S2, S3: string);\nvar\n  L, S2Len, S3Len, LLen: Integer;\nbegin\n  LLen := FLen;\n  S2Len := Length(S2);\n  S3Len := Length(S3);\n  L := 1 + S2Len + S3Len;\n  if LLen + L >= FCapacity then\n    Grow(LLen + L);\n\n  FData[LLen] := Ch1;\n  Inc(LLen);\n\n  case S2Len of\n    0: ;\n    1: FData[LLen] := PChar(Pointer(S2))^;\n    2: PLongWord(@FData[LLen])^ := PLongWord(Pointer(S2))^;\n  else\n    Move(PChar(Pointer(S2))[0], FData[LLen], S2Len * SizeOf(Char));\n  end;\n  Inc(LLen, S2Len);\n\n  case S3Len of\n    1: FData[LLen] := PChar(Pointer(S3))^;\n    2: PLongWord(@FData[LLen])^ := PLongWord(Pointer(S3))^;\n  else\n    Move(PChar(Pointer(S3))[0], FData[LLen], S3Len * SizeOf(Char));\n  end;\n  FLen := LLen + S3Len;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Append3(Ch1: Char; const P2: PChar; P2Len: Integer; Ch3: Char);\nvar\n  L, LLen: Integer;\nbegin\n  LLen := FLen;\n  L := 2 + P2Len;\n  if LLen + L >= FCapacity then\n    Grow(LLen + L);\n\n  FData[LLen] := Ch1;\n  Inc(LLen);\n\n  case P2Len of\n    0: ;\n    1: FData[LLen] := P2^;\n    2: PLongWord(@FData[LLen])^ := PLongWord(P2)^;\n  else\n    Move(P2[0], FData[LLen], P2Len * SizeOf(Char));\n  end;\n  Inc(LLen, P2Len);\n\n  FData[LLen] := Ch1;\n  FLen := LLen + 1;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.Append3(Ch1: Char; const S2: string; Ch3: Char);\nbegin\n  Append3(Ch1, PChar(Pointer(S2)), Length(S2), Ch3);\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.FlushToStringBuffer(var Buffer: TJsonStringBuilder);\nbegin\n  Buffer.Append(FData, FLen);\n  FLen := 0;\nend;\n\nprocedure TJsonOutputWriter.TJsonStringBuilder.FlushToString(var S: string);\nbegin\n  SetString(S, FData, FLen);\n  FLen := 0;\nend;\n\n{ TJsonUTF8StringStream }\n\n{$IFDEF SUPPORTS_UTF8STRING}\nconstructor TJsonUTF8StringStream.Create;\nbegin\n  inherited Create;\n  SetPointer(nil, 0);\nend;\n\nfunction TJsonUTF8StringStream.Realloc(var NewCapacity: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND}): Pointer;\nvar\n  L: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND};\nbegin\n  if NewCapacity <> Capacity then\n  begin\n    if NewCapacity = 0 then\n      FDataString := ''\n    else\n    begin\n      L := Length(FDataString) * 2;\n      {$IFNDEF CPUX64}\n      if L > 256 * 1024 * 1024 then\n      begin\n        // Memory fragmentation can become a problem, so allocate only the amount of memory that\n        // is needed\n        L := NewCapacity;\n      end\n      else\n      {$ENDIF ~CPUX64}\n      if L < NewCapacity then\n        L := NewCapacity;\n      NewCapacity := L;\n      SetLength(FDataString, L);\n    end;\n  end;\n  Result := Pointer(FDataString);\nend;\n{$ENDIF SUPPORTS_UTF8STRING}\n\n{ TJsonBytesStream }\n\nconstructor TJsonBytesStream.Create;\nbegin\n  inherited Create;\n  SetPointer(nil, 0);\nend;\n\nfunction TJsonBytesStream.Realloc(var NewCapacity: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND}): Pointer;\nvar\n  L: {$IF Defined(STREAM_USES_NATIVEINT)}NativeInt{$ELSE}Longint{$IFEND};\nbegin\n  if NewCapacity <> Capacity then\n  begin\n    if NewCapacity = 0 then\n      FBytes := nil\n    else\n    begin\n      L := Length(FBytes) * 2;\n      {$IFNDEF CPUX64}\n      if L > 256 * 1024 * 1024 then\n      begin\n        // Memory fragmentation can become a problem, so allocate only the amount of memory that\n        // is needed\n        L := NewCapacity;\n      end\n      else\n      {$ENDIF ~CPUX64}\n      if L < NewCapacity then\n        L := NewCapacity;\n      NewCapacity := L;\n      ByteArraySetLengthUninit(FBytes, L);\n    end;\n  end;\n  Result := Pointer(FBytes);\nend;\n\ninitialization\n  {$IFDEF USE_NAME_STRING_LITERAL}\n  InitializeJsonMemInfo;\n  {$ENDIF USE_NAME_STRING_LITERAL}\n  {$IFDEF MSWINDOWS}\n    {$IFDEF SUPPORT_WINDOWS2000}\n  TzSpecificLocalTimeToSystemTime := GetProcAddress(GetModuleHandle(kernel32), PAnsiChar('TzSpecificLocalTimeToSystemTime'));\n  if not Assigned(TzSpecificLocalTimeToSystemTime) then\n    TzSpecificLocalTimeToSystemTime := TzSpecificLocalTimeToSystemTimeWin2000;\n    {$ENDIF SUPPORT_WINDOWS2000}\n  {$ENDIF MSWINDOWS}\n  // Make sTrue and sFalse a mutable string (RefCount<>-1) so that UStrAsg doesn't always\n  // create a new string.\n  UniqueString(sTrue);\n  UniqueString(sFalse);\n  JSONFormatSettings.DecimalSeparator := '.';\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace JsonDataObjects\n{\n    #region Exceptions\n\n    public class JsonException : Exception\n    {\n        public JsonException(string message) : base(message) { }\n    }\n\n    public class JsonCastException : JsonException\n    {\n        public JsonCastException(string message) : base(message) { }\n    }\n\n    public class JsonPathException : JsonException\n    {\n        public JsonPathException(string message) : base(message) { }\n    }\n\n    public class JsonParserException : JsonException\n    {\n        public int LineNum { get; }\n        public int Column { get; }\n        public int Position { get; }\n\n        public JsonParserException(string message, int lineNum, int column, int position)\n            : base($\"{message} ({lineNum}, {column})\")\n        {\n            LineNum = lineNum;\n            Column = column;\n            Position = position;\n        }\n    }\n\n    #endregion\n\n    #region Configuration\n\n    public struct JsonSerializationConfig\n    {\n        public string LineBreak;\n        public string IndentChar;\n        public bool UseUtcTime;\n        public bool EscapeAllNonASCIIChars;\n        public bool NullConvertsToValueTypes;\n\n        public void InitDefaults()\n        {\n            LineBreak = \"\\n\";\n            IndentChar = \"\\t\";\n            UseUtcTime = true;\n            EscapeAllNonASCIIChars = false;\n            NullConvertsToValueTypes = false;\n        }\n\n        public static JsonSerializationConfig Default\n        {\n            get\n            {\n                var cfg = new JsonSerializationConfig();\n                cfg.InitDefaults();\n                return cfg;\n            }\n        }\n    }\n\n    #endregion\n\n    #region Core JSON Objects\n\n    \n    public abstract class JsonBaseObject\n    {\n        \n        public abstract JObject ToJson();\n\n        \n        public abstract void FromJson(JObject json);\n\n        \n        public JsonBaseObject Clone()\n        {\n            \n            var json = ToJson();\n            var clone = CreateInstance();\n            clone.FromJson(json);\n            return clone;\n        }\n\n        protected abstract JsonBaseObject CreateInstance();\n\n        public static string DateTimeToJSON(DateTime value, bool useUtcTime)\n        {\n            if (useUtcTime)\n                return value.ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\", CultureInfo.InvariantCulture);\n            else\n                return value.ToString(\"yyyy-MM-ddTHH:mm:ss.fff\", CultureInfo.InvariantCulture);\n        }\n\n        public static DateTime JSONToDateTime(string value, bool convertToLocalTime = true)\n        {\n            \n            var dt = DateTime.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal);\n            return convertToLocalTime ? dt.ToLocalTime() : dt;\n        }\n\n        public static string UtcDateTimeToJSON(DateTime utcDateTime)\n        {\n            return utcDateTime.ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\", CultureInfo.InvariantCulture);\n        }\n    }\n\n    \n    public class JsonObject : JsonBaseObject\n    {\n        private readonly Dictionary<string, object> _dict = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);\n\n        public void Add(string key, object value)\n        {\n            _dict[key] = value;\n        }\n\n        public bool ContainsKey(string key) => _dict.ContainsKey(key);\n\n        public object this[string key]\n        {\n            get => _dict.TryGetValue(key, out var value) ? value : null;\n            set => _dict[key] = value;\n        }\n\n        public override JObject ToJson()\n        {\n            var jobj = new JObject();\n            foreach (var kv in _dict)\n            {\n                if (kv.Value is JsonBaseObject jbo)\n                    jobj[kv.Key] = jbo.ToJson();\n                else if (kv.Value is JsonArray jarr)\n                    jobj[kv.Key] = jarr.ToJson()[\"array\"]; \n                else\n                    jobj[kv.Key] = JToken.FromObject(kv.Value);\n            }\n            return jobj;\n        }\n\n        public override void FromJson(JObject json)\n        {\n            _dict.Clear();\n            foreach (var prop in json.Properties())\n            {\n                \n                _dict[prop.Name] = prop.Value;\n            }\n        }\n\n        protected override JsonBaseObject CreateInstance() => new JsonObject();\n\n        public JsonObject CloneObject() => (JsonObject)this.Clone();\n    }\n\n    \n    public class JsonArray : JsonBaseObject\n    {\n        private readonly List<object> _items = new List<object>();\n\n        public void Add(object value)\n        {\n            _items.Add(value);\n        }\n\n        public object this[int index]\n        {\n            get => _items[index];\n            set => _items[index] = value;\n        }\n\n        public int Count => _items.Count;\n\n        public override JObject ToJson()\n        {\n            var jarr = new JArray();\n            foreach (var item in _items)\n            {\n                if (item is JsonBaseObject jbo)\n                    jarr.Add(jbo.ToJson());\n                else\n                    jarr.Add(JToken.FromObject(item));\n            }\n            \n            return new JObject { [\"array\"] = jarr };\n        }\n\n        public override void FromJson(JObject json)\n        {\n            _items.Clear();\n            var jarr = json[\"array\"] as JArray;\n            if (jarr != null)\n            {\n                foreach (var token in jarr)\n                    _items.Add(token);\n            }\n        }\n\n        protected override JsonBaseObject CreateInstance() => new JsonArray();\n\n        public JsonArray CloneArray() => (JsonArray)this.Clone();\n    }\n\n    #endregion\n\n    #region Data Value Helper\n\n    \n    public class JsonDataValueHelper\n    {\n        public JsonDataType Type { get; set; }\n        public object Value { get; set; }\n\n        public static implicit operator JsonDataValueHelper(string value)\n        {\n            return new JsonDataValueHelper { Type = JsonDataType.String, Value = value };\n        }\n\n        public static implicit operator string(JsonDataValueHelper helper)\n        {\n            return helper.Value?.ToString();\n        }\n\n        public static implicit operator JsonDataValueHelper(int value)\n        {\n            return new JsonDataValueHelper { Type = JsonDataType.Int, Value = value };\n        }\n\n        public static implicit operator int(JsonDataValueHelper helper)\n        {\n            if (helper.Value is int i) return i;\n            if (int.TryParse(helper.Value?.ToString(), out i))\n                return i;\n            return 0;\n        }\n\n        \n    }\n\n    public enum JsonDataType\n    {\n        None,\n        String,\n        Int,\n        Long,\n        ULong,\n        Float,\n        DateTime,\n        UtcDateTime,\n        Bool,\n        Array,\n        Object\n    }\n\n    #endregion\n\n    #region Parsing and Serialization\n\n    \n    public static class JsonParser\n    {\n        \n        public static JsonBaseObject Parse(string json)\n        {\n            if (string.IsNullOrWhiteSpace(json))\n                return null;\n            json = json.Trim();\n            if (json.StartsWith(\"[\"))\n            {\n                var arr = new JsonArray();\n                arr.FromJson(new JObject { [\"array\"] = JArray.Parse(json) });\n                return arr;\n            }\n            else\n            {\n                var obj = new JsonObject();\n                obj.FromJson(JObject.Parse(json));\n                return obj;\n            }\n        }\n\n        \n        public static string Serialize(JsonBaseObject jsonObj, bool compact = true)\n        {\n            var formatting = compact ? Formatting.None : Formatting.Indented;\n            return jsonObj.ToJson().ToString(formatting);\n        }\n    }\n\n    #endregion\n\n    #region Example Usage\n\n    \n\n    #endregion\n}"}
{"input": "unit Horse.Core.Param.Config;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\ntype\n  THorseCoreParamConfig = class\n  private\n    class var FInstance: THorseCoreParamConfig;\n    FRequiredMessage: string;\n    FInvalidFormatMessage: string;\n    FDateFormat: string;\n    FTimeFormat: string;\n    FReturnUTC: Boolean;\n    FTrueValue: string;\n    FCheckLhsBrackets: Boolean;\n    constructor Create;\n  public\n    function RequiredMessage(const AValue: string): THorseCoreParamConfig; overload;\n    function RequiredMessage: string; overload;\n    function InvalidFormatMessage(const AValue: string): THorseCoreParamConfig; overload;\n    function InvalidFormatMessage: string; overload;\n    function DateFormat(const AValue: string): THorseCoreParamConfig; overload;\n    function DateFormat: string; overload;\n    function TimeFormat(const AValue: string): THorseCoreParamConfig; overload;\n    function TimeFormat: string; overload;\n    function ReturnUTC(const AValue: Boolean): THorseCoreParamConfig; overload;\n    function ReturnUTC: Boolean; overload;\n    function TrueValue(const AValue: string): THorseCoreParamConfig; overload;\n    function TrueValue: string; overload;\n    function CheckLhsBrackets(const AValue: Boolean): THorseCoreParamConfig; overload;\n    function CheckLhsBrackets: Boolean; overload;\n    class function GetInstance: THorseCoreParamConfig;\n    class destructor UnInitialize;\n  end;\n\nimplementation\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils;\n{$ELSE}\n  System.SysUtils;\n{$ENDIF}\n\nconstructor THorseCoreParamConfig.Create;\nbegin\n  FReturnUTC := True;\n  FDateFormat := 'yyyy-MM-dd';\n  FTimeFormat := 'hh:mm:ss';\n  FTrueValue := 'true';\n  FRequiredMessage := 'The %s param is required.';\n  FInvalidFormatMessage := 'The %0:s param ''%1:s'' is not valid a %2:s type.';\n  FCheckLhsBrackets := False;\nend;\n\nfunction THorseCoreParamConfig.DateFormat(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FDateFormat := AValue;\nend;\n\nfunction THorseCoreParamConfig.DateFormat: string;\nbegin\n  Result := FDateFormat;\nend;\n\nclass function THorseCoreParamConfig.GetInstance: THorseCoreParamConfig;\nbegin\n  if not Assigned(FInstance) then\n    FInstance := THorseCoreParamConfig.Create;\n  Result := FInstance;\nend;\n\nfunction THorseCoreParamConfig.InvalidFormatMessage: string;\nbegin\n  Result := FInvalidFormatMessage;\nend;\n\nfunction THorseCoreParamConfig.InvalidFormatMessage(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FInvalidFormatMessage := AValue;\nend;\n\nfunction THorseCoreParamConfig.RequiredMessage(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FRequiredMessage := AValue;\nend;\n\nfunction THorseCoreParamConfig.RequiredMessage: string;\nbegin\n  Result := FRequiredMessage;\nend;\n\nfunction THorseCoreParamConfig.ReturnUTC(const AValue: Boolean): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FReturnUTC := AValue;\nend;\n\nfunction THorseCoreParamConfig.ReturnUTC: Boolean;\nbegin\n  Result := FReturnUTC;\nend;\n\nfunction THorseCoreParamConfig.TimeFormat: string;\nbegin\n  Result := FTimeFormat;\nend;\n\nfunction THorseCoreParamConfig.TimeFormat(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FTimeFormat := AValue;\nend;\n\nfunction THorseCoreParamConfig.TrueValue(const AValue: string): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FTrueValue := AValue;\nend;\n\nfunction THorseCoreParamConfig.TrueValue: string;\nbegin\n  Result := FTrueValue;\nend;\n\nfunction THorseCoreParamConfig.CheckLhsBrackets(const AValue: Boolean\n  ): THorseCoreParamConfig;\nbegin\n  Result := Self;\n  FCheckLhsBrackets := AValue;\nend;\n\nfunction THorseCoreParamConfig.CheckLhsBrackets: Boolean;\nbegin\n  Result := FCheckLhsBrackets;\nend;\n\nclass destructor THorseCoreParamConfig.UnInitialize;\nbegin\n  if Assigned(FInstance) then\n    FreeAndNil(FInstance);\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Core.Param.Config\n{\n    public class HorseCoreParamConfig\n    {\n        private static HorseCoreParamConfig _instance;\n        private string _requiredMessage;\n        private string _invalidFormatMessage;\n        private string _dateFormat;\n        private string _timeFormat;\n        private bool _returnUTC;\n        private string _trueValue;\n        private bool _checkLhsBrackets;\n\n        private HorseCoreParamConfig()\n        {\n            _returnUTC = true;\n            _dateFormat = \"yyyy-MM-dd\";\n            _timeFormat = \"hh:mm:ss\";\n            _trueValue = \"true\";\n            _requiredMessage = \"The %s param is required.\";\n            _invalidFormatMessage = \"The %0:s param '%1:s' is not valid a %2:s type.\";\n            _checkLhsBrackets = false;\n        }\n\n        public HorseCoreParamConfig WithRequiredMessage(string value)\n        {\n            _requiredMessage = value;\n            return this;\n        }\n\n        \n        public string RequiredMessage => _requiredMessage;\n\n        \n        public HorseCoreParamConfig WithInvalidFormatMessage(string value)\n        {\n            _invalidFormatMessage = value;\n            return this;\n        }\n\n        \n        public string InvalidFormatMessage => _invalidFormatMessage;\n\n        \n        public HorseCoreParamConfig WithDateFormat(string value)\n        {\n            _dateFormat = value;\n            return this;\n        }\n\n        \n        public string DateFormat => _dateFormat;\n\n        \n        public HorseCoreParamConfig WithTimeFormat(string value)\n        {\n            _timeFormat = value;\n            return this;\n        }\n\n        \n        public string TimeFormat => _timeFormat;\n\n        \n        public HorseCoreParamConfig WithReturnUTC(bool value)\n        {\n            _returnUTC = value;\n            return this;\n        }\n\n        \n        public bool ReturnUTC => _returnUTC;\n\n        \n        public HorseCoreParamConfig WithTrueValue(string value)\n        {\n            _trueValue = value;\n            return this;\n        }\n\n        \n        public string TrueValue => _trueValue;\n\n        \n        public HorseCoreParamConfig WithCheckLhsBrackets(bool value)\n        {\n            _checkLhsBrackets = value;\n            return this;\n        }\n\n        \n        public bool CheckLhsBrackets => _checkLhsBrackets;\n\n        \n        public static HorseCoreParamConfig GetInstance()\n        {\n            if (_instance == null)\n            {\n                _instance = new HorseCoreParamConfig();\n            }\n            return _instance;\n        }\n\n        \n        public static void UnInitialize()\n        {\n            _instance = null;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit WebModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  FireDAC.Stan.StorageJSON\n{$IFDEF MSWINDOWS}\n    ,MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes\n{$ENDIF}\n    ;\n\ntype\n  TMainWebModule = class(TWebModule)\n    FDStanStorageJSONLink1: TFDStanStorageJSONLink;\n    procedure WebModuleCreate(Sender: TObject);\n  private\n    MVCEngine: TMVCEngine;\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMainWebModule;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  TestServerControllerU,\n  TestServerControllerExceptionU,\n  SpeedMiddlewareU,\n  MVCFramework.Middleware.Authentication,\n  MVCFramework.ActiveRecordController,\n  System.Generics.Collections,\n  MVCFramework.Commons,\n  TestServerControllerPrivateU,\n  AuthHandlersU,\n  TestServerControllerJSONRPCU,\n  {$IFNDEF LINUX}\n  MVCFramework.View.Renderers.Mustache,\n  {$ENDIF}\n  MVCFramework.Middleware.Compression,\n  MVCFramework.Middleware.Session,\n  MVCFramework.Middleware.StaticFiles,\n  FireDAC.Comp.Client,\n  MVCFramework.ActiveRecord,\n  FDConnectionConfigU,\n  System.IOUtils;\n\nprocedure TMainWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  MVCEngine := TMVCEngine.Create(self,\n    procedure(Config: TMVCConfig)\n    begin\n      // no config here\n      Config[TMVCConfigKey.PathPrefix] := '';\n      Config[TMVCConfigKey.ViewPath] := TPath.Combine(AppPath, '..\\templates');\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n    end);\n  MVCEngine\n    .AddController(TTestServerController)\n    .AddController(TTestPrivateServerController)\n    .AddController(TTestServerControllerExceptionAfterCreate)\n    .AddController(TTestServerControllerExceptionBeforeDestroy)\n    .AddController(TTestServerControllerActionFilters)\n    .AddController(TTestPrivateServerControllerCustomAuth)\n    .AddController(TTestMultiPathController)\n    .AddController(TTestActionResultController)\n    .AddController(TTestJSONRPCController, '/jsonrpc')\n    .AddController(TTestJSONRPCControllerWithGet, '/jsonrpcwithget')\n    .AddController(TMVCActiveRecordController, '/api/entities')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCClass.Create\n    end, '/jsonrpcclass')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCClassWithGET.Create\n    end, '/jsonrpcclasswithget')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClass.Create\n    end, '/jsonrpcclass1')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClassWithGet.Create\n    end, '/jsonrpcclass1withget')\n    .PublishObject(\n    function: TObject\n    begin\n      Result := TTestJSONRPCHookClassWithGet.Create\n    end, '/jsonrpcclass1withget')\n    .AddController(TTestFaultController) // this will raise an exception\n    .AddController(TTestFault2Controller,\n    function: TMVCController\n    begin\n      Result := TTestFault2Controller.Create; // this will raise an exception\n    end)\n    .AddMiddleware(UseMemorySessionMiddleware())\n    .AddMiddleware(TMVCSpeedMiddleware.Create)\n    .AddMiddleware(TMVCCustomAuthenticationMiddleware.Create(TCustomAuthHandler.Create, '/system/users/logged'))\n    .AddMiddleware(TMVCStaticFilesMiddleware.Create('/static', 'www', 'index.html', False))\n    .AddMiddleware(TMVCStaticFilesMiddleware.Create('/spa', 'www', 'index.html', True))\n    .AddMiddleware(TMVCBasicAuthenticationMiddleware.Create(TBasicAuthHandler.Create))\n    .AddMiddleware(TMVCCompressionMiddleware.Create);\n{$IFDEF MSWINDOWS}\n  MVCEngine.SetViewEngine(TMVCMustacheViewEngine);\n  RegisterOptionalCustomTypesSerializers(MVCEngine.Serializer(TMVCMediaType.APPLICATION_JSON));\n{$ENDIF}\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing TestServerControllerU;\nusing TestServerControllerExceptionU;\nusing SpeedMiddlewareU;\nusing MVCFramework.Middleware.Authentication;\nusing MVCFramework.ActiveRecordController;\nusing TestServerControllerPrivateU;\nusing AuthHandlersU;\nusing TestServerControllerJSONRPCU;\nusing MVCFramework.Middleware.Compression;\nusing MVCFramework.Middleware.Session;\nusing MVCFramework.Middleware.StaticFiles;\nusing FDConnectionConfigU;\n\nnamespace WebModuleUnit\n{\n    public class MainWebModule : WebModule\n    {\n        public TMVCEngine MVCEngine { get; private set; }\n        public MainWebModule()\n        {\n            WebModuleCreate();\n        }\n        public void WebModuleCreate()\n        {\n            MVCEngine = new TMVCEngine(this, config =>\n            {\n                config[TMVCConfigKey.PathPrefix] = \"\";\n                config[TMVCConfigKey.ViewPath] = Path.Combine(AppPath, @\"..\\templates\");\n                config[TMVCConfigKey.DefaultViewFileExtension] = \"html\";\n            });\n            MVCEngine\n                .AddController(typeof(TestServerController))\n                .AddController(typeof(TestServerControllerException))\n                .AddController(typeof(TestServerControllerExceptionAfterCreate))\n                .AddController(typeof(TestServerControllerExceptionBeforeDestroy))\n                .AddController(typeof(TestServerControllerActionFilters))\n                .AddController(typeof(TestPrivateServerControllerCustomAuth))\n                .AddController(typeof(TestMultiPathController))\n                .AddController(typeof(TestActionResultController))\n                .AddController(typeof(TestJSONRPCController), \"/jsonrpc\")\n                .AddController(typeof(TestJSONRPCControllerWithGet), \"/jsonrpcwithget\")\n                .AddController(typeof(TMVCActiveRecordController), \"/api/entities\")\n                .PublishObject(() => new TestJSONRPCClass(), \"/jsonrpcclass\")\n                .PublishObject(() => new TestJSONRPCClassWithGET(), \"/jsonrpcclasswithget\")\n                .PublishObject(() => new TestJSONRPCHookClass(), \"/jsonrpcclass1\")\n                .PublishObject(() => new TestJSONRPCHookClassWithGet(), \"/jsonrpcclass1withget\")\n                .PublishObject(() => new TestJSONRPCHookClassWithGet(), \"/jsonrpcclass1withget\")\n                .AddController(typeof(TestFaultController))\n                .AddController(() => new TestFault2Controller(), \"/testfault2\")\n                .AddMiddleware(UseMemorySessionMiddleware())\n                .AddMiddleware(new TMVCSpeedMiddleware())\n                .AddMiddleware(new TMVCCustomAuthenticationMiddleware(new TCustomAuthHandler(), \"/system/users/logged\"))\n                .AddMiddleware(new TMVCStaticFilesMiddleware(\"/static\", \"www\", \"index.html\", false))\n                .AddMiddleware(new TMVCStaticFilesMiddleware(\"/spa\", \"www\", \"index.html\", true))\n                .AddMiddleware(new TMVCBasicAuthenticationMiddleware(new TBasicAuthHandler()))\n                .AddMiddleware(new TMVCCompressionMiddleware());\n#if MSWINDOWS\n            MVCEngine.SetViewEngine(new TMVCMustacheViewEngine());\n            RegisterOptionalCustomTypesSerializers(MVCEngine.Serializer(MVCMediaType.APPLICATION_JSON));\n#endif\n        }\n    }\n}"}
{"input": "unit Controller2U;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/controller2')]\n  TMyController2 = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\nprocedure TMyController2.Index;\nbegin\n  // use Context property to access to the HTTP request and response\n  Render('Hello DelphiMVCFramework World');\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\n\nnamespace Controller2U\n{\n\n    [Route(\"controller2\")]\n    [ApiController]\n    public class MyController2 : ControllerBase\n    {\n       \n        [HttpGet]\n        public IActionResult Index()\n        {\n            \n            return Ok(\"Hello DelphiMVCFramework World\");\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.LRUCache;\n\ninterface\n\nuses\n  System.SysUtils, System.Generics.Collections;\n\ntype\n  TMVCLRUCacheAction = reference to function(const Key: string): Boolean;\n\n  TMVCLRUCache<T: class> = class\n  private type\n    TMVCLRUCacheItem = class\n    public\n      Key: string;\n      Value: T;\n      constructor Create(const Key: string; const Item: T);\n      destructor Destroy; override;\n    end;\n  private\n    fCache: TObjectList<TMVCLRUCacheItem>;\n    fCapacity: Integer;\n  public\n    constructor Create(const Capacity: Integer); virtual;\n    destructor Destroy; override;\n    function Contains(const Key: string; out ItemIndex: UInt64): Boolean;\n    procedure Put(const Key: string; const Item: T);\n    function TryGet(const Key: string; out Item: T): Boolean;\n    procedure RemoveIf(const Action: TMVCLRUCacheAction);\n    procedure Clear;\n    function Size: UInt32;\n    procedure Lock;\n    procedure UnLock;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger;\n\n{ TMVCLRUCache }\n\nprocedure TMVCLRUCache<T>.Clear;\nbegin\n  fCache.Clear;\nend;\n\nfunction TMVCLRUCache<T>.Contains(const Key: string; out ItemIndex: UInt64): Boolean;\nvar\n  I: Integer;\nbegin\n  Result := False;\n  for I := 0 to fCache.Count - 1 do\n  begin\n    if Key = fCache[I].Key then\n    begin\n      ItemIndex := I;\n      Exit(True);\n    end;\n  end;\nend;\n\nfunction TMVCLRUCache<T>.Size: UInt32;\nbegin\n  Result := fCache.Count;\nend;\n\nconstructor TMVCLRUCache<T>.Create(const Capacity: Integer);\nbegin\n  inherited Create;\n  fCapacity := Capacity;\n  fCache := TObjectList<TMVCLRUCacheItem>.Create(True);\nend;\n\ndestructor TMVCLRUCache<T>.Destroy;\nbegin\n  fCache.Free;\n  inherited;\nend;\n\nprocedure TMVCLRUCache<T>.Lock;\nbegin\n  TMonitor.Enter(Self);\nend;\n\nprocedure TMVCLRUCache<T>.Put(const Key: string; const Item: T);\nbegin\n  Lock;\n  try\n    if fCache.Count = fCapacity then\n    begin\n\t    fCache.Delete(fCache.Count - 1);\n    end;\n    fCache.Insert(0, TMVCLRUCacheItem.Create(Key, Item));\n  finally\n    UnLock;\n  end;\nend;\n\nprocedure TMVCLRUCache<T>.RemoveIf(const Action: TMVCLRUCacheAction);\nvar\n  lIndex: Integer;\n  lCacheSize: Integer;\nbegin\n  lIndex := 0;\n  lCacheSize := fCache.Count;\n  while lIndex < lCacheSize do\n  begin\n    if Action(fCache[lIndex].Key) then\n    begin\n      fCache.Delete(lIndex);\n    end\n    else\n    begin\n      Inc(lIndex);\n    end;\n    lCacheSize := fCache.Count;\n  end;\nend;\n\nfunction TMVCLRUCache<T>.TryGet(const Key: string; out Item: T): Boolean;\nvar\n  lItemIndex: UInt64;\n  lCacheItem: TMVCLRUCacheItem;\nbegin\n  Result := Contains(Key, lItemIndex);\n  if Result { and (lItemIndex <> 0) } then\n  begin\n    if lItemIndex > 0 then\n    begin\n      fCache.Exchange(lItemIndex, 0);\n    end;\n    //\n    //\n    // if lItemIndex = 0 then\n    // begin\n    // lCacheItem := fCache[0];\n    // end\n    // else\n    // begin\n    // lCacheItem := fCache.Extract(fCache[lItemIndex]);\n    // fCache.Insert(0, lCacheItem);\n    // end;\n    lCacheItem := fCache[0];\n    Item := lCacheItem.Value;\n  end;\nend;\n\nprocedure TMVCLRUCache<T>.UnLock;\nbegin\n  TMonitor.Exit(Self);\nend;\n\n{ TMVCLRUCache<T>.TMVCLRUCacheItem<T> }\n\nconstructor TMVCLRUCache<T>.TMVCLRUCacheItem.Create(const Key: string; const Item: T);\nbegin\n  inherited Create;\n  Self.Key := Key;\n  Self.Value := Item;\nend;\n\ndestructor TMVCLRUCache<T>.TMVCLRUCacheItem.Destroy;\nbegin\n  Value.Free;\n  Value := nil;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\n\nnamespace MVCFramework\n{\n\n    public delegate bool MVCLRUCacheAction(string key);\n\n    \n    public class MVCLRUCache<T> where T : class\n    {\n        \n        private class MVCLRUCacheItem\n        {\n            public string Key { get; }\n            public T Value { get; }\n\n            public MVCLRUCacheItem(string key, T item)\n            {\n                Key = key;\n                Value = item;\n            }\n        }\n\n        \n        private readonly List<MVCLRUCacheItem> _cache;\n        \n        private readonly int _capacity;\n        \n        private readonly object _syncRoot = new object();\n\n        \n        public MVCLRUCache(int capacity)\n        {\n            _capacity = capacity;\n            _cache = new List<MVCLRUCacheItem>();\n        }\n\n        \n        public void Clear()\n        {\n            lock (_syncRoot)\n            {\n                _cache.Clear();\n            }\n        }\n\n        \n        public bool Contains(string key, out int itemIndex)\n        {\n            lock (_syncRoot)\n            {\n                for (int i = 0; i < _cache.Count; i++)\n                {\n                    if (key == _cache[i].Key)\n                    {\n                        itemIndex = i;\n                        return true;\n                    }\n                }\n                itemIndex = -1;\n                return false;\n            }\n        }\n\n        \n        public void Put(string key, T item)\n        {\n            lock (_syncRoot)\n            {\n                \n                if (_cache.Count == _capacity)\n                {\n                    \n                    _cache.RemoveAt(_cache.Count - 1);\n                }\n                \n                _cache.Insert(0, new MVCLRUCacheItem(key, item));\n            }\n        }\n\n        \n        public bool TryGet(string key, out T item)\n        {\n            lock (_syncRoot)\n            {\n                int index;\n                if (Contains(key, out index))\n                {\n                    if (index > 0)\n                    {\n                        \n                        var cacheItem = _cache[index];\n                        _cache.RemoveAt(index);\n                        _cache.Insert(0, cacheItem);\n                    }\n                    item = _cache[0].Value;\n                    return true;\n                }\n                item = null;\n                return false;\n            }\n        }\n\n        \n        public void RemoveIf(MVCLRUCacheAction action)\n        {\n            lock (_syncRoot)\n            {\n                int index = 0;\n                while (index < _cache.Count)\n                {\n                    if (action(_cache[index].Key))\n                    {\n                        _cache.RemoveAt(index);\n                    }\n                    else\n                    {\n                        index++;\n                    }\n                }\n            }\n        }\n\n        \n        public uint Size()\n        {\n            lock (_syncRoot)\n            {\n                return (uint)_cache.Count;\n            }\n        }\n\n        \n        public void Lock()\n        {\n            Monitor.Enter(_syncRoot);\n        }\n\n        \n        public void UnLock()\n        {\n            Monitor.Exit(_syncRoot);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit DMVC.Expert.Commands.Templates;\n\ninterface\n\nuses\n  System.Generics.Collections, DMVC.Expert.CodeGen.Executor;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nprocedure FillTemplateProTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebStencilsTemplates(Gen: TMVCCodeGenerator);\nprocedure FillMustacheTemplates(Gen: TMVCCodeGenerator);\nprocedure FillEntitiesTemplates(Gen: TMVCCodeGenerator);\nprocedure FillServicesTemplates(Gen: TMVCCodeGenerator);\n\nimplementation\n\nuses\n  DMVC.Expert.Commons,\n  DMVC.Expert.CodeGen.Commands;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitProgramCommand.Create,\n    TUnitRunServerProcBody.Create,\n    TUnitMainBeginEndCommand.Create\n  ]);\nend;\n\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerCommand.Create,\n    TUnitControllerControllerDeclarationCommand.Create,\n    TUnitFooterCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebModuleDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitJSONRPCDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TWebModuleDFMCommand.Create\n    ]);\nend;\n\nprocedure FillMustacheTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitMustacheHelpersDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillTemplateProTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitTemplateProHelpersDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebStencilsTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebStencilsHelpersDeclarationCommand.Create\n    ]);\nend;\n\n\nprocedure FillServicesTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitServicesDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillEntitiesTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerEntityDeclarationCommand.Create\n    ]);\nend;\n\n\nend.", "output": "using System.Collections.Generic;\nusing DMVC.Expert.CodeGen.Executor;       \nusing DMVC.Expert.CodeGen.Commands;        \n\nnamespace DMVCExpertCommandsTemplates\n{\n    public static class CommandsTemplates\n    {\n        public static void FillProgramTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitProgramCommand(),\n                new TUnitRunServerProcBody(),\n                new TUnitMainBeginEndCommand()\n            });\n        }\n\n        public static void FillControllerTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitControllerCommand(),\n                new TUnitControllerControllerDeclarationCommand(),\n                new TUnitFooterCommand()\n            });\n        }\n\n        public static void FillWebModuleTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitWebModuleDeclarationCommand()\n            });\n        }\n\n        public static void FillWebModuleDFMTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TWebModuleDFMCommand()\n            });\n        }\n\n        public static void FillJSONRPCTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitJSONRPCDeclarationCommand()\n            });\n        }\n\n        public static void FillTemplateProTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitTemplateProHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillWebStencilsTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitWebStencilsHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillMustacheTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitMustacheHelpersDeclarationCommand()\n            });\n        }\n\n        public static void FillEntitiesTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitControllerEntityDeclarationCommand()\n            });\n        }\n\n        public static void FillServicesTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<IGenCommand>\n            {\n                new TUnitServicesDeclarationCommand()\n            });\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi Fake Data Utils\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphi_fake_data_utils\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n{$DEFINE GENERATE_DATASETS}\n\nunit RandomUtilsU;\n\ninterface\n\n{$IF Defined(GENERATE_DATASETS)}\nuses\n  Data.DB, FireDAC.Stan.Intf, FireDAC.Stan.Option,\n  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,\n  FireDAC.DApt.Intf, FireDAC.Comp.DataSet, FireDAC.Comp.Client;\n{$ENDIF}\n\nconst\n  FirstNames: array [0 .. 29] of string = (\n    'Daniele',\n    'Debora',\n    'Mattia',\n    'Jack',\n    'James',\n    'William',\n    'Joseph',\n    'David',\n    'Charles',\n    'Thomas',\n    'Ethan',\n    'Liam',\n    'Noah',\n    'Logan',\n    'Lucas',\n    'Mason',\n    'Benjamin',\n    'Alexander',\n    'Elijah',\n    'Jordan',\n    'Alexander',\n    'Jamie',\n    'Tyler',\n    'Caleb',\n    'Kieran',\n    'Ryan',\n    'Colton',\n    'Jaxon',\n    'Gavin',\n    'Ryder'\n    );\n\n  LastNames: array [0 .. 13] of string = (\n    'Smith',\n    'Johnson',\n    'Williams',\n    'Brown',\n    'Black',\n    'Red',\n    'Green',\n    'Willis',\n    'Jones',\n    'Miller',\n    'Davis',\n    'Wilson',\n    'Martinez',\n    'Anderson'\n    );\n\n  Countries: array [0 .. 24] of string = (\n    'italy',\n    'new york',\n    'illinois',\n    'arizona',\n    'nevada',\n    'uk',\n    'france',\n    'georgia',\n    'spain',\n    'portugal',\n    'germany',\n    'norway',\n    'california',\n    'usa',\n    'japan',\n    'australia',\n    'singapore',\n    'hong kong',\n    'taiwan',\n    'south africa',\n    'canada',\n    'switzerland',\n    'sweden',\n    'netherlands',\n    'belgium'\n  );\n\nLOREM_IPSUM =\n  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.' +\n  'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.' +\n  'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' +\n  'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';\n\n    WORDS: array [0 .. 1000] of string = ('bite', 'mate', 'quill', 'back', 'church', 'pear', 'knit', 'bent', 'wrench', 'crack', 'heavenly',\n      'deceive', 'maddening', 'plain', 'writer', 'rapid', 'acidic', 'decide', 'hat', 'paint', 'cow', 'dysfunctional', 'pet', 'giraffe',\n      'connection', 'sour', 'voracious', 'cloudy', 'wry', 'curve', 'agree', 'eggnog', 'flaky', 'painstaking', 'warm', 'silk', 'icy',\n      'hellish', 'toy', 'milky', 'skirt', 'test', 'daffy', 'questionable', 'gamy', 'aware', 'berry', 'throne', 'oven', 'subtract', 'cool',\n      'care', 'charge', 'smash', 'curve', 'comfortable', 'narrow', 'merciful', 'material', 'fear', 'exercise', 'skinny', 'fire',\n      'rainstorm', 'tail', 'nondescript', 'calculating', 'pack', 'steel', 'marvelous', 'baseball', 'furtive', 'stitch', 'abiding', 'empty',\n      'bushes', 'painful', 'tense', 'verse', 'unwritten', 'reproduce', 'receptive', 'bottle', 'silky', 'alleged', 'stingy', 'irritate',\n      'expand', 'cap', 'unsuitable', 'gigantic', 'exist', 'damp', 'scrub', 'disgusted', 'sun', 'ink', 'detailed', 'defeated', 'economic',\n      'chunky', 'stop', 'overflow', 'numerous', 'joyous', 'wipe', 'drink', 'error', 'branch', 'male', 'proud', 'soggy', 'ship', 'excite',\n      'industry', 'wistful', 'man', 'vacation', 'doctor', 'naughty', 'plane', 'ignore', 'open', 'act', 'earthquake', 'inconclusive',\n      'reflect', 'force', 'funny', 'wonder', 'magenta', 'near', 'dam', 'windy', 'maid', 'wacky', 'release', 'birthday', 'statement',\n      'psychotic', 'quicksand', 'things', 'planes', 'boundary', 'nod', 'touch', 'argue', 'sin', 'train', 'adhoc', 'needle', 'regret',\n      'stroke', 'strengthen', 'bruise', 'mine', 'rod', 'tax', 'twig', 'advise', 'stamp', 'rhyme', 'obnoxious', 'few', 'inform', 'fixed',\n      'mailbox', 'bells', 'grade', 'machine', 'yarn', 'lighten', 'tub', 'guiltless', 'hot', 'misty', 'van', 'flap', 'nosy', 'neighborly',\n      'crime', 'nifty', 'uninterested', 'noisy', 'oafish', 'squeal', 'page', 'wet', 'embarrassed', 'long-term', 'closed', 'language',\n      'argument', 'elite', 'ban', 'trip', 'tour', 'wine', 'profit', 'envious', 'love', 'back', 'bite-sized', 'magical', 'snatch', 'elated',\n      'sniff', 'far', 'shy', 'deeply', 'zoom', 'invent', 'downtown', 'heartbreaking', 'angry', 'can', 'bucket', 'important', 'fetch',\n      'shoe', 'self', 'x-ray', 'abhorrent', 'lumpy', 'fertile', 'nest', 'pick', 'history', 'offbeat', 'interrupt', 'yell', 'grain',\n      'scintillating', 'alluring', 'wren', 'form', 'attack', 'foregoing', 'suspect', 'daughter', 'moldy', 'signal', 'placid', 'quirky',\n      'itchy', 'butter', 'ordinary', 'imaginary', 'list', 'known', 'servant', 'slow', 'apparel', 'meeting', 'lovely', 'bat', 'insurance',\n      'waste', 'aromatic', 'foot', 'breakable', 'theory', 'stiff', 'cream', 'train', 'ground', 'fuel', 'wary', 'store', 'wonderful', 'corn',\n      'zippy', 'dashing', 'risk', 'prose', 'try', 'green', 'bead', 'recess', 'chop', 'stain', 'faded', 'heat', 'camera', 'panicky',\n      'depressed', 'wooden', 'clumsy', 'gullible', 'railway', 'guide', 'current', 'giants', 'enter', 'talented', 'bustling', 'square',\n      'jewel', 'bee', 'jelly', 'utopian', 'heal', 'anger', 'balance', 'tick', 'turn', 'unique', 'lively', 'wrist', 'fade', 'tender',\n      'outgoing', 'own', 'sigh', 'jobless', 'boiling', 'parallel', 'vest', 'leather', 'spark', 'suck', 'knot', 'circle', 'square', 'supply',\n      'tank', 'fax', 'spotless', 'habitual', 'feeling', 'watch', 'cattle', 'end', 'true', 'zonked', 'poison', 'man', 'pedal', 'boorish',\n      'moaning', 'mindless', 'bone', 'spot', 'chubby', 'numberless', 'eye', 'bright', 'sweet', 'fanatical', 'oranges', 'calm', 'squash',\n      'tooth', 'petite', 'design', 'one', 'bump', 'aberrant', 'mine', 'fit', 'rub', 'optimal', 'ugly', 'lyrical', 'borrow', 'queue',\n      'alert', 'normal', 'wrathful', 'truculent', 'level', 'hollow', 'disillusioned', 'kick', 'weather', 'mighty', 'upbeat', 'troubled',\n      'snotty', 'many', 'warn', 'thank', 'trains', 'plan', 'choke', 'activity', 'attend', 'walk', 'thought', 'gabby', 'actor', 'prickly',\n      'smell', 'dangerous', 'observation', 'action', 'steady', 'hypnotic', 'second-hand', 'zip', 'mundane', 'sand', 'sneaky', 'harm',\n      'pancake', 'guarantee', 'empty', 'bulb', 'burn', 'reject', 'decorate', 'obese', 'crowd', 'clap', 'flat', 'available', 'hop', 'untidy',\n      'wreck', 'fasten', 'waves', 'dinosaurs', 'dreary', 'fearful', 'answer', 'parched', 'tight', 'animated', 'desk', 'jaded', 'wax',\n      'silver', 'scream', 'puzzling', 'unbiased', 'unite', 'branch', 'quack', 'writing', 'tease', 'mint', 'full', 'plate', 'gusty', 'bear',\n      'bell', 'sparkling', 'absurd', 'past', 'earsplitting', 'seemly', 'unadvised', 'paper', 'battle', 'friend', 'control', 'rich',\n      'regret', 'used', 'scattered', 'redundant', 'slave', 'languid', 'didactic', 'fairies', 'sofa', 'spiteful', 'reply', 'division',\n      'engine', 'suppose', 'homeless', 'pinch', 'ray', 'channel', 'repeat', 'smoke', 'concentrate', 'handy', 'committee', 'songs', 'madly',\n      'itch', 'hands', 'clean', 'addition', 'majestic', 'careful', 'fallacious', 'guarded', 'last', 'time', 'tumble', 'plastic', 'force',\n      'guess', 'grape', 'loving', 'hand', 'remain', 'vigorous', 'wash', 'cars', 'same', 'provide', 'shelf', 'yam', 'onerous', 'claim',\n      'tramp', 'glistening', 'innocent', 'lock', 'close', 'absorbing', 'daily', 'amuck', 'manage', 'energetic', 'absent', 'fantastic',\n      'flippant', 'unnatural', 'amount', 'luxuriant', 'clover', 'alert', 'wheel', 'cellar', 'agonizing', 'card', 'memorise', 'meal',\n      'suspend', 'concerned', 'uneven', 'deranged', 'spiritual', 'arch', 'dare', 'hammer', 'tug', 'jump', 'vase', 'plant', 'color', 'worm',\n      'grab', 'frame', 'taste', 'incandescent', 'little', 'rule', 'confused', 'roomy', 'gorgeous', 'heat', 'whole', 'cracker', 'water',\n      'flimsy', 'high-pitched', 'grandfather', 'spooky', 'natural', 'grease', 'noiseless', 'superficial', 'gaze', 'finger', 'afford',\n      'racial', 'tiresome', 'tremendous', 'zealous', 'slip', 'position', 'mountainous', 'shelter', 'calculator', 'tacky', 'whip',\n      'mountain', 'clear', 'thin', 'smell', 'ants', 'yellow', 'cross', 'employ', 'trouble', 'dazzling', 'enchanting', 'groovy', 'measure',\n      'disapprove', 'elastic', 'sparkle', 'cub', 'foolish', 'discussion', 'stormy', 'pies', 'absorbed', 'trashy', 'mammoth', 'low',\n      'subdued', 'badge', 'letter', 'previous', 'challenge', 'tart', 'cute', 'suit', 'condition', 'pricey', 'rule', 'wrong', 'bomb', 'wiry',\n      'swim', 'crack', 'disgusting', 'gather', 'half', 'sturdy', 'probable', 'stream', 'trick', 'silly', 'sulky', 'nail', 'rotten', 'stir',\n      'sneeze', 'even', 'adamant', 'cluttered', 'object', 'battle', 'petite', 'wait', 'instinctive', 'donkey', 'squeamish', 'rainy',\n      'craven', 'acceptable', 'husky', 'pollution', 'judicious', 'distribution', 'neck', 'left', 'collect', 'thankful', 'describe',\n      'complex', 'transport', 'horses', 'hope', 'chemical', 'dress', 'idea', 'extend', 'laugh', 'event', 'route', 'hose', 'abundant',\n      'insect', 'spectacular', 'whistle', 'home', 'vast', 'massive', 'grey', 'sail', 'lavish', 'word', 'coach', 'repair', 'squeak',\n      'curious', 'beam', 'middle', 'obscene', 'efficacious', 'supreme', 'torpid', 'jazzy', 'linen', 'cause', 'synonymous', 'book', 'brave',\n      'staking', 'weak', 'show', 'birds', 'barbarous', 'hilarious', 'injure', 'walk', 'screeching', 'frequent', 'wide', 'kiss', 'lonely',\n      'quarrelsome', 'arm', 'flowers', 'surround', 'level', 'enjoy', 'calculate', 'reach', 'brother', 'grandiose', 'clammy', 'thunder',\n      'pen', 'rake', 'whirl', 'sharp', 'fence', 'scissors', 'polish', 'recondite', 'brief', 'pig', 'ten', 'spell', 'coal', 'sidewalk',\n      'straight', 'melted', 'ring', 'deadpan', 'nine', 'wound', 'use', 'switch', 'watch', 'meat', 'governor', 'lively', 'neat', 'dapper',\n      'gate', 'rose', 'wealthy', 'psychedelic', 'slap', 'note', 'request', 'match', 'abashed', 'snail', 'tray', 'pump', 'disappear',\n      'vegetable', 'wool', 'abstracted', 'impulse', 'fork', 'brake', 'shiny', 'team', 'coherent', 'dust', 'relieved', 'long', 'broad',\n      'shop', 'innate', 'milk', 'mother', 'screw', 'cushion', 'listen', 'spot', 'willing', 'legs', 'clever', 'obsolete', 'coil', 'smoke',\n      'call', 'men', 'purpose', 'bumpy', 'receipt', 'soothe', 'thinkable', 'launch', 'kittens', 'oceanic', 'dolls', 'jagged', 'fine',\n      'start', 'muddled', 'want', 'develop', 'skillful', 'real', 'sisters', 'cooperative', 'retire', 'scarecrow', 'caring', 'chance',\n      'search', 'visitor', 'stem', 'rabid', 'seed', 'endurable', 'cloistered', 'knife', 'cast', 'trouble', 'cold', 'brainy', 'admit',\n      'base', 'multiply', 'escape', 'bike', 'frighten', 'large', 'pull', 'observant', 'stereotyped', 'dirty', 'tin', 'vague', 'celery',\n      'hungry', 'best', 'difficult', 'burly', 'horse', 'flawless', 'fresh', 'inquisitive', 'illegal', 'omniscient', 'simplistic', 'selfish',\n      'clean', 'hospital', 'encouraging', 'incompetent', 'right', 'learn', 'relation', 'spoil', 'amused', 'ruthless', 'squalid',\n      'aftermath', 'increase', 'greasy', 'futuristic', 'shut', 'friendly', 'steep', 'range', 'faint', 'jail', 'wide-eyed', 'uptight',\n      'erratic', 'eyes', 'cure', 'overwrought', 'muddle', 'bedroom', 'scale', 'rub', 'conscious', 'snake', 'box', 'command', 'slippery',\n      'handsome', 'spy', 'tongue', 'unbecoming', 'magnificent', 'gold', 'resolute', 'face', 'childlike', 'approval', 'meaty', 'frog',\n      'abrasive', 'rat', 'peel', 'office', 'panoramic', 'explode', 'selective', 'ahead', 'thaw', 'mean', 'odd', 'hate', 'window', 'somber',\n      'guard', 'riddle', 'judge', 'flock', 'black', 'amusement', 'bikes', 'milk', 'sock', 'historical', 'tawdry', 'bare', 'mitten', 'harsh',\n      'street', 'unequal', 'five', 'zinc', 'faulty', 'messy', 'thoughtful', 'spicy', 'oval', 'telephone', 'decisive', 'teeny', 'fix',\n      'outstanding', 'excuse', 'abject', 'print', 'receive', 'jump', 'knock', 'ubiquitous', 'anxious', 'fill', 'shrug', 'ossified',\n      'penitent', 'dry', 'abaft', 'uncle', 'voiceless', 'spray', 'town', 'aspiring', 'testy', 'bed', 'likeable', 'breezy', 'jumpy', 'talk',\n      'powerful', 'various', 'crawl', 'lacking', 'lethal', 'baby', 'sore', 'mourn', 'behave', 'pass', 'mark', 'summer', 'cause',\n      'destruction', 'stale', 'basin', 'embarrass', 'rob', 'income', 'overjoyed', 'aback', 'spark', 'air', 'worthless', 'hospitable',\n      'dynamic', 'push', 'nervous', 'dark', 'chin', 'shock', 'frame', 'dojo');\n\nfunction GetRndFirstName: String;\nfunction GetRndLastName: String;\nfunction GetRndFullName: String;\nfunction GetRndCountry: String;\nfunction GetRndEMailAddress: String;\nfunction GetRndDate(const InitialYear: Word = 1980; YearsSpan: Word = 40): TDate;\nfunction GetRndInteger(const aFrom: Integer = 0; aTo: Integer = 1000): Integer;\nfunction GetRndWord: String;\nfunction GetRndPhrase(const aFrom: Integer = 0; aTo: Integer = 1000): String;\n\n{$IF Defined(GENERATE_DATASETS)}\nfunction GetPeople(const Count: Integer = 20): TDataSet;\nfunction GetUsers(const Count: Integer = 10): TDataSet;\nfunction GetPosts(const Count: Integer = 10): TDataSet;\n{$ENDIF}\n\nimplementation\n\n\nuses\n  System.SysUtils, System.DateUtils, System.Math;\n\nconst\n  OneDay = OneHour * 24;\n\nfunction GetRndDate(const InitialYear: Word; YearsSpan: Word): TDate;\nbegin\n  Result := EncodeDate(InitialYear + Random(YearsSpan),1,1) + (OneDay * Random(365));\nend;\n\nfunction GetRndEMailAddress: String;\nbegin\n  Result := GetRndFirstName.Substring(0, RandomRange(1,3)) + '.' +\n    GetRndLastName + '@' + GetRndCountry + GetRndInteger(1,3).ToString + '.com';\n  Result := Result.Replace(' ', '_', [rfReplaceAll]);\nend;\n\nfunction GetRndCountry: String;\nbegin\n  Result := Countries[Random(High(Countries)+1)];\nend;\n\nfunction GetRndFirstName: String;\nbegin\n  Result := FirstNames[Random(High(FirstNames)+1)];\nend;\n\nfunction GetRndFullName: String;\nbegin\n  Result := GetRndFirstName + ' ' + GetRndLastName;\nend;\n\nfunction GetRndLastName: String;\nbegin\n  Result := LastNames[Random(High(LastNames)+1)];\nend;\n\nfunction GetRndWord: String;\nbegin\n  Result := WORDS[RandomRange(0, Length(WORDS))];\nend;\n\nfunction GetRndPhrase(const aFrom: Integer = 0; aTo: Integer = 1000): String;\nvar\n  WordCount: Integer;\n  I: Integer;\nbegin\n  Result := '';\n  WordCount := RandomRange(aFrom, aTo);\n  for I := 1 to WordCount do\n  begin\n    Result := Result + GetRndWord + ' ';\n  end;\n  Result := Result.Trim;\n  Result := UpCase(Result.Chars[0]) + Result.Substring(1) + '.';\nend;\n\nfunction GetRndInteger(const aFrom: Integer; aTo: Integer): Integer;\nbegin\n  if aFrom >= aTo then\n  begin\n    raise Exception.Create('FROM cannot be greater nor equal to TO');\n  end;\n  Result := RandomRange(aFrom, aTo);\nend;\n\n\n{$IF Defined(GENERATE_DATASETS)}\nfunction GetPeople(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('code', ftInteger);\n    lMT.FieldDefs.Add('first_name', ftString, 20);\n    lMT.FieldDefs.Add('last_name', ftString, 20);\n    lMT.FieldDefs.Add('country', ftString, 20);\n    lMT.FieldDefs.Add('dob', ftDate);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([I, GetRndFirstName, GetRndLastName, GetRndCountry, GetRndDate]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction GetUsers(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('first_name', ftString, 100);\n    lMT.FieldDefs.Add('last_name', ftString, 100);\n    lMT.FieldDefs.Add('email', ftString, 100);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([GetRndFirstName, GetRndLastName, GetRndEMailAddress]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction GetPosts(const Count: Integer): TDataSet;\nvar\n  lMT: TFDMemTable;\n  I: Integer;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('title', ftString, 100);\n    lMT.FieldDefs.Add('abstract', ftString, 400);\n    lMT.FieldDefs.Add('word_count', ftInteger);\n    lMT.FieldDefs.Add('comments', ftInteger);\n    lMT.FieldDefs.Add('post_date', ftDate);\n    lMT.Active := True;\n    for I := 1 to Count do\n    begin\n      lMT.AppendRecord([\n        GetRndPhrase(3, 8),\n        GetRndPhrase(30, 50),\n        GetRndInteger(20, 5000),\n        GetRndInteger(0,20),\n        GetRndDate(2020, 4)\n        ]);\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\n\n{$ENDIF}\n\ninitialization\n\nRandomize;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nnamespace RandomUtilsU\n{\n    public static class RandomUtils\n    {\n        private static readonly Random _random = new Random();\n\n        public static readonly string[] FirstNames = new string[]\n        {\n            \"Daniele\", \"Debora\", \"Mattia\", \"Jack\", \"James\", \"William\", \"Joseph\", \"David\", \"Charles\", \"Thomas\",\n            \"Ethan\", \"Liam\", \"Noah\", \"Logan\", \"Lucas\", \"Mason\", \"Benjamin\", \"Alexander\", \"Elijah\", \"Jordan\",\n            \"Alexander\", \"Jamie\", \"Tyler\", \"Caleb\", \"Kieran\", \"Ryan\", \"Colton\", \"Jaxon\", \"Gavin\", \"Ryder\"\n        };\n\n        public static readonly string[] LastNames = new string[]\n        {\n            \"Smith\", \"Johnson\", \"Williams\", \"Brown\", \"Black\", \"Red\", \"Green\", \"Willis\", \"Jones\", \"Miller\",\n            \"Davis\", \"Wilson\", \"Martinez\", \"Anderson\"\n        };\n\n        public static readonly string[] Countries = new string[]\n        {\n            \"italy\", \"new york\", \"illinois\", \"arizona\", \"nevada\", \"uk\", \"france\", \"georgia\", \"spain\", \"portugal\",\n            \"germany\", \"norway\", \"california\", \"usa\", \"japan\", \"australia\", \"singapore\", \"hong kong\", \"taiwan\",\n            \"south africa\", \"canada\", \"switzerland\", \"sweden\", \"netherlands\", \"belgium\"\n        };\n\n        public const string LOREM_IPSUM =\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\" +\n            \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\" +\n            \"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\" +\n            \"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n\n        public static readonly string[] WORDS = new string[]\n        {\n            \"bite\", \"mate\", \"quill\", \"back\", \"church\", \"pear\", \"knit\", \"bent\", \"wrench\", \"crack\", \"heavenly\",\n            \"deceive\", \"maddening\", \"plain\", \"writer\", \"rapid\", \"acidic\", \"decide\", \"hat\", \"paint\", \"cow\",\n            \"dysfunctional\", \"pet\", \"giraffe\", \"connection\", \"sour\", \"voracious\", \"cloudy\", \"wry\", \"curve\",\n            \"agree\", \"eggnog\", \"flaky\", \"painstaking\", \"warm\", \"silk\", \"icy\", \"hellish\", \"toy\", \"milky\",\n            \"skirt\", \"test\", \"daffy\", \"questionable\", \"gamy\", \"aware\", \"berry\", \"throne\", \"oven\", \"subtract\",\n            \"cool\", \"care\", \"charge\", \"smash\", \"curve\", \"comfortable\", \"narrow\", \"merciful\", \"material\", \"fear\",\n            \"exercise\", \"skinny\", \"fire\", \"rainstorm\", \"tail\", \"nondescript\", \"calculating\", \"pack\", \"steel\",\n            \"marvelous\", \"baseball\", \"furtive\", \"stitch\", \"abiding\", \"empty\", \"bushes\", \"painful\", \"tense\",\n            \"verse\", \"unwritten\", \"reproduce\", \"receptive\", \"bottle\", \"silky\", \"alleged\", \"stingy\", \"irritate\",\n            \"expand\", \"cap\", \"unsuitable\", \"gigantic\", \"exist\", \"damp\", \"scrub\", \"disgusted\", \"sun\", \"ink\",\n            \"detailed\", \"defeated\", \"economic\", \"chunky\", \"stop\", \"overflow\", \"numerous\", \"joyous\", \"wipe\",\n            \"drink\", \"error\", \"branch\", \"male\", \"proud\", \"soggy\", \"ship\", \"excite\", \"industry\", \"wistful\",\n            \"man\", \"vacation\", \"doctor\", \"naughty\", \"plane\", \"ignore\", \"open\", \"act\", \"earthquake\", \"inconclusive\",\n            \"reflect\", \"force\", \"funny\", \"wonder\", \"magenta\", \"near\", \"dam\", \"windy\", \"maid\", \"wacky\", \"release\",\n            \"birthday\", \"statement\", \"psychotic\", \"quicksand\", \"things\", \"planes\", \"boundary\", \"nod\", \"touch\",\n            \"argue\", \"sin\", \"train\", \"adhoc\", \"needle\", \"regret\", \"stroke\", \"strengthen\", \"bruise\", \"mine\",\n            \"rod\", \"tax\", \"twig\", \"advise\", \"stamp\", \"rhyme\", \"obnoxious\", \"few\", \"inform\", \"fixed\"\n        };\n\n        public static string GetRndFirstName()\n        {\n            return FirstNames[_random.Next(FirstNames.Length)];\n        }\n\n        public static string GetRndLastName()\n        {\n            return LastNames[_random.Next(LastNames.Length)];\n        }\n\n        public static string GetRndFullName()\n        {\n            return GetRndFirstName() + \" \" + GetRndLastName();\n        }\n\n        public static string GetRndCountry()\n        {\n            return Countries[_random.Next(Countries.Length)];\n        }\n\n        public static string GetRndEMailAddress()\n        {\n            string first = GetRndFirstName();\n            int len = Math.Min(first.Length, _random.Next(1, 3));\n            first = first.Substring(0, len);\n            string last = GetRndLastName();\n            string domain = GetRndCountry() + _random.Next(1, 4).ToString() + \".com\";\n            return (first + \".\" + last + \"@\" + domain).Replace(\" \", \"_\");\n        }\n\n        public static DateTime GetRndDate(ushort initialYear = 1980, ushort yearsSpan = 40)\n        {\n            int year = initialYear + _random.Next(yearsSpan);\n            int dayOfYear = _random.Next(1, 366);\n            return new DateTime(year, 1, 1).AddDays(dayOfYear - 1);\n        }\n\n        public static int GetRndInteger(int aFrom = 0, int aTo = 1000)\n        {\n            if (aFrom >= aTo)\n            {\n                throw new Exception(\"FROM cannot be greater nor equal to TO\");\n            }\n            return _random.Next(aFrom, aTo);\n        }\n\n        public static string GetRndWord()\n        {\n            return WORDS[_random.Next(WORDS.Length)];\n        }\n\n        public static string GetRndPhrase(int aFrom = 0, int aTo = 1000)\n        {\n            int wordCount = _random.Next(aFrom, aTo);\n            var words = new List<string>();\n            for (int i = 0; i < wordCount; i++)\n            {\n                words.Add(GetRndWord());\n            }\n            string phrase = string.Join(\" \", words).Trim();\n            if (phrase.Length > 0)\n            {\n                phrase = char.ToUpper(phrase[0]) + phrase.Substring(1) + \".\";\n            }\n            return phrase;\n        }\n\n#if GENERATE_DATASETS\n        public static DataTable GetPeople(int count = 20)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"code\", typeof(int));\n            dt.Columns.Add(\"first_name\", typeof(string));\n            dt.Columns.Add(\"last_name\", typeof(string));\n            dt.Columns.Add(\"country\", typeof(string));\n            dt.Columns.Add(\"dob\", typeof(DateTime));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(i, GetRndFirstName(), GetRndLastName(), GetRndCountry(), GetRndDate());\n            }\n            return dt;\n        }\n\n        public static DataTable GetUsers(int count = 10)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"first_name\", typeof(string));\n            dt.Columns.Add(\"last_name\", typeof(string));\n            dt.Columns.Add(\"email\", typeof(string));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(GetRndFirstName(), GetRndLastName(), GetRndEMailAddress());\n            }\n            return dt;\n        }\n\n        public static DataTable GetPosts(int count = 10)\n        {\n            DataTable dt = new DataTable();\n            dt.Columns.Add(\"title\", typeof(string));\n            dt.Columns.Add(\"abstract\", typeof(string));\n            dt.Columns.Add(\"word_count\", typeof(int));\n            dt.Columns.Add(\"comments\", typeof(int));\n            dt.Columns.Add(\"post_date\", typeof(DateTime));\n            for (int i = 1; i <= count; i++)\n            {\n                dt.Rows.Add(\n                    GetRndPhrase(3, 8),\n                    GetRndPhrase(30, 50),\n                    GetRndInteger(20, 5000),\n                    GetRndInteger(0, 20),\n                    GetRndDate(2020, 4)\n                );\n            }\n            return dt;\n        }\n#endif\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ActiveRecord;\n\n{$I dmvcframework.inc}\n\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Generics.Defaults,\n  System.Generics.Collections,\n  System.RTTI,\n  FireDAC.DApt,\n  Data.DB,\n  FireDAC.Comp.Client,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Stan.Param,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.RQL.Parser,\n  MVCFramework.Cache,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  System.SyncObjs,\n  System.TypInfo;\n\ntype\n  EMVCActiveRecord = class(EMVCException)\n  public\n    constructor Create(const AMsg: string); reintroduce; { do not override!! }\n  end;\n\n  EMVCActiveRecordNotFound = class(EMVCActiveRecord)\n  public\n    procedure AfterConstruction; override;\n  end;\n\n  EMVCActiveRecordValidationError = class(EMVCActiveRecord)\n  private\n    fPropertyName: String;\n  public\n    procedure AfterConstruction; override;\n    constructor Create(const PropertyName: String; const ValidationError: string);\n    property PropertyName: String read fPropertyName;\n  end;\n\n  EMVCActiveRecordVersionedItemNotFound = class(EMVCActiveRecordNotFound)\n  end;\n\n  EMVCActiveRecordTransactionContext = class(EMVCActiveRecord)\n  end;\n\n\n  TMVCActiveRecordClass = class of TMVCActiveRecord;\n  TMVCActiveRecord = class;\n\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\n  TMVCTransactionContext = record\n  private\n    fConnection: TFDConnection;\n  public\n    class operator Finalize(var Dest: TMVCTransactionContext);\n    class operator Assign (var Dest: TMVCTransactionContext; const [ref] Src: TMVCTransactionContext);\n    constructor Create(Dummy: Integer); overload;\n  end;\n{$ENDIF}\n\n  TMVCActiveRecordFieldOption = (\n    /// <summary>\n    /// It's the primary key of the mapped table }\n    /// </summary>\n    foPrimaryKey,\n    /// <summary>\n    /// Not written, read - similar to readonly - is updated after insert and update\n    /// </summary>\n    foAutoGenerated,\n    /// <summary>\n    /// shortcut for --> Insertable := False; Updatable := False; Selectable := True;\n    /// </summary>\n    foReadOnly,\n    /// <summary>\n    /// used for versioning, only one field with foVersion is allowed in class\n    /// </summary>\n    foVersion,\n    /// <summary>\n    /// not included in SQL SELECT commands\n    /// </summary>\n    foDoNotSelect,\n    /// <summary>\n    /// not included in SQL INSERT commands\n    /// </summary>\n    foDoNotInsert,\n    /// <summary>\n    /// not included in SQL UPDATE commands\n    /// </summary>\n    foDoNotUpdate\n  );\n\n\n\n\n  TMVCActiveRecordFieldOptions = set of TMVCActiveRecordFieldOption;\n  TMVCEntityAction = (eaCreate, eaRetrieve, eaUpdate, eaDelete);\n  TMVCEntityActions = set of TMVCEntityAction;\n  TMVCActiveRecordLoadOption = (loIgnoreNotExistentFields);\n  TMVCActiveRecordLoadOptions = set of TMVCActiveRecordLoadOption;\n\n  TPartitionFieldNames = class(TList<String>)\n  end;\n\n  TPartitionFieldValues = class(TList<String>)\n  end;\n\n  TPartitionFieldTypes = class(TList<TFieldType>)\n  end;\n\n  IMVCEntityProcessor = interface\n    ['{E7CD11E6-9FF9-46D2-B7B0-DA5B38EAA14E}']\n    procedure GetEntities(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n    procedure CreateEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext; const Renderer: TMVCRenderer; const entityname: string;\n      const id: Integer; var Handled: Boolean);\n  end;\n\n  TFieldInfo = class\n  public\n    FieldName: string;\n    FieldOptions: TMVCActiveRecordFieldOptions;\n    DataTypeName: string;\n    Selectable, Insertable, Updatable, IsVersion: Boolean;\n    procedure EndUpdates;\n  end;\n\n  TSQLQueryWithName = record\n    Name: String;\n    SQLText: String;\n    BackEnd: String; //TMVCActiveRecordBackEnd\n  end;\n\n  TRQLQueryWithName = record\n    Name: String;\n    RQLText: String;\n  end;\n\n\n  TFieldsMap = class(TObjectDictionary<TRTTIField, TFieldInfo>)\n  private\n    fWritableFieldsCount: Integer;\n    fReadableFieldsCount: Integer;\n  public\n    constructor Create;\n    procedure EndUpdates;\n    property WritableFieldsCount: Integer read fWritableFieldsCount;\n    property ReadableFieldsCount: Integer read fReadableFieldsCount;\n    function GetInfoByFieldName(const FieldName: string): TFieldInfo;\n  end;\n\n  MVCActiveRecordCustomAttribute = class(TCustomAttribute)\n\n  end;\n\n  MVCTableAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    RQLFilter: string;\n    constructor Create(aName: string); overload;\n    constructor Create(aName: string; aRQLFilter: String); overload;\n  end;\n\n  MVCPartitionAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    PartitionClause: String;\n    constructor Create(const PartitionClause: String);\n  end;\n\n  MVCNamedSQLQueryAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    SQLQuery: String;\n    Backend: String; //TMVCActiveRecordBackEnd\n    constructor Create(aName: string; aSQLSelect: String); overload;\n    constructor Create(aName: string; aSQLSelect: String; aBackEnd: String); overload;\n  end;\n\n  MVCNamedRQLQueryAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    Name: string;\n    RQLQuery: String;\n    constructor Create(aName: string; aRQL: String);\n  end;\n\n  MVCTableFieldAttribute = class(MVCActiveRecordCustomAttribute)\n  public\n    FieldName: string;\n    FieldOptions: TMVCActiveRecordFieldOptions;\n    SequenceName, DataTypeName: string;\n    constructor Create(const aFieldName: string; const aFieldOptions: TMVCActiveRecordFieldOptions;\n      const aSequenceName: string = ''; const aDataTypeName: string = ''); overload;\n    constructor Create(aFieldName: string; const aDataTypeName: string = ''); overload;\n  end;\n\n  MVCPrimaryKeyAttribute = MVCTableFieldAttribute deprecated '(ERROR) Use MVCTableFieldAttribute';\n\n  MVCEntityActionsAttribute = class(MVCActiveRecordCustomAttribute)\n  private\n    EntityAllowedActions: TMVCEntityActions;\n  public\n    constructor Create(const aEntityAllowedActions: TMVCEntityActions);\n\n  end;\n\n  TMVCSQLGenerator = class;\n\n  TPartitionInfo = class\n  private\n    class\n      var PartitionInfoCache: TMVCThreadedObjectCache<TPartitionInfo>;\n  private\n    fRQLFilter: String;\n    fSQLFilter: String;\n    fFieldValues: TPartitionFieldValues;\n    fFieldTypes: TPartitionFieldTypes;\n    fFieldNames: TPartitionFieldNames;\n  public\n    property FieldNames: TPartitionFieldNames read fFieldNames;\n    property FieldValues: TPartitionFieldValues read fFieldValues;\n    property FieldTypes: TPartitionFieldTypes read fFieldTypes;\n    property RQLFilter: String read fRQLFilter;\n    property SQLFilter: String read fSQLFilter;\n    constructor Create;\n    destructor Destroy; override;\n    class constructor Create;\n    class destructor Destroy;\n    procedure InitializeFilterStrings(const RQLCompiler: TRQLCompiler);\n    class function BuildPartitionClause(const PartitionClause: String; const RQLCompilerClass: TRQLCompilerClass): TPartitionInfo;\n  end;\n\n  TMVCActiveRecordList = class(TObjectList<TMVCActiveRecord>)\n  public\n    constructor Create; virtual;\n  end;\n\n  TMVCTableMap = class\n  private\n    fVersionRTTIField: TRttiField;\n    fVersionFieldName: String;\n  public\n    fPartitionInfoInternal: TPartitionInfo;\n    fEntityAllowedActions: TMVCEntityActions;\n    fTableName: String;\n    fIsVersioned: Boolean;\n    fPartitionClause: String;\n    fRTTIType: TRttiInstanceType;\n    fObjAttributes: TArray<TCustomAttribute>;\n    fDefaultRQLFilter: string;\n    fMap: TFieldsMap;\n    fPrimaryKey: TRTTIField;\n    fPrimaryKeyInInsert: Boolean;\n    fMapping: TMVCFieldsMapping;\n    fPropsAttributes: TArray<TCustomAttribute>;\n    fProps: TArray<TRTTIField>;\n    fPrimaryKeyFieldName: string;\n    fPrimaryKeyOptions: TMVCActiveRecordFieldOptions;\n    fPrimaryKeySequenceName: string;\n    fPrimaryKeyFieldType: TFieldType;\n    fNamedSQLQueries: TArray<TSQLQueryWithName>;\n    fNamedRQLQueries: TArray<TRQLQueryWithName>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    function VersionValueAsInt64For(AR: TMVCActiveRecord): Int64; //inline;\n  end;\n\n  TMVCActiveRecord = class\n  private\n    fChildren: TObjectList<TObject>;\n    fConn: TFDConnection;\n    fSQLGenerator: TMVCSQLGenerator;\n    fRQL2SQL: TRQL2SQL;\n    function MapNullableTValueToParam(aValue: TValue; const aParam: TFDParam): Boolean;\n    function GetPrimaryKeyIsAutogenerated: Boolean;\n    procedure SetPrimaryKeyIsAutogenerated(const Value: Boolean);\n    function GetAttributes(const AttrName: string): TValue;\n    procedure SetAttributes(const AttrName: string; const Value: TValue);\n    function GetTableName: string;\n    procedure AdvanceVersioning(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord);\n    procedure SetInitialObjVersion(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord);\n  protected\n    fBackendDriver: string;\n    fTableMap: TMVCTableMap;\n    function GetCustomTableName: String; virtual;\n    function GetPartitionInfo: TPartitionInfo;\n    function GetConnection: TFDConnection;\n    procedure MapTValueToParam(aValue: TValue; const aParam: TFDParam); virtual;\n    procedure InitTableInfo(const aTableName: String);\n    class function\n      CreateQuery(const Unidirectional, DirectExecute: Boolean): TFDQuery;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean): TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const Connection: TFDConnection;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean)\n      : TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const ValueTypes: array of TFieldType;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean)\n      : TDataSet; overload;\n    class function ExecQuery(\n      const SQL: string;\n      const Values: array of Variant;\n      const ValueTypes: array of TFieldType;\n      const Connection: TFDConnection;\n      const Unidirectional: Boolean;\n      const DirectExecute: Boolean): TDataSet; overload;\n    procedure FillPrimaryKey(const SequenceName: string);\n    function ExecNonQuery(const SQL: string; RefreshAutoGenerated: Boolean = false): Int64;\n      overload;\n    class function GetByPK(aActiveRecord: TMVCActiveRecord; const aValue: string; const aFieldType: TFieldType;\n      const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord; overload;\n\n\n    // load events\n    /// <summary>\n    /// Called everywhere before persist object into database\n    /// </summary>\n    procedure OnValidation(const EntityAction: TMVCEntityAction); virtual;\n\n    /// <summary>\n    /// Called just after load the object state from database\n    /// </summary>\n    procedure OnAfterLoad; virtual;\n\n    /// <summary>\n    /// Called before load the object state from database\n    /// </summary>\n    procedure OnBeforeLoad; virtual;\n\n    /// <summary>\n    /// Called before insert the object state to database\n    /// </summary>\n    procedure OnBeforeInsert; virtual;\n\n    /// <summary>\n    /// Called after insert the object state to database\n    /// </summary>\n    procedure OnAfterInsert; virtual;\n\n    /// <summary>\n    /// Called before update the object state to database\n    /// </summary>\n    procedure OnBeforeUpdate; virtual;\n\n    /// <summary>\n    /// Called after update the object state to database\n    /// </summary>\n    procedure OnAfterUpdate; virtual;\n\n    /// <summary>\n    /// Called before delete object from database\n    /// </summary>\n    procedure OnBeforeDelete; virtual;\n\n    /// <summary>\n    /// Called after delete object from database\n    /// </summary>\n    procedure OnAfterDelete; virtual;\n\n    /// <summary>\n    /// Called before insert or update the object to the database\n    /// </summary>\n    procedure OnBeforeInsertOrUpdate; virtual;\n\n    /// <summary>\n    /// Called before execute sql\n    /// </summary>\n    procedure OnBeforeExecuteSQL(var SQL: string); virtual;\n\n    /// <summary>\n    /// Called after insert or update the object to the database\n    /// </summary>\n    procedure OnAfterInsertOrUpdate; virtual;\n\n    procedure MapObjectToParams(const Params: TFDParams; var Handled: Boolean); virtual;\n    procedure MapDatasetToObject(const DataSet: TDataSet; const Options: TMVCActiveRecordLoadOptions;\n      var Handled: Boolean); virtual;\n\n    function GenerateSelectSQL: string;\n\n    function SQLGenerator: TMVCSQLGenerator;\n    function InternalCount(const RQL: string): Int64;\n    function InternalSelectRQL(const RQL: string; const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    function InternalSelectRQL(const RQL: string; const MaxRecordCount: Integer;\n      const OutList: TMVCActiveRecordList): UInt32; overload;\n  public\n    constructor Create(aLazyLoadConnection: Boolean); overload; // cannot be virtual!\n    constructor Create; overload; virtual;\n    constructor Create(const Connection: TFDConnection); overload; virtual;\n    destructor Destroy; override;\n    procedure EnsureConnection;\n    procedure Assign(ActiveRecord: TMVCActiveRecord); virtual;\n    procedure InvalidateConnection(const ReacquireAfterInvalidate: Boolean = false);\n    function GetBackEnd: string;\n    /// <summary>\n    /// Executes an Insert (pk is null) or an Update (pk is not null)\n    /// </summary>\n    procedure Store;\n    /// <summary>\n    ///   Reload the current instance from database if the primary key is not empty.\n    /// </summary>\n    procedure Refresh; virtual;\n    function CheckAction(const aEntityAction: TMVCEntityAction;\n      const aRaiseException: Boolean = True): Boolean;\n    procedure Insert;\n    function GetMapping: TMVCFieldsMapping;\n    function LoadByPK(const id: Int64): Boolean; overload; virtual;\n    function LoadByPK(const id: string): Boolean; overload; virtual;\n    function LoadByPK(const id: TGuid): Boolean; overload; virtual;\n    function LoadByPK(const id: string; const aFieldType: TFieldType): Boolean; overload; virtual;\n    procedure Update(const RaiseExceptionIfNotFound: Boolean = True);\n    procedure Delete(const RaiseExceptionIfNotFound: Boolean = True);\n    function TableInfo: string;\n    procedure LoadByDataset(const aDataSet: TDataSet;\n      const aOptions: TMVCActiveRecordLoadOptions = []);\n    procedure SetPK(const aValue: TValue);\n    procedure SetPropertyValue(const aProp: TRttiProperty; const aValue: TValue);\n    function GetPK: TValue;\n    function TryGetPKValue(var Value: TValue; out IsNullableType: Boolean): Boolean;\n    function PKIsNullable(out PKValue: TValue): Boolean;\n    function PKIsNull: Boolean;\n    procedure AddChildren(const ChildObject: TObject);\n    procedure RemoveChildren(const ChildObject: TObject);\n    function GetPrimaryKeyFieldType: TFieldType;\n\n    function FindSQLQueryByName(const QueryName: String; out NamedSQLQuery: TSQLQueryWithName): Boolean;\n    function FindRQLQueryByName(const QueryName: String; out NamedRQLQuery: TRQLQueryWithName): Boolean;\n\n    property Attributes[const AttrName: string]: TValue\n      read GetAttributes\n      write SetAttributes;\n\n    [MVCDoNotSerialize]\n    property TableName: string\n      read GetTableName;\n\n    [MVCDoNotSerialize]\n    property PrimaryKeyIsAutogenerated: Boolean\n      read GetPrimaryKeyIsAutogenerated\n      write SetPrimaryKeyIsAutogenerated;\n\n    class function GetScalar(const SQL: string; const Params: array of Variant): Variant;\n    class function CurrentConnection: TFDConnection;\n    class function GetConnectionByName(const ConnectionName: String): TFDConnection;\n  end;\n\n  IMVCUnitOfWork<T: TMVCActiveRecord> = interface\n    ['{68B55DD3-57F6-4CC0-A4DE-BFDE7C3AA287}']\n    procedure RegisterDelete(const Value: T); overload;\n    procedure RegisterDelete(const Enumerable: TEnumerable<T>); overload;\n    procedure RegisterUpdate(const Value: T);\n    procedure RegisterInsert(const Value: T);\n    procedure UnregisterDelete(const Value: T);\n    procedure UnregisterUpdate(const Value: T);\n    procedure UnregisterInsert(const Value: T);\n  end;\n\n  TMVCItemApplyAction<T: TMVCActiveRecord> = reference to procedure(const Obj: T;\n    const EntityAction: TMVCEntityAction; var Handled: Boolean);\n\n  TMergeModeItem = (mmInsert, mmUpdate, mmDelete);\n  TMergeMode = set of TMergeModeItem;\n\n  IMVCMultiExecutor<T: TMVCActiveRecord> = interface\n    ['{C815246B-19CA-4F6C-AA67-8E491F809340}']\n    procedure Apply(const ItemApplyAction: TMVCItemApplyAction<T> = nil);\n  end;\n\n  TMVCActiveRecordHelper = class helper for TMVCActiveRecord\n    { GetByPK }\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: Int64;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: string;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK(const aClass: TMVCActiveRecordClass; const aValue: TGuid;\n      const RaiseExceptionIfNotFound: Boolean = True): TMVCActiveRecord; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: string; const aFieldType: TFieldType;\n      const RaiseExceptionIfNotFound: Boolean): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: Int64;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: string;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetByPK<T: TMVCActiveRecord, constructor>(const aValue: TGuid;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n\n    { Select }\n    /// <summary>\n    ///   Returns a TObjectList<TMVCActiveRecord> from a SQL using variant params\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const Options: TMVCActiveRecordLoadOptions = []): TObjectList<T>; overload;\n    /// <summary>\n    ///   Returns a TObjectList<TMVCActiveRecord> from a SQL using typed params\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = [])\n      : TObjectList<T>; overload;\n    /// <summary>\n    ///   Returns a TMVCActiveRecordList from a SQL using typed params and class ref\n    /// </summary>\n    class function Select(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = [])\n      : TMVCActiveRecordList; overload;\n    /// <summary>\n    ///   Fills a TObjectList<TMVCActiveRecord> from a SQL using typed params.\n    ///   Returns number of the records in the list (not only the selected records, but the current .Count of the list)\n    /// </summary>\n    class function Select<T: TMVCActiveRecord, constructor>(\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions;\n      const OutList: TObjectList<T>): UInt32; overload;\n\n    class function Select(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions;\n      const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant)\n      : TMVCActiveRecordList; overload;\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection): TMVCActiveRecordList; overload;\n    class function Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection; const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    { SelectOne }\n    class function SelectOne<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType; const Options: TMVCActiveRecordLoadOptions = [];\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function SelectOne<T: TMVCActiveRecord, constructor>(const SQL: string;\n      const Params: array of Variant;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n\n\n    { SelectRQL }\n    function SelectRQL(const RQL: string; const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    class function SelectRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const MaxRecordCount: Integer)\n      : TObjectList<T>; overload;\n    class function SelectRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const MaxRecordCount: Integer; const OutList: TObjectList<T>): UInt32; overload;\n    class function SelectOneByRQL<T: constructor, TMVCActiveRecord>(const RQL: string;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function SelectRQL(const aClass: TMVCActiveRecordClass; const RQL: string;\n      const MaxRecordCount: Integer)\n      : TMVCActiveRecordList; overload;\n    class function SelectRQL(const aClass: TMVCActiveRecordClass; const RQL: string;\n      const MaxRecordCount: Integer; const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    { Misc }\n    class function All<T: TMVCActiveRecord, constructor>: TObjectList<T>; overload;\n    class function DeleteRQL<T: TMVCActiveRecord>(const RQL: string = ''): Int64; overload;\n    class function Count<T: TMVCActiveRecord>(const RQL: string = ''): Int64; overload;\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\n    class function UseTransactionContext: TMVCTransactionContext;\n{$ENDIF}\n\n    { Where }\n    class function Where<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant)\n      : TObjectList<T>; overload;\n    /// <summary>\n    ///   Executes a SQL select using the SQLWhere parameter as where clause. This method is partitioning safe.\n    ///   Returns TObjectList<EntityType>.\n    /// </summary>\n    class function Where<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType): TObjectList<T>; overload;\n    class function Where<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const OutList: TObjectList<T>): UInt32; overload;\n    class function Where(\n      const aClass: TMVCActiveRecordClass;\n      const SQLWhere: string;\n      const Params: array of Variant)\n      : TMVCActiveRecordList; overload;\n    class function Where(\n      const aClass: TMVCActiveRecordClass;\n      const SQLWhere: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection): TMVCActiveRecordList; overload;\n    class function Where(\n      const aClass: TMVCActiveRecordClass;\n      const SQLWhere: string;\n      const Params: array of Variant;\n      const Connection: TFDConnection;\n      const OutList: TMVCActiveRecordList): UInt32; overload;\n\n    { GetXXXByWhere }\n    class function GetOneByWhere<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant; const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetOneByWhere<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant; const ParamTypes: array of TFieldType;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetFirstByWhere<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant; const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n    class function GetFirstByWhere<T: TMVCActiveRecord, constructor>(const SQLWhere: string;\n      const Params: array of Variant; const ParamTypes: array of TFieldType;\n      const RaiseExceptionIfNotFound: Boolean = True): T; overload;\n\n    { Merge }\n    class function Merge<T: TMVCActiveRecord>(CurrentList,\n      NewList: TObjectList<T>; const MergeMode: TMergeMode = [mmInsert, mmUpdate, mmDelete]): IMVCMultiExecutor<T>;\n\n    { Misc }\n    class function All(const aClass: TMVCActiveRecordClass): TObjectList<TMVCActiveRecord>;\n      overload;\n    class function All(const aQualifiedClassName: String): TObjectList<TMVCActiveRecord>;\n      overload;\n    class function DeleteAll(const aClass: TMVCActiveRecordClass): Int64; overload;\n    class function DeleteRQL(const aClass: TMVCActiveRecordClass; const RQL: string): Int64; overload;\n    function Count(const RQL: string = ''): Int64; overload;\n    class function Count(const aClass: TMVCActiveRecordClass; const RQL: string = '')\n      : int64; overload;\n\n    { SelectDataSet }\n    class function SelectDataSet(const SQL: string; const Params: array of Variant;\n      const Unidirectional: Boolean = False;\n      const DirectExecute: Boolean = False): TDataSet; overload;\n    class function SelectDataSet(const SQL: string; const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Unidirectional: Boolean = False;\n      const DirectExecute: Boolean = False): TDataSet; overload;\n\n    { NamedQuery}\n    class function SelectByNamedQuery<T: TMVCActiveRecord, constructor>(\n      const QueryName: String;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = []): TObjectList<T>; overload;\n    class function SelectByNamedQuery(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const QueryName: String;\n      const Params: array of Variant;\n      const ParamTypes: array of TFieldType;\n      const Options: TMVCActiveRecordLoadOptions = []): TMVCActiveRecordList; overload;\n    class function SelectRQLByNamedQuery<T: constructor, TMVCActiveRecord>(\n      const QueryName: String;\n      const Params: array of const;\n      const MaxRecordCount: Integer): TObjectList<T>; overload;\n    class function SelectRQLByNamedQuery(\n      const MVCActiveRecordClass: TMVCActiveRecordClass;\n      const QueryName: String;\n      const Params: array of const;\n      const MaxRecordCount: Integer): TMVCActiveRecordList; overload;\n    class function DeleteRQLByNamedQuery<T: TMVCActiveRecord, constructor>(\n      const QueryName: String;\n      const Params: array of const): Int64;\n    class function CountRQLByNamedQuery<T: TMVCActiveRecord, constructor>(\n      const QueryName: string;\n      const Params: array of const): Int64;\n    class function TryGetSQLQuery<T: TMVCActiveRecord, constructor>(\n      const QueryName: String;\n      out   NamedSQLQuery: TSQLQueryWithName): Boolean; overload;\n    class function TryGetRQLQuery<T: TMVCActiveRecord, constructor>(\n      const QueryName: String; out NamedRQLQuery: TRQLQueryWithName): Boolean;\n    { RTTI }\n    class function CreateMVCActiveRecord<T: TMVCActiveRecord>(AQualifiedClassName: string; const AParams: TArray<TValue> = nil): T;\n  end;\n\n  TMVCEntityMapping = TPair<String, TMVCActiveRecordClass>;\n\n  IMVCEntitiesRegistry = interface\n    ['{BB227BEB-A74A-4637-8897-B13BA938C07B}']\n    procedure AddEntity(const aURLSegment: string; const aActiveRecordClass: TMVCActiveRecordClass);\n    procedure AddEntityProcessor(const aURLSegment: string;\n      const aEntityProcessor: IMVCEntityProcessor);\n    function FindEntityClassByURLSegment(const aURLSegment: string;\n      out aMVCActiveRecordClass: TMVCActiveRecordClass): Boolean;\n    function FindProcessorByURLSegment(const aURLSegment: string;\n      out aMVCEntityProcessor: IMVCEntityProcessor)\n      : Boolean;\n    function GetEntities: TArray<String>;\n    function GetURLSegmentWithEntities: TArray<TMVCEntityMapping>;\n  end;\n\n  TMVCEntitiesRegistry = class(TInterfacedObject, IMVCEntitiesRegistry)\n  private\n    fEntitiesDict: TDictionary<string, TMVCActiveRecordClass>;\n    fProcessorsDict: TDictionary<string, IMVCEntityProcessor>;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n  protected\n    procedure AddEntityProcessor(const aURLSegment: string; const aEntityProcessor: IMVCEntityProcessor);\n    procedure AddEntity(const aURLSegment: string; const aActiveRecordClass: TMVCActiveRecordClass);\n    function FindEntityClassByURLSegment(const aURLSegment: string;\n      out aMVCActiveRecordClass: TMVCActiveRecordClass): Boolean;\n    function FindProcessorByURLSegment(const aURLSegment: string; out aMVCEntityProcessor: IMVCEntityProcessor)\n      : Boolean;\n    function GetEntities: TArray<String>;\n    function GetURLSegmentWithEntities: TArray<TMVCEntityMapping>;\n  end;\n\n  IMVCActiveRecordTableMap = interface\n    ['{517A863F-8BAD-4F66-A520-205149228360}']\n    procedure AddTableMap(const AR: TMVCActiveRecord; const TableName: String; var TableMap: TMVCTableMap);\n    function TryGetValue(const AR: TMVCActiveRecord; const TableName: String; out TableMap: TMVCTableMap): Boolean;\n    procedure ExecWithExclusiveLock(Proc: TProc<IMVCActiveRecordTableMap>);\n    procedure FlushCache;\n  end;\n\n  IMVCActiveRecordConnections = interface\n    ['{7B87473C-1784-489F-A838-925E7DDD0DE2}']\n    procedure AddConnection(const aName: string; const aConnection: TFDConnection; const Owns: Boolean = false); overload;\n    procedure AddDefaultConnection(const aConnection: TFDConnection; const Owns: Boolean = false); overload;\n    procedure AddDefaultConnection(const aConnectionDefName: String); overload;\n    procedure AddConnection(const aName, aConnectionDefName: String); overload;\n    procedure RemoveConnection(const aName: string; const RaiseExceptionIfNotAvailable: Boolean = True);\n    procedure RemoveDefaultConnection(const RaiseExceptionIfNotAvailable: Boolean = True);\n    procedure SetCurrent(const aName: string);\n    function GetCurrent(const RaiseExceptionIfNotAvailable: Boolean = True): TFDConnection;\n    function GetCurrentConnectionName(const RaiseExceptionIfNotAvailable: Boolean = False): String;\n    function GetCurrentBackend: string;\n    function GetByName(const aName: string): TFDConnection;\n    procedure SetDefault;\n  end;\n\n  TMVCConnectionsRepository = class(TInterfacedObject, IMVCActiveRecordConnections)\n  private type\n    TConnHolder = class\n    public\n      Connection: TFDConnection;\n      OwnsConnection: Boolean;\n      destructor Destroy; override;\n    end;\n\n  var\n    fMREW: TMultiReadExclusiveWriteSynchronizer;\n    fConnectionsDict: TDictionary<string, TConnHolder>;\n    fCurrentConnectionsByThread: TDictionary<TThreadID, string>;\n    function GetKeyName(const aName: string): string;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n    procedure AddConnection(const aName: string; const aConnection: TFDConnection; const aOwns: Boolean = false); overload;\n    procedure AddConnection(const aName, aConnectionDefName: String); overload;\n    procedure AddDefaultConnection(const aConnection: TFDConnection; const aOwns: Boolean = false); overload;\n    procedure AddDefaultConnection(const aConnectionDefName: String); overload;\n    procedure RemoveConnection(const aName: string; const RaiseExceptionIfNotAvailable: Boolean = True);\n    procedure RemoveDefaultConnection(const RaiseExceptionIfNotAvailable: Boolean = True);\n    procedure SetCurrent(const aName: string);\n    function GetCurrent(const RaiseExceptionIfNotAvailable: Boolean = True): TFDConnection;\n    function GetCurrentConnectionName(const RaiseExceptionIfNotAvailable: Boolean = False): String;\n    function GetByName(const aName: string): TFDConnection;\n    function GetCurrentBackend: string;\n    procedure SetDefault;\n  end;\n\n\n  TMVCTableMapRepository = class(TInterfacedObject, IMVCActiveRecordTableMap)\n  private\n    fMREW: TMultiReadExclusiveWriteSynchronizer;\n    fTableMapDict: TObjectDictionary<String, TMVCTableMap>;\n    function GetCacheKey(const AR: TMVCActiveRecord; const TableName: String): String; inline;\n  protected\n    procedure AddTableMap(const AR: TMVCActiveRecord; const TableName: String; var TableMap: TMVCTableMap);\n    function TryGetValue(const AR: TMVCActiveRecord; const TableName: String; out TableMap: TMVCTableMap): Boolean;\n    procedure ExecWithExclusiveLock(Proc: TProc<IMVCActiveRecordTableMap>);\n    procedure FlushCache;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n  end;\n\n\n  TMVCSQLGenerator = class abstract\n  private\n    fMapping: TMVCFieldsMapping;\n    fDefaultSQLFilter: String;\n    fDefaultRQLFilter: String;\n    fCompiler: TRQLCompiler;\n    fRQL2SQL: TRQL2SQL;\n  protected\n    fPartitionInfo: TPartitionInfo;\n    function GetDefaultSQLFilter(const IncludeWhereClause: Boolean; const IncludeAndClauseBeforeFilter: Boolean = false)\n      : String; // inline;\n    function MergeDefaultRQLFilter(const RQL: String): String; // inline;\n    function MergeSQLFilter(const PartitionSQL, FilteringSQL: String): String;\n    function GetRQLParser: TRQL2SQL;\n    function GetCompiler: TRQLCompiler;\n    function GetCompilerClass: TRQLCompilerClass; virtual; abstract;\n    function GetMapping: TMVCFieldsMapping;\n    function TableFieldsDelimited(const Map: TFieldsMap; const PKFieldName: string; const Delimiter: string): string;\n  public\n    constructor Create(Mapping: TMVCFieldsMapping; const DefaultRQLFilter: string;\n      const PartitionInfo: TPartitionInfo); virtual;\n    destructor Destroy; override;\n    // capabilities\n    function HasSequences: Boolean; virtual;\n    function HasReturning: Boolean; virtual;\n    function HasNativeUUID: Boolean; virtual;\n    // end-capabilities\n\n    // abstract SQL generator methods\n    function CreateSQLWhereByRQL(const RQL: string; const Mapping: TMVCFieldsMapping;\n      const UseArtificialLimit: Boolean = True; const UseFilterOnly: Boolean = false;\n      const MaxRecordCount: Int32 = TMVCConstants.MAX_RECORD_COUNT): string;\n    function CreateSelectSQL(const TableName: string; const Map: TFieldsMap; const PKFieldName: string;\n      const PKOptions: TMVCActiveRecordFieldOptions): string; virtual;\n    function CreateInsertSQL(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord): string; virtual; abstract;\n\n    // virtual methods with default implementation\n    function CreateSelectByPKSQL(const TableName: string; const Map: TFieldsMap; const PKFieldName: string;\n      const PKOptions: TMVCActiveRecordFieldOptions): string; virtual;\n    function CreateDeleteSQL(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord): string; virtual;\n    function CreateDeleteAllSQL(const TableName: string): string; virtual;\n    function CreateSelectCount(const TableName: string): string; virtual;\n    function CreateUpdateSQL(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord): string; virtual;\n    function GetSequenceValueSQL(const PKFieldName: string; const SequenceName: string; const Step: Integer = 1)\n      : string; virtual;\n\n    // Overwritten by descendant if the SQL syntaxt requires more than the simple table name\n    // or if the table name contains spaces.\n    function GetTableNameForSQL(const TableName: string): string; virtual;\n    // Overwritten by descendant if the SQL syntaxt requires more than the simple field name\n    // or if the field name contains spaces.\n    function GetFieldNameForSQL(const FieldName: string): string; virtual;\n    function GetParamNameForSQL(const FieldName: string): string; virtual;\n    // helper methods\n    class function RemoveInitialWhereKeyword(const SQLFilter: String): String;\n  end;\n\n  TMVCSQLGeneratorClass = class of TMVCSQLGenerator;\n\n  TMVCSQLGeneratorRegistry = class sealed\n  private\n    class var cInstance: TMVCSQLGeneratorRegistry;\n\n  class var\n    fSQLGenerators: TDictionary<string, TMVCSQLGeneratorClass>;\n    cConnectionsLock: TObject;\n  protected\n    constructor Create;\n  public\n    destructor Destroy; override;\n    class function Instance: TMVCSQLGeneratorRegistry;\n    class constructor Create;\n    class destructor Destroy;\n    procedure RegisterSQLGenerator(const aBackend: string; const aRQLBackendClass: TMVCSQLGeneratorClass);\n    procedure UnRegisterSQLGenerator(const aBackend: string);\n    function GetSQLGenerator(const aBackend: string): TMVCSQLGeneratorClass;\n  end;\n\n  TMVCUnitOfWork<T: TMVCActiveRecord> = class(TInterfacedObject, IMVCUnitOfWork<T>, IMVCMultiExecutor<T>)\n  private\n    fListToDelete: TObjectList<T>;\n    fListToUpdate: TObjectList<T>;\n    fListToInsert: TObjectList<T>;\n  protected\n    // multiexecutor\n    procedure Apply(const ItemApplyAction: TMVCItemApplyAction<T> = nil);\n    // unitofwork\n    procedure RegisterDelete(const Value: T); overload;\n    procedure RegisterDelete(const Enumerable: TEnumerable<T>); overload;\n    procedure RegisterUpdate(const Value: T);\n    procedure RegisterInsert(const Value: T);\n    procedure UnregisterDelete(const Value: T);\n    procedure UnregisterUpdate(const Value: T);\n    procedure UnregisterInsert(const Value: T);\n\n    // events\n    procedure DoItemApplyAction(const Obj: TMVCActiveRecord; const EntityAction: TMVCEntityAction;\n      const ItemApplyAction: TMVCItemApplyAction<T>; var Handled: Boolean);\n\n    class function KeyExistsInt(const NewList: TObjectList<T>; const KeyValue: Integer; out Index: Integer): Boolean;\n    class function KeyExistsInt64(const NewList: TObjectList<T>; const KeyValue: int64; out Index: Integer): Boolean;\n    class function KeyExistsString(const NewList: TObjectList<T>; const KeyValue: String; out Index: Integer): Boolean;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n  end;\n\n  TMVCActiveRecordBackEnd = record\n  public\n  const\n    Unknown = 'unknown';\n    Oracle = 'oracle';\n    MSSql = 'mssql';\n    MSAccess  = 'msaccess';\n    MySQL ='mysql';\n    DB2 = 'db2';\n    SQLAnywhere = 'sqlanywhere';\n    Advantage = 'advantage';\n    Interbase = 'interbase';\n    FirebirdSQL = 'firebird';\n    SQLite = 'sqlite';\n    PostgreSQL = 'postgresql';\n    NexusDB = 'nexusdb';\n    DataSnap = 'dataSnap';\n    Informix = 'informix';\n    Teradata = 'teradata';\n    MongoDB = 'mongodb';\n    Other = 'other';\n  end;\n\nfunction ActiveRecordConnectionsRegistry: IMVCActiveRecordConnections;\nfunction ActiveRecordTableMapRegistry: IMVCActiveRecordTableMap;\nfunction ActiveRecordMappingRegistry: IMVCEntitiesRegistry;\nfunction GetBackEndByConnection(aConnection: TFDConnection): string;\n\nconst\n  OBJECT_VERSION_STARTING_VALUE = '1';\n  OBJECT_VERSION_STARTING_VALUE_AS_INT: Int64 = 1;\n\nimplementation\n\nuses\n  System.IOUtils,\n  System.Classes,\n  MVCFramework.DataSet.Utils,\n  MVCFramework.Logger,\n  MVCFramework.Nullables,\n  MVCFramework.RTTI.Utils,\n  FireDAC.Stan.Option,\n  Data.FmtBcd,\n  System.Variants,\n  System.Math;\n\nvar\n  gCtx: TRttiContext;\n  gEntitiesRegistry: IMVCEntitiesRegistry;\n  gConnections: IMVCActiveRecordConnections;\n  gTableMap: IMVCActiveRecordTableMap;\n  gTableMapLock: TObject;\n\nfunction GetBackEndByConnection(aConnection: TFDConnection): string;\nbegin\n  if not aConnection.Connected then\n  begin\n    aConnection.Connected := True; {required to know the backend}\n  end;\n\n  case Ord(aConnection.RDBMSKind) of\n    0:\n      Exit(TMVCActiveRecordBackEnd.Unknown);\n    1:\n      Exit(TMVCActiveRecordBackEnd.Oracle);\n    2:\n      Exit(TMVCActiveRecordBackEnd.MSSql);\n    3:\n      Exit(TMVCActiveRecordBackEnd.MSAccess);\n    4:\n      Exit(TMVCActiveRecordBackEnd.MySQL);\n    5:\n      Exit(TMVCActiveRecordBackEnd.DB2);\n    6:\n      Exit(TMVCActiveRecordBackEnd.SQLAnywhere);\n    7:\n      Exit(TMVCActiveRecordBackEnd.Advantage);\n    8:\n      Exit(TMVCActiveRecordBackEnd.Interbase);\n    9:\n      Exit(TMVCActiveRecordBackEnd.FirebirdSQL);\n    10:\n      Exit(TMVCActiveRecordBackEnd.SQLite);\n    11:\n      Exit(TMVCActiveRecordBackEnd.PostgreSQL);\n    12:\n      Exit(TMVCActiveRecordBackEnd.NexusDB);\n    13:\n      Exit(TMVCActiveRecordBackEnd.DataSnap);\n    14:\n      Exit(TMVCActiveRecordBackEnd.Informix);\n    15:\n      Exit(TMVCActiveRecordBackEnd.Teradata);\n    16:\n      Exit(TMVCActiveRecordBackEnd.MongoDB);\n    17:\n      Exit(TMVCActiveRecordBackEnd.Other);\n  else\n    raise EMVCActiveRecord.Create('Unknown RDBMS Kind');\n  end;\nend;\n\nfunction ActiveRecordConnectionsRegistry: IMVCActiveRecordConnections;\nbegin\n  if gConnections = nil then // double check here\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if gConnections = nil then\n      begin\n        gConnections := TMVCConnectionsRepository.Create;\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\n  Result := gConnections;\nend;\n\nfunction ActiveRecordTableMapRegistry: IMVCActiveRecordTableMap;\nbegin\n  if gTableMap = nil then // double check here\n  begin\n    TMonitor.Enter(gTableMapLock);\n    try\n      if gTableMap = nil then\n      begin\n        gTableMap := TMVCTableMapRepository.Create;\n      end;\n    finally\n      TMonitor.Exit(gTableMapLock);\n    end;\n  end;\n  Result := gTableMap;\nend;\n\n\nfunction IntToNullableInt(const Value: Integer): NullableInt32;\nbegin\n  Result.SetValue(Value);\nend;\n\n{ TConnectionsRepository }\n\nprocedure TMVCConnectionsRepository.AddConnection(const aName: string; const aConnection: TFDConnection;\n  const aOwns: Boolean = false);\nvar\n  lName: string;\n  lConnKeyName: string;\n  lConnHolder: TConnHolder;\nbegin\n  lName := aName.ToLower;\n  lConnKeyName := GetKeyName(lName);\n\n  { If the transaction is not started, initialize TxIsolation as ReadCommitted }\n  if aConnection.Transaction = nil then\n  begin\n    { needed for Delphi 10.4 Sydney+ }\n    aConnection.TxOptions.Isolation := TFDTxIsolation.xiReadCommitted;\n  end;\n\n  fMREW.BeginWrite;\n  try\n    if fConnectionsDict.ContainsKey(lConnKeyName) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('Cannot add another connection with the same name for the same thread. Duplicated connection name is \"%s\"', [lName]);\n    end;\n    lConnHolder := TConnHolder.Create;\n    lConnHolder.Connection := aConnection;\n    lConnHolder.OwnsConnection := aOwns;\n    fConnectionsDict.Add(lConnKeyName, lConnHolder);\n    // raise exception on duplicates\n    if (lName = 'default') and (not fCurrentConnectionsByThread.ContainsKey(TThread.CurrentThread.ThreadID)) then\n    begin\n      fCurrentConnectionsByThread.AddOrSetValue(TThread.CurrentThread.ThreadID, lName);\n    end;\n  finally\n    fMREW.EndWrite;\n  end;\nend;\n\nprocedure TMVCConnectionsRepository.AddDefaultConnection(const aConnection: TFDConnection; const aOwns: Boolean);\nbegin\n  AddConnection('default', aConnection, aOwns);\nend;\n\nprocedure TMVCConnectionsRepository.AddConnection(const aName,\n  aConnectionDefName: String);\nvar\n  lConn: TFDConnection;\nbegin\n  lConn := TFDConnection.Create(nil);\n  try\n    lConn.ConnectionDefName := aConnectionDefName;\n    AddConnection(aName, lConn, True);\n  except\n    on E: Exception do\n    begin\n      lConn.Free;\n      raise;\n    end;\n  end;\nend;\n\nprocedure TMVCConnectionsRepository.AddDefaultConnection(const aConnectionDefName: String);\nbegin\n  AddConnection('default', aConnectionDefName);\nend;\n\nconstructor TMVCConnectionsRepository.Create;\nbegin\n  inherited;\n  fMREW := TMultiReadExclusiveWriteSynchronizer.Create;\n  fConnectionsDict := TDictionary<string, TConnHolder>.Create;\n  fCurrentConnectionsByThread := TDictionary<TThreadID, string>.Create;\nend;\n\ndestructor TMVCConnectionsRepository.Destroy;\nbegin\n  fConnectionsDict.Free;\n  fCurrentConnectionsByThread.Free;\n  fMREW.Free;\n  inherited;\nend;\n\nfunction TMVCConnectionsRepository.GetByName(const aName: string): TFDConnection;\nvar\n  lKeyName: string;\n  lConnHolder: TConnHolder;\nbegin\n{$IF not Defined(TokyoOrBetter)}\n  Result := nil;\n{$ENDIF}\n  lKeyName := GetKeyName(aName.ToLower);\n  fMREW.BeginRead;\n  try\n    if not fConnectionsDict.TryGetValue(lKeyName, lConnHolder) then\n      raise EMVCActiveRecord.CreateFmt('Unknown connection %s', [aName]);\n    Result := lConnHolder.Connection;\n    Result.Open;\n  finally\n    fMREW.EndRead;\n  end;\nend;\n\nfunction TMVCConnectionsRepository.GetCurrentConnectionName(\n  const RaiseExceptionIfNotAvailable: Boolean): String;\nvar\n  lName: string;\nbegin\n{$IF not Defined(TokyoOrBetter)}\n  Result := '';\n{$ENDIF}\n  fMREW.BeginRead;\n  try\n    if fCurrentConnectionsByThread.TryGetValue(TThread.CurrentThread.ThreadID, lName) then\n    begin\n      Result := lName;\n    end\n    else\n    begin\n      if RaiseExceptionIfNotAvailable then\n        raise EMVCActiveRecord.Create('No current connection for thread')\n      else\n        Result := '';\n    end;\n  finally\n    fMREW.EndRead;\n  end;\nend;\n\nfunction TMVCConnectionsRepository.GetCurrent(const RaiseExceptionIfNotAvailable: Boolean): TFDConnection;\nvar\n  lName: string;\nbegin\n{$IF not Defined(TokyoOrBetter)}\n  Result := nil;\n{$ENDIF}\n  fMREW.BeginRead;\n  try\n    if fCurrentConnectionsByThread.TryGetValue(TThread.CurrentThread.ThreadID, lName) then\n    begin\n      Result := GetByName(lName);\n    end\n    else\n    begin\n      if RaiseExceptionIfNotAvailable then\n        raise EMVCActiveRecord.Create('No current connection for thread')\n      else\n        Result := nil;\n    end;\n  finally\n    fMREW.EndRead;\n  end;\nend;\n\nfunction TMVCConnectionsRepository.GetCurrentBackend: string;\nbegin\n  Result := GetBackEndByConnection(GetCurrent);\nend;\n\nfunction TMVCConnectionsRepository.GetKeyName(const aName: string): string;\nbegin\n  Result := Format('%10.10d::%s', [TThread.CurrentThread.ThreadID, aName]);\nend;\n\nprocedure TMVCConnectionsRepository.RemoveConnection(const aName: string;\n  const RaiseExceptionIfNotAvailable: Boolean = True);\nvar\n  lName: string;\n  lKeyName: string;\n  lConnHolder: TConnHolder;\nbegin\n  lName := aName.ToLower;\n  lKeyName := GetKeyName(lName);\n\n  fMREW.BeginWrite;\n  try\n    if not fConnectionsDict.TryGetValue(lKeyName, lConnHolder) then\n    begin\n      if RaiseExceptionIfNotAvailable then\n      begin\n        raise EMVCActiveRecord.CreateFmt('Unknown connection %s', [aName])\n      end\n      else\n      begin\n        Exit;\n      end;\n    end;\n    fConnectionsDict.Remove(lKeyName);\n    try\n      FreeAndNil(lConnHolder);\n    except\n      on E: Exception do\n      begin\n        LogE('ActiveRecord: ' + E.ClassName + ' > ' + E.Message);\n        raise;\n      end;\n    end;\n   fCurrentConnectionsByThread.Remove(TThread.CurrentThread.ThreadID);\n  finally\n    fMREW.EndWrite;\n  end;\nend;\n\nprocedure TMVCConnectionsRepository.RemoveDefaultConnection(const RaiseExceptionIfNotAvailable: Boolean = True);\nbegin\n  RemoveConnection('default', RaiseExceptionIfNotAvailable);\nend;\n\nprocedure TMVCConnectionsRepository.SetCurrent(const aName: string);\nvar\n  lName: string;\n  lKeyName: string;\nbegin\n  lName := aName.ToLower;\n  lKeyName := GetKeyName(lName);\n\n  fMREW.BeginWrite;\n  try\n    if not fConnectionsDict.ContainsKey(lKeyName) then\n      raise EMVCActiveRecord.CreateFmt('Unknown connection %s', [aName]);\n    fCurrentConnectionsByThread.AddOrSetValue(TThread.CurrentThread.ThreadID, lName);\n  finally\n    fMREW.EndWrite;\n  end;\nend;\n\nprocedure TMVCConnectionsRepository.SetDefault;\nbegin\n  SetCurrent('default');\nend;\n\nfunction ActiveRecordMappingRegistry: IMVCEntitiesRegistry;\nbegin\n  if gEntitiesRegistry = nil then\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if gEntitiesRegistry = nil then\n      begin\n        gEntitiesRegistry := TMVCEntitiesRegistry.Create;\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\n  Result := gEntitiesRegistry;\nend;\n\n{ TableFieldAttribute }\n\nconstructor MVCTableFieldAttribute.Create(aFieldName: string; const aDataTypeName: string = '');\nbegin\n  Create(aFieldName, [], '', aDataTypeName);\nend;\n\n{ TableAttribute }\n\nconstructor MVCTableAttribute.Create(aName: string);\nbegin\n  Create(aName, '');\nend;\n\n{ TActiveRecord }\n\ndestructor TMVCActiveRecord.Destroy;\nbegin\n  fChildren.Free;\n  fSQLGenerator.Free;\n  fRQL2SQL.Free;\n  fConn := nil; // do not free it!!\n  inherited;\nend;\n\nprocedure TMVCActiveRecord.EnsureConnection;\nbegin\n  GetConnection;\nend;\n\nfunction TMVCActiveRecord.ExecNonQuery(const SQL: string; RefreshAutoGenerated: Boolean = false): int64;\nvar\n  lQry: TFDQuery;\n  lPar: TFDParam;\n  lPair: TPair<TRTTIField, TFieldInfo>;\n  lValue: TValue;\n  lSQL: string;\n  lHandled: Boolean;\n  I: Integer;\nbegin\n  { TODO -oDanieleT -cGeneral : Why not a TFDCommand? }\n  lQry := CreateQuery(True, True);\n  try\n    lQry.Connection := GetConnection;\n    lSQL := SQL;\n    OnBeforeExecuteSQL(lSQL);\n    lQry.SQL.Text := lSQL;\n\n    lHandled := false;\n\n    MapObjectToParams(lQry.Params, lHandled);\n    if not lHandled then\n    begin\n      { partitioning }\n      for I := 0 to GetPartitionInfo.FieldNames.Count - 1 do\n      begin\n        lPar := lQry.FindParam(SQLGenerator.GetParamNameForSQL(GetPartitionInfo.FieldNames[I]));\n        if lPar <> nil then\n        begin\n          if GetPartitionInfo.FieldTypes[I] = ftInteger then\n            lValue := StrToInt(GetPartitionInfo.FieldValues[I])\n          else\n            lValue := GetPartitionInfo.FieldValues[I];\n          MapTValueToParam(lValue, lPar);\n        end\n      end;\n      { end-partitioning }\n\n      for lPair in fTableMap.fMap do\n      begin\n        lPar := lQry.FindParam(SQLGenerator.GetParamNameForSQL(lPair.Value.FieldName));\n        if (lPar <> nil) and (lpair.Value.Insertable or lpair.Value.Updatable) then\n        begin\n          lValue := lPair.Key.GetValue(Self);\n          lPar.DataTypeName := fTableMap.fMap.GetInfoByFieldName(lPair.Value.FieldName).DataTypeName;\n          MapTValueToParam(lValue, lPar);\n        end\n      end;\n\n      // Check if it's the primary key\n      lPar := lQry.FindParam(SQLGenerator.GetParamNameForSQL(fTableMap.fPrimaryKeyFieldName));\n      if lPar <> nil then\n      begin\n        if lPar.DataType = ftUnknown then\n        begin\n          { TODO -oDanieleT -cGeneral : Let's find a smarter way to do this if the engine cannot recognize parameter's datatype }\n          lPar.DataType := GetPrimaryKeyFieldType;\n        end;\n        MapTValueToParam(fTableMap.fPrimaryKey.GetValue(Self), lPar);\n      end;\n    end;\n\n    if RefreshAutoGenerated and (TMVCActiveRecordFieldOption.foAutoGenerated in fTableMap.fPrimaryKeyOptions) and\n      fTableMap.fPrimaryKeySequenceName.IsEmpty then\n    begin\n      lValue := fTableMap.fPrimaryKey.GetValue(Self);\n      lQry.Open;\n\n      if (lValue.Kind = tkRecord) then\n      begin\n        MapDataSetFieldToNullableRTTIField(lValue, lQry.Fields[0], fTableMap.fPrimaryKey, Self);\n      end\n      else\n      begin\n        lValue := lQry.FieldByName(fTableMap.fPrimaryKeyFieldName).AsInteger;\n        fTableMap.fPrimaryKey.SetValue(Self, lValue);\n      end;\n    end\n    else\n    begin\n      lQry.ExecSQL(lSQL);\n    end;\n    Result := lQry.RowsAffected;\n  finally\n    lQry.Free;\n  end;\nend;\n\nclass function TMVCActiveRecord.ExecQuery(const SQL: string; const Values: array of Variant;\n  const Connection: TFDConnection; const Unidirectional: Boolean;\n  const DirectExecute: Boolean): TDataSet;\nbegin\n  Result := ExecQuery(SQL, Values, [], Connection, Unidirectional, DirectExecute);\nend;\n\nprocedure TMVCActiveRecord.FillPrimaryKey(const SequenceName: string);\nvar\n  lDS: TDataSet;\n  lSQL: string;\nbegin\n  if not SequenceName.IsEmpty then\n  begin\n    lSQL := SQLGenerator.GetSequenceValueSQL(fTableMap.fPrimaryKeyFieldName, SequenceName);\n    if lSQL.IsEmpty then\n    begin\n      Exit;\n    end;\n    lDS := ExecQuery(lSQL, [], True, False);\n    try\n      MapDataSetFieldToRTTIField(lDS.Fields[0], fTableMap.fPrimaryKey, Self);\n    finally\n      lDS.Free;\n    end;\n  end;\nend;\n\nfunction TMVCActiveRecord.FindRQLQueryByName(const QueryName: String;\n  out NamedRQLQuery: TRQLQueryWithName): Boolean;\nvar\n  I: Integer;\nbegin\n  for I := Low(fTableMap.fNamedRQLQueries) to High(fTableMap.fNamedRQLQueries) do\n  begin\n    if SameText(QueryName, fTableMap.fNamedRQLQueries[I].Name) then\n    begin\n      NamedRQLQuery := fTableMap.fNamedRQLQueries[I];\n      Exit(True);\n    end;\n  end;\n  Result := False;\nend;\n\nfunction TMVCActiveRecord.FindSQLQueryByName(const QueryName: String;\n  out NamedSQLQuery: TSQLQueryWithName): Boolean;\nvar\n  I: Integer;\n  lBackEnd: String;\nbegin\n  for I := Low(fTableMap.fNamedSQLQueries) to High(fTableMap.fNamedSQLQueries) do\n  begin\n    if SameText(QueryName, fTableMap.fNamedSQLQueries[I].Name) then\n    begin\n      lBackEnd := fTableMap.fNamedSQLQueries[I].BackEnd;\n      if lBackEnd.IsEmpty or (lBackEnd = GetBackEnd) then\n      begin\n        NamedSQLQuery := fTableMap.fNamedSQLQueries[I];\n        Exit(True);\n      end;\n    end;\n  end;\n  Result := False;\nend;\n\nclass function TMVCActiveRecord.ExecQuery(const SQL: string; const Values: array of Variant;\n  const Unidirectional: Boolean; const DirectExecute: Boolean): TDataSet;\nbegin\n  Result := ExecQuery(SQL, Values, nil, Unidirectional, DirectExecute);\nend;\n\nprocedure TMVCActiveRecord.InitTableInfo(const aTableName: String);\nvar\n  lAttribute: TCustomAttribute;\n  lRTTIField: TRTTIField;\n  lFieldInfo: TFieldInfo;\n  lPrimaryFieldTypeAsStr: string;\n  lTableMap: TMVCTableMap;\n  lPKCount: Integer;\n  lNamedSQLQueryCount: Integer;\n  lNamedRQLQueryCount: Integer;\n  lNeedsTableName: Boolean;\nbegin\n  if ActiveRecordTableMapRegistry.TryGetValue(Self, aTableName, fTableMap) then\n  begin\n    Exit;\n  end;\n  TMonitor.Enter(gTableMapLock);\n  try\n    if ActiveRecordTableMapRegistry.TryGetValue(Self, aTableName, fTableMap) then //double check here\n    begin\n      Exit;\n    end;\n    lTableMap := TMVCTableMap.Create;\n    SetLength(lTableMap.fMapping, 0);\n    lTableMap.fPartitionInfoInternal := nil;\n    lTableMap.fEntityAllowedActions := [TMVCEntityAction.eaCreate, TMVCEntityAction.eaRetrieve, TMVCEntityAction.eaUpdate,\n      TMVCEntityAction.eaDelete];\n    lTableMap.fTableName := aTableName;\n    lTableMap.fPartitionClause := '';\n    lTableMap.fRTTIType := gCtx.GetType(Self.ClassInfo) as TRttiInstanceType;\n    lTableMap.fObjAttributes := lTableMap.fRTTIType.GetAttributes;\n    lPKCount := 0;\n    lNeedsTableName := lTableMap.fTableName.IsEmpty;\n    lNamedSQLQueryCount := Length(lTableMap.fNamedSQLQueries);\n    lNamedRQLQueryCount := Length(lTableMap.fNamedRQLQueries);\n    for lAttribute in lTableMap.fObjAttributes do\n    begin\n      if lNeedsTableName and (lAttribute is MVCTableAttribute) then\n      begin\n        lTableMap.fTableName := MVCTableAttribute(lAttribute).Name;\n        lTableMap.fDefaultRQLFilter := MVCTableAttribute(lAttribute).RQLFilter;\n        Continue;\n      end;\n      if lAttribute is MVCEntityActionsAttribute then\n      begin\n        lTableMap.fEntityAllowedActions := MVCEntityActionsAttribute(lAttribute).EntityAllowedActions;\n        Continue;\n      end;\n      if lAttribute is MVCPartitionAttribute then\n      begin\n        lTableMap.fPartitionClause := MVCPartitionAttribute(lAttribute).PartitionClause;\n        Continue;\n      end;\n      if lAttribute is MVCNamedSQLQueryAttribute then\n      begin\n        Inc(lNamedSQLQueryCount);\n        SetLength(lTableMap.fNamedSQLQueries, lNamedSQLQueryCount);\n        lTableMap.fNamedSQLQueries[lNamedSQLQueryCount - 1].Name := MVCNamedSQLQueryAttribute(lAttribute).Name;\n        lTableMap.fNamedSQLQueries[lNamedSQLQueryCount - 1].SQLText := MVCNamedSQLQueryAttribute(lAttribute).SQLQuery;\n        lTableMap.fNamedSQLQueries[lNamedSQLQueryCount - 1].BackEnd := MVCNamedSQLQueryAttribute(lAttribute).Backend;\n        Continue;\n      end;\n      if lAttribute is MVCNamedRQLQueryAttribute then\n      begin\n        Inc(lNamedRQLQueryCount);\n        SetLength(lTableMap.fNamedRQLQueries, lNamedRQLQueryCount);\n        lTableMap.fNamedRQLQueries[lNamedRQLQueryCount - 1].Name := MVCNamedRQLQueryAttribute(lAttribute).Name;\n        lTableMap.fNamedRQLQueries[lNamedRQLQueryCount - 1].RQLText := MVCNamedRQLQueryAttribute(lAttribute).RQLQuery;\n        Continue;\n      end;\n    end;\n\n    if lTableMap.fTableName = '' then\n    begin\n      if [eaCreate, eaUpdate, eaDelete] * lTableMap.fEntityAllowedActions <> [] then\n      begin\n        raise EMVCActiveRecord.Create('Cannot find MVCTable attribute nor a valid \"GetCustomTableName\" method on class \"' + ClassName + '\" - [HINT] Is ' + ClassName + ' class decorated with MVCTable and its fields with MVCTableField?');\n      end;\n    end;\n\n    lTableMap.fProps := lTableMap.fRTTIType.GetFields;\n    for lRTTIField in lTableMap.fProps do\n    begin\n      lTableMap.fPropsAttributes := lRTTIField.GetAttributes;\n      if Length(lTableMap.fPropsAttributes) = 0 then\n        Continue;\n      for lAttribute in lTableMap.fPropsAttributes do\n      begin\n        if lAttribute is MVCTableFieldAttribute then\n        begin\n          if foPrimaryKey in MVCTableFieldAttribute(lAttribute).FieldOptions then\n          begin\n            lTableMap.fPrimaryKeyInInsert :=\n              [foAutoGenerated,foReadOnly,foDoNotInsert] * MVCTableFieldAttribute(lAttribute).FieldOptions = [];\n            lTableMap.fPrimaryKey := lRTTIField;\n            lPrimaryFieldTypeAsStr := lTableMap.fPrimaryKey.FieldType.ToString.ToLowerInvariant;\n            if lPrimaryFieldTypeAsStr.EndsWith('int64') then\n            begin\n              lTableMap.fPrimaryKeyFieldType := ftLargeInt;\n            end\n            else if lPrimaryFieldTypeAsStr.EndsWith('integer')\n              or lPrimaryFieldTypeAsStr.EndsWith('int16')\n              or lPrimaryFieldTypeAsStr.EndsWith('int32') then\n            begin\n              lTableMap.fPrimaryKeyFieldType := ftInteger;\n            end\n            else if lPrimaryFieldTypeAsStr.EndsWith('string') then\n            begin\n              lTableMap.fPrimaryKeyFieldType := ftString;\n            end\n            else if lPrimaryFieldTypeAsStr.EndsWith('guid') then\n            begin\n              lTableMap.fPrimaryKeyFieldType := ftGuid;\n            end\n            else\n            begin\n              raise EMVCActiveRecord.Create\n                ('Allowed primary key types are: (Nullable)Integer, (Nullable)Int16, (Nullable)Int32, (Nullable)Int64, (Nullable)String, GUID - found: ' +\n                lPrimaryFieldTypeAsStr);\n            end;\n            lTableMap.fPrimaryKeyFieldName := MVCTableFieldAttribute(lAttribute).FieldName;\n            lTableMap.fPrimaryKeyOptions := MVCTableFieldAttribute(lAttribute).FieldOptions;\n            lTableMap.fPrimaryKeySequenceName := MVCTableFieldAttribute(lAttribute).SequenceName;\n            Inc(lPKCount);\n            Continue;\n          end;\n\n          lFieldInfo := TFieldInfo.Create;\n          lTableMap.fMap.Add(lRTTIField, lFieldInfo);\n          lFieldInfo.FieldName := MVCTableFieldAttribute(lAttribute).FieldName;\n          lFieldInfo.FieldOptions := MVCTableFieldAttribute(lAttribute).FieldOptions;\n          lFieldInfo.DataTypeName := MVCTableFieldAttribute(lAttribute).DataTypeName;\n\n          if foVersion in lFieldInfo.FieldOptions then\n          begin\n            if not lTableMap.fVersionFieldName.IsEmpty then\n            begin\n              raise EMVCActiveRecord.Create('Only one version field is allowed for table - Currently at least fields [' + lTableMap.fVersionFieldName + '] and [' + lFieldInfo.FieldName + '] are marked as foVersion');\n            end;\n            lTableMap.fVersionRTTIField := lRTTIField;\n            lTableMap.fVersionFieldName := lFieldInfo.FieldName;\n            lTableMap.fIsVersioned := True;\n          end;\n        end;\n      end;\n    end;\n    lTableMap.fMap.EndUpdates;\n\n    if (lPKCount + lTableMap.fMap.WritableFieldsCount + lTableMap.fMap.ReadableFieldsCount) = 0 then\n    begin\n      raise EMVCActiveRecord.Create(\n        'No fields nor PKs defined in class ' + ClassName + '. [HINT] Use MVCTableField in private fields');\n    end;\n\n    if lTableMap.fIsVersioned then\n    begin\n      lFieldInfo := lTableMap.fMap.GetInfoByFieldName(lTableMap.fVersionFieldName);\n      if not (lFieldInfo.Insertable and lFieldInfo.Updatable) then\n      begin\n        raise EMVCActiveRecord\n          .CreateFmt('Field [%s], is marked as foVersion so must be a Read/Write field - ' +\n            '[HINT] This constraint is valid only for the field itself, a property mapped over this field can be defined \"read-only\", \"write-only\" or \"read-write\"',\n            [lTableMap.fVersionFieldName]);\n      end;\n    end;\n\n    lTableMap.fPartitionInfoInternal := nil;\n    ActiveRecordTableMapRegistry.AddTableMap(Self, aTableName, lTableMap);\n    fTableMap := lTableMap;\n  finally\n    TMonitor.Exit(gTableMapLock);\n  end;\nend;\n\nprocedure TMVCActiveRecord.Insert;\nvar\n  SQL: string;\nbegin\n  CheckAction(TMVCEntityAction.eaCreate);\n  OnValidation(TMVCEntityAction.eaCreate);\n  OnBeforeInsert;\n  OnBeforeInsertOrUpdate;\n  if (fTableMap.fMap.WritableFieldsCount = 0) and (not fTableMap.fPrimaryKeyInInsert) then\n  begin\n    raise EMVCActiveRecord.CreateFmt\n      ('Cannot insert an entity if no fields are writable. Class [%s] mapped on table [%s]',\n      [ClassName, TableName]);\n  end;\n  if (not fTableMap.fPrimaryKeyInInsert) {autogenerated} then\n  begin\n    if not SQLGenerator.HasReturning then\n    begin\n      if not SQLGenerator.HasSequences then\n      begin\n        raise EMVCActiveRecord.Create\n          ('Cannot use AutoGenerated primary keys if the engine doesn''t support returning clause nor sequences');\n      end\n      else\n      begin\n        if fTableMap.fPrimaryKeySequenceName.IsEmpty then\n        begin\n          raise EMVCActiveRecord.Create('SequenceName is empty for entity ' + ClassName + ' but ' + GetBackEnd +\n            ' requires it');\n        end;\n        if foReadOnly in fTableMap.fPrimaryKeyOptions then\n        begin\n          raise EMVCActiveRecord.Create('Cannot define a read-only primary key when a sequence is used for the class ' +\n            ClassName);\n        end;\n        FillPrimaryKey(fTableMap.fPrimaryKeySequenceName);\n      end;\n    end;\n  end;\n\n  SQL := SQLGenerator.CreateInsertSQL(fTableMap, Self);\n  ExecNonQuery(SQL, True);\n  if fTableMap.fIsVersioned then\n  begin\n    { in case of INSERT version is defined by constants }\n    SetInitialObjVersion(fTableMap, Self);\n  end;\n  OnAfterInsert;\n  OnAfterInsertOrUpdate;\nend;\n\nfunction TMVCActiveRecord.InternalCount(const RQL: string): int64;\nvar\n  lSQL: string;\nbegin\n  lSQL := Self.SQLGenerator.CreateSelectCount(TableName);\n  lSQL := lSQL + fSQLGenerator.CreateSQLWhereByRQL(RQL, GetMapping, false, True);\n  Result := GetScalar(lSQL, []);\nend;\n\nfunction TMVCActiveRecord.InternalSelectRQL(const RQL: string;\n  const MaxRecordCount: Integer; const OutList: TMVCActiveRecordList): UInt32;\nvar\n  lSQL: string;\nbegin\n  lSQL := SQLGenerator.CreateSQLWhereByRQL(RQL, GetMapping, True, false, MaxRecordCount);\n  LogD(Format('RQL [%s] => SQL [%s]', [RQL, lSQL]));\n  Result := Where(TMVCActiveRecordClass(Self.ClassType), lSQL, [], nil, OutList);\nend;\n\nfunction TMVCActiveRecord.InternalSelectRQL(const RQL: string; const MaxRecordCount: Integer): TMVCActiveRecordList;\nvar\n  lSQL: string;\nbegin\n  lSQL := SQLGenerator.CreateSQLWhereByRQL(RQL, GetMapping, True, false, MaxRecordCount);\n  LogD(Format('RQL [%s] => SQL [%s]', [RQL, lSQL]));\n  Result := Where(TMVCActiveRecordClass(Self.ClassType), lSQL, []);\nend;\n\nconstructor TMVCActiveRecord.Create(aLazyLoadConnection: Boolean);\nbegin\n  inherited Create;\n  fConn := nil;\n  if not aLazyLoadConnection then\n  begin\n    GetConnection;\n  end;\n  InitTableInfo(GetCustomTableName);\nend;\n\nfunction TMVCActiveRecord.GenerateSelectSQL: string;\nbegin\n  Result := SQLGenerator.CreateSelectSQL(TableName, fTableMap.fMap,\n    fTableMap.fPrimaryKeyFieldName, fTableMap.fPrimaryKeyOptions);\nend;\n\nfunction TMVCActiveRecord.GetAttributes(const AttrName: string): TValue;\nvar\n  lProperty: TRttiProperty;\nbegin\n  if not TRttiUtils.ExistsProperty(Self, AttrName, lProperty) then\n  begin\n    raise EMVCActiveRecord.CreateFmt('Attribute [%s] not found', [AttrName]);\n  end;\n  Result := lProperty.GetValue(Self);\nend;\n\nfunction TMVCActiveRecord.GetBackEnd: string;\nbegin\n  if fBackendDriver.IsEmpty then\n  begin\n    fBackendDriver := GetBackEndByConnection(GetConnection);\n  end;\n  Result := fBackendDriver;\nend;\n\nclass function TMVCActiveRecord.GetByPK(aActiveRecord: TMVCActiveRecord; const aValue: string;\n  const aFieldType: TFieldType; const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord;\nvar\n  lFound: Boolean;\nbegin\n  Result := aActiveRecord;\n  try\n    if Result.SQLGenerator.HasNativeUUID then\n    begin\n      lFound := Result.LoadByPK(aValue, aFieldType)\n    end\n    else\n    begin\n      lFound := Result.LoadByPK(aValue);\n    end;\n    if not lFound then\n    begin\n      if RaiseExceptionIfNotFound then\n        raise EMVCActiveRecordNotFound.CreateFmt('No data found for key [Entity: %s][PK: %s]',\n          [aActiveRecord.ClassName, aActiveRecord.fTableMap.fPrimaryKeyFieldName])\n      else\n        FreeAndNil(Result);\n    end;\n  except\n    FreeAndNil(Result);\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK(const aClass: TMVCActiveRecordClass; const aValue: string;\n  const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord;\nbegin\n  Result := GetByPK(aClass.Create, aValue, ftString, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK(const aClass: TMVCActiveRecordClass; const aValue: int64;\n  const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord;\nbegin\n  Result := GetByPK(aClass.Create, aValue.ToString, ftInteger, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK(const aClass: TMVCActiveRecordClass; const aValue: TGuid;\n  const RaiseExceptionIfNotFound: Boolean): TMVCActiveRecord;\nbegin\n  Result := GetByPK(aClass.Create, aValue.ToString, ftGuid, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK<T>(const aValue: int64;\n  const RaiseExceptionIfNotFound: Boolean = True): T;\nbegin\n  Result := GetByPK<T>(aValue.ToString, ftInteger, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK<T>(const aValue: string; const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := GetByPK<T>(aValue, ftString, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK<T>(const aValue: TGuid; const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := GetByPK<T>(aValue.ToString, ftGuid, RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetByPK<T>(const aValue: string; const aFieldType: TFieldType;\n  const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := T(GetByPK(T.Create, aValue, aFieldType, RaiseExceptionIfNotFound));\nend;\n\nclass function TMVCActiveRecordHelper.GetFirstByWhere<T>(const SQLWhere: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const RaiseExceptionIfNotFound: Boolean): T;\nvar\n  lList: TObjectList<T>;\nbegin\n  lList := Where<T>(SQLWhere, Params, ParamTypes);\n  try\n    if lList.Count = 0 then\n    begin\n      if RaiseExceptionIfNotFound then\n        raise EMVCActiveRecordNotFound.Create('Got 0 rows when at least 1 was expected');\n      Exit(nil);\n    end;\n    Result := lList.Extract(lList.First);\n  finally\n    lList.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.GetFirstByWhere<T>(const SQLWhere: string; const Params: array of Variant;\n  const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := GetFirstByWhere<T>(SQLWhere, Params, [], RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.GetOneByWhere<T>(const SQLWhere: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := GetFirstByWhere<T>(SQLWhere, Params, ParamTypes, false);\n  if Result = nil then\n  begin\n    if RaiseExceptionIfNotFound then\n      raise EMVCActiveRecordNotFound.Create('Got 0 rows when exactly 1 was expected');\n  end;\nend;\n\nfunction TMVCActiveRecord.GetMapping: TMVCFieldsMapping;\nvar\n  lPair: TPair<TRTTIField, TFieldInfo>;\n  I: Integer;\n  lPropFromField: TRttiProperty;\n  lParentType: TRttiType;\n  lTmp: String;\nbegin\n  { TODO -oDanieleT -cGeneral : Let share the mapping for instances of the same type }\n  { TODO -oDanieleT -cGeneral : Add NameAs in the TFieldInfo because the user needs to use the property name he see }\n  if Length(fTableMap.fMapping) = 0 then\n  begin\n    if not fTableMap.fPrimaryKeyFieldName.IsEmpty then\n    begin\n      lParentType := fTableMap.fPrimaryKey.Parent;\n      SetLength(fTableMap.fMapping, fTableMap.fMap.Count + 1);\n      fTableMap.fMapping[0].InstanceFieldName := fTableMap.fPrimaryKey.Name.Substring(1).ToLower;\n      fTableMap.fMapping[0].DatabaseFieldName := fTableMap.fPrimaryKeyFieldName;\n      lPropFromField := lParentType.GetProperty(fTableMap.fPrimaryKey.Name.Substring(1));\n      if Assigned(lPropFromField) then\n      begin\n        lTmp := TMVCSerializerHelper.GetKeyName(lPropFromField, lParentType);\n        if not SameText(lTmp, fTableMap.fMapping[0].InstanceFieldName) then\n        begin\n          fTableMap.fMapping[0].Alias := lTmp;\n        end;\n      end;\n      I := 1;\n    end\n    else\n    begin\n      SetLength(fTableMap.fMapping, fTableMap.fMap.Count);\n      I := 0;\n    end;\n\n    for lPair in fTableMap.fMap do\n    begin\n      lParentType := lPair.Key.Parent;\n      fTableMap.fMapping[I].InstanceFieldName := lPair.Key.Name.Substring(1).ToLower;\n      fTableMap.fMapping[I].DatabaseFieldName := lPair.Value.FieldName;\n\n      lPropFromField := lParentType.GetProperty(lPair.Key.Name.Substring(1));\n      if Assigned(lPropFromField) then\n      begin\n        lTmp := TMVCSerializerHelper.GetKeyName(lPropFromField, lParentType);\n        if not SameText(lTmp, fTableMap.fMapping[I].InstanceFieldName) then\n        begin\n          fTableMap.fMapping[I].Alias := lTmp;\n        end;\n      end;\n      Inc(I);\n    end;\n  end;\n  Result := fTableMap.fMapping;\nend;\n\nclass function TMVCActiveRecordHelper.GetOneByWhere<T>(const SQLWhere: string; const Params: array of Variant;\n  const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := GetFirstByWhere<T>(SQLWhere, Params, false);\n  if Result = nil then\n  begin\n    if RaiseExceptionIfNotFound then\n      raise EMVCActiveRecordNotFound.Create('Got 0 rows when exactly 1 was expected');\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectOneByRQL<T>(const RQL: string; const RaiseExceptionIfNotFound: Boolean): T;\nvar\n  lAR: TMVCActiveRecord;\n  lSQL: string;\nbegin\n  lAR := T.Create;\n  try\n    lSQL := lAR.SQLGenerator.CreateSQLWhereByRQL(RQL, lAR.GetMapping).Trim;\n    lSQL := TMVCSQLGenerator.RemoveInitialWhereKeyword(lSQL);\n    Result := GetFirstByWhere<T>(lSQL, [], RaiseExceptionIfNotFound);\n    if Result = nil then\n    begin\n      if RaiseExceptionIfNotFound then\n        raise EMVCActiveRecordNotFound.Create('Got 0 rows when exactly 1 was expected');\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQL<T>(const RQL: string;\n  const MaxRecordCount: Integer; const OutList: TObjectList<T>): UInt32;\nvar\n  lAR: TMVCActiveRecord;\n  lSQL: string;\nbegin\n  lAR := T.Create;\n  try\n    lSQL := lAR.SQLGenerator.CreateSQLWhereByRQL(RQL, lAR.GetMapping, MaxRecordCount > -1, false, MaxRecordCount).Trim;\n    lSQL := TMVCSQLGenerator.RemoveInitialWhereKeyword(lSQL);\n    Result := Where<T>(lSQL, [], [], OutList);\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQLByNamedQuery(\n  const MVCActiveRecordClass: TMVCActiveRecordClass; const QueryName: String;\n  const Params: array of const;\n  const MaxRecordCount: Integer): TMVCActiveRecordList;\nvar\n  lT: TMVCActiveRecord;\n  lRQLQuery: TRQLQueryWithName;\nbegin\n  lT := MVCActiveRecordClass.Create;\n  try\n    if not lT.FindRQLQueryByName(QueryName, lRQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedRQLQuery not found: %s', [QueryName]);\n    end;\n    Result := SelectRQL(MVCActiveRecordClass, Format(lRQLQuery.RQLText, Params), MaxRecordCount);\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQLByNamedQuery<T>(\n  const QueryName: string;\n  const Params: array of const;\n  const MaxRecordCount: Integer): TObjectList<T>;\nvar\n  lT: T;\n  lRQLQuery: TRQLQueryWithName;\nbegin\n  lT := T.Create;\n  try\n    if not lT.FindRQLQueryByName(QueryName, lRQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedRQLQuery not found: %s', [QueryName]);\n    end;\n    Result := SelectRQL<T>(Format(lRQLQuery.RQLText, Params), MaxRecordCount);\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Where<T>(const SQLWhere: string;\n  const Params: array of Variant; const ParamTypes: array of TFieldType;\n  const OutList: TObjectList<T>): UInt32;\nvar\n  lAR: TMVCActiveRecord;\n  lFilter: string;\nbegin\n  lAR := T.Create;\n  try\n    lFilter := lAR.SQLGenerator.GetDefaultSQLFilter(True);\n    if SQLWhere.Trim.IsEmpty() or SQLWhere.Trim.StartsWith('/*limit*/') or SQLWhere.Trim.StartsWith('/*sort*/') then\n    begin\n      Result := Select<T>(lAR.GenerateSelectSQL + lFilter + SQLWhere, Params, ParamTypes, [], OutList);\n    end\n    else\n    begin\n      if lFilter.IsEmpty then\n      begin\n        Result := Select<T>(lAR.GenerateSelectSQL + ' WHERE ' + SQLWhere, Params, ParamTypes, [], OutList);\n      end\n      else\n      begin\n        Result := Select<T>(lAR.GenerateSelectSQL + lFilter + ' AND ' + SQLWhere, Params, ParamTypes, [], OutList);\n      end;\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nfunction TMVCActiveRecord.GetPartitionInfo: TPartitionInfo;\nvar\n  lRQLCompilerClass: TRQLCompilerClass;\nbegin\n  if fTableMap.fPartitionInfoInternal = nil then\n  begin\n    lRQLCompilerClass := TRQLCompilerRegistry.Instance.GetCompiler(GetBackEnd);\n    fTableMap.fPartitionInfoInternal := TPartitionInfo.BuildPartitionClause(fTableMap.fPartitionClause, lRQLCompilerClass);\n  end;\n  Result := fTableMap.fPartitionInfoInternal;\nend;\n\nfunction TMVCActiveRecord.GetPK: TValue;\nvar\n  lIsNullableType: Boolean;\nbegin\n  if not TryGetPKValue(Result, lIsNullableType) then\n  begin\n    if not lIsNullableType then\n    begin\n      raise EMVCActiveRecord.Create('Primary key not available');\n    end;\n  end;\nend;\n\nfunction TMVCActiveRecord.PKIsNull: Boolean;\nvar\n  lValue: TValue;\n  lIsNullableType: Boolean;\nbegin\n  if not PKIsNullable(lValue) then\n  begin\n    raise EMVCActiveRecord.Create('PK is not nullable');\n  end;\n  Result := not TryGetPKValue(lValue, lIsNullableType);\nend;\n\nfunction TMVCActiveRecord.PKIsNullable(out PKValue: TValue): Boolean;\nvar\n  lValue: TValue;\nbegin\n  PKValue := TryGetPKValue(lValue, Result);\nend;\n\nfunction TMVCActiveRecord.GetPrimaryKeyFieldType: TFieldType;\nbegin\n  Result := fTableMap.fPrimaryKeyFieldType;\nend;\n\nfunction TMVCActiveRecord.GetPrimaryKeyIsAutogenerated: Boolean;\nbegin\n  Result := foAutoGenerated in fTableMap.fPrimaryKeyOptions;\nend;\n\nclass function TMVCActiveRecord.GetScalar(const SQL: string; const Params: array of Variant): Variant;\nbegin\n  Result := CurrentConnection.ExecSQLScalar(SQL, Params);\nend;\n\nfunction TMVCActiveRecord.GetTableName: string;\nbegin\n  if Assigned(fTableMap) then\n  begin\n    Result := fTableMap.fTableName\n  end\n  else\n  begin\n    Result := '';\n  end;\nend;\n\nfunction TMVCActiveRecord.CheckAction(const aEntityAction: TMVCEntityAction; const aRaiseException: Boolean): Boolean;\nbegin\n  Result := aEntityAction in fTableMap.fEntityAllowedActions;\n  if (not Result) and aRaiseException then\n    raise EMVCActiveRecord.CreateFmt\n      ('Action [%s] not allowed on entity [%s]. [HINT] If this isn''t the expected behavior, add the entity action in MVCEntityActions attribute.',\n      [GetEnumName(TypeInfo(TMVCEntityAction), Ord(aEntityAction)), ClassName]) at ReturnAddress;\nend;\n\nclass function TMVCActiveRecordHelper.Count(const aClass: TMVCActiveRecordClass; const RQL: string): int64;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create;\n  try\n    // Up to 10.1 Berlin, here the compiler try to call the Count<T> introduced by the class helper\n    // Instead of the Count() which exists in \"TMVCActiveRecord\"\n    Result := lAR.InternalCount(RQL);\n  finally\n    lAR.Free;\n  end;\nend;\n\nfunction TMVCActiveRecordHelper.Count(const RQL: string = ''): int64;\nbegin\n  Result := InternalCount(RQL);\nend;\n\nclass function TMVCActiveRecordHelper.Count<T>(const RQL: string = ''): int64;\nbegin\n  Result := TMVCActiveRecord.Count(TMVCActiveRecordClass(T), RQL);\nend;\n\nclass function TMVCActiveRecordHelper.CountRQLByNamedQuery<T>(\n      const QueryName: string;\n      const Params: array of const): Int64;\nvar\n  lRQLQuery: TRQLQueryWithName;\n  lT: T;\nbegin\n  lT := T.Create;\n  try\n    if not lT.FindRQLQueryByName(QueryName, lRQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedRQLQuery not found: %s', [QueryName]);\n    end;\n    Result := Count<T>(Format(lRQLQuery.RQLText, Params));\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.CreateMVCActiveRecord<T>(\n  AQualifiedClassName: string; const AParams: TArray<TValue>): T;\nvar\n  lTmp: TObject;\nbegin\n  lTmp := TRttiUtils.CreateObject(AQualifiedClassName, AParams);\n  try\n    Result := lTmp as T;\n  except\n    on E: EInvalidCast do\n    begin\n      lTmp.Free;\n      raise EMVCActiveRecord.Create(AQualifiedClassName + ' is not a TMVCActiveRecord descendant');\n    end;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.DeleteRQL<T>(const RQL: string): int64;\nbegin\n  Result := TMVCActiveRecord.DeleteRQL(TMVCActiveRecordClass(T), RQL);\nend;\n\nclass function TMVCActiveRecordHelper.DeleteRQLByNamedQuery<T>(\n      const QueryName: String;\n      const Params: array of const): Int64;\nvar\n  lRQLQuery: TRQLQueryWithName;\n  lT: T;\nbegin\n  lT := T.Create;\n  try\n    if not lT.FindRQLQueryByName(QueryName, lRQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedRQLQuery not found: %s', [QueryName]);\n    end;\n    Result := DeleteRQL<T>(Format(lRQLQuery.RQLText, Params));\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.TryGetSQLQuery<T>(\n  const QueryName: String; out NamedSQLQuery: TSQLQueryWithName): Boolean;\nvar\n  lT: T;\nbegin\n  lT := T.Create;\n  try\n    Result := lT.FindSQLQueryByName(QueryName, NamedSQLQuery);\n  finally\n    lT.Free;\n  end;\nend;\n\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\nclass function TMVCActiveRecordHelper.UseTransactionContext: TMVCTransactionContext;\nbegin\n  Result := TMVCTransactionContext.Create(0);\nend;\n{$ENDIF}\n\nclass function TMVCActiveRecordHelper.TryGetRQLQuery<T>(\n  const QueryName: String; out NamedRQLQuery: TRQLQueryWithName): Boolean;\nvar\n  lT: T;\nbegin\n  lT := T.Create;\n  try\n    Result := lT.FindRQLQueryByName(QueryName, NamedRQLQuery);\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecord.CurrentConnection: TFDConnection;\nbegin\n  Result := ActiveRecordConnectionsRegistry.GetCurrent;\nend;\n\nfunction TMVCActiveRecord.GetConnection: TFDConnection;\nbegin\n  if fConn = nil then\n  begin\n    fConn := ActiveRecordConnectionsRegistry.GetCurrent;\n  end;\n  Result := fConn;\nend;\n\nclass function TMVCActiveRecord.GetConnectionByName(const ConnectionName: String): TFDConnection;\nbegin\n  Result := ActiveRecordConnectionsRegistry.GetByName(ConnectionName);\nend;\n\nfunction TMVCActiveRecord.GetCustomTableName: String;\nbegin\n  Result := '';\nend;\n\nprocedure TMVCActiveRecord.Delete(const RaiseExceptionIfNotFound: Boolean);\nvar\n  SQL: string;\n  lAffectedRows: int64;\nbegin\n  CheckAction(TMVCEntityAction.eaDelete);\n  OnValidation(TMVCEntityAction.eaDelete);\n  OnBeforeDelete;\n  if not Assigned(fTableMap.fPrimaryKey) then\n    raise EMVCActiveRecord.CreateFmt('Cannot delete %s without a primary key', [ClassName]);\n  SQL := SQLGenerator.CreateDeleteSQL(fTableMap, Self);\n  lAffectedRows := ExecNonQuery(SQL, false);\n  if (lAffectedRows = 0) and RaiseExceptionIfNotFound then\n  begin\n    if fTableMap.fIsVersioned then\n    begin\n      raise EMVCActiveRecordVersionedItemNotFound.CreateFmt('No record deleted for key [Entity: %s][PK: %s][Version: %d] - record or version not found',\n        [ClassName, fTableMap.fPrimaryKeyFieldName, fTableMap.VersionValueAsInt64For(Self)]);\n    end\n    else\n    begin\n      raise EMVCActiveRecordNotFound.CreateFmt('No record deleted for key [Entity: %s][PK: %s]',\n        [ClassName, fTableMap.fPrimaryKeyFieldName]);\n    end;\n  end;\n  OnAfterDelete;\nend;\n\nclass function TMVCActiveRecordHelper.DeleteAll(const aClass: TMVCActiveRecordClass): int64;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create;\n  try\n    Result := lAR.ExecNonQuery(lAR.SQLGenerator.CreateDeleteAllSQL(lAR.fTableMap.fTableName) +\n      lAR.SQLGenerator.GetDefaultSQLFilter(True));\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.DeleteRQL(const aClass: TMVCActiveRecordClass; const RQL: string): int64;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create(True);\n  try\n    Result := lAR.ExecNonQuery(lAR.SQLGenerator.CreateDeleteAllSQL(lAR.fTableMap.fTableName) +\n      lAR.SQLGenerator.CreateSQLWhereByRQL(RQL, lAR.GetMapping, false));\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecord.MapDatasetToObject(const DataSet: TDataSet; const Options: TMVCActiveRecordLoadOptions;\n  var Handled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.MapObjectToParams(const Params: TFDParams; var Handled: Boolean);\nbegin\n  // do nothing\nend;\n\nfunction TMVCActiveRecord.MapNullableTValueToParam(aValue: TValue; const aParam: TFDParam): Boolean;\nvar\n  lNullableType: TNullableType;\nbegin\n  Assert(aValue.Kind = tkRecord);\n  Result := True;\n  lNullableType := GetNullableType(aValue.TypeInfo);\n  case lNullableType of\n    ntInvalidNullableType:\n      begin\n        Exit(False);\n      end;\n    ntNullableString:\n      begin\n        if not aValue.AsType<NullableString>().HasValue then\n        begin\n          aParam.DataType := ftString;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableString>().Value;\n        end;\n      end;\n    ntNullableCurrency:\n      begin\n        if not aValue.AsType<NullableCurrency>().HasValue then\n        begin\n          aParam.DataType := TFieldType.ftCurrency;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableCurrency>().Value;\n        end;\n      end;\n    ntNullableBoolean:\n      begin\n        if not aValue.AsType<NullableBoolean>().HasValue then\n        begin\n          aParam.DataType := ftBoolean;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := TValue.From<Boolean>(aValue.AsType<NullableBoolean>().Value);\n        end;\n      end;\n    ntNullableTDate:\n      begin\n        if not aValue.AsType<NullableTDate>().HasValue then\n        begin\n          aParam.DataType := ftDate;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := TValue.From<TDate>(aValue.AsType<NullableTDate>().Value);\n        end;\n      end;\n    ntNullableTTime:\n      begin\n        if not aValue.AsType<NullableTTime>().HasValue then\n        begin\n          aParam.DataType := ftTime;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := TValue.From<TTime>(aValue.AsType<NullableTTime>().Value);\n        end;\n      end;\n    ntNullableTDateTime:\n      begin\n        if not aValue.AsType<NullableTDateTime>().HasValue then\n        begin\n          aParam.DataType := ftDateTime;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := TValue.From<TDateTime>(aValue.AsType<NullableTDateTime>().Value);\n        end;\n      end;\n    ntNullableSingle:\n      begin\n        if not aValue.AsType<NullableSingle>().HasValue then\n        begin\n          aParam.DataType := TFieldType.ftSingle;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableSingle>().Value;\n        end;\n      end;\n    ntNullableDouble:\n      begin\n        if not aValue.AsType<NullableDouble>().HasValue then\n        begin\n          aParam.DataType := TFieldType.ftFloat;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableDouble>().Value;\n        end;\n      end;\n    ntNullableExtended:\n      begin\n        if not aValue.AsType<NullableExtended>().HasValue then\n        begin\n          aParam.DataType := TFieldType.ftExtended;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableExtended>().Value;\n        end;\n      end;\n    ntNullableInt16:\n      begin\n        if not aValue.AsType<NullableInt16>().HasValue then\n        begin\n          aParam.DataType := ftInteger;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableInt16>().Value;\n        end;\n      end;\n    ntNullableUInt16:\n      begin\n        if not aValue.AsType<NullableUInt16>().HasValue then\n        begin\n          aParam.DataType := ftInteger;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableUInt16>().Value;\n        end;\n      end;\n    ntNullableInt32:\n      begin\n        if not aValue.AsType<NullableInt32>().HasValue then\n        begin\n          aParam.DataType := ftInteger;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableInt32>().Value;\n        end;\n      end;\n    ntNullableUInt32:\n      begin\n        if not aValue.AsType<NullableUInt32>().HasValue then\n        begin\n          aParam.DataType := ftInteger;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableUInt32>().Value;\n        end;\n      end;\n    ntNullableInt64:\n      begin\n        if not aValue.AsType<NullableInt64>().HasValue then\n        begin\n          aParam.DataType := ftLargeInt;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableInt64>().Value;\n        end;\n      end;\n    ntNullableUInt64:\n      begin\n        if not aValue.AsType<NullableUInt64>().HasValue then\n        begin\n          aParam.DataType := ftLargeInt;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := aValue.AsType<NullableUInt64>().Value;\n        end;\n      end;\n    ntNullableTGUID:\n      begin\n        if not aValue.AsType<NullableTGUID>().HasValue then\n        begin\n          aParam.DataType := TFieldType.ftGuid;\n          aParam.Clear;\n          Exit(True);\n        end\n        else\n        begin\n          aValue := TValue.From<TGuid>(aValue.AsType<NullableTGUID>().Value);\n        end;\n      end;\n  end; // case\n\n  // the nullable value contains a value, so let's call\n  // the \"non nullable\" version of this procedure\n  MapTValueToParam(aValue, aParam);\nend;\n\nprocedure TMVCActiveRecord.MapTValueToParam(aValue: TValue; const aParam: TFDParam);\nconst\n  MAX_STRING_PARAM_LENGTH = 1000; { Arbitrary value }\nvar\n  lStream: TStream;\n  lName: string;\nbegin\n{$IFDEF NEXTGEN}\n  lName := aValue.TypeInfo.NameFld.ToString;\n{$ELSE}\n  lName := string(aValue.TypeInfo.Name);\n{$ENDIF}\n  if (lName.StartsWith('Nullable', True) and (aValue.TypeInfo.Kind = tkRecord)) then\n  begin\n    if MapNullableTValueToParam(aValue, aParam) then\n    begin\n      Exit;\n    end;\n  end;\n\n  case aValue.TypeInfo.Kind of\n    tkUString:\n      begin\n        case aParam.DataType of\n          ftUnknown, ftWideString:\n            begin\n              if aValue.AsString.Length > MAX_STRING_PARAM_LENGTH then\n              begin\n                aParam.AsWideMemo := aValue.AsString;\n              end\n              else\n              begin\n                aParam.AsWideString := aValue.AsString;\n              end;\n            end;\n          ftString:\n            begin\n              if aValue.AsString.Length > MAX_STRING_PARAM_LENGTH then\n              begin\n                aParam.AsMemo := AnsiString(aValue.AsString);\n              end\n              else\n              begin\n                aParam.AsString := aValue.AsString;\n              end;\n            end;\n          ftWideMemo:\n            begin\n              aParam.AsWideMemo := aValue.AsString;\n            end;\n          ftMemo:\n            begin\n              aParam.AsMemo := AnsiString(aValue.AsString);\n            end;\n        else\n          begin\n            raise EMVCActiveRecord.CreateFmt('Invalid parameter type for (tkUString) [%s]', [lName]);\n          end;\n        end;\n      end;\n    tkString:\n      begin\n        case aParam.DataType of\n          ftUnknown, ftWideString:\n            begin\n              if aValue.AsString.Length > MAX_STRING_PARAM_LENGTH then\n              begin\n                aParam.AsWideMemo := aValue.AsString;\n              end\n              else\n              begin\n                aParam.AsWideString := aValue.AsString;\n              end;\n            end;\n          ftString:\n            begin\n              if aValue.AsString.Length > MAX_STRING_PARAM_LENGTH then\n              begin\n                aParam.AsMemo := AnsiString(aValue.AsString);\n              end\n              else\n              begin\n                aParam.AsString := aValue.AsString;\n              end;\n            end;\n          ftWideMemo:\n            begin\n              aParam.AsWideMemo := aValue.AsString;\n            end;\n          ftMemo:\n            begin\n              aParam.AsMemo := AnsiString(aValue.AsString);\n            end;\n        else\n          begin\n            raise EMVCActiveRecord.CreateFmt('Invalid parameter type for (tkString) [%s]', [lName]);\n          end;\n        end;\n      end;\n{$IF Defined(SeattleOrBetter)}\n    tkWideString:\n      begin\n        if aValue.AsString.Length > MAX_STRING_PARAM_LENGTH then\n        begin\n          aParam.AsWideMemo := aValue.AsString;\n        end\n        else\n        begin\n          aParam.AsWideString := aValue.AsString;\n        end\n      end;\n{$ENDIF}\n    tkInt64:\n      begin\n        aParam.AsLargeInt := aValue.AsInt64;\n      end;\n    tkInteger:\n      begin\n        aParam.AsInteger := aValue.AsInteger;\n      end;\n    tkEnumeration:\n      begin\n        if aValue.TypeInfo = TypeInfo(System.Boolean) then\n        begin\n          if aParam.DataTypeName.StartsWith('int', true) then\n          begin\n            aParam.AsInteger := IfThen(aValue.AsBoolean,1,0);\n          end\n          else\n          begin\n            aParam.AsBoolean := aValue.AsBoolean;\n          end;\n        end\n        else\n        begin\n          aParam.AsInteger := aValue.AsOrdinal;\n        end;\n      end;\n    tkFloat:\n      begin\n        if lName = 'TDate' then\n        begin\n          aParam.AsDate := Trunc(aValue.AsExtended);\n        end\n        else if lName = 'TDateTime' then\n        begin\n          aParam.AsDateTime := aValue.AsExtended;\n        end\n        else if lName = 'TTime' then\n        begin\n          aParam.AsTime := aValue.AsExtended;\n        end\n        else if lName = 'Currency' then\n        begin\n          aParam.AsCurrency := aValue.AsCurrency;\n        end\n        else\n        begin\n          aParam.AsFloat := aValue.AsExtended;\n        end;\n      end;\n    tkClass:\n      begin\n        if (aValue.AsObject <> nil) and (not aValue.IsInstanceOf(TStream)) then\n          raise EMVCActiveRecord.CreateFmt('Unsupported reference type for param %s: %s',\n            [aParam.Name, aValue.AsObject.ClassName]);\n        { .$IF Defined(SeattleOrBetter) }\n        // lStream := aValue.AsType<TStream>();\n        { .$ELSE }\n        lStream := aValue.AsType<TStream>();\n        { .$ENDIF }\n        if Assigned(lStream) then\n        begin\n          lStream.Position := 0;\n          aParam.LoadFromStream(lStream, ftBlob);\n        end\n        else\n        begin\n          aParam.DataType := TFieldType.ftBlob;\n          aParam.Clear;\n        end;\n      end;\n    tkRecord:\n      begin\n        if aValue.TypeInfo = TypeInfo(TGuid) then\n        begin\n          if SQLGenerator.HasNativeUUID then\n          begin\n            aParam.AsGuid := aValue.AsType<TGuid>\n          end\n          else\n          begin\n            aParam.AsString := GUIDToString(aValue.AsType<TGuid>);\n          end;\n        end\n        else if aValue.TypeInfo = TypeInfo(NullableTGUID) then\n        begin\n          if aValue.AsType<NullableTGUID>.HasValue then\n            aParam.AsGuid := aValue.AsType<NullableTGUID>.Value\n          else\n            aParam.Clear();\n        end\n        else\n        begin\n          raise EMVCActiveRecord.CreateFmt('Unsupported Record TypeKind (%d) for param %s',\n            [Ord(aValue.TypeInfo.Kind), aParam.Name]);\n        end;\n      end;\n  else\n    raise EMVCActiveRecord.CreateFmt('Unsupported TypeKind (%d) for param %s', [Ord(aValue.TypeInfo.Kind), aParam.Name]);\n  end;\nend;\n\nprocedure TMVCActiveRecord.LoadByDataset(const aDataSet: TDataSet; const aOptions: TMVCActiveRecordLoadOptions);\nvar\n  lItem: TPair<TRTTIField, TFieldInfo>;\n  lField: TField;\n  lHandled: Boolean;\nbegin\n  CheckAction(TMVCEntityAction.eaRetrieve);\n  OnBeforeLoad;\n\n  lHandled := false;\n  MapDatasetToObject(aDataSet, aOptions, lHandled);\n  if not lHandled then\n  begin\n    for lItem in fTableMap.fMap do\n    begin\n      if not lItem.Value.Selectable then\n      begin\n        Continue;\n      end;\n      lField := aDataSet.FindField(lItem.Value.FieldName);\n      if lField = nil then\n      begin\n        if TMVCActiveRecordLoadOption.loIgnoreNotExistentFields in aOptions then\n          Continue\n        else\n          raise EMVCActiveRecord.CreateFmt\n            ('Field [%s] not found in dataset. [HINT] If you dont need it, use loIgnoreNotExistentFields',\n            [lItem.Value.FieldName]);\n      end;\n      MapDataSetFieldToRTTIField(lField, lItem.Key, Self);\n    end;\n    if not fTableMap.fPrimaryKeyFieldName.IsEmpty then\n    begin\n      MapDataSetFieldToRTTIField(aDataSet.FieldByName(fTableMap.fPrimaryKeyFieldName), fTableMap.fPrimaryKey, Self);\n    end;\n  end;\n  OnAfterLoad;\nend;\n\nfunction TMVCActiveRecord.LoadByPK(const id: string; const aFieldType: TFieldType): Boolean;\nvar\n  lSQL: string;\n  lDataSet: TDataSet;\nbegin\n  CheckAction(TMVCEntityAction.eaRetrieve);\n  lSQL := SQLGenerator.CreateSelectByPKSQL(TableName, fTableMap.fMap,\n    fTableMap.fPrimaryKeyFieldName, fTableMap.fPrimaryKeyOptions);\n  OnBeforeExecuteSQL(lSQL);\n  lDataSet := ExecQuery(lSQL, [id], [aFieldType], GetConnection, True, False);\n  try\n    Result := not lDataSet.Eof;\n    if Result then\n    begin\n      LoadByDataset(lDataSet);\n    end;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\nfunction TMVCActiveRecord.LoadByPK(const id: string): Boolean;\nbegin\n  Result := LoadByPK(id, ftString);\nend;\n\nfunction TMVCActiveRecord.LoadByPK(const id: int64): Boolean;\nbegin\n  Result := LoadByPK(id.ToString, ftInteger);\nend;\n\nfunction TMVCActiveRecord.LoadByPK(const id: TGuid): Boolean;\nbegin\n  Result := LoadByPK(id.ToString, ftGuid);\nend;\n\nprocedure TMVCActiveRecord.OnAfterDelete;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnAfterInsert;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnAfterInsertOrUpdate;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnAfterLoad;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnAfterUpdate;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeDelete;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeExecuteSQL(var SQL: string);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeInsert;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeInsertOrUpdate;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeLoad;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnBeforeUpdate;\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.OnValidation(const EntityAction: TMVCEntityAction);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCActiveRecord.Refresh;\nbegin\n  if not GetPK.IsEmpty then\n  begin\n    case GetPrimaryKeyFieldType of\n      ftLargeInt: begin\n        LoadByPK(GetPK.AsInt64);\n      end;\n      ftInteger: begin\n        LoadByPK(GetPK.AsInteger);\n      end;\n      ftString: begin\n        LoadByPK(GetPK.AsString);\n      end;\n      ftGuid: begin\n        LoadByPK(GetPK.AsType<TGUID>);\n      end;\n      else\n        raise EMVCActiveRecord.Create('Unknown primary key type');\n    end;\n  end;\nend;\n\nprocedure TMVCActiveRecord.RemoveChildren(const ChildObject: TObject);\nbegin\n  if fChildren <> nil then\n  begin\n    fChildren.Extract(ChildObject);\n  end;\nend;\n\nprocedure TMVCActiveRecord.InvalidateConnection(const ReacquireAfterInvalidate: Boolean = false);\nbegin\n  FreeAndNil(fConn);\n  if ReacquireAfterInvalidate then\n  begin\n    EnsureConnection;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n  const Params: array of Variant): TMVCActiveRecordList;\nbegin\n  Result := Select(aClass, SQL, Params, nil);\nend;\n\nclass function TMVCActiveRecordHelper.Select(const aClass: TMVCActiveRecordClass; const SQL: string;\n  const Params: array of Variant; const Connection: TFDConnection): TMVCActiveRecordList;\nbegin\n  Result := TMVCActiveRecordList.Create;\n  try\n    Select(aClass, SQL, Params, Connection, Result);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectDataSet(const SQL: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const Unidirectional: Boolean; const DirectExecute: Boolean): TDataSet;\nbegin\n  Result := TMVCActiveRecord.ExecQuery(SQL, Params, ParamTypes, Unidirectional, DirectExecute);\nend;\n\nclass function TMVCActiveRecordHelper.Select<T>(const SQL: string; const Params: array of Variant;\n  const Options: TMVCActiveRecordLoadOptions): TObjectList<T>;\nbegin\n  Result := Select<T>(SQL, Params, [], Options);\nend;\n\nclass function TMVCActiveRecordHelper.SelectDataSet(const SQL: string; const Params: array of Variant;\n  const Unidirectional: Boolean; const DirectExecute: Boolean): TDataSet;\nbegin\n  Result := TMVCActiveRecord.ExecQuery(SQL, Params, Unidirectional, DirectExecute);\nend;\n\nfunction TMVCActiveRecordHelper.SelectRQL(const RQL: string; const MaxRecordCount: Integer): TMVCActiveRecordList;\nbegin\n  Result := InternalSelectRQL(RQL, MaxRecordCount);\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQL(const aClass: TMVCActiveRecordClass;\n  const RQL: string; const MaxRecordCount: Integer;\n  const OutList: TMVCActiveRecordList): UInt32;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create(True);\n  try\n    Result := lAR.InternalSelectRQL(RQL, MaxRecordCount, OutList);\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Select(\n  const MVCActiveRecordClass: TMVCActiveRecordClass; const SQL: string;\n  const Params: array of Variant; const ParamTypes: array of TFieldType;\n  const Options: TMVCActiveRecordLoadOptions;\n  const OutList: TMVCActiveRecordList): UInt32;\nvar\n  lDataSet: TDataSet;\n  lAR: TMVCActiveRecord;\nbegin\n  lDataSet := ExecQuery(SQL, Params, ParamTypes, True, False);\n  try\n    while not lDataSet.Eof do\n    begin\n      lAR := MVCActiveRecordClass.Create;\n      OutList.Add(lAR);\n      lAR.LoadByDataset(lDataSet, Options);\n      lDataSet.Next;\n    end;\n    Result := OutList.Count;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Select(\n  const MVCActiveRecordClass: TMVCActiveRecordClass; const SQL: string;\n  const Params: array of Variant; const ParamTypes: array of TFieldType;\n  const Options: TMVCActiveRecordLoadOptions): TMVCActiveRecordList;\nbegin\n  Result := TMVCActiveRecordList.Create;\n  try\n    Select(MVCActiveRecordClass, SQL, Params, ParamTypes, Options, Result);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Select<T>(const SQL: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const Options: TMVCActiveRecordLoadOptions; const OutList: TObjectList<T>): UInt32;\nvar\n  lDataSet: TDataSet;\n  lAR: TMVCActiveRecord;\nbegin\n  lDataSet := ExecQuery(SQL, Params, ParamTypes, True, False);\n  try\n    while not lDataSet.Eof do\n    begin\n      lAR := T.Create;\n      OutList.Add(lAR);\n      lAR.LoadByDataset(lDataSet, Options);\n      lDataSet.Next;\n    end;\n    Result := OutList.Count;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectByNamedQuery(\n  const MVCActiveRecordClass: TMVCActiveRecordClass; const QueryName: String;\n  const Params: array of Variant; const ParamTypes: array of TFieldType;\n  const Options: TMVCActiveRecordLoadOptions): TMVCActiveRecordList;\nvar\n  lT: TMVCActiveRecord;\n  lSQLQuery: TSQLQueryWithName;\nbegin\n  lT := MVCActiveRecordClass.Create;\n  try\n    if not lT.FindSQLQueryByName(QueryName, lSQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedSQLQuery \"%s\" not found for entity \"%s\"', [QueryName, lT.ClassName]);\n    end;\n    Result := Select(MVCActiveRecordClass, lSQLQuery.SQLText, Params, ParamTypes, Options);\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectByNamedQuery<T>(\n  const QueryName: String; const Params: array of Variant;\n  const ParamTypes: array of TFieldType;\n  const Options: TMVCActiveRecordLoadOptions): TObjectList<T>;\nvar\n  lT: T;\n  lSQLQuery: TSQLQueryWithName;\nbegin\n  lT := T.Create;\n  try\n    if not lT.FindSQLQueryByName(QueryName, lSQLQuery) then\n    begin\n      raise EMVCActiveRecord.CreateFmt('NamedSQLQuery \"%s\" not found for entity \"%s\"', [QueryName, lT.ClassName]);\n    end;\n    Result := Select<T>(lSQLQuery.SQLText, Params, ParamTypes, Options);\n  finally\n    lT.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Select<T>(const SQL: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const Options: TMVCActiveRecordLoadOptions): TObjectList<T>;\nbegin\n  Result := TObjectList<T>.Create(True);\n  try\n    Select<T>(SQL, Params, ParamTypes, Options, Result);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectOne<T>(const SQL: string; const Params: array of Variant;\n  const RaiseExceptionIfNotFound: Boolean): T;\nbegin\n  Result := SelectOne<T>(SQL, Params, [], [], RaiseExceptionIfNotFound);\nend;\n\nclass function TMVCActiveRecordHelper.SelectOne<T>(const SQL: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType; const Options: TMVCActiveRecordLoadOptions;\n  const RaiseExceptionIfNotFound: Boolean): T;\nvar\n  lList: TObjectList<T>;\nbegin\n  lList := Select<T>(SQL, Params, ParamTypes, Options);\n  try\n    if (lList.Count = 0) then\n    begin\n      if RaiseExceptionIfNotFound then\n        raise EMVCActiveRecordNotFound.Create('Got 0 rows when exactly 1 was expected')\n      else\n        Exit(nil);\n    end;\n    if lList.Count > 1 then\n    begin\n      raise EMVCActiveRecordNotFound.CreateFmt('Got %d rows when exactly 1 was expected', [lList.Count]);\n    end;\n    Result := lList.Extract(lList.First);\n  finally\n    lList.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQL<T>(const RQL: string; const MaxRecordCount: Integer): TObjectList<T>;\nvar\n  lAR: TMVCActiveRecord;\n  lSQL: string;\nbegin\n  lAR := T.Create;\n  try\n    lSQL := lAR.SQLGenerator.CreateSQLWhereByRQL(RQL, lAR.GetMapping, MaxRecordCount > -1, false, MaxRecordCount).Trim;\n    lSQL := TMVCSQLGenerator.RemoveInitialWhereKeyword(lSQL);\n    Result := Where<T>(lSQL, []);\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Where<T>(const SQLWhere: string; const Params: array of Variant;\n  const ParamTypes: array of TFieldType): TObjectList<T>;\nbegin\n  Result := TObjectList<T>.Create(True);\n  try\n    Where<T>(SQLWhere, Params, ParamTypes, Result);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.SelectRQL(const aClass: TMVCActiveRecordClass; const RQL: string;\n  const MaxRecordCount: Integer): TMVCActiveRecordList;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create(True);\n  try\n    Result := lAR.InternalSelectRQL(RQL, MaxRecordCount);\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecord.SetAttributes(const AttrName: string; const Value: TValue);\nvar\n  lProperty: TRttiProperty;\nbegin\n  if not TRttiUtils.ExistsProperty(Self, AttrName, lProperty) then\n  begin\n    raise EMVCActiveRecord.CreateFmt('Attribute [%s] not found', [AttrName]);\n  end;\n  SetPropertyValue(lProperty, Value);\nend;\n\nprocedure TMVCActiveRecord.SetPropertyValue(const aProp: TRttiProperty; const aValue: TValue);\nvar\n  lCurrValue: TValue;\n  lNullableString: NullableString;\n  lNullableUInt32: NullableUInt32;\n  lNullableUInt64: NullableUInt64;\n  lNullableInt64: NullableInt64;\n  lNullableBoolean: NullableBoolean;\n  lNullableTDateTime: NullableTDateTime;\n  lNullableTDate: NullableTDate;\n  lNullableTTime: NullableTTime;\nbegin\n  if aProp.GetValue(Self).Kind = tkRecord then\n  begin\n    lCurrValue := aProp.GetValue(Self);\n    if lCurrValue.IsType<NullableInt32> then\n    begin\n      if aValue.IsType<NullableInt32>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lCurrValue := TValue.From<NullableInt32>(IntToNullableInt(aValue.AsInteger));\n      end\n    end\n    else if lCurrValue.IsType<NullableInt64> then\n    begin\n      if aValue.IsType<NullableInt64>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lNullableInt64 := aValue.AsInt64;\n        lCurrValue := TValue.From<NullableInt64>(lNullableInt64);\n      end;\n    end\n    else if lCurrValue.IsType<NullableString> then\n    begin\n      if aValue.IsType<NullableString>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lNullableString := aValue.AsString;\n        lCurrValue := TValue.From<NullableString>(lNullableString);\n      end;\n    end\n    else if lCurrValue.IsType<NullableUInt32> then\n    begin\n      if aValue.IsType<NullableUInt32>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lNullableUInt32 := aValue.AsInteger;\n        lCurrValue.From<NullableUInt32>(lNullableUInt32);\n      end;\n    end\n    else if lCurrValue.IsType<NullableUInt64> then\n    begin\n      if aValue.IsType<NullableUInt64>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lNullableUInt64 := aValue.AsUInt64;\n        lCurrValue.From<NullableUInt64>(lNullableUInt64);\n      end;\n    end\n    else if lCurrValue.IsType<NullableBoolean> then\n    begin\n      if aValue.IsType<NullableBoolean>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n        lNullableBoolean := aValue.AsBoolean;\n        lCurrValue.From<NullableBoolean>(lNullableBoolean);\n      end;\n    end\n    else if lCurrValue.IsType<NullableTDateTime> then\n    begin\n      if aValue.IsType<NullableTDateTime>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n{$IF Defined(TOKYOORBETTER)}\n        lNullableTDateTime := TDateTime(aValue.AsExtended);\n{$ELSE}\n        lNullableTDateTime := aValue.AsExtended;\n{$ENDIF}\n        lCurrValue.From<NullableTDateTime>(lNullableTDateTime);\n      end;\n    end\n    else if lCurrValue.IsType<NullableTDate> then\n    begin\n      if aValue.IsType<NullableTDate>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n{$IF Defined(TOKYOORBETTER)}\n        lNullableTDate := TDate(aValue.AsExtended);\n{$ELSE}\n        lNullableTDate := aValue.AsExtended;\n{$ENDIF}\n        lCurrValue.From<NullableTDate>(lNullableTDate);\n      end;\n    end\n    else if lCurrValue.IsType<NullableTTime> then\n    begin\n      if aValue.IsType<NullableTTime>() then\n      begin\n        lCurrValue := aValue;\n      end\n      else\n      begin\n{$IF Defined(TOKYOORBETTER)}\n        lNullableTTime := TTime(aValue.AsExtended);\n{$ELSE}\n        lNullableTTime := aValue.AsExtended;\n{$ENDIF}\n        lCurrValue.From<NullableTTime>(lNullableTTime);\n      end;\n    end\n    else\n    begin\n      raise EMVCActiveRecord.Create('Invalid data type for dynamic property access');\n    end;\n    aProp.SetValue(Self, lCurrValue);\n  end\n  else\n  begin\n    aProp.SetValue(Self, aValue)\n  end;\nend;\n\nprocedure TMVCActiveRecord.SetPK(const aValue: TValue);\nvar\n  lPKValue: TValue;\nbegin\n  if fTableMap.fPrimaryKeyFieldName.IsEmpty then\n  begin\n    raise EMVCActiveRecord.Create('No primary key defined');\n  end;\n\n  if fTableMap.fPrimaryKey.GetValue(Self).Kind = tkRecord then\n  begin\n    lPKValue := fTableMap.fPrimaryKey.GetValue(Self);\n    if lPKValue.IsType<NullableInt32> { and aValue.IsType<NullableInt32>() } then\n    begin\n      if aValue.IsType<Int32> then\n      begin\n        lPKValue := TValue.From<NullableInt32>(IntToNullableInt(aValue.AsInteger));\n      end\n      else\n      begin\n        raise EMVCActiveRecord.Create('Invalid type for primary key');\n      end;\n    end\n    else if lPKValue.IsType<NullableInt64> then\n    begin\n      if aValue.IsType<NullableInt64>() then\n      begin\n        if aValue.AsType<NullableInt64>().HasValue then\n        begin\n          lPKValue := aValue;\n        end\n        else\n        begin\n          lPKValue.AsType<NullableInt64>().Clear;\n        end;\n      end\n      else if aValue.TypeInfo = TypeInfo(Integer) then\n      begin\n        lPKValue := TValue.From<NullableInt64>(aValue.AsInteger);\n      end\n      else if aValue.TypeInfo = TypeInfo(Int64) then\n      begin\n        lPKValue := TValue.From<NullableInt64>(aValue.AsInt64);\n      end\n      else if aValue.TypeInfo = TypeInfo(UInt64) then\n      begin\n        lPKValue := TValue.From<NullableInt64>(aValue.AsUInt64);\n      end\n      else\n      begin\n        raise EMVCActiveRecord.CreateFmt(\n          'Invalid type for %s primary key [HINT] Double check if TypeInfo(PK) is equal to TypeInfo(Value)', [lPKValue.TypeInfo.Name]);\n      end;\n    end\n    else if lPKValue.IsType<NullableString> and aValue.IsType<NullableString>() then\n    begin\n      if aValue.AsType<NullableString>().HasValue then\n      begin\n        lPKValue := aValue;\n      end\n      else\n      begin\n        lPKValue.AsType<NullableString>().Clear;\n      end;\n    end\n    else if lPKValue.IsType<NullableUInt32> and aValue.IsType<NullableUInt32>() then\n    begin\n      if aValue.AsType<NullableUInt32>().HasValue then\n      begin\n        lPKValue := aValue;\n      end\n      else\n      begin\n        lPKValue.AsType<NullableUInt32>().Clear;\n      end;\n    end\n    else if lPKValue.IsType<NullableUInt64> then\n    begin\n      if aValue.IsType<NullableUInt64>() then\n      begin\n        if aValue.AsType<NullableUInt64>().HasValue then\n        begin\n          lPKValue := aValue;\n        end\n        else\n        begin\n          lPKValue.AsType<NullableUInt64>().Clear;\n        end\n      end\n      else if aValue.TypeInfo = TypeInfo(Integer) then\n      begin\n        lPKValue := TValue.From<NullableUInt64>(aValue.AsInteger);\n      end\n      else if aValue.TypeInfo = TypeInfo(Int64) then\n      begin\n        lPKValue := TValue.From<NullableUInt64>(aValue.AsInt64);\n      end\n      else if aValue.TypeInfo = TypeInfo(UInt64) then\n      begin\n        lPKValue := TValue.From<NullableUInt64>(aValue.AsUInt64);\n      end\n      else\n      begin\n        raise EMVCActiveRecord.CreateFmt(\n          'Invalid type for %s primary key [HINT] Double check if TypeInfo(PK) is equal to TypeInfo(Value)', [lPKValue.TypeInfo.Name]);\n      end;\n    end\n    else\n    begin\n      raise EMVCActiveRecord.Create\n        ('Invalid type for primary key [HINT] Double check if TypeInfo(PK) is equal to TypeInfo(Value)');\n    end;\n    fTableMap.fPrimaryKey.SetValue(Self, lPKValue);\n  end\n  else\n  begin\n    fTableMap.fPrimaryKey.SetValue(Self, aValue)\n  end;\nend;\n\nprocedure TMVCActiveRecord.SetPrimaryKeyIsAutogenerated(const Value: Boolean);\nbegin\n  if Value then\n  begin\n    Include(fTableMap.fPrimaryKeyOptions, foAutoGenerated);\n  end\n  else\n  begin\n    Exclude(fTableMap.fPrimaryKeyOptions, foAutoGenerated);\n  end;\nend;\n\nprocedure TMVCActiveRecord.SetInitialObjVersion(const TableMap: TMVCTableMap;\n  const ARInstance: TMVCActiveRecord);\nbegin\n  TableMap.fVersionRTTIField.SetValue(ARInstance, OBJECT_VERSION_STARTING_VALUE_AS_INT);\nend;\n\nfunction TMVCActiveRecord.SQLGenerator: TMVCSQLGenerator;\nvar\n  lSQLGeneratorClass: TMVCSQLGeneratorClass;\nbegin\n  if not Assigned(fSQLGenerator) then\n  begin\n    GetConnection.Connected := True;\n    lSQLGeneratorClass := TMVCSQLGeneratorRegistry.Instance.GetSQLGenerator(GetBackEnd);\n    fSQLGenerator := lSQLGeneratorClass.Create(GetMapping, fTableMap.fDefaultRQLFilter, GetPartitionInfo);\n  end;\n  Result := fSQLGenerator;\nend;\n\nprocedure TMVCActiveRecord.Store;\nvar\n  lValue: TValue;\n  lRes: Boolean;\n  lIsNullableType: Boolean;\nbegin\n  lRes := TryGetPKValue(lValue, lIsNullableType);\n  if not lIsNullableType then\n  begin\n    raise EMVCActiveRecord.Create('Store can be used only with nullable PKs [HINT] Use NullableInt64 as PK');\n  end;\n  if lRes then\n  begin\n    Update;\n  end\n  else\n  begin\n    Insert;\n  end;\nend;\n\nfunction TMVCActiveRecord.TableInfo: string;\nvar\n  KeyValue: TPair<TRTTIField, TFieldInfo>;\nbegin\n  Result := 'Table Name: ' + TableName;\n  for KeyValue in fTableMap.fMap do\n    Result := Result + sLineBreak + #9 + KeyValue.Key.Name + ' = ' + KeyValue.Value.FieldName;\nend;\n\nfunction TMVCActiveRecord.TryGetPKValue(var Value: TValue; out IsNullableType: Boolean): Boolean;\nbegin\n  IsNullableType := false;\n  if fTableMap.fPrimaryKeyFieldName.IsEmpty then\n    raise EMVCActiveRecord.Create('No primary key defined');\n  Value := fTableMap.fPrimaryKey.GetValue(Self);\n  if Value.Kind = tkRecord then\n  begin\n    if Value.IsType<NullableInt32>() then\n    begin\n      Result := Value.AsType<NullableInt32>().TryHasValue(Value);\n    end\n    else if Value.IsType<NullableInt64>() then\n    begin\n      Result := Value.AsType<NullableInt64>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableUInt32>() then\n    begin\n      Result := Value.AsType<NullableUInt32>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableUInt64>() then\n    begin\n      Result := Value.AsType<NullableUInt64>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableInt16>() then\n    begin\n      Result := Value.AsType<NullableInt16>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableUInt16>() then\n    begin\n      Result := Value.AsType<NullableUInt16>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableString>() then\n    begin\n      Result := Value.AsType<NullableString>().TryHasValue(Value)\n    end\n    else if Value.IsType<NullableTGUID>() then\n    begin\n      Result := Value.AsType<NullableTGUID>().TryHasValue(Value)\n    end\n    else\n      raise EMVCActiveRecord.Create\n        ('Invalid primary key type [HINT: Use Int64, String, NullableInt64 or NullableString, so that Store method is available too.]');\n    IsNullableType := True;\n  end\n  else\n  begin\n    Result := not Value.IsEmpty;\n  end;\nend;\n\nprocedure TMVCActiveRecord.Update(const RaiseExceptionIfNotFound: Boolean = True);\nvar\n  SQL: string;\n  lAffectedRows: int64;\nbegin\n  CheckAction(TMVCEntityAction.eaUpdate);\n  OnValidation(TMVCEntityAction.eaUpdate);\n  OnBeforeUpdate;\n  OnBeforeInsertOrUpdate;\n  if fTableMap.fMap.WritableFieldsCount = 0 then\n  begin\n    raise EMVCActiveRecord.CreateFmt\n      ('Cannot update an entity if no fields are writeable. Class [%s] mapped on table [%s]', [ClassName, TableName]);\n  end;\n  SQL := SQLGenerator.CreateUpdateSQL(fTableMap, Self);\n  lAffectedRows := ExecNonQuery(SQL, false);\n  if (lAffectedRows = 0) and RaiseExceptionIfNotFound then\n  begin\n    if fTableMap.fIsVersioned then\n    begin\n      raise EMVCActiveRecordVersionedItemNotFound.CreateFmt('No record updated for key [Entity: %s][PK: %s][Version: %d] - record or version not found',\n        [ClassName, fTableMap.fPrimaryKeyFieldName, fTableMap.VersionValueAsInt64For(Self)]);\n    end\n    else\n    begin\n      raise EMVCActiveRecordNotFound.CreateFmt('No record updated for key [Entity: %s][PK: %s]',\n        [ClassName, fTableMap.fPrimaryKeyFieldName]);\n    end;\n  end;\n  if fTableMap.fIsVersioned then\n  begin\n    AdvanceVersioning(fTableMap, Self);\n  end;\n  OnAfterUpdate;\n  OnAfterInsertOrUpdate;\nend;\n\nclass function TMVCActiveRecordHelper.Where(const aClass: TMVCActiveRecordClass;\n  const SQLWhere: string; const Params: array of Variant;\n  const Connection: TFDConnection; const OutList: TMVCActiveRecordList): UInt32;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create;\n  try\n    Result := Select(aClass, lAR.GenerateSelectSQL + SQLWhere, Params, Connection, OutList);\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecord.AddChildren(const ChildObject: TObject);\nbegin\n  if fChildren = nil then\n  begin\n    fChildren := TObjectList<TObject>.Create(True);\n  end;\n  if not(fChildren.Contains(ChildObject)) and (not(ChildObject = Self)) then\n  begin\n    fChildren.Add(ChildObject);\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.All(const aClass: TMVCActiveRecordClass): TObjectList<TMVCActiveRecord>;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := aClass.Create;\n  try\n    Result := Select(aClass,\n      lAR.GenerateSelectSQL + lAR.SQLGenerator.GetDefaultSQLFilter(True), []);\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecord.AdvanceVersioning(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord);\nvar\n  lCurrVersion: Int64;\nbegin\n  lCurrVersion := TableMap.VersionValueAsInt64For(ARInstance);\n  Inc(lCurrVersion);\n  TableMap.fVersionRTTIField.SetValue(ARInstance, lCurrVersion);\nend;\n\nprocedure TMVCActiveRecord.Assign(ActiveRecord: TMVCActiveRecord);\nbegin\n  //do nothing\nend;\n\nclass function TMVCActiveRecordHelper.All(const aQualifiedClassName: String): TObjectList<TMVCActiveRecord>;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := TMVCActiveRecord.CreateMVCActiveRecord<TMVCActiveRecord>(aQualifiedClassName, []);\n  try\n    Result := Select(TMVCActiveRecordClass(lAR.ClassType),\n      lAR.GenerateSelectSQL + lAR.SQLGenerator.GetDefaultSQLFilter(True), []);\n  finally\n    lAr.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.All<T>: TObjectList<T>;\nvar\n  lAR: TMVCActiveRecord;\nbegin\n  lAR := T.Create;\n  try\n    Result := Select<T>(\n      lAR.GenerateSelectSQL + lAR.SQLGenerator.GetDefaultSQLFilter(True), []);\n  finally\n    lAR.Free;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Where(const aClass: TMVCActiveRecordClass; const SQLWhere: string;\n  const Params: array of Variant): TMVCActiveRecordList;\nbegin\n  Result := Where(aClass, SQLWhere, Params, nil);\nend;\n\nclass function TMVCActiveRecordHelper.Where(const aClass: TMVCActiveRecordClass; const SQLWhere: string;\n  const Params: array of Variant; const Connection: TFDConnection): TMVCActiveRecordList;\nbegin\n  Result := TMVCActiveRecordList.Create;\n  try\n    Where(aClass, SQLWhere, Params, Connection, Result);\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecordHelper.Where<T>(const SQLWhere: string; const Params: array of Variant): TObjectList<T>;\nbegin\n  Result := Where<T>(SQLWhere, Params, []);\nend;\n\nclass function TMVCActiveRecordHelper.Merge<T>(CurrentList, NewList: TObjectList<T>; const MergeMode: TMergeMode): IMVCMultiExecutor<T>;\nvar\n  I: Integer;\n  lFoundAtIndex: Integer;\n  lUnitOfWork: IMVCUnitOfWork<T>;\n  lPKType: TFieldType;\n  lNeedsToBeUpdated: Boolean;\nbegin\n  lUnitOfWork := TMVCUnitOfWork<T>.Create;\n  if mmDelete in MergeMode then\n  begin\n    lUnitOfWork.RegisterDelete(CurrentList);\n  end;\n  if NewList.Count > 0 then\n  begin\n    lPKType := NewList[0].GetPrimaryKeyFieldType;\n    for I := 0 to NewList.Count - 1 do\n    begin\n      if NewList[I].PKIsNull then\n      begin\n        if mmInsert in MergeMode then\n        begin\n          lUnitOfWork.RegisterInsert(NewList[I]);\n        end;\n        Continue;\n      end;\n\n      case lPKType of\n        ftString:\n          begin\n            lNeedsToBeUpdated := TMVCUnitOfWork<T>.KeyExistsString(CurrentList, NewList[I].GetPK.AsString,\n              lFoundAtIndex);\n          end;\n        ftInteger:\n          begin\n            lNeedsToBeUpdated := TMVCUnitOfWork<T>.KeyExistsInt(CurrentList, NewList[I].GetPK.AsInteger, lFoundAtIndex);\n          end;\n        ftLargeInt:\n          begin\n            lNeedsToBeUpdated := TMVCUnitOfWork<T>.KeyExistsInt64(CurrentList, NewList[I].GetPK.AsInt64, lFoundAtIndex);\n          end;\n      else\n        raise EMVCActiveRecord.Create('Invalid primary key type for merge');\n      end;\n\n      if lNeedsToBeUpdated then\n      begin\n        if mmUpdate in MergeMode then\n        begin\n          lUnitOfWork.RegisterUpdate(NewList[I])\n        end;\n      end\n      else\n      begin\n        if mmInsert in MergeMode then\n        begin\n          lUnitOfWork.RegisterInsert(NewList[I]);\n        end;\n      end;\n    end;\n  end;\n  Result := lUnitOfWork as IMVCMultiExecutor<T>;\nend;\n\n{ TMVCEntitiesRegistry }\n\nprocedure TMVCEntitiesRegistry.AddEntity(const aURLSegment: string; const aActiveRecordClass: TMVCActiveRecordClass);\nbegin\n  fEntitiesDict.AddOrSetValue(aURLSegment.ToLower, aActiveRecordClass);\nend;\n\nprocedure TMVCEntitiesRegistry.AddEntityProcessor(const aURLSegment: string;\n  const aEntityProcessor: IMVCEntityProcessor);\nbegin\n  fProcessorsDict.Add(aURLSegment, aEntityProcessor);\nend;\n\nconstructor TMVCEntitiesRegistry.Create;\nbegin\n  inherited;\n  fEntitiesDict := TDictionary<string, TMVCActiveRecordClass>.Create;\n  fProcessorsDict := TDictionary<string, IMVCEntityProcessor>.Create;\nend;\n\ndestructor TMVCEntitiesRegistry.Destroy;\nbegin\n  fEntitiesDict.Free;\n  fProcessorsDict.Free;\n  inherited;\nend;\n\nfunction TMVCEntitiesRegistry.FindEntityClassByURLSegment(const aURLSegment: string;\n  out aMVCActiveRecordClass: TMVCActiveRecordClass): Boolean;\nbegin\n  Result := fEntitiesDict.TryGetValue(aURLSegment.ToLower, aMVCActiveRecordClass);\nend;\n\nfunction TMVCEntitiesRegistry.FindProcessorByURLSegment(const aURLSegment: string;\n  out aMVCEntityProcessor: IMVCEntityProcessor): Boolean;\nbegin\n  Result := fProcessorsDict.TryGetValue(aURLSegment.ToLower, aMVCEntityProcessor);\nend;\n\nfunction TMVCEntitiesRegistry.GetEntities: TArray<String>;\nbegin\n  Result := fEntitiesDict.Keys.ToArray;\nend;\n\nfunction TMVCEntitiesRegistry.GetURLSegmentWithEntities: TArray<TMVCEntityMapping>;\nvar\n  lPair: TMVCEntityMapping;\n  i: Integer;\nbegin\n  SetLength(Result, fEntitiesDict.Count);\n  i := 0;\n  for lPair in fEntitiesDict do\n  begin\n    Result[I] := lPair;\n    Inc(i);\n  end;\nend;\n\n{ EMVCActiveRecord }\n\nconstructor EMVCActiveRecord.Create(const AMsg: string);\nbegin\n  inherited Create(http_status.BadRequest, AMsg);\nend;\n\n{ EntityActionsAttribute }\n\nconstructor MVCEntityActionsAttribute.Create(const aEntityAllowedActions: TMVCEntityActions);\nbegin\n  inherited Create;\n  EntityAllowedActions := aEntityAllowedActions;\nend;\n\n{ TMVCActiveRecordList }\n\nconstructor TMVCActiveRecordList.Create;\nbegin\n  inherited Create(True);\nend;\n\n{ TMVCSQLGeneratorRegistry }\n\nconstructor TMVCSQLGeneratorRegistry.Create;\nbegin\n  inherited;\n  fSQLGenerators := TDictionary<string, TMVCSQLGeneratorClass>.Create;\nend;\n\nclass constructor TMVCSQLGeneratorRegistry.Create;\nbegin\n  cConnectionsLock := TObject.Create;\nend;\n\nclass destructor TMVCSQLGeneratorRegistry.Destroy;\nbegin\n  cInstance.Free;\n  cConnectionsLock.Free;\nend;\n\ndestructor TMVCSQLGeneratorRegistry.Destroy;\nbegin\n  fSQLGenerators.Free;\n  inherited;\nend;\n\nfunction TMVCSQLGeneratorRegistry.GetSQLGenerator(const aBackend: string): TMVCSQLGeneratorClass;\nbegin\n  if not fSQLGenerators.TryGetValue(aBackend, Result) then\n  begin\n    raise ERQLCompilerNotFound.CreateFmt('SQLGenerator not found for \"%s\". [HINT] Include unit \"MVCFramework.SQLGenerators.%s.pas\" somewhere in the project code, if available.', [aBackend, aBackend]);\n  end;\nend;\n\nclass function TMVCSQLGeneratorRegistry.Instance: TMVCSQLGeneratorRegistry;\nbegin\n  if not Assigned(cInstance) then\n  begin\n    TMonitor.Enter(cConnectionsLock);\n    try\n      if not Assigned(cInstance) then\n      begin\n        cInstance := TMVCSQLGeneratorRegistry.Create;\n      end;\n    finally\n      TMonitor.Exit(cConnectionsLock);\n    end;\n  end;\n  Result := cInstance;\nend;\n\nprocedure TMVCSQLGeneratorRegistry.RegisterSQLGenerator(const aBackend: string;\n  const aRQLBackendClass: TMVCSQLGeneratorClass);\nbegin\n  fSQLGenerators.AddOrSetValue(aBackend, aRQLBackendClass);\nend;\n\nprocedure TMVCSQLGeneratorRegistry.UnRegisterSQLGenerator(const aBackend: string);\nbegin\n  fSQLGenerators.Remove(aBackend);\nend;\n\n{ TMVCSQLGenerator }\n\nconstructor TMVCSQLGenerator.Create(Mapping: TMVCFieldsMapping; const DefaultRQLFilter: string;\n  const PartitionInfo: TPartitionInfo);\nbegin\n  inherited Create;\n  fMapping := Mapping;\n  fDefaultRQLFilter := DefaultRQLFilter;\n  fPartitionInfo := PartitionInfo;\n  GetCompiler;\n  if not fDefaultRQLFilter.IsEmpty then\n  begin\n    GetRQLParser.Execute(fDefaultRQLFilter, fDefaultSQLFilter, GetCompiler, false, True);\n    fDefaultSQLFilter := TMVCSQLGenerator.RemoveInitialWhereKeyword(fDefaultSQLFilter);\n  end;\nend;\n\nfunction TMVCSQLGenerator.GetMapping: TMVCFieldsMapping;\nbegin\n  Result := fMapping;\nend;\n\nfunction TMVCSQLGenerator.GetParamNameForSQL(const FieldName: string): string;\nbegin\n  Result := fCompiler.GetParamNameForSQL(FieldName);\nend;\n\nfunction TMVCSQLGenerator.CreateDeleteAllSQL(const TableName: string): string;\nbegin\n  Result := 'DELETE FROM ' + GetTableNameForSQL(TableName);\nend;\n\nfunction TMVCSQLGenerator.CreateDeleteSQL(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord): string;\nbegin\n  Result := CreateDeleteAllSQL(TableMap.fTableName) + ' WHERE ' + GetFieldNameForSQL(TableMap.fPrimaryKeyFieldName) + '=:' +\n    GetParamNameForSQL(TableMap.fPrimaryKeyFieldName);\n  if TableMap.fIsVersioned then\n  begin\n    Result := Result + ' and ' + GetFieldNameForSQL(TableMap.fVersionFieldName) + ' = ' + IntToStr(TableMap.VersionValueAsInt64For(ARInstance));\n  end;\nend;\n\nfunction TMVCSQLGenerator.CreateSelectByPKSQL(const TableName: string; const Map: TFieldsMap; const PKFieldName: string;\n  const PKOptions: TMVCActiveRecordFieldOptions): string;\nbegin\n  if PKFieldName.IsEmpty then\n  begin\n    raise EMVCActiveRecord.Create\n      ('No primary key provided. [HINT] Define a primary key field adding foPrimaryKey in field options.');\n  end;\n\n  Result := CreateSelectSQL(TableName, Map, PKFieldName, PKOptions) + ' WHERE ' + GetFieldNameForSQL(PKFieldName) +\n    '= :' + GetParamNameForSQL(PKFieldName) + GetDefaultSQLFilter(false, True);\nend;\n\nfunction TMVCSQLGenerator.CreateSelectCount(const TableName: string): string;\nbegin\n  { do not add SQLFilter here! }\n  Result := 'SELECT count(*) FROM ' + GetTableNameForSQL(TableName);\nend;\n\nfunction TMVCSQLGenerator.CreateSelectSQL(const TableName: string; const Map: TFieldsMap; const PKFieldName: string;\n  const PKOptions: TMVCActiveRecordFieldOptions): string;\nbegin\n  Result := 'SELECT ' + TableFieldsDelimited(Map, PKFieldName, ',') + ' FROM ' + GetTableNameForSQL(TableName);\nend;\n\nfunction TMVCSQLGenerator.CreateSQLWhereByRQL(const RQL: string; const Mapping: TMVCFieldsMapping;\n  const UseArtificialLimit, UseFilterOnly: Boolean; const MaxRecordCount: Int32): string;\nbegin\n  GetRQLParser.Execute(MergeDefaultRQLFilter(RQL), Result, GetCompiler, UseArtificialLimit, UseFilterOnly,\n    MaxRecordCount);\nend;\n\nfunction TMVCSQLGenerator.CreateUpdateSQL(const TableMap: TMVCTableMap; const ARInstance: TMVCActiveRecord): string;\nvar\n  lPair: TPair<TRTTIField, TFieldInfo>;\n//  I: Integer;\nbegin\n  Result := 'UPDATE ' + GetTableNameForSQL(TableMap.fTableName) + ' SET ';\n  for lPair in TableMap.fMap do\n  begin\n    if lPair.Value.IsVersion then\n    begin\n      Result := Result + GetFieldNameForSQL(lPair.Value.FieldName) + ' = ' +\n        GetParamNameForSQL(lPair.Value.FieldName) + ' + 1,';\n    end else if lPair.Value.Updatable then\n    begin\n      Result := Result + GetFieldNameForSQL(lPair.Value.FieldName) + ' = :' +\n        GetParamNameForSQL(lPair.Value.FieldName) + ',';\n    end;\n  end;\n  { partition }\n//  for I := 0 to fPartitionInfo.FieldNames.Count - 1 do\n//  begin\n//    Result := Result + GetFieldNameForSQL(fPartitionInfo.FieldNames[I]) + ' = :' +\n//      GetParamNameForSQL(fPartitionInfo.FieldNames[I]) + ',';\n//  end;\n  { end-partitioning }\n  Result[Length(Result)] := ' ';\n  if not TableMap.fPrimaryKeyFieldName.IsEmpty then\n  begin\n    Result := Result + ' where ' +\n      GetFieldNameForSQL(TableMap.fPrimaryKeyFieldName) + '= :' + GetParamNameForSQL(TableMap.fPrimaryKeyFieldName);\n    if TableMap.fIsVersioned then\n    begin\n      Result := Result + ' and ' + GetFieldNameForSQL(TableMap.fVersionFieldName) +\n        ' = ' + TableMap.VersionValueAsInt64For(ARInstance).ToString\n    end;\n  end\n  else\n  begin\n    raise EMVCActiveRecord.Create('Cannot perform an update without an entity primary key');\n  end;\nend;\n\ndestructor TMVCSQLGenerator.Destroy;\nbegin\n  fCompiler.Free;\n  fRQL2SQL.Free;\n  inherited;\nend;\n\nfunction TMVCSQLGenerator.GetCompiler: TRQLCompiler;\nbegin\n  if fCompiler = nil then\n  begin\n    fCompiler := GetCompilerClass.Create(fMapping);\n  end;\n  Result := fCompiler;\nend;\n\nfunction TMVCSQLGenerator.GetDefaultSQLFilter(const IncludeWhereClause: Boolean;\n  const IncludeAndClauseBeforeFilter: Boolean): String;\nbegin\n  Result := MergeSQLFilter(fPartitionInfo.SQLFilter, fDefaultSQLFilter);\n  if not Result.IsEmpty then\n  begin\n    if IncludeWhereClause then\n    begin\n      Result := ' WHERE ' + Result;\n    end\n    else\n    begin\n      if IncludeAndClauseBeforeFilter then\n        Result := ' and ' + Result;\n    end;\n  end;\nend;\n\nfunction TMVCSQLGenerator.GetFieldNameForSQL(const FieldName: string): string;\nbegin\n  Result := fCompiler.GetFieldNameForSQL(FieldName);\nend;\n\nfunction TMVCSQLGenerator.GetRQLParser: TRQL2SQL;\nbegin\n  if fRQL2SQL = nil then\n  begin\n    fRQL2SQL := TRQL2SQL.Create;\n  end;\n  Result := fRQL2SQL;\nend;\n\nfunction TMVCSQLGenerator.GetSequenceValueSQL(const PKFieldName: string; const SequenceName: string;\n  const Step: Integer = 1): string;\nbegin\n  Result := '';\nend;\n\nfunction TMVCSQLGenerator.GetTableNameForSQL(const TableName: string): string;\nbegin\n  Result := fCompiler.GetTableNameForSQL(TableName);\nend;\n\nfunction TMVCSQLGenerator.HasNativeUUID: Boolean;\nbegin\n  Result := false;\nend;\n\nfunction TMVCSQLGenerator.HasReturning: Boolean;\nbegin\n  Result := True;\nend;\n\nfunction TMVCSQLGenerator.HasSequences: Boolean;\nbegin\n  Result := True;\nend;\n\nfunction TMVCSQLGenerator.MergeDefaultRQLFilter(const RQL: String): String;\nvar\n  lRQLFilterPart, lRQLSortingAndLimitPart: String;\n  lSemicolonPos: Integer;\nbegin\n  lRQLFilterPart := RQL;\n  lRQLSortingAndLimitPart := '';\n  lSemicolonPos := RQL.IndexOf(';');\n  if lSemicolonPos > -1 then\n  begin\n    lRQLFilterPart := RQL.Substring(0, lSemicolonPos);\n    lRQLSortingAndLimitPart := RQL.Substring(lSemicolonPos + 1, 1000);\n  end;\n\n  { this is not the best solution, but it works... }\n  if lRQLFilterPart.Contains('sort') or lRQLFilterPart.Contains('limit') then\n  begin\n    lRQLSortingAndLimitPart := lRQLFilterPart;\n    lRQLFilterPart := '';\n  end;\n\n  if (not fDefaultRQLFilter.IsEmpty) or (not fPartitionInfo.RQLFilter.IsEmpty) then\n  begin\n    Result := 'and(';\n    if not fDefaultRQLFilter.IsEmpty then\n    begin\n      Result := Result + fDefaultRQLFilter;\n    end;\n    if not fPartitionInfo.RQLFilter.IsEmpty then\n    begin\n      Result := Result + ',' + fPartitionInfo.RQLFilter;\n    end;\n    if not lRQLFilterPart.IsEmpty then\n    begin\n      Result := Result + ',' + lRQLFilterPart;\n    end;\n    Result := Result + ')';\n  end\n  else\n  begin\n    Exit(RQL);\n  end;\n\n  if not lRQLSortingAndLimitPart.IsEmpty then\n  begin\n    Result := Result + ';' + lRQLSortingAndLimitPart;\n  end;\nend;\n\nfunction TMVCSQLGenerator.MergeSQLFilter(const PartitionSQL, FilteringSQL: String): String;\nbegin\n  Result := '';\n  if PartitionSQL + FilteringSQL = '' then\n  begin\n    Exit;\n  end;\n  //if PartitionSQL.IsEmpty and (not FilteringSQL.IsEmpty) then\n  if not FilteringSQL.IsEmpty then\n  begin\n    Exit(FilteringSQL); //ignore partitioning while reading if filtering is present\n  end;\n  if FilteringSQL.IsEmpty and (not PartitionSQL.IsEmpty) then\n  begin\n    Exit(PartitionSQL);\n  end;\n//  Result := '((' + PartitionSQL + ') and (' + FilteringSQL + '))';\nend;\n\nclass function TMVCSQLGenerator.RemoveInitialWhereKeyword(const SQLFilter: String): String;\nbegin\n  Result := SQLFilter.TrimLeft;\n  if Result.StartsWith('where', True) then\n  begin\n    Result := Result.Remove(0, 5);\n  end;\nend;\n\nfunction TMVCSQLGenerator.TableFieldsDelimited(const Map: TFieldsMap; const PKFieldName: string;\n  const Delimiter: string): string;\nvar\n  lPair: TPair<TRTTIField, TFieldInfo>;\nbegin\n  for lPair in Map do\n  begin\n    if lPair.Value.Selectable then\n    begin\n      Result := Result + GetFieldNameForSQL(lPair.Value.FieldName) + Delimiter;\n    end;\n  end;\n  Result := Copy(Result, 1, Length(Result) - Length(Delimiter));\n  if not PKFieldName.IsEmpty then\n  begin\n    if not Result.IsEmpty then\n    begin\n      Result := GetFieldNameForSQL(PKFieldName) + ', ' + Result\n    end\n    else\n    begin\n      Result := GetFieldNameForSQL(PKFieldName)\n    end;\n  end;\nend;\n\n{ TMVCConnectionsRepository.TConnHolder }\n\ndestructor TMVCConnectionsRepository.TConnHolder.Destroy;\nbegin\n  if OwnsConnection then\n  begin\n    if Connection.Connected then\n      Connection.Connected := false;\n    FreeAndNil(Connection);\n  end;\n  inherited;\nend;\n\nconstructor MVCTableFieldAttribute.Create(const aFieldName: string; const aFieldOptions: TMVCActiveRecordFieldOptions;\n  const aSequenceName: string; const aDataTypeName: string);\nbegin\n  inherited Create;\n  FieldName := aFieldName;\n  FieldOptions := aFieldOptions;\n  SequenceName := aSequenceName;\n  DataTypeName := aDataTypeName;\nend;\n\n{ EMVCActiveRecordNotFound }\n\nprocedure EMVCActiveRecordNotFound.AfterConstruction;\nbegin\n  inherited;\n  FHTTPStatusCode := http_status.NotFound;\nend;\n\nclass function TMVCActiveRecord.ExecQuery(\n  const SQL: string;\n  const Values: array of Variant;\n  const ValueTypes: array of TFieldType;\n  const Connection: TFDConnection;\n  const Unidirectional: Boolean;\n  const DirectExecute: Boolean): TDataSet;\nvar\n  lQry: TFDQuery;\nbegin\n  lQry := CreateQuery(Unidirectional, DirectExecute);\n  try\n    if Connection = nil then\n    begin\n      lQry.Connection := ActiveRecordConnectionsRegistry.GetCurrent;\n    end\n    else\n    begin\n      lQry.Connection := Connection;\n    end;\n    if Length(ValueTypes) = 0 then\n    begin\n      lQry.Open(SQL, Values);\n    end\n    else\n    begin\n      lQry.Open(SQL, Values, ValueTypes);\n    end;\n    Result := lQry;\n  except\n    lQry.Free;\n    raise;\n  end;\nend;\n\nclass function TMVCActiveRecord.ExecQuery(const SQL: string; const Values: array of Variant;\n  const ValueTypes: array of TFieldType; const Unidirectional: Boolean; const DirectExecute: Boolean): TDataSet;\nbegin\n  Result := ExecQuery(SQL, Values, ValueTypes, nil, Unidirectional, DirectExecute);\nend;\n\n{ TFieldsMap }\n\nconstructor TFieldsMap.Create;\nbegin\n  inherited Create([doOwnsValues]);\n  fWritableFieldsCount := -1;\n  fReadableFieldsCount := -1;\nend;\n\nprocedure TFieldsMap.EndUpdates;\nvar\n  lPair: TPair<TRTTIField, TFieldInfo>;\nbegin\n  fWritableFieldsCount := 0;\n  fReadableFieldsCount := 0;\n  for lPair in Self do\n  begin\n    lPair.Value.EndUpdates;\n    if lPair.Value.Insertable or lPair.Value.Updatable then\n    begin\n      Inc(fWritableFieldsCount);\n    end;\n    if lPair.Value.Selectable then\n    begin\n      Inc(fReadableFieldsCount);\n    end;\n  end;\nend;\n\nfunction TFieldsMap.GetInfoByFieldName(const FieldName: string): TFieldInfo;\nvar\n  lPair: TPair<TRTTIField, TFieldInfo>;\nbegin\n  for lPair in Self do\n  begin\n    if SameText(FieldName, lPair.Value.FieldName) then\n    begin\n      Result := Items[lPair.Key];\n      Exit;\n    end;\n  end;\n  raise EMVCActiveRecord.CreateFmt('FieldName [%s] not found in table', [FieldName]);\nend;\n\n{ TFieldInfo }\n\nprocedure TFieldInfo.EndUpdates;\nbegin\n  if FieldName.IsEmpty then\n  begin\n    Selectable := false;\n    Insertable := False;\n    Updatable := False;\n  end\n  else\n  begin\n    Selectable := not (foDoNotSelect in FieldOptions);\n    Insertable := [foDoNotInsert, foAutoGenerated] * FieldOptions = [];\n    Updatable := [foDoNotUpdate, foAutoGenerated] * FieldOptions = [];\n    if foReadOnly in FieldOptions then\n    begin\n      Insertable := False;\n      Updatable := False;\n      Selectable := True;\n    end;\n  end;\n  IsVersion := foVersion in FieldOptions;\nend;\n\n{ TMVCUnitOfWork<T> }\n\nprocedure TMVCUnitOfWork<T>.Apply(const ItemApplyAction: TMVCItemApplyAction<T>);\nvar\n  I: Integer;\n  lHandled: Boolean;\nbegin\n  for I := 0 to fListToInsert.Count - 1 do\n  begin\n    lHandled := false;\n    DoItemApplyAction(fListToInsert[I], eaCreate, ItemApplyAction, lHandled);\n    if not lHandled then\n    begin\n      fListToInsert[I].Insert;\n    end;\n  end;\n  for I := 0 to fListToUpdate.Count - 1 do\n  begin\n    lHandled := false;\n    DoItemApplyAction(fListToUpdate[I], eaUpdate, ItemApplyAction, lHandled);\n    if not lHandled then\n    begin\n      fListToUpdate[I].Update(True);\n    end;\n  end;\n  for I := 0 to fListToDelete.Count - 1 do\n  begin\n    lHandled := false;\n    DoItemApplyAction(fListToDelete[I], eaDelete, ItemApplyAction, lHandled);\n    if not lHandled then\n    begin\n      fListToDelete[I].Delete(True);\n    end;\n  end;\nend;\n\nconstructor TMVCUnitOfWork<T>.Create;\nbegin\n  inherited Create;\n  fListToDelete := TObjectList<T>.Create(false);\n  fListToUpdate := TObjectList<T>.Create(false);\n  fListToInsert := TObjectList<T>.Create(false);\nend;\n\ndestructor TMVCUnitOfWork<T>.Destroy;\nbegin\n  fListToDelete.Free;\n  fListToUpdate.Free;\n  fListToInsert.Free;\n  inherited;\nend;\n\nprocedure TMVCUnitOfWork<T>.DoItemApplyAction(const Obj: TMVCActiveRecord; const EntityAction: TMVCEntityAction;\n  const ItemApplyAction: TMVCItemApplyAction<T>; var Handled: Boolean);\nbegin\n  if Assigned(ItemApplyAction) then\n  begin\n    ItemApplyAction(Obj, EntityAction, Handled);\n  end;\nend;\n\nclass function TMVCUnitOfWork<T>.KeyExistsInt(const NewList: TObjectList<T>; const KeyValue: Integer;\n  out Index: Integer): Boolean;\nvar\n  I: Integer;\nbegin\n  Result := false;\n  for I := 0 to NewList.Count - 1 do\n  begin\n    if NewList[I].GetPK.AsInteger = KeyValue then\n    begin\n      Index := I;\n      Exit(True);\n    end;\n  end;\nend;\n\nclass function TMVCUnitOfWork<T>.KeyExistsInt64(const NewList: TObjectList<T>; const KeyValue: int64;\n  out Index: Integer): Boolean;\nvar\n  I: Integer;\nbegin\n  Result := false;\n  for I := 0 to NewList.Count - 1 do\n  begin\n    if (not NewList[I].PKIsNull) and (NewList[I].GetPK.AsInt64 = KeyValue) then\n    begin\n      Index := I;\n      Exit(True);\n    end;\n  end;\nend;\n\nclass function TMVCUnitOfWork<T>.KeyExistsString(const NewList: TObjectList<T>; const KeyValue: String;\n  out Index: Integer): Boolean;\nvar\n  I: Integer;\nbegin\n  Result := false;\n  for I := 0 to NewList.Count - 1 do\n  begin\n    if NewList[I].GetPK.AsString = KeyValue then\n    begin\n      Index := I;\n      Exit(True);\n    end;\n  end;\nend;\n\nprocedure TMVCUnitOfWork<T>.RegisterDelete(const Value: T);\nbegin\n  fListToDelete.Add(Value);\nend;\n\nprocedure TMVCUnitOfWork<T>.RegisterDelete(const Enumerable: TEnumerable<T>);\nbegin\n  fListToDelete.AddRange(Enumerable);\nend;\n\nprocedure TMVCUnitOfWork<T>.RegisterInsert(const Value: T);\nbegin\n  fListToInsert.Add(Value);\nend;\n\nprocedure TMVCUnitOfWork<T>.RegisterUpdate(const Value: T);\nvar\n  lCurrPKValue: Integer;\n  lFoundAtIndex: Integer;\nbegin\n  fListToUpdate.Add(Value);\n  lCurrPKValue := Value.GetPK.AsInteger;\n  if KeyExistsInt(fListToDelete, lCurrPKValue, lFoundAtIndex) then\n  begin\n    fListToDelete.Delete(lFoundAtIndex);\n  end;\nend;\n\nprocedure TMVCUnitOfWork<T>.UnregisterDelete(const Value: T);\nbegin\n  fListToDelete.Remove(Value);\nend;\n\nprocedure TMVCUnitOfWork<T>.UnregisterInsert(const Value: T);\nbegin\n  fListToInsert.Remove(Value);\nend;\n\nprocedure TMVCUnitOfWork<T>.UnregisterUpdate(const Value: T);\nbegin\n  fListToUpdate.Remove(Value);\nend;\n\nconstructor MVCTableAttribute.Create(aName, aRQLFilter: String);\nbegin\n  inherited Create;\n  Name := aName;\n  RQLFilter := aRQLFilter;\nend;\n\n{ MVCPartitionAttribute }\n\nconstructor MVCPartitionAttribute.Create(const PartitionClause: String);\nbegin\n  inherited Create;\n  Self.PartitionClause := PartitionClause;\nend;\n\n{ TPartitionInfo }\n\nconstructor TPartitionInfo.Create;\nbegin\n  inherited;\n  fFieldNames := TPartitionFieldNames.Create;\n  fFieldValues := TPartitionFieldValues.Create;\n  fFieldTypes := TPartitionFieldTypes.Create;\nend;\n\ndestructor TPartitionInfo.Destroy;\nbegin\n  fFieldNames.Free;\n  fFieldValues.Free;\n  fFieldTypes.Free;\n  inherited;\nend;\n\nclass destructor TPartitionInfo.Destroy;\nbegin\n  PartitionInfoCache.Free;\nend;\n\nprocedure TPartitionInfo.InitializeFilterStrings(const RQLCompiler: TRQLCompiler);\nvar\n  lFieldCount, I: Integer;\n  lRQL2SQL: TRQL2SQL;\nbegin\n  fRQLFilter := '';\n  lFieldCount := FieldNames.Count;\n  if lFieldCount > 0 then\n  begin\n    for I := 0 to lFieldCount - 1 do\n    begin\n      case FieldTypes[I] of\n        ftString:\n          begin\n            fRQLFilter := fRQLFilter + 'eq(' + FieldNames[I] + ',' + FieldValues[I].QuotedString('\"') + '),';\n          end;\n        ftInteger:\n          begin\n            fRQLFilter := fRQLFilter + 'eq(' + FieldNames[I] + ',' + FieldValues[I] + '),';\n          end;\n      else\n        raise ERQLException.CreateFmt('DataType for field [%s] not supported in partition clause', [fFieldNames[I]]);\n      end;\n    end;\n    fRQLFilter := fRQLFilter.Remove(fRQLFilter.Length - 1, 1);\n    if lFieldCount > 1 then\n    begin\n      fRQLFilter := 'and(' + fRQLFilter + ')';\n    end;\n  end;\n  lRQL2SQL := TRQL2SQL.Create;\n  try\n    lRQL2SQL.Execute(fRQLFilter, fSQLFilter, RQLCompiler, false, True)\n  finally\n    lRQL2SQL.Free;\n  end;\n  fSQLFilter := TMVCSQLGenerator.RemoveInitialWhereKeyword(fSQLFilter);\nend;\n\nclass function TPartitionInfo.BuildPartitionClause(const PartitionClause: String;\n  const RQLCompilerClass: TRQLCompilerClass): TPartitionInfo;\nvar\n  lPieces, lItems: TArray<String>;\n  lPiece: String;\n  lRQLCompiler: TRQLCompiler;\nbegin\n  {\n    Needs to parse [MVCPartition('rating=(integer)4;classname=(string)persona')]\n  }\n  if not PartitionInfoCache.TryGetValue(PartitionClause + '|' + RQLCompilerClass.ClassName, Result) then\n  begin\n    TMonitor.Enter(PartitionInfoCache);\n    try\n      if PartitionInfoCache.TryGetValue(PartitionClause + '|' + RQLCompilerClass.ClassName, Result) then\n      begin\n        Exit;\n      end;\n      lRQLCompiler := RQLCompilerClass.Create(nil);\n      try\n        Result := TPartitionInfo.Create;\n        try\n          lPieces := PartitionClause.Split([';']);\n          for lPiece in lPieces do\n          begin\n            lItems := lPiece.Split(['=', '(', ')'], TStringSplitOptions.ExcludeEmpty);\n            if Length(lItems) <> 3 then\n            begin\n              raise EMVCActiveRecord.Create('Invalid partitioning clause: ' + lPiece +\n                '. [HINT] Partioning must be in the form: \"[fieldname1=(integer|string)value1]\"');\n            end;\n\n            Result.FieldNames.Add(lItems[0]);\n            if lItems[1] = 'integer' then\n              Result.FieldTypes.Add(ftInteger)\n            else if lItems[1] = 'string' then\n            begin\n              Result.FieldTypes.Add(ftString)\n            end\n            else\n            begin\n              raise EMVCActiveRecord.Create('Unknown data type in partitioning: ' + lItems[1] +\n                '. [HINT] data type can be \"integer\" or \"string\"');\n            end;\n            Result.FieldValues.Add(lItems[2]);\n          end;\n        except\n          Result.Free;\n          raise;\n        end;\n        Result.InitializeFilterStrings(lRQLCompiler);\n        PartitionInfoCache.Add(PartitionClause + '|' + RQLCompilerClass.ClassName, Result);\n      finally\n        lRQLCompiler.Free;\n      end;\n    finally\n      TMonitor.Exit(PartitionInfoCache);\n    end;\n  end;\nend;\n\nclass constructor TPartitionInfo.Create;\nbegin\n  PartitionInfoCache := TMVCThreadedObjectCache<TPartitionInfo>.Create;\nend;\n\n{ TMVCTableMapRepository }\n\nprocedure TMVCTableMapRepository.AddTableMap(const AR: TMVCActiveRecord; const TableName: String; var TableMap: TMVCTableMap);\nvar\n  lKey: string;\n{$IF Not Defined(RIOORBETTER)}\n  lTmpTableMap: TMVCTableMap;\n{$ENDIF}\nbegin\n  fMREW.BeginWrite;\n  try\n    lKey := GetCacheKey(AR, TableName);\n    // if, due to multi-threading (and the micro-lock used in the caller),\n    // the tablemap definition is already in the case, I free the passed TableMap\n    // and return the TableMap already present in the cache.\n    LogD(Format('ActiveRecord: Add \"%s\" to the metadata cache', [lKey]));\n\n    {$IF Defined(RIOORBETTER)}\n    if not fTableMapDict.TryAdd(lKey, TableMap) then\n    begin\n      LogD(Format('ActiveRecord: Discarded new mapping - cache for \"%s\" already present', [lKey]));\n      TableMap.Free;\n      TableMap := fTableMapDict[lKey];\n    end;\n    {$ELSE}\n    // https://github.com/danieleteti/delphimvcframework/issues/728\n    if fTableMapDict.TryGetValue(lKey, lTmpTableMap) then\n    begin\n      LogD(Format('ActiveRecord: Discarded new mapping - cache for \"%s\" already present', [lKey]));\n      TableMap.Free;\n      TableMap := lTmpTableMap;\n    end\n    else\n    begin\n      fTableMapDict.Add(lKey, TableMap);\n    end;\n    {$ENDIF}\n  finally\n    fMREW.EndWrite;\n  end;\nend;\n\nconstructor TMVCTableMapRepository.Create;\nbegin\n  inherited;\n  fMREW := TMultiReadExclusiveWriteSynchronizer.Create;\n  fTableMapDict := TObjectDictionary<String, TMVCTableMap>.Create([doOwnsValues]);\nend;\n\ndestructor TMVCTableMapRepository.Destroy;\nbegin\n  fTableMapDict.Free;\n  fMREW.Free;\n  inherited;\nend;\n\nprocedure TMVCTableMapRepository.ExecWithExclusiveLock(Proc: TProc<IMVCActiveRecordTableMap>);\nbegin\n  fMREW.BeginWrite;\n  try\n    Proc(Self);\n  finally\n    fMREW.EndWrite;\n  end;\nend;\n\nprocedure TMVCTableMapRepository.FlushCache;\nbegin\n  ExecWithExclusiveLock(\n    procedure(Map: IMVCActiveRecordTableMap)\n    begin\n      TMVCTableMapRepository(Map).fTableMapDict.Clear;\n    end);\nend;\n\nfunction TMVCTableMapRepository.GetCacheKey(const AR: TMVCActiveRecord; const TableName: String): String;\nbegin\n  Result := AR.QualifiedClassName + ':' + TableName;\nend;\n\nfunction TMVCTableMapRepository.TryGetValue(\n  const AR: TMVCActiveRecord;\n  const TableName: String;\n  out TableMap: TMVCTableMap): Boolean;\nbegin\n{$IF not Defined(TokyoOrBetter)}\n  Result := nil;\n{$ENDIF}\n  fMREW.BeginRead;\n  try\n    Result := fTableMapDict.TryGetValue(GetCacheKey(AR, TableName), TableMap);\n  finally\n    fMREW.EndRead;\n  end;\nend;\n\n{ TMVCTableMap }\n\nconstructor TMVCTableMap.Create;\nbegin\n  inherited;\n  fMap := TFieldsMap.Create;\n  fIsVersioned := False;\n  fVersionFieldName := '';\nend;\n\ndestructor TMVCTableMap.Destroy;\nbegin\n  fMap.Free;\n  inherited;\nend;\n\nfunction TMVCTableMap.VersionValueAsInt64For(AR: TMVCActiveRecord): Int64;\nbegin\n  Result := fVersionRTTIField.GetValue(AR).AsInt64;\nend;\n\nclass function TMVCActiveRecordHelper.Select(\n  const aClass: TMVCActiveRecordClass;\n  const SQL: string; const Params: array of Variant;\n  const Connection: TFDConnection; const OutList: TMVCActiveRecordList): UInt32;\nvar\n  lDataSet: TDataSet;\n  lAR: TMVCActiveRecord;\nbegin\n  lDataSet := ExecQuery(SQL, Params, Connection, True, False);\n  try\n    while not lDataSet.Eof do\n    begin\n      lAR := aClass.Create;\n      OutList.Add(lAR);\n      lAR.LoadByDataset(lDataSet);\n      lDataSet.Next;\n    end;\n    Result := OutList.Count;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\n{ MVCNamedSQLQueryAttribute }\n\nconstructor MVCNamedSQLQueryAttribute.Create(aName, aSQLSelect: String);\nbegin\n  Create(aName, aSQLSelect, '');\nend;\n\nconstructor MVCNamedSQLQueryAttribute.Create(aName, aSQLSelect,\n  aBackEnd: String);\nbegin\n  inherited Create;\n  Name := aName;\n  SQLQuery := aSQLSelect;\n  BackEnd := aBackEnd;\nend;\n\n{ MVCNamedRQLQueryAttribute }\n\nconstructor MVCNamedRQLQueryAttribute.Create(aName, aRQL: String);\nbegin\n  inherited Create;\n  Name := aName;\n  RQLQuery := aRQL;\nend;\n\nconstructor TMVCActiveRecord.Create;\nbegin\n  Create(True);\nend;\n\nclass function TMVCActiveRecord.CreateQuery(const Unidirectional, DirectExecute: Boolean): TFDQuery;\nbegin\n  Result := TFDQuery.Create(nil);\n  Result.FetchOptions.Mode := TFDFetchMode.fmAll;\n  Result.FetchOptions.Unidirectional := Unidirectional;\n  Result.UpdateOptions.ReadOnly := True;\n  Result.UpdateOptions.RequestLive := False;\n  Result.ResourceOptions.DirectExecute := DirectExecute;  //2023-07-12\nend;\n\n{ TMVCTransactionContext }\n\n{$IF Defined(CUSTOM_MANAGED_RECORDS)}\n\nconstructor TMVCTransactionContext.Create(Dummy: Integer);\nbegin\n  fConnection := nil;\nend;\n\nclass operator TMVCTransactionContext.Assign(var Dest: TMVCTransactionContext; const [ref] Src: TMVCTransactionContext);\nbegin\n  if Assigned(Src.fConnection) then\n  begin\n    Dest.fConnection := nil;\n    raise EMVCActiveRecordTransactionContext.Create('Transaction Context cannot be copied nor passed by value');\n  end;\n  Dest.fConnection := TMVCActiveRecord.CurrentConnection;\n  Dest.fConnection.StartTransaction;\nend;\n\nclass operator TMVCTransactionContext.Finalize(var Dest: TMVCTransactionContext);\nbegin\n  if Dest.fConnection <> nil then\n  begin\n    if ExceptAddr <> nil then\n    begin\n      Dest.fConnection.Rollback;\n    end\n    else\n    begin\n      Dest.fConnection.Commit;\n    end;\n  end;\nend;\n\n{$ENDIF}\n\n{ EMVCActiveRecordValidation }\n\nprocedure EMVCActiveRecordValidationError.AfterConstruction;\nbegin\n  inherited;\n  FHTTPStatusCode := HTTP_STATUS.BadRequest;\nend;\n\nconstructor EMVCActiveRecordValidationError.Create(const PropertyName, ValidationError: string);\nbegin\n  inherited Create(ValidationError);\n  fPropertyName := PropertyName;\nend;\n\nconstructor TMVCActiveRecord.Create(const Connection: TFDConnection);\nbegin\n  Create(True);\n  fConn := Connection;\nend;\n\ninitialization\n\ngTableMapLock := TObject.Create;\ngCtx := TRttiContext.Create;\ngCtx.FindType('');\n\nfinalization\n\ngCtx.Free;\ngTableMapLock.Free;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Data.Common;\nusing System.Reflection;\nusing System.Threading;\n\nnamespace MVCFramework.ActiveRecord\n{\n    #region Exceptions\n\n    public class MVCActiveRecordException : Exception\n    {\n        public int HttpStatusCode { get; protected set; }\n\n        public MVCActiveRecordException(string message)\n            : base(message)\n        {\n            HttpStatusCode = 400;\n        }\n\n        public MVCActiveRecordException(string message, Exception innerException)\n            : base(message, innerException)\n        {\n            HttpStatusCode = 400;\n        }\n    }\n\n    public class MVCActiveRecordNotFoundException : MVCActiveRecordException\n    {\n        public MVCActiveRecordNotFoundException(string message)\n            : base(message)\n        {\n            HttpStatusCode = 404;\n        }\n    }\n\n    public class MVCActiveRecordValidationErrorException : MVCActiveRecordException\n    {\n        public string PropertyName { get; private set; }\n\n        public MVCActiveRecordValidationErrorException(string propertyName, string validationError)\n            : base(validationError)\n        {\n            PropertyName = propertyName;\n            HttpStatusCode = 400;\n        }\n    }\n\n    public class MVCActiveRecordTransactionContextException : MVCActiveRecordException\n    {\n        public MVCActiveRecordTransactionContextException(string message)\n            : base(message)\n        { }\n    }\n\n    #endregion\n\n    #region Enumerations and Attributes\n\n    [Flags]\n    public enum MVCActiveRecordFieldOption\n    {\n        None = 0,\n        PrimaryKey = 1,\n        AutoGenerated = 2,\n        ReadOnly = 4,\n        Version = 8,\n        DoNotSelect = 16,\n        DoNotInsert = 32,\n        DoNotUpdate = 64\n    }\n\n    [Flags]\n    public enum MVCEntityAction\n    {\n        Create = 1,\n        Retrieve = 2,\n        Update = 4,\n        Delete = 8\n    }\n\n    [Flags]\n    public enum MVCActiveRecordLoadOption\n    {\n        None = 0,\n        IgnoreNotExistentFields = 1\n    }\n\n    \n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCTableAttribute : Attribute\n    {\n        public string Name { get; }\n        public string RQLFilter { get; }\n\n        public MVCTableAttribute(string name) : this(name, string.Empty) { }\n\n        public MVCTableAttribute(string name, string rqlFilter)\n        {\n            Name = name;\n            RQLFilter = rqlFilter;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCPartitionAttribute : Attribute\n    {\n        public string PartitionClause { get; }\n        public MVCPartitionAttribute(string partitionClause)\n        {\n            PartitionClause = partitionClause;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\n    public class MVCTableFieldAttribute : Attribute\n    {\n        public string FieldName { get; }\n        public MVCActiveRecordFieldOption FieldOptions { get; }\n        public string SequenceName { get; }\n        public string DataTypeName { get; }\n\n        public MVCTableFieldAttribute(string fieldName, MVCActiveRecordFieldOption fieldOptions, string sequenceName = \"\", string dataTypeName = \"\")\n        {\n            FieldName = fieldName;\n            FieldOptions = fieldOptions;\n            SequenceName = sequenceName;\n            DataTypeName = dataTypeName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCNamedSQLQueryAttribute : Attribute\n    {\n        public string Name { get; }\n        public string SQLQuery { get; }\n        public string Backend { get; }\n\n        public MVCNamedSQLQueryAttribute(string name, string sqlQuery)\n            : this(name, sqlQuery, string.Empty)\n        { }\n\n        public MVCNamedSQLQueryAttribute(string name, string sqlQuery, string backend)\n        {\n            Name = name;\n            SQLQuery = sqlQuery;\n            Backend = backend;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCNamedRQLQueryAttribute : Attribute\n    {\n        public string Name { get; }\n        public string RQLQuery { get; }\n        public MVCNamedRQLQueryAttribute(string name, string rqlQuery)\n        {\n            Name = name;\n            RQLQuery = rqlQuery;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class MVCEntityActionsAttribute : Attribute\n    {\n        public MVCEntityAction EntityAllowedActions { get; }\n        public MVCEntityActionsAttribute(MVCEntityAction entityAllowedActions)\n        {\n            EntityAllowedActions = entityAllowedActions;\n        }\n    }\n\n    #endregion\n\n    #region Field Mapping Classes\n\n\n    public class FieldInfo\n    {\n        public string FieldName { get; set; }\n        public MVCActiveRecordFieldOption FieldOptions { get; set; }\n        public string DataTypeName { get; set; }\n        public bool Selectable { get; set; }\n        public bool Insertable { get; set; }\n        public bool Updatable { get; set; }\n        public bool IsVersion { get; set; }\n\n        public void EndUpdates()\n        {\n            \n            if (string.IsNullOrWhiteSpace(FieldName))\n            {\n                Selectable = false;\n                Insertable = false;\n                Updatable = false;\n            }\n            else\n            {\n                Selectable = !FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotSelect);\n                Insertable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotInsert) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));\n                Updatable = !(FieldOptions.HasFlag(MVCActiveRecordFieldOption.DoNotUpdate) || FieldOptions.HasFlag(MVCActiveRecordFieldOption.AutoGenerated));\n\n                if (FieldOptions.HasFlag(MVCActiveRecordFieldOption.ReadOnly))\n                {\n                    Insertable = false;\n                    Updatable = false;\n                    Selectable = true;\n                }\n            }\n        }\n    }\n\n    \n    public class FieldsMap : Dictionary<MemberInfo, FieldInfo>\n    {\n        public int WritableFieldsCount { get; private set; }\n        public int ReadableFieldsCount { get; private set; }\n\n        public FieldsMap() : base(new MemberInfoComparer())\n        {\n            WritableFieldsCount = -1;\n            ReadableFieldsCount = -1;\n        }\n\n        public void EndUpdates()\n        {\n            WritableFieldsCount = 0;\n            ReadableFieldsCount = 0;\n            foreach (var pair in this)\n            {\n                pair.Value.EndUpdates();\n                if (pair.Value.Insertable || pair.Value.Updatable)\n                    WritableFieldsCount++;\n                if (pair.Value.Selectable)\n                    ReadableFieldsCount++;\n            }\n        }\n\n        public FieldInfo GetInfoByFieldName(string fieldName)\n        {\n            foreach (var pair in this)\n            {\n                if (string.Equals(pair.Value.FieldName, fieldName, StringComparison.OrdinalIgnoreCase))\n                    return pair.Value;\n            }\n            throw new MVCActiveRecordException($\"FieldName [{fieldName}] not found in table mapping.\");\n        }\n    }\n\n    \n    public class MemberInfoComparer : IEqualityComparer<MemberInfo>\n    {\n        public bool Equals(MemberInfo x, MemberInfo y)\n        {\n            return x.Name.Equals(y.Name, StringComparison.OrdinalIgnoreCase);\n        }\n\n        public int GetHashCode(MemberInfo obj)\n        {\n            return obj.Name.ToLowerInvariant().GetHashCode();\n        }\n    }\n\n    #endregion\n\n    #region Base ActiveRecord Classes\n\n    \n    public abstract class MVCActiveRecord\n    {\n        \n        protected DbConnection Connection { get; private set; }\n\n        protected FieldsMap FieldMapping { get; set; }\n\n        public virtual string TableName { get; protected set; }\n\n        public virtual string PrimaryKeyName { get; protected set; }\n\n        public virtual bool PrimaryKeyIsAutogenerated { get; set; }\n\n        protected abstract MVCSQLGenerator CreateSQLGenerator();\n\n        protected MVCSQLGenerator SQLGenerator { get; private set; }\n\n        protected MVCActiveRecord()\n        {\n            Connection = MVCActiveRecordConnectionRegistry.CurrentConnection;\n            InitializeMapping();\n            SQLGenerator = CreateSQLGenerator();\n        }\n\n        protected virtual void InitializeMapping()\n        {\n            var type = this.GetType();\n            var tableAttr = type.GetCustomAttribute<MVCTableAttribute>();\n            if (tableAttr != null)\n            {\n                TableName = tableAttr.Name;\n            }\n            else\n            {\n                TableName = type.Name;\n            }\n            FieldMapping = new FieldsMap();\n        }\n\n        \n        public virtual void OnValidation(MVCEntityAction action)\n        {\n            // Do nothing by default.\n        }\n\n        \n        public void Store()\n        {\n            if (IsPrimaryKeyNull())\n            {\n                Insert();\n            }\n            else\n            {\n                Update();\n            }\n        }\n\n        \n        public virtual void Insert()\n        {\n            OnValidation(MVCEntityAction.Create);\n            if (!PrimaryKeyIsAutogenerated)\n            {\n                // \u2026 code to fill primary key from sequence, if needed.\n            }\n            string sql = SQLGenerator.CreateInsertSQL(TableName, FieldMapping, this);\n            ExecuteNonQuery(sql);\n            \n            OnAfterInsert();\n        }\n\n        \n        public virtual void Update()\n        {\n            OnValidation(MVCEntityAction.Update);\n            string sql = SQLGenerator.CreateUpdateSQL(TableName, FieldMapping, this);\n            int affected = ExecuteNonQuery(sql);\n            if (affected == 0)\n            {\n                throw new MVCActiveRecordNotFoundException($\"No record updated for primary key [{PrimaryKeyName}] in table [{TableName}].\");\n            }\n            OnAfterUpdate();\n        }\n\n        \n        public virtual void Delete()\n        {\n            OnValidation(MVCEntityAction.Delete);\n            string sql = SQLGenerator.CreateDeleteSQL(TableName, PrimaryKeyName, this);\n            int affected = ExecuteNonQuery(sql);\n            if (affected == 0)\n            {\n                throw new MVCActiveRecordNotFoundException($\"No record deleted for primary key [{PrimaryKeyName}] in table [{TableName}].\");\n            }\n            OnAfterDelete();\n        }\n\n        \n        public virtual void Refresh()\n        {\n            if (IsPrimaryKeyNull())\n            {\n                throw new MVCActiveRecordException(\"Cannot refresh an object with an empty primary key.\");\n            }\n            string sql = SQLGenerator.CreateSelectByPKSQL(TableName, FieldMapping, PrimaryKeyName);\n            DataSet ds = ExecuteQuery(sql, new object[] { GetPrimaryKeyValue() });\n            if (ds.Tables[0].Rows.Count == 0)\n            {\n                throw new MVCActiveRecordNotFoundException(\"Record not found.\");\n            }\n            MapDataRowToObject(ds.Tables[0].Rows[0]);\n        }\n\n        \n        protected virtual int ExecuteNonQuery(string sql)\n        {\n            \n            Console.WriteLine(\"ExecuteNonQuery: \" + sql);\n            return 1;\n        }\n\n        protected virtual DataSet ExecuteQuery(string sql, object[] parameters)\n        {\n            \n            Console.WriteLine(\"ExecuteQuery: \" + sql);\n            return new DataSet();\n        }\n\n        \n        protected virtual void MapDataRowToObject(DataRow row)\n        {\n            // Use reflection or a mapping framework to assign values from row to properties.\n        }\n\n        \n        public virtual object GetPrimaryKeyValue()\n        {\n            \n            return null;\n        }\n\n        \n        public virtual bool IsPrimaryKeyNull()\n        {\n            var pk = GetPrimaryKeyValue();\n            return pk == null || string.IsNullOrEmpty(pk.ToString());\n        }\n\n        \n        protected virtual void OnAfterInsert() { }\n        protected virtual void OnAfterUpdate() { }\n        protected virtual void OnAfterDelete() { }\n\n        \n    }\n\n    #endregion\n\n    #region SQL Generator (Skeleton)\n\n    \n    public abstract class MVCSQLGenerator\n    {\n        protected FieldsMap Mapping { get; }\n        protected string DefaultRQLFilter { get; }\n        \n\n        public MVCSQLGenerator(FieldsMap mapping, string defaultRQLFilter)\n        {\n            Mapping = mapping;\n            DefaultRQLFilter = defaultRQLFilter;\n        }\n\n        public abstract string CreateInsertSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);\n        public abstract string CreateUpdateSQL(string tableName, FieldsMap mapping, MVCActiveRecord ar);\n        public abstract string CreateDeleteSQL(string tableName, string primaryKeyName, MVCActiveRecord ar);\n        public abstract string CreateSelectByPKSQL(string tableName, FieldsMap mapping, string primaryKeyName);\n    }\n\n    \n    public class MVCSQLGeneratorRegistry\n    {\n        private static readonly Dictionary<string, Type> sqlGenerators = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private static readonly object lockObj = new object();\n\n        public static void RegisterSQLGenerator(string backend, Type sqlGeneratorType)\n        {\n            lock (lockObj)\n            {\n                sqlGenerators[backend] = sqlGeneratorType;\n            }\n        }\n\n        public static MVCSQLGenerator GetSQLGenerator(string backend, FieldsMap mapping, string defaultRQLFilter)\n        {\n            lock (lockObj)\n            {\n                if (!sqlGenerators.TryGetValue(backend, out Type generatorType))\n                {\n                    throw new MVCActiveRecordException($\"SQLGenerator not found for backend \\\"{backend}\\\".\");\n                }\n                return (MVCSQLGenerator)Activator.CreateInstance(generatorType, mapping, defaultRQLFilter);\n            }\n        }\n    }\n\n    #endregion\n\n    #region Connection Registry\n\n    \n    public static class MVCActiveRecordConnectionRegistry\n    {\n        \n        public static DbConnection CurrentConnection { get; set; }\n\n        static MVCActiveRecordConnectionRegistry()\n        {\n            \n            // CurrentConnection = new YourDbConnection(...);\n        }\n    }\n\n    #endregion\n\n    #region MVCActiveRecord Helper (Static methods)\n\n    public static class MVCActiveRecordHelper\n    {\n        \n        public static T GetByPK<T>(this T ar, object primaryKey, bool raiseExceptionIfNotFound = true)\n            where T : MVCActiveRecord, new()\n        {\n            T recordInstance = new T();\n            throw new NotImplementedException(\"GetByPK is not implemented\");\n        }\n\n        public static List<T> Select<T>(string sql, object[] parameters) where T : MVCActiveRecord, new()\n        {\n            T instance = new T();\n            throw new NotImplementedException(\"Select is not implemented\");\n        }\n\n        \n    }\n\n    #endregion\n\n    #region Interfaces\n\n    \n    public interface IMVCEntityProcessor\n    {\n        void GetEntities(object context, object renderer, string entityName, ref bool handled);\n        void GetEntity(object context, object renderer, string entityName, int id, ref bool handled);\n        void CreateEntity(object context, object renderer, string entityName, ref bool handled);\n        void UpdateEntity(object context, object renderer, string entityName, int id, ref bool handled);\n        void DeleteEntity(object context, object renderer, string entityName, int id, ref bool handled);\n    }\n\n    #endregion\n\n    #region (Optional) Unit Of Work and MultiExecutor Interfaces\n\n    \n\n    public interface IMVCUnitOfWork<T> where T : MVCActiveRecord\n    {\n        void RegisterInsert(T value);\n        void RegisterUpdate(T value);\n        void RegisterDelete(T value);\n        void UnregisterInsert(T value);\n        void UnregisterUpdate(T value);\n        void UnregisterDelete(T value);\n    }\n\n    public interface IMVCMultiExecutor<T> where T : MVCActiveRecord\n    {\n        void Apply(Action<T, MVCEntityAction, ref bool> itemApplyAction = null);\n    }\n\n    #endregion\n\n    #region (Optional) Table Map and Registry Classes\n\n    \n\n    public class MVCTableMap\n    {\n        public string TableName { get; set; }\n        public string PrimaryKeyFieldName { get; set; }\n        public bool IsVersioned { get; set; }\n        public string VersionFieldName { get; set; }\n        public FieldsMap Map { get; set; }\n        public string DefaultRQLFilter { get; set; }\n\n        public MVCTableMap()\n        {\n            Map = new FieldsMap();\n        }\n\n       \n        public long VersionValueAsInt64For(MVCActiveRecord ar)\n        {\n            \n            return 1;\n        }\n    }\n\n    #endregion\n\n    #region (Optional) Entities Registry and Connections Repository\n\n    \n\n    public interface IMVCEntitiesRegistry\n    {\n        void AddEntity(string urlSegment, Type activeRecordClass);\n        void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor);\n        bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass);\n        bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor);\n        string[] GetEntities();\n        KeyValuePair<string, Type>[] GetURLSegmentWithEntities();\n    }\n\n    public class MVCEntitiesRegistry : IMVCEntitiesRegistry\n    {\n        private readonly Dictionary<string, Type> entitiesDict = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private readonly Dictionary<string, IMVCEntityProcessor> processorsDict = new Dictionary<string, IMVCEntityProcessor>(StringComparer.OrdinalIgnoreCase);\n\n        public void AddEntity(string urlSegment, Type activeRecordClass)\n        {\n            entitiesDict[urlSegment.ToLower()] = activeRecordClass;\n        }\n\n        public void AddEntityProcessor(string urlSegment, IMVCEntityProcessor entityProcessor)\n        {\n            processorsDict[urlSegment.ToLower()] = entityProcessor;\n        }\n\n        public bool FindEntityClassByURLSegment(string urlSegment, out Type activeRecordClass)\n        {\n            return entitiesDict.TryGetValue(urlSegment.ToLower(), out activeRecordClass);\n        }\n\n        public bool FindProcessorByURLSegment(string urlSegment, out IMVCEntityProcessor entityProcessor)\n        {\n            return processorsDict.TryGetValue(urlSegment.ToLower(), out entityProcessor);\n        }\n\n        public string[] GetEntities()\n        {\n            var keys = new List<string>(entitiesDict.Keys);\n            return keys.ToArray();\n        }\n\n        public KeyValuePair<string, Type>[] GetURLSegmentWithEntities()\n        {\n            var list = new List<KeyValuePair<string, Type>>(entitiesDict);\n            return list.ToArray();\n        }\n    }\n\n    #endregion\n\n    \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX }\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti. }\n//\n// The DUnitX project is run by Vincent Parrett and can be found at: }\n//\n// https://github.com/VSoftTechnologies/DUnitX }\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.NewControllerUnit;\n\ninterface\n\nuses\n  ToolsApi,\n  System.IOUtils,\n  DMVC.Expert.CodeGen.NewUnit,\n  JsonDataObjects, DMVC.Expert.CodeGen.Executor;\n\ntype\n  TNewControllerUnitEx = class(TNewUnit)\n  protected\n    function NewImplSource(const ModuleIdent, FormIdent, AncestorIdent: string)\n      : IOTAFile; override;\n  public\n    constructor Create(\n      const ConfigModelRef: TJSONObject;\n      const APersonality: string = ''); reintroduce;\n  end;\n\n  TTemplateLoadProcedure = procedure(Gen: TMVCCodeGenerator);\n\n  TNewGenericUnitFromTemplate = class(TNewUnit)\n  private\n    fTemplateLoadProcedure: TTemplateLoadProcedure;\n    fUnitIdentKeyName: string;\n  protected\n    function NewImplSource(const ModuleIdent, FormIdent, AncestorIdent: string)\n      : IOTAFile; override;\n  public\n    constructor Create(\n      const ConfigModelRef: TJSONObject;\n      const TemplateLoadProcedure: TTemplateLoadProcedure;\n      const UnitIdentKeyName: String;\n      const APersonality: string = '');reintroduce;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  DMVC.Expert.CodeGen.SourceFile,\n  DMVC.Expert.Commands.Templates,\n  DMVC.Expert.Commons;\n\nconstructor TNewControllerUnitEx.Create(\n  const ConfigModelRef: TJSONObject;\n  const APersonality: string = '');\nbegin\n  inherited Create(ConfigModelRef);\n  Personality := APersonality;\nend;\n\nfunction TNewControllerUnitEx.NewImplSource(const ModuleIdent, FormIdent,\n  AncestorIdent: string): IOTAFile;\nvar\n  lUnitIdent: string;\n  lFormName: string;\n  lFileName: string;\nbegin\n  // http://stackoverflow.com/questions/4196412/how-do-you-retrieve-a-new-unit-name-from-delphis-open-tools-api\n  // So using method mentioned by Marco Cantu.\n  (BorlandIDEServices as IOTAModuleServices).GetNewModuleAndClassName('',\n    lUnitIdent, lFormName, lFileName);\n\n\n  fConfigModelRef.S[TConfigKey.controller_unit_name] := lUnitIdent;\n\n  Result := TSourceFile.Create(\n    procedure (Gen: TMVCCodeGenerator)\n    begin\n      FillControllerTemplates(Gen);\n    end,\n    fConfigModelRef);\nend;\n\n{ TNewJSONRPCUnitEx }\n\nconstructor TNewGenericUnitFromTemplate.Create(\n  const ConfigModelRef: TJSONObject;\n  const TemplateLoadProcedure: TTemplateLoadProcedure;\n  const UnitIdentKeyName: String;\n  const APersonality: string);\nbegin\n  inherited Create(ConfigModelRef);\n  fTemplateLoadProcedure := TemplateLoadProcedure;\n  fUnitIdentKeyName := UnitIdentKeyName;\n  Personality := aPersonality;\nend;\n\nfunction TNewGenericUnitFromTemplate.NewImplSource(const ModuleIdent, FormIdent,\n  AncestorIdent: string): IOTAFile;\nvar\n  lUnitIdent: string;\n  lFileName: string;\n  lDummy: String;\nbegin\n  // http://stackoverflow.com/questions/4196412/how-do-you-retrieve-a-new-unit-name-from-delphis-open-tools-api\n  // So using method mentioned by Marco Cantu.\n  lFileName := '';\n  (BorlandIDEServices as IOTAModuleServices).GetNewModuleAndClassName('',\n    lUnitIdent, lDummy, lFileName);\n  fConfigModelRef.S[fUnitIdentKeyName] := lUnitIdent;\n  Result := TSourceFile.Create(\n    procedure (Gen: TMVCCodeGenerator)\n    begin\n      //FillJSONRPCTemplates(Gen);\n      fTemplateLoadProcedure(Gen);\n    end,\n    fConfigModelRef);\nend;\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertCodeGenNewControllerUnit\n{\n    \n    public interface IOTAFile\n    {\n        // Define members as needed.\n    }\n\n    \n    public abstract class TNewUnit\n    {\n        \n        protected JObject fConfigModelRef;\n        \n        public string Personality { get; set; }\n\n        protected TNewUnit(JObject configModelRef)\n        {\n            fConfigModelRef = configModelRef;\n        }\n\n        public abstract IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent);\n    }\n\n    public delegate void TTemplateLoadProcedure(TMVCCodeGenerator gen);\n\n    public class TMVCCodeGenerator\n    {\n        // Implementation details omitted.\n    }\n\n    public class TSourceFile : IOTAFile\n    {\n        public string Source { get; private set; }\n\n        public TSourceFile(Action<TMVCCodeGenerator> fillerProc, JObject configModel)\n        {\n            TMVCCodeGenerator generator = new TMVCCodeGenerator();\n            fillerProc(generator);\n            Source = string.Empty;\n        }\n\n        public static IOTAFile Create(Action<TMVCCodeGenerator> fillerProc, JObject configModel)\n        {\n            return new TSourceFile(fillerProc, configModel);\n        }\n    }\n\n    public static class OTAModuleServices\n    {\n        public static void GetNewModuleAndClassName(string prefix, out string unitIdent, out string formName, out string fileName)\n        {\n            unitIdent = \"NewUnitName\";\n            formName = \"NewFormName\";\n            fileName = \"NewFileName.cs\";\n        }\n    }\n\n     public class TNewControllerUnitEx : TNewUnit\n    {\n        public TNewControllerUnitEx(JObject configModelRef, string aPersonality = \"\")\n            : base(configModelRef)\n        {\n            Personality = aPersonality;\n        }\n\n        public override IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent)\n        {\n            OTAModuleServices.GetNewModuleAndClassName(string.Empty, out string lUnitIdent, out string lFormName, out string lFileName);\n\n            fConfigModelRef[\"controller_unit_name\"] = lUnitIdent;\n\n            return TSourceFile.Create(\n                gen =>\n                {\n                    \n                    Console.WriteLine(\"Filling controller templates...\");\n                },\n                fConfigModelRef);\n        }\n    }\n\n    public class TNewGenericUnitFromTemplate : TNewUnit\n    {\n        private readonly TTemplateLoadProcedure fTemplateLoadProcedure;\n        private readonly string fUnitIdentKeyName;\n\n        public TNewGenericUnitFromTemplate(\n            JObject configModelRef,\n            TTemplateLoadProcedure templateLoadProcedure,\n            string unitIdentKeyName,\n            string aPersonality = \"\")\n            : base(configModelRef)\n        {\n            fTemplateLoadProcedure = templateLoadProcedure;\n            fUnitIdentKeyName = unitIdentKeyName;\n            Personality = aPersonality;\n        }\n\n        public override IOTAFile NewImplSource(string moduleIdent, string formIdent, string ancestorIdent)\n        {\n            OTAModuleServices.GetNewModuleAndClassName(string.Empty, out string lUnitIdent, out string dummy, out string lFileName);\n            fConfigModelRef[fUnitIdentKeyName] = lUnitIdent;\n\n            return TSourceFile.Create(\n                gen =>\n                {\n                    fTemplateLoadProcedure(gen);\n                },\n                fConfigModelRef);\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Swag.Doc.Definition;\n\ninterface\n\nuses\n  Json.Schema,\n  System.JSON;\n\ntype\n  /// <summary>\n  /// The Schema Object allows the definition of input and output data types.\n  /// These types can be objects, but also primitives and arrays.\n  /// This object is based on the JSON Schema Specification Draft 4 and uses a predefined subset of it.\n  /// On top of this subset, there are extensions provided by this specification to allow for more complete documentation.\n  /// Further information about the properties can be found in JSON Schema Core and JSON Schema Validation.\n  /// Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here.\n  /// </summary>\n  TSwagDefinition = class(TObject)\n  private\n    fName: string;\n    fJsonSchema: TJsonObject;\n    procedure SetName(const pValue: string);\n    procedure SetJsonSchema(const pValue: TJsonObject);\n    function GetJsonSchema: TJsonObject;\n  public\n    destructor Destroy; override;\n\n    function GenerateJsonRefDefinition: TJsonObject;\n    /// <summary>\n    /// The schema name alias.\n    /// </summary>\n    property Name: string read fName write SetName;\n\n    /// <summary>\n    /// See more in:\n    ///  * http://json-schema.org\n    ///  * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject\n    /// </summary>\n    property JsonSchema: TJsonObject read GetJsonSchema write SetJsonSchema;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TSwagDefinition }\n\ndestructor TSwagDefinition.Destroy;\nbegin\n  if Assigned(fJsonSchema) then\n    FreeAndNil(fJsonSchema);\n  inherited Destroy;\nend;\n\nfunction TSwagDefinition.GetJsonSchema: TJsonObject;\nbegin\n  Result := fJsonSchema;\nend;\n\nprocedure TSwagDefinition.SetJsonSchema(const pValue: TJsonObject);\nbegin\n  fJsonSchema := pValue;\n  fJsonSchema.Owned := False;\nend;\n\nprocedure TSwagDefinition.SetName(const pValue: string);\nbegin\n  fName := pValue;\nend;\n\nfunction TSwagDefinition.GenerateJsonRefDefinition: TJsonObject;\nconst\n  c_SchemaRef = '$ref';\n  c_PrefixDefinitionName = '#/definitions/';\nbegin\n  Result := TJsonObject.Create;\n  Result.AddPair(c_SchemaRef, c_PrefixDefinitionName + fName);\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing Swag.Common.Consts;\nusing Swag.Doc.Info;\nusing Swag.Doc.Tags;\nusing Swag.Doc.SecurityDefinition;\nusing Swag.Doc.Path;\nusing Swag.Doc.Definition;\nusing Swag.Doc.FileLoader;\nusing Swag.Common.Types;\n\nnamespace Swag.Doc\n{\n    public class SwagDoc\n    {\n        private SwagInfo _info;\n        private List<SwagTag> _tags;\n        private List<string> _consumes;\n        private List<string> _produces;\n        private string _basePath;\n        private string _host;\n        private HashSet<SwagTransferProtocolScheme> _schemes;\n        private List<SwagPath> _paths;\n        private List<SwagDefinition> _definitions;\n        private List<SwagSecurityDefinition> _securityDefinitions;\n        private SwagExternalDocs _externalDocs;\n        private JToken _swaggerJson;\n        private string _swaggerFilesFolder;\n        private List<SwagRequestParameter> _parameters;\n\n        public SwagDoc()\n        {\n            _info = new SwagInfo();\n            _tags = new List<SwagTag>();\n            _securityDefinitions = new List<SwagSecurityDefinition>();\n            _consumes = new List<string>();\n            _produces = new List<string>();\n            _paths = new List<SwagPath>();\n            _definitions = new List<SwagDefinition>();\n            _externalDocs = new SwagExternalDocs();\n            _parameters = new List<SwagRequestParameter>();\n            _schemes = new HashSet<SwagTransferProtocolScheme>();\n        }\n\n        ~SwagDoc()\n        {\n            _consumes = null;\n            _produces = null;\n            _definitions = null;\n            _paths = null;\n            _info = null;\n            _tags = null;\n            _securityDefinitions = null;\n            _externalDocs = null;\n            _parameters = null;\n            _swaggerJson = null;\n        }\n\n        public void GenerateSwaggerJson()\n        {\n            var json = new JObject();\n            json[\"swagger\"] = SwaggerVersion;\n            json[\"info\"] = _info.GenerateJsonObject();\n            if (!string.IsNullOrEmpty(_host))\n                json[\"host\"] = _host;\n            json[\"basePath\"] = _basePath;\n            if (_tags.Count > 0)\n                json[\"tags\"] = GenerateTagsJsonArray();\n            if (_schemes.Count > 0)\n                json[\"schemes\"] = GenerateSchemesJsonArray();\n            if (_consumes.Count > 0)\n                json[\"consumes\"] = GenerateMimeTypesJsonArray(_consumes);\n            if (_produces.Count > 0)\n                json[\"produces\"] = GenerateMimeTypesJsonArray(_produces);\n            if (_paths.Count > 0)\n                json[\"paths\"] = GeneratePathsJsonObject();\n            if (_parameters.Count > 0)\n                json[\"parameters\"] = GenerateParametersJsonObject();\n            if (_securityDefinitions.Count > 0)\n                json[\"securityDefinitions\"] = GenerateSecurityDefinitionsJsonObject();\n            if (_definitions.Count > 0)\n                json[\"definitions\"] = GenerateDefinitionsJsonObject();\n            if (_externalDocs != null)\n                json[\"externalDocs\"] = _externalDocs.GenerateJsonObject();\n            _swaggerJson = json;\n        }\n\n        public void SaveSwaggerJsonToFile()\n        {\n            if (_swaggerJson == null)\n                return;\n            if (!Directory.Exists(_swaggerFilesFolder))\n                Directory.CreateDirectory(_swaggerFilesFolder);\n            string jsonString = _swaggerJson.ToString(Newtonsoft.Json.Formatting.Indented);\n            File.WriteAllText(ReturnSwaggerFileName(), jsonString);\n        }\n\n        public void LoadFromFile(string filename)\n        {\n            var loader = new SwagFileLoader(this);\n            loader.Load(filename);\n        }\n\n        public string SwaggerVersion => Consts.c_SwaggerVersion;\n\n        public SwagInfo Info => _info;\n\n        public string Host { get => _host; set => _host = value; }\n\n        public string BasePath { get => _basePath; set => _basePath = value; }\n\n        public HashSet<SwagTransferProtocolScheme> Schemes { get => _schemes; set => _schemes = value; }\n\n        public List<string> Consumes => _consumes;\n\n        public List<string> Produces => _produces;\n\n        public List<SwagPath> Paths => _paths;\n\n        public List<SwagDefinition> Definitions => _definitions;\n\n        public List<SwagSecurityDefinition> SecurityDefinitions => _securityDefinitions;\n\n        public List<SwagRequestParameter> Parameters => _parameters;\n\n        public List<SwagTag> Tags => _tags;\n\n        public SwagExternalDocs ExternalDocs => _externalDocs;\n\n        public JToken SwaggerJson => _swaggerJson;\n\n        public string SwaggerFilesFolder\n        {\n            get => _swaggerFilesFolder;\n            set => _swaggerFilesFolder = value.EndsWith(Path.DirectorySeparatorChar.ToString()) ? value : value + Path.DirectorySeparatorChar;\n        }\n\n        private string ReturnSwaggerFileName()\n        {\n            return _swaggerFilesFolder + Consts.c_SwaggerFileName;\n        }\n\n        private JArray GenerateMimeTypesJsonArray(List<string> mimeTypes)\n        {\n            var arr = new JArray();\n            foreach (var mime in mimeTypes)\n                arr.Add(mime);\n            return arr;\n        }\n\n        private JArray GenerateConsumesJsonArray()\n        {\n            return GenerateMimeTypesJsonArray(_consumes);\n        }\n\n        private JArray GenerateProducesJsonArray()\n        {\n            return GenerateMimeTypesJsonArray(_produces);\n        }\n\n        private JObject GenerateDefinitionsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var def in _definitions)\n            {\n                if (def.JsonSchema != null)\n                    obj[def.Name] = def.JsonSchema.DeepClone();\n            }\n            return obj;\n        }\n\n        private JObject GenerateParametersJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var param in _parameters)\n                obj[param.Name] = param.GenerateJsonObject();\n            return obj;\n        }\n\n        private JObject GeneratePathsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var path in _paths)\n                obj[path.Uri] = path.GenerateJsonObject();\n            return obj;\n        }\n\n        private JArray GenerateTagsJsonArray()\n        {\n            var arr = new JArray();\n            foreach (var tag in _tags)\n                arr.Add(tag.GenerateJsonObject());\n            return arr;\n        }\n\n        private JArray GenerateSchemesJsonArray()\n        {\n            var arr = new JArray();\n            foreach (SwagTransferProtocolScheme scheme in Enum.GetValues(typeof(SwagTransferProtocolScheme)))\n            {\n                if (_schemes.Contains(scheme))\n                    arr.Add(Consts.c_SwagTransferProtocolScheme[scheme]);\n            }\n            return arr;\n        }\n\n        private JObject GenerateSecurityDefinitionsJsonObject()\n        {\n            var obj = new JObject();\n            foreach (var sec in _securityDefinitions)\n                obj[sec.SchemeName] = sec.GenerateJsonObject();\n            return obj;\n        }\n    }\n}"}
{"input": "unit Main.Form;\n\ninterface\n\nuses Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Horse, Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.Mask, Vcl.ExtCtrls, Vcl.ComCtrls;\n\ntype\n  TfrmMain = class(TForm)\n    edtPort: TSpinEdit;\n    Button1: TButton;\n    leKey: TLabeledEdit;\n    leCrt: TLabeledEdit;\n    Button2: TButton;\n    Button3: TButton;\n    OpenDialog1: TOpenDialog;\n    lePassword: TLabeledEdit;\n    StatusBar1: TStatusBar;\n    procedure Button2Click(Sender: TObject);\n    procedure Button3Click(Sender: TObject);\n    procedure Button1Click(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n  private\n    function GetFile(const description, extension: string): string;\n    procedure Start;\n    procedure OnGetPassword(var Password: string);\n  end;\n\nvar\n  frmMain: TfrmMain;\n\nimplementation\n\nuses IdSSLOpenSSL;\n\n{$R *.dfm}\n\nprocedure TfrmMain.Button1Click(Sender: TObject);\nbegin\n  Start;\nend;\n\nprocedure TfrmMain.Button2Click(Sender: TObject);\nbegin\n  leKey.Text := GetFile('Private Key', '*key');\nend;\n\nprocedure TfrmMain.Button3Click(Sender: TObject);\nbegin\n  leCrt.Text := GetFile('Public Key', '*crt');\nend;\n\nprocedure TfrmMain.FormCreate(Sender: TObject);\nbegin\n  THorse.Get('/ping',\n    procedure(Req: THorseRequest; Res: THorseResponse)\n    begin\n      Res.Send('securite pong');\n    end);\nend;\n\nfunction TfrmMain.GetFile(const description, extension: string): string;\nbegin\n  Result := EmptyStr;\n  OpenDialog1.Filter := description + '|' + extension;\n  if OpenDialog1.Execute() then\n  begin\n    if OpenDialog1.FileName <> EmptyStr then\n      Result := OpenDialog1.FileName;\n  end;\nend;\n\nprocedure TfrmMain.OnGetPassword(var Password: string);\nbegin\n  Password := lePassword.Text;\nend;\n\nprocedure TfrmMain.Start;\nbegin\n// To use ssl it is necessary to have the ssl, libeay32.dll and ssleay32.dll\n// libraries in your executable folder.\n\n// Command to generate a self-signed certificate using openssl, on windows it is recommended to use git bash.\n// openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout cert.key -out cert.crt\n\n// Not recommended for production, only for testing and internal use, for commercial use in production\n// use a valid certificate, such as Let's Encrypt.\n\n  THorse.IOHandleSSL\n    .KeyFile(leKey.Text)\n    .CertFile(leCrt.Text)\n    .OnGetPassword(Self.OnGetPassword)\n    .SSLVersions([sslvTLSv1_2])\n    .Active(True);\n\n  // Need to set \"HORSE_VCL\" compilation directive\n\n  THorse.Listen(edtPort.Value,\n    procedure\n    begin\n      StatusBar1.Panels.Items[0].Text := Format('Securite Server is running on https://%s:%d', [THorse.Host, THorse.Port]);\n    end);\nend;\n\nend.", "output": "namespace MyHorseApp\n{\n    partial class frmMain\n    {\n        private System.ComponentModel.IContainer components = null;\n\n        private System.Windows.Forms.NumericUpDown numPort;\n        private System.Windows.Forms.Button btnStart;\n        private System.Windows.Forms.TextBox txtKey;\n        private System.Windows.Forms.Label lblKey;\n        private System.Windows.Forms.TextBox txtCrt;\n        private System.Windows.Forms.Label lblCrt;\n        private System.Windows.Forms.Button btnSelectKey;\n        private System.Windows.Forms.Button btnSelectCrt;\n        private System.Windows.Forms.OpenFileDialog openFileDialog1;\n        private System.Windows.Forms.TextBox txtPassword;\n        private System.Windows.Forms.Label lblPassword;\n        private System.Windows.Forms.StatusStrip statusStrip1;\n        private System.Windows.Forms.ToolStripStatusLabel tslStatus;\n\n       \n        protected override void Dispose(bool disposing)\n        {\n            if (disposing && (components != null))\n            {\n                components.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        #region Windows Form Designer generated code\n\n        private void InitializeComponent()\n        {\n            this.numPort = new System.Windows.Forms.NumericUpDown();\n            this.btnStart = new System.Windows.Forms.Button();\n            this.txtKey = new System.Windows.Forms.TextBox();\n            this.lblKey = new System.Windows.Forms.Label();\n            this.txtCrt = new System.Windows.Forms.TextBox();\n            this.lblCrt = new System.Windows.Forms.Label();\n            this.btnSelectKey = new System.Windows.Forms.Button();\n            this.btnSelectCrt = new System.Windows.Forms.Button();\n            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();\n            this.txtPassword = new System.Windows.Forms.TextBox();\n            this.lblPassword = new System.Windows.Forms.Label();\n            this.statusStrip1 = new System.Windows.Forms.StatusStrip();\n            this.tslStatus = new System.Windows.Forms.ToolStripStatusLabel();\n            ((System.ComponentModel.ISupportInitialize)(this.numPort)).BeginInit();\n            this.statusStrip1.SuspendLayout();\n            this.SuspendLayout();\n            \n            this.numPort.Location = new System.Drawing.Point(12, 12);\n            this.numPort.Maximum = new decimal(new int[] {\n            65535,\n            0,\n            0,\n            0});\n            this.numPort.Minimum = new decimal(new int[] {\n            1,\n            0,\n            0,\n            0});\n            this.numPort.Name = \"numPort\";\n            this.numPort.Size = new System.Drawing.Size(120, 20);\n            this.numPort.TabIndex = 0;\n            this.numPort.Value = new decimal(new int[] {\n            8443,\n            0,\n            0,\n            0});\n            \n            this.btnStart.Location = new System.Drawing.Point(12, 38);\n            this.btnStart.Name = \"btnStart\";\n            this.btnStart.Size = new System.Drawing.Size(120, 23);\n            this.btnStart.TabIndex = 1;\n            this.btnStart.Text = \"Start Horse Server\";\n            this.btnStart.UseVisualStyleBackColor = true;\n            this.btnStart.Click += new System.EventHandler(this.btnStart_Click);\n            \n            this.txtKey.Location = new System.Drawing.Point(12, 80);\n            this.txtKey.Name = \"txtKey\";\n            this.txtKey.Size = new System.Drawing.Size(300, 20);\n            this.txtKey.TabIndex = 2;\n            \n            this.lblKey.AutoSize = true;\n            this.lblKey.Location = new System.Drawing.Point(12, 64);\n            this.lblKey.Name = \"lblKey\";\n            this.lblKey.Size = new System.Drawing.Size(49, 13);\n            this.lblKey.TabIndex = 3;\n            this.lblKey.Text = \"Key File:\";\n            \n            this.txtCrt.Location = new System.Drawing.Point(12, 120);\n            this.txtCrt.Name = \"txtCrt\";\n            this.txtCrt.Size = new System.Drawing.Size(300, 20);\n            this.txtCrt.TabIndex = 4;\n            \n            this.lblCrt.AutoSize = true;\n            this.lblCrt.Location = new System.Drawing.Point(12, 104);\n            this.lblCrt.Name = \"lblCrt\";\n            this.lblCrt.Size = new System.Drawing.Size(62, 13);\n            this.lblCrt.TabIndex = 5;\n            this.lblCrt.Text = \"Certificate:\";\n            \n            this.btnSelectKey.Location = new System.Drawing.Point(318, 78);\n            this.btnSelectKey.Name = \"btnSelectKey\";\n            this.btnSelectKey.Size = new System.Drawing.Size(75, 23);\n            this.btnSelectKey.TabIndex = 6;\n            this.btnSelectKey.Text = \"Browse...\";\n            this.btnSelectKey.UseVisualStyleBackColor = true;\n            this.btnSelectKey.Click += new System.EventHandler(this.btnSelectKey_Click);\n            \n            this.btnSelectCrt.Location = new System.Drawing.Point(318, 118);\n            this.btnSelectCrt.Name = \"btnSelectCrt\";\n            this.btnSelectCrt.Size = new System.Drawing.Size(75, 23);\n            this.btnSelectCrt.TabIndex = 7;\n            this.btnSelectCrt.Text = \"Browse...\";\n            this.btnSelectCrt.UseVisualStyleBackColor = true;\n            this.btnSelectCrt.Click += new System.EventHandler(this.btnSelectCrt_Click);\n            \n            this.txtPassword.Location = new System.Drawing.Point(12, 160);\n            this.txtPassword.Name = \"txtPassword\";\n            this.txtPassword.Size = new System.Drawing.Size(300, 20);\n            this.txtPassword.TabIndex = 8;\n            \n            this.lblPassword.AutoSize = true;\n            this.lblPassword.Location = new System.Drawing.Point(12, 144);\n            this.lblPassword.Name = \"lblPassword\";\n            this.lblPassword.Size = new System.Drawing.Size(56, 13);\n            this.lblPassword.TabIndex = 9;\n            this.lblPassword.Text = \"Password:\";\n            \n            this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.tslStatus});\n            this.statusStrip1.Location = new System.Drawing.Point(0, 240);\n            this.statusStrip1.Name = \"statusStrip1\";\n            this.statusStrip1.Size = new System.Drawing.Size(420, 22);\n            this.statusStrip1.TabIndex = 10;\n            this.statusStrip1.Text = \"statusStrip1\";\n             \n            this.tslStatus.Name = \"tslStatus\";\n            this.tslStatus.Size = new System.Drawing.Size(118, 17);\n            this.tslStatus.Text = \"Status: Not running...\";\n            \n            this.ClientSize = new System.Drawing.Size(420, 262);\n            this.Controls.Add(this.statusStrip1);\n            this.Controls.Add(this.lblPassword);\n            this.Controls.Add(this.txtPassword);\n            this.Controls.Add(this.btnSelectCrt);\n            this.Controls.Add(this.btnSelectKey);\n            this.Controls.Add(this.lblCrt);\n            this.Controls.Add(this.txtCrt);\n            this.Controls.Add(this.lblKey);\n            this.Controls.Add(this.txtKey);\n            this.Controls.Add(this.btnStart);\n            this.Controls.Add(this.numPort);\n            this.Name = \"frmMain\";\n            this.Text = \"Horse SSL Server Demo\";\n            this.Load += new System.EventHandler(this.frmMain_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.numPort)).EndInit();\n            this.statusStrip1.ResumeLayout(false);\n            this.statusStrip1.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n\n        }\n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit App.WebModule;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Serializer.JsonDataObjects;\n\ntype\n\n  TAppWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVCEngine: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TAppWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles,\n  Person.Controller;\n\nprocedure TAppWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVCEngine := TMVCEngine.Create(Self,\n    procedure(AConfig: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      AConfig[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      AConfig[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      AConfig[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      AConfig[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      AConfig[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      AConfig[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      AConfig[TMVCConfigKey.ExposeServerSignature] := 'true';\n    end);\n  FMVCEngine.AddController(TPersonController);\n  FMVCEngine.AddSerializer(TMVCMediaType.APPLICATION_JSON, TMVCJsonDataObjectsSerializer.Create);\n  FMVCEngine.AddMiddleware(TMVCStaticFilesMiddleware.Create(\n    '/', { StaticFilesPath }\n    ExtractFilePath(GetModuleName(HInstance)) + 'www', { DocumentRoot }\n    'index.html' {IndexDocument - Before it was named fallbackresource}\n    ));\nend;\n\nprocedure TAppWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVCEngine.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.FileProviders;\nusing System.IO;\nusing System.Collections.Generic;\n\nnamespace App.WebModule\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        \n        public IConfiguration Configuration { get; }\n        \n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers()\n                .AddNewtonsoftJson();\n\n        }\n        \n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            string wwwPath = Path.Combine(env.ContentRootPath, \"www\");\n            var fileProvider = new PhysicalFileProvider(wwwPath);\n            \n            app.UseDefaultFiles(new DefaultFilesOptions\n            {\n                DefaultFileNames = new List<string> { \"index.html\" },\n                FileProvider = fileProvider\n            });\n            app.UseStaticFiles(new StaticFileOptions\n            {\n                FileProvider = fileProvider,\n                RequestPath = \"\"\n            });\n\n            app.UseRouting();\n\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n// Contribution on this file: Copyright (c) 2018 - Jo\ufffdo Ant\ufffdnio Duarte\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.NewProject;\n// This is done to Warnings that I can't control, as Embarcadero has\n// deprecated the functions, but due to design you are still required to\n// to implement.\n{$WARN SYMBOL_DEPRECATED OFF}\ninterface\n\nuses\n  PlatformAPI,\n  ToolsAPI;\n\ntype\n   TNewProject = class abstract(TNotifierObject,IOTACreator, IOTAProjectCreator,IOTAProjectCreator80)\n   protected\n    //IOTACreator\n    function GetCreatorType: string; virtual;\n    function GetExisting: Boolean;\n    function GetFileSystem: string;\n    function GetOwner: IOTAModule;\n    function GetUnnamed: Boolean;\n    // IOTAProjectCreator\n    function GetFileName: string;\n    function GetOptionFileName: string; deprecated;\n    function GetShowSource: Boolean;\n    procedure NewDefaultModule; deprecated;\n    function NewOptionSource(const ProjectName: string): IOTAFile; deprecated;\n    procedure NewProjectResource(const Project: IOTAProject);\n    function NewProjectSource(const ProjectName: string): IOTAFile; virtual; abstract;  // MUST OVERRIDE!\n    // IOTAProjectCreator80\n    function GetProjectPersonality: string;virtual;\n    procedure NewDefaultProjectModule(const Project: IOTAProject);\n  private\n    procedure SetFileName(const Value: String);\n  protected\n    FFileName : String;\n  public\n     property FileName : String read GetFileName write SetFileName;\n  end;\n\n  TNewProjectEx = class(TNewProject, IOTAProjectCreator160)\n  private\n   FPersonality: string;\n  protected\n    function GetProjectPersonality: string;override;\n\n    // IOTAProjectCreator160\n    function GetPlatforms: TArray<string>;\n    function GetFrameworkType: string; virtual;\n    function GetPreferredPlatform: string;\n    procedure SetInitialOptions(const NewProject: IOTAProject);\n  public\n    property Personality : string read FPersonality write FPersonality;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n\n{ TNewProject }\n\nfunction TNewProject.GetCreatorType: string;\nbegin\n  Result := sConsole; // May want to change this in the future, at least making method virtual\nend;\n\nfunction TNewProject.GetExisting: Boolean;\nbegin\n  Result := False;\nend;\n\nfunction TNewProject.GetFileName: string;\nbegin\n  Result := FFileName;\nend;\n\nfunction TNewProject.GetFileSystem: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProject.GetOptionFileName: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProject.GetOwner: IOTAModule;\nbegin\n  Result := (BorlandIDEServices as IOTAModuleServices).MainProjectGroup;\nend;\n\nfunction TNewProject.GetProjectPersonality: string;\nbegin\n  Result := sDelphiPersonality;\nend;\n\nfunction TNewProject.GetShowSource: Boolean;\nbegin\n  Result := False;\nend;\n\nfunction TNewProject.GetUnnamed: Boolean;\nbegin\n  Result := True;\nend;\n\nprocedure TNewProject.NewDefaultModule;\nbegin\nend;\n\nprocedure TNewProject.NewDefaultProjectModule(const Project: IOTAProject);\nbegin\nend;\n\nfunction TNewProject.NewOptionSource(const ProjectName: string): IOTAFile;\nbegin\n  Result := nil;\nend;\n\nprocedure TNewProject.NewProjectResource(const Project: IOTAProject);\nbegin\nend;\n\n\nprocedure TNewProject.SetFileName(const Value: String);\nbegin\n  FFileName := Value;\nend;\n\nfunction TNewProjectEx.GetFrameworkType: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProjectEx.GetPlatforms: TArray<string>;\nbegin\n  Result := TArray<string>.Create(cWin32Platform, cWin64Platform);\nend;\n\nfunction TNewProjectEx.GetPreferredPlatform: string;\nbegin\n  Result := '';\nend;\n\nfunction TNewProjectEx.GetProjectPersonality: string;\nbegin\n  Result := sDelphiPersonality\nend;\n\nprocedure TNewProjectEx.SetInitialOptions(const NewProject: IOTAProject);\nvar\n  LBuildConf: IOTAProjectOptionsConfigurations;\nbegin\n  if Supports(NewProject.ProjectOptions, IOTAProjectOptionsConfigurations, LBuildConf) then\n  begin\n    LBuildConf.BaseConfiguration.AsBoolean['UsingDelphiRTL'] := True;\n  end;\n\nend;\n\nend.", "output": "using System;\n\nnamespace DMVCExpertCodeGenNewProject\n{\n    public interface IOTACreator { }\n    \n    public interface IOTAProjectCreator { }\n    \n    public interface IOTAProjectCreator80 { }\n    \n    public interface IOTAProjectCreator160 { }\n    \n    public interface IOTAModule { }\n    \n    public interface IOTAFile { }\n    \n    public interface IOTAProject\n    {\n        object ProjectOptions { get; }\n    }\n    \n    public interface IOTAProjectOptionsConfigurations\n    {\n        IBaseConfiguration BaseConfiguration { get; }\n    }\n    \n    public interface IBaseConfiguration\n    {\n        bool this[string key] { get; set; }\n    }\n        public static class Constants\n    {\n        public const string sConsole = \"Console\";\n        public const string sDelphiPersonality = \"Delphi\";\n        public const string cWin32Platform = \"Win32\";\n        public const string cWin64Platform = \"Win64\";\n    }\n    \n    public abstract class TNewProject : IOTACreator, IOTAProjectCreator, IOTAProjectCreator80\n    {\n        protected string FFileName;\n\n        \n        public virtual string GetCreatorType() => Constants.sConsole;  \n        public bool GetExisting() => false;\n        public string GetFileSystem() => \"\";\n        public IOTAModule GetOwner() \n        {\n            \n            return null;\n        }\n        public bool GetUnnamed() => true;\n\n        \n        public string GetFileName() => FFileName;\n        public string GetOptionFileName() => \"\";\n        public bool GetShowSource() => false;\n        public virtual void NewDefaultModule() { } \n        public virtual IOTAFile NewOptionSource(string ProjectName) => null;\n        public virtual void NewProjectResource(IOTAProject Project) { }\n        public abstract IOTAFile NewProjectSource(string ProjectName);\n\n        public virtual string GetProjectPersonality() => Constants.sDelphiPersonality;\n        public virtual void NewDefaultProjectModule(IOTAProject Project) { }\n\n        public string FileName\n        {\n            get => GetFileName();"}
{"input": "unit Horse.Core.Route.Contract;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n  Horse.Callback;\n\ntype\n  IHorseCoreRoute<T: class> = interface\n    ['{8D593D98-44B3-4FD2-A21B-BA29F784B3AA}']\n    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\n    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\n    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\n    function Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IFEND}\n    function &End: T;\n  end;\n\nimplementation\n\nend.", "output": "using System;\n\nnamespace Horse.Core.Route.Contract\n{\n    \n    public delegate void THorseCallback();\n    public delegate void THorseCallbackRequestResponse();\n    public delegate void THorseCallbackRequest();\n    public delegate void THorseCallbackResponse();\n\n    public interface IHorseCoreRoute<T> where T : class\n    {\n        IHorseCoreRoute<T> AddCallback(THorseCallback callback);\n        IHorseCoreRoute<T> AddCallbacks(THorseCallback[] callbacks);\n        IHorseCoreRoute<T> All(THorseCallback callback);\n        IHorseCoreRoute<T> All(THorseCallback middleware, THorseCallback callback);\n        IHorseCoreRoute<T> All(params THorseCallback[] callbacks);\n        IHorseCoreRoute<T> All(THorseCallback[] callbacks, THorseCallback callback);\n        IHorseCoreRoute<T> Get(THorseCallback callback);\n        IHorseCoreRoute<T> Get(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Get(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Get(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Put(THorseCallback callback);\n        IHorseCoreRoute<T> Put(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Put(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Put(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Head(THorseCallback callback);\n        IHorseCoreRoute<T> Head(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Head(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Head(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Post(THorseCallback callback);\n        IHorseCoreRoute<T> Post(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Post(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Post(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Patch(THorseCallback callback);\n        IHorseCoreRoute<T> Delete(THorseCallback callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Patch(THorseCallbackResponse callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackRequestResponse callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackRequest callback);\n        IHorseCoreRoute<T> Delete(THorseCallbackResponse callback);\n        T End();\n    }\n}"}
{"input": "unit WebModule02U;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, CustomWebModuleU, MVCFramework;\n\ntype\n  TWebModule02 = class(TCustomWebModule)\n  protected\n    procedure DoConfigureEngine(const aMVCEngine: TMVCEngine); override;\n\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses App1MainControllerU;\n{ TWebModule02 }\n\nprocedure TWebModule02.DoConfigureEngine(const aMVCEngine: TMVCEngine);\nbegin\n  inherited;\n  aMVCEngine.AddController(TApp1MainController);\nend;\n\nend.", "output": "using MVCFramework;\n\nnamespace YourNamespace\n{\n    public class WebModule02 : CustomWebModule\n    {\n        protected override void DoConfigureEngine(TMVCEngine engine)\n        {\n            base.DoConfigureEngine(engine);\n            engine.AddController(typeof(App1MainController));\n        }\n    }\n}"}
{"input": "unit Horse.Core.Route;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n{$ELSE}\n  System.SysUtils,\n{$ENDIF}\n  Horse.Core.Route.Contract,\n  Horse.Callback;\n\ntype\n  THorseCoreRoute<T: class> = class(TInterfacedObject, IHorseCoreRoute<T>)\n  private\n    FPath: string;\n    FHorseCore: TObject;\n  public\n    constructor Create(const APath: string);\n    function This: IHorseCoreRoute<T>;\n    function AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\n    function AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\n    function All(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>; overload;\n    function All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Put(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Head(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Post(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\n    function Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n    function Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>; overload;\n    function Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>; overload;\n{$IFNDEF FPC}\n    function Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>; overload;\n{$IFEND}\n{$IFEND}\n    function &End: T;\n  end;\n\nimplementation\n\nuses\n  Horse.Core;\n\nconstructor THorseCoreRoute<T>.Create(const APath: string);\nbegin\n  FPath := APath;\n  FHorseCore := THorseCore.GetInstance;\nend;\n\nfunction THorseCoreRoute<T>.This: IHorseCoreRoute<T>;\nbegin\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.All(const AMiddleware, ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, [AMiddleware, ACallback]);\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallbacks: array of THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallbacks);\nend;\n\nfunction THorseCoreRoute<T>.&End: T;\nbegin\n  Result := FHorseCore as T;\nend;\n\nfunction THorseCoreRoute<T>.AddCallback(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).AddCallback(ACallback);\nend;\n\nfunction THorseCoreRoute<T>.All(const ACallbacks: array of THorseCallback; const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Use(FPath, ACallbacks);\n  THorseCore(FHorseCore).Use(FPath, [ACallback]);\nend;\n\n{$IF (DEFINED(FPC) OR (CompilerVersion > 27.0))}\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Delete(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Delete(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Patch(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Patch(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Get(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Head(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Post(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallback): IHorseCoreRoute<T>;\nbegin\n  Result := Self;\n  THorseCore(FHorseCore).Put(FPath, ACallback);\nend;\n\nfunction THorseCoreRoute<T>.AddCallbacks(const ACallbacks: TArray<THorseCallback>): IHorseCoreRoute<T>;\nvar\n  LCallback: THorseCallback;\nbegin\n  for LCallback in ACallbacks do\n    AddCallback(LCallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Get(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Get(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Head(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Head(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Post(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Post(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\n{$IFNDEF FPC}\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n{$IFEND}\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackRequest): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n\nfunction THorseCoreRoute<T>.Put(const ACallback: THorseCallbackRequestResponse): IHorseCoreRoute<T>;\nbegin\n  THorseCore(FHorseCore).Put(FPath, ACallback);\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing Horse.Core.Route.Contract; \nusing Horse.Core;                \n\nnamespace Horse.Core.Route\n{\n    public class HorseCoreRoute<T> : IHorseCoreRoute<T> where T : class\n    {\n        private readonly string _path;\n        private readonly object _horseCore; \n\n        public HorseCoreRoute(string aPath)\n        {\n            _path = aPath;\n            \n            _horseCore = HorseCore.GetInstance();\n        }\n\n        public IHorseCoreRoute<T> This() => this;\n\n        public IHorseCoreRoute<T> AddCallback(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).AddCallback(callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> AddCallbacks(THorseCallback[] callbacks)\n        {\n            foreach (var cb in callbacks)\n            {\n                AddCallback(cb);\n            }\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback middleware, THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, new THorseCallback[] { middleware, callback });\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback[] callbacks)\n        {\n            ((HorseCore)_horseCore).Use(_path, callbacks);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> All(THorseCallback[] callbacks, THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Use(_path, callbacks);\n            ((HorseCore)_horseCore).Use(_path, new THorseCallback[] { callback });\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Get(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Get(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Put(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Put(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Head(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Head(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Post(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Post(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Patch(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Patch(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallback callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackRequestResponse callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackRequest callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public IHorseCoreRoute<T> Delete(THorseCallbackResponse callback)\n        {\n            ((HorseCore)_horseCore).Delete(_path, callback);\n            return this;\n        }\n\n        public T End()\n        {\n            return _horseCore as T;\n        }\n    }\n}"}
{"input": "unit MainWebModuleU;\n\ninterface\n\nuses System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TMyWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMyWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  MyControllerU,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles;\n\nprocedure TMyWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      Config[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] :=\n        TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] :=\n        TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n    end);\n  FMVC.AddController(TMyController);\nend;\n\nprocedure TMyWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace MainWebModuleApp\n{\n    \n    [ApiController]\n    [Route(\"api\")]\n    public class MyController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult Index()\n        {\n            return Ok(\"Hello DelphiMVCFramework World\");\n        }\n\n        [HttpGet(\"reversedstrings/{value}\")]\n        public IActionResult GetReversedString(string value)\n        {\n            if (value == null)\n                return BadRequest(\"Value is required\");\n            string reversed = new string(value.Trim().Reverse().ToArray());\n            return Ok(reversed);\n        }\n\n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n            return Ok(Array.Empty<object>());\n        }\n\n        [HttpGet(\"customers/{id:int}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            var customer = new { Id = id, Name = \"Customer \" + id };\n            return Ok(customer);\n        }\n\n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer([FromBody] dynamic customer)\n        {\n            return Created($\"/api/customers/{customer.id}\", customer);\n        }\n\n        [HttpPut(\"customers/{id:int}\")]\n        public IActionResult UpdateCustomer(int id, [FromBody] dynamic customer)\n        {\n            return Ok(customer);\n        }\n\n        [HttpDelete(\"customers/{id:int}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            return NoContent();\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            builder.Services.AddControllers();\n\n\n            var app = builder.Build();\n\n            app.UseStaticFiles();\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"securite pong\");\n\n            Console.WriteLine($\"Server is running on: http://{app.Urls.FirstOrDefault()}\");\n\n            app.Run();\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.RQL.AST2InterbaseSQL;\n\ninterface\n\nuses\n  System.Generics.Defaults,\n  MVCFramework.RQL.Parser,\n  MVCFramework.RQL.AST2FirebirdSQL;\n\ntype\n  TRQLInterbaseCompiler = class(TRQLFirebirdCompiler)\n  protected\n    function GetLiteralBoolean(const Value: Boolean): String; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.ActiveRecord;\n\n{ TRQLInterbaseCompiler }\n\nfunction TRQLInterbaseCompiler.GetLiteralBoolean(const Value: Boolean): String;\nbegin\n  if Value then\n  begin\n    Exit('1');\n  end;\n  Exit('0');\nend;\n\ninitialization\n\nTRQLCompilerRegistry.Instance.RegisterCompiler('interbase', TRQLInterbaseCompiler);\n\nfinalization\n\nTRQLCompilerRegistry.Instance.UnRegisterCompiler('interbase');\n\nend.", "output": "using System;\nusing MVCFramework.RQL.Parser;\nusing MVCFramework.RQL.AST2FirebirdSQL; \nusing MVCFramework.ActiveRecord;\n\nnamespace MVCFramework.RQL.AST2InterbaseSQL\n{\n    \n    public class RQLInterbaseCompiler : RQLFirebirdCompiler\n    {\n        \n        protected override string GetLiteralBoolean(bool value)\n        {\n            return value ? \"1\" : \"0\";\n        }\n    }\n\n    \n    public static class RQLInterbaseCompilerRegistration\n    {\n        static RQLInterbaseCompilerRegistration()\n        {\n            \n            RQLCompilerRegistry.Instance.RegisterCompiler(\"interbase\", typeof(RQLInterbaseCompiler));\n        }\n\n        \n        public static void Unregister()\n        {\n            RQLCompilerRegistry.Instance.UnRegisterCompiler(\"interbase\");\n        }\n    }\n}"}
{"input": "unit Horse.Provider.IOHandleSSL;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n  IdSSLOpenSSL,\n  Horse.Provider.IOHandleSSL.Contract;\n\ntype\n  THorseProviderIOHandleSSL = class(TInterfacedObject, IHorseProviderIOHandleSSL)\n  private\n    FKeyFile: string;\n    FRootCertFile: string;\n    FCertFile: string;\n    FDHParamsFile: string;\n    FCipherList: string;\n    FMethod: TIdSSLVersion;\n    FSSLVersions: TIdSSLVersions;\n    FOnGetPassword: TPasswordEvent;\n    FActive: Boolean;\n    function Active: Boolean; overload;\n    function Active(const AValue: Boolean): IHorseProviderIOHandleSSL; overload;\n    function CertFile: string; overload;\n    function CertFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function RootCertFile: string; overload;\n    function RootCertFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function KeyFile: string; overload;\n    function KeyFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function Method: TIdSSLVersion; overload;\n    function Method(const AValue: TIdSSLVersion): IHorseProviderIOHandleSSL; overload;\n    function SSLVersions: TIdSSLVersions; overload;\n    function SSLVersions(const AValue: TIdSSLVersions): IHorseProviderIOHandleSSL; overload;\n    function DHParamsFile: string; overload;\n    function DHParamsFile(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function CipherList: string; overload;\n    function CipherList(const AValue: string): IHorseProviderIOHandleSSL; overload;\n    function OnGetPassword: TPasswordEvent; overload;\n    function OnGetPassword(const AValue: TPasswordEvent): IHorseProviderIOHandleSSL; overload;\n  public\n    constructor Create;\n    class function New: IHorseProviderIOHandleSSL;\n  end;\n\nimplementation\n\nfunction THorseProviderIOHandleSSL.Active(const AValue: Boolean): IHorseProviderIOHandleSSL;\nbegin\n  FActive := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.Active: Boolean;\nbegin\n  Result := FActive;\nend;\n\nfunction THorseProviderIOHandleSSL.CertFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FCertFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.CipherList: string;\nbegin\n  Result := FCipherList;\nend;\n\nfunction THorseProviderIOHandleSSL.CipherList(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FCipherList := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.CertFile: string;\nbegin\n  Result := FCertFile;\nend;\n\nconstructor THorseProviderIOHandleSSL.Create;\nbegin\n  FActive := True;\n  FMethod := DEF_SSLVERSION;\n  FSSLVersions := DEF_SSLVERSIONS;\nend;\n\nfunction THorseProviderIOHandleSSL.DHParamsFile: string;\nbegin\n  Result := FDHParamsFile;\nend;\n\nfunction THorseProviderIOHandleSSL.DHParamsFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FDHParamsFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.KeyFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FKeyFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.KeyFile: string;\nbegin\n  Result := FKeyFile;\nend;\n\nfunction THorseProviderIOHandleSSL.Method(const AValue: TIdSSLVersion): IHorseProviderIOHandleSSL;\nbegin\n  FMethod := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.Method: TIdSSLVersion;\nbegin\n  Result := FMethod;\nend;\n\nclass function THorseProviderIOHandleSSL.New: IHorseProviderIOHandleSSL;\nbegin\n  Result := THorseProviderIOHandleSSL.Create;\nend;\n\nfunction THorseProviderIOHandleSSL.OnGetPassword(const AValue: TPasswordEvent): IHorseProviderIOHandleSSL;\nbegin\n  FOnGetPassword := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.OnGetPassword: TPasswordEvent;\nbegin\n  Result := FOnGetPassword;\nend;\n\nfunction THorseProviderIOHandleSSL.RootCertFile(const AValue: string): IHorseProviderIOHandleSSL;\nbegin\n  FRootCertFile := AValue;\n  Result := Self;\nend;\n\nfunction THorseProviderIOHandleSSL.RootCertFile: string;\nbegin\n  Result := FRootCertFile;\nend;\n\nfunction THorseProviderIOHandleSSL.SSLVersions: TIdSSLVersions;\nbegin\n  Result := FSSLVersions;\nend;\n\nfunction THorseProviderIOHandleSSL.SSLVersions(const AValue: TIdSSLVersions): IHorseProviderIOHandleSSL;\nbegin\n  FSSLVersions := AValue;\n  Result := Self;\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Provider.IOHandleSSL\n{\n    \n    public enum TIdSSLVersion\n    {\n        TLSv1,\n        TLSv1_1,\n        TLSv1_2\n    }\n\n   \n    [Flags]\n    public enum TIdSSLVersions\n    {\n        TLSv1 = 1,\n        TLSv1_1 = 2,\n        TLSv1_2 = 4\n    }\n\n    \n    public delegate void TPasswordEvent(object sender, ref string password);\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        \n        IHorseProviderIOHandleSSL Active(bool value);\n        bool Active { get; }\n\n        IHorseProviderIOHandleSSL CertFile(string value);\n        string CertFile { get; }\n\n        IHorseProviderIOHandleSSL RootCertFile(string value);\n        string RootCertFile { get; }\n\n        IHorseProviderIOHandleSSL KeyFile(string value);\n        string KeyFile { get; }\n\n        IHorseProviderIOHandleSSL Method(TIdSSLVersion value);\n        TIdSSLVersion Method { get; }\n\n        IHorseProviderIOHandleSSL SSLVersions(TIdSSLVersions value);\n        TIdSSLVersions SSLVersions { get; }\n\n        IHorseProviderIOHandleSSL DHParamsFile(string value);\n        string DHParamsFile { get; }\n\n        IHorseProviderIOHandleSSL CipherList(string value);\n        string CipherList { get; }\n\n        IHorseProviderIOHandleSSL OnGetPassword(TPasswordEvent value);\n        TPasswordEvent OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        private bool _active;\n        private string _keyFile;\n        private string _rootCertFile;\n        private string _certFile;\n        private string _dhParamsFile;\n        private string _cipherList;\n        private TIdSSLVersion _method;\n        private TIdSSLVersions _sslVersions;\n        private TPasswordEvent _onGetPassword;\n\n        \n        private const TIdSSLVersion DEF_SSLVERSION = TIdSSLVersion.TLSv1_2;\n        private const TIdSSLVersions DEF_SSLVERSIONS = TIdSSLVersions.TLSv1_2;\n\n        public HorseProviderIOHandleSSL()\n        {\n            _active = true;\n            _method = DEF_SSLVERSION;\n            _sslVersions = DEF_SSLVERSIONS;\n        }\n\n        public IHorseProviderIOHandleSSL Active(bool value)\n        {\n            _active = value;\n            return this;\n        }\n\n        public bool Active => _active;\n\n        public IHorseProviderIOHandleSSL CertFile(string value)\n        {\n            _certFile = value;\n            return this;\n        }\n\n        public string CertFile => _certFile;\n\n        public IHorseProviderIOHandleSSL RootCertFile(string value)\n        {\n            _rootCertFile = value;\n            return this;\n        }\n\n        public string RootCertFile => _rootCertFile;\n\n        public IHorseProviderIOHandleSSL KeyFile(string value)\n        {\n            _keyFile = value;\n            return this;\n        }\n\n        public string KeyFile => _keyFile;\n\n        public IHorseProviderIOHandleSSL Method(TIdSSLVersion value)\n        {\n            _method = value;\n            return this;\n        }\n\n        public TIdSSLVersion Method => _method;\n\n        public IHorseProviderIOHandleSSL SSLVersions(TIdSSLVersions value)\n        {\n            _sslVersions = value;\n            return this;\n        }\n\n        public TIdSSLVersions SSLVersions => _sslVersions;\n\n        public IHorseProviderIOHandleSSL DHParamsFile(string value)\n        {\n            _dhParamsFile = value;\n            return this;\n        }\n\n        public string DHParamsFile => _dhParamsFile;\n\n        public IHorseProviderIOHandleSSL CipherList(string value)\n        {\n            _cipherList = value;\n            return this;\n        }\n\n        public string CipherList => _cipherList;\n\n        public IHorseProviderIOHandleSSL OnGetPassword(TPasswordEvent value)\n        {\n            _onGetPassword = value;\n            return this;\n        }\n\n        public TPasswordEvent OnGetPassword => _onGetPassword;\n\n        \n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{  Sample author: geoffsmith82 - 2019                                          }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Sample.MvcControllerClientFileBuilder;\n\ninterface\n\nuses\n  System.Classes,\n  System.Json,\n  System.SysUtils,\n  System.Generics.Collections,\n  System.Generics.Defaults,\n  Swag.Doc,\n  Swag.Common.Types,\n  Swag.Doc.Path.Operation,\n  Swag.Doc.Path.Operation.Response,\n  Swag.Doc.Path.Operation.RequestParameter,\n  Sample.DelphiUnit.Generate;\n\ntype\n  TSwagDocToDelphiRESTClientBuilder = class(TObject)\n  strict private\n    fSwagDoc: TSwagDoc;\n\n    function CapitalizeFirstLetter(const pTypeName: string): string;\n    function RewriteUriToSwaggerWay(const pUri: string): string;\n    function OperationIdToFunctionName(pOperation: TSwagPathOperation): string;\n    function GenerateUnitText(pDelphiUnit: TDelphiUnit): string;\n    function ConvertSwaggerTypeToDelphiType(pSwaggerType: TSwagRequestParameter): TUnitTypeDefinition;\n    function ConvertRefToType(const pRef: string): string;\n    function ConvertRefToVarName(const pRef: string): string;\n\n    procedure ChildType(pDelphiUnit: TDelphiUnit; pJson: TJSONPair);\n    procedure HandleArray(pField: TUnitFieldDefinition; pJson: TJSONPair);\n    procedure ConvertSwaggerDefinitionsToTypeDefinitions(pDelphiUnit: TDelphiUnit);\n  public\n    constructor Create(pSwagDoc: TSwagDoc); reintroduce;\n    function Generate: string;\n  end;\n\nimplementation\n\nuses\n  Winapi.Windows,\n  System.IOUtils,\n  System.TypInfo,\n  Json.Common.Helpers;\n\n{ TSwagDocToDelphiMVCFrameworkBuilder }\n\nconstructor TSwagDocToDelphiRESTClientBuilder.Create(pSwagDoc: TSwagDoc);\nbegin\n  inherited Create;\n  fSwagDoc := pSwagDoc;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.OperationIdToFunctionName(pOperation: TSwagPathOperation): string;\nbegin\n  Result := pOperation.OperationId.Replace('{','').Replace('}','').Replace('-','');\n  if not CharInSet(Result[1], ['a'..'z','A'..'Z']) then\n    Result := 'F' + Result;\n\n  Result := CapitalizeFirstLetter(Result);\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.RewriteUriToSwaggerWay(const pUri: string): string;\nbegin\n  Result := pUri.Replace('{','($').Replace('}',')');\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.CapitalizeFirstLetter(const pTypeName: string): string;\nbegin\n  if pTypeName.Length > 2 then\n    Result := Copy(pTypeName, 1, 1).ToUpper + Copy(pTypeName, 2, pTypeName.Length - 1)\n  else\n    Result := pTypeName;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertRefToType(const pRef: string): string;\nbegin\n  Result := Copy(pRef, pRef.LastIndexOf('/') + 2);\n  Result := Copy(Result,1,1).ToUpper + Copy(Result,2);\n  if Result.ToLower <> 'string' then\n    Result := 'T' + Result;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertRefToVarName(const pRef: string): string;\nbegin\n  Result := Copy(pRef, pRef.LastIndexOf('/') + 2);\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.Generate: string;\nvar\n  vPathIndex: Integer;\n  vOperationIndex: Integer;\n  vParameterIndex: Integer;\n  vDelphiUnit: TDelphiUnit;\n  vMVCControllerClient: TUnitTypeDefinition;\n  vMethod: TUnitMethod;\n  vResponse: TPair<string, TSwagResponse>;\n  vSchemaObj: TJsonObject;\n  vResultParam: TUnitParameter;\n  vField: TUnitFieldDefinition;\n  vRef: String;\nbegin\n  vDelphiUnit := TDelphiUnit.Create;\n  try\n    vDelphiUnit.UnitFile := 'UnitFilenameMvcControllerClient';\n    vDelphiUnit.AddInterfaceUnit('IPPeerClient');\n    vDelphiUnit.AddInterfaceUnit('REST.Client');\n    vDelphiUnit.AddInterfaceUnit('REST.Authenticator.OAuth');\n    vDelphiUnit.AddInterfaceUnit('REST.Types');\n    vDelphiUnit.AddInterfaceUnit('MVCFramework');\n    vDelphiUnit.AddInterfaceUnit('MVCFramework.Commons');\n    vDelphiUnit.AddImplementationUnit('Swag.Doc');\n\n    ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n\n    vMVCControllerClient := TUnitTypeDefinition.Create;\n    vMVCControllerClient.TypeName := 'TMyMVCControllerClient';\n    vMVCControllerClient.TypeInherited := 'TObject';\n    vMVCControllerClient.AddAttribute('  [MVCPath(''' + RewriteUriToSwaggerWay(fSwagDoc.BasePath) + ''')]');\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTClient';\n    vField.FieldType := 'TRESTClient';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTRequest';\n    vField.FieldType := 'TRESTRequest';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vField := TUnitFieldDefinition.Create;\n    vField.FieldName := 'RESTResponse';\n    vField.FieldType := 'TRESTResponse';\n    vMVCControllerClient.Fields.Add(vField);\n\n    vDelphiUnit.AddType(vMVCControllerClient);\n    ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n\n    for vPathIndex := 0 to fSwagDoc.Paths.Count - 1 do\n    begin\n      for vOperationIndex := 0 to fSwagDoc.Paths[vPathIndex].Operations.Count - 1 do\n      begin\n        vMethod := TUnitMethod.Create;\n        if fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Description.Trim.Length > 0 then\n          vMethod.AddAttribute('    [MVCDoc(' + QuotedStr(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Description) + ')]');\n        vMethod.AddAttribute('    [MVCPath(''' + fSwagDoc.Paths[vPathIndex].Uri + ''')]');\n        vMethod.AddAttribute('    [MVCHTTPMethod([http' + fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].OperationToString + '])]');\n        vMethod.Name := OperationIdToFunctionName(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex]);\n\n        for vParameterIndex := 0 to fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters.Count - 1 do\n        begin\n          vResultParam := TUnitParameter.Create;\n          vResultParam.ParamName := CapitalizeFirstLetter(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters[vParameterIndex].Name);\n          vResultParam.ParamType := ConvertSwaggerTypeToDelphiType(fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Parameters[vParameterIndex]);\n          vMethod.AddParameter(vResultParam);\n        end;\n\n        for vResponse in fSwagDoc.Paths[vPathIndex].Operations[vOperationIndex].Responses do\n        begin\n          vSchemaObj := vResponse.Value.Schema.JsonSchema;\n          if vSchemaObj = nil then\n            continue;\n          if vSchemaObj.TryGetValue('$ref', vRef) then\n          begin\n            vMethod.AddAttribute('    [MVCResponse(' + vResponse.Key + ', ' +\n                                                   QuotedStr(vResponse.Value.Description) + ', ' + ConvertRefToType(vRef) + ')]');\n            vResultParam := TUnitParameter.Create;\n            vResultParam.ParamName := ConvertRefToVarName(vRef);\n            vResultParam.ParamType := TUnitTypeDefinition.Create;\n            vResultParam.ParamType.TypeName := ConvertRefToType(vRef);\n            vMethod.AddLocalVariable(vResultParam);\n            vMethod.Content.Add('  ' + ConvertRefToVarName(vRef) + ' := ' + ConvertRefToType(vRef) + '.Create;');\n//            method.Content.Add('  Render(' + response.Key + ', ' + ConvertRefToVarName(ref) + ');');\n          end\n          else\n          begin\n            if not vSchemaObj.TryGetValue('properties', vSchemaObj) then\n              continue;\n            if not vSchemaObj.TryGetValue('employees', vSchemaObj) then\n              continue;\n            if not vSchemaObj.TryGetValue('items', vSchemaObj) then\n              continue;\n            if vSchemaObj.TryGetValue('$ref', vRef) then\n            begin\n              vMethod.AddAttribute('    [MVCResponseList(' + vResponse.Key + ', ' +\n                                                     QuotedStr(vResponse.Value.Description) + ', ' + ConvertRefToType(vRef) + ')]');\n              vResultParam := TUnitParameter.Create;\n              vResultParam.ParamName := ConvertRefToVarName(vRef);\n              vResultParam.ParamType := TUnitTypeDefinition.Create;\n              vResultParam.ParamType.TypeName := 'TObjectList<' + ConvertRefToType(vRef) + '>';\n              vMethod.AddLocalVariable(vResultParam);\n              vDelphiUnit.AddInterfaceUnit('Generics.Collections');\n              vMethod.Content.Add('  ' + ConvertRefToVarName(vRef) + ' := TObjectList<' + ConvertRefToType(vRef) + '>.Create;');\n            end;\n          end;\n        end;\n\n        vMVCControllerClient.Methods.Add(vMethod);\n      end;\n    end;\n\n    vDelphiUnit.SortTypeDefinitions;\n\n    Result := GenerateUnitText(vDelphiUnit);\n  finally\n    vDelphiUnit.Free;\n  end;\nend;\n\nprocedure TSwagDocToDelphiRESTClientBuilder.HandleArray(pField : TUnitFieldDefinition; pJson: TJSONPair);\nvar\n  vJsonObj: TJSONObject;\n  vJsonVal: TJSONValue;\n  vType: string;\nbegin\n  if Assigned(((pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject).Values['type']) then\n  begin\n    vType := ((pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject).Values['type'].Value;\n    if vType.ToLower <> 'string' then\n      vType := 'T' + vType;\n    pField.FieldType := 'array of ' + vType;\n  end\n  else\n  begin\n    OutputDebugString(PChar(pJson.ToJSON));\n    vJsonVal := (pJson.JsonValue as TJSONObject).Values['items'] as TJSONObject;\n    OutputDebugString(PChar(vJsonVal.ToJSON));\n    vJsonObj := vJsonVal as TJSONObject;\n    vJsonVal := vJsonObj.Values['$ref'];\n    OutputDebugString(PChar(vJsonVal.Value));\n    pField.FieldType := 'array of ' + ConvertRefToType(vJsonVal.value);\n  end;\nend;\n\n\nprocedure TSwagDocToDelphiRESTClientBuilder.ChildType(pDelphiUnit : TDelphiUnit; pJson: TJSONPair);\nvar\n  vTypeInfo: TUnitTypeDefinition;\n  vJsonProps: TJSONObject;\n  vFieldInfo: TUnitFieldDefinition;\n  vTypeObj: TJSONObject;\n  vJsonPropIndex: Integer;\n  vValue : string;\nbegin\n  OutputDebugString(PChar('Child: ' + pJson.ToJSON));\n  vTypeInfo := TUnitTypeDefinition.Create;\n  vTypeInfo.TypeName := 'T' + CapitalizeFirstLetter(pJson.JSONString.Value);\n\n  vJsonProps := (pJson.JSONValue as TJSONObject).Values['properties'] as TJSONObject;\n  for vJsonPropIndex := 0 to vJsonProps.Count - 1 do\n  begin\n    OutputDebugString(PChar(vJsonProps.Pairs[vJsonPropIndex].ToJSON));\n    vFieldInfo := TUnitFieldDefinition.Create;\n    vFieldInfo.FieldName := vJsonProps.Pairs[vJsonPropIndex].JsonString.Value;\n    vTypeObj := vJsonProps.Pairs[vJsonPropIndex].JsonValue as TJSONObject;\n    vFieldInfo.FieldType := vTypeObj.Values['type'].Value;\n    if vFieldInfo.FieldType = 'number' then\n      vFieldInfo.FieldType := 'Double'\n    else if vFieldInfo.FieldType = 'object' then\n    begin\n      vFieldInfo.FieldType := 'T' + CapitalizeFirstLetter(vJsonProps.Pairs[vJsonPropIndex].JsonString.Value);\n      ChildType(pDelphiUnit, vJsonProps.Pairs[vJsonPropIndex]);\n    end;\n    if vTypeObj.TryGetValue('description', vValue) then\n      vFieldInfo.AddAttribute('[MVCDoc(' + QuotedStr(vValue) + ')]');\n\n    if vTypeObj.TryGetValue('format', vValue) then\n    begin\n      if (vFieldInfo.FieldType.ToLower = 'integer') and (vValue.ToLower = 'int64') then\n        vFieldInfo.FieldType := 'Int64';\n      vFieldInfo.AddAttribute('[MVCFormat(' + QuotedStr(vValue) + ')]');\n    end;\n    if vTypeObj.TryGetValue('maxLength', vValue) then\n      vFieldInfo.AddAttribute('[MVCMaxLength(' + vValue + ')]');\n    vTypeInfo.Fields.Add(vFieldInfo);\n  end;\n  pDelphiUnit.AddType(vTypeInfo);\nend;\n\nprocedure TSwagDocToDelphiRESTClientBuilder.ConvertSwaggerDefinitionsToTypeDefinitions(pDelphiUnit: TDelphiUnit);\nvar\n  vTypeInfo: TUnitTypeDefinition;\n  vJsonProps: TJSONObject;\n  vFieldInfo: TUnitFieldDefinition;\n  vTypeObj: TJSONObject;\n  DefinitionIndex: Integer;\n  vJsonPropIndex: Integer;\n  vValue : string;\nbegin\n  for DefinitionIndex := 0 to fSwagDoc.Definitions.Count - 1 do\n  begin\n    vTypeInfo := TUnitTypeDefinition.Create;\n    vTypeInfo.TypeName := 'T' + CapitalizeFirstLetter(fSwagDoc.Definitions[DefinitionIndex].Name);\n    vJsonProps := fSwagDoc.Definitions[DefinitionIndex].JsonSchema.Values['properties'] as TJSONObject;\n    for vJsonPropIndex := 0 to vJsonProps.Count - 1 do\n    begin\n      OutputDebugString(PChar(vJsonProps.Pairs[vJsonPropIndex].ToJSON));\n      vFieldInfo := TUnitFieldDefinition.Create;\n      vFieldInfo.FieldName := vJsonProps.Pairs[vJsonPropIndex].JsonString.Value;\n      vTypeObj := vJsonProps.Pairs[vJsonPropIndex].JsonValue as TJSONObject;\n      if Assigned(vTypeObj.Values['type']) then\n        vFieldInfo.FieldType := vTypeObj.Values['type'].Value\n      else\n        vFieldInfo.FieldType := ConvertRefToType(vTypeObj.Values['$ref'].Value);\n\n      if vFieldInfo.FieldType = 'number' then\n        vFieldInfo.FieldType := 'Double'\n      else if vFieldInfo.FieldType = 'object' then\n      begin\n        vFieldInfo.FieldType := 'T' + CapitalizeFirstLetter(vJsonProps.Pairs[vJsonPropIndex].JsonString.Value);\n        ChildType(pDelphiUnit, vJsonProps.Pairs[vJsonPropIndex]);\n      end\n      else if vFieldInfo.FieldType = 'array' then\n      begin\n        HandleArray(vFieldInfo, vJsonProps.Pairs[vJsonPropIndex]);\n      end;\n      if vTypeObj.TryGetValue('description', vValue) then\n      begin\n        if vValue.Trim.Length > 0 then\n          vFieldInfo.AddAttribute('[MVCDoc(' + QuotedStr(vValue) + ')]');\n      end;\n      if vTypeObj.TryGetValue('format', vValue) then\n      begin\n        if (vFieldInfo.FieldType.ToLower = 'integer') and (vValue.ToLower = 'int64') then\n          vFieldInfo.FieldType := 'Int64';\n        vFieldInfo.AddAttribute('[MVCFormat(' + QuotedStr(vValue) + ')]');\n      end;\n      if vTypeObj.TryGetValue('maxLength', vValue) then\n        vFieldInfo.AddAttribute('[MVCMaxLength(' + vValue + ')]');\n      if vTypeObj.TryGetValue('minimum', vValue) then\n        vFieldInfo.AddAttribute('[MVCMinimum(' + vValue + ')]');\n      if vTypeObj.TryGetValue('maximum', vValue) then\n        vFieldInfo.AddAttribute('[MVCMaximum(' + vValue + ')]');\n      vTypeInfo.Fields.Add(vFieldInfo);\n    end;\n    pDelphiUnit.AddType(vTypeInfo);\n  end;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.ConvertSwaggerTypeToDelphiType(pSwaggerType: TSwagRequestParameter): TUnitTypeDefinition;\nvar\n  vSwaggerType: TSwagTypeParameter;\n  vJson: TJSONObject;\nbegin\n  Result := TUnitTypeDefinition.Create;\n  vSwaggerType := pSwaggerType.TypeParameter;\n  case vSwaggerType of\n    stpNotDefined:\n    begin\n      if Assigned(pSwaggerType.Schema.JsonSchema.Values['$ref']) then\n        Result.TypeName := ConvertRefToType(pSwaggerType.Schema.JsonSchema.Values['$ref'].Value)\n      else\n      begin\n        Result.TypeName := pSwaggerType.Schema.JsonSchema.Values['type'].Value;\n        if Result.TypeName = 'array' then\n        begin\n          if Assigned(pSwaggerType.Schema.JsonSchema.Values['items']) then\n            if Assigned((pSwaggerType.Schema.JsonSchema.Values['items'] as TJSONObject).Values['$ref']) then\n              Result.TypeName := 'array of ' + ConvertRefToType((pSwaggerType.Schema.JsonSchema.Values['items'] as TJSONObject).Values['$ref'].Value);\n        end;\n      end;\n    end;\n    stpString: Result.TypeName := 'String';\n    stpNumber: Result.TypeName := 'Double';\n    stpInteger: Result.TypeName := 'Integer';\n    stpBoolean: Result.TypeName := 'Boolean';\n    stpArray:\n    begin\n      vJson := pSwaggerType.Schema.JsonSchema;\n      if Assigned(vJson) then\n      begin\n        OutputDebugString(PChar('TYPE: ' + vJson.ToJson));\n        Result.TypeName := 'array of ' + pSwaggerType.Schema.JsonSchema.Values['type'].Value;\n      end\n      else\n      begin\n        if Assigned(pSwaggerType.Items.Values['type']) then\n        begin\n          Result.TypeName := 'array of ' + pSwaggerType.Items.Values['type'].Value;\n        end\n        else\n          Result.TypeName := 'array of ';\n      end;\n    end;\n    stpFile: Result.TypeName := 'err File';\n  end;\nend;\n\nfunction TSwagDocToDelphiRESTClientBuilder.GenerateUnitText(pDelphiUnit: TDelphiUnit): string;\nbegin\n  pDelphiUnit.Title := fSwagDoc.Info.Title;\n  pDelphiUnit.Description := fSwagDoc.Info.Description;\n  pDelphiUnit.License := fSwagDoc.Info.License.Name;\n  Result := pDelphiUnit.Generate;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.Json;\nusing Swag.Doc;\nusing Swag.Common.Types;\nusing Swag.Doc.Path.Operation;\nusing Swag.Doc.Path.Operation.Response;\nusing Swag.Doc.Path.Operation.RequestParameter;\nusing Sample.DelphiUnit.Generate;\nusing System.Text;\n\nnamespace Sample.MvcControllerClientFileBuilder\n{\n    public class SwagDocToDelphiRESTClientBuilder\n    {\n        private TSwagDoc _swagDoc;\n        public SwagDocToDelphiRESTClientBuilder(TSwagDoc pSwagDoc)\n        {\n            _swagDoc = pSwagDoc;\n        }\n        private string CapitalizeFirstLetter(string pTypeName)\n        {\n            if (pTypeName.Length > 2)\n                return char.ToUpper(pTypeName[0]) + pTypeName.Substring(1);\n            return pTypeName;\n        }\n        private string RewriteUriToSwaggerWay(string pUri)\n        {\n            return pUri.Replace(\"{\", \"($\").Replace(\"}\", \")\");\n        }\n        private string OperationIdToFunctionName(TSwagPathOperation pOperation)\n        {\n            string result = pOperation.OperationId.Replace(\"{\", \"\").Replace(\"}\", \"\").Replace(\"-\", \"\");\n            if (!char.IsLetter(result[0]))\n                result = \"F\" + result;\n            return CapitalizeFirstLetter(result);\n        }\n        private string GenerateUnitText(TDelphiUnit pDelphiUnit)\n        {\n            pDelphiUnit.Title = _swagDoc.Info.Title;\n            pDelphiUnit.Description = _swagDoc.Info.Description;\n            pDelphiUnit.License = _swagDoc.Info.License.Name;\n            return pDelphiUnit.Generate();\n        }\n        private TUnitTypeDefinition ConvertSwaggerTypeToDelphiType(TSwagRequestParameter pSwaggerType)\n        {\n            TUnitTypeDefinition result = new TUnitTypeDefinition();\n            TSwagTypeParameter vSwaggerType = pSwaggerType.TypeParameter;\n            switch (vSwaggerType)\n            {\n                case TSwagTypeParameter.stpNotDefined:\n                    if (pSwaggerType.Schema.JsonSchema.TryGetValue(\"$ref\", out string refValue) && !string.IsNullOrEmpty(refValue))\n                        result.TypeName = ConvertRefToType(refValue);\n                    else\n                    {\n                        result.TypeName = pSwaggerType.Schema.JsonSchema.GetValue(\"type\").ToString();\n                        if (result.TypeName.ToLower() == \"array\")\n                        {\n                            if (pSwaggerType.Schema.JsonSchema.TryGetValue(\"items\", out string itemsJson))\n                                result.TypeName = \"array of \" + pSwaggerType.Schema.JsonSchema.GetValue(\"type\").ToString();\n                        }\n                    }\n                    break;\n                case TSwagTypeParameter.stpString:\n                    result.TypeName = \"String\";\n                    break;\n                case TSwagTypeParameter.stpNumber:\n                    result.TypeName = \"Double\";\n                    break;\n                case TSwagTypeParameter.stpInteger:\n                    result.TypeName = \"Integer\";\n                    break;\n                case TSwagTypeParameter.stpBoolean:\n                    result.TypeName = \"Boolean\";\n                    break;\n                case TSwagTypeParameter.stpArray:\n                    {\n                        var vJson = pSwaggerType.Schema.JsonSchema;\n                        if (vJson != null)\n                            result.TypeName = \"array of \" + vJson.GetValue(\"type\").ToString();\n                        else\n                        {\n                            if (pSwaggerType.Items.Values.TryGetValue(\"type\", out object typeObj))\n                                result.TypeName = \"array of \" + typeObj.ToString();\n                            else\n                                result.TypeName = \"array of \";\n                        }\n                    }\n                    break;\n                case TSwagTypeParameter.stpFile:\n                    result.TypeName = \"err File\";\n                    break;\n            }\n            return result;\n        }\n        private string ConvertRefToType(string pRef)\n        {\n            int idx = pRef.LastIndexOf('/');\n            string result = pRef.Substring(idx + 1);\n            result = char.ToUpper(result[0]) + result.Substring(1);\n            if (result.ToLower() != \"string\")\n                result = \"T\" + result;\n            return result;\n        }\n        private string ConvertRefToVarName(string pRef)\n        {\n            int idx = pRef.LastIndexOf('/');\n            return pRef.Substring(idx + 1);\n        }\n        private void ChildType(TDelphiUnit pDelphiUnit, TJsonPair pJson)\n        {\n            TUnitTypeDefinition vTypeInfo = new TUnitTypeDefinition();\n            vTypeInfo.TypeName = \"T\" + CapitalizeFirstLetter(pJson.JsonString.Value);\n            TJsonObject vJsonProps = pJson.JsonValue.GetValue(\"properties\") as TJsonObject;\n            for (int i = 0; i < vJsonProps.Count; i++)\n            {\n                TUnitFieldDefinition vFieldInfo = new TUnitFieldDefinition();\n                vFieldInfo.FieldName = vJsonProps.Pairs[i].JsonString.Value;\n                TJsonObject vTypeObj = vJsonProps.Pairs[i].JsonValue as TJsonObject;\n                vFieldInfo.FieldType = vTypeObj.GetValue(\"type\").ToString();\n                if (vFieldInfo.FieldType == \"number\")\n                    vFieldInfo.FieldType = \"Double\";\n                else if (vFieldInfo.FieldType == \"object\")\n                {\n                    vFieldInfo.FieldType = \"T\" + CapitalizeFirstLetter(vJsonProps.Pairs[i].JsonString.Value);\n                    ChildType(pDelphiUnit, vJsonProps.Pairs[i]);\n                }\n                if (vTypeObj.TryGetValue(\"description\", out object vValue))\n                    vFieldInfo.AddAttribute(\"[MVCDoc(\" + Quote(vValue.ToString()) + \")]\");\n                if (vTypeObj.TryGetValue(\"format\", out vValue))\n                {\n                    if (vFieldInfo.FieldType.ToLower() == \"integer\" && vValue.ToString().ToLower() == \"int64\")\n                        vFieldInfo.FieldType = \"Int64\";\n                    vFieldInfo.AddAttribute(\"[MVCFormat(\" + Quote(vValue.ToString()) + \")]\");\n                }\n                if (vTypeObj.TryGetValue(\"maxLength\", out vValue))\n                    vFieldInfo.AddAttribute(\"[MVCMaxLength(\" + vValue.ToString() + \")]\");\n                vTypeInfo.Fields.Add(vFieldInfo);\n            }\n            pDelphiUnit.AddType(vTypeInfo);\n        }\n        private void HandleArray(TUnitFieldDefinition pField, TJsonPair pJson)\n        {\n            TJsonObject jsonObj = pJson.JsonValue as TJsonObject;\n            if (jsonObj.Values.ContainsKey(\"items\") && (jsonObj.Values[\"items\"] as TJsonObject).Values.ContainsKey(\"type\"))\n            {\n                string vType = (jsonObj.Values[\"items\"] as TJsonObject).Values[\"type\"].ToString();\n                if (vType.ToLower() != \"string\")\n                    vType = \"T\" + vType;\n                pField.FieldType = \"array of \" + vType;\n            }\n            else\n            {\n                TJsonObject vJsonVal = jsonObj.Values[\"items\"] as TJsonObject;\n                string vRef = vJsonVal.Values[\"$ref\"].ToString();\n                pField.FieldType = \"array of \" + ConvertRefToType(vRef);\n            }\n        }\n        private void ConvertSwaggerDefinitionsToTypeDefinitions(TDelphiUnit pDelphiUnit)\n        {\n            for (int i = 0; i < _swagDoc.Definitions.Count; i++)\n            {\n                TUnitTypeDefinition vTypeInfo = new TUnitTypeDefinition();\n                vTypeInfo.TypeName = \"T\" + CapitalizeFirstLetter(_swagDoc.Definitions[i].Name);\n                TJsonObject vJsonProps = _swagDoc.Definitions[i].JsonSchema.GetValue(\"properties\") as TJsonObject;\n                for (int j = 0; j < vJsonProps.Count; j++)\n                {\n                    TUnitFieldDefinition vFieldInfo = new TUnitFieldDefinition();\n                    vFieldInfo.FieldName = vJsonProps.Pairs[j].JsonString.Value;\n                    TJsonObject vTypeObj = vJsonProps.Pairs[j].JsonValue as TJsonObject;\n                    if (vTypeObj.Values.ContainsKey(\"type\"))\n                        vFieldInfo.FieldType = vTypeObj.Values[\"type\"].ToString();\n                    else\n                        vFieldInfo.FieldType = ConvertRefToType(vTypeObj.Values[\"$ref\"].ToString());\n                    if (vFieldInfo.FieldType == \"number\")\n                        vFieldInfo.FieldType = \"Double\";\n                    else if (vFieldInfo.FieldType == \"object\")\n                    {\n                        vFieldInfo.FieldType = \"T\" + CapitalizeFirstLetter(vJsonProps.Pairs[j].JsonString.Value);\n                        ChildType(pDelphiUnit, vJsonProps.Pairs[j]);\n                    }\n                    else if (vFieldInfo.FieldType == \"array\")\n                    {\n                        HandleArray(vFieldInfo, vJsonProps.Pairs[j]);\n                    }\n                    if (vTypeObj.TryGetValue(\"description\", out object vValue) && vValue.ToString().Trim().Length > 0)\n                        vFieldInfo.AddAttribute(\"[MVCDoc(\" + Quote(vValue.ToString()) + \")]\");\n                    if (vTypeObj.TryGetValue(\"format\", out vValue))\n                    {\n                        if (vFieldInfo.FieldType.ToLower() == \"integer\" && vValue.ToString().ToLower() == \"int64\")\n                            vFieldInfo.FieldType = \"Int64\";\n                        vFieldInfo.AddAttribute(\"[MVCFormat(\" + Quote(vValue.ToString()) + \")]\");\n                    }\n                    if (vTypeObj.TryGetValue(\"maxLength\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMaxLength(\" + vValue.ToString() + \")]\");\n                    if (vTypeObj.TryGetValue(\"minimum\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMinimum(\" + vValue.ToString() + \")]\");\n                    if (vTypeObj.TryGetValue(\"maximum\", out vValue))\n                        vFieldInfo.AddAttribute(\"[MVCMaximum(\" + vValue.ToString() + \")]\");\n                    vTypeInfo.Fields.Add(vFieldInfo);\n                }\n                pDelphiUnit.AddType(vTypeInfo);\n            }\n        }\n        private string Quote(string s)\n        {\n            return \"\\\"\" + s + \"\\\"\";\n        }\n        public string Generate()\n        {\n            TDelphiUnit vDelphiUnit = new TDelphiUnit();\n            vDelphiUnit.UnitFile = \"UnitFilenameMvcControllerClient\";\n            vDelphiUnit.AddInterfaceUnit(\"IPPeerClient\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Client\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Authenticator.OAuth\");\n            vDelphiUnit.AddInterfaceUnit(\"REST.Types\");\n            vDelphiUnit.AddInterfaceUnit(\"MVCFramework\");\n            vDelphiUnit.AddInterfaceUnit(\"MVCFramework.Commons\");\n            ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n            TUnitTypeDefinition vMVCControllerClient = new TUnitTypeDefinition();\n            vMVCControllerClient.TypeName = \"TMyMVCControllerClient\";\n            vMVCControllerClient.TypeInherited = \"TObject\";\n            vMVCControllerClient.AddAttribute(\"  [MVCPath('\" + RewriteUriToSwaggerWay(_swagDoc.BasePath) + \"')]\");\n\n            TUnitFieldDefinition vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTClient\";\n            vField.FieldType = \"TRESTClient\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTRequest\";\n            vField.FieldType = \"TRESTRequest\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vField = new TUnitFieldDefinition();\n            vField.FieldName = \"RESTResponse\";\n            vField.FieldType = \"TRESTResponse\";\n            vMVCControllerClient.Fields.Add(vField);\n\n            vDelphiUnit.AddType(vMVCControllerClient);\n            ConvertSwaggerDefinitionsToTypeDefinitions(vDelphiUnit);\n            for (int pathIndex = 0; pathIndex < _swagDoc.Paths.Count; pathIndex++)\n            {\n                for (int opIndex = 0; opIndex < _swagDoc.Paths[pathIndex].Operations.Count; opIndex++)\n                {\n                    TUnitMethod vMethod = new TUnitMethod();\n                    if (_swagDoc.Paths[pathIndex].Operations[opIndex].Description.Trim().Length > 0)\n                        vMethod.AddAttribute(\"    [MVCDoc(\" + Quote(_swagDoc.Paths[pathIndex].Operations[opIndex].Description) + \")]\");\n                    vMethod.AddAttribute(\"    [MVCPath('\" + _swagDoc.Paths[pathIndex].Uri + \"')]\"); \n                    vMethod.AddAttribute(\"    [MVCHTTPMethod([http\" + _swagDoc.Paths[pathIndex].Operations[opIndex].OperationToString + \"])]\");\n                    vMethod.Name = OperationIdToFunctionName(_swagDoc.Paths[pathIndex].Operations[opIndex]);\n                    for (int paramIndex = 0; paramIndex < _swagDoc.Paths[pathIndex].Operations[opIndex].Parameters.Count; paramIndex++)\n                    {\n                        TUnitParameter vResultParam = new TUnitParameter();\n                        vResultParam.ParamName = CapitalizeFirstLetter(_swagDoc.Paths[pathIndex].Operations[opIndex].Parameters[paramIndex].Name);\n                        vResultParam.ParamType = ConvertSwaggerTypeToDelphiType(_swagDoc.Paths[pathIndex].Operations[opIndex].Parameters[paramIndex]);\n                        vMethod.AddParameter(vResultParam);\n                    }\n                    foreach (var response in _swagDoc.Paths[pathIndex].Operations[opIndex].Responses)\n                    {\n                        TJsonObject vSchemaObj = response.Value.Schema.JsonSchema;\n                        if (vSchemaObj == null)\n                            continue;\n                        if (vSchemaObj.TryGetValue(\"$ref\", out string vRef))\n                        {\n                            vMethod.AddAttribute(\"    [MVCResponse(\" + response.Key + \", \" + Quote(response.Value.Description) + \", \" + ConvertRefToType(vRef) + \")]\");\n                            TUnitParameter vResultParam = new TUnitParameter();\n                            vResultParam.ParamName = ConvertRefToVarName(vRef);\n                            vResultParam.ParamType = new TUnitTypeDefinition { TypeName = ConvertRefToType(vRef) };\n                            vMethod.AddLocalVariable(vResultParam);\n                            vMethod.Content.Add(\"  \" + ConvertRefToVarName(vRef) + \" := \" + ConvertRefToType(vRef) + \".Create;\");\n                        }\n                        else\n                        {\n                            if (!vSchemaObj.TryGetValue(\"properties\", out _))\n                                continue;\n                            if (!vSchemaObj.TryGetValue(\"employees\", out _))\n                                continue;\n                            if (!vSchemaObj.TryGetValue(\"items\", out _))\n                                continue;\n                            if (vSchemaObj.TryGetValue(\"$ref\", out vRef))\n                            {\n                                vMethod.AddAttribute(\"    [MVCResponseList(\" + response.Key + \", \" + Quote(response.Value.Description) + \", \" + ConvertRefToType(vRef) + \")]\");\n                                TUnitParameter vResultParam = new TUnitParameter();\n                                vResultParam.ParamName = ConvertRefToVarName(vRef);\n                                vResultParam.ParamType = new TUnitTypeDefinition { TypeName = \"TObjectList<\" + ConvertRefToType(vRef) + \">\" };\n                                vMethod.AddLocalVariable(vResultParam);\n                                vDelphiUnit.AddInterfaceUnit(\"Generics.Collections\");\n                                vMethod.Content.Add(\"  \" + ConvertRefToVarName(vRef) + \" := TObjectList<\" + ConvertRefToType(vRef) + \">.Create;\");\n                            }\n                        }\n                    }\n                    vMVCControllerClient.Methods.Add(vMethod);\n                }\n            }\n            vDelphiUnit.SortTypeDefinitions();\n            return GenerateUnitText(vDelphiUnit);\n        }\n    }\n}"}
{"input": "unit Controller.Customers;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.ActiveRecord,\n  FireDAC.Comp.Client,\n  FireDAC.Phys.SQLite,\n  MVCFramework.SQLGenerators.Sqlite,\n  System.Generics.Collections,\n  Model.Customer,\n  System.JSON;\n\ntype\n\n  [MVCPath('/api')]\n  TCustomersController = class(TMVCController)\n  private\n    FDConn : TFDConnection;\n  public\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomers;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomer(id: Integer);\n\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure CreateCustomer;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    procedure UpdateCustomer(id: Integer);\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    procedure DeleteCustomer(id: Integer);\n\n    constructor Create; override;\n    destructor Destroy; override;\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\n\n//Sample CRUD Actions for a \"Customer\" entity\nprocedure TCustomersController.GetCustomers;\nbegin\n  Render<TCustomer>(TMVCActiveRecord.SelectRQL<TCustomer>('sort(+id)', 200));\nend;\n\nprocedure TCustomersController.GetCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := TMVCActiveRecord.GetByPK<TCustomer>(id);\n\n  Render(lCustomer);\nend;\n\nconstructor TCustomersController.Create;\nbegin\n  inherited;\n  FDConn := TFDConnection.Create(nil);\n  FDConn.Params.Clear;\n  FDConn.Params.Database :=  '../../../data/activerecorddb.db';\n  FDConn.DriverName := 'SQLite';\n  FDConn.Connected := True;\n\n  ActiveRecordConnectionsRegistry.AddDefaultConnection(FDConn);\nend;\n\nprocedure TCustomersController.CreateCustomer;\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := Context.Request.BodyAs<TCustomer>;\n  try\n    lCustomer.Insert;\n  finally\n    lCustomer.Free;\n  end;\n  Render201Created();\nend;\n\nprocedure TCustomersController.UpdateCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := Context.Request.BodyAs<TCustomer>;\n  lCustomer.id := id;\n\n  lCustomer.Update;\n  Render(lCustomer);\nend;\n\nprocedure TCustomersController.DeleteCustomer(id: Integer);\nvar\n  lCustomer : TCustomer;\nbegin\n  lCustomer := TMVCActiveRecord.GetByPK<TCustomer>(id);\n  lCustomer.Delete;\n\n  Render(TJSONObject.Create(TJSONPair.Create('result', 'register successefully deleted')));\nend;\n\ndestructor TCustomersController.Destroy;\nbegin\n  ActiveRecordConnectionsRegistry.RemoveDefaultConnection;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Data.Sqlite;\n\nnamespace Controller.Customers\n{\n   \n    [Route(\"api\")]\n    [ApiController]\n    public class CustomersController : ControllerBase, IDisposable\n    {\n        private SqliteConnection _fdConn;\n\n        public CustomersController()\n        {\n            var connectionString = new SqliteConnectionStringBuilder\n            {\n                DataSource = \"../../../data/activerecorddb.db\"\n            }.ToString();\n\n            _fdConn = new SqliteConnection(connectionString);\n            _fdConn.Open();\n\n            ActiveRecordConnectionsRegistry.AddDefaultConnection(_fdConn);\n        }\n\n        \n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n            \n            List<TCustomer> customers = TMVCActiveRecord.SelectRQL<TCustomer>(\"sort(+id)\", 200);\n            return Ok(customers);\n        }\n\n        \n        [HttpGet(\"customers/{id}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            TCustomer customer = TMVCActiveRecord.GetByPK<TCustomer>(id);\n            if (customer == null)\n                return NotFound();\n\n            return Ok(customer);\n        }\n\n        \n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer([FromBody] TCustomer customer)\n        {\n            if (customer == null)\n                return BadRequest();\n\n            try\n            {\n                customer.Insert();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            \n            return StatusCode(201);\n        }\n\n        \n        [HttpPut(\"customers/{id}\")]\n        public IActionResult UpdateCustomer(int id, [FromBody] TCustomer customer)\n        {\n            if (customer == null)\n                return BadRequest();\n\n            \n            customer.ID = id;\n\n            try\n            {\n                customer.Update();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            return Ok(customer);\n        }\n\n        \n        [HttpDelete(\"customers/{id}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            TCustomer customer = TMVCActiveRecord.GetByPK<TCustomer>(id);\n            if (customer == null)\n                return NotFound();\n\n            try\n            {\n                customer.Delete();\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ex.Message);\n            }\n\n            \n            return Ok(new { result = \"register successefully deleted\" });\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                ActiveRecordConnectionsRegistry.RemoveDefaultConnection();\n                if (_fdConn != null)\n                {\n                    _fdConn.Close();\n                    _fdConn.Dispose();\n                    _fdConn = null;\n                }\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n    }\n\n    \n    public static class ActiveRecordConnectionsRegistry\n    {\n        private static SqliteConnection _defaultConnection;\n        public static void AddDefaultConnection(SqliteConnection connection)\n        {\n            _defaultConnection = connection;\n        }\n\n        public static void RemoveDefaultConnection()\n        {\n            _defaultConnection = null;\n        }\n\n        public static SqliteConnection DefaultConnection => _defaultConnection;\n    }\n\n        public abstract class TMVCActiveRecord\n    {\n        public abstract void Insert();\n        public abstract void Update();\n        public abstract void Delete();\n\n        \n        public static List<T> SelectRQL<T>(string query, int limit) where T : TMVCActiveRecord, new()\n        {\n            \n            return new List<T>();\n        }\n\n        \n        public static T GetByPK<T>(int id) where T : TMVCActiveRecord, new()\n        {\n            \n            return new T();\n        }\n    }\n\n    \n    public class TCustomer : TMVCActiveRecord\n    {\n        public int ID { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        \n\n        public override void Insert()\n        {\n            // Insert logic here.\n        }\n\n        public override void Update()\n        {\n            // Update logic here.\n        }\n\n        public override void Delete()\n        {\n            // Delete logic here.\n        }\n    }\n}"}
{"input": "/// Framework Core Low-Level Wrappers to the Operating-System API\n// - this unit is a part of the Open Source Synopse mORMot framework 2,\n// licensed under a MPL/GPL/LGPL three license - see LICENSE.md\nunit mormot.core.os;\n\n{\n  *****************************************************************************\n\n  Cross-platform functions shared by all framework units\n  - Some Cross-System Type and Constant Definitions\n  - Gather Operating System Information\n  - Operating System Specific Types (e.g. TWinRegistry)\n  - Unicode, Time, File, Console, Library process\n  - Cross-Platform Charset and CodePage Support\n  - Per Class Properties O(1) Lookup via vmtAutoTable Slot (e.g. for RTTI cache)\n  - TSynLocker/TSynLocked and Low-Level Threading Features\n  - Unix Daemon and Windows Service Support\n\n   Aim of this unit is to centralize most used OS-specific API calls, like a\n  SysUtils unit on steroids, to avoid $ifdef/$endif in \"uses\" clauses.\n   In practice, no \"Windows\", nor \"Linux/Posix\" reference should be needed in\n  regular units, once mormot.core.os is included. :)\n   This unit only refers to mormot.core.base so can be used almost stand-alone.\n\n  *****************************************************************************\n}\n\ninterface\n\n{$I mormot.defines.inc}\n\nuses\n  {$ifdef OSWINDOWS}\n  Windows, // needed here e.g. for redefinition/redirection of standard types\n  Messages,\n  {$endif OSWINDOWS}\n  classes,\n  contnrs,\n  types,\n  sysutils,\n  mormot.core.base;\n\n\n{ ****************** Some Cross-System Type and Constant Definitions }\n\nconst\n  {$ifdef OSWINDOWS}\n  /// operating-system dependent Line Feed characters (#13#10 or #10)\n  CRLF = #13#10;\n  /// operating-system dependent wildchar to match all files in a folder\n  FILES_ALL = '*.*';\n  /// operating-system dependent \"inverted\" delimiter for NormalizeFileName()\n  InvertedPathDelim = '/';\n  /// operating-system dependent boolean if paths are case-insensitive\n  PathCaseInsensitive = true;\n  {$else}\n  /// operating-system dependent Line Feed characters\n  CRLF = #10;\n  /// operating-system dependent wildchar to match all files in a folder\n  FILES_ALL = '*';\n  /// operating-system dependent \"inverted\" delimiter for NormalizeFileName()\n  InvertedPathDelim = '\\';\n  /// operating-system dependent boolean if paths are case-insensitive\n  PathCaseInsensitive = false;\n  {$endif OSWINDOWS}\n\n  /// human-friendly alias to open a file for exclusive writing\n  fmShareRead      = fmShareDenyWrite;\n  /// human-friendly alias to open a file for exclusive reading\n  fmShareWrite     = fmShareDenyRead;\n  /// human-friendly alias to open a file with no read/write exclusion\n  fmShareReadWrite = fmShareDenyNone;\n\n  /// a convenient constant to open a file for reading without exclusion\n  fmOpenReadShared = fmOpenRead or fmShareReadWrite;\n\n  /// a convenient constant to open a file for writing without exclusion\n  fmOpenWriteShared = fmOpenReadWrite or fmShareReadWrite;\n\n  /// a convenient constant to create a file without exclusion\n  fmCreateShared = fmCreate or fmShareReadWrite;\n\n  /// a convenient array constant to open a file for writing without exclusion\n  fmCreateOrRewrite: array[{rewrite=}boolean] of cardinal = (\n   fmCreateShared,\n   fmOpenWriteShared);\n\nconst\n  /// void HTTP Status Code (not a standard value, for internal use only)\n  HTTP_NONE = 0;\n  /// HTTP Status Code for \"Continue\"\n  HTTP_CONTINUE = 100;\n  /// HTTP Status Code for \"Switching Protocols\"\n  HTTP_SWITCHINGPROTOCOLS = 101;\n  /// HTTP Status Code for \"Success\"\n  HTTP_SUCCESS = 200;\n  /// HTTP Status Code for \"Created\"\n  HTTP_CREATED = 201;\n  /// HTTP Status Code for \"Accepted\"\n  HTTP_ACCEPTED = 202;\n  /// HTTP Status Code for \"Non-Authoritative Information\"\n  HTTP_NONAUTHORIZEDINFO = 203;\n  /// HTTP Status Code for \"No Content\"\n  HTTP_NOCONTENT = 204;\n  /// HTTP Status Code for \"Reset Content\"\n  HTTP_RESETCONTENT = 205;\n  /// HTTP Status Code for \"Partial Content\"\n  HTTP_PARTIALCONTENT = 206;\n  /// HTTP Status Code for \"Multiple Choices\"\n  HTTP_MULTIPLECHOICES = 300;\n  /// HTTP Status Code for \"Moved Permanently\"\n  HTTP_MOVEDPERMANENTLY = 301;\n  /// HTTP Status Code for \"Found\"\n  HTTP_FOUND = 302;\n  /// HTTP Status Code for \"See Other\"\n  HTTP_SEEOTHER = 303;\n  /// HTTP Status Code for \"Not Modified\"\n  HTTP_NOTMODIFIED = 304;\n  /// HTTP Status Code for \"Use Proxy\"\n  HTTP_USEPROXY = 305;\n  /// HTTP Status Code for \"Temporary Redirect\"\n  HTTP_TEMPORARYREDIRECT = 307;\n  /// HTTP Status Code for \"Permanent Redirect\"\n  HTTP_PERMANENTREDIRECT = 308;\n  /// HTTP Status Code for \"Bad Request\"\n  HTTP_BADREQUEST = 400;\n  /// HTTP Status Code for \"Unauthorized\"\n  HTTP_UNAUTHORIZED = 401;\n  /// HTTP Status Code for \"Forbidden\"\n  HTTP_FORBIDDEN = 403;\n  /// HTTP Status Code for \"Not Found\"\n  HTTP_NOTFOUND = 404;\n  // HTTP Status Code for \"Method Not Allowed\"\n  HTTP_NOTALLOWED = 405;\n  // HTTP Status Code for \"Not Acceptable\"\n  HTTP_NOTACCEPTABLE = 406;\n  // HTTP Status Code for \"Proxy Authentication Required\"\n  HTTP_PROXYAUTHREQUIRED = 407;\n  /// HTTP Status Code for \"Request Time-out\"\n  HTTP_TIMEOUT = 408;\n  /// HTTP Status Code for \"Conflict\"\n  HTTP_CONFLICT = 409;\n  /// HTTP Status Code for \"Payload Too Large\"\n  HTTP_PAYLOADTOOLARGE = 413;\n  /// HTTP Status Code for \"Range Not Satisfiable\"\n  HTTP_RANGENOTSATISFIABLE = 416;\n  /// HTTP Status Code for \"I'm a teapot\"\n  HTTP_TEAPOT = 418;\n  /// HTTP Status Code for \"Internal Server Error\"\n  HTTP_SERVERERROR = 500;\n  /// HTTP Status Code for \"Not Implemented\"\n  HTTP_NOTIMPLEMENTED = 501;\n  /// HTTP Status Code for \"Bad Gateway\"\n  HTTP_BADGATEWAY = 502;\n  /// HTTP Status Code for \"Service Unavailable\"\n  HTTP_UNAVAILABLE = 503;\n  /// HTTP Status Code for \"Gateway Timeout\"\n  HTTP_GATEWAYTIMEOUT = 504;\n  /// HTTP Status Code for \"HTTP Version Not Supported\"\n  HTTP_HTTPVERSIONNONSUPPORTED = 505;\n\n  /// clearly wrong response code, used by THttpServerRequest.SetAsyncResponse\n  // - for internal THttpAsyncServer asynchronous process\n  HTTP_ASYNCRESPONSE = 777;\n\n  /// the successful HTTP response codes after a GET request\n  HTTP_GET_OK = [HTTP_SUCCESS, HTTP_NOCONTENT, HTTP_PARTIALCONTENT];\n\n/// retrieve the HTTP reason text from its integer code as PRawUtf8\n// - e.g. StatusCodeToText(200)^='OK'\n// - as defined in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n// - returns the generic 'Invalid Request' for any unknown Code\nfunction StatusCodeToText(Code: cardinal): PRawUtf8;\n\n/// retrieve the HTTP reason text from its integer code\n// - as defined in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\nprocedure StatusCodeToReason(Code: cardinal; var Reason: RawUtf8);\n\n/// convert any HTTP_* constant to an integer status code and its English text\n// - returns e.g. '200 OK' or '404 Not Found', calling StatusCodeToText()\nfunction StatusCodeToShort(Code: cardinal): TShort47;\n\n/// returns true for successful HTTP status codes, i.e. in 200..399 range\n// - will map mainly SUCCESS (200), CREATED (201), NOCONTENT (204),\n// PARTIALCONTENT (206), NOTMODIFIED (304) or TEMPORARYREDIRECT (307) codes\n// - any HTTP status not part of this range will be identified as erronous\n// request in the internal server statistics\nfunction StatusCodeIsSuccess(Code: integer): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// check the supplied HTTP header to not contain more than one EOL\n// - to avoid unexpected HTTP body injection, e.g. from unsafe business code\nfunction IsInvalidHttpHeader(head: PUtf8Char; headlen: PtrInt): boolean;\n\n\nconst\n  /// HTTP header name for the content type, as defined in the corresponding RFC\n  HEADER_CONTENT_TYPE = 'Content-Type: ';\n\n  /// HTTP header name for the content type, in upper case\n  // - as defined in the corresponding RFC\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  HEADER_CONTENT_TYPE_UPPER = 'CONTENT-TYPE: ';\n\n  /// HTTP header name for the client IP, in upper case\n  // - as defined in our HTTP server classes\n  // - could be used e.g. with IdemPChar() to retrieve the remote IP address\n  HEADER_REMOTEIP_UPPER = 'REMOTEIP: ';\n\n  /// HTTP header name for the authorization token, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve a JWT value\n  // - will detect header computed e.g. by motmot.net.http's\n  // AuthorizationBearer()\n  HEADER_BEARER_UPPER = 'AUTHORIZATION: BEARER ';\n\n  /// MIME content type used for JSON communication (as used by the Microsoft\n  // WCF framework and the YUI framework)\n  // - no 'charset=UTF-8' encoding is necessary, as by specified by RFC 7159\n  JSON_CONTENT_TYPE = 'application/json';\n\n  /// HTTP header for MIME content type used for plain JSON\n  // - i.e. 'Content-Type: application/json'\n  JSON_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + JSON_CONTENT_TYPE;\n\n  /// MIME content type used for plain JSON, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  JSON_CONTENT_TYPE_UPPER = 'APPLICATION/JSON';\n\n  /// HTTP header for MIME content type used for plain JSON, in upper case\n  // - could be used e.g. with IdemPChar() to retrieve the Content-Type value\n  JSON_CONTENT_TYPE_HEADER_UPPER =\n    HEADER_CONTENT_TYPE_UPPER + JSON_CONTENT_TYPE_UPPER;\n\n  /// MIME content type used for plain UTF-8 text\n  TEXT_CONTENT_TYPE = 'text/plain; charset=UTF-8';\n\n  /// HTTP header for MIME content type used for plain UTF-8 text\n  TEXT_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + TEXT_CONTENT_TYPE;\n\n  /// MIME content type used for UTF-8 encoded HTML\n  HTML_CONTENT_TYPE = 'text/html; charset=UTF-8';\n\n  /// HTTP header for MIME content type used for UTF-8 encoded HTML\n  HTML_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + HTML_CONTENT_TYPE;\n\n  /// MIME content type used for UTF-8 encoded XML\n  XML_CONTENT_TYPE = 'text/xml';\n\n  /// HTTP header for MIME content type used for UTF-8 encoded XML\n  XML_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + XML_CONTENT_TYPE;\n\n  /// MIME content type used for raw binary data\n  BINARY_CONTENT_TYPE = 'application/octet-stream';\n\n  /// MIME content type used for raw binary data, in upper case\n  BINARY_CONTENT_TYPE_UPPER = 'APPLICATION/OCTET-STREAM';\n\n  /// HTTP header for MIME content type used for raw binary data\n  BINARY_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE + BINARY_CONTENT_TYPE;\n\n  /// MIME content type used for a JPEG picture\n  JPEG_CONTENT_TYPE = 'image/jpeg';\n\n  /// a IdemPPChar() compatible array of textual MIME content types\n  // - as used e.g. by IsHtmlContentTypeTextual()\n  CONTENT_TYPE_TEXTUAL: array[0..7] of PAnsiChar = (\n    JSON_CONTENT_TYPE_UPPER,\n    'TEXT/',\n    'APPLICATION/XML',\n    'APPLICATION/JSON',\n    'APPLICATION/JAVASCRIPT',\n    'APPLICATION/X-JAVASCRIPT',\n    'IMAGE/SVG+XML',\n    nil);\n\n  /// internal HTTP content-type for efficient static file sending\n  // - detected e.g. by http.sys' THttpApiServer.Request or via the NGINX\n  // X-Accel-Redirect header's THttpServer.Process (see\n  // THttpServer.NginxSendFileFrom) for direct sending with no local bufferring\n  // - the OutCustomHeader should contain the proper 'Content-type: ....'\n  // corresponding to the file (e.g. by calling GetMimeContentType() function)\n  STATICFILE_CONTENT_TYPE = '!STATICFILE';\n\n  /// internal HTTP content-type Header for efficient static file sending\n  STATICFILE_CONTENT_TYPE_HEADER =\n    HEADER_CONTENT_TYPE + STATICFILE_CONTENT_TYPE;\n\n  /// uppercase version of HTTP header for static file content serving\n  STATICFILE_CONTENT_TYPE_HEADER_UPPPER =\n    HEADER_CONTENT_TYPE_UPPER + STATICFILE_CONTENT_TYPE;\n\n  /// used to notify e.g. the THttpServerRequest not to wait for any response\n  // from the client\n  // - is not to be used in normal HTTP process, but may be used e.g. by\n  // TWebSocketProtocolRest.ProcessFrame() to avoid to wait for an incoming\n  // response from the other endpoint\n  NORESPONSE_CONTENT_TYPE = '!NORESPONSE';\n\n  /// HTTP body following RFC 2324 standard e.g. for banned IP\n  HTTP_BANIP_RESPONSE: string[201] =\n    'HTTP/1.0 418 I''m a teapot'#13#10 +\n    'Content-Length: 125'#13#10 +\n    'Content-Type: text/plain'#13#10#13#10 +\n    'Server refuses to brew coffee because it is currently a teapot.'#13#10 +\n    'Do not mess with it and retry from this IP in a few seconds.';\n\n  /// JSON compatible representation of a boolean value, i.e. 'false' and 'true'\n  // - can be used e.g. in logs, or anything accepting a ShortString\n  BOOL_STR: array[boolean] of string[7] = (\n    'false', 'true');\n\n  /// the JavaScript-like values of non-number IEEE constants\n  // - as recognized by FloatToShortNan, and used by TTextWriter.Add()\n  // when serializing such single/double/extended floating-point values\n  JSON_NAN: array[TFloatNan] of string[11] = (\n    '0', '\"NaN\"', '\"Infinity\"', '\"-Infinity\"');\n\nvar\n  /// MIME content type used for JSON communication\n  // - i.e. 'application/json' as stated by datatracker.ietf.org/doc/html/rfc7159\n  // - this global will be initialized with JSON_CONTENT_TYPE constant, to\n  // avoid a memory allocation each time it is assigned to a variable\n  JSON_CONTENT_TYPE_VAR: RawUtf8;\n\n  /// HTTP header for MIME content type used for plain JSON\n  // - this global will be initialized with JSON_CONTENT_TYPE_HEADER constant,\n  // to avoid a memory allocation each time it is assigned to a variable\n  JSON_CONTENT_TYPE_HEADER_VAR: RawUtf8;\n\n  /// can be used to avoid a memory allocation for res := 'null'\n  // - this global will be initialized with 'null' constant, to\n  // avoid a memory allocation each time it is assigned to a variable\n  NULL_STR_VAR: RawUtf8;\n\n  /// JSON compatible representation of a boolean value, i.e. 'false' and 'true'\n  // - can be used when a RawUtf8 string is expected\n  // - this global will be initialized with 'false' and 'true' constants, to\n  // avoid a memory allocation each time it is assigned to a variable\n  BOOL_UTF8: array[boolean] of RawUtf8;\n\n\ntype\n  /// Security IDentifier (SID) Authority, encoded as 48-bit binary\n  TSidAuth = array[0..5] of byte;\n  PSidAuth = ^TSidAuth;\n\n  /// Security IDentifier (SID) binary format, as retrieved e.g. by Windows API\n  // - this definition is not detailed on oldest Delphi, and not available on\n  // POSIX, whereas it makes sense to also have it, e.g. for server process\n  TSid = packed record\n     Revision: byte;\n     SubAuthorityCount: byte;\n     IdentifierAuthority: TSidAuth;\n     SubAuthority: array[byte] of cardinal;\n  end;\n  PSid = ^TSid;\n  PSids = array of PSid;\n\n  /// define a list of well-known Security IDentifier (SID) groups\n  // - for instance, wksBuiltinAdministrators is set for local administrators\n  // - warning: does not exactly match winnt.h WELL_KNOWN_SID_TYPE enumeration\n  TWellKnownSid = (\n    wksNull,\n    wksWorld,\n    wksLocal,\n    wksConsoleLogon,\n    wksCreatorOwner,\n    wksCreatorGroup,\n    wksCreatorOwnerServer,\n    wksCreatorGroupServer,\n    wksIntegrityUntrusted,\n    wksIntegrityLow,\n    wksIntegrityMedium,\n    wksIntegrityMediumPlus,\n    wksIntegrityHigh,\n    wksIntegritySystem,\n    wksIntegrityProtectedProcess,\n    wksIntegritySecureProcess,\n    wksAuthenticationAuthorityAsserted,\n    wksAuthenticationServiceAsserted,\n    wksAuthenticationFreshKeyAuth,\n    wksAuthenticationKeyTrust,\n    wksAuthenticationKeyPropertyMfa,\n    wksAuthenticationKeyPropertyAttestation,\n    wksNtAuthority,\n    wksDialup,\n    wksNetwork,\n    wksBatch,\n    wksInteractive,\n    wksService,\n    wksAnonymous,\n    wksProxy,\n    wksEnterpriseControllers,\n    wksSelf,\n    wksAuthenticatedUser,\n    wksRestrictedCode,\n    wksTerminalServer,\n    wksRemoteLogonId,\n    wksThisOrganisation,\n    wksIisUser,\n    wksLocalSystem,\n    wksLocalService,\n    wksNetworkService,\n    wksLocalAccount,\n    wksLocalAccountAndAdministrator,\n    wksBuiltinDomain,\n    wksBuiltinAdministrators,\n    wksBuiltinUsers,\n    wksBuiltinGuests,\n    wksBuiltinPowerUsers,\n    wksBuiltinAccountOperators,\n    wksBuiltinSystemOperators,\n    wksBuiltinPrintOperators,\n    wksBuiltinBackupOperators,\n    wksBuiltinReplicator,\n    wksBuiltinRasServers,\n    wksBuiltinPreWindows2000CompatibleAccess,\n    wksBuiltinRemoteDesktopUsers,\n    wksBuiltinNetworkConfigurationOperators,\n    wksBuiltinIncomingForestTrustBuilders,\n    wksBuiltinPerfMonitoringUsers,\n    wksBuiltinPerfLoggingUsers,\n    wksBuiltinAuthorizationAccess,\n    wksBuiltinTerminalServerLicenseServers,\n    wksBuiltinDcomUsers,\n    wksBuiltinIUsers,\n    wksBuiltinCryptoOperators,\n    wksBuiltinUnknown,\n    wksBuiltinCacheablePrincipalsGroups,\n    wksBuiltinNonCacheablePrincipalsGroups,\n    wksBuiltinEventLogReadersGroup,\n    wksBuiltinCertSvcDComAccessGroup,\n    wksBuiltinRdsRemoteAccessServers,\n    wksBuiltinRdsEndpointServers,\n    wksBuiltinRdsManagementServers,\n    wksBuiltinHyperVAdmins,\n    wksBuiltinAccessControlAssistanceOperators,\n    wksBuiltinRemoteManagementUsers,\n    wksBuiltinDefaultSystemManagedGroup,\n    wksBuiltinStorageReplicaAdmins,\n    wksBuiltinDeviceOwners,\n    wksCapabilityInternetClient,\n    wksCapabilityInternetClientServer,\n    wksCapabilityPrivateNetworkClientServer,\n    wksCapabilityPicturesLibrary,\n    wksCapabilityVideosLibrary,\n    wksCapabilityMusicLibrary,\n    wksCapabilityDocumentsLibrary,\n    wksCapabilityEnterpriseAuthentication,\n    wksCapabilitySharedUserCertificates,\n    wksCapabilityRemovableStorage,\n    wksCapabilityAppointments,\n    wksCapabilityContacts,\n    wksBuiltinAnyPackage,\n    wksBuiltinAnyRestrictedPackage,\n    wksNtlmAuthentication,\n    wksSChannelAuthentication,\n    wksDigestAuthentication);\n\n  /// define a set of well-known SID\n  TWellKnownSids = set of TWellKnownSid;\n\n  /// custom binary buffer type used as convenient Windows SID storage\n  RawSid = type RawByteString;\n\n  /// a dynamic array of binary SID storage buffers\n  RawSidDynArray = array of RawSid;\n\n\n/// a wrapper around MemCmp() on two Security IDentifier binary buffers\n// - will first compare by length, then by content\nfunction SidCompare(a, b: PSid): integer;\n\n/// compute the actual binary length of a Security IDentifier buffer, in bytes\nfunction SidLength(sid: PSid): PtrInt;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// allocate a RawSid instance from a PSid raw handler\nprocedure ToRawSid(sid: PSid; out result: RawSid);\n\n/// check if a RawSid binary buffer has the expected length of a valid SID\nfunction IsValidRawSid(const sid: RawSid): boolean;\n\n/// search within SID dynamic array for a given SID\nfunction HasSid(const sids: PSids; sid: PSid): boolean;\n\n/// search within SID dynamic array for a given dynamic array of SID buffers\nfunction HasAnySid(const sids: PSids; const sid: RawSidDynArray): boolean;\n\n/// append a SID buffer pointer to a dynamic array of SID buffers\nprocedure AddRawSid(var sids: RawSidDynArray; sid: PSid);\n\n/// convert a Security IDentifier as text, following the standard representation\nprocedure SidToTextShort(sid: PSid; var result: shortstring);\n\n/// convert a Security IDentifier as text, following the standard representation\nfunction SidToText(sid: PSid): RawUtf8;\n\n/// convert several Security IDentifier as text dynamic array\nfunction SidsToText(sids: PSids): TRawUtf8DynArray;\n\n/// convert a Security IDentifier as text, following the standard representation\nfunction RawSidToText(const sid: RawSid): RawUtf8;\n\n/// parse a Security IDentifier text, following the standard representation\n// - won't support hexadecimal IdentifierAuthority, i.e. S-1-0x######-....\nfunction TextToSid(P: PUtf8Char; out sid: TSid): boolean;\n\n/// parse a Security IDentifier text, following the standard representation\nfunction TextToRawSid(const text: RawUtf8): RawSid; overload;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// parse a Security IDentifier text, following the standard representation\nfunction TextToRawSid(const text: RawUtf8; out sid: RawSid): boolean; overload;\n\n/// returns a Security IDentifier of a well-known SID as binary\n// - is using an internal cache for the returned RawSid instances\nfunction KnownRawSid(wks: TWellKnownSid): RawSid;\n\n/// returns a Security IDentifier of a well-known SID as standard text\n// - e.g. wksBuiltinAdministrators as 'S-1-5-32-544'\nfunction KnownSidToText(wks: TWellKnownSid): PShortString;\n\n/// recognize most well-known SID from a Security IDentifier binary buffer\n// - returns wksNull if the supplied buffer was not recognized\nfunction SidToKnown(sid: PSid): TWellKnownSid; overload;\n\n/// recognize most well-known SID from a Security IDentifier standard text\n// - returns wksNull if the supplied text was not recognized\nfunction SidToKnown(const text: RawUtf8): TWellKnownSid; overload;\n\n/// recognize some well-known SIDs from the supplied SID dynamic array\nfunction SidToKnownGroups(const sids: PSids): TWellKnownSids;\n\n\n{ ****************** Gather Operating System Information }\n\ntype\n  /// Exception types raised by this mormot.core.os unit\n  EOSException = class(ExceptionWithProps);\n\n  /// the known operating systems\n  // - it will also recognize most Linux distributions\n  TOperatingSystem = (\n    osUnknown,\n    osWindows,\n    osLinux,\n    osOSX,\n    osBSD,\n    osPOSIX,\n    osArch,\n    osAurox,\n    osDebian,\n    osFedora,\n    osGentoo,\n    osKnoppix,\n    osMint,\n    osMandrake,\n    osMandriva,\n    osNovell,\n    osUbuntu,\n    osSlackware,\n    osSolaris,\n    osSuse,\n    osSynology,\n    osTrustix,\n    osClear,\n    osUnited,\n    osRedHat,\n    osLFS,\n    osOracle,\n    osMageia,\n    osCentOS,\n    osCloud,\n    osXen,\n    osAmazon,\n    osCoreOS,\n    osAlpine,\n    osAndroid);\n\n  /// the recognized Windows versions\n  // - defined even outside OSWINDOWS to access e.g. from monitoring tools\n  TWindowsVersion = (\n    wUnknown,\n    w2000,\n    wXP,\n    wXP_64,\n    wServer2003,\n    wServer2003_R2,\n    wVista,\n    wVista_64,\n    wServer2008,\n    wServer2008_64,\n    wSeven,\n    wSeven_64,\n    wServer2008_R2,\n    wServer2008_R2_64,\n    wEight,\n    wEight_64,\n    wServer2012,\n    wServer2012_64,\n    wEightOne,\n    wEightOne_64,\n    wServer2012R2,\n    wServer2012R2_64,\n    wTen,\n    wTen_64,\n    wServer2016,\n    wServer2016_64,\n    wEleven,\n    wEleven_64,\n    wServer2019_64,\n    wServer2022_64);\n\n  /// the running Operating System, encoded as a 32-bit integer\n  TOperatingSystemVersion = packed record\n    case os: TOperatingSystem of\n    osUnknown: (\n      b: array[0..2] of byte);\n    osWindows: (\n      win: TWindowsVersion;\n      winbuild: word);\n    osLinux: (\n      utsrelease: array[0..2] of byte);\n  end;\n\nconst\n  /// the recognized MacOS versions, as plain text\n  // - indexed from OSVersion32.utsrelease[2] kernel revision\n  MACOS_NAME: array[8 .. 24] of RawUtf8 = (\n    '10.4 Tiger',\n    '10.5 Leopard',\n    '10.6 Snow Leopard',\n    '10.7 Lion',\n    '10.8 Mountain Lion',\n    '10.9 Mavericks',\n    '10.10 Yosemite',\n    '10.11 El Capitan',\n    '10.12 Sierra',\n    '10.13 High Sierra',\n    '10.14 Mojave',\n    '10.15 Catalina',\n    '11 Big Sur',\n    '12 Monterey',\n    '13 Ventura',\n    '14 Sonoma',\n    '15 Glow'); // use known internal codename for upcoming version\n\n  /// the recognized Windows versions, as plain text\n  // - defined even outside OSWINDOWS to allow process e.g. from monitoring tools\n  WINDOWS_NAME: array[TWindowsVersion] of RawUtf8 = (\n    '',\n    '2000',\n    'XP',\n    'XP 64bit',\n    'Server 2003',\n    'Server 2003 R2',\n    'Vista',\n    'Vista 64bit',\n    'Server 2008',\n    'Server 2008 64bit',\n    '7',\n    '7 64bit',\n    'Server 2008 R2',\n    'Server 2008 R2 64bit',\n    '8',\n    '8 64bit',\n    'Server 2012',\n    'Server 2012 64bit',\n    '8.1',\n    '8.1 64bit',\n    'Server 2012 R2',\n    'Server 2012 R2 64bit',\n    '10',\n    '10 64bit',\n    'Server 2016',\n    'Server 2016 64bit',\n    '11',\n    '11 64bit',\n    'Server 2019 64bit',\n    'Server 2022 64bit');\n\n  /// the recognized Windows versions which are 32-bit\n  WINDOWS_32 = [\n     w2000,\n     wXP,\n     wServer2003,\n     wServer2003_R2,\n     wVista,\n     wServer2008,\n     wSeven,\n     wServer2008_R2,\n     wEight,\n     wServer2012,\n     wEightOne,\n     wServer2012R2,\n     wTen,\n     wServer2016,\n     wEleven];\n\n  /// translate one operating system (and distribution) into a its common name\n  OS_NAME: array[TOperatingSystem] of RawUtf8 = (\n    'Unknown',\n    'Windows',\n    'Linux',\n    'OSX',\n    'BSD',\n    'POSIX',\n    'Arch',\n    'Aurox',\n    'Debian',\n    'Fedora',\n    'Gentoo',\n    'Knoppix',\n    'Mint',\n    'Mandrake',\n    'Mandriva',\n    'Novell',\n    'Ubuntu',\n    'Slackware',\n    'Solaris',\n    'Suse',\n    'Synology',\n    'Trustix',\n    'Clear',\n    'United',\n    'RedHat',\n    'LFS',\n    'Oracle',\n    'Mageia',\n    'CentOS',\n    'Cloud',\n    'Xen',\n    'Amazon',\n    'CoreOS',\n    'Alpine',\n    'Android');\n\n  /// translate one operating system (and distribution) into a single character\n  // - may be used internally e.g. for a HTTP User-Agent header, as with\n  // TFileVersion.UserAgent and UserAgentParse()\n  OS_INITIAL: array[TOperatingSystem] of AnsiChar = (\n    '?', // Unknown\n    'W', // Windows\n    'L', // Linux\n    'X', // OSX\n    'B', // BSD\n    'P', // POSIX\n    'A', // Arch\n    'a', // Aurox\n    'D', // Debian\n    'F', // Fedora\n    'G', // Gentoo\n    'K', // Knoppix\n    'M', // Mint\n    'm', // Mandrake\n    'n', // Mandriva\n    'N', // Novell\n    'U', // Ubuntu\n    'S', // Slackware\n    's', // Solaris\n    'u', // Suse\n    'Y', // Synology\n    'T', // Trustix\n    'C', // Clear\n    't', // United\n    'R', // RedHat\n    'l', // LFS\n    'O', // Oracle\n    'G', // Mageia\n    'c', // CentOS\n    'd', // Cloud\n    'x', // Xen\n    'Z', // Amazon\n    'r', // CoreOS\n    'p', // Alpine\n    'J'  // Android (J=JVM)\n    );\n\n  /// the operating systems items which actually have a Linux kernel\n  OS_LINUX = [\n    osLinux,\n    osArch .. osAndroid];\n\n  /// the compiler family used\n  COMP_TEXT = {$ifdef FPC}'Fpc'{$else}'Delphi'{$endif};\n\n  /// the target Operating System used for compilation, as short text\n  OS_TEXT =\n    {$ifdef OSWINDOWS}\n      'Win';\n    {$else} {$ifdef OSDARWIN}\n      'OSX';\n    {$else}{$ifdef OSBSD}\n      'BSD';\n    {$else} {$ifdef OSANDROID}\n      'Android';\n    {$else} {$ifdef OSLINUX}\n      'Linux';\n    {$else}\n      'Posix';\n    {$endif OSLINUX}\n    {$endif OSANDROID}\n    {$endif OSBSD}\n    {$endif OSDARWIN}\n    {$endif OSWINDOWS}\n\n  /// the CPU architecture used for compilation\n  CPU_ARCH_TEXT =\n    {$ifdef CPUX86}\n      'x86'\n    {$else} {$ifdef CPUX64}\n      'x64'\n    {$else} {$ifdef CPUARM}\n      'arm' +\n    {$else} {$ifdef CPUAARCH64}\n      'aarch' +\n    {$ifdef CPUPOWERPC}\n      'ppc' +\n    {$else} {$ifdef CPUSPARC}\n      'sparc' +\n    {$endif CPUSPARC}\n    {$endif CPUPOWERPC}\n    {$endif CPUARM}\n    {$endif CPUAARCH64}\n    {$ifdef CPU32}\n      '32'\n    {$else}\n      '64'\n    {$endif CPU32}\n    {$endif CPUX64}\n    {$endif CPUX86};\n\nvar\n  /// the target Operating System used for compilation, as TOperatingSystem\n  // - a specific Linux distribution may be detected instead of plain osLinux\n  OS_KIND: TOperatingSystem =\n    {$ifdef OSWINDOWS}\n      osWindows\n    {$else} {$ifdef OSDARWIN}\n      osOSX\n    {$else} {$ifdef OSBSD}\n      osBSD\n    {$else} {$ifdef OSANDROID}\n      osAndroid\n    {$else} {$ifdef OSLINUX}\n      osLinux\n    {$else}\n      osPOSIX\n    {$endif OSLINUX}\n    {$endif OSANDROID}\n    {$endif OSBSD}\n    {$endif OSDARWIN}\n    {$endif OSWINDOWS};\n\n  /// the current Operating System version, as retrieved for the current process\n  // - contains e.g. 'Windows Seven 64 SP1 (6.1.7601)' or 'Windows XP SP3 (5.1.2600)' or\n  // 'Windows 10 64bit 22H2 (10.0.19045.4046)' or 'macOS 13 Ventura (Darwin 22.3.0)' or\n  // 'Ubuntu 16.04.5 LTS - Linux 3.13.0 110 generic#157 Ubuntu SMP Mon Feb 20 11:55:25 UTC 2017'\n  OSVersionText: RawUtf8;\n  /// some addition system information as text, e.g. 'Wine 1.1.5'\n  // - also always appended to OSVersionText high-level description\n  // - use if PosEx('Wine', OSVersionInfoEx) > 0 then to check for Wine presence\n  OSVersionInfoEx: RawUtf8;\n  /// the current Operating System version, as retrieved for the current process\n  // and computed by ToTextOS(OSVersionInt32)\n  // - contains e.g. 'Windows Vista' or 'Ubuntu Linux 5.4.0' or\n  // 'macOS 13 Ventura 22.3.0'\n  OSVersionShort: RawUtf8;\n\n  {$ifdef OSWINDOWS}\n  /// on Windows, the Update Build Revision as shown with the \"ver/winver\" command\n  // - to track the current update state of the system\n  WindowsUbr: integer;\n  /// on Windows, the ready-to-be-displayed text version of the system\n  // - e.g. 'Windows 10 Entreprise N'\n  WindowsProductName: RawUtf8;\n  /// on Windows, the ready-to-be-displayed text version of the system\n  // - e.g. '22H2'\n  WindowsDisplayVersion: RawUtf8;\n  {$endif OSWINDOWS}\n\n  /// some textual information about the current CPU and its known cache\n  // - contains e.g. '4 x Intel(R) Core(TM) i5-7300U CPU @ 2.60GHz [3MB]'\n  CpuInfoText: RawUtf8;\n  /// the on-chip cache size, in bytes, as returned by the OS\n  // - retrieved from /proc/cpuinfo \"cache size\" entry (L3 cache) on Linux or\n  // CpuCache[3/4].Size (from GetLogicalProcessorInformation) on Windows\n  CpuCacheSize: cardinal;\n  /// the available cache information as returned by the OS\n  // - e.g. 'L1=2*32KB  L2=256KB  L3=3MB' on Windows or '3072 KB' on Linux\n  CpuCacheText: RawUtf8;\n  /// some textual information about the current computer hardware, from BIOS\n  // - contains e.g. 'LENOVO 20HES23B0U ThinkPad T470'\n  BiosInfoText: RawUtf8;\n\n  /// how many hardware CPU sockets are defined on this system\n  // - i.e. the number of physical CPU slots, not the number of logical CPU\n  // cores as returned by SystemInfo.dwNumberOfProcessors\n  // - as used e.g. by SetThreadAffinity()\n  CpuSockets: integer;\n\n  /// Level 1 to 4 CPU caches as returned by GetLogicalProcessorInformation\n  // - yes, Intel introduced a Level 4 cache (eDRAM) with some Haswell/Iris CPUs\n  // - this information is not retrieved on all Linux / POSIX systems yet\n  // - only Unified or Data caches are include (not Instruction or Trace)\n  // - note: some CPU - like the Apple M1 - have 128 bytes of LineSize\n  CpuCache: array[1..4] of record\n    Count, Size, LineSize: cardinal;\n  end;\n\n  {$ifdef OSLINUXANDROID}\n  /// contains the Flags: or Features: value of Linux /proc/cpuinfo\n  CpuInfoFeatures: RawUtf8;\n  {$endif OSLINUXANDROID}\n\n  /// the running Operating System\n  OSVersion32: TOperatingSystemVersion;\n  /// the running Operating System, encoded as a 32-bit integer\n  OSVersionInt32: integer absolute OSVersion32;\n\n/// convert an Operating System type into its text representation\n// - returns e.g. 'Windows Vista' or 'Ubuntu' or 'macOS 13 Ventura'\nfunction ToText(const osv: TOperatingSystemVersion): RawUtf8; overload;\n\n/// convert an Operating System type into its one-word text representation\n// - returns e.g. 'Vista' or 'Ubuntu' or 'OSX'\nfunction ToTextShort(const osv: TOperatingSystemVersion): RawUtf8;\n\n/// convert a 32-bit Operating System type into its full text representation\n// - including the kernel revision (not the distribution version) on POSIX systems\n// - returns e.g. 'Windows Vista', 'Windows 11 64-bit 22000' or 'Ubuntu Linux 5.4.0'\nfunction ToTextOS(osint32: integer): RawUtf8;\n\n/// check if the current OS (i.e. OS_KIND value) match a description\n// - will handle osPosix and osLinux as generic detection of those systems\n// - osUnknown will always return true\nfunction MatchOS(os: TOperatingSystem): boolean;\n\ntype\n  /// the recognized ARM/AARCH64 CPU types\n  // - https://github.com/karelzak/util-linux/blob/master/sys-utils/lscpu-arm.c\n  // - is defined on all platforms for cross-system use\n  TArmCpuType = (\n    actUnknown,\n    actARM810,\n    actARM920,\n    actARM922,\n    actARM926,\n    actARM940,\n    actARM946,\n    actARM966,\n    actARM1020,\n    actARM1022,\n    actARM1026,\n    actARM11MPCore,\n    actARM1136,\n    actARM1156,\n    actARM1176,\n    actCortexA5,\n    actCortexA7,\n    actCortexA8,\n    actCortexA9,\n    actCortexA12,\n    actCortexA15,\n    actCortexA17,\n    actCortexR4,\n    actCortexR5,\n    actCortexR7,\n    actCortexR8,\n    actCortexM0,\n    actCortexM1,\n    actCortexM3,\n    actCortexM4,\n    actCortexM7,\n    actCortexM0P,\n    actCortexA32,\n    actCortexA53,\n    actCortexA35,\n    actCortexA55,\n    actCortexA65,\n    actCortexA57,\n    actCortexA72,\n    actCortexA73,\n    actCortexA75,\n    actCortexA76,\n    actNeoverseN1,\n    actCortexA77,\n    actCortexA76AE,\n    actCortexR52,\n    actCortexM23,\n    actCortexM33,\n    actNeoverseV1,\n    actCortexA78,\n    actCortexA78AE,\n    actCortexX1,\n    actCortex510,\n    actCortex710,\n    actCortexX2,\n    actNeoverseN2,\n    actNeoverseE1,\n    actCortexA78C,\n    actCortexX1C,\n    actCortexA715,\n    actCortexX3,\n    actNeoverseV2,\n    actCortexA520,\n    actCortexA720,\n    actCortexX4,\n    actNeoverseV3,\n    actNeoverseN3);\n  /// a set of recognized ARM/AARCH64 CPU types\n  TArmCpuTypes = set of TArmCpuType;\n\n  /// the recognized ARM/AARCH64 CPU hardware implementers\n  // - https://github.com/karelzak/util-linux/blob/master/sys-utils/lscpu-arm.c\n  TArmCpuImplementer = (\n    aciUnknown,\n    aciARM,\n    aciBroadcom,\n    aciCavium,\n    aciDEC,\n    aciFUJITSU,\n    aciHiSilicon,\n    aciInfineon,\n    aciMotorola,\n    aciNVIDIA,\n    aciAPM,\n    aciQualcomm,\n    aciSamsung,\n    aciMarvell,\n    aciApple,\n    aciFaraday,\n    aciIntel,\n    aciMicrosoft,\n    aciPhytium,\n    aciAmpere);\n  /// a set of recognized ARM/AARCH64 CPU hardware implementers\n  TArmCpuImplementers = set of TArmCpuImplementer;\n\n/// recognize a given ARM/AARCH64 CPU from its 12-bit hardware ID\nfunction ArmCpuType(id: word): TArmCpuType;\n\n/// recognize a given ARM/AARCH64 CPU type name from its 12-bit hardware ID\nfunction ArmCpuTypeName(act: TArmCpuType; id: word): RawUtf8;\n\n/// recognize a given ARM/AARCH64 CPU implementer from its 8-bit hardware ID\nfunction ArmCpuImplementer(id: byte): TArmCpuImplementer;\n\n/// recognize a given ARM/AARCH64 CPU implementer name from its 8-bit hardware ID\nfunction ArmCpuImplementerName(aci: TArmCpuImplementer; id: word): RawUtf8;\n\n\nconst\n  /// contains the Delphi/FPC Compiler Version as text\n  // - e.g. 'Delphi 10.3 Rio', 'Delphi 2010' or 'Free Pascal 3.3.1'\n  COMPILER_VERSION: RawUtf8 =\n  {$ifdef FPC}\n    'Free Pascal'\n    {$ifdef VER2_6_4} + ' 2.6.4'{$endif}\n    {$ifdef VER3_0}   + ' 3.0'\n      {$ifdef VER3_0_4}   + '.4' {$else}\n        {$ifdef VER3_0_2} + '.2' {$endif}\n      {$endif VER3_0_4}\n    {$endif VER3_0}\n    {$ifdef VER3_1}   + ' 3.1'\n       {$ifdef VER3_1_1} + '.1' {$endif}\n    {$endif VER3_1}\n    {$ifdef VER3_2}   + ' 3.2'\n      {$ifdef VER3_2_4}     + '.4' {$else}\n        {$ifdef VER3_2_3}   + '.3' {$else}\n          {$ifdef VER3_2_2} + '.2' {$endif}\n        {$endif VER3_2_3}\n      {$endif VER3_2_4}\n    {$endif VER3_2}\n    {$ifdef VER3_3}   + ' 3.3'\n       {$ifdef VER3_3_1} + '.1' {$endif}\n    {$endif VER3_3}\n    {$ifdef VER3_4}   + ' 3.4'  {$endif}\n  {$else}\n    'Delphi'\n    {$if     defined(VER140)} + ' 6'\n    {$elseif defined(VER150)} + ' 7'\n    {$elseif defined(VER160)} + ' 8'\n    {$elseif defined(VER170)} + ' 2005'\n    {$elseif defined(VER185)} + ' 2007'\n    {$elseif defined(VER180)} + ' 2006'\n    {$elseif defined(VER200)} + ' 2009'\n    {$elseif defined(VER210)} + ' 2010'\n    {$elseif defined(VER220)} + ' XE'\n    {$elseif defined(VER230)} + ' XE2'\n    {$elseif defined(VER240)} + ' XE3'\n    {$elseif defined(VER250)} + ' XE4'\n    {$elseif defined(VER260)} + ' XE5'\n    {$elseif defined(VER265)} + ' AppMethod 1'\n    {$elseif defined(VER270)} + ' XE6'\n    {$elseif defined(VER280)} + ' XE7'\n    {$elseif defined(VER290)} + ' XE8'\n    {$elseif defined(VER300)} + ' 10 Seattle'\n    {$elseif defined(VER310)} + ' 10.1 Berlin'\n    {$elseif defined(VER320)} + ' 10.2 Tokyo'\n    {$elseif defined(VER330)} + ' 10.3 Rio'\n    {$elseif defined(VER340)} + ' 10.4 Sydney'\n    {$elseif defined(VER350)} + ' 11'\n      {$if declared(RTLVersion113)} + '.3' {$else}\n      {$if declared(RTLVersion112)} + '.2' {$else}\n      {$if declared(RTLVersion111)} + '.1' {$ifend} {$ifend} {$ifend}\n                              + ' Alexandria'\n    {$elseif defined(VER360)} + ' 12'\n      {$if declared(RTLVersion122)} + '.2' {$else}\n      {$if declared(RTLVersion121)} + '.1' {$ifend} {$ifend}\n                              + ' Athens'\n    {$elseif defined(VER370)} + ' 13 Next'\n    {$ifend}\n  {$endif FPC}\n  {$ifdef CPU64} + ' 64 bit' {$else} + ' 32 bit' {$endif};\n\n{$ifndef PUREMORMOT2}\nconst\n  HTTP_RESP_STATICFILE = STATICFILE_CONTENT_TYPE;\n\n/// deprecated function: use COMPILER_VERSION constant instead\nfunction GetDelphiCompilerVersion: RawUtf8; deprecated;\n{$endif PUREMORMOT2}\n\n{$ifdef OSWINDOWS}\n\n{$ifdef UNICODE}\n\nconst\n  /// a global constant to be appended for Windows Ansi or Wide API names\n  // - match the Wide API on Delphi, since String=UnicodeString\n  _AW = 'W';\n\n{$else}\n\nconst\n  /// a global constant to be appended for Windows Ansi or Wide API names\n  // - match the Ansi API on FPC or oldest Delphi, where String=AnsiString\n  _AW = 'A';\n\ntype\n  /// low-level API structure, not defined in old Delphi versions\n  TOSVersionInfoEx = record\n    dwOSVersionInfoSize: DWORD;\n    dwMajorVersion: DWORD;\n    dwMinorVersion: DWORD;\n    dwBuildNumber: DWORD;\n    dwPlatformId: DWORD;\n    szCSDVersion: array[0..127] of char;\n    wServicePackMajor: WORD;\n    wServicePackMinor: WORD;\n    wSuiteMask: WORD;\n    wProductType: BYTE;\n    wReserved: BYTE;\n  end;\n\n{$endif UNICODE}\n\nvar\n  /// is set to TRUE if the current process is a 32-bit image running under WOW64\n  // - WOW64 is the x86 emulator that allows 32-bit Windows-based applications\n  // to run seamlessly on 64-bit Windows\n  // - equals always FALSE if the current executable is a 64-bit image\n  IsWow64: boolean;\n  /// the current System information, as retrieved for the current process\n  // - under a WOW64 process, it will use the GetNativeSystemInfo() new API\n  // to retrieve the real top-most system information\n  // - note that the lpMinimumApplicationAddress field is replaced by a\n  // more optimistic/realistic value ($100000 instead of default $10000)\n  // - under BSD/Linux, only contain dwPageSize and dwNumberOfProcessors fields\n  SystemInfo: TSystemInfo;\n  /// low-level Operating System information, as retrieved for the current process\n  OSVersionInfo: TOSVersionInfoEx;\n  /// the current Windows edition, as retrieved for the current process\n  OSVersion: TWindowsVersion;\n\n{$else OSWINDOWS}\n\nvar\n  /// emulate only some used fields of Windows' TSystemInfo\n  SystemInfo: record\n    /// retrieved from libc's getpagesize() - is expected to not be 0\n    dwPageSize: cardinal;\n    /// the number of available logical CPUs\n    // - retrieved from HW_NCPU (BSD) or /proc/cpuinfo (Linux)\n    // - see CpuSockets for the number of physical CPU sockets\n    dwNumberOfProcessors: cardinal;\n    /// meaningful system information, as returned by fpuname()\n    uts: record\n      sysname, release, version: RawUtf8;\n    end;\n    /// Linux Distribution release name, retrieved from /etc/*-release\n    release: RawUtf8;\n  end;\n\n{$endif OSWINDOWS}\n\n  /// the number of physical memory bytes available to the process\n  // - equals TMemoryInfo.memtotal as retrieved from GetMemoryInfo() at startup\n  SystemMemorySize: PtrUInt;\n\n{$M+} // to have existing RTTI for published properties\n\ntype\n  /// used to retrieve version information from any EXE\n  // - under Linux, all version numbers are set to 0 by default, unless\n  // you define the FPCUSEVERSIONINFO conditional and information is\n  // extracted from executable resources\n  // - for the main executable, do not create once instance of this class, but\n  // call GetExecutableVersion / SetExecutableVersion and access the Executable\n  // global variable\n  TFileVersion = class\n  protected\n    fDetailed: string;\n    fFileName: TFileName;\n    fBuildDateTime: TDateTime;\n    fVersionInfo, fUserAgent: RawUtf8;\n    // change the version - returns true if supplied values are actually new\n    function SetVersion(aMajor, aMinor, aRelease, aBuild: integer): boolean;\n  public\n    /// executable major version number\n    Major: integer;\n    /// executable minor version number\n    Minor: integer;\n    /// executable release version number\n    Release: integer;\n    /// executable release build number\n    Build: integer;\n    /// build year of this exe file\n    BuildYear: word;\n    /// version info of the exe file as '3.1'\n    // - return \"string\" type, i.e. UnicodeString for Delphi 2009+\n    Main: string;\n    /// associated CompanyName string version resource\n    CompanyName: RawUtf8;\n    /// associated FileDescription string version resource\n    FileDescription: RawUtf8;\n    /// associated FileVersion string version resource\n    FileVersion: RawUtf8;\n    /// associated InternalName string version resource\n    InternalName: RawUtf8;\n    /// associated LegalCopyright string version resource\n    LegalCopyright: RawUtf8;\n    /// associated OriginalFileName string version resource\n    OriginalFilename: RawUtf8;\n    /// associated ProductName string version resource\n    ProductName: RawUtf8;\n    /// associated ProductVersion string version resource\n    ProductVersion: RawUtf8;\n    /// associated Comments string version resource\n    Comments: RawUtf8;\n    /// associated Language Translation string version resource\n    LanguageInfo: RawUtf8;\n    /// initialize the version information, with optional custom values\n    // - will set the version numbers, and get BuildDateTime/BuildYear\n    // - call RetrieveInformationFromFileName to parse its internal resources\n    // - for the main executable, do not use this constructor, but call\n    // GetExecutableVersion / SetExecutableVersion and access the Executable\n    // global variable\n    constructor Create(const aFileName: TFileName; aMajor: integer = 0;\n      aMinor: integer = 0; aRelease: integer = 0; aBuild: integer = 0);\n    /// open and extract file information from the executable FileName\n    // - note that resource extraction is not available on POSIX, unless the\n    // FPCUSEVERSIONINFO conditional has been specified in the project options\n    function RetrieveInformationFromFileName: boolean;\n    /// retrieve the version as a 32-bit integer with Major.Minor.Release\n    // - following Major shl 16+Minor shl 8+Release bit pattern\n    function Version32: integer;\n    /// build date and time of this exe file, as plain text\n    function BuildDateTimeString: string;\n    /// version info of the exe file as '3.1.0.123' or ''\n    // - this method returns '' if Detailed is '0.0.0.0'\n    function DetailedOrVoid: string;\n    /// returns the version information of this exe file as text\n    // - includes FileName (without path), Detailed and BuildDateTime properties\n    // - e.g. 'myprogram.exe 3.1.0.123 (2016-06-14 19:07:55)'\n    function VersionInfo: RawUtf8;\n    /// returns a ready-to-use User-Agent header with exe name, version and OS\n    // - e.g. 'myprogram/3.1.0.123W32' for myprogram running on Win32\n    // - here OS_INITIAL[] character is used to identify the OS, with '32'\n    // appended on Win32 only (e.g. 'myprogram/3.1.0.2W', is for Win64)\n    // - use UserAgentParse() to decode this text into meaningful information\n    function UserAgent: RawUtf8;\n    /// returns the version information of a specified exe file as text\n    // - includes FileName (without path), Detailed and BuildDateTime properties\n    // - e.g. 'myprogram.exe 3.1.0.123 2016-06-14 19:07:55'\n    class function GetVersionInfo(const aFileName: TFileName): RawUtf8;\n  published\n    /// version info of the exe file as '3.1.0.123'\n    // - return \"string\" type, i.e. UnicodeString for Delphi 2009+\n    // - under Linux, always return '0.0.0.0' if no custom version number\n    // has been defined\n    // - consider using DetailedOrVoid method if '0.0.0.0' is not expected\n    property Detailed: string\n      read fDetailed write fDetailed;\n    /// build date and time of this exe file\n    property BuildDateTime: TDateTime\n      read fBuildDateTime write fBuildDateTime;\n  end;\n\n{$M-}\n\n/// quickly parse the TFileVersion.UserAgent content\n// - identify e.g. 'myprogram/3.1.0.2W' or 'myprogram/3.1.0.2W32' text\nfunction UserAgentParse(const UserAgent: RawUtf8;\n  out ProgramName, ProgramVersion: RawUtf8;\n  out OS: TOperatingSystem): boolean;\n\ntype\n  /// the command line switches supported by TExecutableCommandLine\n  // - clkArg is for \"exename arg1 arg2 arg3\" main indexed arguments\n  // - clkOption is for \"exename -o --opt1\" boolean flags\n  // - clkParam is for \"exename -n value --name value --name2=value2\" pairs\n  TExecutableCommandLineKind = (\n    clkUndefined,\n    clkArg,\n    clkOption,\n    clkParam);\n\n  /// implements command-line arguments parsing e.g. for TExecutable.Command\n  // - call Arg() Options() and Get/Param() to define and retrieve the flags\n  // from their names and supply some description text, then call\n  // DetectUnknown and/or FullDescription to interact with the user\n  // - by default, will use -/-- switches on POSIX, and / on Windows\n  TExecutableCommandLine = class\n  protected\n    fNames: array[clkArg .. clkParam] of TRawUtf8DynArray;\n    fRawParams, fValues: TRawUtf8DynArray; // for clkParam\n    fDesc, fDescDetail: array[clkArg .. clkParam] of RawUtf8;\n    fRetrieved: array[clkArg .. clkParam] of TBooleanDynArray;\n    fDescArg: TRawUtf8DynArray;\n    fCaseSensitiveNames: boolean;\n    fSwitch: array[{long=}boolean] of RawUtf8;\n    fLineFeed, fExeDescription: RawUtf8;\n    procedure Describe(const v: array of RawUtf8;\n      k: TExecutableCommandLineKind; d, def: RawUtf8; argindex: integer);\n    function Find(const v: array of RawUtf8;\n      k: TExecutableCommandLineKind = clkUndefined; const d: RawUtf8 = '';\n      const def: RawUtf8 = ''; f: PtrInt = 0): PtrInt;\n  public\n    /// mark and describe an \"arg\" value by 0-based index in Args[]\n    function Arg(index: integer; const description: RawUtf8 = '';\n      optional: boolean = true): boolean; overload;\n    /// mark and describe a string/TFileName \"arg\" value by 0-based index in Args[]\n    function ArgString(index: integer; const description: RawUtf8 = '';\n      optional: boolean = true): string;\n    /// mark and describe an \"arg\" value in Args[]\n    function Arg(const name: RawUtf8;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// mark and describe or or several \"arg\" value(s) in Args[]\n    function Arg(const name: array of RawUtf8;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-optionname\" switches in Options[]\n    function Option(const name: RawUtf8;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-optionname\" switches in Options[]\n    function Option(const name: array of RawUtf8;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return its RawUtf8 \"parametervalue\"\n    function Get(const name: RawUtf8; out value: RawUtf8;\n      const description: RawUtf8 = ''; const default: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return its RawUtf8 \"parametervalue\"\n    function Get(const name: array of RawUtf8; out value: RawUtf8;\n      const description: RawUtf8 = ''; const default: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return all RawUtf8 \"parametervalue\" occurrences\n    function Get(const name: array of RawUtf8; out value: TRawUtf8DynArray;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return its plain string \"parametervalue\"\n    function Get(const name: RawUtf8; out value: string;\n      const description: RawUtf8 = ''; const default: string = ''): boolean; overload;\n    /// search for \"-parametername\" and return all string \"parametervalue\" occurrences\n    function Get(const name: array of RawUtf8; out value: TStringDynArray;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return its plain string \"parametervalue\"\n    function Get(const name: array of RawUtf8; out value: string;\n      const description: RawUtf8 = ''; const default: string = ''): boolean; overload;\n    /// search for \"-parametername\" and return all string \"parametervalue\" occurrences\n    function Get(const name: RawUtf8; out value: TStringDynArray;\n      const description: RawUtf8 = ''): boolean; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\"\n    function Get(const name: RawUtf8; out value: integer;\n      const description: RawUtf8 = ''; default: integer = maxInt): boolean; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\"\n    function Get(const name: array of RawUtf8; out value: integer;\n      const description: RawUtf8 = ''; default: integer = maxInt): boolean; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\"\n    function Get(const name: RawUtf8; min, max: integer; out value: integer;\n      const description: RawUtf8 = ''; default: integer = maxInt): boolean; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\"\n    function Get(const name: array of RawUtf8; min, max: integer;\n      out value: integer; const description: RawUtf8 = '';\n      default: integer = -1): boolean; overload;\n    /// search for \"-parametername\" parameter in Names[]\n    function Has(const name: RawUtf8): boolean; overload;\n    /// search for \"-parametername\" parameter in Names[]\n    function Has(const name: array of RawUtf8): boolean; overload;\n    /// search for \"-parametername\" and return '' or its RawUtf8 \"parametervalue\"\n    function Param(const name: RawUtf8; const description: RawUtf8 = '';\n      const default: RawUtf8 = ''): RawUtf8; overload;\n    /// search for \"-parametername\" and return '' or its string \"parametervalue\"\n    function ParamS(const name: array of RawUtf8; const description: RawUtf8 = '';\n      const default: string = ''): string;\n    /// search for \"-parametername\" and return '' or its RawUtf8 \"parametervalue\"\n    function Param(const name: array of RawUtf8; const description: RawUtf8 = '';\n      const default: RawUtf8 = ''): RawUtf8; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\" or default\n    function Param(const name: RawUtf8; default: integer;\n      const description: RawUtf8 = ''): integer; overload;\n    /// search for \"-parametername\" and return its integer \"parametervalue\" or default\n    function Param(const name: array of RawUtf8; default: integer;\n      const description: RawUtf8 = ''): integer; overload;\n    /// generate the text from all Arg() Options() and Get/Param() descriptions\n    // and the supplied high-level description of the program\n    // - the parameter <name> would be extracted from any #word in the\n    // description text,\n    // - for instance:\n    // ! with Executable.Command do\n    // ! begin\n    // !   ExeDescription := 'An executable to test mORMot Execute.Command';\n    // !   verbose := Option(['v', 'verbose'], 'generate verbose output');\n    // !   Get(['t', 'threads'], threads, '#number of threads to run', 5);\n    // !   ConsoleWrite(FullDescription);\n    // ! end;\n    // will fill \"verbose\" and \"threads\" local variables, and output on Linux:\n    // $ An executable to test mORMot Execute.Command\n    // $\n    // $ Usage: mormot2tests [options] [params]\n    // $\n    // $ Options:\n    // $   -v, --verbose       generate verbose output\n    // $\n    // $ Params:\n    // $   -t, --threads <number> (default 5)\n    // $                       number of threads to run\n    function FullDescription(const customexedescription: RawUtf8 = '';\n      const exename: RawUtf8 = ''; const onlyusage: RawUtf8 = ''): RawUtf8;\n    /// check if the supplied parameters were all registered from previous\n    // Arg() Options() and Get/Param() calls\n    // - return '' if no unexpected flag has been supplied\n    // - return an error message like 'Unexpected --name option' otherwise\n    function DetectUnknown: RawUtf8;\n    /// call DetectUnknown and output any error message to the console\n    // - return false if the parameters are valid\n    // - otherwise, return true and caller should exit the process\n    function ConsoleWriteUnknown(const exedescription: RawUtf8 = ''): boolean;\n    /// define 'h help' and call ConsoleWriteUnknown()\n    // - caller should exit the process if this method returned true\n    function ConsoleHelpFailed(const exedescription: RawUtf8 = ''): boolean;\n    /// fill the stored arguments and options from executable parameters\n    // - called e.g. at unit inialization to set Executable.CommandLine variable\n    // - you can execute it again e.g. to customize the switches characters\n    function Parse(const DescriptionLineFeed: RawUtf8 = CRLF;\n      const ShortSwitch: RawUtf8 = {$ifdef OSWINDOWS} '/' {$else} '-' {$endif};\n      const LongSwitch: RawUtf8 = {$ifdef OSWINDOWS} '/' {$else} '--' {$endif}): boolean;\n    /// remove all recognized arguments and switches\n    procedure Clear;\n    /// internal method returning a switch text from its identifier\n    function SwitchAsText(const v: RawUtf8): RawUtf8;\n    /// the ParamStr(1..ParamCount) arguments as RawUtf8, excluding Options[]\n    // switches and Params[]/Values[] parameters\n    property Args: TRawUtf8DynArray\n      read fNames[clkArg];\n    /// the \"-optionname\" boolean switches as stored in ParamStr()\n    property Options: TRawUtf8DynArray\n      read fNames[clkOption];\n    /// the names of \"-parametername parametervalue\" as stored in ParamStr()\n    // - mapping the Values[] associated array\n    property Names: TRawUtf8DynArray\n      read fNames[clkParam];\n    /// the values of \"-parametername parametervalue\" as stored in ParamStr()\n    // - mapping the Names[] associated array\n    property Values: TRawUtf8DynArray\n      read fValues;\n    /// if search within Args[] Options[] or Names[] should be case-sensitive\n    property CaseSensitiveNames: boolean\n      read fCaseSensitiveNames write fCaseSensitiveNames;\n    /// set a text which describes the executable\n    // - as used by default by FullDescription() and ConsoleWriteUnknown()\n    property ExeDescription: RawUtf8\n      read fExeDescription write fExeDescription;\n    /// DescriptionLineFeed value from TExecutableCommandLine.Parse()\n    property LineFeed: RawUtf8\n      read fLineFeed write fLineFeed;\n    /// map ParamStr(1 .. ParamCount) values, encoded as RawUtf8\n    // - may be used e.g. for regression tests instead of ParamStr()\n    property RawParams: TRawUtf8DynArray\n      read fRawParams write fRawParams;\n  end;\n\n  /// stores some global information about the current executable and computer\n  // - as set at unit initialization into the Executable global variable\n  TExecutable = record\n    /// the main executable name, without any path nor extension\n    // - e.g. 'Test' for 'c:\\pathto\\Test.exe'\n    ProgramName: RawUtf8;\n    /// the main executable details, as used e.g. by TSynLog\n    // - e.g. 'C:\\Dev\\lib\\SQLite3\\exe\\TestSQL3.exe 1.2.3.123 (2011-03-29 11:09:06)'\n    // - you should have called GetExecutableVersion or SetExecutableVersion\n    // to populate this field\n    ProgramFullSpec: RawUtf8;\n    /// the main executable file name (including full path)\n    // - same as paramstr(0)\n    ProgramFileName: TFileName;\n    /// the main executable full path (excluding .exe file name)\n    // - same as ExtractFilePath(paramstr(0))\n    ProgramFilePath: TFileName;\n    /// the full path of the running executable or library\n    // - for an executable, same as paramstr(0)\n    // - for a library, will contain the whole .dll file name\n    InstanceFileName: TFileName;\n    /// the current executable version\n    // - you should have called GetExecutableVersion or SetExecutableVersion\n    // to populate this field\n    Version: TFileVersion;\n    /// the current computer host name\n    Host: RawUtf8;\n    /// the current computer user name\n    User: RawUtf8;\n    /// some hash representation of this information\n    // - the very same executable on the very same computer run by the very\n    // same user will always have the same Hash value\n    // - is computed from the crc32c of this TExecutable fields: c0 from\n    // Version32, CpuFeatures and Host, c1 from User, c2 from ProgramFullSpec\n    // and c3 from InstanceFileName\n    // - may be used as an entropy seed, or to identify a process execution\n    Hash: THash128Rec;\n    /// the Command Line arguments, parsed during unit initialization\n    Command: TExecutableCommandLine;\n  end;\n\nvar\n  /// global information about the current executable and computer\n  // - this structure is initialized in this unit's initialization block below\n  // but you need to call GetExecutableVersion to initialize its Version fields\n  // from the executable version resource (if any)\n  // - you can call SetExecutableVersion() with a custom version, if needed\n  Executable: TExecutable;\n\n  {$ifndef PUREMORMOT2}\n  /// deprecated global: use Executable variable instead\n  ExeVersion: TExecutable absolute Executable;\n  {$endif PUREMORMOT2}\n\n/// initialize Executable global variable, from the program version resources\n// - is not retrieved at startup, unless this function is especially called\n// - on POSIX, requires FPCUSEVERSIONINFO conditional to be set for the project\n// - use SetExecutableVersion() if you want to force a custom version\n// - is in fact just a wrapper around SetExecutableVersion(0, 0, 0, 0)\nprocedure GetExecutableVersion;\n\n/// initialize Executable global variable with custom version numbers\n// - GetExecutableVersion will retrieve version information from the\n// executable itself (if it was included at build time and FPCUSEVERSIONINFO\n// conditional was specified for the project)\n// - but you can use this function to set any custom version number\nprocedure SetExecutableVersion(aMajor, aMinor, aRelease, aBuild: integer); overload;\n\n/// initialize Executable global variable, supplying the version as text\n// - e.g. SetExecutableVersion('7.1.2.512');\nprocedure SetExecutableVersion(const aVersionText: RawUtf8); overload;\n\n/// return a function/method location according to the supplied code address\n// - returns the address as hexadecimal by default, e.g. '004cb765'\n// - if mormot.core.log.pas is defined in the project, will redirect to\n// TDebugFile.FindLocationShort() method using .map/.dbg/.mab information, and\n// return filename, symbol name and line number (if any) as plain text, e.g.\n// '4cb765 ../src/core/mormot.core.base.pas statuscodeissuccess (11183)' on FPC\nvar\n  GetExecutableLocation: function(aAddress: pointer): ShortString;\n\n/// try to retrieve the file name of the executable/library holding a function\n// - calls dladdr() on POSIX, or GetModuleFileName() on Windows\nfunction GetExecutableName(aAddress: pointer): TFileName;\n\nvar\n  /// retrieve the MAC addresses of all hardware network adapters\n  // - mormot.net.sock.pas will inject here its own cross-platform version\n  // - this unit will include a simple parser of /sys/class/net/* for Linux only\n  // - as used e.g. by GetComputerUuid() fallback if SMBIOS is not available\n  GetSystemMacAddress: function: TRawUtf8DynArray;\n\n\ntype\n  /// identify an operating system folder for GetSystemPath()\n  // - on Windows, spCommonData maps e.g. 'C:\\ProgramData',\n  // spUserData points to 'C:\\Users\\<user>\\AppData\\Local',\n  // spCommonDocuments to 'C:\\Users\\Public\\Documents',\n  // spUserDocuments to 'C:\\Users\\<user>\\Documents',\n  // spTemp will call GetTempPath() or read the $TEMP environment variable,\n  // pointing typically to 'C:\\Users\\<user>\\AppData\\Local\\Temp\\',\n  // and spLog either to '<exepath>\\log' or\n  // 'C:\\Users\\<user>\\AppData\\Local\\<exename>-log' (the first writable)\n  // - on POSIX, spTemp will use $TMPDIR/$TMP environment variables,\n  // spCommonData, spCommonDocuments and spUserDocuments point to $HOME,\n  // spUserData maps $XDG_CACHE_HOME or '$HOME/.cache' or '$TMP/<user>', and\n  // spLog maps '/var/log/<exename>' or '<exepath>/log' or '$TMP/<exename>-log'\n  // - on all systems, returned spTemp, spLog and spUserData folders are always\n  // writable by the current user\n  TSystemPath = (\n    spCommonData,\n    spUserData,\n    spCommonDocuments,\n    spUserDocuments,\n    spTemp,\n    spLog);\n\n{$ifndef PUREMORMOT2}\nconst\n  spTempFolder = spTemp;\n{$endif PUREMORMOT2}\n\n/// returns an operating system folder\n// - will return the full path of a given kind of private or shared folder,\n// depending on the underlying operating system\n// - will use SHGetFolderPath and the corresponding CSIDL constant under Windows\n// - under POSIX, will return the proper environment variable\n// - spLog is a writable sub-folder specific to mORMot, always created if needed\n// - returned folder name contains the trailing path delimiter (\\ or /)\nfunction GetSystemPath(kind: TSystemPath): TFileName;\n\n/// force an operating system folder\n// - if the default location is not good enough for your project\n// - will just check that the directory exists, not that it is writable\nfunction SetSystemPath(kind: TSystemPath; const path: TFileName): boolean;\n\ntype\n  /// identify the (Windows) system certificate stores for GetSystemStoreAsPem()\n  // - ignored on POSIX systems, in which the main cacert.pem file is used\n  // - scsCA contains known Certification Authority certificates, i.e. from\n  // entities entrusted to issue certificates that assert that the recipient\n  // individual, computer, or organization requesting the certificate fulfills\n  // the conditions of an established policy\n  // - scsMY holds certificates with associated private keys (Windows only)\n  // - scsRoot contains known Root certificates, i.e. self-signed CA certificates\n  // which are the root of the whole certificates trust tree\n  // - scsSpc contains Software Publisher Certificates (Windows only)\n  TSystemCertificateStore = (\n    scsCA,\n    scsMY,\n    scsRoot,\n    scsSpc);\n  TSystemCertificateStores = set of TSystemCertificateStore;\n\nvar\n  /// the local PEM file name to be searched by GetSystemStoreAsPem() to\n  // override the OS certificates store\n  // - a relative file name (i.e. with no included path, e.g. 'cacert.pem') will\n  // be searched in the Executable.ProgramFilePath folder\n  // - an absolute file name (e.g. 'C:\\path\\to\\file.pem' or '/posix/path') could\n  // also be specified\n  // - set by default to '' to disable this override (for security purposes)\n  GetSystemStoreAsPemLocalFile: TFileName;\n\n/// retrieve the OS certificates store as PEM text\n// - first search for [Executable.ProgramFilePath+]GetSystemStoreAsPemLocalFile,\n// then for a file pointed by a 'SSL_CA_CERT_FILE' environment variable - unless\n// OnlySystemStore is forced to true\n// - if no such file exists, or if OnlySystemStore is true, will concatenate the\n// supplied CertStores values via individual GetOneSystemStoreAsPem() calls\n// - return CA + ROOT certificates by default, ready to validate a certificate\n// - Darwin specific API is not supported yet, and is handled as a BSD system\n// - an internal cache is refreshed every 4 minutes unless FlushCache is set\nfunction GetSystemStoreAsPem(\n  CertStores: TSystemCertificateStores = [scsCA, scsRoot];\n  FlushCache: boolean = false; OnlySystemStore: boolean = false): RawUtf8;\n\n/// retrieve all certificates of a given system store as PEM text\n// - on Windows, will use the System Crypt API\n// - on POSIX, scsRoot loads the main CA file of the known system file, and\n// scsCA the additional certificate files which may not be part of the main file\n// - GetSystemStoreAsPemLocalFile file and 'SSL_CA_CERT_FILE' environment\n// variables are ignored: call GetSystemStoreAsPem() instead for the global store\n// - an internal cache is refreshed every 4 minutes unless FlushCache is set\nfunction GetOneSystemStoreAsPem(CertStore: TSystemCertificateStore;\n  FlushCache: boolean = false; now: cardinal = 0): RawUtf8;\n\ntype\n  /// the raw SMBIOS information as filled by GetRawSmbios\n  // - first 4 bytes are $010003ff on POSIX if read from /var/tmp/.synopse.smb\n  TRawSmbiosInfo = record\n    /// some flag only set by GetSystemFirmwareTable() Windows API\n    Reserved: byte;\n    /// typically 2-3\n    SmbMajorVersion: byte;\n    /// typically 0-1\n    SmbMinorVersion: byte;\n    /// typically 0 for SMBIOS 2.1, 1 for SMBIOS 3.0\n    DmiRevision: byte;\n    /// the length of encoded binary in data\n    Length: DWORD;\n    /// low-level binary of the SMBIOS Structure Table\n    Data: RawByteString;\n  end;\n\nvar\n  /// global variable filled by GetRawSmbios from SMBIOS binary information\n  RawSmbios: TRawSmbiosInfo;\n\n/// retrieve the SMBIOS raw information as a single RawSmbios gloabl binary blob\n// - will try the Windows API if available, or search and parse the main system\n// memory with UEFI redirection if needed - via /systab system file on Linux, or\n// kenv() on FreeBSD (only fully tested to work on Windows XP+ and Linux)\n// - follow DSP0134 3.6.0 System Management BIOS (SMBIOS) Reference Specification\n// with both SMBIOS 2.1 (32-bit) or SMBIOS 3.0 (64-bit) entry points\n// - the current user should have enough rights to read the main system memory,\n// which means it should be root on most POSIX Operating Systems - so we persist\n// this raw binary in /var/tmp/.synopse.smb to retrieve it from non-root user\nfunction GetRawSmbios: boolean;\n\ntype\n  /// the basic SMBIOS fields supported by GetSmbios/DecodeSmbios functions\n  // - only include the first occurrence for board/cpu/battery types\n  // - see TSmbiosInfo in mormot.core.perf.pas for more complete decoding\n  TSmbiosBasicInfo = (\n    sbiUndefined,\n    sbiBiosVendor,\n    sbiBiosVersion,\n    sbiBiosFirmware,\n    sbiBiosRelease,\n    sbiBiosDate,\n    sbiManufacturer,\n    sbiProductName,\n    sbiVersion,\n    sbiSerial,\n    sbiUuid,\n    sbiSku,\n    sbiFamily,\n    sbiBoardManufacturer,\n    sbiBoardProductName,\n    sbiBoardVersion,\n    sbiBoardSerial,\n    sbiBoardAssetTag,\n    sbiBoardLocation,\n    sbiCpuManufacturer,\n    sbiCpuVersion,\n    sbiCpuSerial,\n    sbiCpuAssetTag,\n    sbiCpuPartNumber,\n    sbiBatteryLocation,\n    sbiBatteryManufacturer,\n    sbiBatteryName,\n    sbiBatteryVersion,\n    sbiBatteryChemistry,\n    sbiOem\n  );\n\n  /// the text fields stored by GetSmbios/DecodeSmbios functions\n  TSmbiosBasicInfos = array[TSmbiosBasicInfo] of RawUtf8;\n\n/// decode basic SMBIOS information as text from a TRawSmbiosInfo binary blob\n// - see DecodeSmbiosInfo() in mormot.core.perf.pas for a more complete decoder\n// - returns the total size of DMI/SMBIOS information in raw.data (may be lower)\n// - will also adjust raw.Length and truncate raw.Data to the actual useful size\nfunction DecodeSmbios(var raw: TRawSmbiosInfo; out info: TSmbiosBasicInfos): PtrInt;\n\n// some global definitions for proper caching and inlining of GetSmbios()\nprocedure ComputeGetSmbios;\nprocedure DecodeSmbiosUuid(src: PGuid; out dest: RawUtf8; const raw: TRawSmbiosInfo);\nvar\n  _Smbios: TSmbiosBasicInfos;\n  _SmbiosRetrieved: boolean;\n\n  /// customize how DecodeSmbiosUuid() handle endianess of its first bytes\n  // - sduDirect will directly use GUIDToString() layout (seems expected on\n  // Windows to match \"wmic csproduct get uuid\" value)\n  // - sduInvert will force first values inversion (mandatory on MacOS)\n  // - sduVersion will invert for SMBios version < 2.6 (set outside Windows)\n  _SmbiosDecodeUuid: (sduDirect, sduInvert, sduVersion)\n    {$ifdef OSDARWIN}  = sduInvert  {$else}\n      {$ifdef OSPOSIX} = sduVersion {$endif} {$endif};\n\n/// retrieve SMBIOS information as text\n// - only the main values are decoded - see GetSmbiosInfo in mormot.core.perf\n// for a more complete DMI/SMBIOS decoder\n// - on POSIX, requires root to access full SMBIOS information - will fallback\n// reading /sys/class/dmi/id/* on Linux or kenv() on FreeBSD for most entries\n// if we found no previous root-retrieved cache in local /var/tmp/.synopse.smb\n// - see _SmbiosDecodeUuid global flag for UUID decoding\nfunction GetSmbios(info: TSmbiosBasicInfo): RawUtf8;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// retrieve a genuine 128-bit UUID identifier for this computer\n// - first try GetSmbios(sbiUuid), i.e. the SMBIOS System UUID\n// - otherwise, will compute a genuine hash from known hardware information\n// (CPU, Bios, MAC) and store it in a local file for the next access, e.g. into\n// '/var/tmp/.synopse.uid' on POSIX\n// - on Mac, include the mormot.core.os.mac unit to properly read this UUID\n// - note: some BIOS have no UUID, so we fallback to our hardware hash on those\nprocedure GetComputerUuid(out uuid: TGuid);\n\n\n{ ****************** Operating System Specific Types (e.g. TWinRegistry) }\n\n{$ifdef OSWINDOWS}\n\ntype\n  TThreadID     = DWORD;\n  TMessage      = Messages.TMessage;\n  HWND          = Windows.HWND;\n  BOOL          = Windows.BOOL;\n  LARGE_INTEGER = Windows.LARGE_INTEGER;\n  TFileTime     = Windows.FILETIME;\n  PFileTime     = ^TFileTime;\n\n  /// the known Windows Registry Root key used by TWinRegistry.ReadOpen\n  TWinRegistryRoot = (\n    wrClasses,\n    wrCurrentUser,\n    wrLocalMachine,\n    wrUsers);\n\n  /// direct access to the Windows Registry\n  // - could be used as alternative to TRegistry, which doesn't behave the same on\n  // all Delphi versions, and is enhanced on FPC (e.g. which supports REG_MULTI_SZ)\n  // - is also Unicode ready for text, using UTF-8 conversion on all compilers\n  {$ifdef USERECORDWITHMETHODS}\n  TWinRegistry = record\n  {$else}\n  TWinRegistry = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// the opened HKEY handle\n    key: HKEY;\n    /// start low-level read access to a Windows Registry node\n    // - on success (returned true), Close method should be eventually called\n    function ReadOpen(root: TWinRegistryRoot; const keyname: RawUtf8;\n      closefirst: boolean = false): boolean;\n    /// finalize low-level read access to the Windows Registry after ReadOpen()\n    procedure Close;\n    /// read a UTF-8 string from the Windows Registry after ReadOpen()\n    // - in respect to Delphi's TRegistry, will properly handle REG_MULTI_SZ\n    // (return the first value of the multi-list) - use ReadData to retrieve\n    // all REG_MULTI_SZ values as one blob\n    // - we don't use string here since it would induce a dependency to\n    // mormot.core.unicode\n    function ReadString(const entry: SynUnicode; andtrim: boolean = true): RawUtf8;\n    /// read a Windows Registry content after ReadOpen()\n    // - works with any kind of key, but was designed for REG_BINARY\n    function ReadData(const entry: SynUnicode): RawByteString;\n    /// read a Windows Registry 32-bit REG_DWORD value after ReadOpen()\n    function ReadDword(const entry: SynUnicode): cardinal;\n    /// read a Windows Registry 64-bit REG_QWORD value after ReadOpen()\n    function ReadQword(const entry: SynUnicode): QWord;\n    /// read a Windows Registry content as binary buffer after ReadOpen()\n    // - just a wrapper around RegQueryValueExW() API call\n    function ReadBuffer(const entry: SynUnicode; Data: pointer; DataLen: DWORD): boolean;\n    /// retrieve a Windows Registry content size as binary bytes after ReadOpen()\n    // - returns -1 if the entry is not found\n    function ReadSize(const entry: SynUnicode): integer;\n    /// enumeration of all sub-entries names of a Windows Registry key\n    function ReadEnumEntries: TRawUtf8DynArray;\n  end;\n\n  /// TSynWindowsPrivileges enumeration synchronized with WinAPI\n  // - see https://docs.microsoft.com/en-us/windows/desktop/secauthz/privilege-constants\n  TWinSystemPrivilege = (\n    wspCreateToken,\n    wspAssignPrimaryToken,\n    wspLockMemory,\n    wspIncreaseQuota,\n    wspUnsolicitedInput,\n    wspMachineAccount,\n    wspTCP,\n    wspSecurity,\n    wspTakeOwnership,\n    wspLoadDriver,\n    wspSystemProfile,\n    wspSystemTime,\n    wspProfSingleProcess,\n    wspIncBasePriority,\n    wspCreatePageFile,\n    wspCreatePermanent,\n    wspBackup,\n    wspRestore,\n    wspShutdown,\n    wspDebug,\n    wspAudit,\n    wspSystemEnvironment,\n    wspChangeNotify,\n    wspRemoteShutdown,\n    wspUndock,\n    wspSyncAgent,\n    wspEnableDelegation,\n    wspManageVolume,\n    wspImpersonate,\n    wspCreateGlobal,\n    wspTrustedCredmanAccess,\n    wspRelabel,\n    wspIncWorkingSet,\n    wspTimeZone,\n    wspCreateSymbolicLink);\n\n  /// TSynWindowsPrivileges set synchronized with WinAPI\n  TWinSystemPrivileges = set of TWinSystemPrivilege;\n\n  /// define which WinAPI token is to be retrieved\n  // - define the execution context, i.e. if the token is used for the current\n  // process or the current thread\n  // - used e.g. by TSynWindowsPrivileges or CurrentSid()\n  TWinTokenType = (\n    wttProcess,\n    wttThread);\n\n  /// manage available privileges on Windows platform\n  // - not all available privileges are active for all process\n  // - for usage of more advanced WinAPI, explicit enabling of privilege is\n  // sometimes needed\n  {$ifdef USERECORDWITHMETHODS}\n  TSynWindowsPrivileges = record\n  {$else}\n  TSynWindowsPrivileges = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fAvailable: TWinSystemPrivileges;\n    fEnabled: TWinSystemPrivileges;\n    fDefEnabled: TWinSystemPrivileges;\n    fToken: THandle;\n    function SetPrivilege(wsp: TWinSystemPrivilege; on: boolean): boolean;\n    procedure LoadPrivileges;\n  public\n    /// initialize the object dedicated to management of available privileges\n    // - aTokenPrivilege can be used for current process or current thread\n    procedure Init(aTokenPrivilege: TWinTokenType = wttProcess;\n      aLoadPrivileges: boolean = true);\n    /// finalize the object and relese Token handle\n    // - aRestoreInitiallyEnabled parameter can be used to restore initially\n    // state of enabled privileges\n    procedure Done(aRestoreInitiallyEnabled: boolean = true);\n    /// enable privilege\n    // - if aPrivilege is already enabled return true, if operation is not\n    // possible (required privilege doesn't exist or API error) return false\n    function Enable(aPrivilege: TWinSystemPrivilege): boolean;\n    /// disable privilege\n    // - if aPrivilege is already disabled return true, if operation is not\n    // possible (required privilege doesn't exist or API error) return false\n    function Disable(aPrivilege: TWinSystemPrivilege): boolean;\n    /// set of available privileges for current process/thread\n    property Available: TWinSystemPrivileges\n      read fAvailable;\n    /// set of enabled privileges for current process/thread\n    property Enabled: TWinSystemPrivileges\n      read fEnabled;\n    /// low-level access to the privileges token handle\n    property Token: THandle\n      read fToken;\n  end;\n\n  /// which information was returned by GetProcessInfo() overloaded functions\n  // - wpaiPID is set when PID was retrieved\n  // - wpaiBasic with ParentPID/BasePriority/ExitStatus/PEBBaseAddress/AffinityMask\n  // - wpaiPEB with SessionID/BeingDebugged\n  // - wpaiCommandLine and wpaiImagePath when CommandLine and ImagePath are set\n  TWinProcessAvailableInfos = set of (\n    wpaiPID,\n    wpaiBasic,\n    wpaiPEB,\n    wpaiCommandLine,\n    wpaiImagePath);\n\n  /// information returned by GetProcessInfo() overloaded functions\n  TWinProcessInfo = record\n    /// which information was returned within this structure\n    AvailableInfo: TWinProcessAvailableInfos;\n    /// the Process ID\n    PID: cardinal;\n    /// the Parent Process ID\n    ParentPID: cardinal;\n    /// Terminal Services session identifier associated with this process\n    SessionID: cardinal;\n    /// points to the low-level internal PEB structure\n    // - you can not directly access this memory, unless ReadProcessMemory()\n    // with proper wspDebug priviledge API is called\n    PEBBaseAddress: pointer;\n    /// GetProcessAffinityMask-like value\n    AffinityMask: cardinal;\n    /// process priority\n    BasePriority: integer;\n    /// GetExitCodeProcess-like value\n    ExitStatus: integer;\n    /// indicates whether the specified process is currently being debugged\n    BeingDebugged: byte;\n    /// command-line string passed to the process\n    CommandLine: SynUnicode;\n    /// path of the image file for the process\n    ImagePath: SynUnicode;\n  end;\n\n  PWinProcessInfo = ^TWinProcessInfo;\n  TWinProcessInfoDynArray = array of TWinProcessInfo;\n\n  /// the SID types, as recognized by LookupSid()\n  TSidType = (\n    stUndefined,\n    stTypeUser,\n    stTypeGroup,\n    stTypeDomain,\n    stTypeAlias,\n    stTypeWellKnownGroup,\n    stTypeDeletedAccount,\n    stTypeInvalid,\n    stTypeUnknown,\n    stTypeComputer,\n    stTypeLabel,\n    stTypeLogonSession);\n\n\nfunction ToText(p: TWinSystemPrivilege): PShortString; overload;\n\n/// calls OpenProcessToken() or OpenThreadToken() to get the current token\n// - caller should then run CloseHandle() once done with the Token handle\nfunction RawTokenOpen(wtt: TWinTokenType; access: cardinal): THandle;\n\n/// low-level retrieveal of raw binary information for a given token\n// - returns the number of bytes retrieved into buf.buf\n// - caller should then run buf.Done to release the buf result memory\nfunction RawTokenGetInfo(tok: THandle; tic: TTokenInformationClass;\n  var buf: TSynTempBuffer): cardinal;\n\n/// return the SID of a given token, nil if none found\n// - the returned PSid is located within buf temporary buffer\n// - so caller should call buf.Done once this PSid value is not needed any more\nfunction RawTokenSid(tok: THandle; var buf: TSynTempBuffer): PSid;\n\n/// return the group SIDs of a given token, nil if none found\n// - the returned PSid is located within buf temporary buffer\n// - so caller should call buf.Done once this PSid value is not needed any more\nfunction RawTokenGroups(tok: THandle; var buf: TSynTempBuffer): PSids;\n\n/// return the group SIDs of a given token as text dynamic array\nfunction TokenGroupsText(tok: THandle): TRawUtf8DynArray;\n\n/// check if a group SID is part of a given token\nfunction TokenHasGroup(tok: THandle; sid: PSid): boolean;\n\n/// check if any group SID is part of a given token\nfunction TokenHasAnyGroup(tok: THandle; const sid: RawSidDynArray): boolean;\n\n/// return the SID of the current user, from process or thread, as text\n// - e.g. 'S-1-5-21-823746769-1624905683-418753922-1000'\n// - optionally returning the name and domain via LookupSid()\nfunction CurrentSid(wtt: TWinTokenType = wttProcess;\n  name: PRawUtf8 = nil; domain: PRawUtf8 = nil): RawUtf8; overload;\n\n/// return the SID of the current user, from process or thread, as raw binary\nprocedure CurrentRawSid(out sid: RawSid; wtt: TWinTokenType = wttProcess;\n  name: PRawUtf8 = nil; domain: PRawUtf8 = nil); overload;\n\n/// return the SID of the current user groups, from process or thread, as text\nfunction CurrentGroupsSid(wtt: TWinTokenType = wttProcess): TRawUtf8DynArray;\n\n/// recognize the well-known SIDs from the current user, from process or thread\n// - for instance, for an user with administrator rights on Windows, returns\n// $ [wksWorld, wksLocal, wksConsoleLogon, wksIntegrityHigh, wksInteractive,\n// $  wksAuthenticatedUser, wksThisOrganisation, wksBuiltinAdministrators,\n// $  wksBuiltinUsers, wksNtlmAuthentication]\nfunction CurrentKnownGroups(wtt: TWinTokenType = wttProcess): TWellKnownSids;\n\n/// fast check if the current user, from process or thread, has a well-known group SID\n// - e.g. CurrentUserHasGroup(wksLocalSystem) returns true for LOCAL_SYSTEM user\nfunction CurrentUserHasGroup(wks: TWellKnownSid;\n  wtt: TWinTokenType = wttProcess): boolean; overload;\n\n/// fast check if the current user, from process or thread, has a given group SID\nfunction CurrentUserHasGroup(const sid: RawUtf8;\n  wtt: TWinTokenType = wttProcess): boolean; overload;\n\n/// fast check if the current user, from process or thread, has a given group SID\nfunction CurrentUserHasGroup(sid: PSid;\n  wtt: TWinTokenType = wttProcess): boolean; overload;\n\n/// fast check if the current user, from process or thread, has any given group SID\nfunction CurrentUserHasAnyGroup(const sid: RawSidDynArray;\n  wtt: TWinTokenType = wttProcess): boolean;\n\n/// fast check if the current user, from process or thread, match a group by name\n// - calls LookupSid() on each group SID of this user, and filter with name/domain\nfunction CurrentUserHasGroup(const name, domain, server: RawUtf8;\n  wtt: TWinTokenType = wttProcess): boolean; overload;\n\n/// just a wrapper around CurrentUserHasGroup(wksBuiltinAdministrators)\nfunction CurrentUserIsAdmin: boolean;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// rough detection of 'c:\\windows' and 'c:\\program files' folders\nfunction IsSystemFolder(const Folder: TFileName): boolean;\n\n// check if a folder may be affected by UAC folder virtualization\n// - on Win32 Vista+, detects 'c:\\windows' and 'c:\\program files' UAC folders\n// - returns always false on Win64\nfunction IsUacVirtualFolder(const Folder: TFileName): boolean;\n  {$ifdef CPU64} inline; {$endif}\n\n/// check if UAC folder/registry virtualization is enabled for this process\n// - returns always false on Win64 - by design\n// - calls GetTokenInformation(TokenVirtualizationEnabled) on Win32\n// - if you include {$R src\\mormot.win.default.manifest.res} in your project,\n// UAC virtualization is disabled and this function returns false\nfunction IsUacVirtualizationEnabled: boolean;\n  {$ifdef CPU64} inline; {$endif}\n\n/// retrieve the name and domain of a given SID\n// - returns stUndefined if the SID could not be resolved by LookupAccountSid()\nfunction LookupSid(sid: PSid; out name, domain: RawUtf8;\n  const server: RawUtf8 = ''): TSidType; overload;\n\n/// retrieve the name and domain of a given SID, encoded from text\n// - returns stUndefined if the SID could not be resolved by LookupAccountSid()\nfunction LookupSid(const sid: RawUtf8; out name, domain: RawUtf8;\n  const server: RawUtf8 = ''): TSidType; overload;\n\n/// retrieve the name and domain of a given Token\nfunction LookupToken(tok: THandle; out name, domain: RawUtf8;\n  const server: RawUtf8 = ''): boolean; overload;\n\n/// retrieve the 'domain\\name' combined value of a given Token\nfunction LookupToken(tok: THandle; const server: RawUtf8 = ''): RawUtf8; overload;\n\n/// retrieve low-level process information, from the Windows API\nprocedure GetProcessInfo(aPid: cardinal; out aInfo: TWinProcessInfo); overload;\n\n/// retrieve low-level process(es) information, from the Windows API\nprocedure GetProcessInfo(const aPidList: TCardinalDynArray;\n  out aInfo: TWinProcessInfoDynArray); overload;\n\n/// quickly retrieve a Text value from Registry\n// - could be used if TWinRegistry is not needed, e.g. for a single value\nfunction ReadRegString(Key: THandle; const Path, Value: string): string;\n\n/// convenient late-binding of any external library function\n// - just wrapper around LoadLibray + GetProcAddress once over a pointer\nfunction DelayedProc(var api; var lib: THandle;\n  libname: PChar; procname: PAnsiChar): boolean;\n\ntype\n  HCRYPTPROV = pointer;\n  HCRYPTKEY = pointer;\n  HCRYPTHASH = pointer;\n  HCERTSTORE = pointer;\n\n  CRYPTOAPI_BLOB = record\n    cbData: DWORD;\n    pbData: PByteArray;\n  end;\n  CRYPT_INTEGER_BLOB = CRYPTOAPI_BLOB;\n  CERT_NAME_BLOB     = CRYPTOAPI_BLOB;\n  CRYPT_OBJID_BLOB   = CRYPTOAPI_BLOB;\n\n  CRYPT_BIT_BLOB = record\n    cbData: DWORD;\n    pbData: PByteArray;\n    cUnusedBits: DWORD;\n  end;\n\n  CRYPT_ALGORITHM_IDENTIFIER = record\n    pszObjId: PAnsiChar;\n    Parameters: CRYPT_OBJID_BLOB;\n  end;\n\n  CERT_PUBLIC_KEY_INFO = record\n    Algorithm: CRYPT_ALGORITHM_IDENTIFIER;\n    PublicKey: CRYPT_BIT_BLOB;\n  end;\n\n  CERT_EXTENSION = record\n    pszObjId: PAnsiChar;\n    fCritical: BOOL;\n    Blob: CRYPT_OBJID_BLOB;\n  end;\n  PCERT_EXTENSION = ^CERT_EXTENSION;\n  CERT_EXTENSIONS = array[word] of CERT_EXTENSION;\n  PCERT_EXTENSIONS = ^CERT_EXTENSIONS;\n\n  CERT_INFO = record\n    dwVersion: DWORD;\n    SerialNumber: CRYPT_INTEGER_BLOB;\n    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER;\n    Issuer: CERT_NAME_BLOB;\n    NotBefore: TFileTime;\n    NotAfter: TFileTime;\n    Subject: CERT_NAME_BLOB;\n    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO;\n    IssuerUniqueId: CRYPT_BIT_BLOB;\n    SubjectUniqueId: CRYPT_BIT_BLOB;\n    cExtension: DWORD;\n    rgExtension: PCERT_EXTENSIONS;\n  end;\n  PCERT_INFO = ^CERT_INFO;\n\n  CERT_CONTEXT = record\n    dwCertEncodingType: DWORD;\n    pbCertEncoded: PByte;\n    cbCertEncoded: DWORD;\n    pCertInfo: PCERT_INFO;\n    hCertStore: HCERTSTORE;\n  end;\n  PCCERT_CONTEXT = ^CERT_CONTEXT;\n  PPCCERT_CONTEXT = ^PCCERT_CONTEXT;\n\n  CRYPT_KEY_PROV_PARAM = record\n    dwParam: DWORD;\n    pbData: PByte;\n    cbData: DWORD;\n    dwFlags: DWORD;\n  end;\n  PCRYPT_KEY_PROV_PARAM = ^CRYPT_KEY_PROV_PARAM;\n\n  CRYPT_KEY_PROV_INFO = record\n    pwszContainerName: PWideChar;\n    pwszProvName: PWideChar;\n    dwProvType: DWORD;\n    dwFlags: DWORD;\n    cProvParam: DWORD;\n    rgProvParam: PCRYPT_KEY_PROV_PARAM;\n    dwKeySpec: DWORD;\n  end;\n  PCRYPT_KEY_PROV_INFO = ^CRYPT_KEY_PROV_INFO;\n\n  CRYPT_OID_INFO = record\n    cbSize: DWORD;\n    pszOID: PAnsiChar;\n    pwszName: PWideChar;\n    dwGroupId: DWORD;\n    Union: record\n      case integer of\n        0: (dwValue: DWORD);\n        1: (Algid: DWORD);\n        2: (dwLength: DWORD);\n    end;\n    ExtraInfo: CRYPTOAPI_BLOB;\n  end;\n  PCRYPT_OID_INFO = ^CRYPT_OID_INFO;\n\n  PCCRL_CONTEXT = pointer;\n  PPCCRL_CONTEXT = ^PCCRL_CONTEXT;\n  PCRYPT_ATTRIBUTE = pointer;\n\n  CRYPT_SIGN_MESSAGE_PARA = record\n    cbSize: DWORD;\n    dwMsgEncodingType: DWORD;\n    pSigningCert: PCCERT_CONTEXT;\n    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER;\n    pvHashAuxInfo: Pointer;\n    cMsgCert: DWORD;\n    rgpMsgCert: PPCCERT_CONTEXT;\n    cMsgCrl: DWORD;\n    rgpMsgCrl: PPCCRL_CONTEXT;\n    cAuthAttr: DWORD;\n    rgAuthAttr: PCRYPT_ATTRIBUTE;\n    cUnauthAttr: DWORD;\n    rgUnauthAttr: PCRYPT_ATTRIBUTE;\n    dwFlags: DWORD;\n    dwInnerContentType: DWORD;\n    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER;\n    pvHashEncryptionAuxInfo: Pointer;\n  end;\n\n  PFN_CRYPT_GET_SIGNER_CERTIFICATE = function(pvGetArg: Pointer;\n    dwCertEncodingType: DWORD; pSignerId: PCERT_INFO;\n    hMsgCertStore: HCERTSTORE): PCCERT_CONTEXT; stdcall;\n  CRYPT_VERIFY_MESSAGE_PARA = record\n    cbSize: DWORD;\n    dwMsgAndCertEncodingType: DWORD;\n    hCryptProv: HCRYPTPROV;\n    pfnGetSignerCertificate: PFN_CRYPT_GET_SIGNER_CERTIFICATE;\n    pvGetArg: Pointer;\n  end;\n\n  /// direct access to the Windows CryptoApi\n  {$ifdef USERECORDWITHMETHODS}\n  TWinCryptoApi = record\n  {$else}\n  TWinCryptoApi = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    /// if the presence of this API has been tested\n    Tested: boolean;\n    /// if this API has been loaded\n    Handle: THandle;\n    /// used when inlining Available method\n    procedure Resolve;\n  public\n    /// acquire a handle to a particular key container within a\n    // particular cryptographic service provider (CSP)\n    AcquireContextA: function(var phProv: HCRYPTPROV; pszContainer: PAnsiChar;\n      pszProvider: PAnsiChar; dwProvType: DWORD; dwFlags: DWORD): BOOL; stdcall;\n    /// releases the handle of a cryptographic service provider (CSP) and a\n    // key container\n    ReleaseContext: function(hProv: HCRYPTPROV; dwFlags: PtrUInt): BOOL; stdcall;\n    /// transfers a cryptographic key from a key BLOB into a cryptographic\n    // service provider (CSP)\n    ImportKey: function(hProv: HCRYPTPROV; pbData: pointer; dwDataLen: DWORD;\n      hPubKey: HCRYPTKEY; dwFlags: DWORD; var phKey: HCRYPTKEY): BOOL; stdcall;\n    /// customizes various aspects of a session key's operations\n    SetKeyParam: function(hKey: HCRYPTKEY; dwParam: DWORD; pbData: pointer;\n      dwFlags: DWORD): BOOL; stdcall;\n    /// releases the handle referenced by the hKey parameter\n    DestroyKey: function(hKey: HCRYPTKEY): BOOL; stdcall;\n    /// encrypt the data designated by the key held by the CSP module\n    // referenced by the hKey parameter\n    Encrypt: function(hKey: HCRYPTKEY; hHash: HCRYPTHASH; Final: BOOL;\n      dwFlags: DWORD; pbData: pointer; var pdwDataLen: DWORD; dwBufLen: DWORD): BOOL; stdcall;\n    /// decrypts data previously encrypted by using the CryptEncrypt function\n    Decrypt: function(hKey: HCRYPTKEY; hHash: HCRYPTHASH; Final: BOOL;\n      dwFlags: DWORD; pbData: pointer; var pdwDataLen: DWORD): BOOL; stdcall;\n    /// fills a buffer with cryptographically random bytes\n    // - since Windows Vista with Service Pack 1 (SP1), an AES counter-mode\n    // based PRNG specified in NIST Special Publication 800-90 is used\n    GenRandom: function(hProv: HCRYPTPROV; dwLen: DWORD; pbBuffer: Pointer): BOOL; stdcall;\n    /// sign a message (not resolved yet - in crypt32.dll)\n    SignMessage: function(var pSignPara: CRYPT_SIGN_MESSAGE_PARA;\n      fDetachedSignature: BOOL; cToBeSigned: DWORD; rgpbToBeSigned: pointer;\n      var rgcbToBeSigned: DWORD; pbSignedBlob: pointer; var pcbSignedBlob: DWORD): BOOL; stdcall;\n    /// verify a signed message (not resolved yet - in crypt32.dll)\n    VerifyMessageSignature: function(var pVerifyPara: CRYPT_VERIFY_MESSAGE_PARA;\n      dwSignerIndex: DWORD; pbSignedBlob: PByte; cbSignedBlob: DWORD;\n      pbDecoded: PByte; pcbDecoded: LPDWORD; ppSignerCert: PPCCERT_CONTEXT): BOOL; stdcall;\n    /// try to load the CryptoApi on this system\n    function Available: boolean;\n      {$ifdef HASINLINE}inline;{$endif}\n  end;\n\nconst\n  NO_ERROR  = Windows.NO_ERROR;\n\n  ERROR_ACCESS_DENIED      = Windows.ERROR_ACCESS_DENIED;\n  ERROR_INVALID_PARAMETER  = Windows.ERROR_INVALID_PARAMETER;\n  ERROR_HANDLE_EOF         = Windows.ERROR_HANDLE_EOF;\n  ERROR_ALREADY_EXISTS     = Windows.ERROR_ALREADY_EXISTS;\n  ERROR_MORE_DATA          = Windows.ERROR_MORE_DATA;\n  ERROR_CONNECTION_INVALID = Windows.ERROR_CONNECTION_INVALID;\n  ERROR_OLD_WIN_VERSION    = Windows.ERROR_OLD_WIN_VERSION;\n  ERROR_IO_PENDING         = Windows.ERROR_IO_PENDING;\n  ERROR_OPERATION_ABORTED  = Windows.ERROR_OPERATION_ABORTED;\n  // see http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770\n  ERROR_WINHTTP_TIMEOUT                 = 12002;\n  ERROR_WINHTTP_CANNOT_CONNECT          = 12029;\n  ERROR_WINHTTP_INVALID_SERVER_RESPONSE = 12152;\n  ERROR_MUI_FILE_NOT_FOUND              = 15100;\n\n  INVALID_HANDLE_VALUE = Windows.INVALID_HANDLE_VALUE; // = HANDLE(-1)\n  ENGLISH_LANGID       = $0409;\n\n  PROV_RSA_FULL        = 1;\n  PROV_RSA_AES         = 24;\n  CRYPT_NEWKEYSET      = 8;\n  CRYPT_VERIFYCONTEXT  = DWORD($F0000000);\n  PLAINTEXTKEYBLOB     = 8;\n  CUR_BLOB_VERSION     = 2;\n  KP_IV                = 1;\n  KP_MODE              = 4;\n  CALG_AES_128         = $660E;\n  CALG_AES_192         = $660F;\n  CALG_AES_256         = $6610;\n  CRYPT_MODE_CBC       = 1;\n  CRYPT_MODE_ECB       = 2;\n  CRYPT_MODE_OFB       = 3;\n  CRYPT_MODE_CFB       = 4;\n  CRYPT_MODE_CTS       = 5;\n  HCRYPTPROV_NOTTESTED = HCRYPTPROV(-1);\n  NTE_BAD_KEYSET       = HRESULT($80090016);\n\nvar\n  CryptoApi: TWinCryptoApi;\n\n/// protect some data for the current user, using Windows DPAPI\n// - the application can specify a secret salt text, which should reflect the\n// current execution context, to ensure nobody could decrypt the data without\n// knowing this application-specific AppSecret value\n// - will use CryptProtectData DPAPI function call under Windows\n// - see https://msdn.microsoft.com/en-us/library/ms995355\n// - this function is Windows-only, could be slow, and you don't know which\n// algorithm is really used on your system, so using our mormot.crypt.core.pas\n// CryptDataForCurrentUser() is probably a safer (and cross-platform) alternative\n// - also note that DPAPI has been closely reverse engineered - see e.g.\n// https://www.passcape.com/index.php?section=docsys&cmd=details&id=28\nfunction CryptDataForCurrentUserDPAPI(const Data, AppSecret: RawByteString;\n  Encrypt: boolean): RawByteString;\n\nconst\n  WINDOWS_CERTSTORE: array[TSystemCertificateStore] of PWideChar = (\n    'CA', 'MY', 'ROOT', 'SPC');\n\n/// this global procedure should be called from each thread needing to use OLE\n// - it is called e.g. by TOleDBConnection.Create when an OleDb connection\n// is instantiated for a new thread\n// - every call of CoInit shall be followed by a call to CoUninit\n// - implementation will maintain some global counting, to call the CoInitialize\n// API only once per thread\n// - only made public for user convenience, e.g. when using custom COM objects\nprocedure CoInit;\n\n/// this global procedure should be called at thread termination\n// - it is called e.g. by TOleDBConnection.Destroy, when thread associated\n// to an OleDb connection is terminated\n// - every call of CoInit shall be followed by a call to CoUninit\n// - only made public for user convenience, e.g. when using custom COM objects\nprocedure CoUninit;\n\n/// retrieves the current executable module handle, i.e.  its memory load address\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction GetModuleHandle(lpModuleName: PChar): HMODULE;\n\n/// post a message to the Windows message queue\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction PostMessage(hWnd: HWND; Msg: UINT; wParam: WPARAM; lParam: LPARAM): BOOL;\n\n/// retrieves the current stack trace\n// - only available since Windows XP\n// - FramesToSkip + FramesToCapture should be <= 62\nfunction RtlCaptureStackBackTrace(FramesToSkip, FramesToCapture: cardinal;\n  BackTrace, BackTraceHash: pointer): byte; stdcall;\n\n/// retrieves the current thread ID\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction GetCurrentThreadId: DWORD; stdcall;\n\n/// retrieves the current process ID\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction GetCurrentProcessId: DWORD; stdcall;\n\n/// retrieves the current process ID\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction GetCurrentProcess: THandle; stdcall;\n\n/// redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction WaitForSingleObject(hHandle: THandle; dwMilliseconds: DWORD): DWORD; stdcall;\n\n/// redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction GetEnvironmentStringsW: PWideChar; stdcall;\n\n/// redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction FreeEnvironmentStringsW(EnvBlock: PWideChar): BOOL; stdcall;\n\n/// expand any embedded environment variables, i.e %windir%\nfunction ExpandEnvVars(const aStr: string): string;\n\n/// try to enter a Critical Section (Lock)\n// - returns 1 if the lock was acquired, or 0 if the mutex is already locked\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Delphi/Windows, directly call the homonymous Win32 API\nfunction TryEnterCriticalSection(var cs: TRTLCriticalSection): integer; stdcall;\n\n/// enter a Critical Section (Lock)\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Delphi/Windows, directly call the homonymous Win32 API\nprocedure EnterCriticalSection(var cs: TRTLCriticalSection); stdcall;\n\n/// leave a Critical Section (UnLock)\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Delphi/Windows, directly call the homonymous Win32 API\nprocedure LeaveCriticalSection(var cs: TRTLCriticalSection); stdcall;\n\n/// initialize Windows IOCP instance\n// - renamed in mormot.core.os to avoid dependency to the Windows unit\nfunction IocpCreate(FileHandle, ExistingCompletionPort: THandle;\n  CompletionKey: pointer; NumberOfConcurrentThreads: DWORD): THandle; stdcall;\n\n/// retrieve Windows IOCP instance status\n// - renamed in mormot.core.os to avoid dependency to the Windows unit\nfunction IocpGetQueuedStatus(CompletionPort: THandle;\n  var lpNumberOfBytesTransferred: DWORD; var lpCompletionKey: pointer;\n  var lpOverlapped: pointer; dwMilliseconds: DWORD): BOOL; stdcall;\n\n/// trigger a Windows IOCP instance\n// - renamed in mormot.core.os to avoid dependency to the Windows unit\nfunction IocpPostQueuedStatus(CompletionPort: THandle;\n  NumberOfBytesTransferred: DWORD; dwCompletionKey: pointer;\n  lpOverlapped: POverlapped): BOOL; stdcall;\n\n/// finalize a Windows resource (e.g. IOCP instance)\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\nfunction CloseHandle(hObject: THandle): BOOL; stdcall;\n\n/// redefined here to avoid warning to include \"Windows\" in uses clause\n// - why did Delphi define this slow RTL function as inlined in SysUtils.pas?\n// - also supports aFileName longer than MAX_PATH\n// - on Windows, aRights parameter is just ignored, and on POSIX aRights = 0\n// will set the default octal 644 file access attributes (-rw-r-r--)\n// - warning: this function replaces ALL SysUtils.FileCreate() overloads,\n// putting aMode as the SECOND parameter, just like with FileOpen()\nfunction FileCreate(const aFileName: TFileName; aMode: integer = 0;\n  aRights: integer = 0): THandle;\n\n/// redefined here to call CreateFileW() on non-Unicode RTL and support\n// aFileName longer than MAX_PATH\nfunction FileOpen(const aFileName: TFileName; aMode: integer): THandle;\n\n/// redefined here to avoid warning to include \"Windows\" in uses clause\n// - why did Delphi define this slow RTL function as inlined in SysUtils.pas?\nprocedure FileClose(F: THandle); stdcall;\n\n/// redefined here to support FileName longer than MAX_PATH\n// - as our FileOpen/FileCreate redefinitions\n// - CheckAsDir = true is used by DirectoryExists()\nfunction FileExists(const FileName: TFileName; FollowLink: boolean = true;\n  CheckAsDir: boolean = false): boolean;\n\n/// redefined here to support FileName longer than MAX_PATH\nfunction DirectoryExists(const FileName: TFileName;\n  FollowLink: boolean = true): boolean; {$ifdef HASINLINE} inline; {$endif}\n\n/// redefined here to avoid warning to include \"Windows\" in uses clause\n// and support FileName longer than MAX_PATH\n// - why did Delphi define this slow RTL function as inlined in SysUtils.pas?\nfunction DeleteFile(const aFileName: TFileName): boolean;\n\n/// redefined here to avoid warning to include \"Windows\" in uses clause\n// and support FileName longer than MAX_PATH\n// - why did Delphi define this slow RTL function as inlined in SysUtils.pas?\nfunction RenameFile(const OldName, NewName: TFileName): boolean;\n\n/// redirection to Windows SetFileTime() of a file name from Int64(TFileTime)\n// - if any Int64 is 0, the proper value will be guess from the non-0 values\nfunction FileSetTime(const FileName: TFileName;\n  const Created, Accessed, Written: Int64): boolean;\n\n{$else}\n\n/// faster cross-platform alternative to sysutils homonymous function\n// - will directly use fpstat() so is slightly faster than default FPC RTL\nfunction FileExists(const FileName: TFileName): boolean;\n\n/// redefined from FPC RTL sysutils for consistency\n// - warning: this function replaces ALL SysUtils.FileCreate() overloads,\n// putting aMode as the SECOND parameter, just like with FileOpen()\n// - on POSIX, aRights = 0 will set default octal 644 attributes (-rw-r-r--)\nfunction FileCreate(const aFileName: TFileName; aMode: integer = 0;\n  aRights: integer = 0): THandle;\n\n/// returns how many files could be opened at once on this POSIX system\n// - hard=true is for the maximum allowed limit, false for the current process\n// - returns -1 if the getrlimit() API call failed\nfunction GetFileOpenLimit(hard: boolean = false): integer;\n\n/// changes how many files could be opened at once on this POSIX system\n// - hard=true is for the maximum allowed limit (requires root priviledges),\n// false for the current process\n// - returns the new value set (may not match the expected max value on error)\n// - returns -1 if the getrlimit().setrlimit() API calls failed\n// - for instance, to set the limit of the current process to its highest value:\n// ! SetFileOpenLimit(GetFileOpenLimit(true));\nfunction SetFileOpenLimit(max: integer; hard: boolean = false): integer;\n\n/// read /proc/pid/status to ensure pid is of a real process, not a thread\nfunction IsValidPid(pid: cardinal): boolean;\n\ntype\n  /// Low-level access to the ICU library installed on this system\n  // - \"International Components for Unicode\" (ICU) is an open-source set of\n  // libraries for Unicode support, internationalization and globalization\n  // - used by Unicode_CompareString, Unicode_AnsiToWide, Unicode_WideToAnsi,\n  // Unicode_InPlaceUpper and Unicode_InPlaceLower function from this unit\n  TIcuLibrary = packed object\n  protected\n    icu, icudata, icui18n: pointer;\n    Loaded: boolean;\n    procedure DoLoad(const LibName: TFileName = ''; Version: string = '');\n    procedure Done;\n  public\n    /// Initialize an ICU text converter for a given encoding\n    ucnv_open: function (converterName: PAnsiChar; var err: SizeInt): pointer; cdecl;\n    /// finalize the ICU text converter for a given encoding\n    ucnv_close: procedure (converter: pointer); cdecl;\n    /// customize the ICU text converter substitute char\n    ucnv_setSubstChars: procedure (converter: pointer;\n      subChars: PAnsiChar; len: byte; var err: SizeInt); cdecl;\n    /// enable the ICU text converter fallback\n    ucnv_setFallback: procedure (cnv: pointer; usesFallback: LongBool); cdecl;\n    /// ICU text conversion from UTF-16 to a given encoding\n    ucnv_fromUChars: function (cnv: pointer; dest: PAnsiChar; destCapacity: cardinal;\n      src: PWideChar; srcLength: cardinal; var err: SizeInt): cardinal; cdecl;\n    /// ICU text conversion from a given encoding to UTF-16\n    ucnv_toUChars: function (cnv: pointer; dest: PWideChar; destCapacity: cardinal;\n      src: PAnsiChar; srcLength: cardinal; var err: SizeInt): cardinal; cdecl;\n    /// ICU UTF-16 text conversion to uppercase\n    u_strToUpper: function (dest: PWideChar; destCapacity: cardinal;\n      src: PWideChar; srcLength: cardinal; locale: PAnsiChar;\n      var err: SizeInt): cardinal; cdecl;\n    /// ICU UTF-16 text conversion to lowercase\n    u_strToLower: function (dest: PWideChar; destCapacity: cardinal;\n      src: PWideChar; srcLength: cardinal; locale: PAnsiChar;\n      var err: SizeInt): cardinal; cdecl;\n    /// ICU UTF-16 text comparison\n    u_strCompare: function (s1: PWideChar; length1: cardinal;\n      s2: PWideChar; length2: cardinal; codePointOrder: LongBool): cardinal; cdecl;\n    /// ICU UTF-16 text comparison with options, e.g. for case-insensitivity\n    u_strCaseCompare: function (s1: PWideChar; length1: cardinal;\n      s2: PWideChar; length2: cardinal; options: cardinal;\n      var err: SizeInt): cardinal; cdecl;\n    /// get the ICU data folder\n    u_getDataDirectory: function: PAnsiChar; cdecl;\n    /// set the ICU data folder\n    u_setDataDirectory: procedure(directory: PAnsiChar); cdecl;\n    /// initialize the ICU library\n    u_init: procedure(var status: SizeInt); cdecl;\n    /// try to initialize a specific version of the ICU library\n    // - first finalize any existing loaded instance\n    // - returns true if was successfully loaded and setup\n    function ForceLoad(const LibName: TFileName; const Version: string): boolean;\n    /// returns TRUE if a ICU library is available on this system\n    // - will thread-safely load and initialize it if necessary\n    function IsAvailable: boolean; inline;\n    /// Initialize an ICU text converter for a given codepage\n    // - returns nil if ICU is not available on this system\n    // - wrapper around ucnv_open/ucnv_setSubstChars/ucnv_setFallback calls\n    // - caller should make ucnv_close() once done with the returned instance\n    function ucnv(codepage: cardinal): pointer;\n  end;\n\nvar\n  /// low-level late-binding access to any installed ICU library\n  // - typical use is to check icu.IsAvailable then the proper icu.*() functions\n  // - this unit will make icu.Done in its finalization section\n  icu: TIcuLibrary;\n\n  /// contains the current POSIX kernel revision, as one 24-bit integer\n  // - allow quick comparison mainly for kernel feature checking\n  // - e.g. on Linux, may equal $030d02 for 3.13.2, or $020620 for 2.6.32\n  KernelRevision: cardinal;\n\n\n{$ifdef OSLINUX} { some Linux-specific APIs (e.g. systemd or eventfd) }\n\nconst\n  /// The first passed file descriptor is fd 3\n  SD_LISTEN_FDS_START = 3;\n\n  /// low-level libcurl library file name, depending on the running OS\n  LIBSYSTEMD_PATH = 'libsystemd.so.0';\n\n  ENV_INVOCATION_ID: PAnsiChar = 'INVOCATION_ID';\n\ntype\n  /// low-level systemd parameter to sd.journal_sendv() function\n  TIoVec = record\n    iov_base: PAnsiChar;\n    iov_len: PtrUInt;\n  end;\n\n  /// implements late-binding of the systemd library\n  // - about systemd: see https://www.freedesktop.org/wiki/Software/systemd\n  // and http://0pointer.de/blog/projects/socket-activation.html - to get headers\n  // on debian: `sudo apt install libsystemd-dev && cd /usr/include/systemd`\n  TSystemD = record\n  private\n    systemd: pointer;\n    tested: boolean;\n    procedure DoLoad;\n  public\n    /// returns how many file descriptors have been passed to process\n    // - if result=1 then socket for accepting connection is LISTEN_FDS_START\n    listen_fds: function(unset_environment: integer): integer; cdecl;\n    /// returns 1 if the file descriptor is an AF_UNIX socket of the specified type and path\n    is_socket_unix: function(fd, typr, listening: integer;\n      var path: TFileName; pathLength: PtrUInt): integer; cdecl;\n    /// systemd: submit simple, plain text log entries to the system journal\n    // - priority value can be obtained using integer(LOG_TO_SYSLOG[logLevel])\n    journal_print: function(priority: integer; args: array of const): integer; cdecl;\n    /// systemd: submit array of iov structures instead of the format string to the system journal.\n    // - each structure should reference one field of the entry to submit\n    // - the second argument specifies the number of structures in the array\n    journal_sendv: function(var iov: TIoVec; n: integer): integer; cdecl;\n    /// sends notification to systemd\n    // - see https://www.freedesktop.org/software/systemd/man/notify.html\n    // status notification sample: sd.notify(0, 'READY=1');\n    // watchdog notification: sd.notify(0, 'WATCHDOG=1');\n    notify: function(unset_environment: integer; state: PUtf8Char): integer; cdecl;\n    /// check whether the service manager expects watchdog keep-alive\n    // notifications from a service\n    // - if result > 0 then usec contains the notification interval (app should\n    // notify every usec/2)\n    watchdog_enabled: function(unset_environment: integer; usec: Puint64): integer; cdecl;\n    /// returns true in case the current process was started by systemd\n    // - For systemd v232+\n    function ProcessIsStartedBySystemd: boolean;\n    /// returns TRUE if a systemd library is available\n    // - will thread-safely load and initialize it if necessary\n    function IsAvailable: boolean; inline;\n    /// release the systemd library\n    procedure Done;\n  end;\n\nvar\n  /// low-level late-binding of the systemd library\n  // - typical use is to check sd.IsAvailable then the proper sd.*() functions\n  // - this unit will make sd.Done in its finalization section\n  sd: TSystemD;\n\n/// a wrapper to the eventfd() syscall\n// - returns 0 if the kernel does not support eventfd2 (before 2.6.27) or\n// if the platform is not supported (only validated on Linux x86_64 by now)\n// - returns a file descriptor handle on success, which should be fpclose()\nfunction LinuxEventFD(nonblocking, semaphore: boolean): integer;\n\n/// wrapper to read from a eventfd() file\n// - return 1 and decrement the counter by 1 in semaphore mode\n// - return the current counter value and set it to 0 in non-semaphor mode\n// - may be blocking or not blocking, depending on how LinuxEventFD() was called\n// - return -1 on error\nfunction LinuxEventFDRead(fd: integer): Int64;\n\n/// wrapper to write to a eventfd() file\nprocedure LinuxEventFDWrite(fd: integer; count: QWord);\n\n/// wrapper to wait for a eventfd() file read\n// - return true if was notified for reading, or false on timeout\nfunction LinuxEventFDWait(fd: integer; ms: integer): boolean; inline;\n\n{$endif OSLINUX}\n\nvar\n  /// allow runtime-binding of complex OS API calls\n  // - used e.g. by mormot.core.os.mac.pas to inject its own methods\n  PosixInject: record\n    GetSmbios: function(info: TSmbiosBasicInfo): RawUtf8;\n    GetSmbiosData: function: RawByteString;\n  end;\n\n{$endif OSWINDOWS}\n\n\n{ ****************** Unicode, Time, File, Console, Library process }\n\n{$ifdef OSWINDOWS}\n\ntype\n  /// redefined as our own mormot.core.os type to avoid dependency to Windows\n  // - warning: do not use this type directly, but rather TSynSystemTime as\n  // defined in mormot.core.datetime which is really cross-platform, and has\n  // consistent field order (FPC POSIX/Windows fields do not match!)\n  TSystemTime = Windows.TSystemTime;\n  PSystemTime = Windows.PSystemTime;\n\n  /// system-specific type returned by FileAge(): local 32-bit bitmask on Windows\n  TFileAge = integer;\n\n{$ifdef ISDELPHI}\n\n  /// redefined as our own mormot.core.os type to avoid dependency to Windows\n  TRTLCriticalSection = Windows.TRTLCriticalSection;\n\n  /// defined as in FPC RTL, to avoid dependency to Windows.pas unit\n  // - note that on POSIX, a THandle is a 32-bit integer, but library or\n  // resource handles are likely to map pointers, i.e. up to a 64-bit integer\n  TLibHandle = THandle;\n\n{$endif ISDELPHI}\n\n  /// handle for Slim Reader/Writer (SRW) locks in exclusive mode\n  TOSLightMutex = pointer;\n\n/// a wrapper around FileTimeToLocalFileTime/FileTimeToSystemTime Windows APIs\n// - only used by mormot.lib.static for proper SQlite3 linking on Windows\nprocedure UnixTimeToLocalTime(I64: TUnixTime; out Local: TSystemTime);\n\n/// convert an Unix seconds time to a Win32 64-bit FILETIME value\nprocedure UnixTimeToFileTime(I64: TUnixTime; out FT: TFileTime);\n\n/// convert an Unix milliseconds time to a Win32 64-bit FILETIME value\nprocedure UnixMSTimeToFileTime(I64: TUnixMSTime; out FT: TFileTime);\n\n/// convert a TDateTime to a Win32 64-bit FILETIME value\nprocedure DateTimeToFileTime(dt: TDateTime; out FT: TFileTime);\n\n/// convert a Win32 64-bit FILETIME value into an Unix seconds time\nfunction FileTimeToUnixTime(const FT: TFileTime): TUnixTime;\n  {$ifdef FPC} inline; {$endif}\n\n/// convert a Win32 64-bit FILETIME value into a TDateTime\nfunction FileTimeToDateTime(const FT: TFileTime): TDateTime;\n\n/// convert a Win32 64-bit FILETIME value into an Unix milliseconds time\nfunction FileTimeToUnixMSTime(const FT: TFileTime): TUnixMSTime;\n  {$ifdef FPC} inline; {$endif}\n\nvar\n  // Slim Reader/Writer (SRW) API exclusive mode - fallback to TLightLock on XP\n  InitializeSRWLock,\n  AcquireSRWLockExclusive,\n  ReleaseSRWLockExclusive: procedure(var P: TOSLightMutex); stdcall;\n  TryAcquireSRWLockExclusive: function (var P: TOSLightMutex): BOOL; stdcall;\n\n{$else}\n\nconst\n  /// a cross-platform incorrect THandle value, as defined in Windows unit\n  INVALID_HANDLE_VALUE = THandle(-1);\n\n  /// allow to assign proper signed symbol table name for a libc.so.6 method\n  {$ifdef OSLINUXX64}\n  LIBC_SUFFIX = '@GLIBC_2.2.5';\n  {$else}\n  {$ifdef OSLINUXX86}\n  LIBC_SUFFIX = '@GLIBC_2.0';\n  {$else}\n  LIBC_SUFFIX = ''; // no suffix seems needed outside of Intel/AMD systems\n  {$endif OSLINUXX86}\n  {$endif OSLINUXX64}\n\ntype\n  /// system-specific type returned by FileAge(): UTC 64-bit Epoch on POSIX\n  TFileAge = TUnixTime;\n\n  /// system-specific structure holding a non-recursive mutex\n  TOSLightMutex = TRTLCriticalSection;\n\n{$ifdef OSLINUX}\n  {$define OSPTHREADSLIB}    // direct pthread calls were tested on Linux only\n{$endif OSLINUX}\n{$ifdef OSDARWIN}\n  {$define OSPTHREADSSTATIC} // direct pthread calls from the 'c' library\n{$endif OSDARWIN}\n{$ifdef OSBSD}\n  {$define OSPTHREADSSTATIC} // direct pthread calls from the c library\n{$endif OSBSD}\n\n// some pthread_mutex_*() API defined here for proper inlining\n{$ifdef OSPTHREADSLIB}\nvar\n  {%H-}pthread: pointer; // access to pthread.so e.g. for mormot.lib.static\n  pthread_mutex_lock:    function(mutex: pointer): integer; cdecl;\n  pthread_mutex_trylock: function(mutex: pointer): integer; cdecl;\n  pthread_mutex_unlock:  function(mutex: pointer): integer; cdecl;\n{$endif OSPTHREADSLIB}\n{$ifdef OSPTHREADSSTATIC}\nfunction pthread_mutex_lock(mutex: pointer): integer; cdecl;\nfunction pthread_mutex_trylock(mutex: pointer): integer; cdecl;\nfunction pthread_mutex_unlock(mutex: pointer): integer; cdecl;\n{$endif OSPTHREADSSTATIC}\n\n{$endif OSWINDOWS}\n\n/// raw cross-platform library loading function\n// - alternative to LoadLibrary() and SafeLoadLibrary() Windows API and RTL\n// - on Windows, set the SEM_NOOPENFILEERRORBOX and SEM_FAILCRITICALERRORS flags\n// to avoid unexpected message boxes (which should not happen e.g. on a service)\n// - on Win32, reset the FPU flags after load as required with some libraries\n// - consider inheriting TSynLibrary if you want to map a set of API functions\nfunction LibraryOpen(const LibraryName: TFileName): TLibHandle;\n\n/// raw cross-platform library unloading function\n// - alternative to FreeLibrary() Windows API and FPC RTL\nprocedure LibraryClose(Lib: TLibHandle);\n\n/// raw cross-platform library resolution function, as defined in FPC RTL\n// - alternative to GetProcAddr() Windows API and FPC RTL\nfunction LibraryResolve(Lib: TLibHandle; ProcName: PAnsiChar): pointer;\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// raw cross-platform library resolution error, e.g. after LibraryOpen\nfunction LibraryError: string;\n\n\nconst\n  /// redefined here to avoid dependency to the Windows or SyncObjs units\n  INFINITE = cardinal(-1);\n\n/// initialize a Critical Section (for Lock/UnLock)\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Delphi/Windows, directly call the homonymous Win32 API\nprocedure InitializeCriticalSection(var cs : TRTLCriticalSection);\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// finalize a Critical Section (for Lock/UnLock)\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Delphi/Windows, directly call the homonymous Win32 API\nprocedure DeleteCriticalSection(var cs : TRTLCriticalSection);\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n{$ifdef OSPOSIX}\n\n{$ifndef OSLINUX} // try to stabilize MacOS/BSD pthreads API calls\n  {$define NODIRECTTHREADMANAGER}\n{$endif OSLINUX}\n\n{$ifdef NODIRECTTHREADMANAGER} // try to stabilize MacOS pthreads API calls\nfunction GetCurrentThreadId: TThreadID; inline;\nfunction TryEnterCriticalSection(var cs: TRTLCriticalSection): integer; inline;\nprocedure EnterCriticalSection(var cs: TRTLCriticalSection); inline;\nprocedure LeaveCriticalSection(var cs: TRTLCriticalSection); inline;\n{$else}\n\n/// returns the unique ID of the current running thread\n// - defined in mormot.core.os for inlined FpcCurrentThreadManager call\nvar GetCurrentThreadId: function: TThreadID;\n\n/// enter a Critical Section (Lock)\n// - defined in mormot.core.os for inlined FpcCurrentThreadManager call\nvar EnterCriticalSection: procedure(var cs: TRTLCriticalSection);\n\n/// leave a Critical Section (UnLock)\n// - defined in mormot.core.os for inlined FpcCurrentThreadManager call\nvar LeaveCriticalSection: procedure(var cs: TRTLCriticalSection);\n\n/// try to acquire and lock a Critical Section (Lock)\n// - returns 1 if the lock was acquired, or 0 if the mutex is already locked\n// - defined in mormot.core.os for inlined FpcCurrentThreadManager call\nvar TryEnterCriticalSection: function(var cs: TRTLCriticalSection): integer;\n\n{$endif NODIRECTTHREADMANAGER}\n\n{$endif OSPOSIX}\n\n/// returns TRUE if the supplied mutex has been initialized\n// - will check if the supplied mutex is void (i.e. all filled with 0 bytes)\nfunction IsInitializedCriticalSection(var cs: TRTLCriticalSection): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// on need initialization of a mutex, then enter the lock\n// - if the supplied mutex has been initialized, do nothing\n// - if the supplied mutex is void (i.e. all filled with 0), initialize it\nprocedure InitializeCriticalSectionIfNeededAndEnter(var cs: TRTLCriticalSection);\n  {$ifdef HASINLINEWINAPI}inline;{$endif}\n\n/// on need finalization of a mutex\n// - if the supplied mutex has been initialized, delete it\n// - if the supplied mutex is void (i.e. all filled with 0), do nothing\nprocedure DeleteCriticalSectionIfNeeded(var cs: TRTLCriticalSection);\n\n/// returns the current UTC time as TSystemTime from the OS\n// - under Delphi/Windows, directly call the homonymous Win32 API\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Linux/POSIX, calls clock_gettime(CLOCK_REALTIME_COARSE) if available\n// or fpgettimeofday() on Darwin/MacOS\n// - warning: do not call this function directly, but rather mormot.core.datetime\n// TSynSystemTime.FromNowUtc cross-platform method instead\nprocedure GetSystemTime(out result: TSystemTime);\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// set the current system time as UTC timestamp\n// - we define two functions with diverse signature to circumvent the FPC RTL\n// TSystemTime field order inconsistency\n// - warning: do not call this function directly, but rather mormot.core.datetime\n// TSynSystemTime.ChangeOperatingSystemTime cross-platform method instead\n{$ifdef OSWINDOWS}\nfunction SetSystemTime(const utctime: TSystemTime): boolean;\n{$else}\nfunction SetSystemTime(utctime: TUnixTime): boolean;\n{$endif OSWINDOWS}\n\n/// returns the current Local time as TSystemTime from the OS\n// - under Delphi/Windows, directly call the homonymous Win32 API\n// - redefined in mormot.core.os to avoid dependency to the Windows unit\n// - under Linux/POSIX, calls clock_gettime(CLOCK_REALTIME_COARSE) if available\n// or fpgettimeofday() on Darwin/MacOS, with FPC RTL TZSeconds adjustment (so\n// will be fixed for the whole process lifetime and won't change at daylight)\n// - warning: do not call this function directly, but rather mormot.core.datetime\n// TSynSystemTime.FromNowLocal cross-platform method instead\nprocedure GetLocalTime(out result: TSystemTime);\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// compatibility function, wrapping Win32 API file truncate at current position\nprocedure SetEndOfFile(F: THandle);\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// compatibility function, wrapping Win32 API file flush to disk\nprocedure FlushFileBuffers(F: THandle);\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// compatibility function, wrapping Win32 API last error code\nfunction GetLastError: integer;\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// check if the last error reporting by the system is a file access violation\n// - call GetLastError is no ErrorCode is supplied\nfunction IsSharedViolation(ErrorCode: integer = 0): boolean;\n\n/// compatibility function, wrapping Win32 API last error code\nprocedure SetLastError(error: integer);\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// returns a given error code as plain text\n// - redirects to WinErrorText(error, nil) on Windows, or StrError() on POSIX\nfunction GetErrorText(error: integer): RawUtf8;\n  {$ifdef HASINLINE} inline; {$endif}\n\n{$ifdef OSWINDOWS}\n\n/// return the error message of a given Module\n// - first try WinErrorConstant() for system error constants (if ModuleName=nil),\n// then call FormatMessage() and override the RTL function to force the\n// ENGLISH_LANGID flag first\n// - if ModuleName does support this Code, will try it as system error\n// - replace SysErrorMessagePerModule() and SysErrorMessage() from mORMot 1\nfunction WinErrorText(Code: cardinal; ModuleName: PChar): RawUtf8;\n\n/// return the best known ERROR_* system error message constant texts\n// - without the 'ERROR_' prefix\n// - as used by WinErrorText()\nfunction WinErrorConstant(Code: cardinal): PUtf8Char;\n\n/// raise an EOSException from the last system error using WinErrorText()\nprocedure RaiseLastError(const Context: shortstring;\n  RaisedException: ExceptClass = nil);\n\n/// raise an Exception from the last module error using WinErrorText()\nprocedure RaiseLastModuleError(ModuleName: PChar; ModuleException: ExceptClass);\n\n{$endif OSWINDOWS}\n\n/// compatibility function, wrapping Win32 API function\n// - returns the current main Window handle on Windows, or 0 on POSIX/Linux\nfunction GetDesktopWindow: PtrInt;\n  {$ifdef OSWINDOWS} stdcall; {$else} inline; {$endif}\n\n/// returns the curent system code page for AnsiString types\n// - as used to initialize CurrentAnsiConvert in mormot.core.unicode unit\n// - calls GetACP() Win32 API value on Delphi, or DefaultSystemCodePage on FPC -\n// i.e. GetSystemCodePage() on POSIX (likely to be UTF-8) or the value used\n// by the LCL for its \"string\" types (also typically UTF-8 even on Windows)\nfunction Unicode_CodePage: integer;\n  {$ifdef FPC} inline; {$endif}\n\n/// compatibility function, wrapping CompareStringW() Win32 API text comparison\n// - returns 1 if PW1>PW2, 2 if PW1=PW2, 3 if PW1<PW2 - so substract 2 to have\n// -1,0,1 as regular StrCompW/StrICompW comparison function result\n// - will compute StrLen(PW1/PW2) if L1 or L2 < 0\n// - on POSIX, use the ICU library, or fallback to FPC RTL widestringmanager\n// with a temporary variable - you would need to include cwstring unit\n// - in practice, is seldom called, unless our proprietary WIN32CASE collation\n// is used in mormot.db.raw.sqlite3\n// - consider Utf8ILCompReference() from mormot.core.unicode.pas for an\n// operating-system-independent Unicode 10.0 comparison function\nfunction Unicode_CompareString(\n  PW1, PW2: PWideChar; L1, L2: PtrInt; IgnoreCase: boolean): integer;\n\n/// compatibility function, wrapping MultiByteToWideChar() Win32 API call\n// - returns the number of WideChar written into W^ destination buffer\n// - on POSIX, use the ICU library, or fallback to FPC RTL widestringmanager\n// with a temporary variable - you would need to include cwstring unit\n// - raw function called by TSynAnsiConvert.AnsiBufferToUnicode from\n// mormot.core.unicode unit\nfunction Unicode_AnsiToWide(\n  A: PAnsiChar; W: PWideChar; LA, LW, CodePage: PtrInt): integer;\n\n/// compatibility function, wrapping WideCharToMultiByte() Win32 API call\n// - returns the number of AnsiChar written into A^ destination buffer\n// - on POSIX, use the ICU library, or fallback to FPC RTL widestringmanager\n// with a temporary variable - you would need to include cwstring unit\n// - raw function called by TSynAnsiConvert.UnicodeBufferToAnsi from\n// mormot.core.unicode unit\nfunction Unicode_WideToAnsi(\n  W: PWideChar; A: PAnsiChar; LW, LA, CodePage: PtrInt): integer;\n\n/// conversion of some UTF-16 buffer into a temporary Ansi ShortString\n// - used when mormot.core.unicode is an overkill, e.g. TCrtSocket.SockSend()\nprocedure Unicode_WideToShort(\n  W: PWideChar; LW, CodePage: PtrInt; var res: ShortString);\n\n/// compatibility function, wrapping Win32 API CharUpperBuffW()\n// - on POSIX, use the ICU library, or fallback to 'a'..'z' conversion only\n// - raw function called by UpperCaseUnicode() from mormot.core.unicode unit\nfunction Unicode_InPlaceUpper(W: PWideChar; WLen: integer): integer;\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// compatibility function, wrapping Win32 API CharLowerBuffW()\n// - on POSIX, use the ICU library, or fallback to 'A'..'Z' conversion only\n// - raw function called by LowerCaseUnicode() from mormot.core.unicode unit\nfunction Unicode_InPlaceLower(W: PWideChar; WLen: integer): integer;\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// returns a system-wide current monotonic timestamp as milliseconds\n// - will use the corresponding native API function under Vista+, or will be\n// redirected to a custom wrapper function for older Windows versions (XP)\n// to avoid the 32-bit overflow/wrapping issue of GetTickCount\n// - warning: FPC's SysUtils.GetTickCount64 or TThread.GetTickCount64 don't\n// handle properly 49 days wrapping under XP -> always use this safe version\n// - warning: FPC's SysUtils.GetTickCount64 may call fpgettimeofday() e.g.\n// on Darwin, which is not monotonic -> always use this more coherent version\n// - on POSIX, will call (via vDSO) the very fast CLOCK_MONOTONIC_COARSE if\n// available, or the low-level mach_absolute_time() monotonic Darwin API\n// - do not expect exact millisecond resolution - steps may rather be e.g.\n// within the 15-16 ms range on Windows, and 4-5 ms range on Linux\n{$ifdef OSWINDOWS}\nvar\n  GetTickCount64: function: Int64; stdcall;\n{$else}\nfunction GetTickCount64: Int64;\n{$endif OSWINDOWS}\n\n/// returns how many seconds the system was up, accouting for time when\n// the computer is asleep\n// - on Windows, computes GetTickCount64 div 1000\n// - on Linux/BSD, will use CLOCK_BOOTTIME/CLOCK_UPTIME clock\n// - on MacOS, will use mach_continuous_time() API\nfunction GetUptimeSec: cardinal;\n\n/// returns the current UTC time\n// - wrap UnixMSTimeUtcFast, so use e.g. clock_gettime(CLOCK_REALTIME_COARSE)\n// under Linux, or GetSystemTimeAsFileTime under Windows\nfunction NowUtc: TDateTime;\n\n/// returns the current UTC date/time as a second-based c-encoded time\n// - i.e. current number of seconds elapsed since Unix epoch 1/1/1970\n// - use e.g. fast clock_gettime(CLOCK_REALTIME_COARSE) under Linux,\n// or GetSystemTimeAsFileTime under Windows\n// - returns a 64-bit unsigned value, so is \"Year2038bug\" free\nfunction UnixTimeUtc: TUnixTime;\n\n/// returns the current UTC date/time as a millisecond-based c-encoded time\n// - i.e. current number of milliseconds elapsed since Unix epoch 1/1/1970\n// - will use e.g. fast clock_gettime(CLOCK_REALTIME_COARSE) under Linux,\n// or GetSystemTimePreciseAsFileTime under Windows 8 and later\n// - on Windows, is slightly more accurate, but slower than UnixMSTimeUtcFast\nfunction UnixMSTimeUtc: TUnixMSTime;\n\n/// returns the current UTC date/time as a millisecond-based c-encoded time\n// - under Linux/POSIX, is the very same than UnixMSTimeUtc (inlined call)\n// - under Windows 8+, will call GetSystemTimeAsFileTime instead of\n// GetSystemTimePreciseAsFileTime, which has higher precision, but is slower\n// - prefer it under Windows, if a dozen of ms resolution is enough for your task\nfunction UnixMSTimeUtcFast: TUnixMSTime;\n  {$ifdef OSPOSIX} inline; {$endif}\n\nconst\n  /// number of days offset between the Unix Epoch (1970) and TDateTime origin\n  UnixDelta = 25569;\n  /// number of Windows TFileTime ticks (100ns) from year 1601 to 1970\n  UnixFileTimeDelta = 116444736000000000;\n\n/// the number of minutes bias in respect to UTC/GMT date/time\n// - as retrieved via -GetLocalTimeOffset() at startup, so may not be accurate\n// after a time shift during the process execution - but any long-running\n// process (like a service) should use UTC timestamps only\nvar\n  TimeZoneLocalBias: integer;\n\n{$ifndef NOEXCEPTIONINTERCEPT}\n\ntype\n  /// calling context when intercepting exceptions\n  // - used e.g. for TSynLogExceptionToStr or RawExceptionIntercept() handlers\n  {$ifdef USERECORDWITHMETHODS}\n  TSynLogExceptionContext = record\n  {$else}\n  TSynLogExceptionContext = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// the raised exception class\n    EClass: ExceptClass;\n    /// the Delphi Exception instance\n    // - may be nil for external/OS exceptions\n    EInstance: Exception;\n    /// the OS-level exception code\n    // - could be $0EEDFAE0 of $0EEDFADE for Delphi-generated exceptions\n    ECode: DWord;\n    /// = FPC's RaiseProc() FrameCount if EStack is Frame: PCodePointer\n    EStackCount: integer;\n    /// the address where the exception occurred\n    EAddr: PtrUInt;\n    /// the optional stack trace\n    EStack: PPtrUIntArray;\n    /// timestamp of this exception, as number of seconds since UNIX Epoch\n    // - UnixTimeUtc is faster than NowUtc or GetSystemTime\n    // - use UnixTimeToDateTime() to convert it into a regular TDateTime\n    ETimestamp: TUnixTime;\n    /// the logging level corresponding to this exception\n    // - may be either sllException or sllExceptionOS\n    ELevel: TSynLogLevel;\n    /// retrieve some extended information about a given Exception\n    // - on Windows, recognize most DotNet CLR Exception Names\n    function AdditionalInfo(out ExceptionNames: TPUtf8CharDynArray): cardinal;\n  end;\n\n  /// the global function signature expected by RawExceptionIntercept()\n  // - assigned e.g. to SynLogException() in mormot.core.log.pas\n  TOnRawLogException = procedure(const Ctxt: TSynLogExceptionContext);\n\n/// setup Exception interception for the whole process\n// - call RawExceptionIntercept(nil) to disable custom exception handling\nprocedure RawExceptionIntercept(const Handler: TOnRawLogException);\n\n{$endif NOEXCEPTIONINTERCEPT}\n\n/// returns a high-resolution system-wide monotonic timestamp as microseconds\n// - under Linux/POSIX, has true microseconds resolution, calling e.g.\n// CLOCK_MONOTONIC on Linux/BSD\n// - under Windows, calls QueryPerformanceCounter / QueryPerformanceFrequency\nprocedure QueryPerformanceMicroSeconds(out Value: Int64);\n\n/// cross-platform check if the supplied THandle is not invalid\nfunction ValidHandle(Handle: THandle): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// check for unsafe '..' '/xxx' 'c:xxx' '~/xxx' or '\\\\' patterns in a path\nfunction SafePathName(const Path: TFileName): boolean;\n\n/// check for unsafe '..' '/xxx' 'c:xxx' '~/xxx' or '\\\\' patterns in a RawUtf8 path\nfunction SafePathNameU(const Path: RawUtf8): boolean;\n\n/// check for unsafe '..' '/xxx' 'c:xxx' '~/xxx' or '\\\\' patterns in a filename\nfunction SafeFileName(const FileName: TFileName): boolean;\n\n/// check for unsafe '..' '/xxx' 'c:xxx' '~/xxx' or '\\\\' patterns in a RawUtf8 filename\nfunction SafeFileNameU(const FileName: RawUtf8): boolean;\n\n/// ensure all \\ / path delimiters are normalized into the current OS expectation\n// - i.e. normalize file name to use '\\' on Windows, or '/' on POSIX\n// - see MakePath() from mormot.core.text.pas to concatenate path items\nfunction NormalizeFileName(const FileName: TFileName): TFileName;\n\n/// add some \" before and after if FileName has some space within\n// - could be used when generating command line parameters\nfunction QuoteFileName(const FileName: TFileName): TFileName;\n\n/// faster cross-platform alternative to sysutils homonymous function\n// - on Windows, just redirect to WindowsFileTimeToDateTime() since FileDate\n// is already expected to be in local time from FileAge()\n// - on POSIX, FileDate is a 64-bit UTC value as returned from OS stat API, and\n// will be converted into a local TDateTime\n// - note: FPC FileAge(TDateTime) is wrong and truncates 1-2 seconds on Windows\nfunction FileDateToDateTime(const FileDate: TFileAge): TDateTime;\n  {$ifdef HASINLINE}{$ifdef OSWINDOWS}inline;{$endif}{$endif}\n\n/// get a file date and time, from its name\n// - returns 0 if file doesn't exist\n// - returns the local file age, encoded as TDateTime\n// - under Windows, will use GetFileAttributesEx fast API\nfunction FileAgeToDateTime(const FileName: TFileName): TDateTime;\n\n/// get a file date and time, from its name, as seconds since Unix Epoch\n// - returns 0 if file (or folder if AllowDir is true) doesn't exist\n// - returns the system API file age (not converted local), encoded as TUnixTime\n// - under Windows, will use GetFileAttributesEx and FileTimeToUnixTime\n// - under POSIX, will call directly the stat syscall\n// - faster than FileAgeToDateTime() since don't convert to local time\nfunction FileAgeToUnixTimeUtc(const FileName: TFileName;\n  AllowDir: boolean = false): TUnixTime;\n\n/// get the date and time of one file into a Windows File 32-bit TimeStamp\n// - this cross-system function is used e.g. by mormot.core.zip which expects\n// Windows TimeStamps in its headers\nfunction FileAgeToWindowsTime(const FileName: TFileName): integer;\n\n/// copy the date of one file to another\n// - FileSetDate(THandle, Age) is not implemented on POSIX: filename is needed\nfunction FileSetDateFrom(const Dest: TFileName; SourceHandle: THandle): boolean; overload;\n\n/// copy the date of one file to another\n// - FileSetDate(THandle, Age) is not implemented on POSIX: filename is needed\nfunction FileSetDateFrom(const Dest, Source: TFileName): boolean; overload;\n\n/// copy the date of one file from a Windows File 32-bit TimeStamp\n// - this cross-system function is used e.g. by mormot.core.zip which expects\n// Windows TimeStamps in its headers\n// - FileSetDate(THandle, Age) is not implemented on POSIX: filename is needed\nfunction FileSetDateFromWindowsTime(const Dest: TFileName; WinTime: integer): boolean;\n\n/// set the file date/time from a supplied UTC TUnixTime value\n// - avoid any temporary conversion to local time\n// - Time may come from FileAgeToUnixTimeUtc()\nfunction FileSetDateFromUnixUtc(const Dest: TFileName; Time: TUnixTime): boolean;\n\n/// convert a Windows API File 32-bit TimeStamp into a regular TDateTime\n// - returns 0 if the conversion failed\n// - used e.g. by FileSetDateFromWindowsTime() on POSIX\nfunction WindowsFileTimeToDateTime(WinTime: integer): TDateTime;\n\n/// convert a Windows API File 64-bit TimeStamp into a regular TUnixMSTime\n// - i.e. a FILETIME value as returned by GetFileTime() Win32 API\n// - some binary formats (e.g. ISO 9660 or LDAP) have such FILETIME fields\nfunction WindowsFileTime64ToUnixMSTime(WinTime: QWord): TUnixMSTime;\n\n/// low-level conversion of a TDateTime into a Windows File 32-bit TimeStamp\n// - returns 0 if the conversion failed\nfunction DateTimeToWindowsFileTime(DateTime: TDateTime): integer;\n\n/// check if a file exists and can be written\n// - on POSIX, call fpaccess() and check for the W_OK attribute\n// - on Windows, supports aFileName longer than MAX_PATH\nfunction FileIsWritable(const FileName: TFileName): boolean;\n\n/// reduce the visibility of a given file, and set its read/write attributes\n// - on POSIX, change attributes for the the owner, and reset group/world flags\n// so that it is accessible by the current user only; under POSIX, there is\n// no \"hidden\" file attribute, but you should define a FileName starting by '.'\n// - on Windows, will set the \"hidden\" file attribue\nprocedure FileSetHidden(const FileName: TFileName; ReadOnly: boolean);\n\n/// set the \"sticky bit\" on a file or directory\n// - on POSIX, a \"sticky\" folder will ensure that its nested files will be\n// deleted by their owner; and a \"sticky\" file will ensure e.g. that no\n// /var/tmp file is deleted by systemd during its clean up phases\n// - on Windows, will set the Hidden and System file attributes\nprocedure FileSetSticky(const FileName: TFileName);\n\n/// get a file size, from its name\n// - returns 0 if file doesn't exist, or is a directory\n// - under Windows, will use GetFileAttributesEx fast API\n// - on POSIX, will use efficient fpStat() single call but not FileOpen/FileClose\nfunction FileSize(const FileName: TFileName): Int64; overload;\n\n/// get a file size, from its handle\n// - returns 0 if file doesn't exist\n// - under Windows, will use the GetFileSizeEx fast API\n// - on POSIX, will use efficient FpFStat() single call and no file seek\nfunction FileSize(F: THandle): Int64; overload;\n\n/// FileSeek() overloaded function, working with huge files\n// - Delphi FileSeek() is buggy -> use this function to safely access files\n// bigger than 2 GB (thanks to sanyin for the report)\nfunction FileSeek64(Handle: THandle; const Offset: Int64;\n  Origin: cardinal = soFromBeginning): Int64;\n\n/// get a file size and its UTC Unix timestamp in milliseconds resolution\n// - return false if FileName was not found\n// - return true and set FileSize and FileTimestampUtc if found - note that\n// no local time conversion is done, so timestamp won't match FileAge()\n// - use a single Operating System call, so is faster than FileSize + FileAge\nfunction FileInfoByName(const FileName: TFileName; out FileSize: Int64;\n  out FileTimestampUtc: TUnixMSTime): boolean;\n\n/// get low-level file information, in a cross-platform way\n// - returns true on success\n// - you can specify nil for any returned value if you don't need\n// - here file write/creation time are given as TUnixMSTime values, for better\n// cross-platform process - note that FileCreateDateTime may not be supported\n// by most Linux file systems, so the oldest timestamp available is returned\n// as failover on such systems (probably the latest file metadata writing)\nfunction FileInfoByHandle(aFileHandle: THandle; FileId, FileSize: PInt64;\n  LastWriteAccess, FileCreateDateTime: PUnixMSTime): boolean;\n\n/// check if a given file is likely to be an executable\n// - will check the DOS/WinPE executable header in its first bytes on Windows\n// - will call fpStat() on POSIX to check the File and Executable bits\nfunction FileIsExecutable(const FileName: TFileName): boolean;\n\n/// compute the size of a directory's files, optionally with nested folders\n// - basic implementation using FindFirst/FindNext so won't be the fastest\n// available, nor fully accurate when files are actually (hard) links\nfunction DirectorySize(const FileName: TFileName; Recursive: boolean = false;\n  const Mask: TFileName = FILES_ALL): Int64;\n\n/// copy one file to another, similar to the Windows API\nfunction CopyFile(const Source, Target: TFileName;\n  FailIfExists: boolean): boolean;\n\n/// prompt the user for an error message to notify an unexpected issue\n// - in practice, text encoding is expected to be plain 7-bit ASCII\n// - on Windows, will use Writeln() on a (newly allocated if needed) console\n// - on POSIX, will use Writeln(StdErr)\nprocedure DisplayFatalError(const title, msg: RawUtf8);\n\n/// prompt the user for an error message to notify an unexpected issue\n// - redirect to DisplayFatalError() without any title\n// - expects the regular Format() layout with %s %d - not the FormatUtf8() %\nprocedure DisplayError(const fmt: string; const args: array of const);\n\n/// get a file date and time, from a FindFirst/FindNext search\n// - the returned timestamp is in local time, not UTC\n// - this method would use the F.Timestamp field available since Delphi XE2\nfunction SearchRecToDateTime(const F: TSearchRec): TDateTime;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// get a file UTC date and time, from a FindFirst/FindNext search\n// - SearchRecToDateTime(), SearchRecToWindowsTime() and F.TimeStamp, which have\n// local time and require a conversion, may appear less useful on server side\n// - is implemented as a wrapper around SearchRecToUnixTimeUtc()\nfunction SearchRecToDateTimeUtc(const F: TSearchRec): TDateTime;\n\n/// get a file UTC date and time, from a FindFirst/FindNext search, as Unix time\n// - SearchRecToDateTime(), SearchRecToWindowsTime() and F.TimeStamp, which have\n// local time and require a conversion, may appear less useful on server side\nfunction SearchRecToUnixTimeUtc(const F: TSearchRec): TUnixTime;\n  {$ifdef OSPOSIX}inline;{$endif}\n\n/// get a file date and time, from a FindFirst/FindNext search, as Windows time\n// - this cross-system function is used e.g. by mormot.core.zip which expects\n// Windows TimeStamps in its headers\nfunction SearchRecToWindowsTime(const F: TSearchRec): integer;\n\n/// check if a FindFirst/FindNext found instance is actually a file\nfunction SearchRecValidFile(const F: TSearchRec): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// check if a FindFirst/FindNext found instance is actually a folder\nfunction SearchRecValidFolder(const F: TSearchRec): boolean;\n  {$ifdef HASINLINE}inline;{$endif}\n\ntype\n  /// FPC TFileStream miss a Create(aHandle) constructor like Delphi\n  TFileStreamFromHandle = class(THandleStream)\n  protected\n    fDontReleaseHandle: boolean;\n  public\n    /// explictely close the handle if needed\n    destructor Destroy; override;\n    /// Destroy calls FileClose(Handle) unless this property is true\n    property DontReleaseHandle: boolean\n      read fDontReleaseHandle write fDontReleaseHandle;\n  end;\n\n  /// a TFileStream replacement which supports FileName longer than MAX_PATH,\n  // and a proper Create(aHandle) constructor in FPC\n  TFileStreamEx = class(TFileStreamFromHandle)\n  protected\n    fFileName : TFileName;\n    function GetSize: Int64; override; // faster (1 API call instead of 3)\n  public\n    /// open or create the file from its name, depending on the supplied Mode\n    // - Mode is typically fmCreate / fmOpenReadShared\n    constructor Create(const aFileName: TFileName; Mode: cardinal);\n    /// can use this class from a low-level file OS handle\n    constructor CreateFromHandle(const aFileName: TFileName; aHandle: THandle);\n    /// open for writing or create a non-existing file from its name\n    // - use fmCreate if aFileName does not exists, or fmOpenWrite otherwise\n    constructor CreateWrite(const aFileName: TFileName);\n    /// the file name assigned to this class constructor\n    property FileName : TFileName\n      read fFilename;\n  end;\n\n  /// file stream which ignores I/O write errors\n  // - in case disk space is exhausted, TFileStreamNoWriteError.WriteBuffer\n  // won't throw any exception, so application will continue to work\n  // - used e.g. by TSynLog to let the application continue with no exception,\n  // even in case of a disk/partition full of logs\n  TFileStreamNoWriteError = class(TFileStreamEx)\n  public\n    /// open for writing, potentially with alternate unlocked file names\n    // - use fmCreate if aFileName does not exists, or fmOpenWrite otherwise\n    // - on error, will try up to aAliases alternate '<filename>-locked<#>.<ext>'\n    constructor CreateAndRenameIfLocked(\n      var aFileName: TFileName; aAliases: integer = 3);\n    /// this overriden function returns Count, as if it was always successful\n    function Write(const Buffer; Count: Longint): Longint; override;\n  end;\n\n/// a wrapper around FileRead() to ensure a whole memory buffer is retrieved\n// - expects Size to be up to 2GB (seems like a big enough memory buffer)\n// - on Windows, will read by 16MB chunks to avoid ERROR_NO_SYSTEM_RESOURCES\n// - will call FileRead() and retry up to Size bytes are filled in the buffer\n// - return true if all memory buffer has been read, or false on error\nfunction FileReadAll(F: THandle; Buffer: pointer; Size: PtrInt): boolean;\n\n/// a wrapper around FileWrite() to ensure a whole memory buffer is retrieved\n// - will call FileWrite() and retry up to Size bytes are written from the buffer\n// - return true if all memory buffer has been written, or false on error\nfunction FileWriteAll(F: THandle; Buffer: pointer; Size: PtrInt): boolean;\n\n/// overloaded function optimized for one pass reading of a (huge) file\n// - will use e.g. the FILE_FLAG_SEQUENTIAL_SCAN flag under Windows, as stated\n// by http://blogs.msdn.com/b/oldnewthing/archive/2012/01/20/10258690.aspx\n// - on POSIX, calls fpOpen(pointer(FileName),O_RDONLY) with no fpFlock() call\n// - is used e.g. by StringFromFile() or HashFile() functions\n// - note: you could better use FileReadAll() to retrieve a whole data buffer\nfunction FileOpenSequentialRead(const FileName: TFileName): integer;\n\n/// returns a TFileStreamFromHandle optimized for one pass file reading\n// - will use FileOpenSequentialRead(), i.e. FILE_FLAG_SEQUENTIAL_SCAN on Windows\n// - on POSIX, calls fpOpen(pointer(FileName),O_RDONLY) with no fpFlock() call\n// - is used e.g. by TRestOrmServerFullMemory and TAlgoCompress\nfunction FileStreamSequentialRead(const FileName: TFileName): THandleStream;\n\n/// try to open the file from its name, as fmOpenReadShared\n// - on Windows, calls CreateFileW(aFileName,GENERIC_READ) then CloseHandle\n// - on POSIX, calls fpOpen(pointer(aFileName),O_RDONLY) with no fpFlock() call\nfunction FileIsReadable(const aFileName: TFileName): boolean;\n\n/// copy all Source content into Dest from current position\n// - on Delphi, Dest.CopyFrom(Source, 0) uses GetSize and ReadBuffer which is\n// not compatible e.g. with TAesPkcs7Reader padding - and has a small buffer\n// - returns the number of bytes copied from Source to Dest\nfunction StreamCopyUntilEnd(Source, Dest: TStream): Int64;\n\n/// read a File content into a string\n// - content can be binary or text\n// - returns '' if file was not found or any read error occurred\n// - wil use GetFileSize() API by default, unless HasNoSize is defined,\n// and read will be done using a buffer (required e.g. for POSIX char files)\n// - uses RawByteString for byte storage, whatever the codepage is\nfunction StringFromFile(const FileName: TFileName;\n  HasNoSize: boolean = false): RawByteString;\n\n/// read a File content from a list of potential files\n// - returns '' if no file was found, or the first matching FileName[] content\nfunction StringFromFirstFile(const FileName: array of TFileName): RawByteString;\n\n/// read all Files content from a list of file names\n// - returns '' if no FileName[] file was found, or the read content\nfunction StringFromFiles(const FileName: array of TFileName): TRawByteStringDynArray;\n\n/// read all Files content from a list of folders names\n// - returns the content of every file contained in the supplied Folders[]\n// - with optionally the FileNames[] corresponding to each result[] content\nfunction StringFromFolders(const Folders: array of TFileName;\n  const Mask: TFileName = FILES_ALL;\n  FileNames: PFileNameDynArray = nil): TRawByteStringDynArray;\n\n/// create a File from a string content\n// - uses RawByteString for byte storage, whatever the codepage is\n// - can optionaly force flush all write buffers to disk\nfunction FileFromString(const Content: RawByteString; const FileName: TFileName;\n  FlushOnDisk: boolean = false): boolean;\n\n/// create a File from a memory buffer content\nfunction FileFromBuffer(Buf: pointer; Len: PtrInt; const FileName: TFileName): boolean;\n\n/// create or append a string content to a File\n// - can optionally rotate the file to a FileName+'.bak'  over a specific size\nfunction AppendToFile(const Content: RawUtf8; const FileName: TFileName;\n  BackupOverMaxSize: Int64 = 0): boolean;\n\n/// compute an unique temporary file name\n// - following 'exename_123.tmp' pattern, in the system temporary folder\nfunction TemporaryFileName: TFileName;\n\n/// extract a path from a file name like ExtractFilePath function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractPath(const FileName: TFileName): TFileName;\n\n/// extract a path from a RawUtf8 file name like ExtractFilePath function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractPathU(const FileName: RawUtf8): RawUtf8;\n\n/// extract a name from a file name like ExtractFileName function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractName(const FileName: TFileName): TFileName;\n\n/// extract a name from a file name like ExtractFileName function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractNameU(const FileName: RawUtf8): RawUtf8;\n\n/// extract an extension from a file name like ExtractFileExt function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractExt(const FileName: TFileName; WithoutDot: boolean = false): TFileName;\n\n// defined here for proper ExtractExtP() inlining\nfunction GetLastDelimU(const FileName: RawUtf8; OtherDelim: AnsiChar): PtrInt;\n\n/// extract an extension from a file name like ExtractFileExt function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractExtU(const FileName: RawUtf8; WithoutDot: boolean = false): RawUtf8;\n\n/// extract an extension from a file name like ExtractFileExt function\n// - but cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction ExtractExtP(const FileName: RawUtf8; WithoutDot: boolean = false): PUtf8Char;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// compute the file name, including its path if supplied, but without its extension\n// - e.g. GetFileNameWithoutExt('/var/toto.ext') = '/var/toto'\n// - may optionally return the extracted extension, as '.ext'\n// - will be cross-platform, i.e. detect both '\\' and '/' on all platforms\nfunction GetFileNameWithoutExt(const FileName: TFileName;\n  Extension: PFileName = nil): TFileName;\n\n/// extract the file name without any path nor extension, as UTF-8\n// - e.g. GetFileNameWithoutExt('/var/toto.ext') = 'toto'\n// - used e.g. to compute Executable.ProgramName\nfunction GetFileNameWithoutExtOrPath(const FileName: TFileName): RawUtf8;\n\n/// compare two \"array of TFileName\" elements, grouped by file extension\n// - i.e. with no case sensitivity on Windows\n// - the expected string type is the RTL string, i.e. TFileName\n// - calls internally GetFileNameWithoutExt() and AnsiCompareFileName()\nfunction SortDynArrayFileName(const A, B): integer;\n\n{$ifdef ISDELPHI20062007}\n/// compatibility function defined to avoid hints on buggy Delphi 2006/2007\nfunction AnsiCompareFileName(const S1, S2 : TFileName): integer;\n{$endif ISDELPHI20062007}\n\n/// creates a directory if not already existing\n// - returns the full expanded directory name, including trailing path delimiter\n// - returns '' on error, unless RaiseExceptionOnCreationFailure is set\nfunction EnsureDirectoryExists(const Directory: TFileName;\n  RaiseExceptionOnCreationFailure: ExceptionClass = nil): TFileName;\n\n/// just a wrapper around EnsureDirectoryExists(NormalizeFileName(Directory))\nfunction NormalizeDirectoryExists(const Directory: TFileName;\n  RaiseExceptionOnCreationFailure: ExceptionClass = nil): TFileName;\n\n/// delete the content of a specified directory\n// - only one level of file is deleted within the folder: no recursive deletion\n// is processed by this function (for safety)\n// - if DeleteOnlyFilesNotDirectory is TRUE, it won't remove the folder itself,\n// but just the files found in it\nfunction DirectoryDelete(const Directory: TFileName;\n  const Mask: TFileName = FILES_ALL; DeleteOnlyFilesNotDirectory: boolean = false;\n  DeletedCount: PInteger = nil): boolean;\n\n/// delete the files older than a given age in a specified directory\n// - for instance, to delete all files older than one day:\n// ! DirectoryDeleteOlderFiles(FolderName, 1);\n// - only one level of file is deleted within the folder: no recursive deletion\n// is processed by this function, unless Recursive is TRUE\n// - if Recursive=true, caller should set TotalSize^=0 to have an accurate value\n// - return false if any deprecated DeleteFile() did fail during the process\nfunction DirectoryDeleteOlderFiles(const Directory: TFileName;\n  TimePeriod: TDateTime; const Mask: TFileName = FILES_ALL;\n  Recursive: boolean = false; TotalSize: PInt64 = nil): boolean;\n\ntype\n  /// defines how IsDirectoryWritable() verifies a folder\n  // - on Win32 Vista+, idwExcludeWinUac will check IsUacVirtualFolder()\n  // - on Windows, idwExcludeWinSys will check IsSystemFolder()\n  // - on Windows, idwTryWinExeFile will try to generate a 'xxxxx.exe' file\n  // - idwWriteSomeContent will also try to write some bytes into the file\n  TIsDirectoryWritable = set of (\n    idwExcludeWinUac,\n    idwExcludeWinSys,\n    idwTryWinExeFile,\n    idwWriteSomeContent);\n\n/// check if the directory is writable for the current user\n// - try to write and delete a void file with a random name in this folder\nfunction IsDirectoryWritable(const Directory: TFileName;\n  Flags: TIsDirectoryWritable = []): boolean;\n\ntype\n  /// cross-platform memory mapping of a file content\n  {$ifdef USERECORDWITHMETHODS}\n  TMemoryMap = record\n  {$else}\n  TMemoryMap = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fBuf: PAnsiChar;\n    fBufSize: PtrUInt;\n    fFile: THandle;\n    {$ifdef OSWINDOWS}\n    fMap: THandle;\n    {$endif OSWINDOWS}\n    fFileSize: Int64;\n    fFileLocal, fLoadedNotMapped: boolean;\n    function DoMap(aCustomOffset: Int64): boolean;\n    procedure DoUnMap;\n  public\n    /// map the corresponding file handle\n    // - if aCustomSize and aCustomOffset are specified, the corresponding\n    // map view if created (by default, will map whole file)\n    function Map(aFile: THandle; aCustomSize: PtrUInt = 0;\n      aCustomOffset: Int64 = 0; aFileOwned: boolean = false;\n      aFileSize: Int64 = -1): boolean; overload;\n    /// map the file specified by its name\n    // - file will be closed when UnMap will be called\n    function Map(const aFileName: TFileName): boolean; overload;\n    /// set a fixed buffer for the content\n    // - emulates memory-mapping over an existing buffer\n    procedure Map(aBuffer: pointer; aBufferSize: PtrUInt); overload;\n    /// unmap the file\n    procedure UnMap;\n    /// retrieve the memory buffer mapped to the file content\n    property Buffer: PAnsiChar\n      read fBuf;\n    /// retrieve the buffer size\n    property Size: PtrUInt\n      read fBufSize;\n    /// retrieve the mapped file size\n    property FileSize: Int64\n      read fFileSize;\n    /// access to the low-level associated File handle (if any)\n    property FileHandle: THandle\n      read fFile;\n  end;\n\n  /// a TStream created from a file content, using fast memory mapping\n  TSynMemoryStreamMapped = class(TSynMemoryStream)\n  protected\n    fMap: TMemoryMap;\n    fFileStream: THandleStream;\n    fFileName: TFileName;\n  public\n    /// create a TStream from a file content using fast memory mapping\n    // - if aCustomSize and aCustomOffset are specified, the corresponding\n    // map view if created (by default, will map whole file)\n    constructor Create(const aFileName: TFileName;\n      aCustomSize: PtrUInt = 0; aCustomOffset: Int64 = 0); overload;\n    /// create a TStream from a file content using fast memory mapping\n    // - if aCustomSize and aCustomOffset are specified, the corresponding\n    // map view if created (by default, will map whole file)\n    constructor Create(aFile: THandle;\n      aCustomSize: PtrUInt = 0; aCustomOffset: Int64 = 0); overload;\n    /// release any internal mapped file instance\n    destructor Destroy; override;\n    /// the file name, if created from such Create(aFileName) constructor\n    property FileName: TFileName\n      read fFileName;\n  end;\n\n  /// low-level access to a resource bound to the executable\n  // - so that Windows is not required in your unit uses clause\n  {$ifdef USERECORDWITHMETHODS}\n  TExecutableResource = record\n  {$else}\n  TExecutableResource = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    // note: we can't use THandle which is 32-bit on 64-bit POSIX\n    HResInfo: TLibHandle;\n    HGlobal: TLibHandle;\n  public\n    /// the resource memory pointer, after successful Open()\n    Buffer: pointer;\n    /// the resource memory size in bytes, after successful Open()\n    Size: PtrInt;\n    /// locate and lock a resource\n    // - use the current executable if Instance is left to its 0 default value\n    // - returns TRUE if the resource has been found, and Buffer/Size are set\n    function Open(const ResourceName: string; ResType: PChar;\n      Instance: TLibHandle = 0): boolean;\n    /// unlock and finalize a resource\n    procedure Close;\n  end;\n\n\ntype\n  /// store CPU and RAM usage for a given process\n  // - as used by TSystemUse class\n  TSystemUseData = packed record\n    /// when the data has been sampled\n    Timestamp: TDateTime;\n    /// percent of current Kernel-space CPU usage for this process\n    Kernel: single;\n    /// percent of current User-space CPU usage for this process\n    User: single;\n    /// how many KB of working memory are used by this process\n    WorkKB: cardinal;\n    /// how many KB of virtual memory are used by this process\n    VirtualKB: cardinal;\n  end;\n\n  /// store CPU and RAM usage history for a given process\n  // - as returned by TSystemUse.History\n  TSystemUseDataDynArray = array of TSystemUseData;\n\n  /// low-level structure used to compute process memory and CPU usage\n  {$ifdef USERECORDWITHMETHODS}\n  TProcessInfo = record\n  {$else}\n  TProcessInfo = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    {$ifdef OSWINDOWS}\n    fSysPrevIdle, fSysPrevKernel, fSysPrevUser,\n    fDiffIdle, fDiffKernel, fDiffUser, fDiffTotal: Int64;\n    {$endif OSWINDOWS}\n  public\n    /// initialize the system/process resource tracking\n    function Init: boolean;\n    /// to be called before PerSystem() or PerProcess() iteration\n    function Start: boolean;\n    /// percent of current Idle/Kernel/User CPU usage for all processes\n    function PerSystem(out Idle, Kernel, User: single): boolean;\n    /// retrieve CPU and RAM usage for a given process\n    function PerProcess(PID: cardinal; Now: PDateTime;\n      out Data: TSystemUseData; var PrevKernel, PrevUser: Int64): boolean;\n  end;\n\n  /// hold low-level information about current memory usage\n  // - as filled by GetMemoryInfo()\n  TMemoryInfo = record\n    memtotal, memfree, filetotal, filefree,\n    vmtotal, vmfree, allocreserved, allocused: QWord;\n    percent: integer;\n  end;\n\n  /// stores information about a disk partition\n  TDiskPartition = packed record\n    /// the name of this partition\n    // - is the Volume name under Windows, or the Device name under POSIX\n    name: RawUtf8;\n    /// where this partition has been mounted\n    // - e.g. 'C:' or '/home'\n    // - you can use GetDiskInfo(mounted) to retrieve current space information\n    mounted: TFileName;\n    /// total size (in bytes) of this partition\n    size: QWord;\n  end;\n\n  /// stores information about several disk partitions\n  TDiskPartitions = array of TDiskPartition;\n\n\n{$ifdef CPUARM}\nvar\n  /// internal wrapper address for ReserveExecutableMemory()\n  // - set to @TInterfacedObjectFake.ArmFakeStub by mormot.core.interfaces.pas\n  ArmFakeStubAddr: pointer;\n{$endif CPUARM}\n\n\n/// cross-platform reserve some executable memory\n// - using PAGE_EXECUTE_READWRITE flags on Windows, and PROT_READ or PROT_WRITE\n// or PROT_EXEC on POSIX\n// - this function maintain an internal list of 64KB memory pages for efficiency\n// - memory blocks can not be released (don't try to use fremeem on them) and\n// will be returned to the system at process finalization\nfunction ReserveExecutableMemory(size: cardinal): pointer;\n\n/// to be called after ReserveExecutableMemory() when you want to actually write\n// the memory blocks\n// - affect the mapping flags of the first memory page (4KB) of the Reserved\n// buffer, so its size should be < 4KB\n// - do nothing on Windows and Linux, but may be needed on OpenBSD\nprocedure ReserveExecutableMemoryPageAccess(Reserved: pointer; Exec: boolean);\n\n/// check if the supplied pointer is actually pointing to some memory page\n// - will call slow but safe VirtualQuery API on Windows, or try a fpaccess()\n// syscall on POSIX systems (validated on Linux only)\nfunction SeemsRealPointer(p: pointer): boolean;\n\n/// fill a buffer with a copy of some low-level system memory\n// - used e.g. by GetRawSmbios on XP or Linux/POSIX\n// - will allow to read up to 4MB of memory\n// - use low-level ntdll.dll API on Windows, or reading /dev/mem on POSIX - so\n// expect sudo/root rights on most systems\nfunction ReadSystemMemory(address, size: PtrUInt): RawByteString;\n\n/// return the PIDs of all running processes\n// - under Windows, is a wrapper around EnumProcesses() PsAPI call\n// - on Linux, will enumerate /proc/* pseudo-files\nfunction EnumAllProcesses: TCardinalDynArray;\n\n/// return the process name of a given process  ID\n// - under Windows, is a wrapper around\n// QueryFullProcessImageNameW/GetModuleFileNameEx PsAPI call\n// - on Linux, will query /proc/[pid]/exe or /proc/[pid]/cmdline pseudo-file\nfunction EnumProcessName(PID: cardinal): RawUtf8;\n\n/// return the process ID of the parent of a given PID\n// - by default (PID = 0), will search for the parent of the current process\n// - returns 0 if the PID was not found\nfunction GetParentProcess(PID: cardinal = 0): cardinal;\n\n/// check if this process is currently running into the debugger\n// - redirect to the homonymous WinAPI function on Windows, or check if the\n// /proc/self/status \"TracerPid:\" value is non zero on Linux, or search if\n// \"lazarus\" is part of the parent process name for BSD\n{$ifdef OSWINDOWS}\nfunction IsDebuggerPresent: BOOL; stdcall;\n{$else}\nfunction IsDebuggerPresent: boolean;\n{$endif ODWINDOWS}\n\n/// return the time and memory usage information about a given process\n// - under Windows, is a wrapper around GetProcessTimes/GetProcessMemoryInfo\nfunction RetrieveProcessInfo(PID: cardinal; out KernelTime, UserTime: Int64;\n  out WorkKB, VirtualKB: cardinal): boolean;\n\n/// return the system-wide time usage information\n// - under Windows, is a wrapper around GetSystemTimes() kernel API call\n// - return false on POSIX system - call RetrieveLoadAvg() instead\nfunction RetrieveSystemTimes(out IdleTime, KernelTime, UserTime: Int64): boolean;\n\n/// return the system-wide time usage information\n// - on LINUX, retrieve /proc/loadavg or on OSX/BSD call libc getloadavg()\n// - return '' on Windows - call RetrieveSystemTimes() instead\nfunction RetrieveLoadAvg: RawUtf8;\n\n/// retrieve low-level information about current memory usage\n// - as used by TSynMonitorMemory\n// - under BSD, only memtotal/memfree/percent are properly returned\n// - allocreserved and allocused are set only if withalloc is TRUE\nfunction GetMemoryInfo(out info: TMemoryInfo; withalloc: boolean): boolean;\n\n/// retrieve some human-readable text from GetMemoryInfo\n// - numbers are rounded up to a single GB number with no decimals\n// - returns e.g. 'used 6GB/16GB (35% free)' text\nfunction GetMemoryInfoText: RawUtf8;\n\n/// retrieve some human-readable text about the current system in several lines\n// - includes UTC timestamp, memory and disk availability, and exe/OS/CPU info\nfunction GetSystemInfoText: RawUtf8;\n\n/// retrieve low-level information about a given disk partition\n// - as used by TSynMonitorDisk and GetDiskPartitionsText()\n// - aDriveFolderOrFile is a directory on disk (no need to specify a raw drive\n// name like 'c:\\' on Windows)\n// - warning: aDriveFolderOrFile may be modified at input\n// - only under Windows the Quotas are applied separately to aAvailableBytes\n// in respect to global aFreeBytes\nfunction GetDiskInfo(var aDriveFolderOrFile: TFileName;\n  out aAvailableBytes, aFreeBytes, aTotalBytes: QWord\n  {$ifdef OSWINDOWS}; aVolumeName: PSynUnicode = nil{$endif}): boolean;\n\n/// retrieve how many bytes are currently available on a given folder\n// - returns 0 if the function fails\nfunction GetDiskAvailable(aDriveFolderOrFile: TFileName): QWord;\n\n/// retrieve low-level information about all mounted disk partitions of the system\n// - returned partitions array is sorted by \"mounted\" ascending order\nfunction GetDiskPartitions: TDiskPartitions;\n\n/// call several Operating System APIs to gather 512-bit of entropy information\nprocedure XorOSEntropy(var e: THash512Rec);\n\n/// low-level function returning some random binary from the Operating System\n// - will call /dev/urandom or /dev/random under POSIX, and CryptGenRandom API\n// on Windows then return TRUE, or fallback to mormot.core.base gsl_rng_taus2\n// generator and return FALSE if the system API failed\n// - on POSIX, only up to 32 bytes (256 bits) bits are retrieved from /dev/urandom\n// or /dev/random as stated by \"man urandom\" Usage - then RandomBytes() padded\n// - so you may consider that the output Buffer is always filled with random\n// - you should not have to call this procedure, but faster and safer TAesPrng\n// from mormot.crypt.core - also consider the TSystemPrng class\nfunction FillSystemRandom(Buffer: PByteArray; Len: integer;\n  AllowBlocking: boolean): boolean;\n\ntype\n  /// available console colors\n  TConsoleColor = (\n    ccBlack,\n    ccBlue,\n    ccGreen,\n    ccCyan,\n    ccRed,\n    ccMagenta,\n    ccBrown,\n    ccLightGray,\n    ccDarkGray,\n    ccLightBlue,\n    ccLightGreen,\n    ccLightCyan,\n    ccLightRed,\n    ccLightMagenta,\n    ccYellow,\n    ccWhite);\n\nvar\n  /// low-level handle used for console writing\n  // - may be overriden when console is redirected\n  // - on Windows, is initialized when AllocConsole or TextColor() are called\n  StdOut: THandle;\n\n  {$ifdef OSPOSIX}\n  /// set at initialization if StdOut has the TTY flag and env has a known TERM\n  StdOutIsTTY: boolean;\n  {$endif OSPOSIX}\n\n  /// global flag to modify the code behavior at runtime when run from TSynTests\n  // - e.g. TSynDaemon.AfterCreate won't overwrite TSynTests.RunAsConsole logs\n  RunFromSynTests: boolean;\n\n/// similar to Windows AllocConsole API call, to be truly cross-platform\n// - do nothing on Linux/POSIX, but set StdOut propertly from StdOutputHandle\n// - on Windows, will call the corresponding API, and set StdOut global variable\nprocedure AllocConsole;\n\n/// change the console text writing color\nprocedure TextColor(Color: TConsoleColor);\n\n/// change the console text background color\nprocedure TextBackground(Color: TConsoleColor);\n\n/// write some text to the console using a given color\n// - this method is protected by its own CriticalSection for output consistency\nprocedure ConsoleWrite(const Text: RawUtf8; Color: TConsoleColor = ccLightGray;\n  NoLineFeed: boolean = false; NoColor: boolean = false); overload;\n\n/// will wait for the ENTER key to be pressed, with all needed waiting process\n// - on the main thread, will call Synchronize() for proper work e.g. with\n// interface-based service implemented as optExecInMainThread\n// - on Windows, from a non-main Thread, respond to PostThreadMessage(WM_QUIT)\n// - on Windows, also properly respond to Ctrl-C or closing console events\n// - on POSIX, will call SynDaemonIntercept first, so that Ctrl-C or SIG_QUIT\n// will also be intercepted and let this procedure return\nprocedure ConsoleWaitForEnterKey;\n\n/// read all available content from stdin\n// - could be used to retrieve some file piped to the command line\n// - the content is not converted, so will follow the encoding used for storage\nfunction ConsoleReadBody: RawByteString;\n\n{$ifdef OSWINDOWS}\n\n/// low-level access to the keyboard state of a given key\nfunction ConsoleKeyPressed(ExpectedKey: Word): boolean;\n\n/// local RTL wrapper function to avoid linking mormot.core.unicode.pas\nprocedure Win32PWideCharToUtf8(P: PWideChar; Len: PtrInt;\n  out res: RawUtf8); overload;\n\n/// local RTL wrapper function to avoid linking mormot.core.unicode.pas\nprocedure Win32PWideCharToUtf8(P: PWideChar; out res: RawUtf8); overload;\n\n/// local RTL wrapper function to avoid linking mormot.core.unicode.pas\n// - returns dest.buf as PWideChar result, and dest.len as length\n// - caller should always call dest.Done to release (unlikely) temporary memory\nfunction Utf8ToWin32PWideChar(const Text: RawUtf8;\n  var dest: TSynTempBuffer): PWideChar;\n\n/// ask the Operating System to convert a file URL to a local file path\n// - only Windows has a such a PathCreateFromUrl() API\n// - POSIX define this in mormot.net.http.pas, where TUri is available\n// - used e.g. by TNetClientProtocolFile to implement the 'file://' protocol\nfunction GetFileNameFromUrl(const Uri: string): TFileName;\n\n{$else}\n\n/// internal function to avoid linking mormot.core.buffers.pas\nfunction PosixParseHex32(p: PAnsiChar): integer;\n\n/// internal function to avoid linking mormot.core.buffers.pas\nprocedure ParseHex(p: PAnsiChar; b: PByte; n: integer);\n\n/// internal function just wrapping fppoll(POLLIN or POLLPRI)\nfunction WaitReadPending(fd, timeout: integer): boolean;\n\n/// POSIX-only function calling directly getdents/getdents64 syscall\n// - could be used when FindFirst/FindNext are an overkill, e.g. to quickly\n// cache all file names of a folder in memory, optionally with its sub-folders\n// - used e.g. by TPosixFileCaseInsensitive from mormot.core.unicode\n// - warning: the file system has to support d_type (e.g. btrfs, ext2-ext4) so\n// that Recursive is handled and only DT_REG files are retrieved; non-compliant\n// file systems (or Linux Kernel older than 2.6.4) won't support the Recursive\n// search, and may return some false positives, like symlinks or nested folders\nfunction PosixFileNames(const Folder: TFileName; Recursive: boolean): TRawUtf8DynArray;\n\n{$endif OSWINDOWS}\n\n/// internal function to avoid linking mormot.core.buffers.pas\n// - will output the value as one number with one decimal and KB/MB/GB/TB suffix\nfunction _oskb(Size: QWord): shortstring;\n\n/// direct conversion of a UTF-8 encoded string into a console OEM-encoded string\n// - under Windows, will use the CP_OEM encoding\n// - under Linux, will expect the console to be defined with UTF-8 encoding\n// - we don't propose any ConsoleToUtf8() function because Windows depends on\n// the running program itself: most should generates CP_OEM (e.g. 850) as expected,\n// but some could use the system code page or even UTF-16 binary with BOM (!) -\n// so you may consider using AnsiToUtf8() with the proper code page\nfunction Utf8ToConsole(const S: RawUtf8): RawByteString;\n\n\ntype\n  /// encapsulate cross-platform loading of library files\n  // - this generic class can be used for any external library (.dll/.so)\n  TSynLibrary = class\n  protected\n    fHandle: TLibHandle;\n    fLibraryPath: TFileName;\n    fTryFromExecutableFolder: boolean;\n    {$ifdef OSPOSIX}\n    fLibraryPathTested: boolean;\n    {$endif OSPOSIX}\n  public\n    /// cross-platform resolution of a function entry in this library\n    // - if RaiseExceptionOnFailure is set, missing entry will call FreeLib then raise it\n    // - ProcName can be a space-separated list of procedure names, to try\n    // alternate API names (e.g. for OpenSSL 1.1.1/3.x compatibility)\n    // - if ProcName starts with '?' then RaiseExceptionOnFailure = nil is set\n    function Resolve(const Prefix, ProcName: RawUtf8; Entry: PPointer;\n      RaiseExceptionOnFailure: ExceptionClass = nil): boolean;\n    /// cross-platform resolution of all function entries in this library\n    // - will search and fill Entry^ for all ProcName^ until ProcName^=nil\n    // - return true on success, false and call FreeLib if any entry is missing\n    function ResolveAll(ProcName: PPAnsiChar; Entry: PPointer): boolean;\n    /// cross-platform call to FreeLibrary() + set fHandle := 0\n    // - as called by Destroy, but you can use it directly to reload the library\n    procedure FreeLib;\n    /// same as SafeLoadLibrary() but setting fLibraryPath and cwd on Windows\n    function TryLoadLibrary(const aLibrary: array of TFileName;\n      aRaiseExceptionOnFailure: ExceptionClass): boolean; virtual;\n    /// release associated memory and linked library\n    destructor Destroy; override;\n    /// return TRUE if the library and all procedures were found\n    function Exists: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// the associated library handle\n    property Handle: TLibHandle\n      read fHandle write fHandle;\n    /// the loaded library path\n    // - on POSIX, contains the full path (via dladdr) once Resolve() is called\n    property LibraryPath: TFileName\n      read fLibraryPath;\n    /// if set, and no path is specified, will try from Executable.ProgramFilePath\n    property TryFromExecutableFolder: boolean\n      read fTryFromExecutableFolder write fTryFromExecutableFolder;\n  end;\n\n\n{ *************** Per Class Properties O(1) Lookup via vmtAutoTable Slot }\n\n/// self-modifying code - change some memory buffer in the code segment\n// - if Backup is not nil, it should point to a Size array of bytes, ready\n// to contain the overridden code buffer, for further hook disabling\n// - some systems do forbid such live patching: consider setting NOPATCHVMT\n// and NOPATCHRTL conditionals for such projects\nprocedure PatchCode(Old, New: pointer; Size: PtrInt; Backup: pointer = nil;\n  LeaveUnprotected: boolean = false);\n\n/// self-modifying code - change one PtrUInt in the code segment\nprocedure PatchCodePtrUInt(Code: PPtrUInt; Value: PtrUInt;\n  LeaveUnprotected: boolean = false);\n\n{$ifdef CPUINTEL}\n/// low-level i386/x86_64 asm routine patch and redirection\nprocedure RedirectCode(Func, RedirectFunc: Pointer);\n{$endif CPUINTEL}\n\n\n{ ************** Cross-Platform Charset and CodePage Support }\n\n{$ifdef OSPOSIX}\nconst\n  ANSI_CHARSET = 0;\n  DEFAULT_CHARSET = 1;\n  SYMBOL_CHARSET = 2;\n  SHIFTJIS_CHARSET = $80;\n  HANGEUL_CHARSET = 129;\n  GB2312_CHARSET = 134;\n  CHINESEBIG5_CHARSET = 136;\n  OEM_CHARSET = 255;\n  JOHAB_CHARSET = 130;\n  HEBREW_CHARSET = 177;\n  ARABIC_CHARSET = 178;\n  GREEK_CHARSET = 161;\n  TURKISH_CHARSET = 162;\n  VIETNAMESE_CHARSET = 163;\n  THAI_CHARSET = 222;\n  EASTEUROPE_CHARSET = 238;\n  RUSSIAN_CHARSET = 204;\n  BALTIC_CHARSET = 186;\n{$else}\n{$ifdef FPC} // a missing declaration\nconst\n  VIETNAMESE_CHARSET = 163;\n{$endif FPC}\n{$endif OSPOSIX}\n\n/// convert a char set to a code page\nfunction CharSetToCodePage(CharSet: integer): cardinal;\n\n/// convert a code page to a char set\nfunction CodePageToCharSet(CodePage: cardinal): integer;\n\n\n{ **************** TSynLocker/TSynLocked and Low-Level Threading Features }\n\ntype\n  /// a lightweight exclusive non-rentrant lock, stored in a PtrUInt value\n  // - calls SwitchToThread after some spinning, but don't use any R/W OS API\n  // - warning: methods are non rentrant, i.e. calling Lock twice in a raw would\n  // deadlock: use TRWLock or TSynLocker/TOSLock for reentrant methods\n  // - several lightlocks, each protecting a few variables (e.g. a list), may\n  // be more efficient than a more global TOSLock/TRWLock\n  // - our light locks are expected to be kept a very small amount of time (some\n  // CPU cycles): use TOSLightLock if the lock may block too long\n  // - TryLock/UnLock can be used to thread-safely acquire a shared resource\n  // - only consume 4 bytes on CPU32, 8 bytes on CPU64\n  {$ifdef USERECORDWITHMETHODS}\n  TLightLock = record\n  {$else}\n  TLightLock = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    Flags: PtrUInt;\n    // low-level function called by the Lock method when inlined\n    procedure LockSpin;\n  public\n    /// to be called if the instance has not been filled with 0\n    // - e.g. not needed if TLightLock is defined as a class field\n    procedure Init;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// could be called to finalize the instance as a TOSLock\n    // - does nothing - just for compatibility with TOSLock\n    procedure Done;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// enter an exclusive non-rentrant lock\n    procedure Lock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// try to enter an exclusive non-rentrant lock\n    // - if returned true, caller should eventually call UnLock()\n    // - could also be used to thread-safely acquire a shared resource\n    function TryLock: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// check if the non-rentrant lock has been acquired\n    function IsLocked: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// leave an exclusive non-rentrant lock\n    procedure UnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n  end;\n\n  /// a lightweight multiple Reads / exclusive Write non-upgradable lock\n  // - calls SwitchToThread after some spinning, but don't use any R/W OS API\n  // - warning: ReadLocks are reentrant and allow concurrent acccess, but calling\n  // WriteLock within a ReadLock, or within another WriteLock, would deadlock\n  // - consider TRWLock if you need an upgradable lock - but for mostly reads,\n  // TRWLightLock.ReadLock/ReadUnLock/WriteLock pattern is faster than upgrading\n  // - our light locks are expected to be kept a very small amount of time (some\n  // CPU cycles): use TSynLocker or TOSLock if the lock may block too long\n  // - several lightlocks, each protecting a few variables (e.g. a list), may\n  // be more efficient than a more global TOSLock/TRWLock\n  // - only consume 4 bytes on CPU32, 8 bytes on CPU64\n  {$ifdef USERECORDWITHMETHODS}\n  TRWLightLock = record\n  {$else}\n  TRWLightLock = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    Flags: PtrUInt; // bit 0 = WriteLock, >0 = ReadLock\n    // low-level functions called by the Lock methods when inlined\n    procedure ReadLockSpin;\n    procedure WriteLockSpin;\n  public\n    /// to be called if the instance has not been filled with 0\n    // - e.g. not needed if TRWLightLock is defined as a class field\n    procedure Init;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// enter a non-upgradable multiple reads lock\n    // - read locks maintain a thread-safe counter, so are reentrant and non blocking\n    // - warning: nested WriteLock call after a ReadLock would deadlock\n    procedure ReadLock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// try to enter a non-upgradable multiple reads lock\n    // - if returned true, caller should eventually call ReadUnLock\n    // - read locks maintain a thread-safe counter, so are reentrant and non blocking\n    // - warning: nested WriteLock call after a ReadLock would deadlock\n    function TryReadLock: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// leave a non-upgradable multiple reads lock\n    procedure ReadUnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// enter a non-rentrant non-upgradable exclusive write lock\n    // - warning: nested WriteLock call after a ReadLock or another WriteLock\n    // would deadlock\n    procedure WriteLock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// try to enter a non-rentrant non-upgradable exclusive write lock\n    // - if returned true, caller should eventually call WriteUnLock\n    // - warning: nested TryWriteLock call after a ReadLock or another WriteLock\n    // would deadlock\n    function TryWriteLock: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// leave a non-rentrant non-upgradable exclusive write lock\n    procedure WriteUnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n  end;\n\ntype\n  /// how TRWLock.Lock and TRWLock.UnLock high-level wrapper methods are called\n  TRWLockContext = (\n    cReadOnly,\n    cReadWrite,\n    cWrite);\n\n  /// a lightweight multiple Reads / exclusive Write reentrant lock\n  // - calls SwitchToThread after some spinning, but don't use any R/W OS API\n  // - our light locks are expected to be kept a very small amount of time (some\n  // CPU cycles): use TSynLocker or TOSLock if the lock may block too long\n  // - warning: all methods are reentrant, but WriteLock/ReadWriteLock would\n  // deadlock if called after a ReadOnlyLock\n  {$ifdef USERECORDWITHMETHODS}\n  TRWLock = record\n  {$else}\n  TRWLock = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    Flags: PtrUInt; // bit 0 = WriteLock, 1 = ReadWriteLock, >1 = ReadOnlyLock\n    LastReadWriteLockThread, LastWriteLockThread: TThreadID; // to be reentrant\n    LastReadWriteLockCount,  LastWriteLockCount: cardinal;\n    {$ifndef FPC_ASMX64}\n    procedure ReadOnlyLockSpin;\n    {$endif FPC_ASMX64}\n  public\n    /// initialize the R/W lock\n    // - not needed if TRWLock is part of a class - i.e. if was filled with 0\n    procedure Init;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// could be called at shutdown to ensure that the R/W lock is in neutral state\n    procedure AssertDone;\n    /// wait for the lock to be available for reading, but not upgradable to write\n    // - several readers could acquire the lock simultaneously\n    // - ReadOnlyLock is reentrant since there is a thread-safe internal counter\n    // - warning: calling ReadWriteLock/WriteLock after ReadOnlyLock would deadlock\n    // - typical usage is the following:\n    // ! rwlock.ReadOnlyLock; // won't block concurrent ReadOnlyLock\n    // ! try\n    // !   result := Exists(value);\n    // ! finally\n    // !   rwlock.ReadOnlyUnLock;\n    // ! end;\n    procedure ReadOnlyLock;\n      {$ifdef HASINLINE} {$ifndef FPC_ASMX64} inline; {$endif} {$endif}\n    /// release a previous ReadOnlyLock call\n    procedure ReadOnlyUnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// wait for the lock to be accessible for reading - later upgradable to write\n    // - will mark the lock with the current thread so that a nested WriteLock\n    // would be possible, but won't block concurrent ReadOnlyLock\n    // - several readers could acquire ReadOnlyLock simultaneously, but only a\n    // single thread could acquire a ReadWriteLock\n    // - reentrant method, and nested WriteLock is allowed\n    // - typical usage is the following:\n    // ! rwlock.ReadWriteLock;      // won't block concurrent ReadOnlyLock\n    // ! try                        // but block other ReadWriteLock/WriteLock\n    // !   result := Exists(value);\n    // !   if not result then\n    // !   begin\n    // !     rwlock.WriteLock; // block any ReadOnlyLock/ReadWriteLock/WriteLock\n    // !     try\n    // !       Add(value);\n    // !     finally\n    // !       rwlock.WriteUnLock;\n    // !     end;\n    // !   end;\n    // ! finally\n    // !   rwlock.ReadWriteUnLock;\n    // ! end;\n    procedure ReadWriteLock;\n    /// release a previous ReadWriteLock call\n    procedure ReadWriteUnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// wait for the lock to be accessible for writing\n    // - the write lock is exclusive\n    // - calling WriteLock within a ReadWriteLock is allowed and won't block\n    // - but calling WriteLock within a ReadOnlyLock would deaadlock\n    // - this method is rentrant from a single thread\n    // - typical usage is the following:\n    // ! rwlock.WriteLock; // block any ReadOnlyLock/ReadWriteLock/WriteLock\n    // ! try\n    // !   Add(value);\n    // ! finally\n    // !   rwlock.WriteUnLock;\n    // ! end;\n    procedure WriteLock;\n    /// release a previous WriteLock call\n    procedure WriteUnlock;\n      {$ifdef FPC_OR_DELPHIXE4} inline; {$endif} // circumvent weird Delphi bug\n    /// a high-level wrapper over ReadOnlyLock/ReadWriteLock/WriteLock methods\n    procedure Lock(context: TRWLockContext {$ifndef PUREMORMOT2} = cWrite {$endif});\n      {$ifdef HASINLINE} inline; {$endif}\n    /// a high-level wrapper over ReadOnlyUnLock/ReadWriteUnLock/WriteUnLock methods\n    procedure UnLock(context: TRWLockContext {$ifndef PUREMORMOT2} = cWrite {$endif});\n      {$ifdef HASINLINE} inline; {$endif}\n  end;\n  PRWLock = ^TRWLock;\n\n  /// the standard rentrant lock supplied by the Operating System\n  // - maps TRTLCriticalSection, i.e. calls Win32 API or pthreads library\n  // - don't forget to call Init and Done to properly initialize the structure\n  // - if you do require a non-rentrant/recursive lock, consider TOSLightLock\n  // - same signature as TLightLock/TOSLightLock, usable as compile time alternatives\n  {$ifdef USERECORDWITHMETHODS}\n  TOSLock = record\n  {$else}\n  TOSLock = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    CS: TRTLCriticalSection;\n  public\n    /// to be called to setup the instance\n    // - mandatory in all cases, even if TOSLock is part of a class\n    procedure Init;\n    /// to be called to finalize the instance\n    procedure Done;\n    /// enter an OS lock\n    // - notice: this method IS reentrant/recursive\n    procedure Lock;\n      {$ifdef FPC} inline; {$endif}\n    /// try to enter an OS lock\n    // - if returned true, caller should eventually call UnLock()\n    function TryLock: boolean;\n      {$ifdef FPC} inline; {$endif}\n    /// leave an OS lock\n    procedure UnLock;\n      {$ifdef FPC} inline; {$endif}\n  end;\n\n  /// the fastest non-rentrant lock supplied by the Operating System\n  // - calls Slim Reader/Writer (SRW) Win32 API in exclusive mode or directly\n  // the pthread_mutex_*() library calls in non-recursive/fast mode on Linux\n  // - on XP, where SRW are not available, fallback to a TLightLock\n  // - on non-Linux POSIX, fallback to regular cthreads/TRTLCriticalSection\n  // - don't forget to call Init and Done to properly initialize the structure\n  // - to protect a very small code section of a few CPU cycles with no Init/Done\n  // needed, and a lower footprint, you may consider our TLightLock\n  // - same signature as TOSLock/TLightLock, usable as compile time alternatives\n  // - warning: non-rentrant, i.e. nested Lock calls would block, as TLightLock\n  // - no TryLock is defined on Windows, because TryAcquireSRWLockExclusive()\n  // raised some unexpected EExternalException C000026 NT_STATUS_RESOURCE_NOT_OWNED\n  // (\"Attempt to release mutex not owned by caller\") during testing\n  {$ifdef USERECORDWITHMETHODS}\n  TOSLightLock = record\n  {$else}\n  TOSLightLock = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fMutex: TOSLightMutex;\n  public\n    /// to be called to setup the instance\n    // - mandatory in all cases, even if TOSLock is part of a class\n    procedure Init;\n    /// to be called to finalize the instance\n    procedure Done;\n    /// enter an OS lock\n    // - warning: this method is NOT reentrant/recursive, so any nested call\n    // would deadlock\n    procedure Lock;\n      {$ifdef HASINLINE} inline; {$endif}\n    {$ifdef OSPOSIX}\n    /// access to raw pthread_mutex_trylock() method\n    // - TryAcquireSRWLockExclusive() seems not stable on all Windows revisions\n    function TryLock: boolean;\n     {$ifdef HASINLINE} inline; {$endif}\n    {$endif OSPOSIX}\n    /// leave an OS lock\n    procedure UnLock;\n      {$ifdef HASINLINE} inline; {$endif}\n  end;\n\n  /// points to one data entry in TLockedList\n  PLockedListOne = ^TLockedListOne;\n  /// abstract parent of one data entry in TLockedList, storing two PLockedListOne\n  // - TLockedList should store unmanaged records starting with those fields\n  // - sequence field contains an incremental random-seeded 30-bit integer > 65535,\n  // to avoid ABA problems when instances are recycled\n  TLockedListOne = record\n    next, prev: pointer;\n    sequence: PtrUInt;\n  end;\n  /// optional callback event to finalize one TLockedListOne instance\n  TOnLockedListOne = procedure(one: PLockedListOne) of object;\n\n  /// thread-safe dual-linked list of TLockedListOne descendants with recycling\n  {$ifdef USERECORDWITHMETHODS}\n  TLockedList = record\n  {$else}\n  TLockedList = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fHead, fBin: pointer;\n    fSize: integer;\n    fSequence: PtrUInt;\n    fOnFree: TOnLockedListOne;\n  public\n    /// thread-safe access to the list\n    Safe: TLightLock;\n    /// how many TLockedListOne instances are currently stored in this list\n    // - excluding the instances in the recycle bin\n    Count: integer;\n    /// initialize the storage for an inherited TLockedListOne size\n    procedure Init(onesize: PtrUInt; const onefree: TOnLockedListOne = nil);\n    /// release all stored memory\n    procedure Done;\n    /// allocate a new PLockedListOne data instance in threadsafe O(1) process\n    function New: pointer;\n    /// release one PLockedListOne used data instance in threadsafe O(1) process\n    function Free(one: pointer): boolean;\n    /// release all TLockedListOne instances currently stored in this list\n    // - without moving any of those instances into the internal recycle bin\n    procedure Clear;\n    /// release all to-be-recycled items available in the internal bin\n    // - returns how many items have been released from the internal collector\n    function EmptyBin: integer;\n    /// raw access to the stored items as PLockedListOne dual-linked list\n    property Head: pointer\n      read fHead;\n    /// the size of one stored instance, including its TLockedListOne header\n    property Size: integer\n      read fSize;\n  end;\n\ntype\n  /// how TSynLocker handles its thread processing\n  // - by default, uSharedLock will use the main TRTLCriticalSection\n  // - you may set uRWLock and call overloaded RWLock/RWUnLock() to use our\n  // lighter TRWLock - but be aware that cReadOnly followed by cReadWrite/cWrite\n  // would deadlock - regular Lock/UnLock will use cWrite exclusive lock\n  // - uNoLock will disable the whole locking mechanism\n  TSynLockerUse = (\n    uSharedLock,\n    uRWLock,\n    uNoLock);\n\n  /// allow to add cross-platform locking methods to any class instance\n  // - typical use is to define a Safe: TSynLocker property, call Safe.Init\n  // and Safe.Done in constructor/destructor methods, and use Safe.Lock/UnLock\n  // methods in a try ... finally section\n  // - in respect to the TCriticalSection class, fix a potential CPU cache line\n  // conflict which may degrade the multi-threading performance, as reported by\n  // @http://www.delphitools.info/2011/11/30/fixing-tcriticalsection\n  // - internal padding is used to safely store up to 7 values protected\n  // from concurrent access with a mutex, so that SizeOf(TSynLocker)>128\n  // - for object-level locking, see TSynPersistentLock which owns one such\n  // instance, or call low-level fSafe := NewSynLocker in your constructor,\n  // then fSafe^.DoneAndFreemem in your destructor\n  // - RWUse property could replace the TRTLCriticalSection by a lighter TRWLock\n  // - see also TRWLock and TSynPersistentRWLock if the multiple read / exclusive\n  // write lock is better (only if the locked process does not take too much time)\n  {$ifdef USERECORDWITHMETHODS}\n  TSynLocker = record\n  {$else}\n  TSynLocker = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fSection: TRTLCriticalSection;\n    fRW: TRWLock;\n    fPaddingUsedCount: byte;\n    fInitialized: boolean;\n    fRWUse: TSynLockerUse;\n    fLockCount: integer;\n    function GetVariant(Index: integer): Variant;\n    procedure SetVariant(Index: integer; const Value: Variant);\n    function GetInt64(Index: integer): Int64;\n    procedure SetInt64(Index: integer; const Value: Int64);\n    function GetBool(Index: integer): boolean;\n    procedure SetBool(Index: integer; const Value: boolean);\n    function GetUnlockedInt64(Index: integer): Int64;\n    procedure SetUnlockedInt64(Index: integer; const Value: Int64);\n    function GetPointer(Index: integer): Pointer;\n    procedure SetPointer(Index: integer; const Value: Pointer);\n    function GetUtf8(Index: integer): RawUtf8;\n    procedure SetUtf8(Index: integer; const Value: RawUtf8);\n    function GetIsLocked: boolean;\n    // - if RWUse=uSharedLock, calls EnterCriticalSection (no parallel readings)\n    // - warning: if RWUse=uRWLock, this method will use the internal TRWLock\n    // - defined in protected section for better inlining and to fix a Delphi\n    // compiler bug about warning a missing Windows unit in the uses classes\n    procedure RWLock(context: TRWLockContext);\n      {$ifdef HASINLINE} inline; {$endif}\n    procedure RWUnLock(context: TRWLockContext);\n      {$ifdef HASINLINE} inline; {$endif}\n  public\n    /// internal padding data, also used to store up to 7 variant values\n    // - this memory buffer will ensure no CPU cache line mixup occurs\n    // - you should not use this field directly, but rather the Locked[],\n    // LockedInt64[], LockedUtf8[] or LockedPointer[] methods\n    // - if you want to access those array values, ensure you protect them\n    // using a Safe.Lock; try ... Padding[n] ... finally Safe.Unlock structure,\n    // and maintain the PaddingUsedCount property accurately\n    Padding: array[0..6] of TVarData;\n    /// initialize the mutex\n    // - calling this method is mandatory (e.g. in the class constructor owning\n    // the TSynLocker instance), otherwise you may encounter unexpected\n    // behavior, like access violations or memory leaks\n    procedure Init;\n    /// finalize the mutex\n    // - calling this method is mandatory (e.g. in the class destructor owning\n    // the TSynLocker instance), otherwise you may encounter unexpected\n    // behavior, like access violations or memory leaks\n    procedure Done;\n    /// finalize the mutex, and call FreeMem() on the pointer of this instance\n    // - should have been initiazed with a NewSynLocker call\n    procedure DoneAndFreeMem;\n    /// low-level acquisition of the lock, as RWLock(cReadOnly)\n    // - if RWUse=uSharedLock, calls EnterCriticalSection (no parallel readings)\n    // - warning: with RWUse=uRWLock, a nested Lock call would deadlock, but not\n    // nested ReadLock calls\n    procedure ReadLock;\n    /// low-level release of the lock, as RWUnLock(cReadOnly)\n    procedure ReadUnLock;\n    /// low-level acquisition of the lock, as RWLock(cReadWrite)\n    // - if RWUse=uSharedLock, calls EnterCriticalSection (no parallel readings)\n    // - with RWUse=uRWLock, a nested Lock call would not deadlock\n    procedure ReadWriteLock;\n    /// low-level release of the lock, as RWUnLock(cReadWrite)\n    procedure ReadWriteUnLock;\n    /// lock the instance for exclusive access, as RWLock(cWrite)\n    // - is re-entrant from the same thread i.e. you can nest Lock/UnLock calls\n    // - warning: with RWUse=uRWLock, would deadlock after a nested ReadLock,\n    // but not after ReadWriteLock\n    // - use as such to avoid race condition (from a Safe: TSynLocker property):\n    // ! Safe.Lock;\n    // ! try\n    // !   ...\n    // ! finally\n    // !   Safe.Unlock;\n    // ! end;\n    procedure Lock;\n    /// will try to acquire the mutex\n    // - do nothing and return false if RWUse is not the default uSharedLock\n    // - use as such to avoid race condition (from a Safe: TSynLocker property):\n    // ! if Safe.TryLock then\n    // !   try\n    // !     ...\n    // !   finally\n    // !     Safe.Unlock;\n    // !   end;\n    function TryLock: boolean;\n    /// will try to acquire the mutex for a given time\n    // - just wait and return false if RWUse is not the default uSharedLock\n    // - use as such to avoid race condition (from a Safe: TSynLocker property):\n    // ! if Safe.TryLockMS(100) then\n    // !   try\n    // !     ...\n    // !   finally\n    // !     Safe.Unlock;\n    // !   end;\n    function TryLockMS(retryms: integer; terminated: PBoolean = nil): boolean;\n    /// release the instance for exclusive access, as RWUnLock(cWrite)\n    // - each Lock/TryLock should have its exact UnLock opposite, so a\n    // try..finally block is mandatory for safe code\n    procedure UnLock; overload;\n    /// will enter the mutex until the IUnknown reference is released\n    // - could be used as such under Delphi:\n    // !begin\n    // !  ... // unsafe code\n    // !  Safe.ProtectMethod;\n    // !  ... // thread-safe code\n    // !end; // local hidden IUnknown will release the lock for the method\n    // - warning: under FPC, you should assign its result to a local variable -\n    // see bug http://bugs.freepascal.org/view.php?id=26602\n    // !var\n    // !  LockFPC: IUnknown;\n    // !begin\n    // !  ... // unsafe code\n    // !  LockFPC := Safe.ProtectMethod;\n    // !  ... // thread-safe code\n    // !end; // LockFPC will release the lock for the method\n    // or\n    // !begin\n    // !  ... // unsafe code\n    // !  with Safe.ProtectMethod do\n    // !  begin\n    // !    ... // thread-safe code\n    // !  end; // local hidden IUnknown will release the lock for the method\n    // !end;\n    function ProtectMethod: IUnknown;\n    /// number of values stored in the internal Padding[] array\n    // - equals 0 if no value is actually stored, or a 1..7 number otherwise\n    // - you should not have to use this field, but for optimized low-level\n    // direct access to Padding[] values, within a Lock/UnLock safe block\n    property PaddingUsedCount: byte\n      read fPaddingUsedCount write fPaddingUsedCount;\n    /// returns true if the mutex is currently locked by another thread\n    // - with RWUse=uRWLock, any lock (even ReadOnlyLock) would return true\n    property IsLocked: boolean\n      read GetIsLocked;\n    /// returns true if the Init method has been called for this mutex\n    // - is only relevant if the whole object has been previously filled with 0,\n    // i.e. as part of a class or as global variable, but won't be accurate\n    // when allocated on stack\n    property IsInitialized: boolean\n      read fInitialized;\n    /// safe locked access to a Variant value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // LockedBool, LockedInt64, LockedPointer and LockedUtf8 array properties\n    // - returns null if the Index is out of range\n    // - allow concurrent thread reading if RWUse was set to uRWLock\n    property Locked[Index: integer]: Variant\n      read GetVariant write SetVariant;\n    /// safe locked access to a Int64 value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedUtf8 array properties\n    // - Int64s will be stored internally as a varInt64 variant\n    // - returns nil if the Index is out of range, or does not store a Int64\n    // - allow concurrent thread reading if RWUse was set to uRWLock\n    property LockedInt64[Index: integer]: Int64\n      read GetInt64 write SetInt64;\n    /// safe locked access to a boolean value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked, LockedInt64, LockedPointer and LockedUtf8 array properties\n    // - value will be stored internally as a varboolean variant\n    // - returns nil if the Index is out of range, or does not store a boolean\n    // - allow concurrent thread reading if RWUse was set to uRWLock\n    property LockedBool[Index: integer]: boolean\n      read GetBool write SetBool;\n    /// safe locked access to a pointer/TObject value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked, LockedBool, LockedInt64 and LockedUtf8 array properties\n    // - pointers will be stored internally as a varUnknown variant\n    // - returns nil if the Index is out of range, or does not store a pointer\n    // - allow concurrent thread reading if RWUse was set to uRWLock\n    property LockedPointer[Index: integer]: Pointer\n      read GetPointer write SetPointer;\n    /// safe locked access to an UTF-8 string value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedPointer array properties\n    // - UTF-8 string will be stored internally as a varString variant\n    // - returns '' if the Index is out of range, or does not store a string\n    // - allow concurrent thread reading if RWUse was set to uRWLock\n    property LockedUtf8[Index: integer]: RawUtf8\n      read GetUtf8 write SetUtf8;\n    /// safe locked in-place increment to an Int64 value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedUtf8 array properties\n    // - Int64s will be stored internally as a varInt64 variant\n    // - returns the newly stored value\n    // - if the internal value is not defined yet, would use 0 as default value\n    function LockedInt64Increment(Index: integer; const Increment: Int64): Int64;\n    /// safe locked in-place exchange of a Variant value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedUtf8 array properties\n    // - returns the previous stored value, or null if the Index is out of range\n    function LockedExchange(Index: integer; const Value: variant): variant;\n    /// safe locked in-place exchange of a pointer/TObject value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedUtf8 array properties\n    // - pointers will be stored internally as a varUnknown variant\n    // - returns the previous stored value, nil if the Index is out of range,\n    // or does not store a pointer\n    function LockedPointerExchange(Index: integer; Value: pointer): pointer;\n    /// unsafe access to a Int64 value\n    // - you may store up to 7 variables, using an 0..6 index, shared with\n    // Locked and LockedUtf8 array properties\n    // - Int64s will be stored internally as a varInt64 variant\n    // - returns nil if the Index is out of range, or does not store a Int64\n    // - you should rather call LockedInt64[] property, or use this property\n    // with a Lock; try ... finally UnLock block\n    property UnlockedInt64[Index: integer]: Int64\n      read GetUnlockedInt64 write SetUnlockedInt64;\n    /// how RWLock/RWUnLock would be processed\n    property RWUse: TSynLockerUse\n      read fRWUse write fRWUse;\n  end;\n\n  /// a pointer to a TSynLocker mutex instance\n  // - see also NewSynLocker and TSynLocker.DoneAndFreemem functions\n  PSynLocker = ^TSynLocker;\n\n  /// raw class used by TAutoLocker.ProtectMethod and TSynLocker.ProtectMethod\n  // - defined here for use by TAutoLocker in mormot.core.data.pas\n  TAutoLock = class(TInterfacedObject)\n  protected\n    fLock: PSynLocker;\n  public\n    constructor Create(aLock: PSynLocker);\n    destructor Destroy; override;\n  end;\n\n  /// our lightweight cross-platform TEvent-like component\n  // - on Windows, calls directly the CreateEvent/ResetEvent/SetEvent API\n  // - on Linux, will use eventfd() in blocking and non-semaphore mode\n  // - on other POSIX, will use PRTLEvent which is lighter than TEvent BasicEvent\n  // - only limitation is that we don't know if WaitFor is signaled or timeout,\n  // but this is not a real problem in practice since most code don't need this\n  // information or has already its own flag in its implementation logic\n  TSynEvent = class\n  protected\n    fHandle: pointer; // Windows THandle or FPC PRTLEvent\n    fFD: integer;     // for eventfd()\n  public\n    /// initialize an instance of cross-platform event\n    constructor Create;\n    /// finalize this instance of cross-platform event\n    destructor Destroy; override;\n    /// ignore any pending events, so that WaitFor will be set on next SetEvent\n    procedure ResetEvent;\n      {$ifdef OSPOSIX} inline; {$endif}\n    /// trigger any pending event, releasing the WaitFor/WaitForEver methods\n    procedure SetEvent;\n      {$ifdef OSPOSIX} inline; {$endif}\n    /// wait until SetEvent is called from another thread, with a maximum time\n    // - does not return if it was signaled or timeout\n    // - WARNING: you should wait from a single thread at once\n    procedure WaitFor(TimeoutMS: integer);\n      {$ifdef OSPOSIX} inline; {$endif}\n    /// wait until SetEvent is called from another thread, with no maximum time\n    procedure WaitForEver;\n      {$ifdef OSPOSIX} inline; {$endif}\n    /// calls SleepHiRes() in steps while checking terminated flag and this event\n    function SleepStep(var start: Int64; terminated: PBoolean): Int64;\n    /// could be used to tune your algorithm if the eventfd() API is used\n    function IsEventFD: boolean;\n      {$ifdef HASINLINE} inline; {$endif}\n  end;\n\n\n/// initialize a TSynLocker instance from heap\n// - call DoneandFreeMem to release the associated memory and OS mutex\n// - is used e.g. in TSynPersistentLock to reduce class instance size\nfunction NewSynLocker: PSynLocker;\n\ntype\n  {$M+}\n\n  /// a persistent-agnostic alternative to TSynPersistentLock\n  // - can be used as base class when custom JSON persistence is not needed\n  // - consider a TRWLock field as a lighter multi read / exclusive write option\n  TSynLocked = class\n  protected\n    fSafe: PSynLocker; // TSynLocker would increase inherited fields offset\n  public\n    /// initialize the instance, and its associated lock\n    // - is defined as virtual, just like TObjectWithCustomCreate/TSynPersistent\n    constructor Create; virtual;\n    /// finalize the instance, and its associated lock\n    destructor Destroy; override;\n    /// access to the associated instance critical section\n    // - call Safe.Lock/UnLock to protect multi-thread access on this storage\n    property Safe: PSynLocker\n      read fSafe;\n  end;\n\n  {$M-}\n\n  /// meta-class definition of the TSynLocked hierarchy\n  TSynLockedClass = class of TSynLocked;\n\n  /// a thread-safe Pierre L'Ecuyer software random generator\n  // - just wrap TLecuyer with a TLighLock\n  // - should not be used, unless may be slightly faster than a threadvar\n  {$ifdef USERECORDWITHMETHODS}\n  TLecuyerThreadSafe = record\n  {$else}\n  TLecuyerThreadSafe = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    Safe: TLightLock;\n    Generator: TLecuyer;\n    /// compute the next 32-bit generated value\n    function Next: cardinal; overload;\n    /// compute a 64-bit floating point value\n    function NextDouble: double;\n    /// XOR some memory buffer with random bytes\n    procedure Fill(dest: pointer; count: integer);\n    /// fill some string[31] with 7-bit ASCII random text\n    procedure FillShort31(var dest: TShort31);\n  end;\n\n  TThreadIDDynArray = array of TThreadID;\n\nvar\n  /// a global thread-safe Pierre L'Ecuyer software random generator\n  // - should not be used, unless may be slightly faster than a threadvar\n  SharedRandom: TLecuyerThreadSafe;\n\n{$ifdef OSPOSIX}\n  /// could be set to TRUE to force SleepHiRes(0) to call the POSIX sched_yield\n  // - in practice, it has been reported as buggy under POSIX systems\n  // - even Linus Torvald himself raged against its usage - see e.g.\n  // https://www.realworldtech.com/forum/?threadid=189711&curpostid=189752\n  // - you may tempt the devil and try it by yourself\n  SleepHiRes0Yield: boolean = false;\n{$endif OSPOSIX}\n\n/// similar to Windows sleep() API call, to be truly cross-platform\n// - using millisecond resolution\n// - SleepHiRes(0) calls ThreadSwitch on Windows, but POSIX version will\n// wait 10 microsecond unless SleepHiRes0Yield is forced to true (bad idea)\n// - in respect to RTL's Sleep() function, it will return on ESysEINTR if was\n// interrupted by any OS signal\n// - warning: wait typically for the next system timer interrupt on Windows,\n// which is every 16ms by default; as a consequence, never rely on the ms\n// supplied value to guess the elapsed time, but call GetTickCount64\nprocedure SleepHiRes(ms: cardinal); overload;\n\n/// similar to Windows sleep() API call, but truly cross-platform and checking\n// the Terminated flag during its wait for quick abort response\n// - returns true if terminated^ was set to true (terminatedvalue)\nfunction SleepHiRes(ms: cardinal; var terminated: boolean;\n  terminatedvalue: boolean = true): boolean; overload;\n\n/// call SleepHiRes() taking count of the activity, in 0/1/5/50/120-250 ms steps\n// - range is agressively designed burning some CPU in favor of responsiveness\n// - should reset start := 0 when some activity occurred, or start := -1 on\n// Windows to avoid any SleepHiRes(0) = SwitchToThread call\n// - would optionally return if terminated^ is set, or event is signaled\n// - returns the current GetTickCount64 value\nfunction SleepStep(var start: Int64; terminated: PBoolean = nil): Int64;\n\n/// compute optimal sleep time as 0/1/5/50 then 120-250 ms steps\n// - is agressively designed burning some CPU in favor of responsiveness\nfunction SleepDelay(elapsed: PtrInt): PtrInt;\n\n/// compute optimal sleep time as SleepStep, in 0/1/5/50/120-250 ms steps\n// - is agressively designed burning some CPU in favor of responsiveness\n// - start=0 would fill its value with tix; start<0 would fill its value with\n// tix-50 so that SleepDelay() would never call SleepHiRes(0)\nfunction SleepStepTime(var start, tix: Int64; endtix: PInt64 = nil): PtrInt;\n\n/// similar to Windows SwitchToThread API call, to be truly cross-platform\n// - call fpnanosleep(10) on POSIX systems, or the homonymous API on Windows\nprocedure SwitchToThread;\n  {$ifdef OSWINDOWS} stdcall; {$endif}\n\n/// try LockedExc() in a loop, calling SwitchToThread after some spinning\nprocedure SpinExc(var Target: PtrUInt; NewValue, Comperand: PtrUInt);\n\n/// wrapper to implement a thread-safe T*ObjArray dynamic array storage\nfunction ObjArrayAdd(var aObjArray; aItem: TObject;\n  var aSafe: TLightLock; aCount: PInteger = nil): PtrInt; overload;\n\n/// wrapper to implement a thread-safe pointer dynamic array storage\nfunction PtrArrayDelete(var aPtrArray; aItem: pointer; var aSafe: TLightLock;\n  aCount: PInteger = nil): PtrInt; overload;\n\n/// try to kill/cancel a thread\n// - on Windows, calls the TerminateThread() API\n// - under Linux/FPC, calls pthread_cancel() API which is asynchronous\nfunction RawKillThread(Thread: TThread): boolean;\n\ntype\n  /// store a bitmask of logical CPU cores, as used by SetThreadMaskAffinity\n  // - has 32/64-bit pointer-size on Windows, or 1024 bits on POSIX\n  TCpuSet = {$ifdef OSWINDOWS} PtrUInt {$else} array[0..127] of byte {$endif};\nvar\n  /// low-level bitmasks of logical CPU cores hosted on each hardware CPU socket\n  // - filled at process startup as CpuSocketsMask[0 .. CpuSockets - 1] range\n  CpuSocketsMask: array of TCpuSet;\n\n/// fill a bitmask of CPU cores with zeros\nprocedure ResetCpuSet(out CpuSet: TCpuSet);\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// set a particular bit in a mask of CPU cores\nfunction SetCpuSet(var CpuSet: TCpuSet; CpuIndex: cardinal): boolean;\n\n/// retrieve the current CPU cores masks available of the system\n// - the current process may have been tuned to use only a sub-set of the cores\n// e.g. via \"taskset -c\" on Linux\n// - return the number of accessible CPU cores - i.e. GetBitsCount(CpuSet) or\n// 0 if the function failed\nfunction CurrentCpuSet(out CpuSet: TCpuSet): integer;\n\n/// try to assign a given thread to a specific set of logical CPU core(s)\n// - on Windows, calls the SetThreadAffinityMask() API\n// - under Linux/FPC, calls pthread_setaffinity_np() API\nfunction SetThreadMaskAffinity(Thread: TThread; const Mask: TCpuSet): boolean;\n\n/// try to assign a given thread to a specific logical CPU core\n// - CpuIndex should be in 0 .. SystemInfo.dwNumberOfProcessors - 1 range\nfunction SetThreadCpuAffinity(Thread: TThread; CpuIndex: cardinal): boolean;\n\n/// try to assign a given thread to a specific hardware CPU socket\n// - SocketIndex should be in 0 .. CpuSockets - 1 range, and will use the\n// CpuSocketsMask[] information retrieved during process startup\nfunction SetThreadSocketAffinity(Thread: TThread; SocketIndex: cardinal): boolean;\n\n/// low-level naming of a thread\n// - on Windows, will raise a standard \"fake\" exception to notify the thread name\n// - under Linux/FPC, calls pthread_setname_np() API which truncates to 16 chars\nprocedure RawSetThreadName(ThreadID: TThreadID; const Name: RawUtf8);\n\n/// name the current thread so that it would be easily identified in the IDE debugger\n// - could then be retrieved by CurrentThreadNameShort/GetCurrentThreadName\n// - just a wrapper around SetThreadName(GetCurrentThreadId, ...)\nprocedure SetCurrentThreadName(const Format: RawUtf8; const Args: array of const); overload;\n\n/// name the current thread so that it would be easily identified in the IDE debugger\n// - could also be retrieved by CurrentThreadNameShort/GetCurrentThreadName\n// - just a wrapper around SetThreadName(GetCurrentThreadId, ...)\nprocedure SetCurrentThreadName(const Name: RawUtf8); overload;\n\nvar\n  /// name a thread so that it would be easily identified in the IDE debugger\n  // - default implementation does nothing, unless mormot.core.log is included\n  // - you can force this function to do nothing by setting the NOSETTHREADNAME\n  // conditional, if you have issues with this feature when debugging your app\n  // - most meaningless patterns (like 'TSql') are trimmed to reduce the\n  // resulting length - which is convenient e.g. with POSIX truncation to 16 chars\n  // - you can retrieve the name later on using CurrentThreadNameShort\n  // - this method will register TSynLog.LogThreadName(), so threads calling it\n  // should also call TSynLogFamily.OnThreadEnded/TSynLog.NotifyThreadEnded\n  SetThreadName: procedure(ThreadID: TThreadID; const Format: RawUtf8;\n    const Args: array of const);\n\n/// low-level access to the thread name, as set by SetThreadName()\n// - since threadvar can't contain managed strings, it is defined as TShort31,\n// so is limited to 31 chars, which is enough since POSIX truncates to 16 chars\n// and SetThreadName does trim meaningless patterns\nfunction CurrentThreadNameShort: PShortString;\n\n/// retrieve the thread name, as set by SetThreadName()\n// - if possible, direct CurrentThreadNameShort function is slightly faster\n// - will return the CurrentThreadNameShort^ threadvar 31 chars value\nfunction GetCurrentThreadName: RawUtf8;\n\n/// returns the thread id and the thread name as a ShortString\n// - returns e.g. 'Thread 0001abcd [shortthreadname]'\n// - for convenient use when logging or raising an exception\nfunction GetCurrentThreadInfo: ShortString;\n\n/// enter a process-wide giant lock for thread-safe shared process\n// - shall be protected as such:\n// ! GlobalLock;\n// ! try\n// !   .... do something thread-safe but as short as possible\n// ! finally\n// !  GlobalUnLock;\n// ! end;\n// - you should better not use such a giant-lock, but an instance-dedicated\n// critical section/TSynLocker or TRWLock - these functions are just here to be\n// convenient, for non time-critical process (e.g. singleton initialization\n// of external libraries, or before RegisterGlobalShutdownRelease() which will\n// use it anyway)\nprocedure GlobalLock;\n\n/// release the giant lock for thread-safe shared process\nprocedure GlobalUnLock;\n\n/// framework will register here some instances to be released eventually\n// - better in this root unit than in each finalization section\n// - its use is protected by the GlobalLock\nfunction RegisterGlobalShutdownRelease(Instance: TObject;\n  SearchExisting: boolean = false): pointer;\n\n\n{ ****************** Unix Daemon and Windows Service Support }\n\ntype\n  /// all possible states of a Windows service\n  // - on POSIX, will identify only if the daemon is ssRunning or ssStopped\n  TServiceState = (\n    ssNotInstalled,\n    ssStopped,\n    ssStarting,\n    ssStopping,\n    ssRunning,\n    ssResuming,\n    ssPausing,\n    ssPaused,\n    ssFailed,\n    ssErrorRetrievingState);\n  PServiceState = ^TServiceState;\n  TServiceStateDynArray = array of TServiceState;\n\n/// return the ready to be displayed text of a TServiceState value\nfunction ToText(st: TServiceState): PShortString; overload;\n\nconst\n  /// could be used with ConsoleWrite() to notify a Windows service state\n  SERVICESTATE_COLOR: array[TServiceState] of TConsoleColor = (\n    ccBlue,       // NotInstalled\n    ccLightRed,   // Stopped\n    ccGreen,      // Starting\n    ccRed,        // Stopping\n    ccLightGreen, // Running\n    ccGreen,      // Resuming\n    ccBrown,      // Pausing\n    ccWhite,      // Paused\n    ccMagenta,    // Failed\n    ccYellow);    // ErrorRetrievingState\n\n\n{$ifdef OSWINDOWS}\n\n{ *** some minimal Windows API definitions, replacing WinSvc.pas missing for FPC }\n\nconst\n  SERVICE_QUERY_CONFIG         = $0001;\n  SERVICE_CHANGE_CONFIG        = $0002;\n  SERVICE_QUERY_STATUS         = $0004;\n  SERVICE_ENUMERATE_DEPENDENTS = $0008;\n  SERVICE_START                = $0010;\n  SERVICE_STOP                 = $0020;\n  SERVICE_PAUSE_CONTINUE       = $0040;\n  SERVICE_INTERROGATE          = $0080;\n  SERVICE_USER_DEFINED_CONTROL = $0100;\n  SERVICE_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED or\n                                 SERVICE_QUERY_CONFIG or\n                                 SERVICE_CHANGE_CONFIG or\n                                 SERVICE_QUERY_STATUS or\n                                 SERVICE_ENUMERATE_DEPENDENTS or\n                                 SERVICE_START or\n                                 SERVICE_STOP or\n                                 SERVICE_PAUSE_CONTINUE or\n                                 SERVICE_INTERROGATE or\n                                 SERVICE_USER_DEFINED_CONTROL;\n\n  SC_MANAGER_CONNECT            = $0001;\n  SC_MANAGER_CREATE_SERVICE     = $0002;\n  SC_MANAGER_ENUMERATE_SERVICE  = $0004;\n  SC_MANAGER_LOCK               = $0008;\n  SC_MANAGER_QUERY_LOCK_STATUS  = $0010;\n  SC_MANAGER_MODIFY_BOOT_CONFIG = $0020;\n  SC_MANAGER_ALL_ACCESS         = STANDARD_RIGHTS_REQUIRED or\n                                  SC_MANAGER_CONNECT or\n                                  SC_MANAGER_CREATE_SERVICE or\n                                  SC_MANAGER_ENUMERATE_SERVICE or\n                                  SC_MANAGER_LOCK or\n                                  SC_MANAGER_QUERY_LOCK_STATUS or\n                                  SC_MANAGER_MODIFY_BOOT_CONFIG;\n\n  SERVICE_CONFIG_DESCRIPTION    = $0001;\n\n  SERVICE_WIN32_OWN_PROCESS     = $00000010;\n  SERVICE_WIN32_SHARE_PROCESS   = $00000020;\n  SERVICE_INTERACTIVE_PROCESS   = $00000100;\n\n  SERVICE_BOOT_START            = $00000000;\n  SERVICE_SYSTEM_START          = $00000001;\n  SERVICE_AUTO_START            = $00000002;\n  SERVICE_DEMAND_START          = $00000003;\n  SERVICE_DISABLED              = $00000004;\n  SERVICE_ERROR_IGNORE          = $00000000;\n  SERVICE_ERROR_NORMAL          = $00000001;\n  SERVICE_ERROR_SEVERE          = $00000002;\n  SERVICE_ERROR_CRITICAL        = $00000003;\n\n  SERVICE_CONTROL_STOP          = $00000001;\n  SERVICE_CONTROL_PAUSE         = $00000002;\n  SERVICE_CONTROL_CONTINUE      = $00000003;\n  SERVICE_CONTROL_INTERROGATE   = $00000004;\n  SERVICE_CONTROL_SHUTDOWN      = $00000005;\n\n  SERVICE_STOPPED               = $00000001;\n  SERVICE_START_PENDING         = $00000002;\n  SERVICE_STOP_PENDING          = $00000003;\n  SERVICE_RUNNING               = $00000004;\n  SERVICE_CONTINUE_PENDING      = $00000005;\n  SERVICE_PAUSE_PENDING         = $00000006;\n  SERVICE_PAUSED                = $00000007;\n\n  ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063;\n\ntype\n  PServiceStatus = ^TServiceStatus;\n  TServiceStatus = record\n    dwServiceType: cardinal;\n    dwCurrentState: cardinal;\n    dwControlsAccepted: cardinal;\n    dwWin32ExitCode: cardinal;\n    dwServiceSpecificExitCode: cardinal;\n    dwCheckPoint: cardinal;\n    dwWaitHint: cardinal;\n  end;\n\n  PServiceStatusProcess = ^TServiceStatusProcess;\n  TServiceStatusProcess = record\n    Service: TServiceStatus;\n    dwProcessId: cardinal;\n    dwServiceFlags: cardinal;\n  end;\n\n  SC_HANDLE = THandle;\n  SERVICE_STATUS_HANDLE = THandle;\n  TServiceTableEntry = record\n    lpServiceName: PWideChar;\n    lpServiceProc: procedure(ArgCount: cardinal; Args: PPWideChar); stdcall;\n  end;\n  PServiceTableEntry = ^TServiceTableEntry;\n  TServiceDescription = record\n    lpDestription: PWideChar;\n  end;\n\n  {$Z4}\n  SC_STATUS_TYPE = (SC_STATUS_PROCESS_INFO);\n  {$Z1}\n\nfunction OpenSCManagerW(lpMachineName, lpDatabaseName: PWideChar;\n  dwDesiredAccess: cardinal): SC_HANDLE; stdcall; external advapi32;\nfunction ChangeServiceConfig2W(hService: SC_HANDLE; dwsInfoLevel: cardinal;\n  lpInfo: Pointer): BOOL; stdcall; external advapi32;\nfunction StartServiceW(hService: SC_HANDLE; dwNumServiceArgs: cardinal;\n  lpServiceArgVectors: PPWideChar): BOOL; stdcall; external advapi32;\nfunction CreateServiceW(hSCManager: SC_HANDLE;\n  lpServiceName, lpDisplayName: PWideChar;\n  dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl: cardinal;\n  lpBinaryPathName, lpLoadOrderGroup: PWideChar; lpdwTagId: LPDWORD; lpDependencies,\n  lpServiceStartName, lpPassword: PWideChar): SC_HANDLE; stdcall; external advapi32;\nfunction OpenServiceW(hSCManager: SC_HANDLE; lpServiceName: PWideChar;\n  dwDesiredAccess: cardinal): SC_HANDLE; stdcall; external advapi32;\nfunction DeleteService(hService: SC_HANDLE): BOOL; stdcall; external advapi32;\nfunction CloseServiceHandle(hSCObject: SC_HANDLE): BOOL; stdcall; external advapi32;\nfunction QueryServiceStatus(hService: SC_HANDLE;\n  var lpServiceStatus: TServiceStatus): BOOL; stdcall; external advapi32;\nfunction QueryServiceStatusEx(hService: SC_HANDLE;\n  InfoLevel: SC_STATUS_TYPE; lpBuffer: Pointer; cbBufSize: cardinal;\n  var pcbBytesNeeded: cardinal): BOOL; stdcall; external advapi32;\nfunction ControlService(hService: SC_HANDLE; dwControl: cardinal;\n  var lpServiceStatus: TServiceStatus): BOOL; stdcall; external advapi32;\nfunction SetServiceStatus(hServiceStatus: SERVICE_STATUS_HANDLE;\n  var lpServiceStatus: TServiceStatus): BOOL; stdcall; external advapi32;\nfunction RegisterServiceCtrlHandlerW(lpServiceName: PWideChar;\n  lpHandlerProc: TFarProc): SERVICE_STATUS_HANDLE; stdcall; external advapi32;\nfunction StartServiceCtrlDispatcherW(\n  lpServiceStartTable: PServiceTableEntry): BOOL; stdcall; external advapi32;\n\nfunction OpenServiceManager(const TargetComputer, DatabaseName: RawUtf8;\n  dwDesiredAccess: cardinal): SC_HANDLE;\nfunction OpenServiceInstance(hSCManager: SC_HANDLE; const ServiceName: RawUtf8;\n  dwDesiredAccess: cardinal): SC_HANDLE;\n\n\n{ *** high level classes to define and manage Windows Services }\n\nvar\n  /// can be assigned from TSynLog.DoLog class method for\n  // TServiceController/TService logging\n  // - default is nil, i.e. disabling logging, since it may interfere with the\n  // logging process of the Windows Service itself\n  WindowsServiceLog: TSynLogProc;\n\ntype\n  /// TServiceControler class is intended to create a new Windows Service instance\n  // or to maintain (that is start, stop, pause, resume...) an existing Service\n  // - to provide the service itself, use the TService class\n  TServiceController = class\n  protected\n    fSCHandle: THandle;\n    fHandle: THandle;\n    fStatus: TServiceStatus;\n    fName: RawUtf8;\n  protected\n    function GetStatus: TServiceStatus;\n    function GetState: TServiceState;\n  public\n    /// create a new Windows Service and control it and/or its configuration\n    // - TargetComputer - set it to empty string if local computer is the target.\n    // - DatabaseName - set it to empty string if the default database is supposed\n    // ('ServicesActive').\n    // - Name - name of a service.\n    // - DisplayName - display name of a service.\n    // - Path - a path to binary (executable) of the service created.\n    // - OrderGroup - an order group name (unnecessary)\n    // - Dependencies - string containing a list with names of services, which must\n    // start before this service (every name should be separated with ';' or an\n    // empty string can be passed if there is no dependency).\n    // - Username - login name. For service type SERVICE_WIN32_OWN_PROCESS, the\n    // account name in the form of \"DomainName\\Username\"; If the account\n    // belongs to the built-in domain, \".\\Username\" can be specified;\n    // Services of type SERVICE_WIN32_SHARE_PROCESS are not allowed to\n    // specify an account other than LocalSystem. If '' is specified, the\n    // service will be logged on as the 'LocalSystem' account, in which\n    // case, the Password parameter must be empty too.\n    // - Password - a password for login name. If the service type is\n    // SERVICE_KERNEL_DRIVER or SERVICE_FILE_SYSTEM_DRIVER,\n    // this parameter is ignored.\n    // - DesiredAccess - a combination of following flags:\n    // SERVICE_ALL_ACCESS (default value), SERVICE_CHANGE_CONFIG,\n    // SERVICE_ENUMERATE_DEPENDENTS, SERVICE_INTERROGATE, SERVICE_PAUSE_CONTINUE,\n    // SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS, SERVICE_START, SERVICE_STOP,\n    // SERVICE_USER_DEFINED_CONTROL\n    // - ServiceType - a set of following flags:\n    // SERVICE_WIN32_OWN_PROCESS (default value, which specifies a Win32 service\n    // that runs in its own process), SERVICE_WIN32_SHARE_PROCESS,\n    // SERVICE_KERNEL_DRIVER, SERVICE_FILE_SYSTEM_DRIVER,\n    // SERVICE_INTERACTIVE_PROCESS (default value, which enables a Win32 service\n    // process to interact with the desktop)\n    // - StartType - one of following values:\n    // SERVICE_BOOT_START, SERVICE_SYSTEM_START,\n    // SERVICE_AUTO_START (which specifies a device driver or service started by\n    // the service control manager automatically during system startup),\n    // SERVICE_DEMAND_START (default value, which specifies a service started by\n    // a service control manager when a process calls the StartService function,\n    // that is the TServiceController.Start method), SERVICE_DISABLED\n    // - ErrorControl - one of following:\n    // SERVICE_ERROR_IGNORE, SERVICE_ERROR_NORMAL (default value, by which\n    // the startup program logs the error and displays a message but continues\n    // the startup operation), SERVICE_ERROR_SEVERE,\n    // SERVICE_ERROR_CRITICAL\n    constructor CreateNewService(\n      const TargetComputer, DatabaseName, Name, DisplayName: RawUtf8;\n      const Path: TFileName;\n      const OrderGroup: RawUtf8 = ''; const Dependencies: RawUtf8 = '';\n      const Username: RawUtf8 = ''; const Password: RawUtf8 = '';\n      DesiredAccess: cardinal = SERVICE_ALL_ACCESS;\n      ServiceType: cardinal = SERVICE_WIN32_OWN_PROCESS or SERVICE_INTERACTIVE_PROCESS;\n      StartType: cardinal = SERVICE_DEMAND_START;\n      ErrorControl: cardinal = SERVICE_ERROR_NORMAL);\n    /// wrapper around CreateNewService() to install the current executable as service\n    class function Install(const Name, DisplayName, Description: RawUtf8;\n      AutoStart: boolean; ExeName: TFileName = '';\n      const Dependencies: RawUtf8 = ''; const UserName: RawUtf8 = '';\n      const Password: RawUtf8 = ''): TServiceState;\n    /// wrapper around CreateOpenService(SERVICE_QUERY_STATUS) and GetState\n    class function CurrentState(const Name: RawUtf8): TServiceState;\n    /// open an existing service, in order to control it or its configuration\n    // from your application\n    // - TargetComputer - set it to empty string if local computer is the target.\n    // - DatabaseName - set it to empty string if the default database is supposed\n    // ('ServicesActive').\n    // - Name - name of a service.\n    // - DesiredAccess - a combination of following flags:\n    // SERVICE_ALL_ACCESS, SERVICE_CHANGE_CONFIG, SERVICE_ENUMERATE_DEPENDENTS,\n    // SERVICE_INTERROGATE, SERVICE_PAUSE_CONTINUE, SERVICE_QUERY_CONFIG,\n    // SERVICE_QUERY_STATUS, SERVICE_START, SERVICE_STOP, SERVICE_USER_DEFINED_CONTROL\n    constructor CreateOpenService(\n      const TargetComputer, DataBaseName, Name: RawUtf8;\n      DesiredAccess: cardinal = SERVICE_ALL_ACCESS);\n    /// release memory and handles\n    destructor Destroy; override;\n    /// Handle of SC manager\n    property SCHandle: THandle\n      read fSCHandle;\n    /// Handle of service opened or created\n    // - its value is 0 if something failed in any Create*() method\n    property Handle: THandle\n      read fHandle;\n    /// Retrieve the Current status of the service\n    property Status: TServiceStatus\n      read GetStatus;\n    /// Retrieve the Current state of the service\n    property State: TServiceState\n      read GetState;\n    /// Requests the service to stop\n    function Stop: boolean;\n    /// Requests the service to pause\n    function Pause: boolean;\n    /// Requests the paused service to resume\n    function Resume: boolean;\n    /// Requests the service to update immediately its current status information\n    // to the service control manager\n    function Refresh: boolean;\n    /// Request the service to shutdown\n    // - this function always return false\n    function Shutdown: boolean;\n    /// Removes service from the system, i.e. close the Service\n    function Delete: boolean;\n    /// starts the execution of a service with some specified arguments\n    // - this version expect PWideChar pointers, i.e. UTF-16 strings\n    function Start(const Args: array of PWideChar): boolean;\n    /// try to define the description text of this service\n    function SetDescription(const Description: RawUtf8): boolean;\n    /// this class method will check the command line parameters, and will let\n    //  control the service according to it\n    // - MyServiceSetup.exe /install will install the service\n    // - MyServiceSetup.exe /start   will start the service\n    // - MyServiceSetup.exe /stop    will stop the service\n    // - MyServiceSetup.exe /uninstall will uninstall the service\n    // - so that you can write in the main block of your .dpr:\n    // !CheckParameters('MyService.exe',HTTPSERVICENAME,HTTPSERVICEDISPLAYNAME);\n    // - if ExeFileName='', it will install the current executable\n    // - optional Description and Dependencies text may be specified\n    class procedure CheckParameters(const ExeFileName: TFileName;\n      const ServiceName, DisplayName, Description: RawUtf8;\n      const Dependencies: RawUtf8 = '');\n  end;\n\n  {$M+}\n  TService = class;\n  {$M-}\n\n  /// callback procedure for Windows Service Controller\n  TServiceControlHandler = procedure(CtrlCode: cardinal); stdcall;\n\n  /// event triggered for Control handler\n  TServiceControlEvent = procedure(Sender: TService; Code: cardinal) of object;\n\n  /// event triggered to implement the Service functionality\n  TServiceEvent = procedure(Sender: TService) of object;\n\n  /// abstract class to let an executable implement a Windows Service\n  // - do not use this class directly, but TServiceSingle\n  TService = class\n  protected\n    fServiceName: RawUtf8;\n    fDisplayName: RawUtf8;\n    fStartType: cardinal;\n    fServiceType: cardinal;\n    fData: cardinal;\n    fControlHandler: TServiceControlHandler;\n    fOnControl: TServiceControlEvent;\n    fOnInterrogate: TServiceEvent;\n    fOnPause: TServiceEvent;\n    fOnShutdown: TServiceEvent;\n    fOnStart: TServiceEvent;\n    fOnExecute: TServiceEvent;\n    fOnResume: TServiceEvent;\n    fOnStop: TServiceEvent;\n    fStatusRec: TServiceStatus;\n    fArgsList: TRawUtf8DynArray;\n    fStatusHandle: THandle;\n    function GetArgCount: Integer;\n    function GetArgs(Idx: Integer): RawUtf8;\n    function GetInstalled: boolean;\n    procedure SetStatus(const Value: TServiceStatus);\n    procedure CtrlHandle(Code: cardinal);\n    function GetControlHandler: TServiceControlHandler;\n    procedure SetControlHandler(const Value: TServiceControlHandler);\n    procedure ServiceProc(ArgCount: integer; Args: PPWideChar);\n  public\n    /// internal method redirecting to WindowsServiceLog global variable\n    class procedure DoLog(Level: TSynLogLevel; const Fmt: RawUtf8;\n      const Args: array of const; Instance: TObject);\n    /// Creates the service\n    // - the service is added to the internal registered services\n    // - main application must instantiate the TServiceSingle class, then call\n    // the global ServiceSingleRun procedure to actually start the services\n    // - caller must free the TService instance when it's no longer used\n    constructor Create(const aServiceName, aDisplayName: RawUtf8); reintroduce; virtual;\n    /// this method is the main service entrance, from the OS point of view\n    // - it will call OnControl/OnStop/OnPause/OnResume/OnShutdown events\n    // - and report the service status to the system (via ReportStatus method)\n    procedure DoCtrlHandle(Code: cardinal); virtual;\n    /// Reports new status to the system\n    function ReportStatus(dwState, dwExitCode, dwWait: cardinal): BOOL;\n    /// Installs the service in the database\n    // - return true on success\n    // - create a local TServiceController with the current executable file,\n    // with the supplied command line parameters\n    // - you can optionally append some parameters, which will be appended\n    // to the\n    function Install(const Params: TFileName = ''): boolean;\n    /// Removes the service from database\n    //  - uses a local TServiceController with the current Service Name\n    procedure Remove;\n    /// Starts the service\n    //  - uses a local TServiceController with the current Service Name\n    procedure Start;\n    /// Stops the service\n    // - uses a local TServiceController with the current Service Name\n    procedure Stop;\n    /// this is the main method, in which the Service should implement its run\n    procedure Execute; virtual;\n\n    /// Number of arguments passed to the service by the service controler\n    property ArgCount: Integer\n      read GetArgCount;\n    /// List of arguments passed to the service by the service controler\n    // - Idx is in range 0..ArgCount - 1\n    property Args[Idx: Integer]: RawUtf8\n      read GetArgs;\n    /// Any data You wish to associate with the service object\n    property Data: cardinal\n      read FData write FData;\n    /// Whether service is installed in DataBase\n    // - uses a local TServiceController to check if the current Service Name exists\n    property Installed: boolean\n      read GetInstalled;\n    /// Current service status\n    // - To report new status to the system, assign another\n    // value to this record, or use ReportStatus method (preferred)\n    property Status: TServiceStatus\n      read fStatusRec write SetStatus;\n    /// Callback handler for Windows Service Controller\n    // - if handler is not set, then auto generated handler calls DoCtrlHandle\n    // (note that this auto-generated stubb is... not working yet - so you should\n    // either set your own procedure to this property, or use TServiceSingle)\n    // - a typical control handler may be defined as such:\n    // ! var MyGlobalService: TService;\n    // !\n    // ! procedure MyServiceControlHandler(Opcode: LongWord); stdcall;\n    // ! begin\n    // !   if MyGlobalService<>nil then\n    // !     MyGlobalService.DoCtrlHandle(Opcode);\n    // ! end;\n    // !\n    // ! ...\n    // ! MyGlobalService := TService.Create(...\n    // ! MyGlobalService.ControlHandler := MyServiceControlHandler;\n    property ControlHandler: TServiceControlHandler\n      read GetControlHandler write SetControlHandler;\n    /// Start event is executed before the main service thread (i.e. in the Execute method)\n    property OnStart: TServiceEvent\n      read fOnStart write fOnStart;\n    /// custom Execute event\n    // - launched in the main service thread (i.e. in the Execute method)\n    property OnExecute: TServiceEvent\n      read fOnExecute write fOnExecute;\n    /// custom event triggered when a Control Code is received from Windows\n    property OnControl: TServiceControlEvent\n      read fOnControl write fOnControl;\n    /// custom event triggered when the service is stopped\n    property OnStop: TServiceEvent\n      read fOnStop write fOnStop;\n    /// custom event triggered when the service is paused\n    property OnPause: TServiceEvent\n      read fOnPause write fOnPause;\n    /// custom event triggered when the service is resumed\n    property OnResume: TServiceEvent\n      read fOnResume write fOnResume;\n    /// custom event triggered when the service receive an Interrogate command\n    // - could call ReportStatus() e.g. to notify a problem\n    property OnInterrogate: TServiceEvent\n      read fOnInterrogate write fOnInterrogate;\n    /// custom event triggered when the service is shut down\n    property OnShutdown: TServiceEvent\n      read fOnShutdown write fOnShutdown;\n  published\n    /// Name of the service. Must be unique\n    property ServiceName: RawUtf8\n      read fServiceName;\n    /// Display name of the service\n    property DisplayName: RawUtf8\n      read fDisplayName write fDisplayName;\n    /// Type of service\n    property ServiceType: cardinal\n      read fServiceType write fServiceType;\n    /// Type of start of service\n    property StartType: cardinal\n      read fStartType write fStartType;\n  end;\n\n  /// inherit from this class if your application has a single Windows Service\n  // - note that only this single-service implementation is available by now\n  // - the regular way of executing services is to instantiate a TServiceSingle\n  // instance (which will fill the ServiceSingle variable) and its methods,\n  // then eventually call ServiceSingleRun\n  TServiceSingle = class(TService)\n  public\n    /// will set a global function as service controller\n    constructor Create(const aServiceName, aDisplayName: RawUtf8); override;\n    /// will release the global service controller\n    destructor Destroy; override;\n  end;\n\nvar\n  /// the main TServiceSingle instance running in the current executable\n  // - the regular way of executing services is to instantiate a TServiceSingle\n  // instance (which will fill this ServiceSingle variable) and its methods,\n  // then eventually call ServiceSingleRun\n  ServiceSingle: TServiceSingle = nil;\n\n/// launch the registered Service execution\n// - ServiceSingle provided by this application (most probably from\n// TServiceSingle.Create) is sent to the operating system\n// - returns TRUE on success\n// - returns FALSE on error (to get extended information, call GetLastError)\nfunction ServiceSingleRun: boolean;\n\n/// convert the Control Code retrieved from Windows into a service state\n// enumeration item\nfunction CurrentStateToServiceState(CurrentState: cardinal): TServiceState;\n\n/// return the ProcessID of a given service, by name\nfunction GetServicePid(const aServiceName: RawUtf8;\n  aServiceState: PServiceState = nil): cardinal;\n\n/// try to gently stop a given Windows console app from its ProcessID\n// - will send a Ctrl-C event (acquiring the process console)\nfunction CancelProcess(pid: cardinal; waitseconds: integer): boolean;\n\n/// try to gently quit a Windows process from its ProcessID\n// - will send a WM_QUIT message to all its threads\nfunction QuitProcess(pid: cardinal; waitseconds: integer): boolean;\n\n/// forcibly terminate a Windows process from its ProcessID\n// - call TerminateProcess() and wait for its ending\nfunction KillProcess(pid: cardinal; waitseconds: integer = 30): boolean;\n\n/// install a Windows event handler for Ctrl+C pressed on the Console\nfunction HandleCtrlC(const OnClose: TThreadMethod): boolean;\n\n/// define a Windows Job to close associated processes together\n// - warning: main process should include the CREATE_BREAKAWAY_FROM_JOB flag\n// - you should later call CloseHandle() on the returned handle, if not 0 \nfunction CreateJobToClose(parentpid: cardinal): THandle;\n\n/// associate a process to a Windows Job created by CreateJobToClose()\nfunction AssignJobToProcess(job, process: THandle; const ctxt: ShortString): boolean;\n\n{$else}\n\n/// low-level function able to properly run or fork the current process\n// then execute the start/stop methods of a TSynDaemon / TDDDDaemon instance\n// - fork will create a local /run/[ProgramName]-[ProgramPathHash].pid file name\n// - onLog can be assigned from TSynLog.DoLog for proper logging\nprocedure RunUntilSigTerminated(daemon: TObject; dofork: boolean;\n  const start, stop: TThreadMethod; const onlog: TSynLogProc = nil;\n  const servicename: string = '');\n\n/// kill a process previously created by RunUntilSigTerminated(dofork=true)\n// - will lookup a local /run/[ProgramName]-[ProgramPathHash].pid file name to\n// retrieve the actual PID to be killed, then send a SIGTERM, and wait\n// waitseconds for the .pid file to disapear\n// - returns true on success, false on error (e.g. no valid .pid file or\n// the file didn't disappear, which may mean that the daemon is broken)\nfunction RunUntilSigTerminatedForKill(waitseconds: integer = 30): boolean;\n\nvar\n  /// optional folder where the .pid is created\n  // - should include a trailing '/' character\n  // - to be used if the current executable folder is read/only\n  RunUntilSigTerminatedPidFilePath: TFileName;\n\n/// local .pid file name as created by RunUntilSigTerminated(dofork=true)\nfunction RunUntilSigTerminatedPidFile(ensureWritable: boolean = false): TFileName;\n\n/// check the local .pid file to return either ssRunning or ssStopped\nfunction RunUntilSigTerminatedState: TServiceState;\n\nvar\n  /// once SynDaemonIntercept has been called, this global variable\n  // contains the SIGQUIT / SIGTERM / SIGINT received signal\n  SynDaemonTerminated: integer;\n\n/// enable low-level interception of executable stop signals\n// - any SIGQUIT / SIGTERM / SIGINT signal will set appropriately the global\n// SynDaemonTerminated variable, with an optional logged entry to log\n// - called e.g. by RunUntilSigTerminated() or ConsoleWaitForEnterKey()\n// - you can call this method several times with no issue\n// - onLog can be assigned from TSynLog.DoLog for proper logging\nprocedure SynDaemonIntercept(const onlog: TSynLogProc = nil);\n\n/// disable SIGPIPE signal for the current process\n// - is called e.g. by NewOpenSslNetTls since the OpenSsl TLS layer does not\n// (yet) use MSG_NOSIGNAL when accessing the socket\nprocedure SigPipeIntercept;\n\n{$endif OSWINDOWS}\n\n/// change the current UID/GID to another user, by name\n// - only implemented on POSIX by now\nfunction DropPriviledges(const UserName: RawUtf8 = 'nobody'): boolean;\n\n/// changes the root directory of the calling process\n// - only implemented on POSIX by now\nfunction ChangeRoot(const FolderName: RawUtf8): boolean;\n\ntype\n  /// command line patterns recognized by ParseCommandArgs()\n  TParseCommand = (\n    pcHasRedirection,\n    pcHasSubCommand,\n    pcHasParenthesis,\n    pcHasJobControl,\n    pcHasWildcard,\n    pcHasShellVariable,\n    pcUnbalancedSingleQuote,\n    pcUnbalancedDoubleQuote,\n    pcTooManyArguments,\n    pcInvalidCommand,\n    pcHasEndingBackSlash);\n\n  TParseCommands = set of TParseCommand;\n  PParseCommands = ^TParseCommands;\n\n  /// used to store references of arguments recognized by ParseCommandArgs()\n  TParseCommandsArgs = array[0..31] of PAnsiChar;\n  PParseCommandsArgs = ^TParseCommandsArgs;\n\nconst\n  /// identifies some bash-specific processing\n  PARSECOMMAND_BASH =\n    [pcHasRedirection .. pcHasShellVariable];\n\n  /// identifies obvious invalid content\n  PARSECOMMAND_ERROR =\n    [pcUnbalancedSingleQuote .. pcHasEndingBackSlash];\n\n  PARSCOMMAND_POSIX = {$ifdef OSWINDOWS} false {$else} true {$endif};\n\n/// low-level parsing of a RunCommand() execution command\n// - parse and fills argv^[0..argc^-1] with corresponding arguments, after\n// un-escaping and un-quoting if applicable, using temp^ to store the content\n// - if argv=nil, do only the parsing, not the argument extraction - could be\n// used for fast validation of the command line syntax\n// - you can force arguments OS flavor using the posix parameter - note that\n// Windows parsing is not consistent by itself (e.g. double quoting or\n// escaping depends on the actual executable called) so returned flags\n// should be considered as indicative only with posix=false\nfunction ParseCommandArgs(const cmd: RawUtf8; argv: PParseCommandsArgs = nil;\n  argc: PInteger = nil; temp: PRawUtf8 = nil;\n  posix: boolean = PARSCOMMAND_POSIX): TParseCommands;\n\n/// low-level extration of the executable of a RunCommand() execution command\n// - returns the first parameter returned by ParseCommandArgs()\nfunction ExtractExecutableName(const cmd: RawUtf8;\n  posix: boolean = PARSCOMMAND_POSIX): RawUtf8;\n\ntype\n  /// callback used by RunRedirect() to notify of console output at runtime\n  // - newly console output text is given as raw bytes sent by the application,\n  // with no conversion: on POSIX, it is likely to be UTF-8 but on Windows it\n  // depends on the actual program so is likely to be CP_OEM but others could\n  // use the system code page or even UTF-16 binary with BOM (!) - so you\n  // may consider using AnsiToUtf8() with the proper code page\n  // - should return true to stop the execution, or false to continue\n  // - is called once when the process is started, with text='', ignoring its return\n  // - on idle state (each 200ms), is called with text='' to allow execution abort\n  // - the raw process ID (dword on Windows, cint on POSIX) is also supplied\n  TOnRedirect = function(const text: RawByteString; pid: cardinal): boolean of object;\n\n  /// define how RunCommand() and RunRedirect() run their sub-process\n  // - roEnvAddExisting is used when the env pairs should be added to the\n  // existing system environment variable\n  // - roWinJobCloseChildren will setup a Windows Job to close any child\n  // process(es) when the created process quits\n  // - roWinNoProcessDetach will avoid creating a Windows sub-process and group\n  TRunOptions = set of (\n    roEnvAddExisting,\n    roWinJobCloseChildren,\n    roWinNoProcessDetach);\n\n/// like SysUtils.ExecuteProcess, but allowing not to wait for the process to finish\n// - optional env value follows 'n1=v1'#0'n2=v2'#0'n3=v3'#0#0 Windows layout\nfunction RunProcess(const path, arg1: TFileName; waitfor: boolean;\n  const arg2: TFileName = ''; const arg3: TFileName = '';\n  const arg4: TFileName = ''; const arg5: TFileName = '';\n  const env: TFileName = ''; options: TRunOptions = []): integer;\n\n/// like fpSystem, but cross-platform\n// - under POSIX, calls bash only if needed, after ParseCommandArgs() analysis\n// - under Windows (especially Windows 10), creating a process can be dead slow\n// https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess\n// - waitfordelayms/processhandle/redirected/onoutput exist on Windows only -\n// and redirected is the raw byte output, which may be OEM, WinAnsi or UTF-16\n// depending on the program itself\n// - parsed is implemented on POSIX only\n// - optional env should be encoded as 'n1=v1'#0'n2=v2'#0#0 pairs\nfunction RunCommand(const cmd: TFileName; waitfor: boolean;\n  const env: TFileName = ''; options: TRunOptions = [];\n  {$ifdef OSWINDOWS}\n  waitfordelayms: cardinal = INFINITE; processhandle: PHandle = nil;\n  redirected: PRawByteString = nil; const onoutput: TOnRedirect = nil;\n  const wrkdir: TFileName = ''\n  {$else}\n  parsed: PParseCommands = nil\n  {$endif OSWINDOWS}): integer;\n\n/// execute a command, returning its output console as UTF-8 text\n// - calling CreateProcessW on Windows (i.e. our RunCommand), and FPC RTL\n// popen/pclose on POSIX\n// - return '' on cmd execution error, or the whole output console content\n// with no conversion: on POSIX, it is likely to be UTF-8 but on Windows it\n// depends on the actual program so is likely to be CP_OEM but others could\n// use the system code page or even UTF-16 binary with BOM (!) - so you\n// may consider using AnsiToUtf8() with the proper code page\n// - will optionally call onoutput() to notify the new output state\n// - aborts if onoutput() callback returns true, or waitfordelayms expires\n// - optional env is Windows only, (FPC popen does not support it), and should\n// be encoded as name=value#0 pairs\n// - you can specify a wrkdir if the path specified by cmd is not good enough\nfunction RunRedirect(const cmd: TFileName; exitcode: PInteger = nil;\n  const onoutput: TOnRedirect = nil; waitfordelayms: cardinal = INFINITE;\n  setresult: boolean = true; const env: TFileName = '';\n  const wrkdir: TFileName = ''; options: TRunOptions = []): RawByteString;\n\nvar\n  /// how many seconds we should wait for gracefull termination of a process\n  // in RunRedirect() - or RunCommand() on Windows\n  // - set 0 to disable gracefull exit, and force hard SIGKILL/TerminateProcess\n  RunAbortTimeoutSecs: integer = 5;\n\n{$ifdef OSWINDOWS}\ntype\n  /// how RunRedirect() or RunCommand() should try to gracefully terminate\n  // - ramCtrlC calls CancelProcess(), i.e. send CTRL_C_EVENT\n  // - ramQuit calls QuitProcess(), i.e. send WM_QUIT on all the process threads\n  // - note that TerminateProcess is always called after RunAbortTimeoutSecs\n  // timeout, or if this set of methods is void\n  TRunAbortMethods = set of (ramCtrlC, ramQuit);\nvar\n  /// RunRedirect/RunCommand methods to gracefully terminate before TerminateProcess\n  RunAbortMethods: TRunAbortMethods = [ramCtrlC, ramQuit];\n{$else}\ntype\n  /// how RunRedirect() should try to gracefully terminate\n  // - ramSigTerm send a fpkill(pid, SIGTERM) to the process\n  // - note that SIGKILL is always sent after RunAbortTimeoutSecs timeout,\n  // or if ramSigTerm was not supplied\n  TRunAbortMethods = set of (ramSigTerm);\nvar\n  /// RunRedirect() methods to gracefully terminate before SIGKILL\n  RunAbortMethods: TRunAbortMethods = [ramSigTerm];\n{$endif OSWINDOWS}\n\n\nimplementation\n\n// those include files hold all OS-specific functions\n// note: the *.inc files start with their own \"uses\" clause, so both $include\n// should remain here, just after the \"implementation\" clause\n\n{$ifdef OSPOSIX}\n  {$include mormot.core.os.posix.inc}\n{$endif OSPOSIX}\n\n{$ifdef OSWINDOWS}\n  {$include mormot.core.os.windows.inc}\n{$endif OSWINDOWS}\n\n\n{ ****************** Some Cross-System Type and Constant Definitions }\n\nconst\n  // StatusCodeToReason() StatusCodeToText() table to avoid memory allocations\n  // - roughly sorted by actual usage order for WordScanIndex()\n  HTTP_REASON: array[0..43] of RawUtf8 = (\n   'OK',                                // HTTP_SUCCESS - should be first\n   'No Content',                        // HTTP_NOCONTENT\n   'Temporary Redirect',                // HTTP_TEMPORARYREDIRECT\n   'Permanent Redirect',                // HTTP_PERMANENTREDIRECT\n   'Moved Permanently',                 // HTTP_MOVEDPERMANENTLY\n   'Bad Request',                       // HTTP_BADREQUEST\n   'Unauthorized',                      // HTTP_UNAUTHORIZED\n   'Forbidden',                         // HTTP_FORBIDDEN\n   'Not Found',                         // HTTP_NOTFOUND\n   'Method Not Allowed',                // HTTP_NOTALLOWED\n   'Not Modified',                      // HTTP_NOTMODIFIED\n   'Not Acceptable',                    // HTTP_NOTACCEPTABLE\n   'Partial Content',                   // HTTP_PARTIALCONTENT\n   'Payload Too Large',                 // HTTP_PAYLOADTOOLARGE\n   'Created',                           // HTTP_CREATED\n   'See Other',                         // HTTP_SEEOTHER\n   'Continue',                          // HTTP_CONTINUE\n   'Switching Protocols',               // HTTP_SWITCHINGPROTOCOLS\n   'Accepted',                          // HTTP_ACCEPTED\n   'Non-Authoritative Information',     // HTTP_NONAUTHORIZEDINFO\n   'Reset Content',                     // HTTP_RESETCONTENT\n   'Multi-Status',                      // 207\n   'Multiple Choices',                  // HTTP_MULTIPLECHOICES\n   'Found',                             // HTTP_FOUND\n   'Use Proxy',                         // HTTP_USEPROXY\n   'Proxy Authentication Required',     // HTTP_PROXYAUTHREQUIRED\n   'Request Timeout',                   // HTTP_TIMEOUT\n   'Conflict',                          // HTTP_CONFLICT\n   'Gone',                              // 410\n   'Length Required',                   // 411\n   'Precondition Failed',               // 412\n   'URI Too Long',                      // 414\n   'Unsupported Media Type',            // 415\n   'Requested Range Not Satisfiable',   // HTTP_RANGENOTSATISFIABLE\n   'I''m a teapot',                     // HTTP_TEAPOT\n   'Upgrade Required',                  // 426\n   'Internal Server Error',             // HTTP_SERVERERROR\n   'Not Implemented',                   // HTTP_NOTIMPLEMENTED\n   'Bad Gateway',                       // HTTP_BADGATEWAY\n   'Service Unavailable',               // HTTP_UNAVAILABLE\n   'Gateway Timeout',                   // HTTP_GATEWAYTIMEOUT\n   'HTTP Version Not Supported',        // HTTP_HTTPVERSIONNONSUPPORTED\n   'Network Authentication Required',   // 511\n   'Invalid Request');                  // 513 - should be last\n\n  HTTP_CODE: array[0..43] of word = (\n    HTTP_SUCCESS,\n    HTTP_NOCONTENT,\n    HTTP_TEMPORARYREDIRECT,\n    HTTP_PERMANENTREDIRECT,\n    HTTP_MOVEDPERMANENTLY,\n    HTTP_BADREQUEST,\n    HTTP_UNAUTHORIZED,\n    HTTP_FORBIDDEN,\n    HTTP_NOTFOUND,\n    HTTP_NOTALLOWED,\n    HTTP_NOTMODIFIED,\n    HTTP_NOTACCEPTABLE,\n    HTTP_PARTIALCONTENT,\n    HTTP_PAYLOADTOOLARGE,\n    HTTP_CREATED,\n    HTTP_SEEOTHER,\n    HTTP_CONTINUE,\n    HTTP_SWITCHINGPROTOCOLS,\n    HTTP_ACCEPTED,\n    HTTP_NONAUTHORIZEDINFO,\n    HTTP_RESETCONTENT,\n    207,\n    HTTP_MULTIPLECHOICES,\n    HTTP_FOUND,\n    HTTP_USEPROXY,\n    HTTP_PROXYAUTHREQUIRED,\n    HTTP_TIMEOUT,\n    HTTP_CONFLICT,\n    410,\n    411,\n    412,\n    414,\n    415,\n    HTTP_RANGENOTSATISFIABLE,\n    HTTP_TEAPOT,\n    426,\n    HTTP_SERVERERROR,\n    HTTP_NOTIMPLEMENTED,\n    HTTP_BADGATEWAY,\n    HTTP_UNAVAILABLE,\n    HTTP_GATEWAYTIMEOUT,\n    HTTP_HTTPVERSIONNONSUPPORTED,\n    511,\n    513);\n\nfunction StatusCodeToText(Code: cardinal): PRawUtf8;\nvar\n  i: PtrInt;\nbegin\n  if Code <> 200 then // optimistic approach :)\n    if (Code < 513) and\n       (Code >= 100) then\n    begin\n      i := WordScanIndex(@HTTP_CODE, length(HTTP_CODE), Code); // may use SSE2\n      if i < 0 then\n        i := high(HTTP_CODE); // returns cached 513 'Invalid Request'\n    end\n    else\n      i := high(HTTP_CODE)\n  else\n    i := 0;\n  result := @HTTP_REASON[i];\nend;\n\nprocedure StatusCodeToReason(Code: cardinal; var Reason: RawUtf8);\nbegin\n  Reason := StatusCodeToText(Code)^;\nend;\n\nfunction StatusCodeToShort(Code: cardinal): TShort47;\nbegin\n  if Code > 599 then\n    Code := 999; // ensure stay in TShort47\n  result[0] := #0;\n  AppendShortCardinal(Code, result);\n  AppendShortChar(' ', result);\n  AppendShortAnsi7String(StatusCodeToText(Code)^, result);\nend;\n\nfunction StatusCodeIsSuccess(Code: integer): boolean;\nbegin\n  result := (Code >= HTTP_SUCCESS) and\n            (Code < HTTP_BADREQUEST); // 200..399\nend;\n\nfunction IsInvalidHttpHeader(head: PUtf8Char; headlen: PtrInt): boolean;\nvar\n  i: PtrInt;\n  c: cardinal;\nbegin\n  result := true;\n  for i := 0 to headlen - 3 do\n  begin\n    c := PCardinal(head + i)^;\n    if (c = $0a0d0a0d) or\n       (Word(c) = $0d0d) or\n       (Word(c) = $0a0a) then\n      exit;\n  end;\n  result := false;\nend;\n\nfunction _oskb(Size: QWord): shortstring;\nconst\n  _U: array[0..3] of AnsiChar = 'TGMK';\nvar\n  u: PtrInt;\n  b: QWord;\nbegin\n  u := 0;\n  b := Qword(1) shl 40;\n  repeat\n    if Size > b shr 1 then\n      break;\n    b := b shr 10;\n    inc(u);\n  until u = high(_u);\n  str(Size / b : 1 : 1, result); // let the FPU + RTL do the conversion for us\n  if (result[0] <= #2) or\n     (result[ord(result[0]) - 1] <> '.') or\n     (result[ord(result[0])] <> '0') then\n    inc(result[0], 2);\n  result[ord(result[0]) - 1] := _U[u];\n  result[ord(result[0])] := 'B';\nend;\n\nfunction SidLength(sid: PSid): PtrInt;\nbegin\n  if sid = nil then\n    result := 0\n  else\n    result := integer(sid^.SubAuthorityCount) shl 2 + 8;\nend;\n\nfunction SidCompare(a, b: PSid): integer;\nvar\n  l: PtrInt;\nbegin\n  l := SidLength(a);\n  result := l - SidLength(b);\n  if result = 0 then\n    result := MemCmp(pointer(a), pointer(b), l);\nend;\n\nprocedure ToRawSid(sid: PSid; out result: RawSid);\nbegin\n  if sid <> nil then\n    FastSetRawByteString(RawByteString(result), sid, SidLength(sid));\nend;\n\nprocedure SidToTextShort(sid: PSid; var result: shortstring);\nvar\n  a: PSidAuth;\n  i: PtrInt;\nbegin // faster than ConvertSidToStringSidA(), and cross-platform\n  if (sid = nil ) or\n     (sid^.Revision <> 1) then\n  begin\n    result[0] := #0; // invalid SID\n    exit;\n  end;\n  a := @sid^.IdentifierAuthority;\n  if (a^[0] <> 0) or\n     (a^[1] <> 0) then\n  begin\n    result := 'S-1-0x';\n    for i := 0 to 5 do\n      AppendShortByteHex(a^[i], result)\n  end\n  else\n  begin\n    result := 'S-1-';\n    AppendShortCardinal(bswap32(PCardinal(@a^[2])^), result);\n  end;\n  for i := 0 to integer(sid^.SubAuthorityCount) - 1 do\n  begin\n    AppendShortChar('-', result);\n    AppendShortCardinal(sid^.SubAuthority[i], result);\n  end;\nend;\n\nfunction SidToText(sid: PSid): RawUtf8;\nvar\n  tmp: shortstring;\nbegin\n  SidToTextShort(sid, tmp);\n  FastSetString(result, @tmp[1], ord(tmp[0]));\nend;\n\nfunction SidsToText(sids: PSids): TRawUtf8DynArray;\nvar\n  i: PtrInt;\nbegin\n  result := nil;\n  SetLength(result, length(sids));\n  for i := 0 to length(sids) - 1 do\n    result[i] := SidToText(sids[i]);\nend;\n\nfunction IsValidRawSid(const sid: RawSid): boolean;\nvar\n  l: PtrInt;\nbegin\n  l := length(sid);\n  result := (l >= SizeOf(TSidAuth) + 2) and\n            (SidLength(pointer(sid)) = l)\nend;\n\nfunction HasSid(const sids: PSids; sid: PSid): boolean;\nvar\n  i: PtrInt;\nbegin\n  result := true;\n  if sid <> nil then\n    for i := 0 to length(sids) - 1 do\n      if SidCompare(sid, sids[i]) = 0 then\n        exit;\n  result := false;\nend;\n\nfunction HasAnySid(const sids: PSids; const sid: RawSidDynArray): boolean;\nvar\n  i: PtrInt;\nbegin\n  result := true;\n  for i := 0 to length(sid) - 1 do\n    if HasSid(sids, pointer(sid[i])) then\n      exit;\n  result := false;\nend;\n\nprocedure AddRawSid(var sids: RawSidDynArray; sid: PSid);\nvar\n  n: PtrInt;\nbegin\n  if sid = nil then\n    exit;\n  n := length(sids);\n  SetLength(sids, n + 1);\n  ToRawSid(sid, sids[n]);\nend;\n\nfunction RawSidToText(const sid: RawSid): RawUtf8;\nbegin\n  if IsValidRawSid(sid) then\n    result := SidToText(pointer(sid))\n  else\n    result := '';\nend;\n\n// GetNextCardinal() on POSIX does not ignore trailing '-'\nfunction GetNextUInt32(var P: PUtf8Char): cardinal;\nvar\n  c: cardinal;\nbegin\n  result := 0;\n  if P = nil then\n    exit;\n  repeat\n    c := ord(P^) - 48;\n    if c > 9 then\n      break\n    else\n      result := result * 10 + c;\n    inc(P);\n  until false;\n  while P^ in ['.', '-', ' '] do\n    inc(P);\nend;\n\nfunction TextToSid(P: PUtf8Char; out sid: TSid): boolean;\nbegin\n  result := false;\n  if (P = nil) or\n     (PCardinal(P)^ <>\n        ord('S') + ord('-') shl 8 + ord('1') shl 16 + ord('-') shl 24) then\n    exit;\n  inc(P, 4);\n  if not (P^ in ['1'..'9']) then\n    exit;\n  PInt64(@sid)^ := 1;\n  PCardinal(@sid.IdentifierAuthority[2])^ := bswap32(GetNextUInt32(P));\n  while P^ in ['0'..'9'] do\n  begin\n    sid.SubAuthority[sid.SubAuthorityCount] := GetNextUInt32(P);\n    inc(sid.SubAuthorityCount);\n    if sid.SubAuthorityCount = 0 then\n      exit; // avoid any overflow\n  end;\n  result := P^ = #0\nend;\n\nfunction TextToRawSid(const text: RawUtf8): RawSid;\nbegin\n  TextToRawSid(text, result);\nend;\n\nfunction TextToRawSid(const text: RawUtf8; out sid: RawSid): boolean;\nvar\n  tmp: TSid; // maximum size possible on stack (1032 bytes)\nbegin\n  result := TextToSid(pointer(text), tmp);\n  if result then\n    ToRawSid(@tmp, sid)\nend;\n\nvar\n  KNOWN_SID_SAFE: TLightLock; // lighter than GlobalLock/GlobalUnLock\n  KNOWN_SID: array[TWellKnownSid] of RawSid;\n  KNOWN_SID_TEXT: array[TWellKnownSid] of string[15];\nconst\n  INTEGRITY_SID: array[0..7] of word = ( // S-1-16-x known values\n    0, 4096, 8192, 8448, 12288, 16384, 20480, 28672);\n\nprocedure ComputeKnownSid(wks: TWellKnownSid);\nvar\n  sid: TSid;\nbegin\n  PInt64(@sid)^ := $0101; // sid.Revision=1, sid.SubAuthorityCount=1\n  if wks <= wksLocal then\n  begin // S-1-1-0\n    sid.IdentifierAuthority[5] := ord(wks);\n    sid.SubAuthority[0] := 0;\n  end\n  else if wks = wksConsoleLogon then\n  begin // S-1-2-1\n    sid.IdentifierAuthority[5] := 2;\n    sid.SubAuthority[0] := 1;\n  end\n  else if wks <= wksCreatorGroupServer then\n  begin // S-1-3-0\n    sid.IdentifierAuthority[5] := 3;\n    sid.SubAuthority[0] := ord(wks) - ord(wksCreatorOwner);\n  end\n  else if wks <= wksIntegritySecureProcess then\n  begin\n    sid.IdentifierAuthority[5] := 16; // S-1-16-x\n    sid.SubAuthority[0] := INTEGRITY_SID[ord(wks) - ord(wksIntegrityUntrusted)];\n  end\n  else if wks <= wksAuthenticationKeyPropertyAttestation then\n  begin // S-1-18-1\n    sid.IdentifierAuthority[5] := 18;\n    sid.SubAuthority[0] := ord(wks) - (ord(wksAuthenticationAuthorityAsserted) - 1)\n  end\n  else\n  begin // S-1-5-x\n    sid.IdentifierAuthority[5] := 5;\n    if wks = wksNtAuthority then\n      sid.SubAuthorityCount := 0\n    else if wks <= wksInteractive then\n      sid.SubAuthority[0] := ord(wks) - ord(wksNtAuthority)\n    else if wks <= wksThisOrganisation then\n      sid.SubAuthority[0] := ord(wks) - (ord(wksNtAuthority) - 1)\n    else if wks <= wksNetworkService then\n      sid.SubAuthority[0] := ord(wks) - (ord(wksNtAuthority) - 2)\n    else if wks <= wksLocalAccountAndAdministrator then //  S-1-5-113\n      sid.SubAuthority[0] := ord(wks) - (ord(wksLocalAccount) - 113)\n    else\n    begin\n      sid.SubAuthority[0] := 32;\n      if wks <> wksBuiltinDomain then\n      begin\n        sid.SubAuthorityCount := 2;\n        if wks <= wksBuiltinDcomUsers then\n          sid.SubAuthority[1] := ord(wks) - (ord(wksBuiltinAdministrators) - 544)\n        else if wks <= wksBuiltinDeviceOwners then // S-1-5-32-583\n          sid.SubAuthority[1] := ord(wks) - (ord(wksBuiltinIUsers) - 568)\n        else if wks <= wksCapabilityContacts then\n        begin // S-1-15-3-1\n          sid.IdentifierAuthority[5] := 15;\n          sid.SubAuthority[0] := 3;\n          sid.SubAuthority[1] := ord(wks) - (ord(wksCapabilityInternetClient) - 1)\n        end\n        else if wks <= wksBuiltinAnyRestrictedPackage then\n        begin // S-1-15-2-1\n          sid.IdentifierAuthority[5] := 15;\n          sid.SubAuthority[0] := 2;\n          sid.SubAuthority[1] := ord(wks) - (ord(wksBuiltinAnyPackage) - 1)\n        end\n        else if wks <= wksDigestAuthentication then\n        begin\n          sid.SubAuthority[0] := 64;\n          case wks of\n            wksNtlmAuthentication:\n              sid.SubAuthority[1] := 10; // S-1-5-64-10\n            wksSChannelAuthentication:\n              sid.SubAuthority[1] := 14;\n            wksDigestAuthentication:\n              sid.SubAuthority[1] := 21;\n          end;\n        end;\n      end;\n    end;\n  end;\n  KNOWN_SID_SAFE.Lock;\n  if KNOWN_SID[wks] = '' then\n  begin\n    SidToTextShort(@sid, KNOWN_SID_TEXT[wks]);\n    ToRawSid(@sid, KNOWN_SID[wks]); // to be set last\n  end;\n  KNOWN_SID_SAFE.UnLock;\nend;\n\nfunction KnownRawSid(wks: TWellKnownSid): RawSid;\nbegin\n  if (wks <> wksNull) and\n     (KNOWN_SID[wks] = '') then\n    ComputeKnownSid(wks);\n  result := KNOWN_SID[wks];\nend;\n\nfunction KnownSidToText(wks: TWellKnownSid): PShortString;\nbegin\n  if (wks <> wksNull) and\n     (KNOWN_SID[wks] = '') then\n    ComputeKnownSid(wks);\n  result := @KNOWN_SID_TEXT[wks];\nend;\n\n// https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids\n// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/81d92bba-d22b-4a8c-908a-554ab29148ab\n\nfunction SidToKnown(sid: PSid): TWellKnownSid;\nvar\n  c: integer;\nbegin\n  result := wksNull; // not recognized\n  if (sid = nil) or\n     (sid.Revision <> 1) or\n     (PCardinal(@sid.IdentifierAuthority)^ <> 0) or\n     (sid.IdentifierAuthority[4] <> 0) then\n    exit;\n  case sid.SubAuthorityCount of // very fast O(1) SID binary recognition\n    0:\n      if sid.IdentifierAuthority[5] = 5 then\n        result := wksNtAuthority; // S-1-5\n    1:\n      begin\n        c := sid.SubAuthority[0];\n        case sid.IdentifierAuthority[5] of\n          1:\n            if c = 0 then\n              result := wksWorld; // S-1-1-0\n          2:\n            if c in [0 .. 1] then // S-1-2-x\n              result := TWellKnownSid(ord(wksLocal) + c);\n          3:\n            if c in [0 .. 3] then // S-1-3-x\n              result := TWellKnownSid(ord(wksCreatorOwner) + c);\n          5:\n            case c of // S-1-5-x\n              1 .. 4:\n                result := TWellKnownSid((ord(wksDialup) - 1) + c);\n              6 .. 15:\n                result := TWellKnownSid((ord(wksService) - 6) + c);\n              17 .. 20:\n                result := TWellKnownSid((ord(wksIisUser) - 17) + c);\n              32:\n                result := wksBuiltinDomain;\n              113 .. 114:\n                result := TWellKnownSid(integer(ord(wksLocalAccount) - 113) + c);\n            end;\n          16:\n            begin // S-1-16-x\n              c := WordScanIndex(@INTEGRITY_SID, length(INTEGRITY_SID), c);\n              if c >= 0 then\n                result := TWellKnownSid(ord(wksIntegrityUntrusted) + c);\n            end;\n          18:\n            if c in [1 .. 6] then // S-1-18-x\n              result :=\n                TWellKnownSid((ord(wksAuthenticationAuthorityAsserted) - 1) + c);\n        end;\n      end;\n    2:\n      begin\n        c := sid.SubAuthority[1];\n        case sid.IdentifierAuthority[5] of\n          5:\n            case sid.SubAuthority[0] of\n              32: // S-1-5-32-544\n                case c of\n                  544 .. 562:\n                    result := TWellKnownSid(ord(wksBuiltinAdministrators) + c - 544);\n                  568 .. 583:\n                    result := TWellKnownSid(ord(wksBuiltinIUsers) + c - 568);\n                end;\n              64: // S-1-5-64-10\n                case c of\n                  10:\n                    result := wksNtlmAuthentication;\n                  14:\n                    result := wksSChannelAuthentication;\n                  21:\n                    result := wksDigestAuthentication;\n                end;\n            end;\n          15:\n            case sid.SubAuthority[0] of\n              2:\n                if c in [1 .. 2] then // S-1-15-2-x\n                  result := TWellKnownSid(ord(pred(wksBuiltinAnyPackage)) + c);\n              3:\n                if c in [1 .. 12] then // S-1-15-3-x\n                  result := TWellKnownSid(ord(pred(wksCapabilityInternetClient)) + c);\n            end;\n        end;\n      end;\n  end;\nend;\n\nfunction SidToKnown(const text: RawUtf8): TWellKnownSid;\nvar\n  sid: TSid;\nbegin\n  if TextToSid(pointer(text), sid) then\n    result := SidToKnown(@sid)\n  else\n    result := wksNull;\nend;\n\nfunction SidToKnownGroups(const sids: PSids): TWellKnownSids;\nvar\n  k: TWellKnownSid;\n  i: PtrInt;\nbegin\n  result := [];\n  for i := 0 to length(sids) - 1 do\n  begin\n    k := SidToKnown(sids[i]);\n    if k <> wksNull then\n      include(result, k);\n  end;\nend;\n\n\n{ ****************** Gather Operating System Information }\n\nfunction ToText(const osv: TOperatingSystemVersion): RawUtf8;\nbegin\n  result := OS_NAME[osv.os];\n  case osv.os of\n    osWindows:\n      result := 'Windows ' + WINDOWS_NAME[osv.win];\n    osOSX:\n      if osv.utsrelease[2] in [low(MACOS_NAME) .. high(MACOS_NAME)] then\n        result := 'macOS ' + MACOS_NAME[osv.utsrelease[2]];\n  end;\nend;\n\nfunction ToTextShort(const osv: TOperatingSystemVersion): RawUtf8;\nbegin\n  result := OS_NAME[osv.os];\n  case osv.os of\n    osWindows:\n      result := WINDOWS_NAME[osv.win];\n    osOSX:\n      if osv.utsrelease[2] in [low(MACOS_NAME) .. high(MACOS_NAME)] then\n        result := MACOS_NAME[osv.utsrelease[2]];\n  end;\nend;\n\nconst\n  LINUX_TEXT: array[boolean] of string[7] = (\n    '', 'Linux ');\n\nfunction ToTextOS(osint32: integer): RawUtf8;\nvar\n  osv: TOperatingSystemVersion absolute osint32;\nbegin\n  if osint32 = 0 then\n  begin\n    result := '';\n    exit;\n  end;\n  result := ToText(osv);\n  if (osv.os = osWindows) and\n     (osv.winbuild <> 0) then\n    // include the Windows build number, e.g. 'Windows 11 64bit 22000'\n    result := _fmt('%s %d', [result, osv.winbuild]);\n  if (osv.os >= osLinux) and\n     (osv.utsrelease[2] <> 0) then\n    // include kernel number to the distribution name, e.g. 'Ubuntu Linux 5.4.0'\n    result := _fmt('%s %s%d.%d.%d', [result, LINUX_TEXT[osv.os in OS_LINUX],\n      osv.utsrelease[2], osv.utsrelease[1], osv.utsrelease[0]]);\nend;\n\nfunction MatchOS(os: TOperatingSystem): boolean;\nvar\n  current: TOperatingSystem;\nbegin\n  current := OS_KIND;\n  if (os = osUnknown) or\n     (current = osUnknown) or\n     (os = current) then\n    result := true // exact match\n  else\n    case os of // search by family\n      osPosix:\n        result := current <> osWindows;\n      osLinux:\n        result := current in OS_LINUX;\n    else\n      result := false;\n    end;\nend;\n\nconst\n  // https://github.com/karelzak/util-linux/blob/master/sys-utils/lscpu-arm.c\n  ARMCPU_ID: array[TArmCpuType] of word = (\n    0,      // actUnknown\n    $0810,  // actARM810\n    $0920,  // actARM920\n    $0922,  // actARM922\n    $0926,  // actARM926\n    $0940,  // actARM940\n    $0946,  // actARM946\n    $0966,  // actARM966\n    $0a20,  // actARM1020\n    $0a22,  // actARM1022\n    $0a26,  // actARM1026\n    $0b02,  // actARM11MPCore\n    $0b36,  // actARM1136\n    $0b56,  // actARM1156\n    $0b76,  // actARM1176\n    $0c05,  // actCortexA5\n    $0c07,  // actCortexA7\n    $0c08,  // actCortexA8\n    $0c09,  // actCortexA9\n    $0c0d,  // actCortexA12\n    $0c0f,  // actCortexA15\n    $0c0e,  // actCortexA17\n    $0c14,  // actCortexR4\n    $0c15,  // actCortexR5\n    $0c17,  // actCortexR7\n    $0c18,  // actCortexR8\n    $0c20,  // actCortexM0\n    $0c21,  // actCortexM1\n    $0c23,  // actCortexM3\n    $0c24,  // actCortexM4\n    $0c27,  // actCortexM7\n    $0c60,  // actCortexM0P\n    $0d01,  // actCortexA32\n    $0d03,  // actCortexA53\n    $0d04,  // actCortexA35\n    $0d05,  // actCortexA55\n    $0d06,  // actCortexA65\n    $0d07,  // actCortexA57\n    $0d08,  // actCortexA72\n    $0d09,  // actCortexA73\n    $0d0a,  // actCortexA75\n    $0d0b,  // actCortexA76\n    $0d0c,  // actNeoverseN1\n    $0d0d,  // actCortexA77\n    $0d0e,  // actCortexA76AE\n    $0d13,  // actCortexR52\n    $0d20,  // actCortexM23\n    $0d21,  // actCortexM33\n    $0d40,  // actNeoverseV1\n    $0d41,  // actCortexA78\n    $0d42,  // actCortexA78AE\n    $0d44,  // actCortexX1\n    $0d46,  // actCortex510\n    $0d47,  // actCortex710\n    $0d48,  // actCortexX2\n    $0d49,  // actNeoverseN2\n    $0d4a,  // actNeoverseE1\n    $0d4b,  // actCortexA78C\n    $0d4c,  // actCortexX1C\n    $0d4d,  // actCortexA715\n    $0d4e,  // actCortexX3\n    $0d4f,  // actNeoverseV2\n    $0d80,  // actCortexA520\n    $0d81,  // actCortexA720\n    $0d82,  // actCortexX4\n    $0d84,  // actNeoverseV3\n    $0d8e); // actNeoverseN3\n\n  ARMCPU_IMPL: array[TArmCpuImplementer] of byte = (\n    0,    // aciUnknown\n    $41,  // aciARM\n    $42,  // aciBroadcom\n    $43,  // aciCavium\n    $44,  // aciDEC\n    $46,  // aciFUJITSU\n    $48,  // aciHiSilicon\n    $49,  // aciInfineon\n    $4d,  // aciMotorola\n    $4e,  // aciNVIDIA\n    $50,  // aciAPM\n    $51,  // aciQualcomm\n    $53,  // aciSamsung\n    $56,  // aciMarvell\n    $61,  // aciApple\n    $66,  // aciFaraday\n    $69,  // aciIntel\n    $6d,  // aciMicrosoft\n    $70,  // aciPhytium\n    $c0); // aciAmpere\n\n  ARMCPU_ID_TXT: array[TArmCpuType] of string[15] = (\n     '',\n     'ARM810', 'ARM920', 'ARM922', 'ARM926', 'ARM940', 'ARM946', 'ARM966',\n     'ARM1020', 'ARM1022', 'ARM1026', 'ARM11 MPCore', 'ARM1136', 'ARM1156',\n     'ARM1176', 'Cortex-A5', 'Cortex-A7', 'Cortex-A8', 'Cortex-A9',\n     'Cortex-A17',{Originally A12} 'Cortex-A15', 'Cortex-A17', 'Cortex-R4',\n     'Cortex-R5', 'Cortex-R7', 'Cortex-R8', 'Cortex-M0', 'Cortex-M1',\n     'Cortex-M3', 'Cortex-M4', 'Cortex-M7', 'Cortex-M0+', 'Cortex-A32',\n     'Cortex-A53', 'Cortex-A35', 'Cortex-A55', 'Cortex-A65', 'Cortex-A57',\n     'Cortex-A72', 'Cortex-A73', 'Cortex-A75', 'Cortex-A76', 'Neoverse-N1',\n     'Cortex-A77', 'Cortex-A76AE', 'Cortex-R52', 'Cortex-M23', 'Cortex-M33',\n     'Neoverse-V1', 'Cortex-A78', 'Cortex-A78AE', 'Cortex-X1', 'Cortex-510',\n     'Cortex-710', 'Cortex-X2', 'Neoverse-N2', 'Neoverse-E1', 'Cortex-A78C',\n     'Cortex-X1C', 'Cortex-A715', 'Cortex-X3', 'Neoverse-V2', 'Cortex-A520',\n     'Cortex-A720', 'Cortex-X4', 'Neoverse-V3', 'Neoverse-N3');\n  ARMCPU_IMPL_TXT: array[TArmCpuImplementer] of string[18] = (\n      '',\n      'ARM', 'Broadcom', 'Cavium', 'DEC', 'FUJITSU', 'HiSilicon', 'Infineon',\n      'Motorola/Freescale', 'NVIDIA', 'APM', 'Qualcomm', 'Samsung', 'Marvell',\n      'Apple', 'Faraday', 'Intel', 'Microsoft', 'Phytium', 'Ampere');\n\nfunction ArmCpuType(id: word): TArmCpuType;\nbegin\n  for result := low(TArmCpuType) to high(TArmCpuType) do\n    if ARMCPU_ID[result] = id then\n      exit;\n  result := actUnknown;\nend;\n\nfunction ArmCpuTypeName(act: TArmCpuType; id: word): RawUtf8;\nbegin\n  if act = actUnknown then\n    result := 'ARM 0x' + RawUtf8(IntToHex(id, 3))\n  else\n    ShortStringToAnsi7String(ARMCPU_ID_TXT[act], result);\nend;\n\nfunction ArmCpuImplementer(id: byte): TArmCpuImplementer;\nbegin\n  for result := low(TArmCpuImplementer) to high(TArmCpuImplementer) do\n    if ARMCPU_IMPL[result] = id then\n      exit;\n  result := aciUnknown;\nend;\n\nfunction ArmCpuImplementerName(aci: TArmCpuImplementer; id: word): RawUtf8;\nbegin\n  if aci = aciUnknown then\n    result := 'HW 0x' + RawUtf8(IntToHex(id, 2))\n  else\n    ShortStringToAnsi7String(ARMCPU_IMPL_TXT[aci], result);\nend;\n\n\n{ *************** Per Class Properties O(1) Lookup via vmtAutoTable Slot }\n\nprocedure PatchCodePtrUInt(Code: PPtrUInt; Value: PtrUInt; LeaveUnprotected: boolean);\nbegin\n  PatchCode(Code, @Value, SizeOf(Code^), nil, LeaveUnprotected);\nend;\n\n{$ifdef CPUINTEL}\nprocedure RedirectCode(Func, RedirectFunc: Pointer);\nvar\n  rel: PtrInt;\n  NewJump: packed record\n    Code: byte;        // $e9 = jmp {relative}\n    Distance: integer; // relative jump is 32-bit even on CPU64\n  end;\nbegin\n  if (Func = nil) or\n     (RedirectFunc = nil) or\n     (Func = RedirectFunc) then\n    exit; // nothing to redirect to\n  NewJump.Code := $e9; // on both i386 and x86_64\n  rel := PtrInt(PtrUInt(RedirectFunc) - PtrUInt(Func) - SizeOf(NewJump));\n  NewJump.Distance := rel;\n  {$ifdef CPU64}\n  if NewJump.Distance <> rel then\n    exit; // RedirectFunc is too far away from the original code :(\n  {$endif CPU64}\n  PatchCode(Func, @NewJump, SizeOf(NewJump));\n  assert(PByte(Func)^ = $e9);\nend;\n{$endif CPUINTEL}\n\n\n\n{ ************** Cross-Platform Charset and CodePage Support }\n\nfunction CharSetToCodePage(CharSet: integer): cardinal;\nbegin\n  case CharSet of\n    SHIFTJIS_CHARSET:\n      result := 932;\n    HANGEUL_CHARSET:\n      result := 949;\n    GB2312_CHARSET:\n      result := 936;\n    HEBREW_CHARSET:\n      result := 1255;\n    ARABIC_CHARSET:\n      result := 1256;\n    GREEK_CHARSET:\n      result := 1253;\n    TURKISH_CHARSET:\n      result := 1254;\n    VIETNAMESE_CHARSET:\n      result := 1258;\n    THAI_CHARSET:\n      result := 874;\n    EASTEUROPE_CHARSET:\n      result := 1250;\n    RUSSIAN_CHARSET:\n      result := 1251;\n    BALTIC_CHARSET:\n      result := 1257;\n  else\n    result := CP_WINANSI; // default ANSI_CHARSET = iso-8859-1 = windows-1252\n  end;\nend;\n\nfunction CodePageToCharSet(CodePage: cardinal): integer;\nbegin\n  case CodePage of\n    932:\n      result := SHIFTJIS_CHARSET;\n    949:\n      result := HANGEUL_CHARSET;\n    936:\n      result := GB2312_CHARSET;\n    1255:\n      result := HEBREW_CHARSET;\n    1256:\n      result := ARABIC_CHARSET;\n    1253:\n      result := GREEK_CHARSET;\n    1254:\n      result := TURKISH_CHARSET;\n    1258:\n      result := VIETNAMESE_CHARSET;\n    874:\n      result := THAI_CHARSET;\n    1250:\n      result := EASTEUROPE_CHARSET;\n    1251:\n      result := RUSSIAN_CHARSET;\n    1257:\n      result := BALTIC_CHARSET;\n  else\n    result := ANSI_CHARSET; // default is iso-8859-1 = windows-1252\n  end;\nend;\n\n\n{ ****************** Unicode, Time, File, Console, Library process }\n\nprocedure InitializeCriticalSectionIfNeededAndEnter(var cs: TRTLCriticalSection);\nbegin\n  if not IsInitializedCriticalSection(cs) then\n    InitializeCriticalSection(cs);\n  mormot.core.os.EnterCriticalSection(cs);\nend;\n\nprocedure DeleteCriticalSectionIfNeeded(var cs: TRTLCriticalSection);\nbegin\n  if IsInitializedCriticalSection(cs) then\n    DeleteCriticalSection(cs);\nend;\n\nfunction Unicode_CodePage: integer;\nbegin\n  {$ifdef FPC}\n  // = GetSystemCodePage on POSIX, Lazarus may override to UTF-8 on Windows\n  result := DefaultSystemCodePage;\n  {$else}\n  // Delphi always uses the main Windows System Code Page\n  result := GetACP;\n  {$endif FPC}\nend;\n\nfunction Unicode_CompareString(PW1, PW2: PWideChar; L1, L2: PtrInt;\n  IgnoreCase: boolean): integer;\nconst\n  _CASEFLAG: array[boolean] of DWORD = (0, NORM_IGNORECASE);\nbegin\n  result := CompareStringW(LOCALE_USER_DEFAULT, _CASEFLAG[IgnoreCase], PW1, L1, PW2, L2);\nend;\n\nprocedure Unicode_WideToShort(W: PWideChar; LW, CodePage: PtrInt;\n  var res: ShortString);\nvar\n  i: PtrInt;\nbegin\n  if LW <= 0 then\n    res[0] := #0\n  else if (LW <= 255) and\n          IsAnsiCompatibleW(W, LW) then\n  begin\n    // fast handling of pure English content\n    res[0] := AnsiChar(LW);\n    i := 1;\n    repeat\n      res[i] := AnsiChar(W^);\n      if i = LW then\n        break;\n      inc(W);\n      inc(i);\n    until false;\n  end\n  else\n    // use WinAPI, ICU or cwstring/RTL for accurate conversion\n    res[0] := AnsiChar(\n      Unicode_WideToAnsi(W, PAnsiChar(@res[1]), LW, 255, CodePage));\nend;\n\nfunction NowUtc: TDateTime;\nbegin\n  result := UnixMSTimeUtcFast / Int64(MSecsPerDay) + Int64(UnixDelta);\nend;\n\nfunction DateTimeToWindowsFileTime(DateTime: TDateTime): integer;\nvar\n  YY, MM, DD, H, m, s, ms: word;\nbegin\n  DecodeDate(DateTime, YY, MM, DD);\n  DecodeTime(DateTime, h, m, s, ms);\n  if (YY < 1980) or\n     (YY > 2099) then\n    result := 0\n  else\n    result := (s shr 1) or (m shl 5) or (h shl 11) or\n      cardinal((DD shl 16) or (MM shl 21) or (cardinal(YY - 1980) shl 25));\nend;\n\nfunction WindowsFileTimeToDateTime(WinTime: integer): TDateTime;\nvar\n  date, time: TDateTime;\nbegin\n  with PLongRec(@WinTime)^ do\n  if TryEncodeDate(Hi shr 9 + 1980, Hi shr 5 and 15, Hi and 31, date) and\n     TryEncodeTime(Lo shr 11, Lo shr 5 and 63, Lo and 31 shl 1, 0, time) then\n    result := date + time\n  else\n    result := 0;\nend;\n\nconst\n  FileTimePerMs = 10000; // a tick is 100ns\n\nfunction WindowsFileTime64ToUnixMSTime(WinTime: QWord): TUnixMSTime;\nbegin\n  result := (Int64(WinTime) - UnixFileTimeDelta) div FileTimePerMs;\nend;\n\nfunction DirectorySize(const FileName: TFileName; Recursive: boolean;\n  const Mask: TFileName): Int64;\nvar\n  SR: TSearchRec;\n  dir: TFileName;\nbegin\n  result := 0;\n  dir := IncludeTrailingPathDelimiter(FileName);\n  if FindFirst(dir + Mask, faAnyFile, SR) <> 0 then\n    exit;\n  repeat\n   if SearchRecValidFile(SR) then\n     inc(result, SR.Size)\n   else if Recursive and\n           SearchRecValidFolder(SR) then\n     inc(result, DirectorySize(dir + SR.Name, true));\n  until FindNext(SR) <> 0;\n  FindClose(SR);\nend;\n\nfunction SafePathName(const Path: TFileName): boolean;\nvar\n  i, o: PtrInt;\nbegin\n  if Path <> '' then\n  begin\n    result := false;\n    if (Path[1] = '/') or\n       (PosExString(':', Path) <> 0) or\n       (PosExString('\\\\', Path) <> 0) then\n      exit;\n    o := 1;\n    repeat\n      i := PosExString('..', Path, o);\n      if i = 0 then\n        break;\n      o := i + 2; // '..test' or 'test..' are valid folder names\n      if cardinal(Path[o]) in [0, ord('\\'), ord('/')] then\n        if (i = 1) or\n           (cardinal(Path[i - 1]) in [ord('\\'), ord('/')]) then\n          exit;\n    until false;\n  end;\n  result := true;\nend;\n\nfunction SafePathNameU(const Path: RawUtf8): boolean;\nvar\n  i, o: PtrInt;\nbegin\n  if Path <> '' then\n  begin\n    result := false;\n    if (Path[1] = '/') or\n       (PosExChar(':', Path) <> 0) or\n       (PosEx('\\\\', Path) <> 0) then\n      exit;\n    o := 1;\n    repeat\n      i := PosEx('..', Path, o);\n      if i = 0 then\n        break;\n      o := i + 2;\n      if Path[o] in [#0, '\\', '/'] then\n        if (i = 1) or\n           (Path[i - 1] in ['\\', '/']) then\n          exit;\n    until false;\n  end;\n  result := true;\nend;\n\nfunction SafeFileName(const FileName: TFileName): boolean;\nbegin\n  result := SafePathName(ExtractPath(FileName));\nend;\n\nfunction SafeFileNameU(const FileName: RawUtf8): boolean;\nbegin\n  result := SafePathNameU(ExtractPathU(FileName));\nend;\n\nfunction NormalizeFileName(const FileName: TFileName): TFileName;\nbegin\n  result := StringReplace(FileName, InvertedPathDelim, PathDelim, [rfReplaceAll]);\nend;\n\nfunction QuoteFileName(const FileName: TFileName): TFileName;\nbegin\n  if (FileName <> '') and\n     (PosExString(' ', FileName) <> 0) and\n     (FileName[1] <> '\"') then\n    result := '\"' + FileName + '\"'\n  else\n    result := FileName;\nend;\n\nprocedure DisplayError(const fmt: string; const args: array of const);\nvar\n  msg: string;\nbegin\n  msg := Format(fmt, args);\n  DisplayFatalError('', RawUtf8(msg));\nend;\n\nfunction SearchRecToDateTime(const F: TSearchRec): TDateTime;\nbegin\n  {$ifdef ISDELPHIXE}\n  result := F.Timestamp; // use new API\n  {$else}\n  result := FileDateToDateTime(F.Time);\n  {$endif ISDELPHIXE}\nend;\n\nfunction SearchRecToDateTimeUtc(const F: TSearchRec): TDateTime;\nbegin\n  result := SearchRecToUnixTimeUtc(F) / Int64(SecsPerDay) + Int64(UnixDelta);\nend;\n\nfunction SearchRecValidFile(const F: TSearchRec): boolean;\nbegin\n  result := (F.Name <> '') and\n            (F.Attr and faInvalidFile = 0);\nend;\n\nfunction SearchRecValidFolder(const F: TSearchRec): boolean;\nbegin\n  result := (F.Attr and faDirectoryMask = faDirectory) and\n            (F.Name <> '') and\n            (F.Name <> '.') and\n            (F.Name <> '..');\nend;\n\n{ TFileStreamFromHandle }\n\ndestructor TFileStreamFromHandle.Destroy;\nbegin\n  if not fDontReleaseHandle then\n    FileClose(Handle); // otherwise file remains opened (FPC RTL inconsistency)\nend;\n\n{ TFileStreamEx }\n\nfunction TFileStreamEx.GetSize: Int64;\nbegin\n  result := FileSize(Handle); // faster than 3 FileSeek() calls\nend;\n\nconstructor TFileStreamEx.Create(const aFileName: TFileName; Mode: cardinal);\nvar\n  h: THandle;\nbegin\n  if Mode and fmCreate = fmCreate then\n    h := FileCreate(aFileName, Mode and (not fmCreate))\n  else\n    h := FileOpen(aFileName, Mode);\n  CreateFromHandle(aFileName, h);\nend;\n\nconstructor TFileStreamEx.CreateFromHandle(const aFileName: TFileName; aHandle: THandle);\nbegin\n  if not ValidHandle(aHandle) then\n    raise EOSException.CreateFmt('%s.Create(%s) failed as %s',\n      [ClassNameShort(self)^, aFileName, GetErrorText(GetLastError)]);\n  inherited Create(aHandle); // TFileStreamFromHandle constructor which own it \n  fFileName := aFileName;\nend;\n\nconstructor TFileStreamEx.CreateWrite(const aFileName: TFileName);\nvar\n  h: THandle;\nbegin\n  h := FileOpen(aFileName, fmOpenReadWrite or fmShareRead);\n  if not ValidHandle(h) then // we may need to create the file\n    h := FileCreate(aFileName, fmShareRead);\n  CreateFromHandle(aFileName, h);\nend;\n\n\n{ TFileStreamNoWriteError }\n\nconstructor TFileStreamNoWriteError.CreateAndRenameIfLocked(\n  var aFileName: TFileName; aAliases: integer);\nvar\n  h: THandle;\n  fn, ext: TFileName;\n  err, retry: integer;\n\n  function CanOpenWrite: boolean;\n  begin\n    h := FileOpen(aFileName, fmOpenReadWrite or fmShareRead);\n    result := ValidHandle(h);\n    if not result then\n      err := GetLastError;\n  end;\n\nbegin\n  // logic similar to TSynLog.CreateLogWriter\n  h := 0;\n  err := 0;\n  if not CanOpenWrite then\n    if not FileExists(aFileName) then\n      // immediately raise EOSException if this new file could not be created\n      h := FileCreate(aFileName, fmShareRead)\n    else\n    begin\n      fn := aFileName;\n      ext := ExtractFileExt(aFileName);\n      for retry := 1 to aAliases do\n      begin\n        if IsSharedViolation(err) then\n        begin\n          // file was locked: wait a little for a background process and retry\n          SleepHiRes(50);\n          if CanOpenWrite then\n            break;\n        end;\n        // file can't be opened: try '<filename>-locked<#>.<ext>' alternatives\n        aFileName := ChangeFileExt(fn, '-locked' + IntToStr(retry) + ext);\n        if CanOpenWrite then\n          break;\n      end;\n    end;\n  CreateFromHandle(aFileName, h);\nend;\n\nfunction TFileStreamNoWriteError.Write(const Buffer; Count: Longint): Longint;\nbegin\n  FileWriteAll(Handle, @Buffer, Count); // and ignore any I/O error\n  result := Count; //\nend;\n\n\nfunction FileStreamSequentialRead(const FileName: TFileName): THandleStream;\nbegin\n  result := TFileStreamFromHandle.Create(FileOpenSequentialRead(FileName));\nend;\n\nfunction StreamCopyUntilEnd(Source, Dest: TStream): Int64;\nvar\n  tmp: array[word] of word; // 128KB stack buffer\n  read: integer;\nbegin\n  result := 0;\n  if (Source <> nil) and\n     (Dest <> nil) then\n    repeat\n      read := Source.Read(tmp, SizeOf(tmp));\n      if read <= 0 then\n        break;\n      Dest.WriteBuffer(tmp, read);\n      inc(result, read);\n    until false;\nend;\n\nfunction FileReadAll(F: THandle; Buffer: pointer; Size: PtrInt): boolean;\nvar\n  chunk, read: PtrInt;\nbegin\n  result := false;\n  if Size > 0 then\n    repeat\n      chunk := Size;\n      {$ifdef OSWINDOWS}\n      if chunk > 16 shl 20 then\n        chunk := 16 shl 20; // to avoid ERROR_NO_SYSTEM_RESOURCES errors\n      {$endif OSWINDOWS}\n      read := FileRead(F, Buffer^, chunk);\n      if read <= 0 then\n        exit; // error reading Size bytes\n      inc(PByte(Buffer), read);\n      dec(Size, read);\n    until Size = 0;\n  result := true;\nend;\n\nfunction FileWriteAll(F: THandle; Buffer: pointer; Size: PtrInt): boolean;\nvar\n  written: PtrInt;\nbegin\n  result := false;\n  if Size > 0 then\n    repeat\n      written := FileWrite(F, Buffer^, Size);\n      if written <= 0 then\n        exit; // fatal error\n      inc(PByte(Buffer), written); // e.g. may have been interrrupted\n      dec(Size, written);\n    until Size = 0;\n  result := true;\nend;\n\nfunction StringFromFile(const FileName: TFileName; HasNoSize: boolean): RawByteString;\nvar\n  F: THandle;\n  size: Int64;\n  read, pos: integer;\n  tmp: array[0..$7fff] of AnsiChar; // 32KB stack buffer\nbegin\n  result := '';\n  if FileName = '' then\n    exit;\n  F := FileOpenSequentialRead(FileName); // = plain fpOpen() on POSIX\n  if ValidHandle(F) then\n  begin\n    if HasNoSize then\n    begin\n      pos := 0;\n      repeat\n        read := FileRead(F, tmp, SizeOf(tmp)); // fill per 32KB local buffer\n        if read <= 0 then\n          break;\n        SetLength(result, pos + read); // in-place resize\n        MoveFast(tmp, PByteArray(result)^[pos], read);\n        inc(pos, read);\n      until false;\n    end\n    else\n    begin\n      size := FileSize(F);\n      if (size < MaxInt) and // 2GB seems big enough for a RawByteString\n         (size > 0) then\n      begin\n        FastSetString(RawUtf8(result), size); // assume CP_UTF8 for FPC RTL bug\n        if not FileReadAll(F, pointer(result), size) then\n          result := ''; // error reading\n      end;\n    end;\n    FileClose(F);\n  end;\nend;\n\nfunction StringFromFirstFile(const FileName: array of TFileName): RawByteString;\nvar\n  f: PtrInt;\nbegin\n  for f := 0 to high(FileName) do\n  begin\n    result := StringFromFile(FileName[f]);\n    if result <> '' then\n      exit;\n  end;\n  result := '';\nend;\n\nfunction StringFromFiles(const FileName: array of TFileName): TRawByteStringDynArray;\nvar\n  f: PtrInt;\nbegin\n  result := nil;\n  SetLength(result, length(FileName));\n  for f := 0 to high(FileName) do\n    result[f] := StringFromFile(FileName[f]);\nend;\n\nfunction StringFromFolders(const Folders: array of TFileName;\n  const Mask: TFileName; FileNames: PFileNameDynArray): TRawByteStringDynArray;\nvar\n  dir, fn: TFileName;\n  sr: TSearchRec;\n  f, n: PtrInt;\n  one: RawUtf8;\nbegin\n  result := nil;\n  if FileNames <> nil then\n    FileNames^ := nil;\n  n := 0;\n  for f := 0 to high(Folders) do\n    if DirectoryExists(Folders[f]) then\n    begin\n      dir := IncludeTrailingPathDelimiter(Folders[f]);\n      if FindFirst(dir + Mask, faAnyFile - faDirectory, sr) = 0 then\n      begin\n        repeat\n          if SearchRecValidFile(sr) then\n          begin\n            fn := dir + sr.Name;\n            one := StringFromFile(fn);\n            if one <> '' then\n            begin\n              if length(result) = n then\n              begin\n                SetLength(result, NextGrow(n));\n                if FileNames <> nil then\n                  SetLength(FileNames^, length(result));\n              end;\n              result[n] := one;\n              if FileNames <> nil then\n                FileNames^[n] := fn;\n              inc(n);\n            end;\n          end;\n        until FindNext(sr) <> 0;\n        FindClose(sr);\n      end;\n    end;\n  if n = 0 then\n    exit;\n  DynArrayFakeLength(result, n);\n  if FileNames <> nil then\n    DynArrayFakeLength(FileNames^, n);\nend;\n\nfunction FileFromString(const Content: RawByteString;\n  const FileName: TFileName; FlushOnDisk: boolean): boolean;\nvar\n  h: THandle;\nbegin\n  result := false;\n  h := FileCreate(FileName);\n  if not ValidHandle(h) then\n    exit;\n  if not FileWriteAll(h, pointer(Content), length(Content)) then\n  begin\n    FileClose(h); // abort on write error\n    exit;\n  end;\n  if FlushOnDisk then\n    FlushFileBuffers(h);\n  FileClose(h);\n  result := true;\nend;\n\nfunction FileFromBuffer(Buf: pointer; Len: PtrInt; const FileName: TFileName): boolean;\nvar\n  h: THandle;\nbegin\n  result := false;\n  h := FileCreate(FileName);\n  if not ValidHandle(h) then\n    exit;\n  result := FileWriteAll(h, Buf, Len);\n  FileClose(h);\nend;\n\nfunction AppendToFile(const Content: RawUtf8; const FileName: TFileName;\n  BackupOverMaxSize: Int64): boolean;\nvar\n  h: THandle;\n  bak: TFileName;\nbegin\n  result := Content = '';\n  if result then\n    exit;\n  if (BackupOverMaxSize > 0) and\n     (FileSize(FileName) > BackupOverMaxSize) then\n  begin\n    bak := FileName + '.bak';\n    DeleteFile(bak);\n    RenameFile(FileName, bak);\n    h := 0;\n  end\n  else\n    h := FileOpen(FileName, fmOpenWriteShared);\n  if ValidHandle(h) then\n    FileSeek64(h, 0, soFromEnd) // append\n  else\n  begin\n    h := FileCreate(FileName, fmShareReadWrite);\n    if not ValidHandle(h) then\n      exit;\n  end;\n  result := FileWriteAll(h, pointer(Content), Length(Content));\n  FileClose(h);\nend;\n\nvar\n  _TmpCounter: integer;\n\nfunction TemporaryFileName: TFileName;\nvar\n  folder: TFileName;\n  retry: integer;\nbegin\n  // fast cross-platform implementation\n  folder := GetSystemPath(spTemp);\n  if _TmpCounter = 0 then\n    _TmpCounter := Random32;\n  retry := 10;\n  repeat\n    // thread-safe unique file name generation\n    result := Format('%s%s_%x.tmp',\n      [folder, Executable.ProgramName, InterlockedIncrement(_TmpCounter)]);\n    if not FileExists(result) then\n      exit;\n    dec(retry); // no endless loop\n  until retry = 0;\n  raise EOSException.Create('TemporaryFileName failed');\nend;\n\nfunction GetLastDelim(const FileName: TFileName; OtherDelim: cardinal): PtrInt;\nvar\n  {$ifdef UNICODE}\n  p: PWordArray absolute FileName;\n  {$else}\n  p: PByteArray absolute FileName;\n  {$endif UNICODE}\nbegin\n  result := length(FileName);\n  while (result > 0) and\n        not (p[result - 1] in [ord('\\'), ord('/'), ord(':'), OtherDelim]) do\n    dec(result);\nend;\n\nfunction GetLastDelimU(const FileName: RawUtf8; OtherDelim: AnsiChar): PtrInt;\nbegin\n  result := length(FileName);\n  while (result > 0) and\n        not (FileName[result] in ['\\', '/', ':', OtherDelim]) do\n    dec(result);\nend;\n\nfunction ExtractPath(const FileName: TFileName): TFileName;\nbegin\n  SetString(result, PChar(pointer(FileName)), GetLastDelim(FileName, 0));\nend;\n\nfunction ExtractName(const FileName: TFileName): TFileName;\nbegin\n  result := copy(FileName, GetLastDelim(FileName, 0) + 1, maxInt);\nend;\n\nfunction ExtractNameU(const FileName: RawUtf8): RawUtf8;\nbegin\n  result := copy(FileName, GetLastDelimU(FileName, #0) + 1, maxInt);\nend;\n\nfunction ExtractPathU(const FileName: RawUtf8): RawUtf8;\nbegin\n  FastSetString(result, pointer(FileName), GetLastDelimU(FileName, #0));\nend;\n\nfunction ExtractExt(const FileName: TFileName; WithoutDot: boolean): TFileName;\nvar\n  i: PtrInt;\nbegin\n  result := '';\n  i := GetLastDelim(FileName, ord('.'));\n  if (i <= 1) or\n     (FileName[i] <> '.') then\n    exit;\n  if WithoutDot then\n    inc(i);\n  result := copy(FileName, i, 100);\nend;\n\nfunction ExtractExtU(const FileName: RawUtf8; WithoutDot: boolean): RawUtf8;\nvar\n  i: PtrInt;\nbegin\n  result := '';\n  i := GetLastDelimU(FileName, '.');\n  if (i <= 1) or\n     (FileName[i] <> '.') then\n    exit;\n  if WithoutDot then\n    inc(i);\n  result := copy(FileName, i, 100);\nend;\n\nfunction ExtractExtP(const FileName: RawUtf8; WithoutDot: boolean): PUtf8Char;\nvar\n  i: PtrInt;\nbegin\n  result := nil;\n  i := GetLastDelimU(FileName, '.') - 1;\n  if i <= 0 then\n    exit;\n  result := PUtf8Char(pointer(FileName)) + i;\n  if result^ <> '.' then\n    result := nil\n  else if WithoutDot then\n    inc(result);\nend;\n\nfunction GetFileNameWithoutExt(const FileName: TFileName; Extension: PFileName): TFileName;\nvar\n  i, max: PtrInt;\nbegin\n  i := length(FileName);\n  max := i - 16; // a file .extension is unlikely to be more than 16 chars\n  while (i > 0) and\n        not (cardinal(FileName[i]) in [ord('\\'), ord('/'), ord('.'), ord(':')]) and\n        (i >= max) do\n    dec(i);\n  if (i = 0) or\n     (FileName[i] <> '.') then\n  begin\n    result := FileName;\n    if Extension <> nil then\n      Extension^ := '';\n  end\n  else\n  begin\n    result := copy(FileName, 1, i - 1);\n    if Extension <> nil then\n      Extension^ := copy(FileName, i, 100);\n  end;\nend;\n\nfunction GetFileNameWithoutExtOrPath(const FileName: TFileName): RawUtf8;\nbegin\n  result := RawUtf8(GetFileNameWithoutExt(ExtractFileName(FileName)));\nend;\n\n{$ifdef ISDELPHI20062007} // circumvent Delphi 2007 RTL inlining issue\nfunction AnsiCompareFileName(const S1, S2 : TFileName): integer;\nbegin\n  result := SysUtils.AnsiCompareFileName(S1,S2);\nend;\n{$endif ISDELPHI20062007}\n\nfunction SortDynArrayFileName(const A, B): integer;\nvar\n  Aname, Aext, Bname, Bext: TFileName;\nbegin\n  // code below is not very fast, but correct ;)\n  Aname := GetFileNameWithoutExt(string(A), @Aext);\n  Bname := GetFileNameWithoutExt(string(B), @Bext);\n  result := AnsiCompareFileName(Aext, Bext);\n  if result = 0 then\n    // if both extensions matches, compare by filename\n    result := AnsiCompareFileName(Aname, Bname);\nend;\n\nfunction EnsureDirectoryExists(const Directory: TFileName;\n  RaiseExceptionOnCreationFailure: ExceptionClass): TFileName;\nbegin\n  if Directory = '' then\n    if RaiseExceptionOnCreationFailure <> nil then\n      raise RaiseExceptionOnCreationFailure.Create('EnsureDirectoryExists('''')')\n    else\n      result := ''\n  else\n  begin\n    result := IncludeTrailingPathDelimiter(ExpandFileName(Directory));\n    if not DirectoryExists(result) then\n      if not ForceDirectories(result) then\n        if RaiseExceptionOnCreationFailure <> nil then\n          raise RaiseExceptionOnCreationFailure.CreateFmt(\n            'EnsureDirectoryExists(%s) failed as %s',\n            [result, GetErrorText(GetLastError)])\n        else\n          result := '';\n  end;\nend;\n\nfunction NormalizeDirectoryExists(const Directory: TFileName;\n  RaiseExceptionOnCreationFailure: ExceptionClass): TFileName;\nbegin\n  result := EnsureDirectoryExists(NormalizeFileName(Directory),\n    RaiseExceptionOnCreationFailure);\nend;\n\nfunction DirectoryDelete(const Directory: TFileName; const Mask: TFileName;\n  DeleteOnlyFilesNotDirectory: boolean; DeletedCount: PInteger): boolean;\nvar\n  F: TSearchRec;\n  Dir: TFileName;\n  n: integer;\nbegin\n  n := 0;\n  result := true;\n  if DirectoryExists(Directory) then\n  begin\n    Dir := IncludeTrailingPathDelimiter(Directory);\n    if FindFirst(Dir + Mask, faAnyFile - faDirectory, F) = 0 then\n    begin\n      repeat\n        if SearchRecValidFile(F) then\n          if DeleteFile(Dir + F.Name) then\n            inc(n)\n          else\n            result := false;\n      until FindNext(F) <> 0;\n      FindClose(F);\n    end;\n    if not DeleteOnlyFilesNotDirectory and\n       not RemoveDir(Dir) then\n      result := false;\n  end;\n  if DeletedCount <> nil then\n    DeletedCount^ := n;\nend;\n\nfunction DirectoryDeleteOlderFiles(const Directory: TFileName;\n  TimePeriod: TDateTime; const Mask: TFileName; Recursive: boolean;\n  TotalSize: PInt64): boolean;\nvar\n  F: TSearchRec;\n  Dir: TFileName;\n  old: TDateTime;\nbegin\n  if not Recursive and\n     (TotalSize <> nil) then\n    TotalSize^ := 0;\n  result := true;\n  if (Directory = '') or\n     not DirectoryExists(Directory) then\n    exit;\n  Dir := IncludeTrailingPathDelimiter(Directory);\n  if FindFirst(Dir + Mask, faAnyFile, F) = 0 then\n  begin\n    old := NowUtc - TimePeriod;\n    repeat\n      if SearchRecValidFolder(F) then\n      begin\n        if Recursive then\n          DirectoryDeleteOlderFiles(\n            Dir + F.Name, TimePeriod, Mask, true, TotalSize);\n      end\n      else if SearchRecValidFile(F) and\n              (SearchRecToDateTimeUtc(F) < old) then\n        if not DeleteFile(Dir + F.Name) then\n          result := false\n        else if TotalSize <> nil then\n          inc(TotalSize^, F.Size);\n    until FindNext(F) <> 0;\n    FindClose(F);\n  end;\nend;\n\nvar\n  lastIsDirectoryWritable: TFileName; // naive but efficient cache\n\nfunction IsDirectoryWritable(const Directory: TFileName;\n  Flags: TIsDirectoryWritable): boolean;\nvar\n  dir, last, fmt, fn: TFileName;\n  f: THandle;\n  retry: integer;\nbegin\n  // check the Directory itself\n  result := false;\n  if Directory = '' then\n    exit;                       \n  dir := ExcludeTrailingPathDelimiter(Directory);\n  if Flags = [] then\n  begin\n    last := lastIsDirectoryWritable;\n    result := (last <> '') and\n              (dir = last);\n    if result then\n      exit; // we just tested this folder\n  end;\n  if not FileIsWritable(dir) then\n    exit; // the folder does not exist or is read-only for the current user\n  {$ifdef OSWINDOWS}\n  // ensure is not a system/virtual folder\n  if ((idwExcludeWinUac in Flags) and\n      IsUacVirtualFolder(dir)) or\n     ((idwExcludeWinSys in Flags) and\n      IsSystemFolder(dir)) then\n    exit;\n  // compute a non existing temporary file name in this Directory\n  if idwTryWinExeFile in Flags then\n    fmt := '%s\\%x.exe'  // may trigger the anti-virus heuristic\n  else\n    fmt := '%s\\%x.test'; // neutral file name\n    // we tried .crt which triggered UAC heuristic but also some anti-viruses :(\n  {$else}\n  // compute a non existing temporary file name in this Directory\n  fmt := '%s/.%x.test'; // make the file \"invisible\"\n  {$endif OSWINDOWS}\n  retry := 10;\n  repeat\n    fn := Format(fmt, [dir, Random32]);\n    if not FileExists(fn) then\n      break;\n    dec(retry); // never loop forever\n    if retry = 0 then\n      exit;\n  until false;\n  // ensure we can create this temporary file\n  f := FileCreate(fn);\n  if not ValidHandle(f) then\n    exit; // a file can't be created\n  result := true;\n  if (idwWriteSomeContent in flags) and // some pointers and hash\n     (FileWrite(f, Executable, SizeOf(Executable)) <> SizeOf(Executable)) then\n    result := false;\n  FileClose(f);\n  if not DeleteFile(fn) then // success if the file can be created and deleted\n    result := false\n  else if result then\n    lastIsDirectoryWritable := dir\nend;\n\n\n{$ifndef NOEXCEPTIONINTERCEPT}\n\n{$ifdef WITH_RAISEPROC} // for FPC on Win32 + Linux (Win64=WITH_VECTOREXCEPT)\nvar\n  OldRaiseProc: TExceptProc;\n\nprocedure SynRaiseProc(Obj: TObject; Addr: CodePointer;\n  FrameCount: integer; Frame: PCodePointer);\nvar\n  ctxt: TSynLogExceptionContext;\n  backuplasterror: DWORD;\n  backuphandler: TOnRawLogException;\nbegin\n  if (Obj <> nil) and\n     Obj.InheritsFrom(Exception) then\n  begin\n    backuplasterror := GetLastError;\n    backuphandler := _RawLogException;\n    if Assigned(backuphandler) then\n      try\n        _RawLogException := nil; // disable nested exception\n        ctxt.EClass := PPointer(Obj)^;\n        ctxt.EInstance := Exception(Obj);\n        ctxt.EAddr := PtrUInt(Addr);\n        if Obj.InheritsFrom(EExternal) then\n          ctxt.ELevel := sllExceptionOS\n        else\n          ctxt.ELevel := sllException;\n        ctxt.ETimestamp := UnixTimeUtc;\n        ctxt.EStack := pointer(Frame);\n        ctxt.EStackCount := FrameCount;\n        backuphandler(ctxt);\n      except\n        { ignore any nested exception }\n      end;\n    _RawLogException := backuphandler;\n    SetLastError(backuplasterror); // may have changed above\n  end;\n  if Assigned(OldRaiseProc) then\n    OldRaiseProc(Obj, Addr, FrameCount, Frame);\nend;\n\n{$endif WITH_RAISEPROC}\n\nvar\n  RawExceptionIntercepted: boolean;\n\nprocedure RawExceptionIntercept(const Handler: TOnRawLogException);\nbegin\n  _RawLogException := Handler;\n  if RawExceptionIntercepted or\n     not Assigned(Handler) then\n    exit;\n  RawExceptionIntercepted := true; // intercept once\n  {$ifdef WITH_RAISEPROC}\n  // FPC RTL redirection function\n  if not Assigned(OldRaiseProc) then\n  begin\n    OldRaiseProc := RaiseProc;\n    RaiseProc := @SynRaiseProc;\n  end;\n  {$endif WITH_RAISEPROC}\n  {$ifdef WITH_VECTOREXCEPT} // SEH32/SEH64 official API\n  // RemoveVectoredContinueHandler() is available under 64 bit editions only\n  if Assigned(AddVectoredExceptionHandler) then\n  begin\n    AddVectoredExceptionHandler(0, @SynLogVectoredHandler);\n    AddVectoredExceptionHandler := nil;\n  end;\n  {$endif WITH_VECTOREXCEPT}\n  {$ifdef WITH_RTLUNWINDPROC}\n  // Delphi x86 RTL redirection function\n  if not Assigned(OldUnWindProc) then\n  begin\n    OldUnWindProc := RTLUnwindProc;\n    RTLUnwindProc := @SynRtlUnwind;\n  end;\n  {$endif WITH_RTLUNWINDPROC}\nend;\n\n{$endif NOEXCEPTIONINTERCEPT}\n\n\n{ TMemoryMap }\n\nfunction TMemoryMap.Map(aFile: THandle; aCustomSize: PtrUInt;\n  aCustomOffset: Int64; aFileOwned: boolean; aFileSize: Int64): boolean;\nvar\n  Available: Int64;\nbegin\n  fBuf := nil;\n  fBufSize := 0;\n  {$ifdef OSWINDOWS}\n  fMap := 0;\n  {$endif OSWINDOWS}\n  fFileLocal := aFileOwned;\n  fFile := aFile;\n  if aFileSize < 0 then\n    aFileSize := mormot.core.os.FileSize(fFile);\n  fFileSize := aFileSize;\n  if aFileSize = 0 then\n  begin\n    result := true; // handle 0 byte file without error (but no memory map)\n    exit;\n  end;\n  result := false;\n  if (fFileSize <= 0)\n     {$ifdef CPU32} or (fFileSize > maxInt){$endif} then\n    // maxInt = $7FFFFFFF = 1.999 GB (2GB would induce PtrInt errors on CPU32)\n    exit;\n  if aCustomSize = 0 then\n    fBufSize := fFileSize\n  else\n  begin\n    Available := fFileSize - aCustomOffset;\n    if Available < 0 then\n      exit;\n    if aCustomSize > Available then\n      fBufSize := Available;\n    fBufSize := aCustomSize;\n  end;\n  fLoadedNotMapped := fBufSize < 1 shl 20;\n  if fLoadedNotMapped then\n  begin\n    // mapping is not worth it for size < 1MB which can be just read at once\n    GetMem(fBuf, fBufSize);\n    FileSeek64(fFile, aCustomOffset);\n    if FileReadAll(fFile, fBuf, fBufSize) then\n      result := true\n    else\n    begin\n      Freemem(fBuf);\n      fBuf := nil;\n      fLoadedNotMapped := false;\n    end;\n  end\n  else\n    // call actual Windows/POSIX memory mapping API\n    result := DoMap(aCustomOffset);\nend;\n\nprocedure TMemoryMap.Map(aBuffer: pointer; aBufferSize: PtrUInt);\nbegin\n  fBuf := aBuffer;\n  fFileSize := aBufferSize;\n  fBufSize := aBufferSize;\n  {$ifdef OSWINDOWS}\n  fMap := 0;\n  {$endif OSWINDOWS}\n  fFile := 0;\n  fFileLocal := false;\nend;\n\nfunction TMemoryMap.Map(const aFileName: TFileName): boolean;\nvar\n  F: THandle;\nbegin\n  result := false;\n  // Memory-mapped file access does not go through the cache manager so\n  // using FileOpenSequentialRead() is pointless here\n  F := FileOpen(aFileName, fmOpenReadShared);\n  if not ValidHandle(F) then\n    exit;\n  result := Map(F);\n  if not result then\n    FileClose(F);\n  fFileLocal := result;\nend;\n\nprocedure TMemoryMap.UnMap;\nbegin\n  if fLoadedNotMapped then\n    // mapping was not worth it\n    Freemem(fBuf)\n  else\n    // call actual Windows/POSIX map API\n    DoUnMap;\n  fBuf := nil;\n  fBufSize := 0;\n  if fFile <> 0 then\n  begin\n    if fFileLocal then\n      FileClose(fFile);\n    fFile := 0;\n  end;\nend;\n\n\n\n{ TSynMemoryStreamMapped }\n\nconstructor TSynMemoryStreamMapped.Create(const aFileName: TFileName;\n  aCustomSize: PtrUInt; aCustomOffset: Int64);\nbegin\n  fFileName := aFileName;\n  // Memory-mapped file access does not go through the cache manager so\n  // using FileOpenSequentialRead() is pointless here\n  fFileStream := TFileStreamEx.Create(aFileName, fmOpenReadShared);\n  Create(fFileStream.Handle, aCustomSize, aCustomOffset);\nend;\n\nconstructor TSynMemoryStreamMapped.Create(aFile: THandle;\n  aCustomSize: PtrUInt; aCustomOffset: Int64);\nbegin\n  if not fMap.Map(aFile, aCustomSize, aCustomOffset) then\n    raise EOSException.CreateFmt('%s.Create(%s) mapping error',\n      [ClassNameShort(self)^, fFileName]);\n  inherited Create(fMap.fBuf, fMap.fBufSize);\nend;\n\ndestructor TSynMemoryStreamMapped.Destroy;\nbegin\n  fMap.UnMap;\n  fFileStream.Free;\n  inherited;\nend;\n\n\n{ TExecutableResource }\n\nfunction TExecutableResource.Open(const ResourceName: string; ResType: PChar;\n  Instance: TLibHandle): boolean;\nbegin\n  result := false;\n  if Instance = 0 then\n    Instance := HInstance;\n  HResInfo := FindResource(Instance, PChar(ResourceName), ResType);\n  if HResInfo = 0 then\n    exit;\n  HGlobal := LoadResource(Instance, HResInfo);\n  if HGlobal = 0 then // direct decompression from memory mapped .exe content\n    exit;\n  Buffer := LockResource(HGlobal);\n  Size := SizeofResource(Instance, HResInfo);\n  if Size > 0 then\n    result := true\n  else\n    Close; // paranoid check\nend;\n\nprocedure TExecutableResource.Close;\nbegin\n  if HGlobal <> 0 then\n  begin\n    UnlockResource(HGlobal); // only needed outside of Windows\n    FreeResource(HGlobal);\n    HGlobal := 0;\n  end;\nend;\n\n\n{ ReserveExecutableMemory() / TFakeStubBuffer }\n\ntype\n  // internal memory buffer created with PAGE_EXECUTE_READWRITE flags\n  TFakeStubBuffer = class\n  public\n    Stub: PByteArray;\n    StubUsed: cardinal;\n    constructor Create;\n    destructor Destroy; override;\n    function Reserve(size: cardinal): pointer;\n  end;\n\nvar\n  CurrentFakeStubBuffer: TFakeStubBuffer;\n  CurrentFakeStubBuffers: array of TFakeStubBuffer;\n  CurrentFakeStubBufferLock: TLightLock;\n  {$ifdef UNIX}\n  MemoryProtection: boolean = false; // set to true if PROT_EXEC seems to fail\n  {$endif UNIX}\n\nconstructor TFakeStubBuffer.Create;\nbegin\n  {$ifdef OSWINDOWS}\n  Stub := VirtualAlloc(nil, STUB_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n  if Stub = nil then\n  {$else OSWINDOWS}\n  if not MemoryProtection then\n    Stub := StubCallAllocMem(STUB_SIZE, PROT_READ or PROT_WRITE or PROT_EXEC);\n  if (Stub = MAP_FAILED) or\n     MemoryProtection then\n  begin\n    // i.e. on OpenBSD or OSX M1, we can not have w^x protection\n    Stub := StubCallAllocMem(STUB_SIZE, PROT_READ OR PROT_WRITE);\n    if Stub <> MAP_FAILED then\n      MemoryProtection := True;\n  end;\n  if Stub = MAP_FAILED then\n  {$endif OSWINDOWS}\n    raise EOSException.Create('ReserveExecutableMemory(): OS mmap failed');\n  PtrArrayAdd(CurrentFakeStubBuffers, self);\nend;\n\ndestructor TFakeStubBuffer.Destroy;\nbegin\n  {$ifdef OSWINDOWS}\n  VirtualFree(Stub, 0, MEM_RELEASE);\n  {$else}\n  fpmunmap(Stub, STUB_SIZE);\n  {$endif OSWINDOWS}\n  inherited;\nend;\n\nfunction TFakeStubBuffer.Reserve(size: cardinal): pointer;\nbegin\n  result := @Stub[StubUsed];\n  while size and 15 <> 0 do\n    inc(size); // ensure the returned buffers are 16 bytes aligned\n  inc(StubUsed, size);\nend;\n\nfunction ReserveExecutableMemory(size: cardinal): pointer;\nbegin\n  if size > STUB_SIZE then\n    raise EOSException.CreateFmt('ReserveExecutableMemory(size=%d>%d)',\n      [size, STUB_SIZE]);\n  CurrentFakeStubBufferLock.Lock;\n  try\n    if (CurrentFakeStubBuffer = nil) or\n       (CurrentFakeStubBuffer.StubUsed + size > STUB_SIZE) then\n      CurrentFakeStubBuffer := TFakeStubBuffer.Create;\n    result := CurrentFakeStubBuffer.Reserve(size);\n  finally\n    CurrentFakeStubBufferLock.UnLock;\n  end;\nend;\n\n{$ifdef UNIX}\nprocedure ReserveExecutableMemoryPageAccess(Reserved: pointer; Exec: boolean);\nvar\n  PageAlignedFakeStub: pointer;\n  flags: cardinal;\nbegin\n  if not MemoryProtection then\n    // nothing to be done on this platform\n    exit;\n  // toggle execution permission of memory to be able to write into memory\n  PageAlignedFakeStub := Pointer(\n    (PtrUInt(Reserved) div SystemInfo.dwPageSize) * SystemInfo.dwPageSize);\n  if Exec then\n    flags := PROT_READ OR PROT_EXEC\n  else\n    flags := PROT_READ or PROT_WRITE;\n  if SynMProtect(PageAlignedFakeStub, SystemInfo.dwPageSize shl 1, flags) < 0 then\n     raise EOSException.Create('ReserveExecutableMemoryPageAccess: mprotect fail');\nend;\n{$else}\nprocedure ReserveExecutableMemoryPageAccess(Reserved: pointer; Exec: boolean);\nbegin\n  // nothing to be done\nend;\n{$endif UNIX}\n\n{$ifndef PUREMORMOT2}\nfunction GetDelphiCompilerVersion: RawUtf8;\nbegin\n  result := COMPILER_VERSION;\nend;\n{$endif PUREMORMOT2}\n\nfunction GetMemoryInfoText: RawUtf8;\nvar\n  info: TMemoryInfo;\nbegin\n  if GetMemoryInfo(info, false) then\n    _fmt('used %s/%s (%d%s free)', [_oskb(info.memtotal - info.memfree),\n      _oskb(info.memtotal), info.percent, '%'], result)\n  else\n    result := '';\nend;\n\nfunction GetDiskAvailable(aDriveFolderOrFile: TFileName): QWord;\nvar\n  free, total: QWord; // dummy values\nbegin\n  if not GetDiskInfo(aDriveFolderOrFile, result, free, total) then\n    result := 0;\nend;\n\nfunction GetSystemInfoText: RawUtf8;\nvar\n  avail, free, total: QWord;\nbegin\n  GetDiskInfo(Executable.ProgramFilePath, avail, free, total);\n  result := _fmt('Current UTC date is %s (%d)'#13#10'Memory %s'#13#10 +\n                 'Executable free disk %s/%s'#13#10 +\n                 {$ifdef OSPOSIX} 'LoadAvg is %s'#13#10 + {$endif OSPOSIX}\n                 '%s'#13#10'%s'#13#10'%s'#13#10'%s'#13#10,\n    [FormatDateTime('yyyy\"-\"mm\"-\"dd\" \"hh\":\"nn\":\"ss', NowUtc), UnixTimeUtc,\n     GetMemoryInfoText, _oskb(avail), _oskb(total),\n     {$ifdef OSPOSIX} RetrieveLoadAvg, {$endif} Executable.Version.VersionInfo,\n     OSVersionText, CpuInfoText, BiosInfoText]);\nend;\n\nfunction ConsoleReadBody: RawByteString;\nvar\n  len, n: integer;\n  P: PByte;\nbegin\n  len := ConsoleStdInputLen;\n  FastNewRawByteString(result, len);\n  P := pointer(result);\n  while len > 0 do\n  begin\n    n := FileRead(StdInputHandle, P^, len);\n    if n <= 0 then\n    begin\n      result := ''; // read error\n      break;\n    end;\n    dec(len, n);\n    inc(P, n);\n  end;\nend;\n\nvar\n  GlobalCriticalSection: TOSLock;\n\n{ TSynLibrary }\n\nfunction TSynLibrary.Resolve(const Prefix, ProcName: RawUtf8; Entry: PPointer;\n  RaiseExceptionOnFailure: ExceptionClass): boolean;\nvar\n  P: PAnsiChar;\n  name, search: RawUtf8;\n{$ifdef OSPOSIX}\n  dlinfo: dl_info;\n{$endif OSPOSIX}\nbegin\n  result := false;\n  if (Entry = nil) or\n     (fHandle = 0) or\n     (ProcName = '') then\n    exit; // avoid GPF\n  P := pointer(ProcName);\n  repeat\n    name := GetNextItem(P); // try all alternate names\n    if name = '' then\n      break;\n    if name[1] = '?' then\n    begin\n      RaiseExceptionOnFailure := nil;\n      delete(name, 1, 1);\n    end;\n    search := Prefix + name;\n    Entry^ := LibraryResolve(fHandle, pointer(search));\n    if (Entry^ = nil) and\n       (Prefix <> '') then // try without the prefix\n      Entry^ := LibraryResolve(fHandle, pointer(name));\n    result := Entry^ <> nil;\n  until result;\n  {$ifdef OSPOSIX}\n  if result and\n     not fLibraryPathTested then\n  begin\n    fLibraryPathTested := true;\n    FillCharFast(dlinfo, SizeOf(dlinfo), 0);\n    dladdr(Entry^, @dlinfo);\n    if dlinfo.dli_fname <> nil then\n      fLibraryPath := dlinfo.dli_fname;\n  end;\n  {$endif OSPOSIX}\n  if (RaiseExceptionOnFailure <> nil) and\n     not result then\n  begin\n    FreeLib;\n    raise RaiseExceptionOnFailure.CreateFmt(\n      '%s.Resolve(''%s%s''): not found in %s',\n      [ClassNameShort(self)^, Prefix, ProcName, LibraryPath]);\n  end;\nend;\n\nfunction TSynLibrary.ResolveAll(ProcName: PPAnsiChar; Entry: PPointer): boolean;\nvar\n  tmp: RawUtf8;\nbegin\n  repeat\n    if ProcName^ = nil then\n      break;\n    FastSetString(tmp, ProcName^, StrLen(ProcName^));\n    if not Resolve('', tmp, Entry) then\n    begin\n      FreeLib;\n      result := false;\n      exit;\n    end;\n    inc(ProcName);\n    inc(Entry);\n  until false;\n  result := true;\nend;\n\ndestructor TSynLibrary.Destroy;\nbegin\n  FreeLib;\n  inherited Destroy;\nend;\n\nprocedure TSynLibrary.FreeLib;\nbegin\n  if fHandle = 0 then\n    exit; // nothing to free\n  LibraryClose(fHandle);\n  fHandle := 0;\nend;\n\nfunction TSynLibrary.TryLoadLibrary(const aLibrary: array of TFileName;\n  aRaiseExceptionOnFailure: ExceptionClass): boolean;\nvar\n  i, j: PtrInt;\n  {$ifdef OSWINDOWS}\n  cwd,\n  {$endif OSWINDOWS}\n  lib, libs, nwd: TFileName;\n  err: string;\nbegin\n  for i := 0 to high(aLibrary) do\n  begin\n    // check library name\n    lib := aLibrary[i];\n    if lib = '' then\n      continue;\n    result := true;\n    for j := 0 to i - 1 do\n      if aLibrary[j] = lib then\n      begin\n        result := false;\n        break;\n      end;\n    if not result then\n      continue; // don't try twice the same library name\n    // open the library\n    nwd := ExtractFilePath(lib);\n    if fTryFromExecutableFolder  and\n       (nwd = '') and\n       FileExists(Executable.ProgramFilePath + lib) then\n    begin\n      lib := Executable.ProgramFilePath + lib;\n      nwd := Executable.ProgramFilePath;\n    end;\n    {$ifdef OSWINDOWS}\n    if nwd <> '' then\n    begin\n      cwd := GetCurrentDir;\n      SetCurrentDir(nwd); // change the current folder at loading on Windows\n    end;\n    fHandle := LibraryOpen(lib); // preserve x87 flags and prevent msg box \n    if nwd <> '' then\n      SetCurrentDir(cwd{%H-});\n    {$else}\n    fHandle := LibraryOpen(lib); // use regular .so loading behavior\n    {$endif OSWINDOWS}\n    if fHandle <> 0 then\n    begin\n      {$ifdef OSWINDOWS} // on POSIX, will call dladdr() in Resolve()\n      fLibraryPath := GetModuleName(fHandle);\n      if length(fLibraryPath) < length(lib) then\n      {$endif OSWINDOWS}\n        fLibraryPath := lib;\n      exit;\n    end;\n    // handle any error\n    if {%H-}libs = '' then\n      libs := lib\n    else\n      libs := libs + ', ' + lib;\n    err := LibraryError;\n    if err <> '' then\n      libs := libs + ' [' + err + ']';\n  end;\n  result := false;\n  if aRaiseExceptionOnFailure <> nil then\n    raise aRaiseExceptionOnFailure.CreateFmt('%s.TryLoadLibray failed' +\n      ' - searched in %s', [ClassNameShort(self)^, libs]);\nend;\n\nfunction TSynLibrary.Exists: boolean;\nbegin\n  result := (self <> nil) and\n            (fHandle <> 0);\nend;\n\n\n{ TFileVersion }\n\nconstructor TFileVersion.Create(const aFileName: TFileName;\n  aMajor, aMinor, aRelease, aBuild: integer);\nvar\n  M, D: word;\nbegin\n  fFileName := aFileName;\n  SetVersion(aMajor, aMinor, aRelease, aBuild);\n  if fBuildDateTime = 0 then // get build date from file age\n    fBuildDateTime := FileAgeToDateTime(aFileName);\n  if fBuildDateTime <> 0 then\n    DecodeDate(fBuildDateTime, BuildYear, M, D);\nend;\n\nfunction TFileVersion.Version32: integer;\nbegin\n  if self = nil then\n    result := 0\n  else\n    result := Major shl 16 + Minor shl 8 + Release;\nend;\n\nfunction TFileVersion.SetVersion(aMajor, aMinor, aRelease, aBuild: integer): boolean;\nbegin\n  result := (Major <> aMajor) or\n            (Minor <> aMinor) or\n            (Release <> aRelease) or\n            (Build <> aBuild);\n  if not result then\n    exit;\n  Major := aMajor;\n  Minor := aMinor;\n  Release := aRelease;\n  Build := aBuild;\n  Main := Format('%d.%d', [Major, Minor]);\n  if Build <> 0 then\n    fDetailed := Format('%s.%d.%d', [Main, Release, Build])\n  else if Release <> 0 then\n    fDetailed := Format('%s.%d', [Main, Release])\n  else\n    fDetailed := Main;\n  fVersionInfo :=  '';\n  fUserAgent := '';\nend;\n\nfunction TFileVersion.BuildDateTimeString: string;\nbegin\n  result := DateTimeToIsoString(fBuildDateTime);\nend;\n\nfunction TFileVersion.DetailedOrVoid: string;\nbegin\n  if (self = nil) or\n     (Major or Minor or Release or Build = 0) then\n    result := ''\n  else\n    result := fDetailed;\nend;\n\nfunction TFileVersion.VersionInfo: RawUtf8;\nbegin\n  if self = nil then\n    result := ''\n  else\n  begin\n    if fVersionInfo = '' then\n      _fmt('%s %s (%s)', [ExtractFileName(fFileName),\n        DetailedOrVoid, BuildDateTimeString], fVersionInfo);\n    result := fVersionInfo;\n  end;\nend;\n\nfunction TFileVersion.UserAgent: RawUtf8;\nbegin\n  if self = nil then\n    result := ''\n  else\n  begin\n    if fUserAgent = '' then\n    begin\n      _fmt('%s/%s%s', [GetFileNameWithoutExtOrPath(fFileName), DetailedOrVoid,\n        OS_INITIAL[OS_KIND]], fUserAgent);\n      {$ifdef OSWINDOWS}\n      if OSVersion in WINDOWS_32 then\n        fUserAgent := fUserAgent + '32';\n      {$endif OSWINDOWS}\n    end;\n    result := fUserAgent;\n  end;\nend;\n\nclass function TFileVersion.GetVersionInfo(const aFileName: TFileName): RawUtf8;\nbegin\n  with Create(aFileName, 0, 0, 0, 0) do\n  try\n    result := VersionInfo;\n  finally\n    Free;\n  end;\nend;\n\nfunction UserAgentParse(const UserAgent: RawUtf8;\n  out ProgramName, ProgramVersion: RawUtf8;\n  out OS: TOperatingSystem): boolean;\nvar\n  i, v, vlen, o: PtrInt;\nbegin\n  result := false;\n  ProgramName := Split(UserAgent, '/');\n  v := length(ProgramName);\n  if (v = 0) or\n     (UserAgent[v + 1] <> '/') then\n    exit;\n  inc(v, 2);\n  vlen := 0;\n  o := -1;\n  for i := v to length(UserAgent) do\n    if not (UserAgent[i] in ['0' .. '9', '.']) then\n    begin\n      vlen := i - v; // vlen may be 0 if DetailedOrVoid was ''\n      if UserAgent[i + 1] in [#0, '3'] then // end with OS_INITIAL or '32' suffix\n        o := ByteScanIndex(pointer(@OS_INITIAL),\n          ord(high(TOperatingSystem)) + 1, ord(UserAgent[i]));\n      break;\n    end;\n  if o < 0 then\n    exit; // should end with OS_INITIAL[OS_KIND]]\n  os := TOperatingSystem(o);\n  ProgramVersion := copy(UserAgent, v, vlen);\n  result := true;\nend;\n\nprocedure SetExecutableVersion(const aVersionText: RawUtf8);\nvar\n  P: PUtf8Char;\n  i: integer;\n  ver: array[0 .. 3] of integer;\nbegin\n  P := pointer(aVersionText);\n  for i := 0 to 3 do\n    ver[i] := GetNextUInt32(P);\n  SetExecutableVersion(ver[0], ver[1], ver[2], ver[3]);\nend;\n\nprocedure ComputeExecutableHash;\nbegin\n  with Executable do\n  begin\n    _fmt('%s %s (%s)', [ProgramFileName,\n      Version.DetailedOrVoid, Version.BuildDateTimeString], ProgramFullSpec);\n    Hash.c0 := Version.Version32;\n    {$ifdef OSLINUXANDROID}\n    Hash.c0 := crc32c(Hash.c0, pointer(CpuInfoFeatures), length(CpuInfoFeatures));\n    {$else}\n    {$ifdef CPUINTELARM}\n    Hash.c0 := crc32c(Hash.c0, @CpuFeatures, SizeOf(CpuFeatures));\n    {$else}\n    Hash.c0 := crc32c(Hash.c0, pointer(CpuInfoText), length(CpuInfoText));\n    {$endif OSLINUXANDROID}\n    {$endif CPUINTELARM}\n    Hash.c0 := crc32c(Hash.c0, pointer(Host), length(Host));\n    Hash.c1 := crc32c(Hash.c0, pointer(User), length(User));\n    Hash.c2 := crc32c(Hash.c1, pointer(ProgramFullSpec), length(ProgramFullSpec));\n    Hash.c3 := crc32c(Hash.c2, pointer(InstanceFileName), length(InstanceFileName));\n  end;\nend;\n\nprocedure GetExecutableVersion;\nbegin\n  if Executable.Version.RetrieveInformationFromFileName then\n    ComputeExecutableHash;\nend;\n\nprocedure InitializeExecutableInformation; // called once at startup\nbegin\n  with Executable do\n  begin\n    {$ifdef OSWINDOWS}\n    ProgramFileName := ParamStr(0); // RTL seems just fine here\n    {$else}\n    ProgramFileName := GetExecutableName(@InitializeExecutableInformation);\n    if (ProgramFileName = '') or\n       not FileExists(ProgramFileName) then\n      ProgramFileName := ExpandFileName(ParamStr(0));\n    {$endif OSWINDOWS}\n    ProgramFilePath := ExtractFilePath(ProgramFileName);\n    if IsLibrary then\n      InstanceFileName := GetModuleName(HInstance)\n    else\n      InstanceFileName := ProgramFileName;\n    ProgramName := GetFileNameWithoutExtOrPath(ProgramFileName);\n    GetUserHost(User, Host);\n    if Host = '' then\n      Host := 'unknown';\n    if User = '' then\n      User := 'unknown';\n    Version := TFileVersion.Create(ProgramFileName); // with versions=0\n    Command := TExecutableCommandLine.Create;\n    Command.ExeDescription := ProgramName;\n    Command.Parse;\n  end;\n  ComputeExecutableHash;\nend;\n\nprocedure SetExecutableVersion(aMajor, aMinor, aRelease, aBuild: integer);\nbegin\n  if Executable.Version.SetVersion(aMajor, aMinor, aRelease, aBuild) then\n    ComputeExecutableHash; // re-compute if changed\nend;\n\n\n{ TExecutableCommandLine }\n\nfunction TExecutableCommandLine.SwitchAsText(const v: RawUtf8): RawUtf8;\nbegin\n  result := fSwitch[length(v) > 1] + v;\nend;\n\nprocedure TExecutableCommandLine.Describe(const v: array of RawUtf8;\n  k: TExecutableCommandLineKind; d, def: RawUtf8; argindex: integer);\nvar\n  i, j: PtrInt;\n  desc, param, pnames, sp: RawUtf8;\nbegin\n  if (self = nil) or\n     (d = '') then\n    exit;\n  if k <> clkArg then\n  begin\n    if high(v) < 0 then\n      exit;\n    desc := SwitchAsText(v[0]);\n    if length(v[0]) <> 1 then\n      desc := '    ' + desc; // right align --#\n    for i := 1 to high(v) do\n      desc := desc + ', ' + SwitchAsText(v[i]);\n  end;\n  if k <> clkOption then\n  begin\n    i := PosExChar('#', d); // #valuename in description -> <valuename>\n    if i > 0 then\n    begin\n      j := 1;\n      while d[i + j] > ' ' do\n        inc(j);\n      delete(d, i, 1); // remove #\n      if d[i] <> '#' then\n        param := copy(d, i, j - 1) // extract '<valuename>'\n      else\n      begin\n        param := copy(d, i + 1, j - 2); // ##type\n        delete(d, i, j);                // not included in description\n      end;\n    end\n    else if k = clkArg then\n      if high(v) = 0 then\n        param := v[0]\n      else if argindex > 0 then\n        param := _fmt('arg%d', [argindex])\n      else\n        param := 'arg'\n    else\n    begin\n      i := PosEx(' - values: ', d); // see SetObjectFromExecutableCommandLine()\n      if i > 0 then\n      begin\n        inc(i, 11);\n        j := 1;\n        if copy(d, i, 7) = 'set of ' then\n          inc(j, 7);\n        while d[i + j] > ' ' do\n          inc(j);\n        param := copy(d, i, j);\n        dec(i, 11);\n        delete(d, i, j + 11);\n        if j > 50 then\n        begin\n          j := 50;\n          for i := 50 downto 1 do\n            if param[i] = '|' then\n            begin\n              j := i;\n              break;\n            end;\n          insert(fLineFeed + '         ', param, j + 1);\n        end;\n      end\n      else\n        param := 'value';\n    end;\n    desc := desc + ' <' + param + '>';\n    if (k = clkArg) and\n       (argindex > 0) then\n    begin\n      if argindex > length(fDescArg) then\n        SetLength(fDescArg, argindex);\n      fDescArg[argindex - 1] := param;\n    end;\n  end;\n  fDesc[k] := fDesc[k] + ' ' + desc;\n  j := 1;\n  if fSwitch[true] <> '--' then\n    repeat\n      i := PosEx('--', d, j); // e.g. '--switch' -> '/switch' on Windows\n      if i = 0 then\n        break;\n      delete(d, i, 2);\n      insert(fSwitch[true], d, i);\n      j := i;\n    until false;\n  if def <> '' then\n    def := ' (default ' + def + ')';\n  pnames := _fmt('  %0:-20s', [desc + def]);\n  if (length(pnames) > 22) or\n     (length(d) > 80) then\n  begin\n    // write description on next line(s)\n    sp := fLineFeed + '                      ';\n    while length(d) > 57 do\n    begin\n      j := 57;\n      for i := 57 downto 1 do\n        if d[i] = ' ' then\n        begin\n          j := i;\n          break;\n        end;\n      if j = 57 then\n        for i := 57 downto 1 do\n          if d[i] in [',', ';', '|'] then\n          begin\n            j := i;\n            break;\n          end;\n      pnames := pnames + sp + copy(d, 1, j);\n      delete(d, 1, j);\n    end;\n    pnames := pnames + sp + d;\n  end\n  else\n    pnames := pnames + d; // we can put everything on the same line\n  fDescDetail[k] := fDescDetail[k] + pnames + fLineFeed;\nend;\n\nfunction TExecutableCommandLine.Find(const v: array of RawUtf8;\n  k: TExecutableCommandLineKind; const d, def: RawUtf8; f: PtrInt): PtrInt;\nvar\n  i: PtrInt;\nbegin\n  if self <> nil then\n  begin\n    if k <> clkUndefined then\n      Describe(v, k, d, def, -1);\n    if (high(v) >= 0) and\n       (fNames[k] <> nil) then\n      for i := 0 to high(v) do\n      begin\n        result := FindNonVoid[fCaseSensitiveNames](\n          @fNames[k][f], pointer(v[i]), length(v[i]), length(fNames[k]) - f);\n        if result >= 0 then\n        begin\n          inc(result, f);\n          fRetrieved[k][result] := true;\n          exit;\n        end;\n      end;\n  end;\n  result := -1\nend;\n\nfunction TExecutableCommandLine.Arg(index: integer; const description: RawUtf8;\n  optional: boolean): boolean;\nvar\n  n: PtrUInt;\nbegin\n  result := self <> nil;\n  if not result then\n    exit;\n  n := length(fNames[clkArg]);\n  result := PtrUInt(index) < n;\n  if result then\n    fRetrieved[clkArg][index] := true\n  else\n  begin\n    SetLength(fRetrieved[clkArg], n + 1); // to notify missing <arg>\n    if optional then\n      fRetrieved[clkArg][index] := true;\n  end;\n  Describe([], clkArg, description, '', index + 1);\nend;\n\nfunction TExecutableCommandLine.ArgString(index: integer;\n  const description: RawUtf8; optional: boolean): string;\nbegin\n  result := '';\n  if Arg(index, description, optional) then\n    result := string(Args[0]);\nend;\n\nfunction TExecutableCommandLine.Arg(const name, description: RawUtf8): boolean;\nbegin\n  result := Arg([name], description);\nend;\n\nfunction TExecutableCommandLine.Arg(const name: array of RawUtf8;\n  const description: RawUtf8): boolean;\nbegin\n  result := Find(name, clkArg, description) >= 0;\nend;\n\nfunction TExecutableCommandLine.Option(const name, description: RawUtf8): boolean;\nbegin\n  result := Find([name], clkOption, description) >= 0;\nend;\n\nfunction TExecutableCommandLine.Option(const name: array of RawUtf8;\n  const description: RawUtf8): boolean;\nbegin\n  result := Find(name, clkOption, description) >= 0;\nend;\n\nfunction TExecutableCommandLine.Get(const name: RawUtf8; out value: RawUtf8;\n  const description, default: RawUtf8): boolean;\nbegin\n  result := Get([name], value, description, default);\nend;\n\nprocedure AddRawUtf8(var Values: TRawUtf8DynArray; const Value: RawUtf8);\nvar\n  n: PtrInt;\nbegin\n  n := length(Values);\n  SetLength(Values, n + 1);\n  Values[n] := Value;\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  out value: TRawUtf8DynArray; const description: RawUtf8): boolean;\nvar\n  first, i: PtrInt;\nbegin\n  result := false;\n  if self = nil then\n    exit;\n  Describe(name, clkParam, description, '', -1);\n  first := 0;\n  repeat\n    i := Find(name, clkParam, '', '', first);\n    if i < 0 then\n      break;\n    AddRawUtf8(value, fValues[i]);\n    result := true;\n    first := i + 1;\n  until first >= length(fValues);\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  out value: RawUtf8; const description, default: RawUtf8): boolean;\nvar\n  i: PtrInt;\nbegin\n  if self = nil then\n    i := -1\n  else\n    i := Find(name, clkParam, description, default);\n  if i >= 0 then\n  begin\n    value := Values[i];\n    result := true;\n  end\n  else\n  begin\n    value := default;\n    result := false;\n  end;\nend;\n\nfunction TExecutableCommandLine.Get(const name: RawUtf8; out value: string;\n  const description: RawUtf8; const default: string): boolean;\nbegin\n  result := Get([name], value, description, default);\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  out value: string; const description: RawUtf8; const default: string): boolean;\nvar\n  tmp: RawUtf8;\nbegin\n  result := Get(name, tmp, description);\n  if result then\n    value := string(tmp)\n  else\n    value := default; // no conversion needed\nend;\n\nfunction TExecutableCommandLine.Get(const name: RawUtf8;\n  out value: TStringDynarray; const description: RawUtf8): boolean;\nbegin\n  result := Get([name], value, description);\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  out value: TStringDynarray; const description: RawUtf8): boolean;\nvar\n  tmp: TRawUtf8DynArray;\n  i: PtrInt;\nbegin\n  result := Get(name, tmp, description);\n  SetLength(value, length(tmp));\n  for i := 0 to length(tmp) - 1 do\n    value[i] := string(tmp[i]);\nend;\n\nfunction TExecutableCommandLine.Get(const name: RawUtf8;\n  out value: integer; const description: RawUtf8; default: integer): boolean;\nbegin\n  result := Get([name], value, description, default);\nend;\n\nfunction defI(default: integer): RawUtf8;\nbegin\n  if default = maxInt then\n    result := ''\n  else\n    result := RawUtf8(IntToStr(default));\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  out value: integer; const description: RawUtf8; default: integer): boolean;\nvar\n  i: PtrInt;\nbegin\n  if self = nil then\n    i := -1\n  else\n    i := Find(name, clkParam, description, defI(default));\n  result := (i >= 0) and\n            ToInteger(Values[i], value);\n  if not result and\n     (default <> maxInt) then\n    value := default;\nend;\n\nfunction TExecutableCommandLine.Get(const name: RawUtf8; min, max: integer;\n  out value: integer; const description: RawUtf8; default: integer): boolean;\nbegin\n  result := Get([name], min, max, value, description, default);\nend;\n\nfunction TExecutableCommandLine.Get(const name: array of RawUtf8;\n  min, max: integer; out value: integer; const description: RawUtf8;\n  default: integer): boolean;\nbegin\n  result := Get(name, value, description, default) and\n            (value >= min) and\n            (value <= max);\nend;\n\nfunction TExecutableCommandLine.Has(const name: RawUtf8): boolean;\nbegin\n  result := Find([name], clkParam) >= 0;\nend;\n\nfunction TExecutableCommandLine.Has(const name: array of RawUtf8): boolean;\nbegin\n  result := Find(name, clkParam) >= 0;\nend;\n\nfunction TExecutableCommandLine.Param(\n  const name, description, default: RawUtf8): RawUtf8;\nbegin\n  Get([name], result, description, default);\nend;\n\nfunction TExecutableCommandLine.Param(const name: array of RawUtf8;\n  const description, default: RawUtf8): RawUtf8;\nbegin\n  Get(name, result, description, default);\nend;\n\nfunction TExecutableCommandLine.ParamS(const name: array of RawUtf8;\n  const description: RawUtf8; const default: string): string;\nbegin\n  Get(name, result, description, default);\nend;\n\nfunction TExecutableCommandLine.Param(const name: RawUtf8;\n  default: integer; const description: RawUtf8): integer;\nbegin\n  Get([name], result, description, default);\nend;\n\nfunction TExecutableCommandLine.Param(const name: array of RawUtf8;\n  default: integer;const description: RawUtf8): integer;\nbegin\n  Get(name, result, description, default);\nend;\n\nconst\n  CLK_TXT: array[clkOption .. clkParam] of RawUtf8 = (\n    ' [options]', ' [params]');\n  CLK_DESCR: array[clkOption .. clkParam] of RawUtf8 = (\n    'Options', 'Params');\n  CASE_DESCR: array[boolean] of RawUtf8 = (\n    ':', ' (case-sensitive):');\n\nfunction TExecutableCommandLine.FullDescription(\n  const customexedescription, exename, onlyusage: RawUtf8): RawUtf8;\nvar\n  clk: TExecutableCommandLineKind;\nbegin\n  if customexedescription <> '' then\n    fExeDescription := customexedescription;\n  result := fExeDescription + fLineFeed + fLineFeed + 'Usage: ';\n  if exename = '' then\n    result := result + Executable.ProgramName\n  else\n    result := result + exename;\n  result := result + fDesc[clkArg];\n  for clk := low(CLK_TXT) to high(CLK_TXT) do\n    if fDesc[clk] <> '' then\n      result := result + CLK_TXT[clk];\n  result := result + fLineFeed;\n  if onlyusage <> '' then\n    result := result + onlyusage\n  else\n    for clk := low(fDescDetail) to high(fDescDetail) do\n      if fDescDetail[clk] <> '' then\n      begin\n        if clk in [low(CLK_TXT) .. high(CLK_TXT)] then\n          result := result + fLineFeed +\n                    CLK_DESCR[clk] + CASE_DESCR[CaseSensitiveNames];\n        result := result + fLineFeed + fDescDetail[clk];\n      end;\nend;\n\nfunction TExecutableCommandLine.DetectUnknown: RawUtf8;\nvar\n  clk: TExecutableCommandLineKind;\n  i: PtrInt;\nbegin\n  result := '';\n  for clk := low(fRetrieved) to high(fRetrieved) do\n    for i := 0 to length(fRetrieved[clk]) - 1 do\n      if not fRetrieved[clk][i] then\n        if clk = clkArg then\n          result := result + 'Missing <' + fDescArg[i] + '> argument' + fLineFeed\n        else\n        begin\n          result := result + 'Unexpected ' + SwitchAsText(fNames[clk][i]) + ' ';\n          case clk of\n            clkOption:\n              result := result + 'option';\n            clkParam:\n              result := result + fValues[i] + ' parameter';\n          end;\n          result := result + fLineFeed;\n        end;\nend;\n\nfunction TExecutableCommandLine.ConsoleWriteUnknown(\n  const exedescription: RawUtf8): boolean;\nvar\n  err: RawUtf8;\nbegin\n  err := DetectUnknown;\n  result := err <> '';\n  if not result then\n    exit;\n  ConsoleWrite(FullDescription(exedescription));\n  ConsoleWrite(err, ccLightRed);\n  TextColor(ccLightGray);\nend;\n\nfunction TExecutableCommandLine.ConsoleHelpFailed(\n  const exedescription: RawUtf8): boolean;\nbegin\n  if exedescription <> '' then\n    fExeDescription := exedescription;\n  result := Option(['h', 'help'], 'display this help');\n  if result then\n    ConsoleWrite(FullDescription)\n  else\n    result := ConsoleWriteUnknown(exedescription);\nend;\n\nprocedure TExecutableCommandLine.Clear;\nbegin\n  CleanupInstance; // finalize all TRawUtf8DynArray fields\nend;\n\nfunction TExecutableCommandLine.Parse(\n  const DescriptionLineFeed, ShortSwitch, LongSwitch: RawUtf8): boolean;\nvar\n  i, j, n: PtrInt;\n  swlen: TByteDynArray;\n  s: RawUtf8;\nbegin\n  result := false;\n  fLineFeed := DescriptionLineFeed;\n  if (ShortSwitch = '') or\n     (LongSwitch  = '') then\n    exit;\n  fSwitch[false] := ShortSwitch;\n  fSwitch[true]  := LongSwitch;\n  if fRawParams = nil then\n  begin\n    n := ParamCount;\n    if n <= 0 then\n      exit; // may equal -1 e.g. from a .so on MacOS\n    SetLength(fRawParams, n);\n    for i := 0 to n - 1 do\n      fRawParams[i] := RawUtf8(ParamStr(i + 1));\n  end;\n  n := length(fRawParams);\n  if n = 0 then\n  begin\n    result := true;\n    exit;\n  end;\n  SetLength(swlen, n);\n  for i := 0 to n - 1 do\n  begin\n    s := fRawParams[i];\n    if s <> '' then\n      if CompareMemSmall(pointer(s), pointer(LongSwitch), length(LongSwitch)) then\n        swlen[i] := length(LongSwitch)\n      else if CompareMemSmall(pointer(s), pointer(ShortSwitch), length(ShortSwitch)) then\n        swlen[i] := length(ShortSwitch)\n      {$ifdef OSWINDOWS}\n      else while s[swlen[i] + 1] = '-' do\n        inc(swlen[i]); // allow -v --verbose on Windows for cross-platform run\n      {$endif OSWINDOWS}\n  end;\n  i := 0;\n  repeat\n    s := fRawParams[i];\n    if s <> '' then\n      if swlen[i] <> 0 then\n      begin\n        delete(s, 1, swlen[i]);\n        if s <> '' then\n        begin\n          j := PosExChar('=', s);\n          if j <> 1 then\n            if j <> 0 then\n            begin\n              AddRawUtf8(fNames[clkParam], copy(s, 1, j - 1));\n              AddRawUtf8(fValues, copy(s, j + 1, MaxInt));\n            end\n            else if (i + 1 = n) or\n                    (swlen[i + 1] <> 0) then\n              AddRawUtf8(fNames[clkOption], s)\n            else\n            begin\n              AddRawUtf8(fNames[clkParam], s);\n              inc(i);\n              AddRawUtf8(fValues, fRawParams[i]);\n            end;\n          end;\n      end\n      else\n        AddRawUtf8(fNames[clkArg], s);\n    inc(i);\n  until i = n;\n  SetLength(fRetrieved[clkArg],    length(fNames[clkArg]));\n  SetLength(fRetrieved[clkOption], length(fNames[clkOption]));\n  SetLength(fRetrieved[clkParam],  length(fNames[clkParam]));\n  result := true;\nend;\n\nvar\n  _SystemPath: array[TSystemPath] of TFileName; // GetSystemPath() cache\n\nfunction GetSystemPath(kind: TSystemPath): TFileName;\nbegin\n  result := _SystemPath[kind];\n  if result <> '' then\n    exit;\n  _ComputeSystemPath(kind, result); // in os.posix.inc or os.windows.inc\n  _SystemPath[kind] := result;\nend;\n\nfunction SetSystemPath(kind: TSystemPath; const path: TFileName): boolean;\nvar\n  full: TFileName;\nbegin\n  full := ExpandFileName(ExcludeTrailingPathDelimiter(path));\n  result := DirectoryExists(full);\n  if result then\n    _SystemPath[kind] := IncludeTrailingPathDelimiter(full);\nend;\n\nfunction _GetExecutableLocation(aAddress: pointer): ShortString;\nvar\n  i: PtrInt;\nbegin // return the address as hexadecimal - hexstr() is not available on Delphi\n  result[0] := #0;\n  for i := SizeOf(aAddress) - 1 downto 0 do\n    AppendShortByteHex(PByteArray(aAddress)[i], result);\nend; // mormot.core.log.pas will properly decode debug info - and handle .mab\n\nvar\n  _SystemStoreAsPemSafe: TLightLock;\n  _OneSystemStoreAsPem: array[TSystemCertificateStore] of record\n    Tix: cardinal;\n    Pem: RawUtf8;\n  end;\n  _SystemStoreAsPem: record\n    Tix: cardinal;\n    Scope: TSystemCertificateStores;\n    Pem: RawUtf8;\n  end;\n\nfunction GetOneSystemStoreAsPem(CertStore: TSystemCertificateStore;\n  FlushCache: boolean; now: cardinal): RawUtf8;\nbegin\n  if now = 0 then\n    now := GetTickCount64 shr 18 + 1; // div 262.144 seconds = every 4.4 min\n  _SystemStoreAsPemSafe.Lock;\n  try\n    // first search if not already in cache\n    with _OneSystemStoreAsPem[CertStore] do\n    begin\n      if not FlushCache then\n        if Tix = now then\n        begin\n          result := Pem; // quick retrieved from cache\n          exit;\n        end;\n      // fallback search depending on the POSIX / Windows specific OS\n      result := _GetSystemStoreAsPem(CertStore); // implemented in each .inc\n      Tix := now;\n      Pem := result;\n    end;\n  finally\n    _SystemStoreAsPemSafe.UnLock;\n  end;\nend;\n\nfunction GetSystemStoreAsPem(CertStores: TSystemCertificateStores;\n  FlushCache, OnlySystemStore: boolean): RawUtf8;\nvar\n  now: cardinal;\n  s: TSystemCertificateStore;\n  v: RawUtf8;\nbegin\n  result := '';\n  now := GetTickCount64 shr 18 + 1;\n  _SystemStoreAsPemSafe.Lock;\n  try\n    // first search if not already in cache\n    if not FlushCache then\n      with _SystemStoreAsPem do\n        if (Tix = now) and\n           (Scope = CertStores) and\n           (Pem <> '') then\n        begin\n          result := Pem; // quick retrieved from cache\n          exit;\n        end;\n    // load from a file, bounded within the application or from env variable\n    if not OnlySystemStore then\n    begin\n      if GetSystemStoreAsPemLocalFile <> '' then\n        {$ifdef OSPOSIX}\n        if GetSystemStoreAsPemLocalFile[1] = '/' then // full /posix/path\n        {$else}\n        if GetSystemStoreAsPemLocalFile[2] = ':' then // 'C:\\path\\to\\file.pem'\n        {$endif OSPOSIX}\n          result := StringFromFile(GetSystemStoreAsPemLocalFile)\n        else\n          result := StringFromFile(\n            Executable.ProgramFilePath + GetSystemStoreAsPemLocalFile);\n      if result = '' then\n        result := StringFromFile(GetEnvironmentVariable('SSL_CA_CERT_FILE'));\n    end;\n  finally\n    _SystemStoreAsPemSafe.UnLock; // GetOneSystemStoreAsPem() blocks\n  end;\n  // fallback to search depending on the POSIX / Windows specific OS stores\n  if result = '' then\n    for s := low(s) to high(s) do\n      if s in CertStores then\n      begin\n        v := GetOneSystemStoreAsPem(s, FlushCache, now);\n        if v <> '' then\n          result := result + v + #13#10;\n      end;\n  if result <> '' then\n  begin\n    _SystemStoreAsPemSafe.Lock;\n    try\n      with _SystemStoreAsPem do\n      begin\n        Tix := now;\n        Scope := CertStores;\n        Pem := result;\n      end;\n    finally\n      _SystemStoreAsPemSafe.UnLock;\n    end;\n  end;\nend;\n\n{$ifdef CPUINTEL} // don't mess with raw SMBIOS encoding outside of Intel/AMD\n\n// from DSP0134 3.6.0 System Management BIOS (SMBIOS) Reference Specification\nconst\n  SMB_ANCHOR  = $5f4d535f;  // _SM_\n  SMB_INT4    = $494d445f;  // _DMI\n  SMB_INT5    = $5f;        // _\n  SMB_ANCHOR4 = $334d535f;  // _SM3\n  SMB_ANCHOR5 = $5f;        // _\n\ntype\n  TSmbEntryPoint32 = packed record\n    Anchor: cardinal;  // = SMB_ANCHOR\n    Checksum: byte;\n    Length: byte;\n    MajVers: byte;\n    MinVers: byte;\n    MaxSize: word;\n    Revision: byte;\n    PadTo16: array[1 .. 5] of byte;\n    IntAnch4: cardinal; // = SMB_INT4\n    IntAnch5: byte;     // = SMB_INT5\n    IntChecksum: byte;\n    StructLength: word;\n    StructAddr: cardinal;\n    NumStruct: word;\n    BcdRevision: byte;\n  end;\n  PSmbEntryPoint32 = ^TSmbEntryPoint32;\n\n  TSmbEntryPoint64 = packed record\n    Anch4: cardinal; // = SMB_ANCHOR4\n    Anch5: byte;     // = SMB_ANCHOR5\n    Checksum: byte;\n    Length: byte;\n    MajVers: byte;\n    MinVers: byte;\n    DocRev: byte;\n    Revision: byte;\n    Reserved: byte;\n    StructMaxLength: cardinal;\n    StructAddr: QWord;\n  end;\n  PSmbEntryPoint64 = ^TSmbEntryPoint64;\n\nfunction GetRawSmbios32(p: PSmbEntryPoint32; var info: TRawSmbiosInfo): PtrUInt;\nvar\n  cs: byte;\n  i: PtrInt;\nbegin\n  cs := 0;\n  for i := 0 to p^.Length - 1 do\n    inc(cs, PByteArray(p)[i]);\n  if cs <> 0 then\n  begin\n    result := 0; // invalid checksum\n    exit;\n  end;\n  result := p^.StructAddr;\n  info.SmbMajorVersion := p^.MajVers;\n  info.SmbMinorVersion := p^.MinVers;\n  info.DmiRevision := p^.Revision; // 0 = SMBIOS 2.1\n  info.Length := p^.StructLength;\nend;\n\nfunction GetRawSmbios64(p: PSmbEntryPoint64; var info: TRawSmbiosInfo): PtrUInt;\nvar\n  cs: byte;\n  i: PtrInt;\nbegin\n  cs := 0;\n  for i := 0 to p^.Length - 1 do\n    inc(cs, PByteArray(p)[i]);\n  if cs <> 0 then\n  begin\n    result := 0;\n    exit;\n  end;\n  result := p^.StructAddr;\n  info.SmbMajorVersion := p^.MajVers;\n  info.SmbMinorVersion := p^.MinVers;\n  info.DmiRevision := p^.Revision; // 1 = SMBIOS 3.0\n  info.Length := p^.StructMaxLength;\nend;\n\n// caller should then try to decode SMB from pointer(result) + info.Len\nfunction SearchSmbios(const mem: RawByteString; var info: TRawSmbiosInfo): PtrUInt;\nvar\n  p, pend: PSmbEntryPoint32;\nbegin\n  result := 0;\n  if mem = '' then\n    exit;\n  p := pointer(mem);\n  pend := @PByteArray(mem)[length(mem) - SizeOf(p^)];\n  repeat\n    if (p^.Anchor = SMB_ANCHOR) and\n       (p^.IntAnch4 = SMB_INT4) and\n       (p^.IntAnch5 = SMB_INT5) then\n    begin\n      result := GetRawSmbios32(p, info);\n      if result <> 0 then\n        exit;\n    end\n    else if (p^.Anchor = SMB_ANCHOR4) and\n            (p^.Checksum = SMB_ANCHOR5) then\n    begin\n      result := GetRawSmbios64(pointer(p), info);\n      if result <> 0 then\n        exit; // here info.Length = max length\n    end;\n    inc(PHash128(p)); // search on 16-byte (paragraph) boundaries\n  until PtrUInt(p) >= PtrUInt(pend);\nend;\n\n{$endif CPUINTEL}\n\nprocedure ComputeGetSmbios;\nbegin\n  GlobalLock; // thread-safe retrieval\n  try\n    if not _SmbiosRetrieved then\n    begin\n      _SmbiosRetrieved := true;\n      Finalize(RawSmbios.Data);\n      FillCharFast(RawSmbios, SizeOf(RawSmbios), 0);\n      if _GetRawSmbios(RawSmbios) then // OS specific call\n         if DecodeSmbios(RawSmbios, _Smbios) <> 0 then\n         begin\n           // we were able to retrieve and decode SMBIOS information\n           {$ifdef OSPOSIX}\n           _AfterDecodeSmbios(RawSmbios); // persist in SMB_CACHE for non-root\n           {$endif OSPOSIX}\n           exit;\n         end;\n      // if not root on POSIX, SMBIOS is not available\n      // -> try to get what the OS exposes (Linux, MacOS or FreeBSD)\n      DirectSmbiosInfo(_Smbios);\n    end;\n  finally\n    GlobalUnLock;\n  end;\nend;\n\nfunction GetRawSmbios: boolean;\nbegin\n  if not _SmbiosRetrieved then\n    ComputeGetSmbios; // fill both RawSmbios and _Smbios[]\n  result := RawSmbios.Data <> '';\nend;\n\nfunction GetSmbios(info: TSmbiosBasicInfo): RawUtf8;\nbegin\n  if not _SmbiosRetrieved then\n    ComputeGetSmbios; // fill both RawSmbios and _Smbios[]\n  result := _Smbios[info];\nend;\n\n{$ifdef ISDELPHI} // missing convenient RTL function in Delphi\nfunction TryStringToGUID(const s: string; var uuid: TGuid): boolean;\nbegin\n  try\n    uuid := StringToGUID(s);\n    result := true;\n  except\n    result := false;\n  end;\nend;\n{$endif ISDELPHI}\n\nprocedure GetComputerUuid(out uuid: TGuid);\nvar\n  n, i: PtrInt;\n  u: THash128Rec absolute uuid;\n  s: RawByteString;\n  fn: TFileName;\n  mac: TRawUtf8DynArray;\n\n  procedure crctext(const s: RawUtf8);\n  begin\n    if s = '' then\n      exit;\n    u.c[n] := crc32c(u.c[n], pointer(s), length(s));\n    n := (n + 1) and 3; // update only 32-bit of UUID per crctext() call\n  end;\n\nbegin\n  // first try to retrieve the Machine BIOS UUID\n  if not _SmbiosRetrieved then\n    ComputeGetSmbios; // maybe from local SMB_CACHE file for non-root\n  if (_Smbios[sbiUuid] <> '') and\n     TryStringToGUID('{' + string(_Smbios[sbiUuid]) + '}', uuid) then\n    exit;\n  // did we already compute this UUID?\n  fn := UUID_CACHE;\n  s := StringFromFile(fn);\n  if length(s) = SizeOf(uuid) then\n  begin\n    uuid := PGuid(s)^; // seems to be a valid UUID binary blob\n    exit;\n  end;\n  // no known UUID: compute and store a 128-bit hash from HW specs\n  // which should remain identical even between full OS reinstalls\n  // note: /etc/machine-id is no viable alternative since it is from SW random\n  {$ifdef CPUINTELARM}\n  crc128c(@CpuFeatures, SizeOf(CpuFeatures), u.b);\n  {$else}\n  s := CPU_ARCH_TEXT;\n  crc128c(pointer(s), length(s), u.b); // rough starting point\n  {$endif CPUINTELARM}\n  if RawSmbios.Data <> '' then // some bios have no uuid but some HW info\n    crc32c128(@u.b, pointer(RawSmbios.Data), length(RawSmbios.Data));\n  n := 0;\n  for i := 0 to length(_Smbios) - 1 do // some of _Smbios[] may be set\n    crctext(PRawUtf8Array(@_Smbios)[i]);\n  crctext(CpuCacheText);\n  crctext(BiosInfoText);\n  crctext(CpuInfoText);\n  if Assigned(GetSystemMacAddress) then\n    // from mormot.net.sock or mormot.core.os.posix.inc for Linux only\n    mac := GetSystemMacAddress;\n  if mac <> nil then\n  begin\n    // MAC should make it unique at least over the local network\n    for i := 0 to high(mac) do\n      crctext(mac[i]);\n    // we have enough unique HW information to store it locally for next startup\n    // note: RawSmbios.Data may not be genuine e.g. between VMs\n    if FileFromBuffer(@u, SizeOf(u), fn) then\n      FileSetSticky(fn); // use S_ISVTX so that file is not removed from /var/tmp\n  end\n  else\n    // unpersisted fallback if mormot.net.sock is not included (very unlikely)\n    crctext(Executable.Host);\nend;\n\nprocedure DecodeSmbiosUuid(src: PGuid; out dest: RawUtf8; const raw: TRawSmbiosInfo);\nvar\n  uid: TGuid;\nbegin\n  uid := src^;\n  // reject full $00 = unsupported or full $ff = not set\n  if IsZero(@uid, SizeOf(uid)) or\n     ((PCardinalArray(@uid)[0] = $ffffffff) and\n      (PCardinalArray(@uid)[1] = $ffffffff) and\n      (PCardinalArray(@uid)[2] = $ffffffff) and\n      (PCardinalArray(@uid)[3] = $ffffffff)) then\n    exit;\n  // GUIDToString() already displays the first 4 bytes as little-endian\n  // - we don't need to swap those bytes as dmi_system_uuid() in dmidecode.c\n  // on Windows, to match \"wmic csproduct get uuid\" official value\n  // - on MacOs, sduInvert is set to match IOPlatformUUID value from ioreg :(\n  if (_SmbiosDecodeUuid = sduInvert) or\n  // - dmi_save_uuid() from the Linux kernel do check for SMBIOS 2.6 version\n  // https://elixir.bootlin.com/linux/latest/source/drivers/firmware/dmi_scan.c\n     ((_SmbiosDecodeUuid = sduVersion) and\n      (raw.SmbMajorVersion shl 8 + raw.SmbMinorVersion < $0206)) then\n  begin\n    uid.D1 := bswap32(uid.D1);\n    uid.D2 := swap(uid.D2);\n    uid.D3 := swap(uid.D3);\n  end;\n  dest := RawUtf8(UpperCase(copy(GUIDToString(uid), 2, 36)));\nend;\n\nfunction DecodeSmbios(var raw: TRawSmbiosInfo; out info: TSmbiosBasicInfos): PtrInt;\nvar\n  lines: array[byte] of TSmbiosBasicInfo; // single pass efficient decoding\n  len, trimright: PtrInt;\n  cur: ^TSmbiosBasicInfo;\n  s, sEnd: PByteArray;\nbegin\n  result := 0;\n  Finalize(info);\n  s := pointer(raw.Data);\n  if s = nil then\n    exit;\n  sEnd := @s[length(raw.Data)];\n  FillCharFast(lines, SizeOf(lines), 0);\n  repeat\n    if (s[0] = 127) or // type (127=EOT)\n       (s[1] < 4) or   // length\n       (PtrUInt(@s[s[1]]) > PtrUInt(sEnd)) then\n    begin\n      s := @s[2]; // truncate to the exact end of DMI/SMBIOS input\n      break;\n    end;\n    case s[0] of\n      0: // Bios Information (type 0)\n        begin\n          lines[s[4]] := sbiBiosVendor;\n          lines[s[5]] := sbiBiosVersion;\n          lines[s[8]] := sbiBiosDate;\n          if s[1] >= $17 then // 2.4+\n          begin\n            _fmt('%d.%d', [s[$14], s[$15]], info[sbiBiosRelease]);\n            _fmt('%d.%d', [s[$16], s[$17]], info[sbiBiosFirmware]);\n          end;\n        end;\n      1: // System Information (type 1)\n        begin\n          lines[s[4]] := sbiManufacturer;\n          lines[s[5]] := sbiProductName;\n          lines[s[6]] := sbiVersion;\n          lines[s[7]] := sbiSerial;\n          if s[1] >= $18 then // 2.1+\n          begin\n            DecodeSmbiosUuid(@s[8], info[sbiUuid], raw);\n            if s[1] >= $1a then // 2.4+\n            begin\n              lines[s[$19]] := sbiSku;\n              lines[s[$1a]] := sbiFamily;\n            end;\n          end;\n        end;\n      2: // Baseboard (or Module) Information (type 2) - keep only the first\n        begin\n          lines[s[4]] := sbiBoardManufacturer;\n          lines[s[5]] := sbiBoardProductName;\n          lines[s[6]] := sbiBoardVersion;\n          lines[s[7]] := sbiBoardSerial;\n          lines[s[8]] := sbiBoardAssetTag;\n          lines[s[10]] := sbiBoardLocation;\n        end;\n      4: // Processor Information (type 4) - keep only the first\n        begin\n          lines[s[7]] := sbiCpuManufacturer;\n          lines[s[$10]] := sbiCpuVersion;\n          if s[1] >= $22 then // 2.3+\n          begin\n            lines[s[$20]] := sbiCpuSerial;\n            lines[s[$21]] := sbiCpuAssetTag;\n            lines[s[$22]] := sbiCpuPartNumber;\n          end;\n        end;\n      11: // OEM Strings (Type 11) - keep only the first\n        if s[4] <> 0 then\n          lines[1] := sbiOem; // e.g. 'vboxVer_6.1.36'\n      22: // Portable Battery (type 22) - keep only the first\n        if s[1] >= $0f then // 2.1+\n        begin\n          lines[s[4]] := sbiBatteryLocation;\n          lines[s[5]] := sbiBatteryManufacturer;\n          lines[s[8]] := sbiBatteryName;\n          lines[s[$0e]] := sbiBatteryVersion;\n          if s[1] >= $14 then // 2.2+\n            lines[s[$14]] := sbiBatteryChemistry;\n        end;\n    end;\n    s := @s[s[1]]; // go to string table\n    cur := @lines[1];\n    if s[0] = 0 then\n      inc(PByte(s)) // no string table\n    else\n      repeat\n        len := StrLen(s);\n        if cur^ <> sbiUndefined then\n        begin\n          if info[cur^] = '' then // only set the first occurrence if multiple\n          begin\n            trimright := len;\n            while (trimright <> 0) and\n                  (s[trimright - 1] <= ord(' ')) do\n              dec(trimright);\n            FastSetString(info[cur^], s, trimright);\n          end;\n          cur^ := sbiUndefined; // reset slot in lines[]\n        end;\n        s := @s[len + 1]; // next string\n        inc(cur);\n      until s[0] = 0; // end of string table\n    inc(PByte(s)); // go to next structure\n  until false;\n  // compute the exact DMI/SMBIOS size, and adjust the raw.Data length\n  result := PtrUInt(s) - PtrUInt(raw.Data);\n  raw.Length := result;\n  if length(raw.Data) <> result then\n    FakeSetLength(raw.Data, result);\nend;\n\n\n{ **************** TSynLocker Threading Features }\n\n// as reference, take a look at Linus insight\n// from https://www.realworldtech.com/forum/?threadid=189711&curpostid=189755\n{$ifdef CPUINTEL}\nprocedure DoPause; {$ifdef FPC} assembler; nostackframe; {$endif}\nasm\n      pause\nend;\n{$endif CPUINTEL}\n\nconst\n  {$ifdef CPUINTEL}\n  SPIN_COUNT = 1000;\n  {$else}\n  SPIN_COUNT = 100; // since DoPause does nothing, switch to thread sooner\n  {$endif CPUINTEL}\n\nfunction DoSpin(spin: PtrUInt): PtrUInt;\n  {$ifdef CPUINTEL} {$ifdef HASINLINE} inline; {$endif} {$endif}\n  // on Intel, the pause CPU instruction would relax the core\n  // on ARM/AARCH64, the not-inlined function call makes a small delay\nbegin\n  {$ifdef CPUINTEL}\n  DoPause;\n  {$endif CPUINTEL}\n  dec(spin);\n  if spin = 0 then\n  begin\n    SwitchToThread; // fpnanosleep on POSIX\n    spin := SPIN_COUNT;\n  end;\n  result := spin;\nend;\n\n\n{ TLightLock }\n\nprocedure TLightLock.Init;\nbegin\n  Flags := 0;\nend;\n\nprocedure TLightLock.Done;\nbegin // just for compatibility with TOSLock\nend;\n\nprocedure TLightLock.Lock;\nbegin\n  // we tried a dedicated asm but it was slower: inlining is preferred\n  if not LockedExc(Flags, 1, 0) then\n    LockSpin;\nend;\n\nprocedure TLightLock.UnLock;\nbegin\n  {$ifdef CPUINTEL}\n  Flags := 0; // non reentrant locks need no additional thread safety\n  {$else}\n  LockedExc(Flags, 0, 1); // ARM can be weak-ordered\n  // https://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu\n  {$endif CPUINTEL}\nend;\n\nfunction TLightLock.TryLock: boolean;\nbegin\n  result := (Flags = 0) and // first check without any (slow) atomic opcode\n            LockedExc(Flags, 1, 0);\nend;\n\nfunction TLightLock.IsLocked: boolean;\nbegin\n  result := Flags <> 0;\nend;\n\nprocedure TLightLock.LockSpin;\nvar\n  spin: PtrUInt;\nbegin\n  spin := SPIN_COUNT;\n  repeat\n    spin := DoSpin(spin);\n  until TryLock;\nend;\n\n\n{ TRWLightLock }\n\nprocedure TRWLightLock.Init;\nbegin\n  Flags := 0; // bit 0=WriteLock, >0=ReadLock counter\nend;\n\nprocedure TRWLightLock.ReadLock;\nvar\n  f: PtrUInt;\nbegin\n  // if not writing, atomically increase the RD counter in the upper flag bits\n  f := Flags and not 1; // bit 0=WriteLock, >0=ReadLock counter\n  if not LockedExc(Flags, f + 2, f) then\n    ReadLockSpin;\nend;\n\nfunction TRWLightLock.TryReadLock: boolean;\nvar\n  f: PtrUInt;\nbegin\n  // if not writing, atomically increase the RD counter in the upper flag bits\n  f := Flags and not 1; // bit 0=WriteLock, >0=ReadLock counter\n  result := LockedExc(Flags, f + 2, f);\nend;\n\nprocedure TRWLightLock.ReadUnLock;\nbegin\n  LockedDec(Flags, 2);\nend;\n\nprocedure TRWLightLock.ReadLockSpin;\nvar\n  spin: PtrUInt;\nbegin\n  spin := SPIN_COUNT;\n  repeat\n    spin := DoSpin(spin);\n  until TryReadLock;\nend;\n\nfunction TRWLightLock.TryWriteLock: boolean;\nvar\n  f: PtrUInt;\nbegin\n  f := Flags and not 1; // bit 0=WriteLock, >0=ReadLock\n  result := (Flags = f) and\n            LockedExc(Flags, f + 1, f);\nend;\n\nprocedure TRWLightLock.WriteLock;\nbegin\n  if not TryWriteLock then\n    WriteLockSpin;\nend;\n\nprocedure TRWLightLock.WriteUnLock;\nbegin\n  LockedDec(Flags, 1);\nend;\n\nprocedure TRWLightLock.WriteLockSpin;\nvar\n  spin: PtrUInt;\nbegin\n  spin := SPIN_COUNT;\n  repeat\n    spin := DoSpin(spin);\n  until TryWriteLock;\nend;\n\n\n{ TRWLock }\n\nprocedure TRWLock.Init;\nbegin\n  // bit 0 = WriteLock, 1 = ReadWriteLock, 2.. = ReadOnlyLock counter\n  Flags := 0;\n  // no need to set the other fields because they will be reset if Flags=0\nend;\n\nprocedure TRWLock.AssertDone;\nbegin\n  if Flags <> 0 then\n    raise EOSException.CreateFmt('TRWLock Flags=%x', [Flags]);\nend;\n\n// dedicated asm for this most simple (and used) method\n{$ifdef FPC_ASMX64} // some Delphi version was reported to fail with no clue why\n\nprocedure TRWLock.ReadOnlyLock;\nasm     // stack frame is required since we may call SwitchToThread\n        {$ifdef SYSVABI}\n        mov     rcx, rdi      // rcx = self\n        {$endif SYSVABI}\n@retry: mov     r8d, SPIN_COUNT\n@spin:  mov     rax, qword ptr [rcx + TRWLock.Flags]\n        and     rax, not 1\n        lea     rdx, [rax + 4]\n   lock cmpxchg qword ptr [rcx + TRWLock.Flags], rdx\n        jz      @done\n        pause\n        dec     r8d\n        jnz     @spin\n        push    rcx\n        call    SwitchToThread\n        pop     rcx\n        jmp     @retry\n@done:  // restore the stack frame\nend;\n\n{$else}\n\nprocedure TRWLock.ReadOnlyLock;\nvar\n  f: PtrUInt;\nbegin\n  // if not writing, atomically increase the RD counter in the upper flag bits\n  f := Flags and not 1; // bit 0=WriteLock, 1=ReadWriteLock, >1=ReadOnlyLock\n  if not LockedExc(Flags, f + 4, f) then\n    ReadOnlyLockSpin;\nend;\n\nprocedure TRWLock.ReadOnlyLockSpin;\nvar\n  spin, f: PtrUInt;\nbegin\n  spin := SPIN_COUNT;\n  repeat\n    spin := DoSpin(spin);\n    f := Flags and not 1; // retry ReadOnlyLock\n  until (Flags = f) and\n        LockedExc(Flags, f + 4, f);\nend;\n\n{$endif FPC_ASMX64}\n\nprocedure TRWLock.ReadOnlyUnLock;\nbegin\n  LockedDec(Flags, 4);\nend;\n\nprocedure TRWLock.ReadWriteLock;\nvar\n  spin, f: PtrUInt;\n  tid: TThreadID;\nbegin\n  tid := GetCurrentThreadId;\n  if (Flags and 2 = 2) and\n     (LastReadWriteLockThread = tid) then\n  begin\n    inc(LastReadWriteLockCount); // allow ReadWriteLock to be reentrant\n    exit;\n  end;\n  // if not writing, atomically acquire the upgradable RD flag bit\n  spin := SPIN_COUNT;\n  repeat\n    f := Flags and not 3; // bit 0=WriteLock, 1=ReadWriteLock, >1=ReadOnlyLock\n    if (Flags = f) and\n       LockedExc(Flags, f + 2, f) then\n      break;\n    spin := DoSpin(spin);\n  until false;\n  LastReadWriteLockThread := tid;\n  LastReadWriteLockCount := 0;\nend;\n\nprocedure TRWLock.ReadWriteUnLock;\nbegin\n  if LastReadWriteLockCount <> 0 then\n  begin\n    dec(LastReadWriteLockCount);\n    exit;\n  end;\n  LastReadWriteLockThread := TThreadID(0);\n  LockedDec(Flags, 2);\nend;\n\nprocedure TRWLock.WriteLock;\nvar\n  spin, f: PtrUInt;\n  tid: TThreadID;\nbegin\n  tid := GetCurrentThreadId;\n  if (Flags and 1 = 1) and\n     (LastWriteLockThread = tid) then\n  begin\n    inc(LastWriteLockCount); // allow WriteLock to be reentrant\n    exit;\n  end;\n  spin := SPIN_COUNT;\n  // acquire the WR flag bit\n  repeat\n    f := Flags and not 1; // bit 0=WriteLock, 1=ReadWriteLock, >1=ReadOnlyLock\n    if (Flags = f) and\n       LockedExc(Flags, f + 1, f) then\n      if (Flags and 2 = 2) and\n         (LastReadWriteLockThread <> tid) then\n        // there is a pending ReadWriteLock but not on this thread\n        LockedDec(Flags, 1) // try again\n      else\n        // we exclusively acquired the WR lock\n        break;\n    spin := DoSpin(spin);\n  until false;\n  LastWriteLockThread := tid;\n  LastWriteLockCount := 0;\n  // wait for all readers to have finished their job\n  while Flags > 3 do\n    spin := DoSpin(spin);\nend;\n\nprocedure TRWLock.WriteUnlock;\nbegin\n  if LastWriteLockCount <> 0 then\n  begin\n    dec(LastWriteLockCount); // reentrant call\n    exit;\n  end;\n  LastWriteLockThread := TThreadID(0);\n  LockedDec(Flags, 1);\nend;\n\nprocedure TRWLock.Lock(context: TRWLockContext);\nbegin\n  if context = cReadOnly then\n    ReadOnlyLock\n  else if context = cReadWrite then\n    ReadWriteLock\n  else\n    WriteLock;\nend;\n\nprocedure TRWLock.UnLock(context: TRWLockContext);\nbegin\n  if context = cReadOnly then\n    ReadOnlyUnLock\n  else if context = cReadWrite then\n    ReadWriteUnLock\n  else\n    WriteUnLock;\nend;\n\n\n{ TOSLock }\n\nprocedure TOSLock.Init;\nbegin\n  mormot.core.os.InitializeCriticalSection(CS);\nend;\n\nprocedure TOSLock.Done;\nbegin\n  DeleteCriticalSectionIfNeeded(CS);\nend;\n\nprocedure TOSLock.Lock;\nbegin\n  mormot.core.os.EnterCriticalSection(CS);\nend;\n\nfunction TOSLock.TryLock: boolean;\nbegin\n  result := mormot.core.os.TryEnterCriticalSection(CS) <> 0;\nend;\n\nprocedure TOSLock.UnLock;\nbegin\n  mormot.core.os.LeaveCriticalSection(CS);\nend;\n\n\n{ TLockedList }\n\nprocedure TLockedList.Init(onesize: PtrUInt; const onefree: TOnLockedListOne);\nbegin\n  FillCharFast(self, SizeOf(self), 0);\n  fSize := onesize;\n  fOnFree := onefree;\n  fSequence := (Random32 shr 2) + 65536; // 65535 < sequence < MaxInt\nend;\n\nfunction LockedListFreeAll(o: PLockedListOne; const OnFree: TOnLockedListOne): integer;\nvar\n  next: PLockedListOne;\nbegin\n  result := 0;\n  while o <> nil do\n  begin\n    inc(result);\n    next := o.next;\n    if Assigned(OnFree) then\n      OnFree(o);\n    FreeMem(o);\n    o := next;\n  end;\nend;\n\nprocedure TLockedList.Done;\nbegin\n  Clear;\n  EmptyBin;\nend;\n\nprocedure TLockedList.Clear;\nbegin\n  Safe.Lock;\n  try\n    LockedListFreeAll(fHead, fOnFree);\n    fHead := nil;\n    Count := 0;\n  finally\n    Safe.UnLock;\n  end;\nend;\n\nfunction TLockedList.EmptyBin: integer;\nbegin\n  Safe.Lock;\n  try\n    result := LockedListFreeAll(fBin, nil);\n    fBin := nil;\n  finally\n    Safe.UnLock;\n  end;\nend;\n\nfunction TLockedList.New: pointer;\nbegin\n  Safe.Lock;\n  try\n    // try to recycle from single-linked list bin, or allocate\n    result := fBin;\n    if result <> nil then\n      fBin := PLockedListOne(result).next\n    else\n      result := AllocMem(fSize);\n    PLockedListOne(result).sequence := fSequence;\n    inc(fSequence); // protected by Safe.Lock\n    // insert at beginning of the main double-linked list\n    PLockedListOne(result).next := fHead;\n    if fHead <> nil then\n      PLockedListOne(fHead).prev := result;\n    fHead := result;\n    inc(Count);\n  finally\n    Safe.UnLock;\n  end;\nend;\n\nfunction TLockedList.Free(one: pointer): boolean;\nvar\n  o: PLockedListOne absolute one;\nbegin\n  result := false;\n  if (o = nil) or\n     (o^.sequence = 0) then\n    exit;\n  Safe.Lock;\n  try\n    // remove from main double-linked list\n    if o = fHead then\n      fHead := o.next;\n    if o.next <> nil then\n      PLockedListOne(o.next).prev := o.prev;\n    if o.prev <> nil then\n      PLockedListOne(o.prev).next := o.next;\n    // release internals and add to the recycle bin\n    if Assigned(fOnFree) then\n      fOnFree(o);\n    FillCharFast(o^, fSize, 0); // garbage collect as void\n    o.next := fBin;\n    fBin := o;\n    dec(Count);\n  finally\n    Safe.UnLock;\n  end;\n  result := true;\nend;\n\n\n{ TAutoLock }\n\nconstructor TAutoLock.Create(aLock: PSynLocker);\nbegin\n  fLock := aLock;\n  fLock^.Lock;\nend;\n\ndestructor TAutoLock.Destroy;\nbegin\n  fLock^.UnLock;\nend;\n\n\n{ TSynLocker }\n\nfunction NewSynLocker: PSynLocker;\nbegin\n  result := AllocMem(SizeOf(TSynLocker));\n  InitializeCriticalSection(result^.fSection);\n  result^.fInitialized := true;\nend;\n\nprocedure TSynLocker.Init;\nbegin\n  InitializeCriticalSection(fSection);\n  fLockCount := 0;\n  fPaddingUsedCount := 0;\n  fInitialized := true;\n  fRW.Init;\nend;\n\nprocedure TSynLocker.Done;\nvar\n  i: PtrInt;\nbegin\n  for i := 0 to fPaddingUsedCount - 1 do\n    if not (integer(Padding[i].VType) in VTYPE_SIMPLE) then\n      VarClearProc(Padding[i]);\n  DeleteCriticalSection(fSection);\n  fInitialized := false;\nend;\n\nprocedure TSynLocker.DoneAndFreeMem;\nbegin\n  Done;\n  FreeMem(@self);\nend;\n\nfunction TSynLocker.GetIsLocked: boolean;\nbegin\n  case fRWUse of\n    uSharedLock:\n      result := fLockCount <> 0; // only updated by uSharedLock\n    uRWLock:\n      result := fRW.Flags = 0;   // no lock at all\n  else\n    result := false;             // uNoLock will never lock\n  end;\nend;\n\nprocedure TSynLocker.RWLock(context: TRWLockContext);\nbegin\n  case fRWUse of\n    uSharedLock:\n      begin\n        mormot.core.os.EnterCriticalSection(fSection);\n        inc(fLockCount);\n      end;\n    uRWLock:\n      fRW.Lock(context);\n  end; // uNoLock will just do nothing\nend;\n\nprocedure TSynLocker.RWUnLock(context: TRWLockContext);\nbegin\n  case fRWUse of\n    uSharedLock:\n      begin\n        dec(fLockCount);\n        mormot.core.os.LeaveCriticalSection(fSection);\n      end;\n    uRWLock:\n      fRW.UnLock(context);\n  end; // uNoLock will just do nothing\nend;\n\nprocedure TSynLocker.ReadLock;\nbegin\n  RWLock(cReadOnly); // will be properly inlined\nend;\n\nprocedure TSynLocker.ReadUnLock;\nbegin\n  RWUnLock(cReadOnly);\nend;\n\nprocedure TSynLocker.ReadWriteLock;\nbegin\n  RWLock(cReadWrite);\nend;\n\nprocedure TSynLocker.ReadWriteUnLock;\nbegin\n  RWUnLock(cReadWrite);\nend;\n\nprocedure TSynLocker.Lock;\nbegin\n  RWLock(cWrite);\nend;\n\nprocedure TSynLocker.UnLock;\nbegin\n  RWUnLock(cWrite);\nend;\n\nfunction TSynLocker.TryLock: boolean;\nbegin\n  result := (fRWUse = uSharedLock) and\n            (mormot.core.os.TryEnterCriticalSection(fSection) <> 0);\n  if result then\n    inc(fLockCount);\nend;\n\nfunction TSynLocker.TryLockMS(retryms: integer; terminated: PBoolean): boolean;\nvar\n  ms: integer;\n  endtix: Int64;\nbegin\n  result := TryLock;\n  if result or\n     (fRWUse <> uSharedLock) or\n     (retryms <= 0) then\n    exit;\n  ms := 0;\n  endtix := GetTickCount64 + retryms;\n  repeat\n    SleepHiRes(ms);\n    result := TryLock;\n    if result or\n       ((terminated <> nil) and\n        terminated^) then\n      exit;\n    ms := ms xor 1; // 0,1,0,1... seems to be good for scaling\n  until GetTickCount64 > endtix;\nend;\n\nfunction TSynLocker.ProtectMethod: IUnknown;\nbegin\n  result := TAutoLock.Create(@self);\nend;\n\nfunction TSynLocker.GetVariant(Index: integer): Variant;\nbegin\n  if cardinal(Index) < cardinal(fPaddingUsedCount) then\n  {$ifdef HASFASTTRYFINALLY}\n  try\n  {$else}\n  begin\n  {$endif HASFASTTRYFINALLY}\n    RWLock(cReadOnly);\n    result := variant(Padding[Index]);\n  {$ifdef HASFASTTRYFINALLY}\n  finally\n  {$endif HASFASTTRYFINALLY}\n    RWUnLock(cReadOnly);\n  end\n  else\n    VarClear(result);\nend;\n\nprocedure TSynLocker.SetVariant(Index: integer; const Value: Variant);\nbegin\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    if Index >= fPaddingUsedCount then\n      fPaddingUsedCount := Index + 1;\n    variant(Padding[Index]) := Value;\n  finally\n    RWUnLock(cWrite);\n  end;\nend;\n\nfunction TSynLocker.GetInt64(Index: integer): Int64;\nbegin\n  if cardinal(Index) < cardinal(fPaddingUsedCount) then\n  {$ifdef HASFASTTRYFINALLY}\n  try\n  {$else}\n  begin\n  {$endif HASFASTTRYFINALLY}\n    RWLock(cReadOnly);\n    if not VariantToInt64(variant(Padding[Index]), result) then\n      result := 0;\n  {$ifdef HASFASTTRYFINALLY}\n  finally\n  {$endif HASFASTTRYFINALLY}\n    RWUnLock(cReadOnly);\n  end\n  else\n    result := 0;\nend;\n\nprocedure TSynLocker.SetInt64(Index: integer; const Value: Int64);\nbegin\n  SetVariant(Index, Value);\nend;\n\nfunction TSynLocker.GetBool(Index: integer): boolean;\nbegin\n  if cardinal(Index) < cardinal(fPaddingUsedCount) then\n  {$ifdef HASFASTTRYFINALLY}\n  try\n  {$else}\n  begin\n  {$endif HASFASTTRYFINALLY}\n    RWLock(cReadOnly);\n    if not VariantToBoolean(variant(Padding[Index]), result) then\n      result := false;\n  {$ifdef HASFASTTRYFINALLY}\n  finally\n  {$endif HASFASTTRYFINALLY}\n    RWUnLock(cReadOnly);\n  end\n  else\n    result := false;\nend;\n\nprocedure TSynLocker.SetBool(Index: integer; const Value: boolean);\nbegin\n  SetVariant(Index, Value);\nend;\n\nfunction TSynLocker.GetUnlockedInt64(Index: integer): Int64;\nbegin\n  if (cardinal(Index) >= cardinal(fPaddingUsedCount)) or\n     not VariantToInt64(variant(Padding[Index]), result) then\n    result := 0;\nend;\n\nprocedure TSynLocker.SetUnlockedInt64(Index: integer; const Value: Int64);\nbegin\n  if cardinal(Index) <= high(Padding) then\n  begin\n    if Index >= fPaddingUsedCount then\n      fPaddingUsedCount := Index + 1;\n    variant(Padding[Index]) := Value;\n  end;\nend;\n\nfunction TSynLocker.GetPointer(Index: integer): Pointer;\nbegin\n  if cardinal(Index) < cardinal(fPaddingUsedCount) then\n  {$ifdef HASFASTTRYFINALLY}\n  try\n  {$else}\n  begin\n  {$endif HASFASTTRYFINALLY}\n    RWLock(cReadOnly);\n    with Padding[Index] do\n      if VType = varUnknown then\n        result := VUnknown\n      else\n        result := nil;\n  {$ifdef HASFASTTRYFINALLY}\n  finally\n  {$endif HASFASTTRYFINALLY}\n    RWUnLock(cReadOnly);\n  end\n  else\n    result := nil;\nend;\n\nprocedure TSynLocker.SetPointer(Index: integer; const Value: Pointer);\nbegin\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    if Index >= fPaddingUsedCount then\n      fPaddingUsedCount := Index + 1;\n    with Padding[Index] do\n    begin\n      VarClearAndSetType(PVariant(@VType)^, varUnknown);\n      VUnknown := Value;\n    end;\n  finally\n    RWUnLock(cWrite);\n  end;\nend;\n\nfunction TSynLocker.GetUtf8(Index: integer): RawUtf8;\nbegin\n  if cardinal(Index) < cardinal(fPaddingUsedCount) then\n  {$ifdef HASFASTTRYFINALLY}\n  try\n  {$else}\n  begin\n  {$endif HASFASTTRYFINALLY}\n    RWLock(cReadOnly);\n    VariantStringToUtf8(variant(Padding[Index]), result);\n  {$ifdef HASFASTTRYFINALLY}\n  finally\n  {$endif HASFASTTRYFINALLY}\n    RWUnLock(cReadOnly);\n  end\n  else\n    result := '';\nend;\n\nprocedure TSynLocker.SetUtf8(Index: integer; const Value: RawUtf8);\nbegin\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    if Index >= fPaddingUsedCount then\n      fPaddingUsedCount := Index + 1;\n    RawUtf8ToVariant(Value, variant(Padding[Index]));\n  finally\n    RWUnLock(cWrite);\n  end;\nend;\n\nfunction TSynLocker.LockedInt64Increment(Index: integer; const Increment: Int64): Int64;\nbegin\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    result := 0;\n    if Index < fPaddingUsedCount then\n      VariantToInt64(variant(Padding[Index]), result)\n    else\n      fPaddingUsedCount := Index + 1;\n    variant(Padding[Index]) := Int64(result + Increment);\n  finally\n    RWUnLock(cWrite);\n  end\n  else\n    result := 0;\nend;\n\nfunction TSynLocker.LockedExchange(Index: integer; const Value: variant): variant;\nbegin\n  VarClear(result);\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    with Padding[Index] do\n    begin\n      if Index < fPaddingUsedCount then\n        result := PVariant(@VType)^\n      else\n        fPaddingUsedCount := Index + 1;\n      PVariant(@VType)^ := Value;\n    end;\n  finally\n    RWUnLock(cWrite);\n  end;\nend;\n\nfunction TSynLocker.LockedPointerExchange(Index: integer; Value: pointer): pointer;\nbegin\n  if cardinal(Index) <= high(Padding) then\n  try\n    RWLock(cWrite);\n    with Padding[Index] do\n    begin\n      if Index < fPaddingUsedCount then\n        if VType = varUnknown then\n          result := VUnknown\n        else\n        begin\n          VarClear(PVariant(@VType)^);\n          result := nil;\n        end\n      else\n      begin\n        fPaddingUsedCount := Index + 1;\n        result := nil;\n      end;\n      VType := varUnknown;\n      VUnknown := Value;\n    end;\n  finally\n    RWUnLock(cWrite);\n  end\n  else\n    result := nil;\nend;\n\n\n\n{ TSynLocked }\n\nconstructor TSynLocked.Create;\nbegin\n  fSafe := NewSynLocker;\nend;\n\ndestructor TSynLocked.Destroy;\nbegin\n  inherited Destroy;\n  fSafe^.DoneAndFreeMem;\nend;\n\n\n{ TSynEvent }\n\nfunction TSynEvent.SleepStep(var start: Int64; terminated: PBoolean): Int64;\nvar\n  ms: integer;\n  endtix: Int64;\nbegin\n  ms := SleepStepTime(start, result, @endtix);\n  if (ms < 10) or\n     (terminated = nil) then\n    if ms = 0 then\n      SleepHiRes(0) // < 16 ms is a pious wish on Windows anyway\n    else\n      WaitFor(ms)\n  else\n    repeat\n      WaitFor(10);\n      if terminated^ then\n        exit;\n      result := GetTickCount64;\n    until result >= endtix;\nend;\n\nfunction TSynEvent.IsEventFD: boolean;\nbegin\n  {$ifdef HASEVENTFD}\n  result := fFD <> 0;\n  {$else}\n  result := false;\n  {$endif HASEVENTFD}\nend;\n\n\n{ TLecuyerThreadSafe }\n\nfunction TLecuyerThreadSafe.Next: cardinal;\nbegin\n  Safe.Lock;\n  result := Generator.Next;\n  Safe.UnLock;\nend;\n\nfunction TLecuyerThreadSafe.NextDouble: double;\nbegin\n  Safe.Lock;\n  result := Generator.NextDouble;\n  Safe.UnLock;\nend;\n\nprocedure TLecuyerThreadSafe.Fill(dest: pointer; count: integer);\nbegin\n  Safe.Lock;\n  Generator.Fill(dest, count);\n  Safe.UnLock;\nend;\n\nprocedure TLecuyerThreadSafe.FillShort31(var dest: TShort31);\nbegin\n  Fill(@dest, 32);\n  FillAnsiStringFromRandom(@dest, 32);\nend;\n\n\nprocedure GlobalLock;\nbegin\n  mormot.core.os.EnterCriticalSection(GlobalCriticalSection.CS);\nend;\n\nprocedure GlobalUnLock;\nbegin\n  mormot.core.os.LeaveCriticalSection(GlobalCriticalSection.CS);\nend;\n\nvar\n  InternalGarbageCollection: record // RegisterGlobalShutdownRelease() list\n    Instances:  TObjectDynArray;\n    Count: integer;\n    Shutdown: boolean; // paranoid check to avoid messing with Instances[]\n  end;\n\nfunction RegisterGlobalShutdownRelease(Instance: TObject;\n  SearchExisting: boolean): pointer;\nbegin\n  if not InternalGarbageCollection.Shutdown then\n  begin\n    GlobalLock;\n    try\n      with InternalGarbageCollection do\n        if not SearchExisting or\n           not PtrUIntScanExists(pointer(Instances), Count, PtrUInt(Instance)) then\n          PtrArrayAdd(Instances, Instance, Count);\n    finally\n      GlobalUnLock;\n    end;\n  end;\n  result := Instance;\nend;\n\nfunction SleepDelay(elapsed: PtrInt): PtrInt;\nbegin\n  if elapsed < 50 then\n    result := 0 // 10us on POSIX, SwitchToThread on Windows\n  else if elapsed < 200 then\n    result := 1\n  else if elapsed < 500 then\n    result := 5\n  else if elapsed < 2000 then\n    result := 50\n  else\n    result := 120 + Random32(130); // random 120-250 ms\nend;\n\nfunction SleepStepTime(var start, tix: Int64; endtix: PInt64): PtrInt;\nbegin\n  tix := GetTickCount64;\n  if (start = 0) or\n     (tix < 50) then\n    start := tix\n  else if start < 0 then\n    start := tix - 50; // ensure tix - start = elapsed is not < 50\n  result := SleepDelay(tix - start);\n  if endtix <> nil then\n    endtix^ := tix + result;\nend;\n\nfunction SleepStep(var start: Int64; terminated: PBoolean): Int64;\nvar\n  ms: integer;\n  endtix: Int64;\nbegin\n  ms := SleepStepTime(start, result, @endtix);\n  if (ms < 10) or\n     (terminated = nil) then\n    SleepHiRes(ms) // < 16 ms is a pious wish on Windows anyway\n  else\n    repeat\n      SleepHiRes(10); // on Windows, HW clock resolution is around 16 ms\n      result := GetTickCount64;\n    until (ms = 0) or\n          terminated^ or\n          (result >= endtix);\nend;\n\nfunction SleepHiRes(ms: cardinal; var terminated: boolean;\n  terminatedvalue: boolean): boolean;\nvar\n  start, endtix: Int64;\nbegin\n  if terminated <> terminatedvalue then\n    if ms < 20 then\n      SleepHiRes(ms) // below HW clock resolution\n    else\n    begin\n      start := GetTickCount64;\n      endtix := start + ms;\n      repeat\n      until (terminated = terminatedvalue) or\n            (SleepStep(start, @terminated) > endtix);\n    end;\n  result := terminated = terminatedvalue;\nend;\n\nprocedure SpinExc(var Target: PtrUInt; NewValue, Comperand: PtrUInt);\nvar\n  spin: PtrUInt;\nbegin\n  spin := SPIN_COUNT;\n  while (Target <> Comperand) or\n        not LockedExc(Target, NewValue, Comperand) do\n    spin := DoSpin(spin);\nend;\n\nfunction ObjArrayAdd(var aObjArray; aItem: TObject;\n  var aSafe: TLightLock; aCount: PInteger): PtrInt;\nbegin\n  aSafe.Lock;\n  if aCount <> nil then\n    result := PtrArrayAdd(aObjArray, aItem, aCount^)\n  else\n    result := PtrArrayAdd(aObjArray, aItem);\n  aSafe.UnLock;\nend;\n\nfunction PtrArrayDelete(var aPtrArray; aItem: pointer; var aSafe: TLightLock;\n  aCount: PInteger): PtrInt;\nbegin\n  if pointer(aPtrArray) = nil then\n  begin\n    result := -1; // no need to lock anything\n    exit;\n  end;\n  aSafe.Lock;\n  result := PtrArrayDelete(aPtrArray, aItem, aCount);\n  aSafe.UnLock;\nend;\n\nfunction SetCpuSet(var CpuSet: TCpuSet; CpuIndex: cardinal): boolean;\nbegin\n  result := false;\n  if (CpuIndex >= SizeOf(CpuSet) shl 3) or\n     (CpuIndex >= SystemInfo.dwNumberOfProcessors) then\n    exit;\n  SetBitPtr(@CpuSet, CpuIndex);\n  result := true;\nend;\n\nfunction CurrentCpuSet(out CpuSet: TCpuSet): integer;\nbegin\n  ResetCpuSet(CpuSet);\n  if GetMaskAffinity(CpuSet) then\n    result := GetBitsCount(CpuSet, SizeOf(CpuSet) shl 3)\n  else\n    result := 0;\nend;\n\nfunction SetThreadCpuAffinity(Thread: TThread; CpuIndex: cardinal): boolean;\nvar\n  mask: TCpuSet;\nbegin\n  ResetCpuSet(mask);\n  result := SetCpuSet(mask, CpuIndex) and\n            SetThreadMaskAffinity(Thread, mask);\nend;\n\nfunction SetThreadSocketAffinity(Thread: TThread; SocketIndex: cardinal): boolean;\nbegin\n  result := (SocketIndex < cardinal(length(CpuSocketsMask))) and\n            SetThreadMaskAffinity(Thread, CpuSocketsMask[SocketIndex]);\nend;\n\nprocedure _SetThreadName(ThreadID: TThreadID; const Format: RawUtf8;\n  const Args: array of const);\nbegin\n  // do nothing - properly implemented in mormot.core.log\nend;\n\nprocedure SetCurrentThreadName(const Format: RawUtf8; const Args: array of const);\nbegin\n  SetThreadName(GetCurrentThreadId, Format, Args);\nend;\n\nprocedure SetCurrentThreadName(const Name: RawUtf8);\nbegin\n  SetThreadName(GetCurrentThreadId, '%', [Name]);\nend;\n\nthreadvar // do not publish for compilation within Delphi packages\n  _CurrentThreadName: TShort31; // 31 chars is enough for our debug purpose\n\nfunction CurrentThreadNameShort: PShortString;\nbegin\n  result := @_CurrentThreadName;\nend;\n\nfunction GetCurrentThreadName: RawUtf8;\nbegin\n  ShortStringToAnsi7String(_CurrentThreadName, result);\nend;\n\nfunction GetCurrentThreadInfo: ShortString;\nbegin\n  result := ShortString(format('Thread %x [%s]',\n    [PtrUInt(GetCurrentThreadId), _CurrentThreadName]));\nend;\n\n\n{ ****************** Unix Daemon and Windows Service Support }\n\nconst\n  // hardcoded to avoid linking mormot.core.rtti for GetEnumName()\n  _SERVICESTATE: array[TServiceState] of string[12] = (\n    'NotInstalled',\n    'Stopped',\n    'Starting',\n    'Stopping',\n    'Running',\n    'Resuming',\n    'Pausing',\n    'Paused',\n    'Failed',\n    'Error');\n\nfunction ToText(st: TServiceState): PShortString; overload;\nbegin\n  result := @_SERVICESTATE[st];\nend;\n\nfunction ExtractExecutableName(const cmd: RawUtf8; posix: boolean): RawUtf8;\nvar\n  temp: RawUtf8;\n  argv: TParseCommandsArgs;\n  argc: integer;\nbegin\n  if (pcInvalidCommand in ParseCommandArgs(cmd, @argv, @argc, @temp, posix)) or\n     ({%H-}argc = 0) then\n    result := ''\n  else\n    FastSetString(result, argv[0], StrLen(argv[0]));\nend;\n\nfunction ParseCommandArgs(const cmd: RawUtf8; argv: PParseCommandsArgs;\n  argc: PInteger; temp: PRawUtf8; posix: boolean): TParseCommands;\nvar\n  n: PtrInt;\n  state: set of (sWhite, sInArg, sInSQ, sInDQ, sSpecial, sBslash);\n  c: AnsiChar;\n  D, P: PAnsiChar;\nbegin\n  result := [pcInvalidCommand];\n  if argv <> nil then\n    argv[0] := nil;\n  if argc <> nil then\n    argc^ := 0;\n  if cmd = '' then\n    exit;\n  if argv = nil then\n    D := nil\n  else\n  begin\n    if temp = nil then\n      exit;\n    SetLength(temp^, length(cmd));\n    D := pointer(temp^);\n  end;\n  state := [];\n  n := 0;\n  P := pointer(cmd);\n  repeat\n    c := P^;\n    if D <> nil then\n      D^ := c;\n    inc(P);\n    case c of\n      #0:\n        begin\n          if sInSQ in state then\n            include(result, pcUnbalancedSingleQuote);\n          if sInDQ in state then\n            include(result, pcUnbalancedDoubleQuote);\n          exclude(result, pcInvalidCommand);\n          if argv <> nil then\n            argv[n] := nil;\n          if argc <> nil then\n            argc^ := n;\n          exit;\n        end;\n      #1 .. ' ':\n        begin\n         if state = [sInArg] then\n         begin\n           state := [];\n           if D <> nil then\n           begin\n             D^ := #0;\n             inc(D);\n           end;\n           continue;\n         end;\n         if state * [sInSQ, sInDQ] = [] then\n           continue;\n        end;\n      '\\':\n        if posix and\n           (state * [sInSQ, sBslash] = []) then\n          if sInDQ in state then\n          begin\n            case P^ of\n              '\"', '\\', '$', '`':\n                begin\n                  include(state, sBslash);\n                  continue;\n                end;\n            end;\n          end\n          else if P^ = #0 then\n          begin\n            include(result, pcHasEndingBackSlash);\n            exit;\n          end\n          else\n          begin\n            if D <> nil then\n              D^ := P^;\n            inc(P);\n          end;\n      '^':\n        if not posix and\n           (state * [sInSQ, sInDQ, sBslash] = []) then\n          if PWord(P)^ = $0a0d then\n          begin\n            inc(P, 2);\n            continue;\n          end\n          else if P^ = #0 then\n          begin\n            include(result, pcHasEndingBackSlash);\n            exit;\n          end\n          else\n          begin\n            if D <> nil then\n              D^ := P^;\n            inc(P);\n          end;\n      '''':\n        if posix and\n           not(sInDQ in state) then\n          if sInSQ in state then\n          begin\n            exclude(state, sInSQ);\n            continue;\n          end\n          else if state = [] then\n          begin\n            if argv <> nil then\n            begin\n              argv[n] := D;\n              inc(n);\n              if n = high(argv^) then\n                exit;\n            end;\n            state := [sInSQ, sInArg];\n            continue;\n          end\n          else if state = [sInArg] then\n          begin\n            state := [sInSQ, sInArg];\n            continue;\n          end;\n      '\"':\n        if not(sInSQ in state) then\n          if sInDQ in state then\n          begin\n            exclude(state, sInDQ);\n            continue;\n          end\n          else if state = [] then\n          begin\n            if argv <> nil then\n            begin\n              argv[n] := D;\n              inc(n);\n              if n = high(argv^) then\n                exit;\n            end;\n            state := [sInDQ, sInArg];\n            continue;\n          end\n          else if state = [sInArg] then\n          begin\n            state := [sInDQ, sInArg];\n            continue;\n          end;\n      '|',\n      '<',\n      '>':\n        if state * [sInSQ, sInDQ] = [] then\n          include(result, pcHasRedirection);\n      '&',\n      ';':\n        if posix and\n           (state * [sInSQ, sInDQ] = []) then\n        begin\n          include(state, sSpecial);\n          include(result, pcHasJobControl);\n        end;\n      '`':\n        if posix and\n           (state * [sInSQ, sBslash] = []) then\n           include(result, pcHasSubCommand);\n      '(',\n      ')':\n        if posix and\n           (state * [sInSQ, sInDQ] = []) then\n          include(result, pcHasParenthesis);\n      '$':\n        if posix and\n           (state * [sInSQ, sBslash] = []) then\n          if p^ = '(' then\n            include(result, pcHasSubCommand)\n          else\n            include(result, pcHasShellVariable);\n      '*',\n      '?':\n        if posix and\n           (state * [sInSQ, sInDQ] = []) then\n          include(result, pcHasWildcard);\n    end;\n    exclude(state, sBslash);\n    if state = [] then\n    begin\n      if argv <> nil then\n      begin\n        argv[n] := D;\n        inc(n);\n        if n = high(argv^) then\n          exit;\n      end;\n      state := [sInArg];\n    end;\n    if D <> nil then\n      inc(D);\n  until false;\nend;\n\nprocedure TrimDualSpaces(var s: RawUtf8);\nvar\n  f, i: integer;\nbegin\n  f := 1;\n  repeat\n    i := PosEx('  ', s, f);\n    if i = 0 then\n      break;\n    delete(s, i, 1); // dual space -> single space\n    f := i;\n  until false;\n  TrimSelf(s);\nend;\n\n\nprocedure InitializeUnit;\nbegin\n  {$ifdef ISFPC27}\n  SetMultiByteConversionCodePage(CP_UTF8);\n  SetMultiByteRTLFileSystemCodePage(CP_UTF8);\n  {$endif ISFPC27}\n  GlobalCriticalSection.Init;\n  ConsoleCriticalSection.Init;\n  InitializeSpecificUnit; // in mormot.core.os.posix/windows.inc files\n  TrimDualSpaces(OSVersionText);\n  TrimDualSpaces(OSVersionInfoEx);\n  TrimDualSpaces(BiosInfoText);\n  TrimDualSpaces(CpuInfoText);\n  OSVersionShort := ToTextOS(OSVersionInt32);\n  InitializeExecutableInformation;\n  JSON_CONTENT_TYPE_VAR := JSON_CONTENT_TYPE;\n  JSON_CONTENT_TYPE_HEADER_VAR := JSON_CONTENT_TYPE_HEADER;\n  NULL_STR_VAR := 'null';\n  BOOL_UTF8[false] := 'false';\n  BOOL_UTF8[true]  := 'true';\n  // minimal stubs which will be properly implemented in mormot.core.log.pas\n  GetExecutableLocation := _GetExecutableLocation;\n  SetThreadName := _SetThreadName;\nend;\n\nprocedure FinalizeUnit;\nvar\n  i: PtrInt;\nbegin\n  with InternalGarbageCollection do\n  begin\n    Shutdown := true; // avoid nested initialization at shutdown\n    for i := Count - 1 downto 0 do\n      FreeAndNilSafe(Instances[i]); // before GlobalCriticalSection deletion\n  end;\n  ObjArrayClear(CurrentFakeStubBuffers);\n  Executable.Version.Free;\n  Executable.Command.Free;\n  FinalizeSpecificUnit; // in mormot.core.os.posix/windows.inc files\n  ConsoleCriticalSection.Done;\n  GlobalCriticalSection.Done;\n  {$ifndef NOEXCEPTIONINTERCEPT}\n  _RawLogException := nil;\n  RawExceptionIntercepted := true;\n  {$endif NOEXCEPTIONINTERCEPT}\nend;\n\n\ninitialization\n  InitializeUnit;\n\nfinalization\n  FinalizeUnit;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.MemoryMappedFiles;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading;\n\nnamespace Mormot.Core.OS\n{\n\n    public static class OSConstants\n    {\n        \n        public static readonly string CRLF =\n#if WINDOWS\n            \"\\r\\n\";\n#else\n            \"\\n\";\n#endif\n\n        \n#if WINDOWS\n        public const string FILES_ALL = \"*.*\";\n        public const char InvertedPathDelim = '/';\n        public const bool PathCaseInsensitive = true;\n#else\n        public const string FILES_ALL = \"*\";\n        public const char InvertedPathDelim = '\\\\';\n        public const bool PathCaseInsensitive = false;\n#endif\n\n        \n        public const FileShare fmShareRead      = FileShare.Read;\n        public const FileShare fmShareWrite     = FileShare.Write;\n        public const FileShare fmShareReadWrite = FileShare.ReadWrite;\n    }\n\n    \n\n    public static class HttpStatus\n    {\n        \n        public const int HTTP_NONE = 0;\n        public const int HTTP_CONTINUE = 100;\n        public const int HTTP_SWITCHINGPROTOCOLS = 101;\n        public const int HTTP_SUCCESS = 200;\n        public const int HTTP_CREATED = 201;\n        public const int HTTP_ACCEPTED = 202;\n        public const int HTTP_NONAUTHORIZEDINFO = 203;\n        public const int HTTP_NOCONTENT = 204;\n        public const int HTTP_RESETCONTENT = 205;\n        public const int HTTP_PARTIALCONTENT = 206;\n        public const int HTTP_MULTIPLECHOICES = 300;\n        public const int HTTP_MOVEDPERMANENTLY = 301;\n        public const int HTTP_FOUND = 302;\n        public const int HTTP_SEEOTHER = 303;\n        public const int HTTP_NOTMODIFIED = 304;\n        public const int HTTP_USEPROXY = 305;\n        public const int HTTP_TEMPORARYREDIRECT = 307;\n        public const int HTTP_PERMANENTREDIRECT = 308;\n        public const int HTTP_BADREQUEST = 400;\n        public const int HTTP_UNAUTHORIZED = 401;\n        public const int HTTP_FORBIDDEN = 403;\n        public const int HTTP_NOTFOUND = 404;\n        public const int HTTP_NOTALLOWED = 405;\n        public const int HTTP_NOTACCEPTABLE = 406;\n        public const int HTTP_PROXYAUTHREQUIRED = 407;\n        public const int HTTP_TIMEOUT = 408;\n        public const int HTTP_CONFLICT = 409;\n        public const int HTTP_PAYLOADTOOLARGE = 413;\n        public const int HTTP_RANGENOTSATISFIABLE = 416;\n        public const int HTTP_TEAPOT = 418;\n        public const int HTTP_SERVERERROR = 500;\n        public const int HTTP_NOTIMPLEMENTED = 501;\n        public const int HTTP_BADGATEWAY = 502;\n        public const int HTTP_UNAVAILABLE = 503;\n        public const int HTTP_GATEWAYTIMEOUT = 504;\n        public const int HTTP_HTTPVERSIONNONSUPPORTED = 505;\n\n        private static readonly int[] HTTP_CODES = new int[]\n        {\n            HTTP_SUCCESS,\n            HTTP_NOCONTENT,\n            HTTP_TEMPORARYREDIRECT,\n            HTTP_PERMANENTREDIRECT,\n            HTTP_MOVEDPERMANENTLY,\n            HTTP_BADREQUEST,\n            HTTP_UNAUTHORIZED,\n            HTTP_FORBIDDEN,\n            HTTP_NOTFOUND,\n            HTTP_NOTALLOWED,\n            HTTP_NOTMODIFIED,\n            HTTP_NOTACCEPTABLE,\n            HTTP_PARTIALCONTENT,\n            HTTP_PAYLOADTOOLARGE,\n            HTTP_CREATED,\n            HTTP_SEEOTHER,\n            HTTP_CONTINUE,\n            HTTP_SWITCHINGPROTOCOLS,\n            HTTP_ACCEPTED,\n            HTTP_NONAUTHORIZEDINFO,\n            HTTP_RESETCONTENT,\n            207, \n            HTTP_MULTIPLECHOICES,\n            HTTP_FOUND,\n            HTTP_USEPROXY,\n            HTTP_PROXYAUTHREQUIRED,\n            HTTP_TIMEOUT,\n            HTTP_CONFLICT,\n            410, \n            411, \n            412, \n            414, \n            415, \n            HTTP_RANGENOTSATISFIABLE,\n            HTTP_TEAPOT,\n            426, \n            HTTP_SERVERERROR,\n            HTTP_NOTIMPLEMENTED,\n            HTTP_BADGATEWAY,\n            HTTP_UNAVAILABLE,\n            HTTP_GATEWAYTIMEOUT,\n            HTTP_HTTPVERSIONNONSUPPORTED,\n            511, \n            513  \n        };\n\n        private static readonly string[] HTTP_REASON = new string[]\n        {\n            \"OK\",\n            \"No Content\",\n            \"Temporary Redirect\",\n            \"Permanent Redirect\",\n            \"Moved Permanently\",\n            \"Bad Request\",\n            \"Unauthorized\",\n            \"Forbidden\",\n            \"Not Found\",\n            \"Method Not Allowed\",\n            \"Not Modified\",\n            \"Not Acceptable\",\n            \"Partial Content\",\n            \"Payload Too Large\",\n            \"Created\",\n            \"See Other\",\n            \"Continue\",\n            \"Switching Protocols\",\n            \"Accepted\",\n            \"Non-Authoritative Information\",\n            \"Reset Content\",\n            \"Multi-Status\",\n            \"Multiple Choices\",\n            \"Found\",\n            \"Use Proxy\",\n            \"Proxy Authentication Required\",\n            \"Request Timeout\",\n            \"Conflict\",\n            \"Gone\",\n            \"Length Required\",\n            \"Precondition Failed\",\n            \"URI Too Long\",\n            \"Unsupported Media Type\",\n            \"Requested Range Not Satisfiable\",\n            \"I'm a teapot\",\n            \"Upgrade Required\",\n            \"Internal Server Error\",\n            \"Not Implemented\",\n            \"Bad Gateway\",\n            \"Service Unavailable\",\n            \"Gateway Timeout\",\n            \"HTTP Version Not Supported\",\n            \"Network Authentication Required\",\n            \"Invalid Request\"\n        };\n\n        \n        public static string StatusCodeToText(int code)\n        {\n            int index = Array.IndexOf(HTTP_CODES, code);\n            if (index < 0)\n            {\n                \n                index = HTTP_CODES.Length - 1;\n            }\n            return HTTP_REASON[index];\n        }\n\n        \n        public static void StatusCodeToReason(int code, out string reason)\n        {\n            reason = StatusCodeToText(code);\n        }\n\n        \n        public static string StatusCodeToShort(int code)\n        {\n            if (code > 599) code = 999;\n            return $\"{code} {StatusCodeToText(code)}\";\n        }\n\n        \n        public static bool StatusCodeIsSuccess(int code)\n        {\n            return code >= HTTP_SUCCESS && code < HTTP_BADREQUEST;\n        }\n    }\n\n    \n    public static class FileUtils\n    {\n        \n        public static string NormalizeFileName(string fileName)\n        {\n            if (string.IsNullOrEmpty(fileName)) return fileName;\n#if WINDOWS\n            return fileName.Replace('/', Path.DirectorySeparatorChar);\n#else\n            return fileName.Replace('\\\\', Path.DirectorySeparatorChar);\n#endif\n        }\n\n        \n        public static string QuoteFileName(string fileName)\n        {\n            if (!string.IsNullOrEmpty(fileName) &&\n                fileName.Contains(\" \") &&\n                !fileName.StartsWith(\"\\\"\"))\n            {\n                return $\"\\\"{fileName}\\\"\";\n            }\n            return fileName;\n        }\n\n        \n        public static string EnsureDirectoryExists(string directory)\n        {\n            if (string.IsNullOrEmpty(directory))\n                throw new ArgumentException(\"Directory name is empty\");\n\n            string full = Path.GetFullPath(directory);\n            if (!Directory.Exists(full))\n            {\n                Directory.CreateDirectory(full);\n            }\n            return full;\n        }\n\n        \n        public static string ExtractPath(string fileName)\n        {\n            return Path.GetDirectoryName(fileName) + Path.DirectorySeparatorChar;\n        }\n\n        \n        public static string ExtractName(string fileName)\n        {\n            return Path.GetFileName(fileName);\n        }\n\n        \n        public static string ExtractExt(string fileName, bool withoutDot = false)\n        {\n            string ext = Path.GetExtension(fileName);\n            return withoutDot ? ext.TrimStart('.') : ext;\n        }\n\n        \n        public static string GetFileNameWithoutExt(string fileName, out string extension)\n        {\n            extension = Path.GetExtension(fileName);\n            return Path.GetFileNameWithoutExtension(fileName);\n        }\n\n        \n        public static string GetFileNameWithoutExtOrPath(string fileName)\n        {\n            return Path.GetFileNameWithoutExtension(Path.GetFileName(fileName));\n        }\n\n        \n        public static bool DirectoryDelete(string directory, string mask = \"*.*\", bool deleteOnlyFilesNotDirectory = false, out int deletedCount)\n        {\n            deletedCount = 0;\n            if (!Directory.Exists(directory))\n                return true;\n            bool result = true;\n            foreach (var file in Directory.GetFiles(directory, mask))\n            {\n                try\n                {\n                    File.Delete(file);\n                    deletedCount++;\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            if (!deleteOnlyFilesNotDirectory)\n            {\n                try\n                {\n                    Directory.Delete(directory);\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            return result;\n        }\n\n        \n        public static bool DirectoryDeleteOlderFiles(string directory, TimeSpan ageThreshold, string mask = \"*.*\", bool recursive = false, out long totalSize)\n        {\n            totalSize = 0;\n            if (!Directory.Exists(directory))\n                return true;\n            bool result = true;\n            DateTime cutoff = DateTime.UtcNow - ageThreshold;\n            foreach (var file in Directory.GetFiles(directory, mask))\n            {\n                try\n                {\n                    DateTime lastWrite = File.GetLastWriteTimeUtc(file);\n                    if (lastWrite < cutoff)\n                    {\n                        totalSize += new FileInfo(file).Length;\n                        File.Delete(file);\n                    }\n                }\n                catch\n                {\n                    result = false;\n                }\n            }\n            if (recursive)\n            {\n                foreach (var subDir in Directory.GetDirectories(directory))\n                {\n                    DirectoryDeleteOlderFiles(subDir, ageThreshold, mask, true, out long subSize);\n                    totalSize += subSize;\n                }\n            }\n            return result;\n        }\n\n        \n        public static string TemporaryFileName()\n        {\n            return Path.Combine(Path.GetTempPath(), $\"{Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetEntryAssembly().Location)}_{Guid.NewGuid():N}.tmp\");\n        }\n    }\n\n\n    public class MemoryMap : IDisposable\n    {\n        private MemoryMappedFile _mmf;\n        private MemoryMappedViewAccessor _accessor;\n        public byte[] Buffer { get; private set; }\n        public long Size { get; private set; }\n        public long FileSize { get; private set; }\n\n        \n        public MemoryMap(string filePath, long? customSize = null, long customOffset = 0)\n        {\n            if (!File.Exists(filePath))\n                throw new FileNotFoundException(\"File not found\", filePath);\n\n            FileSize = new FileInfo(filePath).Length;\n            Size = customSize ?? (FileSize - customOffset);\n            \n            if (Size < (1 << 20))\n            {\n                Buffer = File.ReadAllBytes(filePath);\n            }\n            else\n            {\n                _mmf = MemoryMappedFile.CreateFromFile(filePath, FileMode.Open, null, FileSize, MemoryMappedFileAccess.Read);\n                _accessor = _mmf.CreateViewAccessor(customOffset, Size, MemoryMappedFileAccess.Read);\n                Buffer = new byte[Size];\n                _accessor.ReadArray(0, Buffer, 0, (int)Size);\n            }\n        }\n\n        public void Dispose()\n        {\n            _accessor?.Dispose();\n            _mmf?.Dispose();\n        }\n    }\n\n    \n    public class LightLock\n    {\n        private int _flag;\n\n        public void Lock()\n        {\n            while (Interlocked.Exchange(ref _flag, 1) != 0)\n            {\n                Thread.SpinWait(100);\n                Thread.Yield();\n            }\n        }\n\n        public bool TryLock()\n        {\n            return Interlocked.Exchange(ref _flag, 1) == 0;\n        }\n\n        public void Unlock()\n        {\n            Volatile.Write(ref _flag, 0);\n        }\n    }\n\n    \n    public class RWLock\n    {\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n\n        public void ReadLock() => _lock.EnterReadLock();\n        public void ReadUnlock() => _lock.ExitReadLock();\n        public void WriteLock() => _lock.EnterWriteLock();\n        public void WriteUnlock() => _lock.ExitWriteLock();\n    }\n\n    \n    public class OSLock\n    {\n        private readonly object _lockObj = new object();\n\n        public void Lock() => Monitor.Enter(_lockObj);\n        public bool TryLock() => Monitor.TryEnter(_lockObj);\n        public void Unlock() => Monitor.Exit(_lockObj);\n    }\n\n\n    public class ExecutableCommandLine\n    {\n        public List<string> Args { get; private set; }\n        public ExecutableCommandLine()\n        {\n            Args = new List<string>(Environment.GetCommandLineArgs());\n            if (Args.Count > 0)\n                Args.RemoveAt(0);\n        }\n\n        \n        public string FullDescription(string exeDescription = \"\")\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(string.IsNullOrEmpty(exeDescription)\n                ? \"Usage:\"\n                : exeDescription);\n            sb.AppendLine(\"Arguments:\");\n            foreach (var arg in Args)\n                sb.AppendLine(\"  \" + arg);\n            return sb.ToString();\n        }\n\n        \n        public string DetectUnknown(HashSet<string> expectedParameters)\n        {\n            StringBuilder sb = new StringBuilder();\n            foreach (var arg in Args)\n            {\n                if (!expectedParameters.Contains(arg))\n                    sb.AppendLine($\"Unexpected parameter: {arg}\");\n            }\n            return sb.ToString();\n        }\n    }\n\n    \n    public static class ExceptionInterceptor\n    {\n        \n        public static void Setup(Action<Exception> handler)\n        {\n            AppDomain.CurrentDomain.UnhandledException += (sender, e) =>\n            {\n                handler(e.ExceptionObject as Exception);\n            };\n        }\n    }\n\n    \n    public class FileVersionInfoWrapper\n    {\n        public int Major { get; private set; }\n        public int Minor { get; private set; }\n        public int Release { get; private set; }\n        public int Build { get; private set; }\n        public DateTime BuildDateTime { get; private set; }\n        public string Detailed => $\"{Major}.{Minor}.{Release}.{Build}\";\n        public string FileName { get; private set; }\n\n        public FileVersionInfoWrapper(string fileName)\n        {\n            FileName = fileName;\n            var fvi = System.Diagnostics.FileVersionInfo.GetVersionInfo(fileName);\n            Major = fvi.FileMajorPart;\n            Minor = fvi.FileMinorPart;\n            Release = fvi.FileBuildPart;\n            Build = fvi.FilePrivatePart;\n            BuildDateTime = File.GetCreationTime(fileName);\n        }\n\n        public override string ToString()\n        {\n            return $\"{Path.GetFileName(FileName)} {Detailed} ({BuildDateTime:yyyy-MM-dd HH:mm:ss})\";\n        }\n    }\n\n    \n    public static class ConsoleUtils\n    {\n        \n        public static void ConsoleWrite(string text, ConsoleColor color = ConsoleColor.Gray, bool noLineFeed = false)\n        {\n            Console.ForegroundColor = color;\n            if (noLineFeed)\n                Console.Write(text);\n            else\n                Console.WriteLine(text);\n            Console.ResetColor();\n        }\n\n        \n        public static void ConsoleWaitForEnterKey()\n        {\n            Console.WriteLine(\"Press ENTER to continue...\");\n            Console.ReadLine();\n        }\n    }\n\n    \n    public static class ServiceHelpers\n    {\n        \n        public static bool InstallService(string serviceName, string displayName, string exePath, string dependencies = \"\", string username = \"\", string password = \"\")\n        {\n            throw new NotImplementedException(\"Service installation not implemented in this port.\");\n        }\n\n        public static bool StartService(string serviceName)\n        {\n            \n            throw new NotImplementedException(\"Service start not implemented in this port.\");\n        }\n\n        public static bool StopService(string serviceName)\n        {\n            \n            throw new NotImplementedException(\"Service stop not implemented in this port.\");\n        }\n    }\n\n    \n    public static class PrivilegeHelpers\n    {\n        \n        public static bool DropPrivileges(string userName = \"nobody\")\n        {\n            \n            throw new NotImplementedException(\"Privilege dropping is not implemented in this port.\");\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// LoggerPro\n//\n// Copyright (c) 2015-2017 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.MemoryAppender;\n\ninterface\n\nuses\n  LoggerPro, System.Generics.Collections, System.SyncObjs, System.SysUtils,\n  ThreadSafeQueueU;\n\ntype\n  TMREWLogItemList = class(TMREWObjectList<TLogItem>)\n  end;\n\n  TLoggerProMemoryAppender = class(TLoggerProAppenderBase)\n  private\n    fMREWLogList: TMREWLogItemList;\n    fTag: string;\n    fMaxSize: Int32;\n  public\n    procedure Setup; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    procedure TearDown; override;\n    constructor Create(aLogList: TMREWLogItemList; aTag: string; aMaxSize: Int32); reintroduce; virtual;\n  end;\n\nimplementation\n\nvar\n  Glock: TObject = nil;\n\n  { TLoggerProMemoryAppender }\n\nconstructor TLoggerProMemoryAppender.Create(aLogList: TMREWLogItemList; aTag: string; aMaxSize: Int32);\nbegin\n  inherited Create;\n  fMREWLogList := aLogList;\n  fTag := aTag;\n  fMaxSize := aMaxSize\nend;\n\nprocedure TLoggerProMemoryAppender.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProMemoryAppender.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProMemoryAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lList: TObjectList<TLogItem>;\nbegin\n  if aLogItem.LogTag <> fTag then\n    Exit;\n\n  lList := fMREWLogList.BeginWrite;\n  try\n    if lList.Count >= fMaxSize then\n    begin\n      while lList.Count > (fMaxSize * 0.9) do // remove 10% of the list HEAD\n        lList.Delete(0);\n    end;\n    lList.Add(aLogItem.Clone);\n  finally\n    fMREWLogList.EndWrite;\n  end;\nend;\n\ninitialization\n\nGlock := TObject.Create;\n\nfinalization\n\nGlock.Free;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing LoggerPro; \n\nnamespace LoggerPro.Appenders\n{\n   \n    public class MREWLogItemList\n    {\n        private readonly List<TLogItem> _list = new List<TLogItem>();\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\n\n        \n        public List<TLogItem> BeginWrite()\n        {\n            _lock.EnterWriteLock();\n            return _list;\n        }\n\n        \n        public void EndWrite()\n        {\n            _lock.ExitWriteLock();\n        }\n    }\n\n    \n    public class LoggerProMemoryAppender : LoggerProAppenderBase, ILogAppender\n    {\n        private readonly MREWLogItemList _mrewLogList;\n        private readonly string _tag;\n        private readonly int _maxSize;\n\n        \n        public LoggerProMemoryAppender(MREWLogItemList logList, string tag, int maxSize)\n        {\n            _mrewLogList = logList;\n            _tag = tag;\n            _maxSize = maxSize;\n        }\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            if (logItem.LogTag != _tag)\n                return;\n\n            List<TLogItem> list = _mrewLogList.BeginWrite();\n            try\n            {\n                if (list.Count >= _maxSize)\n                {\n                    \n                    int threshold = (int)(_maxSize * 0.9);\n                    while (list.Count > threshold)\n                    {\n                        list.RemoveAt(0);\n                    }\n                }\n                list.Add(logItem.Clone());\n            }\n            finally\n            {\n                _mrewLogList.EndWrite();\n            }\n        }\n    }\n}"}
{"input": "unit MVCFramework.SystemJSONUtils;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.JSON, MVCFramework.RESTClient, System.Rtti;\n\ntype\n  TSystemJSON = class sealed\n  private\n    class var CTX: TRttiContext;\n  public\n    class function StringToJSONValue(const Value: string): TJSONValue;\n    class function StringToJSONValueNoException(const Value: string): TJSONValue;\n    class function StringAsJSONObject(const Value: string): TJSONObject;\n    class function StringAsJSONObjectNoException(const Value: string): TJSONObject;\n    class function StringAsJSONArray(const Value: string): TJSONArray;\n    class function JSONValueToString(JSONValue: TJSONValue; const Owns: Boolean = true): string;\n    class function GetPair(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONPair;\n    class function GetStringDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: string = ''): string;\n    class function GetNumberDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Extended = 0): Extended;\n    class function GetJSONObj(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONObject;\n    class function GetJSONArray(JSONObject: TJSONObject; PropertyName: string)\n      : TJSONArray;\n    class function GetIntegerDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Integer = 0): Integer;\n    class function GetInt64Def(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: Int64 = 0): Int64;\n    class function GetBooleanDef(JSONObject: TJSONObject; PropertyName: string;\n      DefaultValue: boolean = false): boolean;\n    class function GetProperty(Obj: TObject;\n      const PropertyName: string): TValue; static;\n    class function PropertyExists(JSONObject: TJSONObject;\n      PropertyName: string): boolean;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Commons, System.SysUtils, MVCFramework.DuckTyping,\n  System.Classes, MVCFramework.Serializer.Commons;\n\nclass function TSystemJSON.StringAsJSONArray(const Value: string): TJSONArray;\nbegin\n  Result := TSystemJSON.StringToJSONValue(Value) as TJSONArray;\nend;\n\nclass function TSystemJSON.StringAsJSONObject(const Value: string): TJSONObject;\nbegin\n  Result := TSystemJSON.StringToJSONValue(Value) as TJSONObject;\nend;\n\nclass function TSystemJSON.StringAsJSONObjectNoException(\n  const Value: string): TJSONObject;\nbegin\n  Result := TSystemJSON.StringToJSONValueNoException(Value) as TJSONObject;\nend;\n\nclass function TSystemJSON.StringToJSONValue(const Value: string): TJSONValue;\nvar\n  lBodyAsJSONValue: TJSONValue;\nbegin\n  lBodyAsJSONValue := TJSONObject.ParseJSONValue(Value);\n  if lBodyAsJSONValue = nil then\n    raise EMVCException.Create('Invalid JSON');\n  Result := lBodyAsJSONValue;\nend;\n\nclass function TSystemJSON.StringToJSONValueNoException(\n  const Value: string): TJSONValue;\nbegin\n  Result := TJSONObject.ParseJSONValue(Value);\nend;\n\nclass function TSystemJSON.JSONValueToString(JSONValue: TJSONValue;\n  const Owns: Boolean): string;\nbegin\n  Result := JSONValue.ToJSON;\n  if Owns then\n  begin\n    JSONValue.Free;\n  end;\nend;\n\nclass function TSystemJSON.GetBooleanDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: boolean): boolean;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONFalse then\n    Exit(false)\n  else if pair.JsonValue is TJSONTrue then\n    Exit(True)\n  else\n    raise EMVCException.CreateFmt('Property %s is not a Boolean Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetInt64Def(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Int64): Int64;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsInt64)\n  else\n    raise EMVCException.CreateFmt('Property %s is not a Int64 Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetIntegerDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Integer): Integer;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsInt)\n  else\n    raise EMVCException.CreateFmt('Property %s is not an Integer Property',\n      [PropertyName]);\nend;\n\nclass function TSystemJSON.GetJSONArray(JSONObject: TJSONObject;\n  PropertyName: string): TJSONArray;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(nil);\n  if pair.JsonValue is TJSONArray then\n    Exit(TJSONArray(pair.JsonValue))\n  else\n    raise EMVCException.Create('Property is not a JSONArray');\nend;\n\nclass function TSystemJSON.GetJSONObj(JSONObject: TJSONObject;\n  PropertyName: string): TJSONObject;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(nil);\n  if pair.JsonValue is TJSONObject then\n    Exit(TJSONObject(pair.JsonValue))\n  else\n    raise EMVCException.Create('Property is not a JSONObject');\nend;\n\nclass function TSystemJSON.PropertyExists(JSONObject: TJSONObject;\n  PropertyName: string): boolean;\nbegin\n  Result := Assigned(GetPair(JSONObject, PropertyName));\nend;\n\nclass function TSystemJSON.GetNumberDef(JSONObject: TJSONObject;\n  PropertyName: string; DefaultValue: Extended): Extended;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONNumber then\n    Exit(TJSONNumber(pair.JsonValue).AsDouble)\n  else\n    raise EMVCException.Create('Property is not a Number Property');\nend;\n\nclass function TSystemJSON.GetPair(JSONObject: TJSONObject; PropertyName: string)\n  : TJSONPair;\nvar\n  pair: TJSONPair;\nbegin\n  if not Assigned(JSONObject) then\n    raise EMVCException.Create('JSONObject is nil');\n  pair := JSONObject.Get(PropertyName);\n  Result := pair;\nend;\n\nclass function TSystemJSON.GetProperty(Obj: TObject;\n  const PropertyName: string): TValue;\nvar\n  Prop: TRttiProperty;\n  ARTTIType: TRttiType;\nbegin\n  ARTTIType := ctx.GetType(Obj.ClassType);\n  if not Assigned(ARTTIType) then\n    raise EMVCException.CreateFmt('Cannot get RTTI for type [%s]',\n      [ARTTIType.ToString]);\n  Prop := ARTTIType.GetProperty(PropertyName);\n  if not Assigned(Prop) then\n    raise EMVCException.CreateFmt('Cannot get RTTI for property [%s.%s]',\n      [ARTTIType.ToString, PropertyName]);\n  if Prop.IsReadable then\n    Result := Prop.GetValue(Obj)\n  else\n    raise EMVCException.CreateFmt('Property is not readable [%s.%s]',\n      [ARTTIType.ToString, PropertyName]);\nend;\n\nclass function TSystemJSON.GetStringDef(JSONObject: TJSONObject;\n  PropertyName, DefaultValue: string): string;\nvar\n  pair: TJSONPair;\nbegin\n  pair := GetPair(JSONObject, PropertyName);\n  if pair = nil then\n    Exit(DefaultValue);\n  if pair.JsonValue is TJSONString then\n    Exit(TJSONString(pair.JsonValue).Value)\n  else\n    raise EMVCException.Create('Property is not a String Property');\nend;\n\n\n\nend.", "output": "using System;\nusing System.Reflection;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework\n{\n    \n    public static class SystemJSONUtils\n    {\n        \n        public static JToken StringToJSONValue(string value)\n        {\n            try\n            {\n                JToken token = JToken.Parse(value);\n                if (token == null)\n                    throw new Exception(\"Invalid JSON\");\n                return token;\n            }\n            catch (Exception ex)\n            {\n                throw new Exception(\"Invalid JSON: \" + ex.Message);\n            }\n        }\n\n        \n        public static JToken StringToJSONValueNoException(string value)\n        {\n            try\n            {\n                return JToken.Parse(value);\n            }\n            catch\n            {\n                return null;\n            }\n        }\n\n       \n        public static JObject StringAsJSONObject(string value)\n        {\n            var token = StringToJSONValue(value) as JObject;\n            if (token == null)\n                throw new Exception(\"Invalid JSON Object\");\n            return token;\n        }\n\n        \n        public static JObject StringAsJSONObjectNoException(string value)\n        {\n            return StringToJSONValueNoException(value) as JObject;\n        }\n\n        \n        public static JArray StringAsJSONArray(string value)\n        {\n            var token = StringToJSONValue(value) as JArray;\n            return token;\n        }\n\n       \n        public static string JSONValueToString(JToken token, bool owns = true)\n        {\n            string result = token.ToString(Formatting.None);\n            return result;\n        }\n\n        \n        public static JProperty GetPair(JObject obj, string propertyName)\n        {\n            if (obj == null)\n                throw new Exception(\"JSONObject is null\");\n            return obj.Property(propertyName);\n        }\n\n        \n        public static string GetStringDef(JObject obj, string propertyName, string defaultValue = \"\")\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.String)\n                return pair.Value.ToString();\n            throw new Exception($\"Property {propertyName} is not a String Property\");\n        }\n\n        \n        public static double GetNumberDef(JObject obj, string propertyName, double defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Float || pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<double>();\n            throw new Exception(\"Property is not a Number Property\");\n        }\n\n        \n        public static JObject GetJSONObj(JObject obj, string propertyName)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return null;\n            if (pair.Value.Type == JTokenType.Object)\n                return (JObject)pair.Value;\n            throw new Exception(\"Property is not a JSONObject\");\n        }\n\n        \n        public static JArray GetJSONArray(JObject obj, string propertyName)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return null;\n            if (pair.Value.Type == JTokenType.Array)\n                return (JArray)pair.Value;\n            throw new Exception(\"Property is not a JSONArray\");\n        }\n\n        \n        public static int GetIntegerDef(JObject obj, string propertyName, int defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<int>();\n            throw new Exception($\"Property {propertyName} is not an Integer Property\");\n        }\n\n        \n        public static long GetInt64Def(JObject obj, string propertyName, long defaultValue = 0)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Integer)\n                return pair.Value.Value<long>();\n            throw new Exception($\"Property {propertyName} is not an Int64 Property\");\n        }\n\n        \n        public static bool GetBooleanDef(JObject obj, string propertyName, bool defaultValue = false)\n        {\n            var pair = GetPair(obj, propertyName);\n            if (pair == null)\n                return defaultValue;\n            if (pair.Value.Type == JTokenType.Boolean)\n                return pair.Value.Value<bool>();\n            throw new Exception($\"Property {propertyName} is not a Boolean Property\");\n        }\n\n        \n        public static object GetProperty(object obj, string propertyName)\n        {\n            if (obj == null)\n                throw new Exception(\"Object is null\");\n            var type = obj.GetType();\n            PropertyInfo prop = type.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);\n            if (prop == null)\n                throw new Exception($\"Cannot get RTTI for property [{type.Name}.{propertyName}]\");\n            if (prop.CanRead)\n                return prop.GetValue(obj);\n            throw new Exception($\"Property is not readable [{type.Name}.{propertyName}]\");\n        }\n\n        \n        public static bool PropertyExists(JObject obj, string propertyName)\n        {\n            return obj.Property(propertyName) != null;\n        }\n    }\n}"}
{"input": "unit CustomWebModuleU;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n\n  TCustomWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVCEngine: TMVCEngine;\n  protected\n    procedure DoConfigureEngine(const aMVCEngine: TMVCEngine); virtual; abstract;\n  public\n\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  App1MainControllerU,\n  MVCFramework.Commons;\n\nprocedure TCustomWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVCEngine := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // nothing to configure here\n    end);\n  DoConfigureEngine(FMVCEngine);\nend;\n\nprocedure TCustomWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVCEngine.free;\nend;\n\nend.", "output": "using System;\n\nnamespace CustomWebModuleU\n{\n    \n    public class TMVCConfig\n    {\n        // Configuration properties go here.\n    }\n\n    public class TMVCEngine : IDisposable\n    {\n        public TMVCEngine(Action<TMVCConfig> configAction)\n        {\n            \n            TMVCConfig config = new TMVCConfig();\n            configAction(config);\n        }\n\n        public void Dispose()\n        {\n            // Dispose any resources held by the engine.\n        }\n    }\n\n    \n    public abstract class CustomWebModule : IDisposable\n    {\n        protected TMVCEngine MVCEngine { get; private set; }\n\n        \n        protected CustomWebModule()\n        {\n            \n            MVCEngine = new TMVCEngine(config =>\n            {\n                // Nothing to configure here.\n            });\n            \n            DoConfigureEngine(MVCEngine);\n        }\n\n        \n        \n        protected abstract void DoConfigureEngine(TMVCEngine engine);\n\n        \n        public void Dispose()\n        {\n            if (MVCEngine != null)\n            {\n                MVCEngine.Dispose();\n                MVCEngine = null;\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Core.Files;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes;\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections;\n{$ENDIF}\n\ntype\n  THorseCoreFile = class\n  private\n    FFileName: string;\n    FName: string;\n    FFileStream: TStream;\n    FFreeContentStream: Boolean;\n    FContentType: string;\n  public\n    constructor Create(const AFileName: string);\n    destructor Destroy; override;\n    function ContentType: string;\n    function ContentStream: TStream;\n    function Size: Int64;\n    property Name: string read FName;\n    property FreeContentStream: Boolean read FFreeContentStream write FFreeContentStream;\n  end;\n\nimplementation\n\nuses\n  Horse.Mime;\n\nconstructor THorseCoreFile.Create(const AFileName: string);\nbegin\n  if AFileName = EmptyStr then\n    raise Exception.Create('Invalid FileName');\n\n  if not FileExists(AFileName) then\n    raise Exception.Create('File not exist');\n\n  FFileName := AFileName;\n  FName := ExtractFileName(FFileName);\n  FFreeContentStream := True;\n  FContentType := THorseMimeTypes.GetFileType(FFileName);\nend;\n\ndestructor THorseCoreFile.Destroy;\nbegin\n  if FFreeContentStream then\n    FFileStream.Free;\n  inherited;\nend;\n\nfunction THorseCoreFile.ContentType: string;\nbegin\n  Result := FContentType;\nend;\n\nfunction THorseCoreFile.ContentStream: TStream;\nbegin\n  if not Assigned(FFileStream) then\n    FFileStream := TFileStream.Create(FFileName, fmOpenRead or fmShareDenyWrite);\n  Result := FFileStream;\nend;\n\nfunction THorseCoreFile.Size: Int64;\nbegin\n  Result := ContentStream.Size;\nend;\n\nend.", "output": "using System;\nusing System.IO;\n\nnamespace Horse.Core.Files\n{\n    public class HorseCoreFile : IDisposable\n    {\n        private string _fileName;\n        private string _name;\n        private FileStream _fileStream;\n        private bool _freeContentStream;\n        private string _contentType;\n\n        public HorseCoreFile(string fileName)\n        {\n            if (string.IsNullOrEmpty(fileName))\n                throw new ArgumentException(\"Invalid FileName\");\n\n            if (!File.Exists(fileName))\n                throw new FileNotFoundException(\"File not exist\", fileName);\n\n            _fileName = fileName;\n            _name = Path.GetFileName(_fileName);\n            _freeContentStream = true;\n            _contentType = HorseMimeTypes.GetFileType(_fileName);\n        }\n\n        public string ContentType()\n        {\n            return _contentType;\n        }\n\n        public Stream ContentStream()\n        {\n            if (_fileStream == null)\n            {\n                _fileStream = new FileStream(_fileName, FileMode.Open, FileAccess.Read, FileShare.Read);\n            }\n            return _fileStream;\n        }\n\n        public long Size()\n        {\n            return ContentStream().Length;\n        }\n\n        public string Name\n        {\n            get { return _name; }\n        }\n\n        public bool FreeContentStream\n        {\n            get { return _freeContentStream; }\n            set { _freeContentStream = value; }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing && _freeContentStream && _fileStream != null)\n            {\n                _fileStream.Dispose();\n                _fileStream = null;\n            }\n        }\n\n        ~HorseCoreFile()\n        {\n            Dispose(false);\n        }\n    }\n\n    public static class HorseMimeTypes\n    {\n        public static string GetFileType(string fileName)\n        {\n            string ext = Path.GetExtension(fileName)?.ToLowerInvariant();\n            switch (ext)\n            {\n                case \".html\":\n                case \".htm\":\n                    return \"text/html\";\n                case \".txt\":\n                    return \"text/plain\";\n                case \".json\":\n                    return \"application/json\";\n                case \".xml\":\n                    return \"application/xml\";\n                case \".jpg\":\n                case \".jpeg\":\n                    return \"image/jpeg\";\n                case \".png\":\n                    return \"image/png\";\n                case \".gif\":\n                    return \"image/gif\";\n                default:\n                    return \"application/octet-stream\";\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.Apache;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}\nuses\n{$IFDEF unix}\n  cthreads,\n{$ENDIF}\n  fphttp,\n  httpdefs,\n  httpd24,\n  fpApache24,\n  custapache24,\n  SysUtils,\n  Classes,\n  Horse.Provider.Abstract,\n  Horse.Proc;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FApacheApplication: TCustomApacheApplication;\n    class var FHandlerName: string;\n    class var FModuleName: string;\n    class var FDefaultModule: pmodule;\n    class function GetDefaultApacheApplication: TCustomApacheApplication;\n    class function ApacheApplicationIsNil: Boolean;\n    class procedure InternalListen; virtual;\n    class procedure SetHandlerName(const AValue: string); static;\n    class function GetHandlerName: string; static;\n    class procedure SetModuleName(const AValue: string); static;\n    class function GetModuleName: string; static;\n    class procedure SetDefaultModule(const AValue: pmodule); static;\n    class function GetDefaultModule: pmodule; static;\n    class procedure DoGetModule(Sender: TObject; ARequest: TRequest; var pmoduleClass: TCustomHTTPModuleClass);\n  public\n    class property HandlerName: string read GetHandlerName write SetHandlerName;\n    class property ModuleName: string read GetModuleName write SetModuleName;\n    class property DefaultModule: pmodule read GetDefaultModule write SetDefaultModule;\n    class procedure Listen; overload; override;\n    class procedure Listen(const ACallback: TProc); reintroduce; overload; static;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_APACHE) AND DEFINED(FPC)}\nuses\n  Horse.WebModule;\n\nclass function THorseProvider.GetDefaultApacheApplication: TCustomApacheApplication;\nbegin\n  if ApacheApplicationIsNil then\n    FApacheApplication := Application;\n  Result := FApacheApplication;\nend;\n\nclass function THorseProvider.GetDefaultModule: pmodule;\nbegin\n  Result := FDefaultModule;\nend;\n\nclass function THorseProvider.GetHandlerName: string;\nbegin\n  Result := FHandlerName;\nend;\n\nclass procedure THorseProvider.SetModuleName(const AValue: string);\nbegin\n  FModuleName := AValue;\nend;\n\nclass function THorseProvider.GetModuleName: string;\nbegin\n  Result := FModuleName;\nend;\n\nclass function THorseProvider.ApacheApplicationIsNil: Boolean;\nbegin\n  Result := FApacheApplication = nil;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LApacheApplication: TCustomApacheApplication;\nbegin\n  inherited;\n  LApacheApplication := GetDefaultApacheApplication;\n  LApacheApplication.ModuleName := FModuleName;\n  LApacheApplication.HandlerName := FHandlerName;\n  LApacheApplication.SetModuleRecord(FDefaultModule^);\n  LApacheApplication.AllowDefaultModule := True;\n  LApacheApplication.OnGetModule := DoGetModule;\n  LApacheApplication.LegacyRouting := True;\n  DoOnListen;\n  LApacheApplication.Initialize;\nend;\n\nclass procedure THorseProvider.DoGetModule(Sender: TObject; ARequest: TRequest; var pmoduleClass: TCustomHTTPModuleClass);\nbegin\n  pmoduleClass := THorseWebModule;\nend;\n\nclass procedure THorseProvider.SetDefaultModule(const AValue: pmodule);\nbegin\n  FDefaultModule := AValue;\nend;\n\nclass procedure THorseProvider.SetHandlerName(const AValue: string);\nbegin\n  FHandlerName := AValue;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const ACallback: TProc);\nbegin\n  SetOnListen(ACallback);\n  InternalListen;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Collections.Generic;\n\nnamespace Horse.Provider.FPC.Apache\n{\n    \n    public class ModuleRecord\n    {\n        // Define properties as needed.\n    }\n\n    \n    public class CustomApacheApplication\n    {\n        public string ModuleName { get; set; }\n        public string HandlerName { get; set; }\n        public bool AllowDefaultModule { get; set; }\n        public bool LegacyRouting { get; set; }\n        public Action<object, Request, out Type> OnGetModule { get; set; }\n        public bool Active { get; set; }\n        public int ListenQueue { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n        public int MaxConnections { get; set; }\n        public int DefaultPort { get; set; }\n        public bool KeepAlive { get; set; }\n        \n        \n        public void SetModuleRecord(ModuleRecord moduleRecord)\n        {\n            \n            Console.WriteLine(\"Module record set.\");\n        }\n        \n        \n        public void Initialize()\n        {\n            \n            Console.WriteLine(\"Apache application initialized.\");\n        }\n        \n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"Listening on {HandlerName}:{DefaultPort}...\");\n        }\n        \n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"Stopped listening.\");\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public class Request { }\n\n    \n    public class HorseWebModule { }\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        string Method { get; }\n        string SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public string Method => \"TLSv1.2\";\n        public string SSLVersions => \"TLSv1.2\";\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n    \n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        \n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n    }\n\n    \n\n    public static class HorseProvider \n    {\n        \n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static EventWaitHandle _event;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static CustomApacheApplication _apacheApplication;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n        private static string _handlerName;\n        private static string _moduleName;\n        private static ModuleRecord _defaultModule;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => _maxConnections; set => _maxConnections = value; }\n        public static int ListenQueue { get => _listenQueue; set => _listenQueue = value; }\n        public static bool KeepConnectionAlive { get => _keepConnectionAlive; set => _keepConnectionAlive = value; }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetDefaultHorseProviderIOHandleSSL(); set => _horseProviderIOHandleSSL = value; }\n        public static string HandlerName { get => GetHandlerName(); set => SetHandlerName(value); }\n        public static string ModuleName { get => GetModuleName(); set => SetModuleName(value); }\n        public static ModuleRecord DefaultModule { get => _defaultModule; set => _defaultModule = value; }\n\n        \n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static string GetHandlerName() => _handlerName;\n        private static void SetHandlerName(string value) => _handlerName = value;\n        private static string GetModuleName() => _moduleName;\n        private static void SetModuleName(string value) => _moduleName = value;\n\n        private static IHorseProviderIOHandleSSL GetDefaultHorseProviderIOHandleSSL()\n        {\n            if (_horseProviderIOHandleSSL == null)\n                _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New;\n            return _horseProviderIOHandleSSL;\n        }\n\n        private static CustomApacheApplication GetDefaultApacheApplication()\n        {\n            if (_apacheApplication == null)\n            {\n                \n                _apacheApplication = new CustomApacheApplication();\n            }\n            return _apacheApplication;\n        }\n\n        private static bool ApacheApplicationIsNil() => _apacheApplication == null;\n\n        private static EventWaitHandle GetDefaultEvent()\n        {\n            if (_event == null)\n                _event = new EventWaitHandle(false, EventResetMode.AutoReset);\n            return _event;\n        }\n\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n\n        \n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (_horseProviderIOHandleSSL != null) && GetDefaultHorseProviderIOHandleSSL().Active;\n        }\n\n        \n        private static void InitServerIOHandlerSSLOpenSSL(CustomApacheApplication app, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with CertFile: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        \n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var app = GetDefaultApacheApplication();\n            app.ModuleName = _moduleName;\n            app.HandlerName = _handlerName;\n            app.SetModuleRecord(_defaultModule);\n            app.AllowDefaultModule = true;\n            app.OnGetModule = DoGetModule;\n            app.LegacyRouting = true;\n            \n            HorseProviderAbstract.OnListenCallback?.Invoke();\n            app.Initialize();\n            _running = true;\n\n            if (IsConsole())\n            {\n                while (_running)\n                {\n                    GetDefaultEvent().WaitOne();\n                }\n            }\n        }\n\n        \n        private static void InternalStopListen()\n        {\n            if (!ApacheApplicationIsNil())\n            {\n                var app = GetDefaultApacheApplication();\n                app.StopListening();\n                app.Active = false;\n                HorseProviderAbstract.OnStopListenCallback?.Invoke();\n                _running = false;\n                _event?.Set();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        \n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            HorseProviderAbstract.OnListenCallback = callbackListen;\n            HorseProviderAbstract.OnStopListenCallback = callbackStopListen;\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static bool IsRunning() => _running;\n\n        public static void UnInitialize()\n        {\n            _apacheApplication = null;\n            if (_event != null)\n            {\n                _event.Dispose();\n                _event = null;\n            }\n        }\n\n        \n        private static bool IsConsole()\n        {\n            try\n            {\n                return Console.WindowHeight > 0;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \n        private static void DoGetModule(object sender, Request request, out Type moduleClass)\n        {\n            moduleClass = typeof(Horse.WebModule.HorseWebModule);\n        }\n    }\n}"}
{"input": "unit uMovie.Controller;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, uBase.Controller, JsonDataObjects;\n\ntype\n\n  [MVCPath('/movie')]\n  TMovieController = class(TBaseController)\n  private\n    FInsertMode: Boolean;\n    FIncludeBlankRow: Boolean;\n  protected\n    procedure RenderForm(const AViewNames: TArray<string>);\n  public\n    [MVCDoc('Trigger a client side error')]\n    [MVCPath('/error/400'), MVCHTTPMethod([httpGET])]\n    [MVCConsumes('application/json')]\n    procedure TriggerError;\n\n    [MVCDoc('Ask server to swap something on the page')]\n    [MVCPath('/swap'), MVCHTTPMethod([httpPATCH])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure TriggerSwap;\n\n    [MVCDoc('Get the list of Movies')]\n    [MVCPath('/page'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetMoviesPage;\n\n    [MVCDoc('Search for movies')]\n    [MVCPath('/search'), MVCHTTPMethod([httpPOST])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure SearchMovies;\n\n    [MVCDoc('Get the page to edit an individual Movie')]\n    [MVCPath('/($MovieID)/edit'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetEditPanel(MovieID: Integer);\n\n    [MVCDoc('Render a dialog for an insert')]\n    [MVCPath('/insert'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetInsertPanel;\n\n    [MVCDoc('Render a specified Movie to the grid')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpGET])]\n    [MVCProduces('text/html')]\n    procedure GetMovie(MovieID: Integer);\n\n    [MVCDoc('Update a specified Movie')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpPUT])]\n    [MVCProduces('text/html')]\n    procedure UpdateMovie(MovieID: Integer);\n\n    [MVCDoc('Create a specified Movie')]\n    [MVCPath(''), MVCHTTPMethod([httpPOST])]\n    [MVCProduces('text/html')]\n    procedure CreateMovie;\n\n    [MVCDoc('Delete a specified Movie')]\n    [MVCPath('/($MovieID)'), MVCHTTPMethod([httpDELETE])]\n    [MVCConsumes('application/json')]\n    [MVCProduces('text/html')]\n    procedure DeleteMovie(MovieID: Integer);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Utils,\n  System.SysUtils,\n  MVCFramework.Serializer.JsonDataObjects,\n  uServices,\n  System.Generics.Collections,\n  uData.Model,\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.HTMX;\n\n{ TMovieController }\n\nprocedure TMovieController.RenderForm(const AViewNames: TArray<string>);\nbegin\n  PageData.b['InsertMode'] := FInsertMode;\n  PageData.b['IncludeBlankRow'] := FIncludeBlankRow;\n  ResponseStream.Append(RenderViews(AViewNames));\n  RenderResponseStream;\nend;\n\n/// // HTML rendering\nprocedure TMovieController.GetMoviesPage;\n// render the Movies page\nvar\n  Movies: TObjectList<TMovie>;\nbegin\n  Movies := GetMovieService.ListAll;\n  try\n    ViewData['Movies'] := Movies;\n    if Context.Request.IsHTMX then\n    begin\n      PageData.S['Explanation'] := 'Loaded via a seamless ajax call';\n      // rendering with htmx, pudsh the URL into the browser bar so a page refresh will not go back to the index page\n      Context.Response.HXSetPushUrl('/movie/page');\n      // Context.Response.SetReswap(soInnerHTML,  ssScroll, sstBottom, '#theFooter');\n      RenderForm(['Movie']);\n    end\n    else\n    begin\n      // just a normal form render\n      PageData.S['Explanation'] :=\n        'Loaded via a full page reload, watch for the flicker in the title bar and see the calls in the browser Dev Tools console (network tab)';\n      RenderForm(['Header', 'Movie', 'Footer']);\n    end;\n  finally\n    Movies.Free;\n  end;\nend;\n\nprocedure TMovieController.SearchMovies;\n// Search the Movies page\nvar\n  Params: TJsonObject;\n  Movies: TObjectList<TMovie>;\nbegin\n  Params := TJsonBaseObject.Parse(Context.Request.Body) as TJsonObject;\n  Movies := GetMovieService.ListBySearchTerm(Params.S['search']);\n  try\n    ViewData['Movies'] := Movies;\n    begin\n      RenderForm(['MovieDataRow']);\n    end;\n  finally\n    Movies.Free;\n    Params.Free;\n  end;\nend;\n\nprocedure TMovieController.TriggerError;\n// propogate an error from the server back to the web page\nbegin\n  raise Exception.Create('Exception for client side');\nend;\n\nprocedure TMovieController.TriggerSwap;\nbegin\n  // make a server side delay so you can see the htmx indicator svg\n  sleep(500);\n  // now tell the web page to delay doing the content swap for another 1 second\n  Context.Response.HXSetReswap(soInnerHTML, 1000);\n  Render(Format('... Button was clicked at %s', [FormatDateTime('hh:mm:ss', Now)]));\nend;\n\nprocedure TMovieController.GetEditPanel(MovieID: Integer);\n// return the editor panel\nvar\n  Genres: TObjectList<TGenre>;\n  Movie: TMovie;\nbegin\n  Movie := GetMovieService.GetByID(MovieID);\n  Genres := GetGenreService.GetGenresAsList(Movie.GenreID);\n  try\n    ViewData['Movies'] := Movie;\n    ViewData['Genres'] := Genres;\n    Context.Response.HXTriggerClientEvent('setFocus', '.focus', etSwapped);\n    RenderForm(['MovieDataEdit']);\n  finally\n    Movie.Free;\n    Genres.Free;\n  end;\nend;\n\nprocedure TMovieController.GetInsertPanel;\n// get the movie insert panel\nvar\n  Movie: TMovie;\n  Genres: TObjectList<TGenre>;\nbegin\n  Movie := TMovie.CreateNew(true);\n  Genres := GetGenreService.GetGenresAsList(Movie.GenreID);\n  try\n    Movie.MovieID := GetMovieService.GetNextID;\n    FInsertMode := true;\n    ViewData['Genres'] := Genres;\n    ViewData['Movies'] := Movie;\n    // make sure the insert panel is visible - this shows how to triiger evenst in the browser from the server\n    Context.Response.HXTriggerClientEvent('setFocus', '.focus', etSwapped);\n    RenderForm(['MovieDataEdit']);\n  finally\n    Genres.Free;\n    Movie.Free;\n  end;\nend;\n\nprocedure TMovieController.GetMovie(MovieID: Integer);\n// render out a specified movie\nvar\n  Movie: TMovie;\nbegin\n  Movie := GetMovieService.GetByID(MovieID);\n  try\n    if Movie <> nil then\n      ViewData['Movies'] := Movie\n    else\n      FIncludeBlankRow := true;\n    RenderForm(['MovieDataRow']);\n  finally\n    if Movie <> nil then\n      Movie.Free;\n  end;\nend;\n\nprocedure TMovieController.CreateMovie;\n// create a new Movie, and return it\nvar\n  MovieID: Integer;\n  Movie: TMovie;\nbegin\n  Movie := Context.Request.BodyAs<TMovie>;\n  try\n    if not GetMovieService.UpdateMovie(Movie, true) then\n      raise Exception.Create('Could not create Movie');\n    MovieID := Movie.MovieID;\n    // send the object back to the script on the page\n    Context.Response.HXTriggerClientEvent('myEventObject', Movie);\n  finally\n    Movie.Free;\n  end;\n  FIncludeBlankRow := true;\n  GetMovie(MovieID);\nend;\n\nprocedure TMovieController.UpdateMovie(MovieID: Integer);\n// handle the update, send back the modified record\nvar\n  Movie: TMovie;\nbegin\n  Movie := Context.Request.BodyAs<TMovie>;\n  try\n    if not GetMovieService.UpdateMovie(Movie, false) then\n      raise Exception.Create('Could not update Movie');\n  finally\n    Movie.Free;\n  end;\n  Context.Response.HXTriggerClientEvent('savedEvent', 'Movie Saved OK');\n\n  GetMovie(MovieID);\nend;\n\nprocedure TMovieController.DeleteMovie(MovieID: Integer);\n// delete the movie, render nothing back so <tr> gets remove from the web page\nbegin\n  if not GetMovieService.DeleteMovie(MovieID) then\n    raise Exception.Create('Could not delete Movie');\n  Context.Response.HXTriggerClientEvent('savedEvent', 'Movie Deleted OK');\n\n  RenderForm([]);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing JsonDataObjects;\nusing System.Threading;\n\nnamespace MovieApp.Controllers\n{\n    [MVCPath(\"/movie\")]\n    public class MovieController : BaseController\n    {\n        private bool _insertMode;\n        private bool _includeBlankRow;\n\n        protected void RenderForm(string[] viewNames)\n        {\n            PageData[\"InsertMode\"] = _insertMode;\n            PageData[\"IncludeBlankRow\"] = _includeBlankRow;\n            ResponseStream.Append(RenderViews(viewNames));\n            RenderResponseStream();\n        }\n\n        [MVCDoc(\"Trigger a client side error\")]\n        [MVCPath(\"/error/400\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCConsumes(\"application/json\")]\n        public void TriggerError()\n        {\n            throw new Exception(\"Exception for client side\");\n        }\n\n        [MVCDoc(\"Ask server to swap something on the page\")]\n        [MVCPath(\"/swap\")]\n        [MVCHTTPMethod(HttpMethod.PATCH)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void TriggerSwap()\n        {\n            Thread.Sleep(500);\n            Context.Response.HXSetReswap(SwapOption.InnerHTML, 1000);\n            Render(string.Format(\"... Button was clicked at {0}\", DateTime.Now.ToString(\"hh:mm:ss\")));\n        }\n\n        [MVCDoc(\"Get the list of Movies\")]\n        [MVCPath(\"/page\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetMoviesPage()\n        {\n            var movies = GetMovieService().ListAll();\n            try\n            {\n                ViewData[\"Movies\"] = movies;\n                if (Context.Request.IsHTMX)\n                {\n                    PageData[\"Explanation\"] = \"Loaded via a seamless ajax call\";\n                    Context.Response.HXSetPushUrl(\"/movie/page\");\n                    RenderForm(new string[] { \"Movie\" });\n                }\n                else\n                {\n                    PageData[\"Explanation\"] = \"Loaded via a full page reload, watch for the flicker in the title bar and see the calls in the browser Dev Tools console (network tab)\";\n                    RenderForm(new string[] { \"Header\", \"Movie\", \"Footer\" });\n                }\n            }\n            finally\n            {\n                movies.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Search for movies\")]\n        [MVCPath(\"/search\")]\n        [MVCHTTPMethod(HttpMethod.POST)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void SearchMovies()\n        {\n            var parameters = JsonObject.Parse(Context.Request.Body) as JsonObject;\n            var movies = GetMovieService().ListBySearchTerm(parameters[\"search\"]);\n            try\n            {\n                ViewData[\"Movies\"] = movies;\n                RenderForm(new string[] { \"MovieDataRow\" });\n            }\n            finally\n            {\n                movies.Dispose();\n                parameters.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Get the page to edit an individual Movie\")]\n        [MVCPath(\"/($MovieID)/edit\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetEditPanel(int movieID)\n        {\n            var movie = GetMovieService().GetByID(movieID);\n            var genres = GetGenreService().GetGenresAsList(movie.GenreID);\n            try\n            {\n                ViewData[\"Movies\"] = movie;\n                ViewData[\"Genres\"] = genres;\n                Context.Response.HXTriggerClientEvent(\"setFocus\", \".focus\", ClientEventType.Swapped);\n                RenderForm(new string[] { \"MovieDataEdit\" });\n            }\n            finally\n            {\n                movie.Dispose();\n                genres.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Render a dialog for an insert\")]\n        [MVCPath(\"/insert\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetInsertPanel()\n        {\n            var movie = TMovie.CreateNew(true);\n            var genres = GetGenreService().GetGenresAsList(movie.GenreID);\n            try\n            {\n                movie.MovieID = GetMovieService().GetNextID();\n                _insertMode = true;\n                ViewData[\"Genres\"] = genres;\n                ViewData[\"Movies\"] = movie;\n                Context.Response.HXTriggerClientEvent(\"setFocus\", \".focus\", ClientEventType.Swapped);\n                RenderForm(new string[] { \"MovieDataEdit\" });\n            }\n            finally\n            {\n                genres.Dispose();\n                movie.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Render a specified Movie to the grid\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.GET)]\n        [MVCProduces(\"text/html\")]\n        public void GetMovie(int movieID)\n        {\n            var movie = GetMovieService().GetByID(movieID);\n            try\n            {\n                if (movie != null)\n                    ViewData[\"Movies\"] = movie;\n                else\n                    _includeBlankRow = true;\n                RenderForm(new string[] { \"MovieDataRow\" });\n            }\n            finally\n            {\n                if (movie != null)\n                    movie.Dispose();\n            }\n        }\n\n        [MVCDoc(\"Update a specified Movie\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.PUT)]\n        [MVCProduces(\"text/html\")]\n        public void UpdateMovie(int movieID)\n        {\n            var movie = Context.Request.BodyAs<TMovie>();\n            try\n            {\n                if (!GetMovieService().UpdateMovie(movie, false))\n                    throw new Exception(\"Could not update Movie\");\n            }\n            finally\n            {\n                movie.Dispose();\n            }\n            Context.Response.HXTriggerClientEvent(\"savedEvent\", \"Movie Saved OK\");\n            GetMovie(movieID);\n        }\n\n        [MVCDoc(\"Create a specified Movie\")]\n        [MVCPath(\"\")]\n        [MVCHTTPMethod(HttpMethod.POST)]\n        [MVCProduces(\"text/html\")]\n        public void CreateMovie()\n        {\n            var movie = Context.Request.BodyAs<TMovie>();\n            try\n            {\n                if (!GetMovieService().UpdateMovie(movie, true))\n                    throw new Exception(\"Could not create Movie\");\n                int movieID = movie.MovieID;\n                Context.Response.HXTriggerClientEvent(\"myEventObject\", movie);\n            }\n            finally\n            {\n                movie.Dispose();\n            }\n            _includeBlankRow = true;\n            GetMovie(movieID);\n        }\n\n        [MVCDoc(\"Delete a specified Movie\")]\n        [MVCPath(\"/($MovieID)\")]\n        [MVCHTTPMethod(HttpMethod.DELETE)]\n        [MVCConsumes(\"application/json\")]\n        [MVCProduces(\"text/html\")]\n        public void DeleteMovie(int movieID)\n        {\n            if (!GetMovieService().DeleteMovie(movieID))\n                throw new Exception(\"Could not delete Movie\");\n            Context.Response.HXTriggerClientEvent(\"savedEvent\", \"Movie Deleted OK\");\n            RenderForm(new string[] { });\n        }\n\n        private IMovieService GetMovieService() => ServiceLocator.GetMovieService();\n        private IGenreService GetGenreService() => ServiceLocator.GetGenreService();\n    }\n}"}
{"input": "unit REST.RestServer;\n\ninterface\n\nuses\n  System.SysUtils,\n  MVCFramework,\n  MVCFramework.Logger,\n  MVCFramework.Commons,\n  MVCFramework.REPLCommandsHandlerU,\n  Web.WebReq,\n  Web.WebBroker,\n  IdHTTPWebBrokerBridge;\n\ntype\n  TDMVCRestServer = class\n  private\n    fServer: TIdHTTPWebBrokerBridge;\n  public\n    constructor Create(const aPort: integer); overload;\n    procedure Activate;\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nuses\n  REST.WebModule;\n\nprocedure TDMVCRestServer.Activate;\nbegin\n  fServer.Active := true;\n\n  if fServer.Active then\n  begin\n    LogD('Server active on port=' + IntToStr(fServer.DefaultPort));\n  end;\nend;\n\nconstructor TDMVCRestServer.Create(const aPort: integer);\nbegin\n  inherited Create;\n  fServer := TIdHTTPWebBrokerBridge.Create();\n  if WebRequestHandler <> nil then\n  begin\n    WebRequestHandler.WebModuleClass := WebModuleClass;\n    WebRequestHandlerProc.MaxConnections := 1024;\n  end;\n  fServer.DefaultPort := aPort;\nend;\n\ndestructor TDMVCRestServer.Destroy;\nbegin\n  EnterInShutdownState;\n  try\n    fServer.Active := false;\n    FreeAndNil(fServer);\n    LogD('Server not active');\n  except\n    on E: Exception do\n    begin\n      LogE('[TDMVCRestServer.Destroy] ' + E.Message);\n    end;\n  end;\n  ReleaseGlobalLogger;\n  inherited Destroy;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing System.Net;\nusing MVCFramework;\nusing MVCFramework.Logger;\nusing MVCFramework.Commons;\nusing MVCFramework.REPLCommandsHandlerU;\nusing REST.WebModule;\n\nnamespace REST\n{\n    public class DMVCRestServer : IDisposable\n    {\n        private HttpListener _server;\n        public Type WebModuleClass { get; set; }\n        public DMVCRestServer(int port)\n        {\n            _server = new HttpListener();\n            _server.Prefixes.Add($\"http://*:{port}/\");\n            if (WebRequestHandler.Instance != null)\n            {\n                WebRequestHandler.Instance.WebModuleClass = WebModuleClass;\n                WebRequestHandlerProc.MaxConnections = 1024;\n            }\n        }\n        public void Activate()\n        {\n            _server.Start();\n            if (_server.IsListening)\n            {\n                var prefix = _server.Prefixes.First();\n                LogD(\"Server active on port=\" + prefix.Split(':')[2].TrimEnd('/'));\n            }\n        }\n        public void Dispose()\n        {\n            EnterInShutdownState();\n            try\n            {\n                if (_server.IsListening)\n                    _server.Stop();\n                _server.Close();\n                LogD(\"Server not active\");\n            }\n            catch (Exception ex)\n            {\n                LogE(\"[DMVCRestServer.Dispose] \" + ex.Message);\n            }\n            ReleaseGlobalLogger();\n        }\n        ~DMVCRestServer()\n        {\n            Dispose();\n        }\n        private void EnterInShutdownState() { }\n        private void ReleaseGlobalLogger() { }\n    }\n}"}
{"input": "unit Controllers.Articles;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  System.Generics.Collections,\n  Controllers.Base,\n  BusinessObjects,\n  Services;\n\ntype\n  [MVCDoc('Resource that manages articles CRUD')]\n  [MVCPath('/articles')]\n  TArticlesController = class(TBaseController)\n  private\n    fArticlesService: IArticlesService;\n  public\n    [MVCInject]\n    constructor Create(ArticlesService: IArticlesService); reintroduce;\n\n    [MVCDoc('Returns the list of articles')]\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticles: IMVCResponse;\n\n    [MVCDoc('Returns the list of articles')]\n    [MVCPath('/searches')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticlesByDescription(const [MVCFromQueryString('q', '')] Search: String): IMVCResponse;\n\n    [MVCDoc('Returns the article with the specified id')]\n    [MVCPath('/meta')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticleMeta: IMVCResponse;\n\n    [MVCDoc('Returns the article with the specified id')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    function GetArticleByID(id: Integer): IMVCResponse;\n\n    [MVCDoc('Deletes the article with the specified id')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpDelete])]\n    procedure DeleteArticleByID(id: Integer);\n\n    [MVCDoc('Updates the article with the specified id and return \"200: OK\"')]\n    [MVCPath('/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    function UpdateArticleByID(const [MVCFromBody] Article: TArticle; const id: Integer): IMVCResponse;\n\n    [MVCDoc('Creates a new article and returns \"201: Created\"')]\n    [MVCPath]\n    [MVCHTTPMethod([httpPOST])]\n    function CreateArticle(const [MVCFromBody] Article: TArticle): IMVCResponse;\n\n    [MVCDoc('Creates new articles from a list and returns \"201: Created\"')]\n    [MVCPath('/bulk')]\n    [MVCHTTPMethod([httpPOST])]\n    function CreateArticles(const [MVCFromBody] ArticleList: TObjectList<TArticle>): IMVCResponse;\n  end;\n\nimplementation\n\n{ TArticlesController }\n\nuses\n  System.SysUtils;\n\nconstructor TArticlesController.Create(ArticlesService: IArticlesService);\nbegin\n  inherited Create;\n  fArticlesService := ArticlesService;\nend;\n\nfunction TArticlesController.CreateArticle(const Article: TArticle): IMVCResponse;\nbegin\n  fArticlesService.Add(Article);\n  Result := CreatedResponse('/articles/' + Article.id.ToString, 'Article Created');\nend;\n\nfunction TArticlesController.CreateArticles(const ArticleList: TObjectList<TArticle>): IMVCResponse;\nbegin\n  fArticlesService.CreateArticles(ArticleList);\n  Result := CreatedResponse('', 'Articles created');\nend;\n\nprocedure TArticlesController.DeleteArticleByID(id: Integer);\nbegin\n  fArticlesService.Delete(fArticlesService.GetByID(id));\nend;\n\nfunction TArticlesController.GetArticles: IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetAll);\nend;\n\nfunction TArticlesController.GetArticlesByDescription(const Search: String): IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetArticles(Search));\nend;\n\nfunction TArticlesController.UpdateArticleByID(const Article: TArticle; const id: Integer): IMVCResponse;\nbegin\n  Article.id := id;\n  fArticlesService.Update(Article);\n  Result := OKResponse;\nend;\n\nfunction TArticlesController.GetArticleByID(id: Integer): IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetByID(id));\nend;\n\nfunction TArticlesController.GetArticleMeta: IMVCResponse;\nbegin\n  Result := OKResponse(fArticlesService.GetMeta);\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Controllers.Base;       \nusing BusinessObjects;        \nusing Services;                \n\nnamespace ControllersArticles\n{\n    \n    [ApiController]\n    [Route(\"articles\")]\n    public class ArticlesController : BaseController\n    {\n        private readonly IArticlesService _articlesService;\n\n        public ArticlesController(IArticlesService articlesService)\n            : base()\n        {\n            _articlesService = articlesService;\n        }\n\n        \n        [HttpGet]\n        public IActionResult GetArticles()\n        {\n            var articles = _articlesService.GetAll();\n            return Ok(articles);\n        }\n\n        \n        [HttpGet(\"searches\")]\n        public IActionResult GetArticlesByDescription([FromQuery(Name = \"q\")] string search = \"\")\n        {\n            var articles = _articlesService.GetArticles(search);\n            return Ok(articles);\n        }\n\n        \n        [HttpGet(\"meta\")]\n        public IActionResult GetArticleMeta()\n        {\n            var meta = _articlesService.GetMeta();\n            return Ok(meta);\n        }\n\n        \n        [HttpGet(\"{id}\")]\n        public IActionResult GetArticleByID(int id)\n        {\n            var article = _articlesService.GetByID(id);\n            return Ok(article);\n        }\n\n \n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteArticleByID(int id)\n        {\n            var article = _articlesService.GetByID(id);\n            _articlesService.Delete(article);\n            return Ok();\n        }\n\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateArticleByID([FromBody] TArticle article, int id)\n        {\n            article.ID = id;\n            _articlesService.Update(article);\n            return Ok();\n        }\n\n        [HttpPost]\n        public IActionResult CreateArticle([FromBody] TArticle article)\n        {\n            _articlesService.Add(article);\n            return Created($\"/articles/{article.ID}\", \"Article Created\");\n        }\n\n        \n        [HttpPost(\"bulk\")]\n        public IActionResult CreateArticles([FromBody] List<TArticle> articleList)\n        {\n            _articlesService.CreateArticles(articleList);\n            return Created(string.Empty, \"Articles created\");\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.DMSEventStreamsAppender;\n\ninterface\n\nuses\n  System.Classes,\n  MVCFramework.Commons, {this demo requires DMVCFramework}\n  System.SysUtils,\n  LoggerPro,\n  System.Net.HttpClient,\n  EventStreamsRPCProxy,\n  JsonDataObjects;\n\ntype\n\n  {\n    Log appender for a DMSContainer EventStreams endpoint\n    Author: Daniele Teti (https://github.com/danieleteti/)\n  }\n\n  TOnCreateJSONData = reference to procedure(const Sender: TObject; const LogItem: TLogItem;\n    const ExtendedInfo: TLoggerProExtendedInfo;\n    Data: TJSONObject);\n  TOnNetSendError = reference to procedure(const Sender: TObject; const LogItem: TLogItem; const NetError: Exception;\n    var RetryCount: Integer);\n\n  {\n    dmsatByTag:\n    all messages with the same tag go in the same queue\n\n    dmsatByType:\n    all messages with the same type go in the same queue\n    dmsatByTagThenType:\n    messages are organized in one queue for each tag,\n    then one queue for each type (es. myapp.mytag.error, myapp.mytag.warning etc)\n\n    dmsatByTypeThenTag:\n    messages are organized in one queue for each type,\n    then one queue for each tag (es. myapp.error.mytag, myapp.warning.mytag etc)\n  }\n  TDMSQueueAggregationType = (dmsatByTag, dmsatByType, dmsatByTagThenType, dmsatByTypeThenTag);\n\n  TLoggerProDMSContainerAppender = class(TLoggerProAppenderBase, ILogAppender)\n  strict private\n    fOnCreateJSONData: TOnCreateJSONData;\n    fOnNetSendError: TOnNetSendError;\n    fExtendedInfo: TLoggerProExtendedInfo;\n    fEventStreamsProxy: TEventStreamsRPCProxy;\n    fDMSContainerAPIKey: String;\n    fExtendedInfoData: array [low(TLogExtendedInfo) .. high(TLogExtendedInfo)] of string;\n    procedure SetOnCreateJSONData(const Value: TOnCreateJSONData);\n    procedure SetOnNetSendError(const Value: TOnNetSendError);\n  private\n    fQueueNameBase: string;\n    fLogItemAggregationType: TDMSQueueAggregationType;\n  strict protected\n    procedure LoadExtendedInfo;\n    function GetExtendedInfo: TJSONObject;\n  protected const\n    DEFAULT_EXTENDED_INFO = [TLogExtendedInfo.EIUserName, TLogExtendedInfo.EIComputerName,\n      TLogExtendedInfo.EIProcessName,\n      TLogExtendedInfo.EIProcessID, TLogExtendedInfo.EIDeviceID];\n    procedure InternalWriteLog(const aLogItem: TLogItem; const aJSONObject: TJSONObject);\n  public\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    constructor Create(aEventStreamsProxy: TEventStreamsRPCProxy;\n      aDMSContainerAPIKey: String;\n      aEventStreamsQueueNameBase: String = 'queues.logs.';\n      aLogItemAggregationType: TDMSQueueAggregationType = dmsatByTag;\n      aLogExtendedInfo: TLoggerProExtendedInfo = DEFAULT_EXTENDED_INFO); reintroduce;\n    destructor Destroy; override;\n    property OnCreateJSONData: TOnCreateJSONData read fOnCreateJSONData write SetOnCreateJSONData;\n    property OnNetSendError: TOnNetSendError read fOnNetSendError write SetOnNetSendError;\n    procedure TearDown; override;\n    procedure Setup; override;\n    function CreateData(const SrcLogItem: TLogItem): TJSONObject; virtual;\n    function GetDefaultLog(const aLogItem: TLogItem): TJSONObject; virtual;\n    class function GetModuleBaseName: String;\n  end;\n\nimplementation\n\nuses\n{$IF Defined(MSWINDOWS) }\n  Winapi.Windows,\n{$ENDIF}\n{$IF Defined(Android) }\n  Androidapi.JNI.GraphicsContentViewText,\n  Androidapi.JNI.JavaTypes,\n  Androidapi.JNI.Os,\n  Androidapi.JNI.Util,\n  Androidapi.Helpers,\n{$ENDIF}\n  System.NetEncoding,\n  System.IOUtils,\n  System.Net.URLClient;\n\n{$IFDEF MSWINDOWS }\n\n\nfunction GetUserFromWindows: string;\nvar\n  iLen: Cardinal;\nbegin\n  iLen := 256;\n  Result := StringOfChar(#0, iLen);\n  GetUserName(PChar(Result), iLen);\n  SetLength(Result, iLen - 1);\nend;\n\nfunction GetComputerNameFromWindows: string;\nvar\n  iLen: Cardinal;\nbegin\n  iLen := MAX_COMPUTERNAME_LENGTH + 1;\n  Result := StringOfChar(#0, iLen);\n  GetComputerName(PChar(Result), iLen);\n  SetLength(Result, iLen);\nend;\n\n{$ENDIF}\n\n\nconstructor TLoggerProDMSContainerAppender.Create(\n  aEventStreamsProxy: TEventStreamsRPCProxy;\n  aDMSContainerAPIKey: String;\n  aEventStreamsQueueNameBase: String;\n  aLogItemAggregationType: TDMSQueueAggregationType;\n  aLogExtendedInfo: TLoggerProExtendedInfo);\nbegin\n  inherited Create;\n  fEventStreamsProxy := aEventStreamsProxy;\n  fQueueNameBase := aEventStreamsQueueNameBase;\n  fLogItemAggregationType := aLogItemAggregationType;\n  if not fQueueNameBase.EndsWith('.') then\n    fQueueNameBase := fQueueNameBase + '.';\n  fExtendedInfo := aLogExtendedInfo;\n  fDMSContainerAPIKey := aDMSContainerAPIKey;\n  LoadExtendedInfo;\nend;\n\nfunction TLoggerProDMSContainerAppender.CreateData(const SrcLogItem: TLogItem): TJSONObject;\nbegin\n  Result := nil;\n  try\n    if Assigned(fOnCreateJSONData) then\n    begin\n      fOnCreateJSONData(Self, SrcLogItem, fExtendedInfo, Result);\n    end\n    else\n    begin\n      Result := GetDefaultLog(SrcLogItem);\n    end;\n  except\n    on E: Exception do\n    begin\n      FreeAndNil(Result);\n      raise;\n    end;\n  end;\nend;\n\ndestructor TLoggerProDMSContainerAppender.Destroy;\nbegin\n  fEventStreamsProxy.Free;\n  inherited;\nend;\n\nfunction TLoggerProDMSContainerAppender.GetDefaultLog(const aLogItem: TLogItem): TJSONObject;\nbegin\n  Result := TJSONObject.Create;\n  try\n    Result.S['timestamp'] := datetimetostr(aLogItem.TimeStamp, FormatSettings);\n    Result.L['tid'] := aLogItem.ThreadID;\n    Result.S['type'] := aLogItem.LogTypeAsString;\n    Result.S['text'] := aLogItem.LogMessage;\n    Result.O['info'] := GetExtendedInfo;\n    // Result.S['tag'] := aLogItem.LogTag;\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nfunction TLoggerProDMSContainerAppender.GetExtendedInfo: TJSONObject;\nbegin\n  Result := TJSONObject.Create;\n  try\n{$IF Defined(MSWINDOWS)}\n    if TLogExtendedInfo.EIUserName in fExtendedInfo then\n    begin\n      Result.S['username'] := fExtendedInfoData[TLogExtendedInfo.EIUserName];\n    end;\n    if TLogExtendedInfo.EIComputerName in fExtendedInfo then\n    begin\n      Result.S['computername'] := fExtendedInfoData[TLogExtendedInfo.EIComputerName];\n    end;\n    if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n    begin\n      Result.S['processname'] := fExtendedInfoData[TLogExtendedInfo.EIProcessName];\n    end;\n    if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n    begin\n      Result.S['pid'] := fExtendedInfoData[TLogExtendedInfo.EIProcessID];\n    end;\n{$ENDIF}\n{$IF Defined(Android)}\n    if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n    begin\n      Result.S['processname'] := fExtendedInfoData[TLogExtendedInfo.EIProcessName];\n    end;\n{$ENDIF}\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nclass function TLoggerProDMSContainerAppender.GetModuleBaseName: String;\nbegin\n{$IF Defined(MSWINDOWS)}\n  Result := TPath.ChangeExtension(TPath.GetFileName(GetModuleName(HInstance)), '');\n{$ENDIF}\n{$IF Defined(Android)}\n  Result := TAndroidHelper.ApplicationTitle;\n{$ENDIF}\n  if Result.IsEmpty then\n  begin\n    raise ELoggerPro.Create('Current platform not supported by ' + ClassName);\n  end;\nend;\n\nprocedure TLoggerProDMSContainerAppender.LoadExtendedInfo;\nbegin\n{$IF Defined(MSWINDOWS)}\n  if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessID] := IntToStr(GetCurrentProcessId);\n  end;\n  if TLogExtendedInfo.EIUserName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIUserName] := GetUserFromWindows;\n  end;\n  if TLogExtendedInfo.EIComputerName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIComputerName] := GetComputerNameFromWindows;\n  end;\n  if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessName] := TPath.GetFileName(GetModuleName(HInstance));\n  end;\n  if TLogExtendedInfo.EIProcessID in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessID] := IntToStr(GetCurrentProcessId);\n  end;\n{$ENDIF}\n{$IF Defined(Android)}\n  if TLogExtendedInfo.EIProcessName in fExtendedInfo then\n  begin\n    fExtendedInfoData[TLogExtendedInfo.EIProcessName] := TAndroidHelper.ApplicationTitle;\n  end;\n{$ENDIF}\nend;\n\nprocedure TLoggerProDMSContainerAppender.SetOnCreateJSONData(const Value: TOnCreateJSONData);\nbegin\n  fOnCreateJSONData := Value;\nend;\n\nprocedure TLoggerProDMSContainerAppender.SetOnNetSendError(const Value: TOnNetSendError);\nbegin\n  fOnNetSendError := Value;\nend;\n\nprocedure TLoggerProDMSContainerAppender.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProDMSContainerAppender.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProDMSContainerAppender.InternalWriteLog(const aLogItem: TLogItem;\n  const aJSONObject: TJSONObject);\nvar\n  lRetryCount: Integer;\n  lJSONResp: TJSONObject;\nconst\n  MAX_RETRY_COUNT = 5;\nbegin\n  lRetryCount := 0;\n  repeat\n    try\n      lJSONResp := fEventStreamsProxy.EnqueueMessage(fDMSContainerAPIKey, fQueueNameBase + aLogItem.LogTag,\n        aJSONObject);\n      try\n\n      finally\n        lJSONResp.Free;\n      end;\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for net exception, call it\n        if Assigned(fOnNetSendError) then\n          OnNetSendError(Self, aLogItem, E, lRetryCount);\n        Inc(lRetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if lRetryCount >= MAX_RETRY_COUNT then\n          Break;\n      end;\n    end;\n  until False;\n  // finally\n  // FreeAndNil(lHTTPCli);\n  // end;\nend;\n\nprocedure TLoggerProDMSContainerAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lRetryCount: Integer;\n  lJSONResp: TJSONObject;\n  lQueueName: string;\nconst\n  MAX_RETRY_COUNT = 5;\nbegin\n  lRetryCount := 0;\n  repeat\n    try\n      case fLogItemAggregationType of\n        dmsatByTag:\n          lQueueName := fQueueNameBase + aLogItem.LogTag;\n        dmsatByType:\n          lQueueName := fQueueNameBase + aLogItem.LogTypeAsString;\n        dmsatByTagThenType:\n          lQueueName := fQueueNameBase + aLogItem.LogTag + '.' + aLogItem.LogTypeAsString;\n        dmsatByTypeThenTag:\n          lQueueName := fQueueNameBase + aLogItem.LogTypeAsString + '.' + aLogItem.LogTag;\n      else\n        raise ELoggerPro.Create('Invalid Aggregation type');\n      end;\n      lJSONResp := fEventStreamsProxy.EnqueueMessage(fDMSContainerAPIKey,\n        lQueueName,\n        CreateData(aLogItem));\n      try\n\n      finally\n        lJSONResp.Free;\n      end;\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for net exception, call it\n        if Assigned(fOnNetSendError) then\n          OnNetSendError(Self, aLogItem, E, lRetryCount);\n        Inc(lRetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if lRetryCount >= MAX_RETRY_COUNT then\n          Break;\n      end;\n    end;\n  until False;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.IO;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing System.Runtime.InteropServices; \n\nnamespace LoggerPro.Appenders\n{\n    \n    public delegate void OnCreateJSONData(object sender, TLogItem logItem, LoggerProExtendedInfo extendedInfo, JObject data);\n\n    \n    public delegate void OnNetSendError(object sender, TLogItem logItem, Exception netError, ref int retryCount);\n\n    \n    public delegate T GetStoredProc<T>(IDbConnection connection) where T : class;\n\n    \n    public delegate void SetParams<T>(T dataObject, TLogItem logItem) where T : class;\n\n    \n    public enum DMSQueueAggregationType\n    {\n        ByTag,\n        ByType,\n        ByTagThenType,\n        ByTypeThenTag\n    }\n\n    \n    public abstract class LoggerProDMSContainerAppender<T> : LoggerProAppenderBase, ILogAppender where T : class\n    {\n        protected const int MAX_RETRY_COUNT = 5;\n\n        protected OnCreateJSONData _onCreateJSONData;\n        protected OnNetSendError _onNetSendError;\n        protected LoggerProExtendedInfo _extendedInfo;\n        \n        protected Dictionary<LogExtendedInfo, string> _extendedInfoData = new Dictionary<LogExtendedInfo, string>();\n        protected TEventStreamsRPCProxy _eventStreamsProxy;\n        protected string _dmsContainerAPIKey;\n        protected string _queueNameBase;\n        protected DMSQueueAggregationType _logItemAggregationType;\n\n        \n        public OnCreateJSONData OnCreateJSONData\n        {\n            get => _onCreateJSONData;\n            set => _onCreateJSONData = value;\n        }\n\n        public OnNetSendError OnNetSendError\n        {\n            get => _onNetSendError;\n            set => _onNetSendError = value;\n        }\n\n        \n        public LoggerProDMSContainerAppender(\n            TEventStreamsRPCProxy eventStreamsProxy,\n            string dmsContainerAPIKey,\n            string eventStreamsQueueNameBase = \"queues.logs.\",\n            DMSQueueAggregationType logItemAggregationType = DMSQueueAggregationType.ByTag,\n            LoggerProExtendedInfo logExtendedInfo = LoggerProExtendedInfo.Default)\n        {\n            _eventStreamsProxy = eventStreamsProxy ?? throw new ArgumentNullException(nameof(eventStreamsProxy));\n            _dmsContainerAPIKey = dmsContainerAPIKey;\n            _queueNameBase = eventStreamsQueueNameBase.EndsWith(\".\") ? eventStreamsQueueNameBase : eventStreamsQueueNameBase + \".\";\n            _logItemAggregationType = logItemAggregationType;\n            _extendedInfo = logExtendedInfo;\n            LoadExtendedInfo();\n        }\n\n        \n        protected abstract void RefreshParams(T dataObject);\n        protected abstract void ExecuteDataObject(T dataObject);\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        public override void TearDown()\n        {\n            base.TearDown();\n            if (_eventStreamsProxy != null)\n            {\n                _eventStreamsProxy.Dispose();\n                _eventStreamsProxy = null;\n            }\n        }\n\n        public override void TryToRestart(out bool restarted)\n        {\n            restarted = false;\n            try\n            {\n                \n                if (DbObject != null)\n                {\n                    if (DbObject is IDisposable disp)\n                    {\n                        disp.Dispose();\n                    }\n                    DbObject = null;\n                }\n            }\n            catch\n            {\n                // Ignore any errors during cleanup.\n            }\n            \n            restarted = true;\n        }\n\n        \n        protected T DbObject;\n\n        \n        protected virtual JObject GetDefaultLog(TLogItem logItem)\n        {\n            var jo = new JObject();\n            jo[\"timestamp\"] = logItem.TimeStamp.ToString(\"o\"); \n            jo[\"tid\"] = logItem.ThreadID;\n            jo[\"type\"] = logItem.LogTypeAsString;\n            jo[\"text\"] = logItem.LogMessage;\n            jo[\"info\"] = GetExtendedInfo();\n            \n            return jo;\n        }\n\n        \n        protected virtual JObject GetExtendedInfo()\n        {\n            var jo = new JObject();\n#if WINDOWS\n            if (_extendedInfo.HasFlag(LogExtendedInfo.UserName) && _extendedInfoData.ContainsKey(LogExtendedInfo.UserName))\n                jo[\"username\"] = _extendedInfoData[LogExtendedInfo.UserName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ComputerName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ComputerName))\n                jo[\"computername\"] = _extendedInfoData[LogExtendedInfo.ComputerName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessName))\n                jo[\"processname\"] = _extendedInfoData[LogExtendedInfo.ProcessName];\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessID) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessID))\n                jo[\"pid\"] = _extendedInfoData[LogExtendedInfo.ProcessID];\n#elif ANDROID\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName) && _extendedInfoData.ContainsKey(LogExtendedInfo.ProcessName))\n                jo[\"processname\"] = _extendedInfoData[LogExtendedInfo.ProcessName];\n#endif\n            return jo;\n        }\n\n        \n        public virtual JObject CreateData(TLogItem logItem)\n        {\n            JObject data;\n            try\n            {\n                if (OnCreateJSONDataCallback != null)\n                {\n                    data = new JObject();\n                    OnCreateJSONDataCallback(this, logItem, _extendedInfo, data);\n                }\n                else\n                {\n                    data = GetDefaultLog(logItem);\n                }\n            }\n            catch\n            {\n                throw;\n            }\n            return data;\n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            while (true)\n            {\n                try\n                {\n                    string queueName;\n                    switch (_logItemAggregationType)\n                    {\n                        case DMSQueueAggregationType.ByTag:\n                            queueName = _queueNameBase + logItem.LogTag;\n                            break;\n                        case DMSQueueAggregationType.ByType:\n                            queueName = _queueNameBase + logItem.LogTypeAsString;\n                            break;\n                        case DMSQueueAggregationType.ByTagThenType:\n                            queueName = _queueNameBase + logItem.LogTag + \".\" + logItem.LogTypeAsString;\n                            break;\n                        case DMSQueueAggregationType.ByTypeThenTag:\n                            queueName = _queueNameBase + logItem.LogTypeAsString + \".\" + logItem.LogTag;\n                            break;\n                        default:\n                            throw new Exception(\"Invalid Aggregation type\");\n                    }\n                    \n                    var data = CreateData(logItem);\n                    \n                    using (var response = _eventStreamsProxy.EnqueueMessage(_dmsContainerAPIKey, queueName, data))\n                    {\n                        // Optionally, process the response.\n                    }\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    if (OnNetSendErrorCallback != null)\n                    {\n                        OnNetSendErrorCallback(this, logItem, ex, ref retryCount);\n                    }\n                    retryCount++;\n                    if (retryCount >= MAX_RETRY_COUNT)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n\n        \n        public static string GetModuleBaseName()\n        {\n#if WINDOWS\n            return Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().Location);\n#elif ANDROID\n            \n            return \"AndroidApp\";\n#else\n            throw new NotSupportedException(\"Current platform not supported by LoggerProDMSContainerAppender\");\n#endif\n        }\n\n        \n        protected virtual void LoadExtendedInfo()\n        {\n#if WINDOWS\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessID))\n                _extendedInfoData[LogExtendedInfo.ProcessID] = System.Diagnostics.Process.GetCurrentProcess().Id.ToString();\n            if (_extendedInfo.HasFlag(LogExtendedInfo.UserName))\n                _extendedInfoData[LogExtendedInfo.UserName] = Environment.UserName;\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ComputerName))\n                _extendedInfoData[LogExtendedInfo.ComputerName] = Environment.MachineName;\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName))\n                _extendedInfoData[LogExtendedInfo.ProcessName] = Path.GetFileName(Assembly.GetExecutingAssembly().Location);\n#elif ANDROID\n            if (_extendedInfo.HasFlag(LogExtendedInfo.ProcessName))\n                _extendedInfoData[LogExtendedInfo.ProcessName] = \"AndroidApp\"; \n#endif\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit Serializers.JsonDataObjectsTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  System.Rtti,\n  System.Classes,\n  System.SysUtils,\n  System.DateUtils,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.JsonDataObjects,\n  MVCFramework.Tests.Serializer.Intf,\n  MVCFramework.Tests.Serializer.Entities,\n  MVCFramework.Tests.Serializer.EntitiesModule,\n  JsonDataObjects,\n  MVCFramework.DataSet.Utils;\n\ntype\n\n  [TestFixture]\n  TMVCTestSerializerJsonDataObjects = class(TObject)\n  private\n    fSerializer: IMVCSerializer;\n  public\n    [SetupFixture]\n    procedure SetupFixture;\n    [Setup]\n    procedure Setup;\n    [TearDown]\n    procedure TearDown;\n\n    { serialize declarations }\n    [Test]\n    procedure TestSerializeAsSqids;\n    [Test]\n    procedure TestSerializeAllTypes;\n    [Test]\n    procedure TestSerializeDateTimeProperty;\n    [Test]\n    procedure TestSerializeAllNullableTypes;\n    [Test]\n    procedure TestSerializeAllTypesInList;\n    [Test]\n    procedure TestSerializeEntity;\n    [Test]\n    procedure TestSerializeNil;\n    [Test]\n    procedure TestSerializeEntityUpperCaseNames;\n    [Test]\n    procedure TestSerializeEntityWithArray;\n    [Test]\n    procedure TestSerializeEntityLowerCaseNames;\n    [Test]\n    procedure TestSerializeEntityNameAs;\n    [Test]\n    procedure TestSerializeEntityCustomSerializer;\n    [Test]\n    procedure TestSerializeEntityCustomMemberSerializer;\n    [Test]\n    procedure TestSerializeEntitySerializationType;\n    [Test]\n    procedure TestSerializeCollection;\n    [Test]\n    procedure TestSerializeDataSet;\n    [Test]\n    [Category('datasets')]\n    procedure TestDataSetHelpers;\n    { deserialize declarations }\n    [Test]\n    procedure TestDeserializeEntity;\n    [Test]\n    procedure TestDeserializeEntityCustomSerializer;\n    [Test]\n    procedure TestDeserializeEntityCustomValueTypeSerializer;\n    [Test]\n    procedure TestDeserializeEntityCustomMemberSerializer;\n    [Test]\n    procedure TestDeserializeEntitySerializationType;\n    [Test]\n    procedure TestDeserializeCollection;\n    [Test]\n    procedure TestDeserializeDataSet;\n    [Test]\n    procedure TestSerializeEmptyDataSet;\n    [Test]\n    // [Category('this')]\n    procedure TestDeserializeEntityWithArray;\n    { full cycle }\n    [Test]\n    procedure TestSerializeDeSerializeEntityWithEnums;\n    [Test]\n    procedure TestSerializeDeSerializeEntityWithSet;\n    [Test]\n    procedure TestStringDictionary;\n    [Test]\n    procedure TestSerializeDeserializeGuid;\n    [Test]\n    procedure TestSerializeDeserializeEntityWithInterface;\n\n    [Test]\n    procedure TestSerializeDeserializeGenericEntity;\n    [Test]\n    procedure TestSerializeDeserializeMultipleGenericEntity;\n    [Test]\n    procedure TestDoNotSerializeDoNotDeSerialize;\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListOfSomething;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListWithNulls;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestSerializeListWithNulls2;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNotExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithFieldsUnassigned_JSONExists;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedField_WithFieldsAssigned_JSONNull;\n\n    [Test]\n    [Category('serializers')]\n    procedure TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists_Polimorphic;\n\n    [Test]\n    [Category('issues')]\n    procedure TestIssue792;\n  end;\n\n  TMVCEntityCustomSerializerJsonDataObjects = class(TInterfacedObject, IMVCTypeSerializer)\n  private\n    { private declarations }\n  protected\n    procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n      const AAttributes: TArray<TCustomAttribute>);\n  public\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n\n  end;\n\n  TMVCNullableIntegerSerializerJsonDataObjects = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n  end;\n\n  /// <summary>\n  /// When using nested generic types it is necessary to declare explicitly for delphi's RTTI to recognize them.\n  /// </summary>\n  TNestedGenericEntity = TGenericEntity<TGenericEntity<TNote>>;\n\n  TMyObj = class\n  private\n    fName: string;\n    fNumber: integer;\n  public\n    property Name: string read FName write FName;\n    property Number: integer read FNumber write FNumber;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Serializer.JsonDataObjects.CustomTypes,\n  MVCFramework.Commons, System.TypInfo, BOs, BusinessObjectsU;\n\nconst\n  LINE_BREAK = #$A;\n  TAB_SPACE = #9;\n\n  { TMVCTestSerializerJsonDataObjects }\n\nprocedure TMVCTestSerializerJsonDataObjects.Setup;\nbegin\n  inherited;\n  fSerializer := TMVCJsonDataObjectsSerializer.Create;\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TStringStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TMemoryStream), TMVCStreamSerializerJsonDataObject.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TEntityCustom), TMVCEntityCustomSerializerJsonDataObjects.Create);\n  fSerializer.RegisterTypeSerializer(System.TypeInfo(TMVCNullable<Integer>),\n    TMVCNullableIntegerSerializerJsonDataObjects.Create);\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.SetupFixture;\nbegin\n  FormatSettings.ShortDateFormat := 'dd/mm/yyyy';\n  FormatSettings.DateSeparator:= '/';\n  FormatSettings.TimeSeparator:= ':';\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TearDown;\nbegin\n  inherited;\n  fSerializer := nil;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDataSetHelpers;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50.000+01:00\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Amount\":100.0,' + '\"BlobFld\":\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\",' +\n    '\"Items\":[' + '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id\":2,' + '\"Name\":\"Juliano\"' +\n    '}' + '],' + '\"Departament\":{' + '\"Name\":\"Depto1\"' + '},' + '\"GUID\":\"{9386C957-5379-4370-8492-8FA464A9CF0C}\"' + '}';\n\n  JSON_LOWERCASE = '{' + '\"id\":1,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_UPPERCASE = '{' + '\"ID\":1,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_ASIS = '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_LIST = '[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id_Id\":2,' +\n    '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}' + ']';\n\nvar\n  Dm: TEntitiesModule;\n  S: string;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    Dm.Entity.Insert;\n    Dm.EntityId.AsLargeInt := 1;\n    Dm.EntityCode.AsInteger := 2;\n    Dm.EntityName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityBirthday.AsDateTime := StrToDate('15/10/1987');\n    Dm.EntityAccessDateTime.AsDateTime := StrToDateTime('17/02/2017 16:37:50');\n    Dm.EntityAccessTime.AsDateTime := StrToTime('16:40:50');\n    Dm.EntityActive.AsBoolean := True;\n    Dm.EntitySalary.AsCurrency := 100;\n    Dm.EntityAmount.AsFloat := 100;\n    Dm.EntityBlobFld.AsString := '<html><body><h1>BLOB</h1></body></html>';\n    Dm.EntityGUID.AsGuid := StringToGUID('{9386C957-5379-4370-8492-8FA464A9CF0C}');\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 1;\n    Dm.ItemName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.Item.Post;\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 2;\n    Dm.ItemName.AsString := 'Juliano';\n    Dm.Item.Post;\n\n    Dm.Departament.Insert;\n    Dm.DepartamentName.AsString := 'Depto1';\n    Dm.Departament.Post;\n\n    S := Dm.Entity.AsJSONObject(ncAsIs, ['Ignored']);\n    Assert.areEqual(JSON, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncAsIs);\n    Assert.areEqual(JSON_ASIS, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncUpperCase);\n    Assert.areEqual(JSON_UPPERCASE, S, False);\n\n    Dm.Item.First;\n    S := Dm.Item.AsJSONObject(ncLowerCase);\n    Assert.areEqual(JSON_LOWERCASE, S, False);\n\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeCollection;\n\n  procedure CheckObjectList(const AList: TObjectList<TNote>);\n  begin\n    Assert.isTrue(AList.Count = 4);\n    Assert.isTrue(AList.Items[0].Description = 'Description 1');\n    Assert.isTrue(AList.Items[1].Description = 'Description 2');\n    Assert.isTrue(AList.Items[2].Description = 'Description 3');\n    Assert.isTrue(AList.Items[3].Description = 'Description 4');\n  end;\n\nconst\n  JSON_PROPERTIES = '[' + '{' + '\"Description\":\"Description 1\"' + '},' + '{' + '\"Description\":\"Description 2\"' + '},' +\n    '{' + '\"Description\":\"Description 3\"' + '},' + '{' + '\"Description\":\"Description 4\"' + '}' + ']';\n\n  JSON_FIELDS = '[' + '{' + '\"FDescription\":\"Description 1\"' + '},' + '{' + '\"FDescription\":\"Description 2\"' + '},' +\n    '{' + '\"FDescription\":\"Description 3\"' + '},' + '{' + '\"FDescription\":\"Description 4\"' + '}' + ']';\nvar\n  O: TObjectList<TNote>;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TObjectList<TNote>.Create(True);\n  try\n    fSerializer.DeserializeCollection(JSON_PROPERTIES, O, TNote);\n    CheckObjectList(O);\n  finally\n    O.Free;\n  end;\n\n  O := TObjectList<TNote>.Create(True);\n  try\n    fSerializer.DeserializeCollection(JSON_FIELDS, O, TNote, stFields);\n    CheckObjectList(O);\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeDataSet;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17 16:37:50\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Amount\":100.0,' + '\"BlobFld\":\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\",' +\n    '\"Items\":[' + '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel\"' + '},' + '{' + '\"Id\":2,' + '\"Name\":\"Juliano\"' + '}' + '],' +\n    '\"Departament\":{' + '\"Name\":\"Depto1\"' + '},' + '\"GUID\":\"{9386C957-5379-4370-8492-8FA464A9CF0C}\"' + '}';\n\n  JSON_LOWERCASE = '{' + '\"id\":1,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_UPPERCASE = '{' + '\"ID\":1,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_ASIS = '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_LIST = '[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id_Id\":2,' +\n    '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}' + ']';\n\n  JSON_ITEMS = '{' + '\"items\":[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Pedro Henrique de Oliveira\"' + '},' + '{' +\n    '\"Id_Id\":2,' + '\"Name_Name\":\"Rogers Abe\"' + '}' + '],' + '\"meta\":{\"count\":\"2\"}}';\nvar\n  Dm: TEntitiesModule;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    fSerializer.DeserializeDataSetRecord(JSON, Dm.Entity, ['Ignored']);\n    Assert.isTrue(Dm.EntityId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityCode.AsInteger = 2);\n    Assert.isTrue(Dm.EntityName.AsString = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(Dm.EntityBirthday.AsDateTime = StrToDate('15/10/1987'));\n    Assert.isTrue(Dm.EntityAccessDateTime.AsDateTime = StrToDateTime('17/02/2017 16:37:50'));\n    Assert.isTrue(Dm.EntityAccessTime.AsDateTime = StrToTime('16:40:50'));\n    Assert.isTrue(Dm.EntityActive.AsBoolean = True);\n    Assert.isTrue(Dm.EntitySalary.AsCurrency = 100);\n    Assert.isTrue(Dm.EntityAmount.AsFloat = 100);\n    Assert.isTrue(Dm.EntityBlobFld.AsString = '<html><body><h1>BLOB</h1></body></html>');\n    Assert.isTrue(GUIDToString(Dm.EntityGUID.AsGuid) = '{9386C957-5379-4370-8492-8FA464A9CF0C}');\n\n    Dm.Item.First;\n    Assert.isTrue(Dm.ItemId.AsLargeInt = 1);\n    Assert.isTrue(Dm.ItemName.AsString = 'Ezequiel');\n\n    Dm.Item.Next;\n    Assert.isTrue(Dm.ItemId.AsLargeInt = 2);\n    Assert.isTrue(Dm.ItemName.AsString = 'Juliano');\n\n    Dm.Departament.First;\n    Assert.isTrue(Dm.DepartamentName.AsString = 'Depto1');\n\n    fSerializer.DeserializeDataSetRecord(JSON_LOWERCASE, Dm.EntityLowerCase);\n    Assert.isTrue(Dm.EntityLowerCaseId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityLowerCaseName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_UPPERCASE, Dm.EntityUpperCase);\n    Assert.isTrue(Dm.EntityUpperCaseId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityUpperCaseName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_UPPERCASE, Dm.EntityUpperCase2, [], ncUpperCase);\n    Assert.isTrue(Dm.EntityUpperCase2Id.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityUpperCase2Name.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    fSerializer.DeserializeDataSetRecord(JSON_ASIS, Dm.EntityAsIs);\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.EmptyDataSet;\n    fSerializer.DeserializeDataSet(JSON_LIST, Dm.EntityAsIs);\n    Dm.EntityAsIs.First;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.Next;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 2);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Ezequiel Juliano M\ufffdller');\n\n    Dm.EntityAsIs.EmptyDataSet;\n    Dm.EntityAsIs.LoadJSONArrayFromJSONObjectProperty('items', JSON_ITEMS, ncAsIs);\n    Dm.EntityAsIs.First;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 1);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Pedro Henrique de Oliveira');\n\n    Dm.EntityAsIs.Next;\n    Assert.isTrue(Dm.EntityAsIsId.AsLargeInt = 2);\n    Assert.isTrue(Dm.EntityAsIsName.AsString = 'Rogers Abe');\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntity;\n\n  procedure CheckObject(const AEntity: TEntity);\n  begin\n    Assert.isTrue(AEntity.Id = 1);\n    Assert.isTrue(AEntity.Code = 2);\n    Assert.isTrue(AEntity.Name = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(AEntity.Salary = 100);\n    Assert.isTrue(DateToStr(AEntity.Birthday) = '15/10/1987');\n    Assert.isTrue(DateTimeToStr(AEntity.AccessDateTime) = '17/02/2017 16:37:50');\n    Assert.isTrue(TimeToStr(AEntity.AccessTime) = '16:40:50');\n    Assert.isTrue(AEntity.Active = True);\n    Assert.isTrue(AEntity.Role = TRole.roGuest);\n    Assert.isTrue(DateTimeToStr(TimeStampToDateTime(AEntity.Temporization)) = '17/02/2017 16:37:50');\n    Assert.isTrue(AEntity.Department <> nil);\n    Assert.isTrue(AEntity.Department.Id = 1);\n    Assert.isTrue(AEntity.Department.Name = 'Development');\n    Assert.isTrue(AEntity.DepartmentNull = nil);\n    Assert.isTrue(AEntity.Notes.Count = 2);\n    Assert.isTrue(AEntity.Notes[0].Description = 'EntNote1');\n    Assert.isTrue(AEntity.Notes[1].Description = 'EntNote2');\n    Assert.isTrue(AEntity.NotesEmpty.Count = 0);\n    Assert.isTrue(AEntity.AppreciationAs.AsString = 'Yes');\n    Assert.isTrue(AEntity.Appreciation.AsString = 'Yes');\n  end;\n\nconst\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Role\":\"roGuest\",' + '\"Temporization\":63623032670000,' + '\"Department\":{' + '\"Id\":1,' +\n    '\"Name\":\"Development\",' + '\"Notes\":[' + '{' + '\"Description\":\"DepNote1\"' + '},' + '{' + '\"Description\":\"DepNote2\"' +\n    '}' + ']' + '},' + '\"DepartmentNull\":null,' + '\"Notes\":[' + '{' + '\"Description\":\"EntNote1\"' + '},' + '{' +\n    '\"Description\":\"EntNote2\"' + '}' + '],' + '\"NotesEmpty\":[],' + '\"AppreciationAs\":\"Yes\",' + '\"Appreciation\":{' +\n    '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\n\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\",' + '\"FSalary\":100.0,' +\n    '\"FBirthday\":\"1987-10-15\",' + '\"FAccessDateTime\":\"2017-02-17T16:37:50\",' + '\"FAccessTime\":\"16:40:50\",' +\n    '\"FActive\":true,' + '\"FRole\":\"roGuest\",' + '\"FTemporization\":63623032670000,' + '\"FDepartment\":{' + '\"FId\":1,' +\n    '\"FName\":\"Development\",' + '\"FNotes\":[' + '{' + '\"FDescription\":\"DepNote1\"' + '},' + '{' +\n    '\"FDescription\":\"DepNote2\"' + '}' + ']' + '},' + '\"FDepartmentNull\":null,' + '\"FNotes\":[' + '{' +\n    '\"FDescription\":\"EntNote1\"' + '},' + '{' + '\"FDescription\":\"EntNote2\"' + '}' + '],' + '\"FNotesEmpty\":[],' +\n    '\"FAppreciationAs\":\"Yes\",' + '\"FAppreciation\":{' + '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\nvar\n  O: TEntity;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntity.Create;\n  try\n    fSerializer.DeserializeObject(JSON_PROPERTIES, O);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n\n  O := TEntity.Create;\n  try\n    fSerializer.DeserializeObject(JSON_FIELDS, O, stFields);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomMemberSerializer;\nconst\n  JSON = '{' + '\"Entity\":{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' +\n    '\"Notes\":\"RXplcXVpZWwgSnVsaWFubyBN/GxsZXI=\",' + '\"NotesAsString\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TSale;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TSale.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Entity.Id = 1);\n    Assert.isTrue(O.Entity.Code = 2);\n    Assert.isTrue(O.Entity.Name = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(O.Notes.DataString = 'Ezequiel Juliano M\ufffdller');\n    Assert.isTrue(O.NotesAsString.DataString = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomSerializer;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityCustom;\nbegin\n  O := TEntityCustom.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Id = 1);\n    Assert.isTrue(O.Code = 2);\n    Assert.isTrue(O.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityCustomValueTypeSerializer;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"NullableInteger\":3' + '}';\nvar\n  O: TEntityCustomWithNullables;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntityCustomWithNullables.Create;\n  try\n    fSerializer.DeserializeObject(JSON, O);\n    Assert.isTrue(O.Id = 1);\n    Assert.isTrue(O.Code = 2);\n    Assert.isTrue(O.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    O.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntitySerializationType;\nconst\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  OFields: TEntitySerializeFields;\n  OProperties: TEntitySerializeProperties;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  OFields := TEntitySerializeFields.Create;\n  try\n    fSerializer.DeserializeObject(JSON_FIELDS, OFields);\n    Assert.isTrue(OFields.Id = 1);\n    Assert.isTrue(OFields.Code = 2);\n    Assert.isTrue(OFields.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    OFields.Free;\n  end;\n\n  OProperties := TEntitySerializeProperties.Create;\n  try\n    fSerializer.DeserializeObject(JSON_PROPERTIES, OProperties);\n    Assert.isTrue(OProperties.Id = 1);\n    Assert.isTrue(OProperties.Code = 2);\n    Assert.isTrue(OProperties.Name = 'Ezequiel Juliano M\ufffdller');\n  finally\n    OProperties.Free;\n  end;\n\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeEntityWithArray;\n  procedure CheckObject(const AEntity: TEntityWithArray);\n  begin\n    Assert.isTrue(AEntity.Id = 1);\n    Assert.isTrue(AEntity.Names[0] = 'Pedro');\n    Assert.isTrue(AEntity.Names[1] = 'Oliveira');\n    Assert.isTrue(AEntity.Values[0] = 1);\n    Assert.isTrue(AEntity.Values[1] = 2);\n    Assert.isTrue(AEntity.Booleans[0] = True);\n    Assert.isTrue(AEntity.Booleans[1] = False);\n    Assert.isTrue(AEntity.Booleans[2] = True);\n  end;\n\nconst\n  JSON_WITH_ARRAY = '{' + '\"Id\":1,' + '\"Names\":[\"Pedro\",\"Oliveira\"],' + '\"Values\":[1,2],\"Booleans\":[true,false,true]}';\nvar\n  O: TEntityWithArray;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n\n  O := TEntityWithArray.Create;\n  try\n    fSerializer.DeserializeObject(JSON_WITH_ARRAY, O);\n    CheckObject(O);\n  finally\n    O.Free;\n  end;\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false,' +\n\t'  \"mentor\": { ' +\n  '\t\t\t\"mentor\": null, ' +\n  '\t\t\t\"skills\": \"superb programmer\", ' +\n  '\t\t\t\"firstname\": \"mentor firstname\", ' +\n  '\t\t\t\"lastname\": \"mentor lasttname\", ' +\n  '\t\t\t\"dob\": null, ' +\n  '\t\t\t\"married\": false, ' +\n  '\t\t\t\"id\": 2 ' +\n  '\t\t\t}' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNotNull(lProgrammerEx.Mentor);\n    Assert.IsNull(lProgrammerEx.Mentor.Mentor);\n    Assert.AreEqual('mentor firstname', lProgrammerEx.Mentor.FirstName);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyUnassigned_JSONExists_Polimorphic;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false,' +\n\t'  \"mentor\": { ' +\n  '\t\t\t\"mentor\": null, ' +\n  '\t\t\t\"skills\": \"superb programmer\", ' +\n  '\t\t\t\"firstname\": \"mentor firstname\", ' +\n  '\t\t\t\"lastname\": \"mentor lasttname\", ' +\n  '\t\t\t\"dob\": null, ' +\n  '\t\t\t\"married\": false, ' +\n  '\t\t\t\"id\": 2 ' +\n  '\t\t\t}' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx2;\nbegin\n  lProgrammerEx := TProgrammerEx2.Create;\n  try\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNotNull(lProgrammerEx.Mentor);\n    Assert.IsTrue(lProgrammerEx.Mentor is TProgrammerEx2, lProgrammerEx.Mentor.ClassName);\n    Assert.AreEqual('mentor firstname', lProgrammerEx.Mentor.FirstName);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyUnAssigned_JSONNull;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false,' +\n\t'  \"mentor\": null ' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNull(lProgrammerEx.Mentor);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedField_WithFieldsAssigned_JSONNull;\nconst\n  lJSON = '{' +\n  ' \"fskills\": \"\",' +\n  ' \"fid\": 2,' +\n  ' \"ffirstname\": \"child firstname\",' +\n  ' \"flastname\": \"child lastname\",' +\n  ' \"fdob\": null,' +\n  ' \"fmarried\": false,' +\n\t' \"fmentor\": null ' +\n  ' }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    lProgrammerEx.Mentor := TProgrammerEx.Create;\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx, stFields);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNull(lProgrammerEx.Mentor);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithFieldsUnassigned_JSONExists;\nconst\n  lJSON = '{' +\n  ' \"fskills\": \"\",' +\n  ' \"fid\": 2,' +\n  ' \"ffirstname\": \"child firstname\",' +\n  ' \"flastname\": \"child lastname\",' +\n  ' \"fdob\": null,' +\n  ' \"fmarried\": false,' +\n\t' \"fmentor\": { ' +\n  '\t\t\t\"fmentor\": null, ' +\n  '\t\t\t\"fskills\": \"superb programmer\", ' +\n  '\t\t\t\"ffirstname\": \"mentor firstname\", ' +\n  '\t\t\t\"flastname\": \"mentor lasttname\", ' +\n  '\t\t\t\"fdob\": null, ' +\n  '\t\t\t\"fmarried\": false, ' +\n  '\t\t\t\"fid\": 2 ' +\n  '\t\t\t}' +\n  ' }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx, stFields);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNotNull(lProgrammerEx.Mentor);\n    Assert.IsNull(lProgrammerEx.Mentor.Mentor);\n    Assert.AreEqual('mentor firstname', lProgrammerEx.Mentor.FirstName);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyAssigned_JSONExists;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false,' +\n\t'  \"mentor\": { ' +\n  '\t\t\t\"mentor\": null, ' +\n  '\t\t\t\"skills\": \"superb programmer\", ' +\n  '\t\t\t\"firstname\": \"mentor firstname\", ' +\n  '\t\t\t\"lastname\": \"mentor lasttname\", ' +\n  '\t\t\t\"dob\": null, ' +\n  '\t\t\t\"married\": false, ' +\n  '\t\t\t\"id\": 2 ' +\n  '\t\t\t}' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    lProgrammerEx.Mentor := TProgrammerEx.Create;\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNotNull(lProgrammerEx.Mentor);\n    Assert.IsNull(lProgrammerEx.Mentor.Mentor);\n    Assert.AreEqual('mentor firstname', lProgrammerEx.Mentor.FirstName);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNotExists;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    lProgrammerEx.Mentor := TProgrammerEx.Create;\n    lProgrammerEx.Mentor.FirstName := 'existent_value';\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNotNull(lProgrammerEx.Mentor);\n    Assert.AreEqual('existent_value', lProgrammerEx.Mentor.FirstName);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDeserializeOwnedProperty_WithPropertyAssigned_JSONNull;\nconst\n  lJSON = '{' +\n  ' \"skills\": \"\",' +\n  '  \"id\": 2,' +\n  '  \"firstname\": \"child firstname\",' +\n  '  \"lastname\": \"child lastname\",' +\n  '  \"dob\": null,' +\n  '  \"married\": false,' +\n\t'  \"mentor\": null ' +\n  '  }';\nvar\n  lProgrammerEx: TProgrammerEx;\nbegin\n  lProgrammerEx := TProgrammerEx.Create;\n  try\n    lProgrammerEx.Mentor := TProgrammerEx.Create;\n    fSerializer.DeserializeObject(lJSON, lProgrammerEx);\n    Assert.AreEqual('child firstname', lProgrammerEx.FirstName);\n    Assert.IsNull(lProgrammerEx.Mentor);\n  finally\n    lProgrammerEx.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestDoNotSerializeDoNotDeSerialize;\nvar\n  lObj: TPartialSerializableType;\n  lStr: string;\nbegin\n  lObj := TPartialSerializableType.Create;\n  try\n    lStr := fSerializer.SerializeObject(lObj);\n    Assert.DoesNotContain(lStr, 'prop1', False);\n    Assert.Contains(lStr, 'prop2', False);\n    Assert.DoesNotContain(lStr, 'prop3', False);\n    Assert.Contains(lStr, 'prop4', False);\n  finally\n    lObj.Free;\n  end;\n\n  lObj := TPartialSerializableType.Create;\n  try\n    fSerializer.DeserializeObject('{\"prop1\":\"x1\",\"prop2\":\"x2\",\"prop3\":\"x3\",\"prop4\":\"x4\"}', lObj);\n    Assert.areEqual('x1', lObj.Prop1);\n    Assert.areEqual('prop2', lObj.Prop2);\n    Assert.areEqual('prop3', lObj.Prop3);\n    Assert.areEqual('x4', lObj.Prop4);\n  finally\n    lObj.Free;\n  end;\n\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestIssue792;\nvar\n  lMyObj: TMyObj;\n  lSer: IMVCSerializer;\nbegin\n  lMyObj := TMyObj.Create;\n  try\n    lMyObj.Name := 'will be changed';\n    lSer := TMVCJsonDataObjectsSerializer.Create();\n    lSer.DeserializeObject('{ \"dataobject\" : { \"name\" : \"Daniele\", \"number\" : 123 }}', lMyObj, stDefault, nil, 'dataobject');\n    Assert.Contains(lSer.SerializeObject(lMyObj), 'Daniele');\n  finally\n    lMyObj.Free;\n  end;\n\n  lMyObj := TMyObj.Create;\n  try\n    lSer := TMVCJsonDataObjectsSerializer.Create();\n    lMyObj.Name := 'the untouchable';\n    lSer.DeserializeObject('{ \"dataobject\" : null}', lMyObj, stDefault, nil, 'dataobject');\n    Assert.Contains(lSer.SerializeObject(lMyObj), 'the untouchable');\n  finally\n    lMyObj.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeAllNullableTypes;\nvar\n  lObj1, lObj2: BusinessObjectsU.TNullablesTest;\n  lSerWithNulls, lSerWithoutNulls: string;\nbegin\n  Assert.IsTrue(MVCSerializeNulls, 'By Default \"MVCSerializeNulls\" must be true');\n  lObj1 := BusinessObjectsU.TNullablesTest.Create;\n  try\n    lObj1.LoadSomeData;\n    lSerWithNulls := fSerializer.SerializeObject(lObj1);\n    lObj2 := BusinessObjectsU.TNullablesTest.Create;\n    try\n      fSerializer.DeserializeObject(lSerWithNulls, lObj2);\n      Assert.IsTrue(lObj1.Equals(lObj2));\n    finally\n      lObj2.Free;\n    end;\n  finally\n    lObj1.Free;\n  end;\n\n  MVCSerializeNulls := False;\n  try\n    lObj1 := BusinessObjectsU.TNullablesTest.Create;\n    try\n      //lObj1.LoadSomeData;\n      lSerWithoutNulls := fSerializer.SerializeObject(lObj1);\n      Assert.AreNotEqual(lSerWithNulls, lSerWithoutNulls);\n      lObj2 := BusinessObjectsU.TNullablesTest.Create;\n      try\n        fSerializer.DeserializeObject(lSerWithoutNulls, lObj2);\n        Assert.IsTrue(lObj1.Equals(lObj2));\n      finally\n        lObj2.Free;\n      end;\n    finally\n      lObj1.Free;\n    end;\n  finally\n    MVCSerializeNulls := True;\n  end;\n\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeAllTypes;\nvar\n  lObj1, lObj2: TMyObject;\n  lSer: string;\nbegin\n  lObj1 := GetMyObject;\n  try\n    lSer := fSerializer.SerializeObject(lObj1);\n    lObj2 := TMyObject.Create;\n    try\n      fSerializer.DeserializeObject(lSer, lObj2);\n      Assert.isTrue(lObj1.Equals(lObj2));\n    finally\n      lObj2.Free;\n    end;\n  finally\n    lObj1.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeAllTypesInList;\nvar\n  lList1, lList2: TObjectList<TMyObject>;\n  lSer: string;\n  I: Integer;\n  lObj: TMyObject;\nbegin\n  lList1 := TObjectList<TMyObject>.Create;\n  try\n    for I := 0 to 9 do\n    begin\n      lObj := GetMyObject;\n      lObj.PropJSONObject.I['value'] := I;\n      lList1.Add(lObj);\n    end;\n\n    lSer := fSerializer.SerializeCollection(lList1);\n\n    lList2 := TObjectList<TMyObject>.Create;\n    try\n      fSerializer.DeserializeCollection(lSer, lList2, TMyObject);\n      for I := 0 to 9 do\n      begin\n        Assert.isTrue(lList1[I].Equals(lList2[I]));\n      end;\n    finally\n      lList2.Free;\n    end;\n  finally\n    lList1.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeAsSqids;\nvar\n  lObj1: TMyObject;\n  lSer: string;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n  lObj1 := GetMyObject;\n  try\n    lSer := fSerializer.SerializeObject(lObj1);\n  finally\n    lObj1.Free;\n  end;\n\n  var lJObj := StrToJSONObject(lSer, True);\n  try\n    Assert.IsTrue(lJObj.Types['PropInt16'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropInteger'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropInt16'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropUInt16'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropInt32'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropUInt32'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropInt64'] = jdtInt);\n    Assert.IsTrue(lJObj.Types['PropUInt64'] = jdtLong);\n\n    Assert.IsTrue(lJObj.Types['PropInt16Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropIntegerSqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropInt16Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropUInt16Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropInt32Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropUInt32Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropInt64Sqids'] = jdtString);\n    Assert.IsTrue(lJObj.Types['PropUInt64Sqids'] = jdtString);\n  finally\n    lJObj.Free;\n  end;\n  MVCNameCaseDefault := lSavedMVCNameCase\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeCollection;\nconst\n  JSON = '[' + '{' + '\"Description\":\"Description 1\"' + '},' + '{' + '\"Description\":\"Description 2\"' + '},' + '{' +\n    '\"Description\":\"Description 3\"' + '},' + '{' + '\"Description\":\"Description 4\"' + '}' + ']';\n\n  JSON_FIELDS = '[' + '{' + '\"FDescription\":\"Description 1\"' + '},' + '{' + '\"FDescription\":\"Description 2\"' + '},' +\n    '{' + '\"FDescription\":\"Description 3\"' + '},' + '{' + '\"FDescription\":\"Description 4\"' + '}' + ']';\nvar\n  O: TObjectList<TNote>;\n  S: string;\nbegin\n  O := TObjectList<TNote>.Create(True);\n  try\n    O.Add(TNote.Create('Description 1'));\n    O.Add(TNote.Create('Description 2'));\n    O.Add(TNote.Create('Description 3'));\n    O.Add(TNote.Create('Description 4'));\n\n    S := fSerializer.SerializeCollection(O);\n    Assert.areEqual(JSON, S);\n\n    S := fSerializer.SerializeCollection(O, stFields);\n    Assert.areEqual(JSON_FIELDS, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDataSet;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50.000+01:00\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Amount\":100.0,' + '\"BlobFld\":\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\",' +\n    '\"Items\":[' + '{' + '\"Id\":1,' + '\"Name\":\"Ezequiel\"' + '},' + '{' + '\"Id\":2,' + '\"Name\":\"Juliano\"' + '}' + '],' +\n    '\"Departament\":{' + '\"Name\":\"Depto1\"' + '},' + '\"GUID\":\"{9386C957-5379-4370-8492-8FA464A9CF0C}\"' + '}';\n\n  JSON_LOWERCASE = '{' + '\"id\":1,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_UPPERCASE = '{' + '\"ID\":1,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_ASIS = '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_LIST = '[' + '{' + '\"Id_Id\":1,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '},' + '{' + '\"Id_Id\":2,' +\n    '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}' + ']';\n\nvar\n  Dm: TEntitiesModule;\n  S: string;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    Dm.Entity.Insert;\n    Dm.EntityId.AsLargeInt := 1;\n    Dm.EntityCode.AsInteger := 2;\n    Dm.EntityName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityBirthday.AsDateTime := StrToDate('15/10/1987');\n    Dm.EntityAccessDateTime.AsDateTime := StrToDateTime('17/02/2017 16:37:50');\n    Dm.EntityAccessTime.AsDateTime := StrToTime('16:40:50');\n    Dm.EntityActive.AsBoolean := True;\n    Dm.EntitySalary.AsCurrency := 100;\n    Dm.EntityAmount.AsFloat := 100;\n    Dm.EntityBlobFld.AsString := '<html><body><h1>BLOB</h1></body></html>';\n    Dm.EntityGUID.AsGuid := StringToGUID('{9386C957-5379-4370-8492-8FA464A9CF0C}');\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 1;\n    Dm.ItemName.AsString := 'Ezequiel';\n    Dm.Item.Post;\n\n    Dm.Item.Insert;\n    Dm.ItemId.AsLargeInt := 2;\n    Dm.ItemName.AsString := 'Juliano';\n    Dm.Item.Post;\n\n    Dm.Departament.Insert;\n    Dm.DepartamentName.AsString := 'Depto1';\n    Dm.Departament.Post;\n\n    Dm.Entity.Post;\n    S := fSerializer.SerializeDataSetRecord(Dm.Entity, ['Ignored'], ncAsIs);\n    Assert.areEqual(JSON, S, False);\n\n    Dm.EntityLowerCase.Insert;\n    Dm.EntityLowerCaseId.AsLargeInt := 1;\n    Dm.EntityLowerCaseName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityLowerCase.Post;\n    S := fSerializer.SerializeDataSetRecord(Dm.EntityLowerCase);\n    Assert.areEqual(JSON_LOWERCASE, S, False, 'json lowercase');\n\n    Dm.EntityUpperCase.Insert;\n    Dm.EntityUpperCaseId.AsLargeInt := 1;\n    Dm.EntityUpperCaseName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityUpperCase.Post;\n    S := fSerializer.SerializeDataSetRecord(Dm.EntityUpperCase);\n    Assert.areEqual(JSON_UPPERCASE, S, False, 'json uppercase (1)');\n\n    Dm.EntityUpperCase2.Insert;\n    Dm.EntityUpperCase2Id.AsLargeInt := 1;\n    Dm.EntityUpperCase2Name.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityUpperCase2.Post;\n    S := fSerializer.SerializeDataSetRecord(Dm.EntityUpperCase2, [], ncUpperCase);\n    Assert.areEqual(JSON_UPPERCASE, S, False, 'json uppercase (2)');\n\n    Dm.EntityAsIs.Insert;\n    Dm.EntityAsIsId.AsLargeInt := 1;\n    Dm.EntityAsIsName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityAsIs.Post;\n    S := fSerializer.SerializeDataSetRecord(Dm.EntityAsIs);\n    Assert.areEqual(JSON_ASIS, S, False, 'json as is');\n\n    Dm.EntityAsIs.Append;\n    Dm.EntityAsIsId.AsLargeInt := 2;\n    Dm.EntityAsIsName.AsString := 'Ezequiel Juliano M\ufffdller';\n    Dm.EntityAsIs.Post;\n\n    // serialize dataset\n    S := fSerializer.SerializeDataSet(Dm.EntityAsIs);\n    Assert.areEqual(JSON_LIST, S, False, 'json list');\n\n    // serialize dataset as object\n    S := fSerializer.SerializeObject(Dm.EntityAsIs);\n    Assert.areEqual(JSON_LIST, S, False, 'json list');\n\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDateTimeProperty;\nvar\n  lObj1, lObj2: TMyObjectWithUTC;\n  lSer: string;\nbegin\n  lObj1 := TMyObjectWithUTC.Create;\n  try\n    lObj1.MyDateTime := EncodeDateTime(2020, 11, 4, 12, 12, 12, 0);\n    lSer := fSerializer.SerializeObject(lObj1);\n    lObj2 := TMyObjectWithUTC.Create;\n    try\n      fSerializer.DeserializeObject(lSer, lObj2);\n      Assert.isTrue(lObj1.Equals(lObj2));\n    finally\n      lObj2.Free;\n    end;\n  finally\n    lObj1.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeSerializeEntityWithEnums;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Daniele Teti\",' + '\"Color\":\"RED\",' + '\"MonthName\":\"January\",' +\n    '\"MonthName2\":\"meFebruary\",' + '\"MonthOrder\":0' + '}';\nvar\n  O: TEntityWithEnums;\n  S: string;\nbegin\n  O := TEntityWithEnums.Create;\n  try\n    O.Id := 1;\n    O.Code := 2;\n    O.Name := 'Daniele Teti';\n    O.Color := TColorEnum.RED;\n    O.MonthName := TMonthEnum.meJanuary;\n    O.MonthName2 := TMonthEnum.meFebruary;\n    O.MonthOrder := TMonthEnum.meJanuary;\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\n\n  O := TEntityWithEnums.Create;\n  try\n    fSerializer.DeserializeObject(S, O);\n    Assert.areEqual(int64(1), O.Id);\n    Assert.areEqual(2, O.Code);\n    Assert.areEqual('Daniele Teti', O.Name);\n    Assert.areEqual(Ord(TMonthEnum.meJanuary), Ord(O.MonthName));\n    Assert.areEqual(Ord(TMonthEnum.meFebruary), Ord(O.MonthName2));\n    Assert.areEqual(Ord(TMonthEnum.meJanuary), Ord(O.MonthOrder));\n    Assert.areEqual(Ord(TColorEnum.RED), Ord(O.Color));\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEmptyDataSet;\nvar\n  Dm: TEntitiesModule;\n  S: string;\nbegin\n  Dm := TEntitiesModule.Create(nil);\n  try\n    Dm.Entity.EmptyDataSet;\n    S := fSerializer.SerializeDataSet(Dm.Entity);\n    Assert.areEqual('[]', S);\n  finally\n    Dm.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntity;\nconst\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":\"1987-10-15\",' + '\"AccessDateTime\":\"2017-02-17T16:37:50.000+01:00\",' + '\"AccessTime\":\"16:40:50\",' +\n    '\"Active\":true,' + '\"Role\":\"roGuest\",' + '\"Temporization\":63623032670000,' + '\"Department\":{' + '\"Id\":1,' +\n    '\"Name\":\"Development\",' + '\"Notes\":[' + '{' + '\"Description\":\"DepNote1\"' + '},' + '{' + '\"Description\":\"DepNote2\"' +\n    '}' + ']' + '},' + '\"DepartmentNull\":null,' + '\"Notes\":[' + '{' + '\"Description\":\"EntNote1\"' + '},' + '{' +\n    '\"Description\":\"EntNote2\"' + '}' + '],' + '\"NotesEmpty\":[],' + '\"AppreciationAs\":\"Yes\",' + '\"Appreciation\":{' +\n    '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\n\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\",' + '\"FSalary\":100.0,' +\n    '\"FBirthday\":\"1987-10-15\",' + '\"FAccessDateTime\":\"2017-02-17T16:37:50.000+01:00\",' + '\"FAccessTime\":\"16:40:50\",' +\n    '\"FActive\":true,' + '\"FRole\":\"roGuest\",' + '\"FTemporization\":63623032670000,' + '\"FDepartment\":{' + '\"FId\":1,' +\n    '\"FName\":\"Development\",' + '\"FNotes\":[' + '{' + '\"FDescription\":\"DepNote1\"' + '},' + '{' +\n    '\"FDescription\":\"DepNote2\"' + '}' + ']' + '},' + '\"FDepartmentNull\":null,' + '\"FNotes\":[' + '{' +\n    '\"FDescription\":\"EntNote1\"' + '},' + '{' + '\"FDescription\":\"EntNote2\"' + '}' + '],' + '\"FNotesEmpty\":[],' +\n    '\"FAppreciationAs\":\"Yes\",' + '\"FAppreciation\":{' + '\"type\":\"ustring\",' + '\"value\":\"Yes\"' + '}' + '}';\n\n  JSON_NULLS = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\",' + '\"Salary\":100.0,' +\n    '\"Birthday\":null,' + '\"AccessDateTime\":null,' + '\"AccessTime\":null,' + '\"Active\":true,' + '\"Role\":\"roGuest\",' +\n    '\"Temporization\":63623032670000,' + '\"Department\":{' + '\"Id\":1,' + '\"Name\":\"Development\",' + '\"Notes\":[' + '{' +\n    '\"Description\":\"DepNote1\"' + '},' + '{' + '\"Description\":\"DepNote2\"' + '}' + ']' + '},' + '\"DepartmentNull\":null,' +\n    '\"Notes\":[' + '{' + '\"Description\":\"EntNote1\"' + '},' + '{' + '\"Description\":\"EntNote2\"' + '}' + '],' +\n    '\"NotesEmpty\":[],' + '\"AppreciationAs\":\"Yes\",' + '\"Appreciation\":{' + '\"type\":\"ustring\",' + '\"value\":\"Yes\"' +\n    '}' + '}';\nvar\n  O: TEntity;\n  S: string;\n  lSavedMVCNameCaseDefault: TMVCNameCase;\nbegin\n  lSavedMVCNameCaseDefault := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n  try\n    O := TEntity.Create;\n    try\n      O.Id := 1;\n      O.Code := 2;\n      O.Name := 'Ezequiel Juliano M\ufffdller';\n      O.Salary := 100;\n      O.Birthday := StrToDate('15/10/1987');\n      O.AccessDateTime := StrToDateTime('17/02/2017 16:37:50');\n      O.AccessTime := StrToTime('16:40:50');\n      O.Active := True;\n      O.Role := roGuest;\n      O.Temporization := DateTimeToTimeStamp(StrToDateTime('17/02/2017 16:37:50'));\n      O.Appreciation := 'Yes';\n      O.AppreciationAs := 'Yes';\n      O.Ignored := 'Yes';\n      O.Transient := 'Yes';\n      O.Notes.Add(TNote.Create('EntNote1'));\n      O.Notes.Add(TNote.Create('EntNote2'));\n      O.Department.Id := 1;\n      O.Department.Name := 'Development';\n      O.Department.Notes.Add(TNote.Create('DepNote1'));\n      O.Department.Notes.Add(TNote.Create('DepNote2'));\n\n      S := fSerializer.SerializeObject(O, stProperties, ['Ignored']);\n      Assert.areEqual(JSON_PROPERTIES, S);\n\n      S := fSerializer.SerializeObject(O, stFields, ['FIgnored']);\n      Assert.areEqual(JSON_FIELDS, S);\n\n      O.Birthday := 0;\n      O.AccessDateTime := 0;\n      O.AccessTime := 0;\n      S := fSerializer.SerializeObject(O, stProperties, ['Ignored']);\n      Assert.areEqual(JSON_NULLS, S);\n    finally\n      O.Free;\n    end;\n  finally\n    MVCNameCaseDefault := lSavedMVCNameCaseDefault;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityCustomMemberSerializer;\nconst\n  JSON = '{' + '\"Entity\":{' + '\"AId\":1,' + '\"ACode\":2,' + '\"AName\":\"Ezequiel Juliano M\ufffdller\"' + '},' +\n    '\"Notes\":\"RXplcXVpZWwgSnVsaWFubyBN/GxsZXI=\",' + '\"NotesAsString\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TSale;\n  S: string;\nbegin\n  O := TSale.Create;\n  try\n    O.Entity.Id := 1;\n    O.Entity.Code := 2;\n    O.Entity.Name := 'Ezequiel Juliano M\ufffdller';\n    O.Notes.WriteString('Ezequiel Juliano M\ufffdller');\n    O.NotesAsString.WriteString('Ezequiel Juliano M\ufffdller');\n\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityCustomSerializer;\nconst\n  JSON = '{' + '\"AId\":1,' + '\"ACode\":2,' + '\"AName\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityCustom;\n  S: string;\nbegin\n  O := TEntityCustom.Create;\n  try\n    O.Id := 1;\n    O.Code := 2;\n    O.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityLowerCaseNames;\nconst\n  JSON = '{' + '\"id\":1,' + '\"code\":2,' + '\"name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityLowerCase;\n  S: string;\nbegin\n  O := TEntityLowerCase.Create;\n  try\n    O.Id := 1;\n    O.Code := 2;\n    O.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityNameAs;\nconst\n  JSON = '{' + '\"Id_Id\":1,' + '\"Code_Code\":2,' + '\"Name_Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityNameAs;\n  S: string;\nbegin\n  O := TEntityNameAs.Create;\n  try\n    O.Id := 1;\n    O.Code := 2;\n    O.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n\n    S := fSerializer.SerializeObject(O, stFields);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntitySerializationType;\nconst\n  JSON_FIELDS = '{' + '\"FId\":1,' + '\"FCode\":2,' + '\"FName\":\"Ezequiel Juliano M\ufffdller\"' + '}';\n\n  JSON_PROPERTIES = '{' + '\"Id\":1,' + '\"Code\":2,' + '\"Name\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  OFields: TEntitySerializeFields;\n  OProperties: TEntitySerializeProperties;\n  S: string;\nbegin\n  OFields := TEntitySerializeFields.Create;\n  try\n    OFields.Id := 1;\n    OFields.Code := 2;\n    OFields.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(OFields);\n    Assert.areEqual(JSON_FIELDS, S);\n  finally\n    OFields.Free;\n  end;\n\n  OProperties := TEntitySerializeProperties.Create;\n  try\n    OProperties.Id := 1;\n    OProperties.Code := 2;\n    OProperties.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(OProperties);\n    Assert.areEqual(JSON_PROPERTIES, S);\n  finally\n    OProperties.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityUpperCaseNames;\nconst\n  JSON = '{' + '\"ID\":1,' + '\"CODE\":2,' + '\"NAME\":\"Ezequiel Juliano M\ufffdller\"' + '}';\nvar\n  O: TEntityUpperCase;\n  S: string;\nbegin\n  O := TEntityUpperCase.Create;\n  try\n    O.Id := 1;\n    O.Code := 2;\n    O.Name := 'Ezequiel Juliano M\ufffdller';\n\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeEntityWithArray;\nconst\n  JSON_WITH_ARRAY = '{' + '\"Id\":1,' + '\"Names\":[\"Pedro\",\"Oliveira\"],' +\n    '\"Values\":[1,2],\"Values8\":[7,8],\"Values64\":[3,4],\"Booleans\":[true,false,true]' + '}';\nvar\n  O: TEntityWithArray;\n  S: string;\nbegin\n  O := TEntityWithArray.Create;\n  try\n    O.Id := 1;\n    O.Names := ['Pedro', 'Oliveira'];\n    O.Values := [1, 2];\n    O.Values8 := [7, 8];\n    O.Values64 := [3, 4];\n    O.Booleans := [True, False, True];\n    S := fSerializer.SerializeObject(O);\n    Assert.areEqual(JSON_WITH_ARRAY, S);\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeListOfSomething;\nvar\n  lList, lList2: TListOfSomething;\n  lData: string;\nbegin\n  lList := TListOfSomething.Create;\n  try\n    lData := fSerializer.SerializeObject(lList);\n\n    lList2 := TListOfSomething.Create;\n    try\n      lList2.ListOfString.Clear;\n      lList2.ListOfInteger.Clear;\n      lList2.ListOfBoolean.Clear;\n      lList2.ListOfDouble.Clear;\n\n      fSerializer.DeserializeObject(lData, lList2);\n\n      Assert.areEqual<Integer>(2, lList2.ListOfString.Count);\n      Assert.areEqual<Integer>(2, lList2.ListOfInteger.Count);\n      Assert.areEqual<Integer>(2, lList2.ListOfBoolean.Count);\n      Assert.areEqual<Integer>(2, lList2.ListOfDouble.Count);\n\n      Assert.areEqual(lList.ListOfString[0], lList2.ListOfString[0]);\n      Assert.areEqual(lList.ListOfString[1], lList2.ListOfString[1]);\n\n      Assert.areEqual(lList.ListOfInteger[0], lList2.ListOfInteger[0]);\n      Assert.areEqual(lList.ListOfInteger[1], lList2.ListOfInteger[1]);\n\n      Assert.areEqual(lList.ListOfBoolean[0], lList2.ListOfBoolean[0]);\n      Assert.areEqual(lList.ListOfBoolean[1], lList2.ListOfBoolean[1]);\n\n      Assert.areEqual(lList.ListOfDouble[0], lList2.ListOfDouble[0], 0.0001);\n      Assert.areEqual(lList.ListOfDouble[1], lList2.ListOfDouble[1], 0.0001);\n    finally\n      lList2.Free;\n    end;\n  finally\n    lList.Free;\n  end;\n\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeListWithNulls;\nvar\n  lPeople: TPeople;\n  lPerson: TPerson;\n  lStr: string;\n  lJObj: TJsonObject;\nbegin\n  var lSavedMVCNameCase := MVCNameCaseDefault;\n  MVCNameCaseDefault := ncAsIs;\n  lPeople := TPeople.Create;\n  try\n    lPerson := TPerson.Create;\n    lPerson.Id := 1;\n    lPerson.FirstName := 'Daniele';\n    lPerson.LastName := 'Teti';\n    lPeople.Add(lPerson);\n    lPeople.Add(nil);\n    lStr := fSerializer.SerializeObject(lPeople);\n    lJObj := TJsonObject.Parse(lStr) as TJsonObject;\n    try\n      // this test should test that the serialization happens even for \"nil\" objects\n      Assert.IsFalse(lJObj.A['List'].Items[0].IsNull);\n      Assert.isTrue(lJObj.A['List'].Items[1].IsNull);\n    finally\n      lJObj.Free;\n    end;\n  finally\n    lPeople.Free;\n  end;\n  MVCNameCaseDefault := lSavedMVCNameCase;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeListWithNulls2;\nvar\n  lPeople: TPeople;\n  lPerson: TPerson;\n  lStr: string;\n  lJArr: TJsonArray;\nbegin\n  lPeople := TPeople.Create;\n  try\n    lPerson := TPerson.Create;\n    lPerson.Id := 1;\n    lPerson.FirstName := 'Daniele';\n    lPerson.LastName := 'Teti';\n    lPeople.Add(lPerson);\n    lPeople.Add(nil);\n    lStr := fSerializer.SerializeCollection(lPeople);\n    lJArr := TJsonObject.Parse(lStr) as TJsonArray;\n    try\n      // this test should test that the serialization happens even for \"nil\" objects\n      Assert.IsFalse(lJArr.Items[0].IsNull);\n      Assert.IsTrue(lJArr.Items[1].IsNull);\n    finally\n      lJArr.Free;\n    end;\n  finally\n    lPeople.Free;\n  end;\nend;\n\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeserializeEntityWithInterface;\nconst\n  JSON = '{' + '\"Id\":1,' + '\"Name\":\"Jo\ufffdo Ant\ufffdnio Duarte\",' + '\"ChildEntity\":{' + '\"Code\":10,' +\n    '\"Description\":\"Child Entity\"' + '}' + '}';\nvar\n  LEntity: IEntityWithInterface;\n  LJson: string;\nbegin\n  LEntity := TEntityWithInterface.Create;\n  LEntity.Id := 1;\n  LEntity.Name := 'Jo\ufffdo Ant\ufffdnio Duarte';\n  LEntity.ChildEntity.Code := 10;\n  LEntity.ChildEntity.Description := 'Child Entity';\n\n  LJson := fSerializer.SerializeObject(LEntity);\n  Assert.areEqual(JSON, LJson);\n\n  LEntity := TEntityWithInterface.Create;\n  fSerializer.DeserializeObject(LJson, LEntity);\n  Assert.areEqual(Integer(1), LEntity.Id);\n  Assert.areEqual('Jo\ufffdo Ant\ufffdnio Duarte', LEntity.Name);\n  Assert.areEqual(Integer(10), LEntity.ChildEntity.Code);\n  Assert.areEqual('Child Entity', LEntity.ChildEntity.Description);\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeSerializeEntityWithSet;\nconst\n  O1 = '{\"MonthsSet\":\"meJanuary,meMarch\",\"ColorsSet\":\"\"}';\n  O2 = '{\"MonthsSet\":\"\",\"ColorsSet\":\"RED\"}';\n  O3 = '{\"MonthsSet\":\"meJanuary,meFebruary,meMarch\",\"ColorsSet\":\"RED,GREEN,BLUE\"}';\nvar\n  O: TEntityWithSets;\n  S: string;\n  OClone: TEntityWithSets;\nbegin\n  O := TEntityWithSets.Create;\n  try\n    O.MonthsSet := [meJanuary, meMarch];\n    O.ColorsSet := [];\n    S := fSerializer.SerializeObject(O);\n    Assert.AreEqual(O1, S);\n    OClone := TEntityWithSets.Create;\n    try\n      fSerializer.DeserializeObject(S, OClone);\n      Assert.IsTrue(OClone.MonthsSet = [meJanuary,meMarch]);\n      Assert.IsTrue(OClone.ColorsSet = []);\n    finally\n      OClone.Free;\n    end;\n\n    ////////\n    O.MonthsSet := [];\n    O.ColorsSet := [TColorEnum.RED];\n    S := fSerializer.SerializeObject(O);\n    Assert.AreEqual(O2, S);\n    OClone := TEntityWithSets.Create;\n    try\n      fSerializer.DeserializeObject(S, OClone);\n      Assert.IsTrue(OClone.MonthsSet = []);\n      Assert.IsTrue(OClone.ColorsSet = [RED]);\n    finally\n      OClone.Free;\n    end;\n\n\n    ///////\n    O.MonthsSet := [meJanuary, meMarch, meFebruary];\n    O.ColorsSet := [TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE];\n    S := fSerializer.SerializeObject(O);\n    Assert.AreEqual(O3, S);\n\n    OClone := TEntityWithSets.Create;\n    try\n      fSerializer.DeserializeObject(S, OClone);\n      Assert.IsTrue(OClone.MonthsSet = [meJanuary, meFebruary, meMarch]);\n      Assert.IsTrue(OClone.ColorsSet = [RED, GREEN, BLUE]);\n    finally\n      OClone.Free;\n    end;\n  finally\n    O.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeserializeGenericEntity;\nconst\n  JSON = '{' + '\"Code\":1,' + '\"Description\":\"General Description\",' + '\"Items\":[' + '{\"Description\":\"Description 01\"},'\n    + '{\"Description\":\"Description 02\"},' + '{\"Description\":\"Description 03\"},' + '{\"Description\":\"Description 04\"},' +\n    '{\"Description\":\"Description 05\"}' + ']' + '}';\n\n  NESTED_JSON = '{' + '\"Code\":1,' + '\"Description\":\"General Description\",' + '\"Items\":[' + '{' + '\"Code\":10,' +\n    '\"Description\":\"Item_01\",' + '\"Items\":[' + '{\"Description\":\"Description 01\"}' + ']' + '},' + '{' + '\"Code\":11,' +\n    '\"Description\":\"Item_02\",' + '\"Items\":[' + '{\"Description\":\"Description 02\"}' + ']' + '},' + '{' + '\"Code\":12,' +\n    '\"Description\":\"Item_03\",' + '\"Items\":[' + '{\"Description\":\"Description 03\"}' + ']' + '}' + ']' + '}';\nvar\n  LGenericEntity: TGenericEntity<TNote>;\n  LNestedGenericEntity: TNestedGenericEntity;\n  LJson: string;\nbegin\n  LGenericEntity := TGenericEntity<TNote>.Create;\n  try\n    LGenericEntity.Code := 1;\n    LGenericEntity.Description := 'General Description';\n\n    LGenericEntity.Items.Add(TNote.Create('Description 01'));\n    LGenericEntity.Items.Add(TNote.Create('Description 02'));\n    LGenericEntity.Items.Add(TNote.Create('Description 03'));\n    LGenericEntity.Items.Add(TNote.Create('Description 04'));\n    LGenericEntity.Items.Add(TNote.Create('Description 05'));\n\n    LJson := fSerializer.SerializeObject(LGenericEntity);\n\n    Assert.areEqual(JSON, LJson);\n  finally\n    LGenericEntity.Free;\n  end;\n\n  LGenericEntity := TGenericEntity<TNote>.Create;\n  try\n    fSerializer.DeserializeObject(LJson, LGenericEntity);\n\n    Assert.areEqual(Integer(1), LGenericEntity.Code);\n    Assert.areEqual('General Description', LGenericEntity.Description);\n    Assert.areEqual<Integer>(5, LGenericEntity.Items.Count);\n    Assert.areEqual('Description 01', LGenericEntity.Items[0].Description);\n    Assert.areEqual('Description 02', LGenericEntity.Items[1].Description);\n    Assert.areEqual('Description 03', LGenericEntity.Items[2].Description);\n    Assert.areEqual('Description 04', LGenericEntity.Items[3].Description);\n    Assert.areEqual('Description 05', LGenericEntity.Items[4].Description);\n\n  finally\n    LGenericEntity.Free;\n  end;\n\n  LNestedGenericEntity := TNestedGenericEntity.Create;\n  try\n    LNestedGenericEntity.Code := 1;\n    LNestedGenericEntity.Description := 'General Description';\n\n    LGenericEntity := TGenericEntity<TNote>.Create;\n    LGenericEntity.Code := 10;\n    LGenericEntity.Description := 'Item_01';\n    LGenericEntity.Items.Add(TNote.Create('Description 01'));\n    LNestedGenericEntity.Items.Add(LGenericEntity);\n\n    LGenericEntity := TGenericEntity<TNote>.Create;\n    LGenericEntity.Code := 11;\n    LGenericEntity.Description := 'Item_02';\n    LGenericEntity.Items.Add(TNote.Create('Description 02'));\n    LNestedGenericEntity.Items.Add(LGenericEntity);\n\n    LGenericEntity := TGenericEntity<TNote>.Create;\n    LGenericEntity.Code := 12;\n    LGenericEntity.Description := 'Item_03';\n    LGenericEntity.Items.Add(TNote.Create('Description 03'));\n    LNestedGenericEntity.Items.Add(LGenericEntity);\n\n    LJson := fSerializer.SerializeObject(LNestedGenericEntity);\n\n    Assert.areEqual(NESTED_JSON, LJson);\n  finally\n    LNestedGenericEntity.Free;\n  end;\n\n  LNestedGenericEntity := TNestedGenericEntity.Create;;\n  try\n    fSerializer.DeserializeObject(LJson, LNestedGenericEntity);\n\n    Assert.areEqual(Integer(1), LNestedGenericEntity.Code);\n    Assert.areEqual('General Description', LNestedGenericEntity.Description);\n    Assert.areEqual<Integer>(Integer(3), LNestedGenericEntity.Items.Count);\n\n    Assert.areEqual<Integer>(Integer(10), LNestedGenericEntity.Items[0].Code);\n    Assert.areEqual('Item_01', LNestedGenericEntity.Items[0].Description);\n    Assert.areEqual<Integer>(Integer(1), LNestedGenericEntity.Items[0].Items.Count);\n    Assert.areEqual('Description 01', LNestedGenericEntity.Items[0].Items[0].Description);\n\n    Assert.areEqual<Integer>(Integer(11), LNestedGenericEntity.Items[1].Code);\n    Assert.areEqual('Item_02', LNestedGenericEntity.Items[1].Description);\n    Assert.areEqual<Integer>(Integer(1), LNestedGenericEntity.Items[1].Items.Count);\n    Assert.areEqual('Description 02', LNestedGenericEntity.Items[1].Items[0].Description);\n\n    Assert.areEqual<Integer>(Integer(12), LNestedGenericEntity.Items[2].Code);\n    Assert.areEqual('Item_03', LNestedGenericEntity.Items[2].Description);\n    Assert.areEqual<Integer>(Integer(1), LNestedGenericEntity.Items[2].Items.Count);\n    Assert.areEqual('Description 03', LNestedGenericEntity.Items[2].Items[0].Description);\n\n  finally\n    LNestedGenericEntity.Free;\n  end;\n\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeserializeGuid;\nconst\n  JSON = '{' + '\"GuidValue\":\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\",' +\n    '\"GuidValue2\":\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\",' +\n    '\"NullableGuid\":\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\",' +\n    '\"NullableGuid2\":\"fa51caa7-7d48-46ba-bfde-34c1f740e066\",' +\n    '\"Id\":1,' + '\"Code\":2,' +\n    '\"Name\":\"Jo\ufffdo Ant\ufffdnio\"' + '}';\nvar\n  LEntity: TEntityCustomWithGuid;\n  LJson: string;\nbegin\n  LEntity := TEntityCustomWithGuid.Create;\n  try\n    LEntity.Id := 1;\n    LEntity.Code := 2;\n    LEntity.Name := 'Jo\ufffdo Ant\ufffdnio';\n    LEntity.GuidValue := StringToGUID('{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}');\n    LEntity.GuidValue2 := StringToGUID('{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}');\n    LEntity.NullableGuid := StringToGUID('{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}');\n    LEntity.NullableGuid2 := StringToGUID('{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}');\n\n    LJson := fSerializer.SerializeObject(LEntity);\n    Assert.AreEqual(JSON, LJson);\n  finally\n    LEntity.Free;\n  end;\n\n  LEntity := TEntityCustomWithGuid.Create;\n  try\n    fSerializer.DeserializeObject(LJson, LEntity);\n    Assert.AreEqual(int64(1), LEntity.Id);\n    Assert.AreEqual(Integer(2), LEntity.Code);\n    Assert.AreEqual('Jo\ufffdo Ant\ufffdnio', LEntity.Name);\n    Assert.AreEqual(StringToGUID('{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}'), LEntity.GuidValue);\n    Assert.AreEqual(StringToGUID('{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}'), LEntity.GuidValue2);\n    Assert.AreEqual(StringToGUID('{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}'), LEntity.NullableGuid.Value);\n    Assert.AreEqual(StringToGUID('{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}'), LEntity.NullableGuid2.Value);\n  finally\n    LEntity.Free;\n  end;\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeDeserializeMultipleGenericEntity;\nconst\n  JSON = '{' + '\"Code\":1,' + '\"Description\":\"General Description\",' + '\"Items\":[' + '{\"Description\":\"Description 01\"},'\n    + '{\"Description\":\"Description 02\"},' + '{\"Description\":\"Description 03\"},' + '{\"Description\":\"Description 04\"},' +\n    '{\"Description\":\"Description 05\"}' + '],' + '\"Items2\":[' + '{\"Description\":\"Description2 01\"},' +\n    '{\"Description\":\"Description2 02\"},' + '{\"Description\":\"Description2 03\"},' + '{\"Description\":\"Description2 04\"},' +\n    '{\"Description\":\"Description2 05\"}' + ']' + '}';\nvar\n  LGenericEntity: TMultipleGenericEntity<TNote, TNote>;\n  LJson: string;\nbegin\n  LGenericEntity := TMultipleGenericEntity<TNote, TNote>.Create;\n  try\n    LGenericEntity.Code := 1;\n    LGenericEntity.Description := 'General Description';\n\n    LGenericEntity.Items.Add(TNote.Create('Description 01'));\n    LGenericEntity.Items.Add(TNote.Create('Description 02'));\n    LGenericEntity.Items.Add(TNote.Create('Description 03'));\n    LGenericEntity.Items.Add(TNote.Create('Description 04'));\n    LGenericEntity.Items.Add(TNote.Create('Description 05'));\n\n    LGenericEntity.Items2.Add(TNote.Create('Description2 01'));\n    LGenericEntity.Items2.Add(TNote.Create('Description2 02'));\n    LGenericEntity.Items2.Add(TNote.Create('Description2 03'));\n    LGenericEntity.Items2.Add(TNote.Create('Description2 04'));\n    LGenericEntity.Items2.Add(TNote.Create('Description2 05'));\n\n    LJson := fSerializer.SerializeObject(LGenericEntity);\n\n    Assert.areEqual(JSON, LJson);\n  finally\n    LGenericEntity.Free;\n  end;\n\n  LGenericEntity := TMultipleGenericEntity<TNote, TNote>.Create;\n  try\n    fSerializer.DeserializeObject(LJson, LGenericEntity);\n\n    Assert.areEqual(Integer(1), LGenericEntity.Code);\n    Assert.areEqual('General Description', LGenericEntity.Description);\n\n    Assert.areEqual<Integer>(Integer(5), LGenericEntity.Items.Count);\n    Assert.areEqual('Description 01', LGenericEntity.Items[0].Description);\n    Assert.areEqual('Description 02', LGenericEntity.Items[1].Description);\n    Assert.areEqual('Description 03', LGenericEntity.Items[2].Description);\n    Assert.areEqual('Description 04', LGenericEntity.Items[3].Description);\n    Assert.areEqual('Description 05', LGenericEntity.Items[4].Description);\n\n    Assert.areEqual<Integer>(Integer(5), LGenericEntity.Items2.Count);\n    Assert.areEqual('Description2 01', LGenericEntity.Items2[0].Description);\n    Assert.areEqual('Description2 02', LGenericEntity.Items2[1].Description);\n    Assert.areEqual('Description2 03', LGenericEntity.Items2[2].Description);\n    Assert.areEqual('Description2 04', LGenericEntity.Items2[3].Description);\n    Assert.areEqual('Description2 05', LGenericEntity.Items2[4].Description);\n\n  finally\n    LGenericEntity.Free;\n  end;\n\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestSerializeNil;\nbegin\n  Assert.areEqual('null', fSerializer.SerializeObject(nil));\nend;\n\nprocedure TMVCTestSerializerJsonDataObjects.TestStringDictionary;\nvar\n  lDict: TMVCStringDictionary;\n  lSerString: string;\n  lDict2: TMVCStringDictionary;\n  lEntityDict: TEntityWithStringDictionary;\n  lEntityDict2: TEntityWithStringDictionary;\nbegin\n  lDict := TMVCStringDictionary.Create;\n  try\n    lDict['prop1'] := 'value1';\n    lDict['prop2'] := 'value2';\n    lDict['prop3'] := 'value3';\n    lSerString := fSerializer.SerializeObject(lDict);\n    lDict2 := TMVCStringDictionary.Create;\n    try\n      fSerializer.DeserializeObject(lSerString, lDict2);\n      Assert.isTrue(lDict2.ContainsKey('prop1'));\n      Assert.isTrue(lDict2.ContainsKey('prop2'));\n      Assert.isTrue(lDict2.ContainsKey('prop3'));\n      Assert.areEqual(lDict['prop1'], lDict2['prop1']);\n      Assert.areEqual(lDict['prop2'], lDict2['prop2']);\n      Assert.areEqual(lDict['prop3'], lDict2['prop3']);\n    finally\n      lDict2.Free;\n    end;\n  finally\n    lDict.Free;\n  end;\n\n  lEntityDict := TEntityWithStringDictionary.Create;\n  try\n    lEntityDict.Dict['prop1'] := 'value1';\n    lEntityDict.Dict['prop2'] := 'value2';\n    lEntityDict.Dict['prop3'] := 'value3';\n    lSerString := fSerializer.SerializeObject(lEntityDict);\n\n    lEntityDict2 := TEntityWithStringDictionary.Create;\n    try\n      fSerializer.DeserializeObject(lSerString, lEntityDict2);\n      Assert.isTrue(lEntityDict2.Dict.ContainsKey('prop1'));\n      Assert.isTrue(lEntityDict2.Dict.ContainsKey('prop2'));\n      Assert.isTrue(lEntityDict2.Dict.ContainsKey('prop3'));\n      Assert.areEqual(lEntityDict.Dict['prop1'], lEntityDict2.Dict['prop1']);\n      Assert.areEqual(lEntityDict.Dict['prop2'], lEntityDict2.Dict['prop2']);\n      Assert.areEqual(lEntityDict.Dict['prop3'], lEntityDict2.Dict['prop3']);\n    finally\n      lEntityDict2.Free;\n    end;\n  finally\n    lEntityDict.Free;\n  end;\nend;\n\n{ TMVCEntityCustomSerializerJsonDataObjects }\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.Deserialize(const ASerializedObject: TObject;\n  var AElementValue: TValue; const AAttributes: TArray<TCustomAttribute>);\nvar\n  JsonObject: TJsonObject;\n  EntityCustom: TEntityCustom;\nbegin\n  JsonObject := ASerializedObject as TJsonObject;\n  if Assigned(JsonObject) then\n  begin\n    EntityCustom := AElementValue.AsObject as TEntityCustom;\n    if Assigned(EntityCustom) then\n    begin\n      EntityCustom.Id := JsonObject['AId'].LongValue;\n      EntityCustom.Code := JsonObject['ACode'].IntValue;\n      EntityCustom.Name := JsonObject['AName'].Value;\n    end;\n  end;\nend;\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string; const ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n  DeserializeRoot(ASerializerObject, AElementValue.AsObject, AAttributes);\nend;\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nvar\n  LEntity: TEntityCustom;\n  LJson: TJDOJsonObject;\n  lAttr: TCustomAttribute;\n  lAsLowerCase: Boolean;\nbegin\n  LEntity := TEntityCustom(AObject);\n  LJson := ASerializerObject as TJDOJsonObject;\n  lAsLowerCase := False;\n  for lAttr in AAttributes do\n  begin\n    if lAttr is MVCNameCaseAttribute then\n    begin\n      lAsLowerCase := MVCNameCaseAttribute(lAttr).KeyCase = ncLowerCase;\n      break;\n    end;\n  end;\n\n  if lAsLowerCase then\n  begin\n    LEntity.Id := LJson.I['id'];\n    LEntity.Code := LJson.I['code'];\n    LEntity.Name := LJson.S['name'];\n  end\n  else\n  begin\n    // as is (upper case is not supported by the custom type serializer)\n    LEntity.Id := LJson.I['Id'];\n    LEntity.Code := LJson.I['Code'];\n    LEntity.Name := LJson.S['Name'];\n  end;\nend;\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.Serialize(const AElementValue: TValue;\n  var ASerializerObject: TObject; const AAttributes: TArray<TCustomAttribute>);\nvar\n  EntityCustom: TEntityCustom;\nbegin\n  EntityCustom := AElementValue.AsObject as TEntityCustom;\n  if Assigned(EntityCustom) then\n  begin\n    ASerializerObject := TJsonObject.Create;\n    TJsonObject(ASerializerObject).L['AId'] := EntityCustom.Id;\n    TJsonObject(ASerializerObject).I['ACode'] := EntityCustom.Code;\n    TJsonObject(ASerializerObject).S['AName'] := EntityCustom.Name;\n  end;\nend;\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string; const ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nvar\n  lEntityCustom: TEntityCustom;\nbegin\n  lEntityCustom := AElementValue.AsObject as TEntityCustom;\n  if Assigned(lEntityCustom) then\n  begin\n    TJsonObject(ASerializerObject).O[APropertyName].L['AId'] := lEntityCustom.Id;\n    TJsonObject(ASerializerObject).O[APropertyName].I['ACode'] := lEntityCustom.Code;\n    TJsonObject(ASerializerObject).O[APropertyName].S['AName'] := lEntityCustom.Name;\n  end\n  else\n  begin\n    TJsonObject(ASerializerObject).Values[APropertyName] := nil;\n  end;\nend;\n\nprocedure TMVCEntityCustomSerializerJsonDataObjects.SerializeRoot(const AObject: TObject;\n  out ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nvar\n  lEntityCustom: TEntityCustom;\nbegin\n  ASerializerObject := nil;\n  lEntityCustom := AObject as TEntityCustom;\n  if Assigned(lEntityCustom) then\n  begin\n    ASerializerObject := TJsonObject.Create;\n    TJsonObject(ASerializerObject).L['AId'] := lEntityCustom.Id;\n    TJsonObject(ASerializerObject).I['ACode'] := lEntityCustom.Code;\n    TJsonObject(ASerializerObject).S['AName'] := lEntityCustom.Name;\n  end;\nend;\n\n{ TMVCNullableIntegerSerializerJsonDataObjects }\n\nprocedure TMVCNullableIntegerSerializerJsonDataObjects.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string; const ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TMVCNullableIntegerSerializerJsonDataObjects.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TMVCNullableIntegerSerializerJsonDataObjects.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string; const ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TMVCNullableIntegerSerializerJsonDataObjects.SerializeRoot(const AObject: TObject;\n  out ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nbegin\n\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TMVCTestSerializerJsonDataObjects);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Globalization;\nusing NUnit.Framework;\nusing MVCFramework.Serializer.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.JsonDataObjects;\nusing MVCFramework.Tests.Serializer.Intf;\nusing MVCFramework.Tests.Serializer.Entities;\nusing MVCFramework.Tests.Serializer.EntitiesModule;\nusing JsonDataObjects;\nusing MVCFramework.DataSet.Utils;\n\nnamespace MVCFramework.Tests.Serializer\n{\n    [TestFixture]\n    public class MVCTestSerializerJsonDataObjects\n    {\n        private IMVCSerializer fSerializer;\n\n        [OneTimeSetUp]\n        public void SetupFixture()\n        {\n            CultureInfo.CurrentCulture = new CultureInfo(\"en-GB\");\n            CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern = \"dd/MM/yyyy\";\n            CultureInfo.CurrentCulture.DateTimeFormat.DateSeparator = \"/\";\n            CultureInfo.CurrentCulture.DateTimeFormat.TimeSeparator = \":\";\n        }\n\n        [SetUp]\n        public void Setup()\n        {\n            fSerializer = new TMVCJsonDataObjectsSerializer();\n            fSerializer.RegisterTypeSerializer(typeof(Stream), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(StringReader), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(MemoryStream), new TMVCStreamSerializerJsonDataObject());\n            fSerializer.RegisterTypeSerializer(typeof(EntityCustom), new TMVCEntityCustomSerializerJsonDataObjects());\n            fSerializer.RegisterTypeSerializer(typeof(TMVCNullable<int>), new TMVCNullableIntegerSerializerJsonDataObjects());\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            fSerializer = null;\n        }\n\n        [Test]\n        public void TestDataSetHelpers()\n        {\n            TEntitiesModule dm = new TEntitiesModule(null);\n            try\n            {\n                dm.Entity.Insert();\n                dm.EntityId.AsLargeInt = 1;\n                dm.EntityCode.AsInteger = 2;\n                dm.EntityName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityBirthday.AsDateTime = DateTime.ParseExact(\"15/10/1987\", \"dd/MM/yyyy\", CultureInfo.InvariantCulture);\n                dm.EntityAccessDateTime.AsDateTime = DateTime.Parse(\"17/02/2017 16:37:50\");\n                dm.EntityAccessTime.AsDateTime = DateTime.ParseExact(\"16:40:50\", \"HH:mm:ss\", CultureInfo.InvariantCulture);\n                dm.EntityActive.AsBoolean = true;\n                dm.EntitySalary.AsCurrency = 100;\n                dm.EntityAmount.AsFloat = 100;\n                dm.EntityBlobFld.AsString = \"<html><body><h1>BLOB</h1></body></html>\";\n                dm.EntityGUID.AsGuid = Guid.Parse(\"{9386C957-5379-4370-8492-8FA464A9CF0C}\");\n\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 1;\n                dm.ItemName.AsString = \"Ezequiel\";\n                dm.Item.Post();\n\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 2;\n                dm.ItemName.AsString = \"Juliano\";\n                dm.Item.Post();\n\n                dm.Departament.Insert();\n                dm.DepartamentName.AsString = \"Depto1\";\n                dm.Departament.Post();\n\n                string s = dm.Entity.AsJSONObject(MVCNameCaseDefault.ncAsIs, new List<string> { \"Ignored\" });\n                Assert.AreEqual(\"{\\\"Id\\\":1,\\\"Code\\\":2,\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\",\\\"Salary\\\":100.0,\\\"Birthday\\\":\\\"1987-10-15\\\",\\\"AccessDateTime\\\":\\\"2017-02-17T16:37:50.000+01:00\\\",\\\"AccessTime\\\":\\\"16:40:50\\\",\\\"Active\\\":true,\\\"Amount\\\":100.0,\\\"BlobFld\\\":\\\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\\\",\\\"GUID\\\":\\\"{9386C957-5379-4370-8492-8FA464A9CF0C}\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncAsIs);\n                Assert.AreEqual(\"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncUpperCase);\n                Assert.AreEqual(\"{\\\"ID\\\":1,\\\"NAME\\\":\\\"Ezequiel\\\"}\", s);\n                dm.Item.First();\n                s = dm.Item.AsJSONObject(MVCNameCaseDefault.ncLowerCase);\n                Assert.AreEqual(\"{\\\"id\\\":1,\\\"name\\\":\\\"ezequiel\\\"}\", s);\n            }\n            finally\n            {\n                dm.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestDeserializeCollection()\n        {\n            void CheckObjectList(IList<TNote> list)\n            {\n                Assert.IsTrue(list.Count == 4);\n                Assert.IsTrue(list[0].Description == \"Description 1\");\n                Assert.IsTrue(list[1].Description == \"Description 2\");\n                Assert.IsTrue(list[2].Description == \"Description 3\");\n                Assert.IsTrue(list[3].Description == \"Description 4\");\n            }\n            const string JSON_PROPERTIES = \"[{\\\"Description\\\":\\\"Description 1\\\"},{\\\"Description\\\":\\\"Description 2\\\"},{\\\"Description\\\":\\\"Description 3\\\"},{\\\"Description\\\":\\\"Description 4\\\"}]\";\n            const string JSON_FIELDS = \"[{\\\"FDescription\\\":\\\"Description 1\\\"},{\\\"FDescription\\\":\\\"Description 2\\\"},{\\\"FDescription\\\":\\\"Description 3\\\"},{\\\"FDescription\\\":\\\"Description 4\\\"}]\";\n            var list1 = new List<TNote>();\n            fSerializer.DeserializeCollection(JSON_PROPERTIES, list1, typeof(TNote));\n            CheckObjectList(list1);\n            var list2 = new List<TNote>();\n            fSerializer.DeserializeCollection(JSON_FIELDS, list2, typeof(TNote), TMVCSerializationType.stFields);\n            CheckObjectList(list2);\n        }\n\n        [Test]\n        public void TestDeserializeDataSet()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\",\" +\n                \"\\\"Salary\\\":100.0,\" +\n                \"\\\"Birthday\\\":\\\"1987-10-15\\\",\" +\n                \"\\\"AccessDateTime\\\":\\\"2017-02-17 16:37:50\\\",\" +\n                \"\\\"AccessTime\\\":\\\"16:40:50\\\",\" +\n                \"\\\"Active\\\":true,\" +\n                \"\\\"Amount\\\":100.0,\" +\n                \"\\\"BlobFld\\\":\\\"PGh0bWw+PGJvZHk+PGgxPkJMT0I8L2gxPjwvYm9keT48L2h0bWw+\\\",\" +\n                \"\\\"Items\\\":[{\\\"Id\\\":1,\\\"Name\\\":\\\"Ezequiel\\\"},{\\\"Id\\\":2,\\\"Name\\\":\\\"Juliano\\\"}],\" +\n                \"\\\"Departament\\\":{\\\"Name\\\":\\\"Depto1\\\"},\" +\n                \"\\\"GUID\\\":\\\"{9386C957-5379-4370-8492-8FA464A9CF0C}\\\"\" +\n                \"}\";\n            const string JSON_LOWERCASE = \"{\\\"id\\\":1,\\\"name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_UPPERCASE = \"{\\\"ID\\\":1,\\\"NAME\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_ASIS = \"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\";\n            const string JSON_LIST = \"[\" +\n                \"{\\\"Id_Id\\\":1,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"},\" +\n                \"{\\\"Id_Id\\\":2,\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"}\" +\n                \"]\";\n            var dm = new TEntitiesModule(null);\n            try\n            {\n                dm.Entity.Insert();\n                dm.EntityId.AsLargeInt = 1;\n                dm.EntityCode.AsInteger = 2;\n                dm.EntityName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityBirthday.AsDateTime = DateTime.ParseExact(\"15/10/1987\", \"dd/MM/yyyy\", CultureInfo.InvariantCulture);\n                dm.EntityAccessDateTime.AsDateTime = DateTime.Parse(\"17/02/2017 16:37:50\");\n                dm.EntityAccessTime.AsDateTime = DateTime.ParseExact(\"16:40:50\", \"HH:mm:ss\", CultureInfo.InvariantCulture);\n                dm.EntityActive.AsBoolean = true;\n                dm.EntitySalary.AsCurrency = 100;\n                dm.EntityAmount.AsFloat = 100;\n                dm.EntityBlobFld.AsString = \"<html><body><h1>BLOB</h1></body></html>\";\n                dm.EntityGUID.AsGuid = Guid.Parse(\"{9386C957-5379-4370-8492-8FA464A9CF0C}\");\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 1;\n                dm.ItemName.AsString = \"Ezequiel\";\n                dm.Item.Post();\n                dm.Item.Insert();\n                dm.ItemId.AsLargeInt = 2;\n                dm.ItemName.AsString = \"Juliano\";\n                dm.Item.Post();\n                dm.Departament.Insert();\n                dm.DepartamentName.AsString = \"Depto1\";\n                dm.Departament.Post();\n                dm.Entity.Post();\n                string s = fSerializer.SerializeDataSetRecord(dm.Entity, new List<string> { \"Ignored\" });\n                Assert.AreEqual(JSON, s);\n                dm.EntityLowerCase.Insert();\n                dm.EntityLowerCaseId.AsLargeInt = 1;\n                dm.EntityLowerCaseName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityLowerCase.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityLowerCase);\n                Assert.AreEqual(JSON_LOWERCASE, s);\n                dm.EntityUpperCase.Insert();\n                dm.EntityUpperCaseId.AsLargeInt = 1;\n                dm.EntityUpperCaseName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityUpperCase.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityUpperCase);\n                Assert.AreEqual(JSON_UPPERCASE, s);\n                dm.EntityUpperCase2.Insert();\n                dm.EntityUpperCase2Id.AsLargeInt = 1;\n                dm.EntityUpperCase2Name.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityUpperCase2.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityUpperCase2, new List<string>(), MVCNameCaseDefault.ncUpperCase);\n                Assert.AreEqual(JSON_UPPERCASE, s);\n                dm.EntityAsIs.Insert();\n                dm.EntityAsIsId.AsLargeInt = 1;\n                dm.EntityAsIsName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityAsIs.Post();\n                s = fSerializer.SerializeDataSetRecord(dm.EntityAsIs);\n                Assert.AreEqual(JSON_ASIS, s);\n                dm.EntityAsIs.Append();\n                dm.EntityAsIsId.AsLargeInt = 2;\n                dm.EntityAsIsName.AsString = \"Ezequiel Juliano M\u00fcller\";\n                dm.EntityAsIs.Post();\n                s = fSerializer.SerializeDataSet(dm.EntityAsIs);\n                Assert.AreEqual(JSON_LIST, s);\n                s = fSerializer.SerializeObject(dm.EntityAsIs);\n                Assert.AreEqual(JSON_LIST, s);\n            }\n            finally\n            {\n                dm.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDateTimeProperty()\n        {\n            TMyObjectWithUTC obj1 = new TMyObjectWithUTC();\n            try\n            {\n                obj1.MyDateTime = new DateTime(2020, 11, 4, 12, 12, 12, 0);\n                string ser = fSerializer.SerializeObject(obj1);\n                TMyObjectWithUTC obj2 = new TMyObjectWithUTC();\n                try\n                {\n                    fSerializer.DeserializeObject(ser, obj2);\n                    Assert.IsTrue(obj1.Equals(obj2));\n                }\n                finally\n                {\n                    obj2.Dispose();\n                }\n            }\n            finally\n            {\n                obj1.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithEnums()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Daniele Teti\\\",\" +\n                \"\\\"Color\\\":\\\"RED\\\",\" +\n                \"\\\"MonthName\\\":\\\"January\\\",\" +\n                \"\\\"MonthName2\\\":\\\"meFebruary\\\",\" +\n                \"\\\"MonthOrder\\\":0\" +\n                \"}\";\n            TEntityWithEnums o = new TEntityWithEnums();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Daniele Teti\";\n                o.Color = TColorEnum.RED;\n                o.MonthName = TMonthEnum.meJanuary;\n                o.MonthName2 = TMonthEnum.meFebruary;\n                o.MonthOrder = TMonthEnum.meJanuary;\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n            o = new TEntityWithEnums();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, o);\n                Assert.AreEqual(1, o.Id);\n                Assert.AreEqual(2, o.Code);\n                Assert.AreEqual(\"Daniele Teti\", o.Name);\n                Assert.AreEqual((int)TMonthEnum.meJanuary, (int)o.MonthName);\n                Assert.AreEqual((int)TMonthEnum.meFebruary, (int)o.MonthName2);\n                Assert.AreEqual((int)TMonthEnum.meJanuary, (int)o.MonthOrder);\n                Assert.AreEqual((int)TColorEnum.RED, (int)o.Color);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityCustomMemberSerializer()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Entity\\\":{\" +\n                \"\\\"AId\\\":1,\" +\n                \"\\\"ACode\\\":2,\" +\n                \"\\\"AName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"},\" +\n                \"\\\"Notes\\\":\\\"RXplcXVpZWwgSnVsaWFubyBN/GxsZXI=\\\",\" +\n                \"\\\"NotesAsString\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TSale o = new TSale();\n            try\n            {\n                o.Entity.Id = 1;\n                o.Entity.Code = 2;\n                o.Entity.Name = \"Ezequiel Juliano M\u00fcller\";\n                o.Notes.WriteString(\"Ezequiel Juliano M\u00fcller\");\n                o.NotesAsString.WriteString(\"Ezequiel Juliano M\u00fcller\");\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityCustomSerializer()\n        {\n            const string JSON = \"{\" +\n                \"\\\"AId\\\":1,\" +\n                \"\\\"ACode\\\":2,\" +\n                \"\\\"AName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityCustom o = new TEntityCustom();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityLowerCaseNames()\n        {\n            const string JSON = \"{\" +\n                \"\\\"id\\\":1,\" +\n                \"\\\"code\\\":2,\" +\n                \"\\\"name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityLowerCase o = new TEntityLowerCase();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityNameAs()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id_Id\\\":1,\" +\n                \"\\\"Code_Code\\\":2,\" +\n                \"\\\"Name_Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityNameAs o = new TEntityNameAs();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n                s = fSerializer.SerializeObject(o, TMVCSerializationType.stFields);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntitySerializationType()\n        {\n            const string JSON_FIELDS = \"{\" +\n                \"\\\"FId\\\":1,\" +\n                \"\\\"FCode\\\":2,\" +\n                \"\\\"FName\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            const string JSON_PROPERTIES = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntitySerializeFields oFields = new TEntitySerializeFields();\n            try\n            {\n                oFields.Id = 1;\n                oFields.Code = 2;\n                oFields.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(oFields);\n                Assert.AreEqual(JSON_FIELDS, s);\n            }\n            finally\n            {\n                oFields.Dispose();\n            }\n            TEntitySerializeProperties oProperties = new TEntitySerializeProperties();\n            try\n            {\n                oProperties.Id = 1;\n                oProperties.Code = 2;\n                oProperties.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(oProperties);\n                Assert.AreEqual(JSON_PROPERTIES, s);\n            }\n            finally\n            {\n                oProperties.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityUpperCaseNames()\n        {\n            const string JSON = \"{\" +\n                \"\\\"ID\\\":1,\" +\n                \"\\\"CODE\\\":2,\" +\n                \"\\\"NAME\\\":\\\"Ezequiel Juliano M\u00fcller\\\"\" +\n                \"}\";\n            TEntityUpperCase o = new TEntityUpperCase();\n            try\n            {\n                o.Id = 1;\n                o.Code = 2;\n                o.Name = \"Ezequiel Juliano M\u00fcller\";\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeEntityWithArray()\n        {\n            const string JSON_WITH_ARRAY = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Names\\\":[\\\"Pedro\\\",\\\"Oliveira\\\"],\" +\n                \"\\\"Values\\\":[1,2],\" +\n                \"\\\"Values8\\\":[7,8],\" +\n                \"\\\"Values64\\\":[3,4],\" +\n                \"\\\"Booleans\\\":[true,false,true]\" +\n                \"}\";\n            TEntityWithArray o = new TEntityWithArray();\n            try\n            {\n                o.Id = 1;\n                o.Names = new string[] { \"Pedro\", \"Oliveira\" };\n                o.Values = new int[] { 1, 2 };\n                o.Values8 = new byte[] { 7, 8 };\n                o.Values64 = new long[] { 3, 4 };\n                o.Booleans = new bool[] { true, false, true };\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(JSON_WITH_ARRAY, s);\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListOfSomething()\n        {\n            TListOfSomething list = new TListOfSomething();\n            try\n            {\n                string s = fSerializer.SerializeObject(list);\n                Assert.AreEqual(\"[\" +\n                    \"{\\\"Description\\\":\\\"Description 1\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 2\\\"}\" +\n                    \"]\", s);\n                s = fSerializer.SerializeObject(list, TMVCSerializationType.stFields);\n                Assert.AreEqual(\"[\" +\n                    \"{\\\"FDescription\\\":\\\"Description 1\\\"},\" +\n                    \"{\\\"FDescription\\\":\\\"Description 2\\\"}\" +\n                    \"]\", s);\n            }\n            finally\n            {\n                list.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListWithNulls()\n        {\n            TPeople people = new TPeople();\n            try\n            {\n                TPerson person = new TPerson();\n                person.Id = 1;\n                person.FirstName = \"Daniele\";\n                person.LastName = \"Teti\";\n                people.Add(person);\n                people.Add(null);\n                string s = fSerializer.SerializeObject(people);\n                JsonObject jObj = JsonObject.Parse(s) as JsonObject;\n                Assert.IsFalse(jObj.A(\"List\").Items[0].IsNull);\n                Assert.IsTrue(jObj.A(\"List\").Items[1].IsNull);\n            }\n            finally\n            {\n                people.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeListWithNulls2()\n        {\n            TPeople people = new TPeople();\n            try\n            {\n                TPerson person = new TPerson();\n                person.Id = 1;\n                person.FirstName = \"Daniele\";\n                person.LastName = \"Teti\";\n                people.Add(person);\n                people.Add(null);\n                string s = fSerializer.SerializeCollection(people);\n                JsonArray jArr = JsonObject.Parse(s) as JsonArray;\n                Assert.IsFalse(jArr.Items[0].IsNull);\n                Assert.IsTrue(jArr.Items[1].IsNull);\n            }\n            finally\n            {\n                people.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                \"\\\"Code\\\":10,\" +\n                \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7D48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46ba-bfde-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46ba-bfde-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestStringDictionary()\n        {\n            TMVCStringDictionary dict = new TMVCStringDictionary();\n            try\n            {\n                dict[\"prop1\"] = \"value1\";\n                dict[\"prop2\"] = \"value2\";\n                dict[\"prop3\"] = \"value3\";\n                string s = fSerializer.SerializeObject(dict);\n                TMVCStringDictionary dict2 = new TMVCStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(s, dict2);\n                    Assert.IsTrue(dict2.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(dict2.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(dict[\"prop1\"], dict2[\"prop1\"]);\n                    Assert.AreEqual(dict[\"prop2\"], dict2[\"prop2\"]);\n                    Assert.AreEqual(dict[\"prop3\"], dict2[\"prop3\"]);\n                }\n                finally\n                {\n                    dict2.Dispose();\n                }\n            }\n            finally\n            {\n                dict.Dispose();\n            }\n            TEntityWithStringDictionary entityDict = new TEntityWithStringDictionary();\n            try\n            {\n                entityDict.Dict[\"prop1\"] = \"value1\";\n                entityDict.Dict[\"prop2\"] = \"value2\";\n                entityDict.Dict[\"prop3\"] = \"value3\";\n                string sEntity = fSerializer.SerializeObject(entityDict);\n                TEntityWithStringDictionary entityDict2 = new TEntityWithStringDictionary();\n                try\n                {\n                    fSerializer.DeserializeObject(sEntity, entityDict2);\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop1\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop2\"));\n                    Assert.IsTrue(entityDict2.Dict.ContainsKey(\"prop3\"));\n                    Assert.AreEqual(entityDict.Dict[\"prop1\"], entityDict2.Dict[\"prop1\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop2\"], entityDict2.Dict[\"prop2\"]);\n                    Assert.AreEqual(entityDict.Dict[\"prop3\"], entityDict2.Dict[\"prop3\"]);\n                }\n                finally\n                {\n                    entityDict2.Dispose();\n                }\n            }\n            finally\n            {\n                entityDict.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeEntityWithInterface()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio Duarte\\\",\" +\n                \"\\\"ChildEntity\\\":{\" +\n                    \"\\\"Code\\\":10,\" +\n                    \"\\\"Description\\\":\\\"Child Entity\\\"\" +\n                \"}\" +\n                \"}\";\n            IEntityWithInterface entity = new EntityWithInterface();\n            entity.Id = 1;\n            entity.Name = \"Jo\u00e3o Ant\u00f4nio Duarte\";\n            entity.ChildEntity.Code = 10;\n            entity.ChildEntity.Description = \"Child Entity\";\n            string json = fSerializer.SerializeObject(entity);\n            Assert.AreEqual(JSON, json);\n            entity = new EntityWithInterface();\n            fSerializer.DeserializeObject(json, entity);\n            Assert.AreEqual(1, entity.Id);\n            Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio Duarte\", entity.Name);\n            Assert.AreEqual(10, entity.ChildEntity.Code);\n            Assert.AreEqual(\"Child Entity\", entity.ChildEntity.Description);\n        }\n\n        [Test]\n        public void TestSerializeDeSerializeEntityWithSet()\n        {\n            const string O1 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meMarch\\\",\\\"ColorsSet\\\":\\\"\\\"}\";\n            const string O2 = \"{\\\"MonthsSet\\\":\\\"\\\",\\\"ColorsSet\\\":\\\"RED\\\"}\";\n            const string O3 = \"{\\\"MonthsSet\\\":\\\"meJanuary,meFebruary,meMarch\\\",\\\"ColorsSet\\\":\\\"RED,GREEN,BLUE\\\"}\";\n            TEntityWithSets o = new TEntityWithSets();\n            try\n            {\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch };\n                o.ColorsSet = new HashSet<TColorEnum>();\n                string s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O1, s);\n                TEntityWithSets oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum>(), oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum>();\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O2, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum>(), oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n                o.MonthsSet = new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meMarch, TMonthEnum.meFebruary };\n                o.ColorsSet = new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE };\n                s = fSerializer.SerializeObject(o);\n                Assert.AreEqual(O3, s);\n                oClone = new TEntityWithSets();\n                try\n                {\n                    fSerializer.DeserializeObject(s, oClone);\n                    CollectionAssert.AreEqual(new HashSet<TMonthEnum> { TMonthEnum.meJanuary, TMonthEnum.meFebruary, TMonthEnum.meMarch }, oClone.MonthsSet);\n                    CollectionAssert.AreEqual(new HashSet<TColorEnum> { TColorEnum.RED, TColorEnum.GREEN, TColorEnum.BLUE }, oClone.ColorsSet);\n                }\n                finally\n                {\n                    oClone.Dispose();\n                }\n            }\n            finally\n            {\n                o.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGuid()\n        {\n            const string JSON = \"{\" +\n                \"\\\"GuidValue\\\":\\\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\\\",\" +\n                \"\\\"GuidValue2\\\":\\\"ca09dc98-85ba-46e8-aba2-117c2fa8ef25\\\",\" +\n                \"\\\"NullableGuid\\\":\\\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\\\",\" +\n                \"\\\"NullableGuid2\\\":\\\"fa51caa7-7d48-46ba-bfde-34c1f740e066\\\",\" +\n                \"\\\"Id\\\":1,\" +\n                \"\\\"Code\\\":2,\" +\n                \"\\\"Name\\\":\\\"Jo\u00e3o Ant\u00f4nio\\\"\" +\n                \"}\";\n            TEntityCustomWithGuid entity = new TEntityCustomWithGuid();\n            try\n            {\n                entity.Id = 1;\n                entity.Code = 2;\n                entity.Name = \"Jo\u00e3o Ant\u00f4nio\";\n                entity.GuidValue = Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\");\n                entity.GuidValue2 = Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\");\n                entity.NullableGuid = Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\");\n                entity.NullableGuid2 = Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\");\n                string json = fSerializer.SerializeObject(entity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n            entity = new TEntityCustomWithGuid();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, entity);\n                Assert.AreEqual(1, entity.Id);\n                Assert.AreEqual(2, entity.Code);\n                Assert.AreEqual(\"Jo\u00e3o Ant\u00f4nio\", entity.Name);\n                Assert.AreEqual(Guid.Parse(\"{AEED1A0F-9061-40F0-9FDA-D69AE7F20222}\"), entity.GuidValue);\n                Assert.AreEqual(Guid.Parse(\"{CA09DC98-85BA-46E8-ABA2-117C2FA8EF25}\"), entity.GuidValue2);\n                Assert.AreEqual(Guid.Parse(\"{EABA9B61-6812-4F0A-9469-D247EB2DA8F4}\"), entity.NullableGuid.Value);\n                Assert.AreEqual(Guid.Parse(\"{FA51CAA7-7d48-46BA-BFDE-34C1F740E066}\"), entity.NullableGuid2.Value);\n            }\n            finally\n            {\n                entity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeDeserializeMultipleGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"],\" +\n                \"\\\"Items2\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description2 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description2 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TMultipleGenericEntity<TNote, TNote> genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 01\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 02\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 03\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 04\"));\n                genericEntity.Items2.Add(new TNote(\"Description2 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TMultipleGenericEntity<TNote, TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n                Assert.AreEqual(5, genericEntity.Items2.Count);\n                Assert.AreEqual(\"Description2 01\", genericEntity.Items2[0].Description);\n                Assert.AreEqual(\"Description2 02\", genericEntity.Items2[1].Description);\n                Assert.AreEqual(\"Description2 03\", genericEntity.Items2[2].Description);\n                Assert.AreEqual(\"Description2 04\", genericEntity.Items2[3].Description);\n                Assert.AreEqual(\"Description2 05\", genericEntity.Items2[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestSerializeNil()\n        {\n            Assert.AreEqual(\"null\", fSerializer.SerializeObject(null));\n        }\n\n        [Test]\n        public void TestSerializeDeserializeGenericEntity()\n        {\n            const string JSON = \"{\" +\n                \"\\\"Code\\\":1,\" +\n                \"\\\"Description\\\":\\\"General Description\\\",\" +\n                \"\\\"Items\\\":[\" +\n                    \"{\\\"Description\\\":\\\"Description 01\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 02\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 03\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 04\\\"},\" +\n                    \"{\\\"Description\\\":\\\"Description 05\\\"}\" +\n                \"]\" +\n                \"}\";\n            TGenericEntity<TNote> genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                genericEntity.Code = 1;\n                genericEntity.Description = \"General Description\";\n                genericEntity.Items.Add(new TNote(\"Description 01\"));\n                genericEntity.Items.Add(new TNote(\"Description 02\"));\n                genericEntity.Items.Add(new TNote(\"Description 03\"));\n                genericEntity.Items.Add(new TNote(\"Description 04\"));\n                genericEntity.Items.Add(new TNote(\"Description 05\"));\n                string json = fSerializer.SerializeObject(genericEntity);\n                Assert.AreEqual(JSON, json);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n            genericEntity = new TGenericEntity<TNote>();\n            try\n            {\n                fSerializer.DeserializeObject(JSON, genericEntity);\n                Assert.AreEqual(1, genericEntity.Code);\n                Assert.AreEqual(\"General Description\", genericEntity.Description);\n                Assert.AreEqual(5, genericEntity.Items.Count);\n                Assert.AreEqual(\"Description 01\", genericEntity.Items[0].Description);\n                Assert.AreEqual(\"Description 02\", genericEntity.Items[1].Description);\n                Assert.AreEqual(\"Description 03\", genericEntity.Items[2].Description);\n                Assert.AreEqual(\"Description 04\", genericEntity.Items[3].Description);\n                Assert.AreEqual(\"Description 05\", genericEntity.Items[4].Description);\n            }\n            finally\n            {\n                genericEntity.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestDoNotSerializeDoNotDeSerialize()\n        {\n            TPartialSerializableType obj = new TPartialSerializableType();\n            try\n            {\n                string s = fSerializer.SerializeObject(obj);\n                Assert.IsFalse(s.Contains(\"prop1\"));\n                Assert.IsTrue(s.Contains(\"prop2\"));\n                Assert.IsFalse(s.Contains(\"prop3\"));\n                Assert.IsTrue(s.Contains(\"prop4\"));\n            }\n            finally\n            {\n                obj.Dispose();\n            }\n            obj = new TPartialSerializableType();\n            try\n            {\n                fSerializer.DeserializeObject(\"{\\\"prop1\\\":\\\"x1\\\",\\\"prop2\\\":\\\"x2\\\",\\\"prop3\\\":\\\"x3\\\",\\\"prop4\\\":\\\"x4\\\"}\", obj);\n                Assert.AreEqual(\"x1\", obj.Prop1);\n                Assert.AreEqual(\"prop2\", obj.Prop2);\n                Assert.AreEqual(\"prop3\", obj.Prop3);\n                Assert.AreEqual(\"x4\", obj.Prop4);\n            }\n            finally\n            {\n                obj.Dispose();\n            }\n        }\n\n        [Test]\n        public void TestIssue792()\n        {\n            TMyObj myObj = new TMyObj();\n            try\n            {\n                myObj.Name = \"will be changed\";\n                IMVCSerializer ser = new TMVCJsonDataObjectsSerializer();\n                ser.DeserializeObject(\"{ \\\"dataobject\\\" : { \\\"name\\\" : \\\"Daniele\\\", \\\"number\\\" : 123 } }\", myObj, TMVCSerializationType.stDefault, null, \"dataobject\");\n                Assert.IsTrue(ser.SerializeObject(myObj).Contains(\"Daniele\"));\n            }\n            finally\n            {\n                myObj.Dispose();\n            }\n            myObj = new TMyObj();\n            try\n            {\n                IMVCSerializer ser = new TMVCJsonDataObjectsSerializer();\n                myObj.Name = \"the untouchable\";\n                ser.DeserializeObject(\"{ \\\"dataobject\\\" : null}\", myObj, TMVCSerializationType.stDefault, null, \"dataobject\");\n                Assert.IsTrue(ser.SerializeObject(myObj).Contains(\"the untouchable\"));\n            }\n            finally\n            {\n                myObj.Dispose();\n            }\n        }\n    }\n\n    public class MVCTestSerializerJsonDataObjects_EntityCustomSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(TValue elementValue, out object serializerObject, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            serializerObject = new JsonObject();\n            ((JsonObject)serializerObject).L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).S[\"AName\"] = entity.Name;\n        }\n\n        public void SerializeAttribute(TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            ((JsonObject)serializerObject).Object[propertyName].L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).Object[propertyName].I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).Object[propertyName].S[\"AName\"] = entity.Name;\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, TCustomAttribute[] attributes, TMVCSerializationAction serializationAction = null)\n        {\n            TEntityCustom entity = obj as TEntityCustom;\n            serializerObject = new JsonObject();\n            ((JsonObject)serializerObject).L[\"AId\"] = entity.Id;\n            ((JsonObject)serializerObject).I[\"ACode\"] = entity.Code;\n            ((JsonObject)serializerObject).S[\"AName\"] = entity.Name;\n        }\n\n        public void Deserialize(object serializedObject, ref TValue elementValue, TCustomAttribute[] attributes)\n        {\n            JsonObject json = serializedObject as JsonObject;\n            TEntityCustom entity = elementValue.AsType<TEntityCustom>();\n            entity.Id = json.I[\"AId\"];\n            entity.Code = json.I[\"ACode\"];\n            entity.Name = json.S[\"AName\"];\n        }\n\n        public void DeserializeAttribute(ref TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n            DeserializeRoot(serializerObject, ref elementValue, attributes);\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, TCustomAttribute[] attributes)\n        {\n            TEntityCustom entity = obj as TEntityCustom;\n            JsonObject json = serializerObject as JsonObject;\n            entity.Id = json.I[\"AId\"];\n            entity.Code = json.I[\"ACode\"];\n            entity.Name = json.S[\"AName\"];\n        }\n    }\n\n    public class MVCTestSerializerJsonDataObjects_NullableIntegerSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(TValue elementValue, out object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void SerializeAttribute(TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, TCustomAttribute[] attributes, TMVCSerializationAction serializationAction = null)\n        {\n        }\n\n        public void Deserialize(object serializerObject, ref TValue elementValue, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void DeserializeAttribute(ref TValue elementValue, string propertyName, object serializerObject, TCustomAttribute[] attributes)\n        {\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, TCustomAttribute[] attributes)\n        {\n        }\n    }\n\n    public static class Extensions\n    {\n        public static void Dispose(this object obj)\n        {\n            (obj as IDisposable)?.Dispose();\n        }\n    }\n}"}
{"input": "unit Service1U;\n\ninterface\n\nuses ServicesInterfaceU, Spring.Container.Common;\n\ntype\n  TUsersService = class(TInterfacedObject, IUsersService)\n  protected\n    [Inject]\n    fCommonService: ICommonService;\n  public\n    function GetUserNameByID(const ID: Integer): string;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TUsersService }\n\nfunction TUsersService.GetUserNameByID(const ID: Integer): string;\nbegin\n  Result := Format('User #%d (CommonServiceID = %s)', [ID, fCommonService.GetID]);\nend;\n\nend.", "output": "using System;\nusing ServicesInterfaceU;\nusing Spring.Container.Common;\n\nnamespace ServiceNamespace\n{\n    public class UsersService : IUsersService\n    {\n        [Inject]\n        private ICommonService commonService;\n\n        public string GetUserNameByID(int id)\n        {\n            return string.Format(\"User #{0} (CommonServiceID = {1})\", id, commonService.GetID);\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.HTTPApplication;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(FPC)}\nuses\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fphttpapp,\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Proc;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FListenQueue: Integer;\n    class var FHTTPApplication: THTTPApplication;\n    class function GetDefaultHTTPApplication: THTTPApplication;\n    class function HTTPApplicationIsNil: Boolean;\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetHost(const AValue: string); static;\n    class function GetListenQueue: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure DoGetModule(Sender: TObject; ARequest: TRequest; var ModuleClass: TCustomHTTPModuleClass);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallback: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallback: TProc); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallback: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallback: TProc); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(FPC)}\n\nuses\n  Horse.WebModule;\n\nclass function THorseProvider.GetDefaultHTTPApplication: THTTPApplication;\nbegin\n  if HTTPApplicationIsNil then\n    FHTTPApplication := Application;\n  Result := FHTTPApplication;\nend;\n\nclass function THorseProvider.HTTPApplicationIsNil: Boolean;\nbegin\n  Result := FHTTPApplication = nil;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LHTTPApplication: THTTPApplication;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n  if FListenQueue = 0 then\n    FListenQueue := 15;\n  LHTTPApplication := GetDefaultHTTPApplication;\n  LHTTPApplication.AllowDefaultModule := True;\n  LHTTPApplication.OnGetModule := DoGetModule;\n  LHTTPApplication.Threaded := True;\n  LHTTPApplication.QueueSize := FListenQueue;\n  LHTTPApplication.Port := FPort;\n  LHTTPApplication.LegacyRouting := True;\n  LHTTPApplication.Address := FHost;\n  LHTTPApplication.Initialize;\n  FRunning := True;\n  DoOnListen;\n  LHTTPApplication.Run;\nend;\n\nclass procedure THorseProvider.DoGetModule(Sender: TObject; ARequest: TRequest; var ModuleClass: TCustomHTTPModuleClass);\nbegin\n  ModuleClass := THorseWebModule;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallback: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallback);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallback: TProc);\nbegin\n  Listen(FPort, AHost, ACallback);\nend;\n\nclass procedure THorseProvider.Listen(const ACallback: TProc);\nbegin\n  Listen(FPort, FHost, ACallback);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallback: TProc);\nbegin\n  Listen(APort, FHost, ACallback);\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Threading;\n\nnamespace Horse.Provider.FPC.HTTPApplication\n{\n    \n    public class HTTPApplication\n    {\n        public bool AllowDefaultModule { get; set; }\n        public OnGetModuleDelegate OnGetModule { get; set; }\n        public bool Threaded { get; set; }\n        public int QueueSize { get; set; }\n        public int Port { get; set; }\n        public bool LegacyRouting { get; set; }\n        public string Address { get; set; }\n        public bool Active { get; set; }\n\n        \n        public void Initialize()\n        {\n            \n            Console.WriteLine(\"HTTPApplication initialized.\");\n        }\n\n        \n        public void Run()\n        {\n            Active = true;\n            Console.WriteLine($\"HTTPApplication running on {Address}:{Port}.\");\n            \n            while (Active)\n            {\n                Thread.Sleep(1000);\n            }\n        }\n    }\n\n    \n    public delegate void OnGetModuleDelegate(object sender, Request request, out Type moduleClass);\n\n    \n    public class Request\n    {\n        // Define request properties as needed.\n    }\n\n    \n    public class HorseWebModule\n    {\n        // Define your web module logic here.\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n    }\n\n    \n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        \n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n\n        protected static void DoOnListen() => OnListenCallback?.Invoke();\n        protected static void DoOnStopListen() => OnStopListenCallback?.Invoke();\n\n        public static void SetOnListen(Action callback) => OnListenCallback = callback;\n        public static void SetOnStopListen(Action callback) => OnStopListenCallback = callback;\n    }\n\n    \n    public static class HorseProvider \n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _listenQueue;\n        private static HTTPApplication _httpApplication;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n\n        \n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost = \"0.0.0.0\", Action callbackListen = null)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            HorseProviderAbstract.SetOnListen(callbackListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen)\n        {\n            Listen(_port, aHost, callbackListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen)\n        {\n            Listen(aPort, _host, callbackListen);\n        }\n\n        public static void Listen(Action callbackListen)\n        {\n            Listen(_port, _host, callbackListen);\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n\n        private static HTTPApplication GetDefaultHTTPApplication()\n        {\n            if (HTTPApplicationIsNil())\n            {\n                _httpApplication = new HTTPApplication();\n            }\n            return _httpApplication;\n        }\n\n        private static bool HTTPApplicationIsNil() => _httpApplication == null;\n\n        private static void DoGetModule(object sender, Request request, out Type moduleClass)\n        {\n            moduleClass = typeof(HorseWebModule);\n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n            if (_listenQueue == 0)\n                _listenQueue = HorseConstants.IdListenQueueDefault;\n\n            var app = GetDefaultHTTPApplication();\n            app.AllowDefaultModule = true;\n            app.OnGetModule = DoGetModule;\n            app.Threaded = true;\n            app.QueueSize = _listenQueue;\n            app.Port = _port;\n            app.LegacyRouting = true;\n            app.Address = _host;\n            app.Initialize();\n            _running = true;\n            HorseProviderAbstract.DoOnListen();\n            app.Run();\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPApplicationIsNil())\n            {\n                var app = GetDefaultHTTPApplication();\n                app.Active = false;\n                HorseProviderAbstract.DoOnStopListen();\n                _running = false;\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Redirect;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Logger,\n  MVCFramework.Commons;\n\ntype\n  TMVCRedirectMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fRedirectToURL: string;\n    fRequestedPathInfos: TArray<String>;\n  protected\n    procedure OnBeforeRouting(Context: TWebContext; var Handled: Boolean);\n    procedure OnBeforeControllerAction(Context: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionNAme: string; var Handled: Boolean);\n    procedure OnAfterRouting(Context: TWebContext; const AHandled: Boolean);\n    procedure OnAfterControllerAction(Context: TWebContext; const AControllerQualifiedClassName: string; const AActionName: string; const AHandled: Boolean);\n  public\n    constructor Create(\n      const RequestedPathInfos: TArray<String>;\n      const RedirectToURL: String);\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.Classes;\n\nconstructor TMVCRedirectMiddleware.Create(\n  const RequestedPathInfos: TArray<String>;\n  const RedirectToURL: String);\nbegin\n  inherited Create;\n  fRequestedPathInfos := RequestedPathInfos;\n  fRedirectToURL := RedirectToURL;\nend;\n\nprocedure TMVCRedirectMiddleware.OnAfterControllerAction(\n  Context: TWebContext; const AControllerQualifiedClassName: string;\n  const AActionName: string; const AHandled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnAfterRouting(Context: TWebContext; const AHandled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnBeforeControllerAction(Context: TWebContext;\n  const AControllerQualifiedClassName, AActionNAme: string; var Handled: Boolean);\nbegin\nend;\n\nprocedure TMVCRedirectMiddleware.OnBeforeRouting(Context: TWebContext; var Handled: Boolean);\nvar\n  I: Integer;\n  lPathInfo: string;\nbegin\n  if not Handled then\n  begin\n    lPathInfo := Context.Request.PathInfo;\n    for I := 0 to Pred(Length(fRequestedPathInfos)) do\n    begin\n      if lPathInfo = fRequestedPathInfos[I] then\n      begin\n        Context.Response.RawWebResponse.SendRedirect(fRedirectToURL);\n        LogI(Format('Redirected from [%s] to [%s]', [lPathInfo, fRedirectToURL]));\n        Handled := True;\n      end;\n    end;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Linq;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Logger;\n\nnamespace MVCFramework.Middleware\n{\n    \n    public class MVCRedirectMiddleware : IMVCMiddleware\n    {\n        private readonly string[] _requestedPathInfos;\n        private readonly string _redirectToURL;\n\n        public MVCRedirectMiddleware(string[] requestedPathInfos, string redirectToURL)\n        {\n            _requestedPathInfos = requestedPathInfos;\n            _redirectToURL = redirectToURL;\n        }\n\n        \n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            if (!handled)\n            {\n                string pathInfo = context.Request.PathInfo;\n                foreach (var requestedPath in _requestedPathInfos)\n                {\n                    if (string.Equals(pathInfo, requestedPath, StringComparison.OrdinalIgnoreCase))\n                    {\n                        context.Response.RawWebResponse.SendRedirect(_redirectToURL);\n                        Logger.LogInfo($\"Redirected from [{pathInfo}] to [{_redirectToURL}]\");\n                        handled = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // No additional logic needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // No additional logic needed.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No additional logic needed.\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Tests.Serializer.EntitiesModule;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Data.DB,\n  Datasnap.DBClient,\n  MVCFramework.Serializer.Commons,\n  MidasLib;\n\ntype\n\n  TEntitiesModule = class(TDataModule)\n    Entity: TClientDataSet;\n    EntityId: TLargeintField;\n    EntityCode: TIntegerField;\n    EntityName: TStringField;\n    EntitySalary: TCurrencyField;\n    EntityBirthday: TDateField;\n    EntityAccessDateTime: TDateTimeField;\n    EntityAccessTime: TTimeField;\n    EntityActive: TBooleanField;\n    EntityAmount: TFloatField;\n    EntityIgnored: TStringField;\n    EntityBlobFld: TBlobField;\n\n    [MVCDoNotSerialize]\n    EntityIgnoredAtt: TStringField;\n\n    [MVCDataSetField(dtArray)]\n    EntityItems: TDataSetField;\n    Item: TClientDataSet;\n    ItemId: TLargeintField;\n    ItemName: TStringField;\n\n    [MVCDataSetField(dtObject)]\n    EntityDepartament: TDataSetField;\n    Departament: TClientDataSet;\n    DepartamentName: TStringField;\n\n    [MVCNameCase(ncLowerCase)]\n    EntityLowerCase: TClientDataSet;\n    EntityLowerCaseId: TLargeintField;\n    EntityLowerCaseName: TStringField;\n\n    [MVCNameCase(ncUpperCase)]\n    EntityUpperCase: TClientDataSet;\n    EntityUpperCaseId: TLargeintField;\n    EntityUpperCaseName: TStringField;\n\n    EntityUpperCase2: TClientDataSet;\n    EntityUpperCase2Id: TLargeintField;\n    EntityUpperCase2Name: TStringField;\n\n    EntityAsIs: TClientDataSet;\n\n    [MVCNameAs('Id_Id')]\n    EntityAsIsId: TLargeintField;\n\n    [MVCNameAs('Name_Name')]\n    EntityAsIsName: TStringField;\n    EntityGUID: TGuidField;\n\n    procedure DataModuleCreate(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{ %CLASSGROUP 'System.Classes.TPersistent' }\n\n{$R *.dfm}\n\nprocedure TEntitiesModule.DataModuleCreate(Sender: TObject);\nbegin\n  Entity.CreateDataSet;\n  EntityLowerCase.CreateDataSet;\n  EntityUpperCase.CreateDataSet;\n  EntityUpperCase2.CreateDataSet;\n  EntityAsIs.CreateDataSet;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.Collections.Generic;\n\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property)]\npublic class MVCNameCaseAttribute : Attribute\n{\n    public string Case { get; }\n    public MVCNameCaseAttribute(string nameCase)\n    {\n        Case = nameCase;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Property)]\npublic class MVCDoNotSerializeAttribute : Attribute\n{\n}\n\n[AttributeUsage(AttributeTargets.Property)]\npublic class MVCNameAsAttribute : Attribute\n{\n    public string Name { get; }\n    public MVCNameAsAttribute(string name)\n    {\n        Name = name;\n    }\n}\n\nnamespace MVCFramework.Tests.Serializer\n{\n    \n    public class EntitiesModule\n    {\n        public DataTable Entity { get; private set; }\n\n        public DataTable Item { get; private set; }\n\n        public DataTable Departament { get; private set; }\n\n        [MVCNameCase(\"ncLowerCase\")]\n        public DataTable EntityLowerCase { get; private set; }\n\n        [MVCNameCase(\"ncUpperCase\")]\n        public DataTable EntityUpperCase { get; private set; }\n\n        public DataTable EntityUpperCase2 { get; private set; }\n\n        public DataTable EntityAsIs { get; private set; }\n\n        public EntitiesModule()\n        {\n            CreateDataSets();\n        }\n\n        private void CreateDataSets()\n        {\n            Entity = new DataTable(\"Entity\");\n            Entity.Columns.Add(\"EntityId\", typeof(long));\n            Entity.Columns.Add(\"EntityCode\", typeof(int));\n            Entity.Columns.Add(\"EntityName\", typeof(string));\n            Entity.Columns.Add(\"EntitySalary\", typeof(decimal)); // Currency\n            Entity.Columns.Add(\"EntityBirthday\", typeof(DateTime));\n            Entity.Columns.Add(\"EntityAccessDateTime\", typeof(DateTime));\n            Entity.Columns.Add(\"EntityAccessTime\", typeof(TimeSpan));\n            Entity.Columns.Add(\"EntityActive\", typeof(bool));\n            Entity.Columns.Add(\"EntityAmount\", typeof(double));\n            Entity.Columns.Add(\"EntityIgnored\", typeof(string));\n            Entity.Columns.Add(\"EntityIgnoredAtt\", typeof(string));\n            Entity.Columns.Add(\"EntityBlobFld\", typeof(byte[]));\n            Entity.Columns.Add(\"EntityGUID\", typeof(Guid));\n\n            Item = new DataTable(\"Item\");\n            Item.Columns.Add(\"ItemId\", typeof(long));\n            Item.Columns.Add(\"ItemName\", typeof(string));\n\n            Departament = new DataTable(\"Departament\");\n            Departament.Columns.Add(\"DepartamentName\", typeof(string));\n\n            EntityLowerCase = new DataTable(\"EntityLowerCase\");\n            EntityLowerCase.Columns.Add(\"entitylowercaseid\", typeof(long));\n            EntityLowerCase.Columns.Add(\"entitylowercasename\", typeof(string));\n\n            EntityUpperCase = new DataTable(\"EntityUpperCase\");\n            EntityUpperCase.Columns.Add(\"ENTITYUPPERCASEID\", typeof(long));\n            EntityUpperCase.Columns.Add(\"ENTITYUPPERCASENAME\", typeof(string));\n\n            EntityUpperCase2 = new DataTable(\"EntityUpperCase2\");\n            EntityUpperCase2.Columns.Add(\"EntityUpperCase2Id\", typeof(long));\n            EntityUpperCase2.Columns.Add(\"EntityUpperCase2Name\", typeof(string));\n\n            EntityAsIs = new DataTable(\"EntityAsIs\");\n            EntityAsIs.Columns.Add(\"Id_Id\", typeof(long));\n            EntityAsIs.Columns.Add(\"Name_Name\", typeof(string));\n\n            \n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Session;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils,\n  System.Generics.Collections,\n  MVCFramework.Commons,\n  MVCFramework.Nullables;\n\nconst\n  DEFAULT_SESSION_INACTIVITY = 60; // in minutes\n\ntype\n  EMVCSession = class(EMVCException)\n\n  end;\n\n  TMVCWebSessionFactory = class;\n\n  TMVCWebSession = class abstract\n  strict private\n    fChanged: Boolean;\n    fExpirationTimeStamp: NullableTDateTime;\n    fSessionFactory: TMVCWebSessionFactory;\n  protected\n    fSessionId: string;\n    fTimeout: UInt64;\n    function GetSessionFactory: TMVCWebSessionFactory;\n    function GetItems(const AKey: string): string; virtual; abstract;\n    procedure SetItems(const AKey, AValue: string); virtual;\n    procedure InternalApplyChanges; virtual;\n    function GetExpirationTimeStamp: NullableTDateTime; virtual;\n    procedure SetExpirationTimeStamp(const Value: NullableTDateTime); virtual;\n    procedure SetTimeout(const Value: UInt64); virtual;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory); virtual;\n    destructor Destroy; override;\n    procedure MarkAsUsed; virtual;\n    procedure ApplyChanges;\n    function ToString: string; override;\n    function IsExpired: Boolean; virtual;\n    function Keys: TArray<String>; virtual;\n    procedure StopSession; virtual;\n    procedure RefreshSessionExpiration; virtual;\n    property ExpirationTimeStamp: NullableTDateTime read GetExpirationTimeStamp write SetExpirationTimeStamp;\n    function Clone: TMVCWebSession; virtual; abstract;\n    property Items[const AKey: string]: string read GetItems write SetItems; default;\n    property SessionId: string read FSessionId;\n    property Timeout: UInt64 read FTimeout write SetTimeout;\n  end;\n\n  TMVCWebSessionFactory = class abstract\n  private\n    fTimeoutInMinutes: Integer;\n  public\n    function GetTimeout: Integer;\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; virtual; abstract;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; virtual; abstract;\n    function TryFindSessionID(const ASessionID: String): Boolean; virtual; abstract;\n    procedure TryDeleteSessionID(const ASessionID: String); virtual; abstract;\n    constructor Create(aTimeoutInMinutes: Integer = 0); virtual;\n  end;\n\n  TMVCWebSessionClass = class of TMVCWebSession;\n\n  TMVCWebSessionMemory = class(TMVCWebSession)\n  private\n    FData: TDictionary<string, string>;\n  protected\n    function GetItems(const AKey: string): string; override;\n    procedure SetItems(const AKey, AValue: string); override;\n    procedure InternalApplyChanges; override;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory); override;\n    destructor Destroy; override;\n    function Keys: TArray<String>; override;\n    function Clone: TMVCWebSession; override;\n    function ToString: string; override;\n    property Data: TDictionary<string, string> read FData;\n//    class function CreateNewSession(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function TryFindSessionID(const ASessionID: String): Boolean; override;\n//    class procedure TryDeleteSessionID(const aSessionID: String); override;\n  end;\n\n  TMVCWebSessionMemoryFactory = class(TMVCWebSessionFactory)\n  protected\n    class function GlobalSessionList: TObjectDictionary<string, TMVCWebSessionMemory>;\n  public\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; override;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; override;\n    function TryFindSessionID(const ASessionID: String): Boolean; override;\n    procedure TryDeleteSessionID(const ASessionID: String); override;\n  end;\n\n  TMVCWebSessionFile = class(TMVCWebSession)\n  private\n    fSessionFolder: String;\n    fData: TDictionary<string, string>;\n  protected\n    class var gLock: TObject;\n    function GetItems(const AKey: string): string; override;\n    procedure SetItems(const AKey, AValue: string); override;\n    procedure LoadFromFile;\n    procedure SaveToFile;\n    procedure InternalApplyChanges; override;\n  public\n    constructor Create(const aOwnerFactory: TMVCWebSessionFactory; const SessionFolder: String); reintroduce;\n    destructor Destroy; override;\n    function Keys: TArray<String>; override;\n    function Clone: TMVCWebSession; override;\n    function ToString: string; override;\n    property Data: TDictionary<string, string> read FData;\n//    class function CreateNewSession(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession; override;\n//    class function TryFindSessionID(const ASessionID: String): Boolean; override;\n//    class procedure TryDeleteSessionID(const aSessionID: String); override;\n    //\n    class constructor Create;\n    class destructor Destroy;\n  end;\n\n  TMVCWebSessionFileFactory = class(TMVCWebSessionFactory)\n  protected\n    fSessionFolder: String;\n    function GetSessionFolder(aAbsoluteOrRelativePath: String): String;\n    function GetSessionFileName(aSessionID: String): String;\n  public\n    function CreateNewSession(const ASessionId: string): TMVCWebSession; override;\n    function CreateFromSessionID(const ASessionId: string): TMVCWebSession; override;\n    function TryFindSessionID(const ASessionID: String): Boolean; override;\n    procedure TryDeleteSessionID(const ASessionID: String); override;\n    constructor Create(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'); reintroduce; virtual;\n  end;\n\n\n//  TMVCSessionFactory = class sealed\n//  private\n//    FSessionTypeClass: TMVCWebSessionClass;\n//    FRegisteredSessionTypes: TDictionary<string, TMVCWebSessionClass>;\n//  protected\n//    class var cInstance: TMVCSessionFactory;\n//    constructor Create;\n//  public\n//    destructor Destroy; override;\n//    procedure RegisterSessionType(const AName: string; AWebSessionClass: TMVCWebSessionClass);\n//    function CreateNewSession(const ATimeout: UInt64): TMVCWebSession;\n//    function CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession;\n//    function TryFindSessionID(const ASessionID: String): Boolean;\n//    procedure TryDeleteSessionID(const ASessionID: String);\n//    class function GetInstance: TMVCSessionFactory; static;\n//    procedure SetSessionType(const SessionType: String);\n//  end;\n\n\nimplementation\n\nuses\n  System.IOUtils,\n  MVCFramework.Logger,\n  MVCFramework.Serializer.Commons, System.DateUtils;\n\nvar\n  GlSessionList: TObjectDictionary<string, TMVCWebSessionMemory> = nil;\n  GlLastSessionListClear: TDateTime;\n  GlCriticalSection: TCriticalSection;\n  GSessionTypeLock: Int64 = 0;\n\nclass function TMVCWebSessionMemoryFactory.GlobalSessionList: TObjectDictionary<string, TMVCWebSessionMemory>;\nvar\n  S: string;\nbegin\n  if not Assigned(GlSessionList) then\n  begin\n    GlCriticalSection.Enter;\n    try\n      if not Assigned(GlSessionList) then\n      begin\n        GlSessionList := TObjectDictionary<string, TMVCWebSessionMemory>.Create([doOwnsValues], 1024);\n      end;\n    finally\n      GlCriticalSection.Leave;\n    end;\n  end;\n\n  if MinutesBetween(Now, GlLastSessionListClear) >= 1 then\n  begin\n    TMonitor.Enter(GlSessionList);\n    try\n      for S in GlSessionList.Keys do\n        if TMVCWebSession(GlSessionList.Items[S]).IsExpired then\n          GlSessionList.Remove(S);\n      GlLastSessionListClear := Now;\n    finally\n      TMonitor.Exit(GlSessionList);\n    end;\n  end;\n\n  Result := GlSessionList;\nend;\n\nprocedure TMVCWebSessionMemory.InternalApplyChanges;\nbegin\n  TMonitor.Enter(TMVCWebSessionMemoryFactory.GlobalSessionList);\n  try\n    TMVCWebSessionMemoryFactory.GlobalSessionList.AddOrSetValue(fSessionId, TMVCWebSessionMemory(Self.Clone));\n  finally\n    TMonitor.Exit(TMVCWebSessionMemoryFactory.GlobalSessionList);\n  end;\nend;\n\nfunction TMVCWebSessionMemory.Keys: TArray<String>;\nbegin\n  Result := Data.Keys.ToArray;\nend;\n\nprocedure TMVCWebSession.ApplyChanges;\nbegin\n  if Self <> nil then\n  begin\n    if FChanged then\n    begin\n      InternalApplyChanges;\n      FChanged := False;\n    end;\n  end;\nend;\n\nconstructor TMVCWebSession.Create(const aOwnerFactory: TMVCWebSessionFactory);\nbegin\n  inherited Create;\n  fSessionFactory := aOwnerFactory;\n  fChanged := False;\nend;\n\n{ TWebSession }\n\ndestructor TMVCWebSession.Destroy;\nbegin\n  inherited Destroy;\nend;\n\nfunction TMVCWebSession.GetExpirationTimeStamp: NullableTDateTime;\nbegin\n  Result := fExpirationTimeStamp;\nend;\n\nfunction TMVCWebSession.GetSessionFactory: TMVCWebSessionFactory;\nbegin\n  Result := fSessionFactory;\nend;\n\nprocedure TMVCWebSession.InternalApplyChanges;\nbegin\n  // do nothing\nend;\n\nfunction TMVCWebSession.IsExpired: Boolean;\nbegin\n  if ExpirationTimeStamp.HasValue then\n    Result := ExpirationTimeStamp.Value < RecodeMilliSecond(RecodeSecond(Now(), 0), 0)\n  else\n    Result := False;\nend;\n\nfunction TMVCWebSession.Keys: TArray<String>;\nbegin\n  Result := ['<not implemented>'];\nend;\n\nprocedure TMVCWebSession.MarkAsUsed;\nbegin\n  fChanged := True;\n  ExpirationTimeStamp := Now + OneMinute * Timeout;\nend;\n\nprocedure TMVCWebSession.SetTimeout(const Value: UInt64);\nbegin\n  fTimeout := Value;\n  RefreshSessionExpiration;\nend;\n\nprocedure TMVCWebSession.SetExpirationTimeStamp(const Value: NullableTDateTime);\nbegin\n  fExpirationTimeStamp := Value;\nend;\n\nprocedure TMVCWebSession.SetItems(const AKey, AValue: string);\nbegin\n  FChanged := True;\nend;\n\nprocedure TMVCWebSession.StopSession;\nbegin\n  //do nothing\nend;\n\nprocedure TMVCWebSession.RefreshSessionExpiration;\nbegin\n  if fTimeout > 0 then\n    fExpirationTimeStamp := RecodeMilliSecond(RecodeSecond(Now() + OneMinute * fTimeout, 0), 0)\n  else\n    fExpirationTimeStamp.Clear;\nend;\n\nfunction TMVCWebSession.ToString: string;\nbegin\n  Result := String.Join(',', Keys);\nend;\n\nfunction TMVCWebSessionMemory.Clone: TMVCWebSession;\nvar\n  lMemSess: TMVCWebSessionMemory;\n  lItem: TPair<String, String>;\nbegin\n  lMemSess := TMVCWebSessionMemory.Create(GetSessionFactory);\n  try\n    lMemSess.fSessionId := SessionId;\n    lMemSess.Timeout := Timeout;\n    for lItem in Self.Data do\n    begin\n      lMemSess.Data.Add(lItem.Key, lItem.Value);\n    end;\n  except\n    lMemSess.Free;\n    raise;\n  end;\n  Result := lMemSess;\nend;\n\nconstructor TMVCWebSessionMemory.Create(const aOwnerFactory: TMVCWebSessionFactory);\nbegin\n  inherited;\n  fData := TDictionary<String, String>.Create;\nend;\n\nfunction TMVCWebSessionMemoryFactory.CreateFromSessionID(const ASessionId: string): TMVCWebSession;\nvar\n  lSess: TMVCWebSessionMemory;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    Result := nil;\n    if GlobalSessionList.TryGetValue(ASessionId, lSess) then\n    begin\n      lSess.Timeout := GetTimeout;\n      Result := lSess.Clone;\n    end;\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TWebSessionMemory }\n\ndestructor TMVCWebSessionMemory.Destroy;\nbegin\n  FData.Free;\n  inherited Destroy;\nend;\n\nfunction TMVCWebSessionMemory.GetItems(const AKey: string): string;\nbegin\n  TMonitor.Enter(Self);\n  try\n    if not FData.TryGetValue(AKey, Result) then\n      Result := '';\n  finally\n    TMonitor.Exit(Self);\n  end;\nend;\n\nprocedure TMVCWebSessionMemory.SetItems(const AKey, AValue: string);\nbegin\n  inherited;\n  TMonitor.Enter(Self);\n  try\n    FData.AddOrSetValue(AKey, AValue);\n  finally\n    TMonitor.Exit(Self);\n  end;\nend;\n\nfunction TMVCWebSessionMemory.ToString: string;\nvar\n  LKey: string;\nbegin\n  Result := '';\n  for LKey in FData.Keys do\n    Result := Result + LKey + '=' + QuotedStr(FData.Items[LKey]) + sLineBreak;\nend;\n\nprocedure TMVCWebSessionMemoryFactory.TryDeleteSessionID(const ASessionID: String);\nbegin\n  inherited;\n  TMonitor.Enter(GlobalSessionList);\n  try\n    GlobalSessionList.Remove(aSessionID);\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\nfunction TMVCWebSessionMemoryFactory.TryFindSessionID(const ASessionID: String): Boolean;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    Result := GlobalSessionList.ContainsKey(ASessionId);\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TMVCSessionFactory }\n\n//constructor TMVCSessionFactory.Create;\n//begin\n//  inherited Create;\n//  FRegisteredSessionTypes := TDictionary<string, TMVCWebSessionClass>.Create;\n//end;\n//\n//function TMVCSessionFactory.CreateNewSession(const ATimeout: UInt64): TMVCWebSession;\n//begin\n//  Result := FSessionTypeClass.CreateNewSession(GenerateSessionID, ATimeout);\n//end;\n//\n//function TMVCSessionFactory.CreateFromSessionID(const aSessionId: string; const ATimeout: UInt64): TMVCWebSession;\n//begin\n//  Result := FSessionTypeClass.CreateFromSessionID(ASessionId, ATimeout);\n//  if (Result = nil) or Result.IsExpired then\n//  begin\n//    raise EMVCSessionExpiredException.Create;\n//  end;\n//end;\n//\n//destructor TMVCSessionFactory.Destroy;\n//begin\n//  FRegisteredSessionTypes.Free;\n//  inherited Destroy;\n//end;\n//\n//class function TMVCSessionFactory.GetInstance: TMVCSessionFactory;\n//begin\n//  if not Assigned(cInstance) then\n//  begin\n//    cInstance := TMVCSessionFactory.Create;\n//  end;\n//  Result := cInstance;\n//end;\n//\n//procedure TMVCSessionFactory.RegisterSessionType(const AName: string; AWebSessionClass: TMVCWebSessionClass);\n//begin\n//  if TInterlocked.Read(GSessionTypeLock) = 1 then\n//  begin\n//    raise EMVCSession.Create('Session factory already initialized');\n//  end;\n//  FRegisteredSessionTypes.AddOrSetValue(AName, AWebSessionClass);\n//end;\n//\n//procedure TMVCSessionFactory.SetSessionType(const SessionType: String);\n//var\n//  Clazz: TMVCWebSessionClass;\n//begin\n//  if TInterlocked.CompareExchange(GSessionTypeLock, 1, 0) = 0 then\n//  begin\n//    if not FRegisteredSessionTypes.TryGetValue(SessionType, Clazz) then\n//      raise EMVCSession.Create('Unknown session type: ' + SessionType);\n//    FSessionTypeClass := Clazz;\n//  end;\n//end;\n//\n//procedure TMVCSessionFactory.TryDeleteSessionID(const ASessionID: String);\n//begin\n//  FSessionTypeClass.TryDeleteSessionID(ASessionID);\n//end;\n//\n//function TMVCSessionFactory.TryFindSessionID(const ASessionID: String): Boolean;\n//begin\n//  Result := FSessionTypeClass.TryFindSessionID(ASessionID);\n//end;\n\nfunction TMVCWebSessionFile.Clone: TMVCWebSession;\nvar\n  lMemSess: TMVCWebSessionFile;\n  lItem: TPair<String, String>;\nbegin\n  lMemSess := TMVCWebSessionFile.Create(GetSessionFactory, Self.fSessionFolder);\n  try\n    lMemSess.fSessionFolder := Self.fSessionFolder;\n    lMemSess.fSessionId := Self.fSessionId;\n    lMemSess.fTimeout := Self.fTimeout;\n    for lItem in Self.Data do\n    begin\n      lMemSess.Data.Add(lItem.Key, lItem.Value);\n    end;\n  except\n    lMemSess.Free;\n    raise;\n  end;\n  Result := lMemSess;\nend;\n\n{ TMVCWebSessionFile }\n\ndestructor TMVCWebSessionFile.Destroy;\nbegin\n  inherited;\n  fData.Free;\nend;\n\nconstructor TMVCWebSessionFile.Create(const aOwnerFactory: TMVCWebSessionFactory; const SessionFolder: String);\nbegin\n  inherited Create(aOwnerFactory);\n  fData := TDictionary<String, String>.Create;\n  fSessionFolder := SessionFolder;\nend;\n\nclass destructor TMVCWebSessionFile.Destroy;\nbegin\n  gLock.Free;\nend;\n\nfunction TMVCWebSessionFile.GetItems(const AKey: string): string;\nbegin\n  if not fData.TryGetValue(AKey, Result) then\n    Result := '';\nend;\n\nfunction TMVCWebSessionFileFactory.GetSessionFileName(aSessionID: String): String;\nbegin\n  Result := TPath.Combine(fSessionFolder, aSessionId);\nend;\n\nfunction TMVCWebSessionFileFactory.GetSessionFolder(aAbsoluteOrRelativePath: String): String;\nbegin\n  if TPath.IsRelativePath(aAbsoluteOrRelativePath) then\n    Result := TPath.Combine(AppPath, aAbsoluteOrRelativePath)\n  else\n    Result := aAbsoluteOrRelativePath;\n  TDirectory.CreateDirectory(Result);\nend;\n\nprocedure TMVCWebSessionFile.InternalApplyChanges;\nbegin\n  TMonitor.Enter(gLock);\n  try\n    SaveToFile;\n  finally\n    TMonitor.Exit(gLock);\n  end;\nend;\n\nfunction TMVCWebSessionFile.Keys: TArray<String>;\nbegin\n  Result := fData.Keys.ToArray;\nend;\n\nprocedure TMVCWebSessionFile.LoadFromFile;\nvar\n  lFileName: String;\n  lFile: TStreamReader;\n  lLine: string;\n  lPieces: TArray<System.string>;\nbegin\n  lFileName := TMVCWebSessionFileFactory(GetSessionFactory).GetSessionFileName(fSessionId);\n  if not TFile.Exists(lFileName) then\n  begin\n    Exit;\n  end;\n  lFile := TFile.OpenText(lFileName);\n  try\n    ExpirationTimeStamp := ISOTimeStampToDateTime(lFile.ReadLine);\n    fTimeout := lFile.ReadLine.ToInteger;\n    while not lFile.EndOfStream do\n    begin\n      lLine := lFile.ReadLine;\n      lPieces := lLine.Split(['=']);\n      SetItems(lPieces[0], lPieces[1]);\n    end;\n  finally\n    lFile.Free;\n  end;\nend;\n\nprocedure TMVCWebSessionFile.SaveToFile;\nvar\n  lFileName: String;\n  lPair: TPair<String, String>;\n  lFile: TStreamWriter;\nbegin\n  MarkAsUsed;\n  lFileName := TMVCWebSessionFileFactory(GetSessionFactory).GetSessionFileName(fSessionId);\n  lFile := TFile.CreateText(lFileName);\n  try\n    lFile.WriteLine(DateTimeToISOTimeStamp(ExpirationTimeStamp));\n    lFile.WriteLine(fTimeout);\n    for lPair in Data do\n    begin\n      lFile.WriteLine(String.Join('=', [lPair.Key, lPair.Value]));\n    end;\n    lFile.Close;\n  finally\n    lFile.Free;\n  end;\nend;\n\nprocedure TMVCWebSessionFile.SetItems(const AKey, AValue: string);\nbegin\n  inherited;\n  fData.AddOrSetValue(AKey, AValue);\nend;\n\nfunction TMVCWebSessionFile.ToString: string;\nbegin\n  Result := String.Join(',', Keys);\nend;\n\nprocedure TMVCWebSessionFileFactory.TryDeleteSessionID(const ASessionID: String);\nvar\n  lSessionFileName: string;\nbegin\n  inherited;\n  lSessionFileName := GetSessionFileName(ASessionID);\n  if TFile.Exists(lSessionFileName) then\n  begin\n    try\n      TFile.Delete(lSessionFileName);\n    except\n      on E: Exception do\n      begin\n        LogE('Cannot delete session file ' + lSessionFileName);\n      end;\n    end;\n  end;\nend;\n\nfunction TMVCWebSessionFileFactory.TryFindSessionID(\n  const ASessionID: String): Boolean;\nbegin\n  inherited;\n  Result := TFile.Exists(GetSessionFileName(ASessionID));\nend;\n\nclass constructor TMVCWebSessionFile.Create;\nbegin\n  gLock := TObject.Create;\nend;\n\nconstructor TMVCWebSessionFileFactory.Create(aTimeoutInMinutes: Integer; aSessionFolder: String);\nbegin\n  inherited Create(aTimeoutInMinutes);\n  fSessionFolder := GetSessionFolder(aSessionFolder);\nend;\n\nfunction TMVCWebSessionFileFactory.CreateFromSessionID(const aSessionId: string): TMVCWebSession;\nbegin\n  Result := TMVCWebSessionFile.Create(Self,  GetSessionFolder(fSessionFolder));\n  try\n    TMVCWebSessionFile(Result).fSessionId := aSessionId;\n    TMVCWebSessionFile(Result).LoadFromFile;\n    TMVCWebSessionFile(Result).fTimeout := GetTimeout;\n  except\n    Result.Free;\n    raise;\n  end;\nend;\n\nfunction TMVCWebSessionFileFactory.CreateNewSession(const aSessionId: string): TMVCWebSession;\nbegin\n  Result := TMVCWebSessionFile.Create(Self, GetSessionFolder(fSessionFolder));\n  Result.fSessionId := aSessionId;\n  Result.fTimeout := GetTimeout;\n  TMVCWebSessionFile(Result).SaveToFile;\nend;\n\n{ TMVCWebSessionMemoryFactory }\n\nfunction TMVCWebSessionMemoryFactory.CreateNewSession(const ASessionId: string): TMVCWebSession;\nvar\n  lSess: TMVCWebSessionMemory;\nbegin\n  TMonitor.Enter(GlobalSessionList);\n  try\n    lSess := TMVCWebSessionMemory.Create(Self);\n    try\n      lSess.fSessionId := ASessionId;\n      lSess.fTimeout := GetTimeout;\n      lSess.MarkAsUsed;\n      GlobalSessionList.Add(ASessionId, lSess);\n      Result := lSess.Clone;\n    except\n      lSess.Free;\n      raise;\n    end;\n  finally\n    TMonitor.Exit(GlobalSessionList);\n  end;\nend;\n\n{ TMVCWebSessionFactory }\n\nconstructor TMVCWebSessionFactory.Create(aTimeoutInMinutes: Integer);\nbegin\n  inherited Create;\n  fTimeoutInMinutes := aTimeoutInMinutes;\nend;\n\nfunction TMVCWebSessionFactory.GetTimeout: Integer;\nbegin\n  Result := fTimeoutInMinutes;\nend;\n\ninitialization\n\nGlCriticalSection := TCriticalSection.Create;\n\nfinalization\n\nFreeAndNil(GlCriticalSection);\n\nif Assigned(GlSessionList) then\n  FreeAndNil(GlSessionList);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace MVCFramework.Session\n{\n    public class MVCSessionException : Exception\n    {\n        public MVCSessionException() { }\n        public MVCSessionException(string message) : base(message) { }\n        public MVCSessionException(string message, Exception innerException) : base(message, innerException) { }\n    }\n\n    \n    public abstract class MVCWebSession\n    {\n        protected bool _changed;\n        protected DateTime? _expirationTimeStamp;\n        protected MVCWebSessionFactory _sessionFactory;\n\n        protected MVCWebSession(MVCWebSessionFactory ownerFactory)\n        {\n            _sessionFactory = ownerFactory;\n            _changed = false;\n        }\n\n        \n        public abstract string GetItem(string key);\n        public virtual void SetItem(string key, string value)\n        {\n            _changed = true;\n        }\n\n       \n        protected virtual void InternalApplyChanges() { }\n\n       \n        public virtual DateTime? ExpirationTimeStamp\n        {\n            get { return _expirationTimeStamp; }\n            set { _expirationTimeStamp = value; }\n        }\n\n        \n        public string SessionId { get; protected set; }\n\n        \n        public int Timeout { get; set; }\n\n        public MVCWebSessionFactory SessionFactory => _sessionFactory;\n\n        \n        public void MarkAsUsed()\n        {\n            _changed = true;\n            RefreshSessionExpiration();\n        }\n\n        \n        public void ApplyChanges()\n        {\n            if (_changed)\n            {\n                InternalApplyChanges();\n                _changed = false;\n            }\n        }\n\n        public override string ToString()\n        {\n            return string.Join(\",\", Keys());\n        }\n\n        \n        public abstract string[] Keys();\n\n        \n        public virtual void StopSession() { }\n\n        \n        public virtual void RefreshSessionExpiration()\n        {\n            if (Timeout > 0)\n                _expirationTimeStamp = DateTime.Now.AddMinutes(Timeout);\n            else\n                _expirationTimeStamp = null;\n        }\n\n        \n        public abstract MVCWebSession Clone();\n\n        \n        public virtual string this[string key]\n        {\n            get { return GetItem(key); }\n            set { SetItem(key, value); }\n        }\n\n        \n        public bool IsExpired()\n        {\n            if (_expirationTimeStamp.HasValue)\n            {\n                return _expirationTimeStamp.Value < DateTime.Now;\n            }\n            return false;\n        }\n    }\n\n    \n    public abstract class MVCWebSessionFactory\n    {\n        protected int _timeoutInMinutes;\n\n        public const int DEFAULT_SESSION_INACTIVITY = 60;\n\n        public MVCWebSessionFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY)\n        {\n            _timeoutInMinutes = timeoutInMinutes;\n        }\n\n        public int TimeoutInMinutes => _timeoutInMinutes;\n\n        public abstract MVCWebSession CreateNewSession(string sessionId);\n        public abstract MVCWebSession CreateFromSessionID(string sessionId);\n        public abstract bool TryFindSessionID(string sessionId);\n        public abstract void TryDeleteSessionID(string sessionId);\n    }\n\n    #region In\u2010Memory Sessions\n\n   \n    public class MVCWebSessionMemory : MVCWebSession\n    {\n        private Dictionary<string, string> _data;\n\n        public MVCWebSessionMemory(MVCWebSessionFactory ownerFactory) : base(ownerFactory)\n        {\n            _data = new Dictionary<string, string>();\n        }\n\n        public override string GetItem(string key)\n        {\n            return _data.TryGetValue(key, out string value) ? value : string.Empty;\n        }\n\n        public override void SetItem(string key, string value)\n        {\n            base.SetItem(key, value);\n            _data[key] = value;\n        }\n\n        public override string[] Keys()\n        {\n            return _data.Keys.ToArray();\n        }\n\n        public override MVCWebSession Clone()\n        {\n            var clone = new MVCWebSessionMemory(_sessionFactory);\n            clone.SessionId = this.SessionId;\n            clone.Timeout = this.Timeout;\n            foreach (var kvp in _data)\n            {\n                clone._data[kvp.Key] = kvp.Value;\n            }\n            return clone;\n        }\n\n        public override string ToString()\n        {\n            return string.Join(Environment.NewLine, _data.Select(kvp => $\"{kvp.Key}='{kvp.Value}'\"));\n        }\n\n        protected override void InternalApplyChanges()\n        {\n            \n            lock (MVCWebSessionMemoryFactory.GlobalSessionListLock)\n            {\n                MVCWebSessionMemoryFactory.GlobalSessionList[SessionId] = (MVCWebSessionMemory)this.Clone();\n            }\n        }\n    }\n\n    \n    public class MVCWebSessionMemoryFactory : MVCWebSessionFactory\n    {\n        \n        internal static Dictionary<string, MVCWebSessionMemory> GlobalSessionList = new Dictionary<string, MVCWebSessionMemory>();\n        internal static readonly object GlobalSessionListLock = new object();\n        private static DateTime _lastSessionListClear = DateTime.Now;\n\n        public MVCWebSessionMemoryFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY)\n            : base(timeoutInMinutes)\n        {\n        }\n\n        private void ClearExpiredSessions()\n        {\n            lock (GlobalSessionListLock)\n            {\n                if ((DateTime.Now - _lastSessionListClear).TotalMinutes >= 1)\n                {\n                    var expiredKeys = GlobalSessionList\n                        .Where(pair => pair.Value.IsExpired())\n                        .Select(pair => pair.Key)\n                        .ToList();\n                    foreach (var key in expiredKeys)\n                    {\n                        GlobalSessionList.Remove(key);\n                    }\n                    _lastSessionListClear = DateTime.Now;\n                }\n            }\n        }\n\n        public override MVCWebSession CreateNewSession(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                var newSession = new MVCWebSessionMemory(this)\n                {\n                    SessionId = sessionId,\n                    Timeout = _timeoutInMinutes\n                };\n                newSession.MarkAsUsed();\n                GlobalSessionList[sessionId] = newSession;\n                return newSession.Clone();\n            }\n        }\n\n        public override MVCWebSession CreateFromSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                if (GlobalSessionList.TryGetValue(sessionId, out MVCWebSessionMemory session))\n                {\n                    session.Timeout = _timeoutInMinutes;\n                    return session.Clone();\n                }\n                return null;\n            }\n        }\n\n        public override bool TryFindSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                ClearExpiredSessions();\n                return GlobalSessionList.ContainsKey(sessionId);\n            }\n        }\n\n        public override void TryDeleteSessionID(string sessionId)\n        {\n            lock (GlobalSessionListLock)\n            {\n                GlobalSessionList.Remove(sessionId);\n            }\n        }\n    }\n\n    #endregion\n\n    #region File-based Sessions\n\n    \n    public class MVCWebSessionFile : MVCWebSession\n    {\n        private Dictionary<string, string> _data;\n        private string _sessionFolder;\n\n        public MVCWebSessionFile(MVCWebSessionFactory ownerFactory, string sessionFolder)\n            : base(ownerFactory)\n        {\n            _data = new Dictionary<string, string>();\n            _sessionFolder = sessionFolder;\n        }\n\n        public override string GetItem(string key)\n        {\n            return _data.TryGetValue(key, out string value) ? value : string.Empty;\n        }\n\n        public override void SetItem(string key, string value)\n        {\n            base.SetItem(key, value);\n            _data[key] = value;\n        }\n\n        public override string[] Keys()\n        {\n            return _data.Keys.ToArray();\n        }\n\n        public override MVCWebSession Clone()\n        {\n            var clone = new MVCWebSessionFile(_sessionFactory, _sessionFolder);\n            clone.SessionId = this.SessionId;\n            clone.Timeout = this.Timeout;\n            foreach (var kvp in _data)\n            {\n                clone._data[kvp.Key] = kvp.Value;\n            }\n            return clone;\n        }\n\n        public override string ToString()\n        {\n            return string.Join(Environment.NewLine, _data.Select(kvp => $\"{kvp.Key}='{kvp.Value}'\"));\n        }\n\n        protected override void InternalApplyChanges()\n        {\n           \n            lock (MVCWebSessionFileFactory.GlobalFileLock)\n            {\n                SaveToFile();\n            }\n        }\n\n        \n        protected void LoadFromFile()\n        {\n            string fileName = MVCWebSessionFileFactory.GetSessionFileNameStatic(_sessionFactory, SessionId, _sessionFolder);\n            if (!File.Exists(fileName))\n                return;\n\n            using (var reader = new StreamReader(fileName))\n            {\n                \n                string expLine = reader.ReadLine();\n                _expirationTimeStamp = ISOTimeStampToDateTime(expLine);\n                string timeoutLine = reader.ReadLine();\n                Timeout = int.Parse(timeoutLine);\n                while (!reader.EndOfStream)\n                {\n                    string line = reader.ReadLine();\n                    var parts = line.Split('=');\n                    if (parts.Length >= 2)\n                        SetItem(parts[0], parts[1]);\n                }\n            }\n        }\n\n        \n        protected void SaveToFile()\n        {\n            MarkAsUsed();\n            string fileName = MVCWebSessionFileFactory.GetSessionFileNameStatic(_sessionFactory, SessionId, _sessionFolder);\n            Directory.CreateDirectory(Path.GetDirectoryName(fileName));\n            using (var writer = new StreamWriter(fileName, false))\n            {\n                writer.WriteLine(DateTimeToISOTimeStamp(ExpirationTimeStamp));\n                writer.WriteLine(Timeout);\n                foreach (var kvp in _data)\n                {\n                    writer.WriteLine($\"{kvp.Key}={kvp.Value}\");\n                }\n            }\n        }\n    }\n\n    \n    public class MVCWebSessionFileFactory : MVCWebSessionFactory\n    {\n        private string _sessionFolder;\n\n        public MVCWebSessionFileFactory(int timeoutInMinutes = DEFAULT_SESSION_INACTIVITY, string sessionFolder = \"dmvc_sessions\")\n            : base(timeoutInMinutes)\n        {\n            _sessionFolder = GetSessionFolder(sessionFolder);\n        }\n\n        private string GetSessionFolder(string path)\n        {\n            if (!Path.IsPathRooted(path))\n                return Path.Combine(AppPath.Value, path);\n            else\n                return path;\n        }\n\n        \n        public static string GetSessionFileNameStatic(MVCWebSessionFactory factory, string sessionId, string folder)\n        {\n            string fullFolder = folder;\n            if (!Path.IsPathRooted(folder))\n                fullFolder = Path.Combine(AppPath.Value, folder);\n            return Path.Combine(fullFolder, sessionId);\n        }\n\n        public override MVCWebSession CreateNewSession(string sessionId)\n        {\n            var session = new MVCWebSessionFile(this, _sessionFolder)\n            {\n                SessionId = sessionId,\n                Timeout = _timeoutInMinutes\n            };\n            session.MarkAsUsed();\n            session.RefreshSessionExpiration();\n            (session as MVCWebSessionFile).SaveToFile();\n            return session;\n        }\n\n        public override MVCWebSession CreateFromSessionID(string sessionId)\n        {\n            var session = new MVCWebSessionFile(this, _sessionFolder)\n            {\n                SessionId = sessionId,\n                Timeout = _timeoutInMinutes\n            };\n            (session as MVCWebSessionFile).LoadFromFile();\n            return session;\n        }\n\n        public override bool TryFindSessionID(string sessionId)\n        {\n            string fileName = GetSessionFileNameStatic(this, sessionId, _sessionFolder);\n            return File.Exists(fileName);\n        }\n\n        public override void TryDeleteSessionID(string sessionId)\n        {\n            string fileName = GetSessionFileNameStatic(this, sessionId, _sessionFolder);\n            if (File.Exists(fileName))\n            {\n                try\n                {\n                    File.Delete(fileName);\n                }\n                catch (Exception ex)\n                {\n                    Console.Error.WriteLine($\"Cannot delete session file {fileName}: {ex.Message}\");\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region Application Path Helper\n\n    public static class AppPath\n    {\n        public static string Value => AppDomain.CurrentDomain.BaseDirectory;\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes;\n\n{$IFDEF LINUX}\n{$ERROR 'This unit is not compatible with linux!'}\n{$ENDIF}\n\ninterface\n\nuses\n  System.Rtti,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons;\n\ntype\n  TMVCBitmapSerializerJsonDataObject = class(TInterfacedObject, IMVCTypeSerializer)\n  protected\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>; const ASerializationAction: TMVCSerializationAction = nil);\n\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: TArray<TCustomAttribute>);\n\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n\n  end;\n\nprocedure RegisterOptionalCustomTypesSerializers(const JDOSerializer: IMVCSerializer); overload;\nprocedure RegisterOptionalCustomTypesSerializersForJSON(const Serializers\n  : TDictionary<string, IMVCSerializer>); overload;\n\nimplementation\n\nuses\n{$IFDEF MSWINDOWS}\n  Vcl.Graphics, {do not specialize VCL or FMX, let use the UnitScope defined in the project}\n  Vcl.Imaging.pngimage, {do not specialize VCL or FMX, le use the UnitScope defined in the project}\n  Vcl.Imaging.jpeg, {do not specialize VCL or FMX, le use the UnitScope defined in the project}\n{$ENDIF}\n  System.Classes,\n  System.SysUtils,\n  JsonDataObjects,\n  MVCFramework.Commons;\n\nprocedure RegisterOptionalCustomTypesSerializers(const JDOSerializer: IMVCSerializer);\nbegin\n{$IFDEF MSWINDOWS}\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TBitmap), TMVCBitmapSerializerJsonDataObject.Create);\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TPngImage), TMVCBitmapSerializerJsonDataObject.Create);\n  JDOSerializer\n    .RegisterTypeSerializer(TypeInfo(TJPEGImage), TMVCBitmapSerializerJsonDataObject.Create);\n{$ENDIF}\nend;\n\nprocedure RegisterOptionalCustomTypesSerializersForJSON(const Serializers: TDictionary<string, IMVCSerializer>);\nbegin\n  RegisterOptionalCustomTypesSerializers(Serializers.Items[TMVCMediaType.APPLICATION_JSON]);\nend;\n\n{ TMVCBitmapSerializerJsonDataObject }\n\nprocedure TMVCBitmapSerializerJsonDataObject.DeserializeAttribute(\n  var AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nvar\n  lGraphic: TGraphic;\n  SS: TStringStream;\n  lJSON: TJDOJsonObject;\n  lTmpStream: TMemoryStream;\nbegin\n  lJSON := ASerializerObject as TJDOJsonObject;\n  if Assigned(lJSON) then\n  begin\n    lGraphic := AElementValue.AsObject as TGraphic;\n    if Assigned(lGraphic) then\n    begin\n      SS := TStringStream.Create(lJSON.S[APropertyName]);\n      try\n        SS.Position := 0;\n        lTmpStream := TMemoryStream.Create;\n        try\n          TMVCSerializerHelper.DecodeStream(SS, lTmpStream);\n          lTmpStream.Position := 0;\n          lGraphic.LoadFromStream(lTmpStream);\n        finally\n          lTmpStream.Free;\n        end;\n      finally\n        SS.Free;\n      end;\n    end;\n  end;\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.DeserializeRoot(\n  const ASerializerObject, AObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n  raise EMVCDeserializationException.Create('Direct image deserialization not supported');\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.SerializeAttribute(\n  const AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nvar\n  lGraphic: TGraphic;\n  lTmpStream: TMemoryStream;\n  lStringStream: TStringStream;\nbegin\n  lGraphic := AElementValue.AsObject as TGraphic;\n  if Assigned(lGraphic) then\n  begin\n    lStringStream := TStringStream.Create('', TEncoding.ASCII);\n    try\n      lTmpStream := TMemoryStream.Create;\n      try\n        lGraphic.SaveToStream(lTmpStream);\n        lTmpStream.Position := 0;\n        TMVCSerializerHelper.EncodeStream(lTmpStream, lStringStream);\n      finally\n        lTmpStream.Free;\n      end;\n      TJDOJsonObject(ASerializerObject).S[APropertyName] := lStringStream.DataString;\n    finally\n      lStringStream.Free;\n    end;\n  end\n  else\n  begin\n    TJsonObject(ASerializerObject).Values[APropertyName] := nil;\n  end;\nend;\n\nprocedure TMVCBitmapSerializerJsonDataObject.SerializeRoot(\n  const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nbegin\n  ASerializerObject := TJsonObject.Create;\n  try\n    SerializeAttribute(AObject, 'data', ASerializerObject, AAttributes);\n  except\n    ASerializerObject.Free;\n    raise;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.IO;\nusing Newtonsoft.Json.Linq;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.Commons;\n\nnamespace MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes\n{\n#if WINDOWS\n    public class MVCBitmapSerializerJsonDataObject : IMVCTypeSerializer\n    {\n        \n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, object[] attributes)\n        {\n            var image = elementValue as Image;\n            if (image != null)\n            {\n                using (var ms = new MemoryStream())\n                {\n                    \n                    image.Save(ms, System.Drawing.Imaging.ImageFormat.Png);\n                    ms.Position = 0;\n                    string base64 = Convert.ToBase64String(ms.ToArray());\n                    \n                    if (serializerObject is JObject jObj)\n                    {\n                        jObj[propertyName] = base64;\n                    }\n                }\n            }\n            else\n            {\n                if (serializerObject is JObject jObj)\n                {\n                    jObj[propertyName] = null;\n                }\n            }\n        }\n\n        \n        public void SerializeRoot(object obj, out object serializerObject, object[] attributes, Action serializationAction = null)\n        {\n            var jObj = new JObject();\n            serializerObject = jObj;\n            try\n            {\n                SerializeAttribute(obj, \"data\", jObj, attributes);\n            }\n            catch (Exception)\n            {\n                \n                throw;\n            }\n        }\n\n        \n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, object[] attributes)\n        {\n            if (serializerObject is JObject jObj)\n            {\n                string base64 = jObj.Value<string>(propertyName);\n                if (!string.IsNullOrEmpty(base64))\n                {\n                    byte[] bytes = Convert.FromBase64String(base64);\n                    using (var ms = new MemoryStream(bytes))\n                    {\n                        var image = Image.FromStream(ms);\n                        elementValue = image;\n                    }\n                }\n            }\n        }\n\n        \n        public void DeserializeRoot(object serializerObject, object obj, object[] attributes)\n        {\n            throw new NotSupportedException(\"Direct image deserialization not supported\");\n        }\n    }\n#endif\n\n    public static class OptionalCustomTypesSerializers\n    {\n#if WINDOWS\n        \n        public static void RegisterOptionalCustomTypesSerializers(IMVCSerializer serializer)\n        {\n            \n            serializer.RegisterTypeSerializer(typeof(Bitmap), new MVCBitmapSerializerJsonDataObject());\n            serializer.RegisterTypeSerializer(typeof(Image), new MVCBitmapSerializerJsonDataObject());\n        }\n#endif\n\n        \n        public static void RegisterOptionalCustomTypesSerializersForJSON(System.Collections.Generic.Dictionary<string, IMVCSerializer> serializers)\n        {\n#if WINDOWS\n            if (serializers.TryGetValue(MVCMediaType.APPLICATION_JSON, out IMVCSerializer serializer))\n            {\n                RegisterOptionalCustomTypesSerializers(serializer);\n            }\n#endif\n        }\n    }\n}"}
{"input": "unit MyController2U;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/api/person')]\n  TMyController2 = class(TMVCController)\n  public\n    [MVCPath('')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetPerson;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Controllers.Register;\n\n{ TMyController2 }\n\ntype\n  TPerson = class\n  private\n    FName: string;\n    FAge: Integer;\n    FCountry: string;\n  public\n    property Name: string read FName write FName;\n    property Age: Integer read FAge write FAge;\n    property Country: string read FCountry write FCountry;\n  end;\n\nprocedure TMyController2.GetPerson;\nvar\n  LPerson: TPerson;\nbegin\n  LPerson := TPerson.Create;\n  LPerson.Name := 'Jo\ufffdo Ant\ufffdnio Duarte';\n  LPerson.Age := 26;\n  LPerson.Country := 'Brasil';\n  Render(LPerson);\nend;\n\ninitialization\n\nTControllersRegister.Instance.RegisterController(TMyController2, 'MyServerName');\n\nend.", "output": "public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Country { get; set; }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.Executor;\n\ninterface\n\nuses\n  MVCFramework.Commons, System.SysUtils, System.Generics.Collections,\n  JsonDataObjects, DMVC.Expert.Commons;\n\ntype\n  TMVCCodeGenerator = class\n  private\n    fIntf: TStringBuilder;\n    fImpl: TStringBuilder;\n    fCommands: TList<IGenCommand>;\n    fSource: string;\n  public\n    constructor Create; virtual;\n    destructor Destroy; override;\n    procedure Execute(Model: TJSONObject);\n    function Commands: TList<IGenCommand>;\n    function Source: String;\n    class function GenerateSource(ConfigModelRef: TJSONObject; FillerProc: TProc<TMVCCodeGenerator>): String;\n  end;\n\n\nimplementation\n\nfunction TMVCCodeGenerator.Commands: TList<IGenCommand>;\nbegin\n  Result := fCommands;\nend;\n\nconstructor TMVCCodeGenerator.Create;\nbegin\n  inherited;\n  fCommands := TList<IGenCommand>.Create;\n  fSource := '';\nend;\n\ndestructor TMVCCodeGenerator.Destroy;\nbegin\n  fCommands.Free;\n  inherited;\nend;\n\n{ TMVCProjectGenerator }\n\nprocedure TMVCCodeGenerator.Execute(Model: TJSONObject);\nvar\n  I: Integer;\nbegin\n  fSource := '';\n  fIntf := TStringBuilder.Create;\n  try\n    fImpl := TStringBuilder.Create;\n    try\n      for I := 0 to fCommands.Count - 1 do\n      begin\n        fCommands[I].ExecuteInterface(fIntf, Model);\n        fCommands[I].ExecuteImplementation(fImpl, Model);\n      end;\n      fSource := fIntf.ToString + fImpl.ToString;\n    finally\n      fImpl.Free;\n    end;\n  finally\n    fIntf.Free;\n  end;\nend;\n\nclass function TMVCCodeGenerator.GenerateSource(ConfigModelRef: TJSONObject;\n  FillerProc: TProc<TMVCCodeGenerator>): String;\nvar\n  lGenerator: TMVCCodeGenerator;\nbegin\n  lGenerator := TMVCCodeGenerator.Create;\n  try\n    lGenerator.Commands.Clear;\n    FillerProc(lGenerator);\n    lGenerator.Execute(ConfigModelRef);\n    Result := lGenerator.Source;\n  finally\n    lGenerator.Free;\n  end;\nend;\n\n{ TIntfCommand }\n\nfunction TMVCCodeGenerator.Source: String;\nbegin\n  Result := fSource;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertCodeGenExecutor\n{\n        public interface IGenCommand\n    {\n                void ExecuteInterface(StringBuilder intf, JObject model);\n        void ExecuteImplementation(StringBuilder impl, JObject model);\n    }\n\n    public class TMVCCodeGenerator\n    {\n        private StringBuilder fIntf;\n        private StringBuilder fImpl;\n        private List<IGenCommand> fCommands;\n        private string fSource;\n\n        public TMVCCodeGenerator()\n        {\n            fCommands = new List<IGenCommand>();\n            fSource = string.Empty;\n        }\n\n        public List<IGenCommand> Commands => fCommands;\n\n        public string Source => fSource;\n\n        public void Execute(JObject model)\n        {\n            fSource = string.Empty;\n            fIntf = new StringBuilder();\n            try\n            {\n                fImpl = new StringBuilder();\n                try\n                {\n                    foreach (var command in fCommands)\n                    {\n                        command.ExecuteInterface(fIntf, model);\n                        command.ExecuteImplementation(fImpl, model);\n                    }\n                    fSource = fIntf.ToString() + fImpl.ToString();\n                }\n                finally\n                {\n                    // fImpl is a managed object; no explicit disposal is required.\n                }\n            }\n            finally\n            {\n                // fIntf is a managed object; no explicit disposal is required.\n            }\n        }\n\n        \n        public static string GenerateSource(JObject configModelRef, Action<TMVCCodeGenerator> fillerProc)\n        {\n            var generator = new TMVCCodeGenerator();\n            try\n            {\n                generator.Commands.Clear();\n                fillerProc(generator);\n                generator.Execute(configModelRef);\n                return generator.Source;\n            }\n            finally\n            {\n                // No unmanaged resources to dispose.\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Authentication;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.StrUtils,\n  System.Generics.Collections,\n  System.JSON,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons;\n\ntype\n\n  TMVCBasicAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FRealm: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      );\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean\n      );\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  public\n    constructor Create(\n      const AAuthenticationHandler: IMVCAuthenticationHandler;\n      const ARealm: string = 'DelphiMVCFramework REALM'\n      ); virtual;\n  end;\n\n  TMVCCustomAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FLoginUrl: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      ); virtual;\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(\n      AContext: TWebContext;\n      const AHandled: Boolean\n      );\n\n    procedure SendResponse(AContext: TWebContext; var AHandled: Boolean; AHttpStatus: Word = HTTP_STATUS.Unauthorized);\n    procedure DoLogin(AContext: TWebContext; var AHandled: Boolean);\n    procedure DoLogout(AContext: TWebContext; var AHandled: Boolean);\n  public\n    constructor Create(\n      const AAuthenticationHandler: IMVCAuthenticationHandler;\n      const ALoginUrl: string = '/system/users/logged'\n      ); virtual;\n  end;\n\nimplementation\n\nconst\n  CONTENT_HTML_FORMAT = '<html><body><h1>%s</h1><p>%s</p></body></html>';\n  CONTENT_401_NOT_AUTHORIZED = '401: Not authorized';\n  CONTENT_403_FORBIDDEN = '403: Forbidden';\n\n  { TMVCBasicAuthenticationMiddleware }\n\nconstructor TMVCBasicAuthenticationMiddleware.Create(\n  const AAuthenticationHandler: IMVCAuthenticationHandler;\n  const ARealm: string);\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FRealm := ARealm;\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean\n      );\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string;\n  var AHandled: Boolean);\n\n  procedure SendWWWAuthenticate;\n  begin\n    AContext.LoggedUser.Clear;\n    if AContext.Request.ClientPreferHTML then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n      AContext.Response.RawWebResponse.Content :=\n        Format(CONTENT_HTML_FORMAT, [CONTENT_401_NOT_AUTHORIZED, AContext.Config[TMVCConfigKey.ServerName]]);\n    end\n    else\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_PLAIN;\n      AContext.Response.RawWebResponse.Content := CONTENT_401_NOT_AUTHORIZED + sLineBreak + AContext.Config\n        [TMVCConfigKey.ServerName];\n    end;\n    AContext.Response.StatusCode := HTTP_STATUS.Unauthorized;\n    AContext.Response.SetCustomHeader('WWW-Authenticate', 'Basic realm=' + QuotedStr(FRealm));\n    AContext.SessionStop(False);\n    AHandled := True;\n  end;\n\n  procedure Send403Forbidden;\n  begin\n    AContext.LoggedUser.Clear;\n    if AContext.Request.ClientPreferHTML then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n      AContext.Response.RawWebResponse.Content :=\n        Format(CONTENT_HTML_FORMAT, [CONTENT_403_FORBIDDEN, AContext.Config[TMVCConfigKey.ServerName]]);\n    end\n    else if AContext.Request.ContentMediaType.StartsWith(TMVCMediaType.APPLICATION_JSON) then\n    begin\n      AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n      AContext.Response.RawWebResponse.Content :=\n        '{\"status\":\"error\", \"message\":\"' + CONTENT_403_FORBIDDEN.Replace('\"', '\\\"') + '\"}';\n    end\n    else\n    begin\n      AContext.Response.ContentType := TMVCMediaType.TEXT_PLAIN;\n      AContext.Response.RawWebResponse.Content := CONTENT_403_FORBIDDEN + sLineBreak + AContext.Config\n        [TMVCConfigKey.ServerName];\n    end;\n    AContext.Response.StatusCode := HTTP_STATUS.Forbidden;\n    AContext.Response.ReasonString := AContext.Config[TMVCConfigKey.ServerName];\n    AHandled := True;\n  end;\n\nvar\n  AuthRequired: Boolean;\n  IsValid, IsAuthorized: Boolean;\n  AuthHeader, Token: string;\n  AuthPieces: TArray<string>;\n  RolesList: TList<string>;\n  SessionData: TSessionData;\n  SessionPair: TPair<string, string>;\nbegin\n  FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n  if not AuthRequired then\n  begin\n    AHandled := False;\n    Exit;\n  end;\n\n  AContext.LoggedUser.LoadFromSession(AContext.Session);\n  IsValid := AContext.LoggedUser.IsValid;\n  if not IsValid then\n  begin\n    AuthHeader := AContext.Request.Headers['Authorization'];\n    if AuthHeader.IsEmpty or (not AuthHeader.StartsWith('Basic ', True)) then\n    begin\n      SendWWWAuthenticate;\n      Exit;\n    end;\n    Token := AuthHeader.Remove(0, 'Basic '.Length).Trim;\n    AuthHeader := TMVCSerializerHelper.DecodeString(Token);\n    AuthPieces := AuthHeader.Split([':']);\n    if Length(AuthPieces) <> 2 then\n    begin\n      SendWWWAuthenticate;\n      Exit;\n    end;\n\n    RolesList := TList<string>.Create;\n    try\n      SessionData := TSessionData.Create;\n      try\n        FAuthenticationHandler.OnAuthentication(AContext, AuthPieces[0], AuthPieces[1], RolesList, IsValid,\n          SessionData);\n        if IsValid then\n        begin\n          AContext.LoggedUser.Roles.AddRange(RolesList);\n          AContext.LoggedUser.UserName := AuthPieces[0];\n          AContext.LoggedUser.LoggedSince := Now;\n          AContext.LoggedUser.Realm := FRealm;\n          AContext.LoggedUser.SaveToSession(AContext.Session);\n          for SessionPair in SessionData do\n            AContext.Session[SessionPair.Key] := SessionPair.Value;\n        end;\n      finally\n        SessionData.Free;\n      end;\n    finally\n      RolesList.Free;\n    end;\n  end;\n\n  IsAuthorized := False;\n  if IsValid then\n    FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n      AActionName, IsAuthorized);\n\n  if IsAuthorized then\n    AHandled := False\n  else\n  begin\n    if IsValid then\n      Send403Forbidden\n    else\n    begin\n      SendWWWAuthenticate;\n    end;\n  end;\nend;\n\nprocedure TMVCBasicAuthenticationMiddleware.OnBeforeRouting(\n  AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  AHandled := False;\nend;\n\n{ TMVCCustomAuthenticationMiddleware }\n\nconstructor TMVCCustomAuthenticationMiddleware.Create(\n  const AAuthenticationHandler: IMVCAuthenticationHandler;\n  const ALoginUrl: string);\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FLoginUrl := ALoginUrl.ToLower;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.DoLogin(\n  AContext: TWebContext;\n  var AHandled: Boolean);\nvar\n  Jo: TJSONObject;\n  UserName, Password: string;\n  RolesList: TList<string>;\n  SessionPair: TPair<string, string>;\n  SessionData: TSessionData;\n  IsValid: Boolean;\nbegin\n  AContext.SessionStop(False);\n  AContext.LoggedUser.Clear;\n  if not AContext.Request.HasBody then\n  begin\n    AHandled := True;\n    AContext.Response.StatusCode := HTTP_STATUS.BadRequest;\n    AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n    AContext.Response.RawWebResponse.Content :=\n      '{\"status\":\"error\", \"message\":\"username and password are mandatory in the body request as json object\"}';\n    Exit;\n  end;\n\n  Jo := TJSONObject.ParseJSONValue(AContext.Request.Body) as TJSONObject;\n  try\n    if not Assigned(Jo) then\n    begin\n      AHandled := True;\n      SendResponse(AContext, AHandled, HTTP_STATUS.BadRequest);\n      Exit;\n    end;\n\n    UserName := EmptyStr;\n    if (Jo.Get('username') <> nil) then\n      UserName := Jo.Get('username').JsonValue.Value;\n\n    Password := EmptyStr;\n    if (Jo.Get('password') <> nil) then\n      Password := Jo.Get('password').JsonValue.Value;\n\n    if UserName.IsEmpty or Password.IsEmpty then\n    begin\n      AHandled := True;\n      SendResponse(AContext, AHandled);\n      Exit;\n    end;\n\n    RolesList := TList<string>.Create;\n    try\n      SessionData := TSessionData.Create;\n      try\n        IsValid := False;\n        FAuthenticationHandler.OnAuthentication(AContext, UserName, Password, RolesList, IsValid, SessionData);\n        if not IsValid then\n        begin\n          SendResponse(AContext, AHandled);\n          Exit;\n        end;\n\n        AContext.LoggedUser.Roles.AddRange(RolesList);\n        AContext.LoggedUser.UserName := UserName;\n        AContext.LoggedUser.LoggedSince := Now;\n        AContext.LoggedUser.Realm := 'custom';\n        AContext.LoggedUser.SaveToSession(AContext.Session);\n\n        for SessionPair in SessionData do\n          AContext.Session[SessionPair.Key] := SessionPair.Value;\n\n        AContext.Response.StatusCode := HTTP_STATUS.OK;\n        AContext.Response.CustomHeaders.Values['X-LOGOUT-URL'] := FLoginUrl;\n        AContext.Response.CustomHeaders.Values['X-LOGOUT-METHOD'] := 'DELETE';\n        AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n        AContext.Response.RawWebResponse.Content := '{\"status\":\"OK\"}';\n\n        AHandled := True;\n      finally\n        SessionData.Free;\n      end;\n    finally\n      RolesList.Free;\n    end;\n  finally\n    Jo.Free;\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.DoLogout(\n  AContext: TWebContext; var AHandled: Boolean);\nbegin\n  AContext.SessionStop(False);\n  SendResponse(AContext, AHandled, HTTP_STATUS.OK);\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string;\n  var AHandled: Boolean);\nvar\n  IsValid: Boolean;\n  IsAuthorized: Boolean;\n  AuthRequired: Boolean;\nbegin\n  FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n  if not AuthRequired then\n  begin\n    AHandled := False;\n    Exit;\n  end;\n\n  AContext.LoggedUser.LoadFromSession(AContext.Session);\n  IsValid := AContext.LoggedUser.IsValid;\n  if not IsValid then\n  begin\n    AContext.SessionStop(False);\n    SendResponse(AContext, AHandled);\n    Exit;\n  end;\n\n  IsAuthorized := False;\n  FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n    AActionName, IsAuthorized);\n  if IsAuthorized then\n    AHandled := False\n  else\n  begin\n    if IsValid then\n      SendResponse(AContext, AHandled, HTTP_STATUS.Forbidden)\n    else\n      SendResponse(AContext, AHandled, HTTP_STATUS.Unauthorized);\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.OnBeforeRouting(\n  AContext: TWebContext; var AHandled: Boolean);\nbegin\n  if (AContext.Request.PathInfo.ToLower = FLoginUrl) then\n  begin\n    AHandled := False;\n\n    if (AContext.Request.HTTPMethod = httpPOST) and\n      (AContext.Request.ContentType.StartsWith(TMVCMediaType.APPLICATION_JSON)) then\n      DoLogin(AContext, AHandled);\n\n    if (AContext.Request.HTTPMethod = httpDELETE) then\n      DoLogout(AContext, AHandled);\n  end;\nend;\n\nprocedure TMVCCustomAuthenticationMiddleware.SendResponse(\n  AContext: TWebContext; var AHandled: Boolean; AHttpStatus: Word);\nvar\n  IsPositive: Boolean;\n  Msg: string;\nbegin\n  AContext.LoggedUser.Clear;\n  AContext.Response.CustomHeaders.Values['X-LOGIN-URL'] := FLoginUrl;\n  AContext.Response.CustomHeaders.Values['X-LOGIN-METHOD'] := 'POST';\n  AContext.Response.StatusCode := AHttpStatus;\n  if AContext.Request.ClientPreferHTML then\n  begin\n    AContext.Response.ContentType := TMVCMediaType.TEXT_HTML;\n    AContext.Response.RawWebResponse.Content :=\n      Format(CONTENT_HTML_FORMAT, [IntToStr(AHttpStatus), AContext.Config[TMVCConfigKey.ServerName]]);\n  end\n  else\n  begin\n    IsPositive := (AHttpStatus div 100) = 2;\n    Msg := IfThen(IsPositive, 'OK', 'KO');\n    AContext.Response.ContentType := TMVCMediaType.APPLICATION_JSON;\n    AContext.Response.RawWebResponse.Content := '{\"status\":\"' + Msg + '\", \"message\":\"' + IntToStr(AHttpStatus) + '\"}';\n  end;\n  AHandled := True;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Text.Json;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Commons;\n\nnamespace MVCFramework.Middleware.Authentication\n{\n    \n    public class MVCBasicAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly string _realm;\n\n        private const string CONTENT_HTML_FORMAT = \"<html><body><h1>{0}</h1><p>{1}</p></body></html>\";\n        private const string CONTENT_401_NOT_AUTHORIZED = \"401: Not authorized\";\n        private const string CONTENT_403_FORBIDDEN = \"403: Forbidden\";\n\n        public MVCBasicAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            string realm = \"DelphiMVCFramework REALM\")\n        {\n            _authenticationHandler = authenticationHandler;\n            _realm = realm;\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            \n            handled = false;\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            \n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                return;\n            }\n\n            \n            context.LoggedUser.LoadFromSession(context.Session);\n            bool isValid = context.LoggedUser.IsValid;\n\n            \n            if (!isValid)\n            {\n                string authHeader = context.Request.Headers[\"Authorization\"];\n                if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith(\"Basic \", StringComparison.OrdinalIgnoreCase))\n                {\n                    SendWWWAuthenticate(context, ref handled);\n                    return;\n                }\n\n                \n                string token = authHeader.Substring(\"Basic \".Length).Trim();\n                \n                authHeader = MVCSerializerHelper.DecodeString(token);\n                string[] authPieces = authHeader.Split(':');\n                if (authPieces.Length != 2)\n                {\n                    SendWWWAuthenticate(context, ref handled);\n                    return;\n                }\n\n                var rolesList = new List<string>();\n                SessionData sessionData = new SessionData();\n                _authenticationHandler.OnAuthentication(context, authPieces[0], authPieces[1], rolesList, out isValid, sessionData);\n                if (isValid)\n                {\n                    context.LoggedUser.Roles.AddRange(rolesList);\n                    context.LoggedUser.UserName = authPieces[0];\n                    context.LoggedUser.LoggedSince = DateTime.Now;\n                    context.LoggedUser.Realm = _realm;\n                    context.LoggedUser.SaveToSession(context.Session);\n                    foreach (var pair in sessionData)\n                    {\n                        context.Session[pair.Key] = pair.Value;\n                    }\n                }\n            }\n\n            \n            bool isAuthorized = false;\n            if (isValid)\n            {\n                _authenticationHandler.OnAuthorization(\n                    context,\n                    context.LoggedUser.Roles,\n                    controllerQualifiedClassName,\n                    actionName,\n                    out isAuthorized);\n            }\n\n            if (isAuthorized)\n            {\n                handled = false;\n            }\n            else\n            {\n                if (isValid)\n                    Send403Forbidden(context, ref handled);\n                else\n                    SendWWWAuthenticate(context, ref handled);\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No post-action processing in basic authentication.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Nothing to do after routing.\n        }\n\n        #region Helper Methods\n\n        private void SendWWWAuthenticate(WebContext context, ref bool handled)\n        {\n            context.LoggedUser.Clear();\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    CONTENT_HTML_FORMAT,\n                    CONTENT_401_NOT_AUTHORIZED,\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else\n            {\n                context.Response.ContentType = MediaType.TextPlain;\n                context.Response.RawWebResponse.Content = CONTENT_401_NOT_AUTHORIZED + Environment.NewLine +\n                    context.Config[ConfigKey.ServerName];\n            }\n            context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n            context.Response.SetCustomHeader(\"WWW-Authenticate\", $\"Basic realm={Quote(_realm)}\");\n            context.SessionStop(false);\n            handled = true;\n        }\n\n        private void Send403Forbidden(WebContext context, ref bool handled)\n        {\n            context.LoggedUser.Clear();\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    CONTENT_HTML_FORMAT,\n                    CONTENT_403_FORBIDDEN,\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else if (context.Request.ContentMediaType.StartsWith(MediaType.ApplicationJson, StringComparison.OrdinalIgnoreCase))\n            {\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content = \"{\\\"status\\\":\\\"error\\\", \\\"message\\\":\\\"\" +\n                    CONTENT_403_FORBIDDEN.Replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"}\";\n            }\n            else\n            {\n                context.Response.ContentType = MediaType.TextPlain;\n                context.Response.RawWebResponse.Content = CONTENT_403_FORBIDDEN + Environment.NewLine +\n                    context.Config[ConfigKey.ServerName];\n            }\n            context.Response.StatusCode = (int)HttpStatusCode.Forbidden;\n            context.Response.ReasonString = context.Config[ConfigKey.ServerName];\n            handled = true;\n        }\n\n        private string Quote(string s) => $\"\\\"{s}\\\"\";\n\n        #endregion\n    }\n\n    \n    public class MVCCustomAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly string _loginUrl;\n\n        public MVCCustomAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            string loginUrl = \"/system/users/logged\")\n        {\n            _authenticationHandler = authenticationHandler;\n            _loginUrl = loginUrl.ToLower();\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            if (context.Request.PathInfo.ToLower() == _loginUrl)\n            {\n                handled = false;\n                if (context.Request.HTTPMethod.Equals(\"POST\", StringComparison.OrdinalIgnoreCase) &&\n                    context.Request.ContentType.StartsWith(MediaType.ApplicationJson, StringComparison.OrdinalIgnoreCase))\n                {\n                    DoLogin(context, ref handled);\n                }\n                else if (context.Request.HTTPMethod.Equals(\"DELETE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    DoLogout(context, ref handled);\n                }\n            }\n        }\n\n        public virtual void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                return;\n            }\n            context.LoggedUser.LoadFromSession(context.Session);\n            bool isValid = context.LoggedUser.IsValid;\n            if (!isValid)\n            {\n                context.SessionStop(false);\n                SendResponse(context, ref handled);\n                return;\n            }\n            bool isAuthorized = false;\n            _authenticationHandler.OnAuthorization(\n                context,\n                context.LoggedUser.Roles,\n                controllerQualifiedClassName,\n                actionName,\n                out isAuthorized);\n            if (isAuthorized)\n            {\n                handled = false;\n            }\n            else\n            {\n                if (isValid)\n                    SendResponse(context, ref handled, HttpStatusCode.Forbidden);\n                else\n                    SendResponse(context, ref handled, HttpStatusCode.Unauthorized);\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement post-action processing if needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Nothing to do.\n        }\n\n        #region Protected Helpers\n\n        protected void SendResponse(WebContext context, ref bool handled, HttpStatusCode status = HttpStatusCode.Unauthorized)\n        {\n            context.LoggedUser.Clear();\n            context.Response.SetCustomHeader(\"X-LOGIN-URL\", _loginUrl);\n            context.Response.SetCustomHeader(\"X-LOGIN-METHOD\", \"POST\");\n            context.Response.StatusCode = (int)status;\n            if (context.Request.ClientPreferHTML)\n            {\n                context.Response.ContentType = MediaType.TextHtml;\n                context.Response.RawWebResponse.Content = string.Format(\n                    MVCBasicAuthenticationMiddleware.CONTENT_HTML_FORMAT,\n                    ((int)status).ToString(),\n                    context.Config[ConfigKey.ServerName]);\n            }\n            else\n            {\n                bool isPositive = (((int)status) / 100) == 2;\n                string msg = isPositive ? \"OK\" : \"KO\";\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content = $\"{{\\\"status\\\":\\\"{msg}\\\", \\\"message\\\":\\\"{(int)status}\\\"}}\";\n            }\n            handled = true;\n        }\n\n        protected void DoLogin(WebContext context, ref bool handled)\n        {\n            context.SessionStop(false);\n            context.LoggedUser.Clear();\n            if (!context.Request.HasBody)\n            {\n                handled = true;\n                context.Response.StatusCode = (int)HttpStatusCode.BadRequest;\n                context.Response.ContentType = MediaType.ApplicationJson;\n                context.Response.RawWebResponse.Content =\n                    \"{\\\"status\\\":\\\"error\\\", \\\"message\\\":\\\"username and password are mandatory in the body request as json object\\\"}\";\n                return;\n            }\n\n            \n            JsonDocument doc = JsonDocument.Parse(context.Request.Body);\n            JsonElement root = doc.RootElement;\n            string userName = root.TryGetProperty(\"username\", out JsonElement userProp)\n                ? userProp.GetString() ?? string.Empty : string.Empty;\n            string password = root.TryGetProperty(\"password\", out JsonElement passProp)\n                ? passProp.GetString() ?? string.Empty : string.Empty;\n\n            if (string.IsNullOrEmpty(userName) || string.IsNullOrEmpty(password))\n            {\n                handled = true;\n                SendResponse(context, ref handled);\n                return;\n            }\n\n            var rolesList = new List<string>();\n            SessionData sessionData = new SessionData();\n            bool isValid = false;\n            _authenticationHandler.OnAuthentication(context, userName, password, rolesList, out isValid, sessionData);\n            if (!isValid)\n            {\n                SendResponse(context, ref handled);\n                return;\n            }\n\n            context.LoggedUser.Roles.AddRange(rolesList);\n            context.LoggedUser.UserName = userName;\n            context.LoggedUser.LoggedSince = DateTime.Now;\n            context.LoggedUser.Realm = \"custom\";\n            context.LoggedUser.SaveToSession(context.Session);\n\n            foreach (var pair in sessionData)\n            {\n                context.Session[pair.Key] = pair.Value;\n            }\n\n            context.Response.StatusCode = (int)HttpStatusCode.OK;\n            context.Response.SetCustomHeader(\"X-LOGOUT-URL\", _loginUrl);\n            context.Response.SetCustomHeader(\"X-LOGOUT-METHOD\", \"DELETE\");\n            context.Response.ContentType = MediaType.ApplicationJson;\n            context.Response.RawWebResponse.Content = \"{\\\"status\\\":\\\"OK\\\"}\";\n            handled = true;\n        }\n\n        protected void DoLogout(WebContext context, ref bool handled)\n        {\n            context.SessionStop(false);\n            SendResponse(context, ref handled, HttpStatusCode.OK);\n        }\n\n        #endregion\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.DotEnv;\n\ninterface\n\nuses\n  System.Generics.Collections,\n  MVCFramework.DotEnv.Parser,\n  System.SysUtils;\n\ntype\n{$SCOPEDENUMS ON}\n  TMVCDotEnvPriority = (FileThenEnv, EnvThenFile, OnlyFile, OnlyEnv);\n\n  EMVCDotEnv = class(Exception)\n\n  end;\n\n  IMVCDotEnv = interface\n    ['{5FD2C3CB-0895-4CCD-985F-27394798E4A8}']\n    function Env(const Name: string): string; overload;\n    function Env(const Name: string; const DefaultValue: String): string; overload;\n    function Env(const Name: string; const DefaultValue: Integer): Integer; overload;\n    function Env(const Name: string; const DefaultValue: Boolean): Boolean; overload;\n    procedure RequireKeys(const Keys: TArray<String>);\n    function SaveToFile(const FileName: String): IMVCDotEnv;\n    function ToArray(): TArray<String>;\n  end;\n\n  IMVCDotEnvBuilder = interface\n    ['{1A5EDD44-7226-40BC-A8EE-789E27522392}']\n    function UseStrategy(const Strategy: TMVCDotEnvPriority = TMVCDotEnvPriority.EnvThenFile): IMVCDotEnvBuilder;\n    function SkipDefaultEnv: IMVCDotEnvBuilder;\n    function UseLogger( const Logger: TProc<String>): IMVCDotEnvBuilder;\n    function UseProfile(const ProfileName: String): IMVCDotEnvBuilder; overload;\n    function UseProfile(const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder; overload;\n    function ClearProfiles: IMVCDotEnvBuilder;\n    function Build(const DotEnvPath: string = ''): IMVCDotEnv; overload;\n  end;\n\nfunction NewDotEnv: IMVCDotEnvBuilder;\n\nimplementation\n\nuses\n  System.IOUtils,\n  System.TypInfo,\n  System.Classes,\n  MVCFramework.Commons;\n\nvar\n  gDotEnv: IMVCDotEnvBuilder = nil;\n\n{ TDotEnv }\n\ntype\n{$SCOPEDENUMS ON}\n  TdotEnvEngineState = (created, building, built);\n  TMVCDotEnv = class(TInterfacedObject, IMVCDotEnv, IMVCDotEnvBuilder)\n  strict private\n    fState: TdotEnvEngineState;\n    fPriority: TMVCDotEnvPriority;\n    fEnvPath: string;\n    fEnvDict: TMVCDotEnvDictionary;\n    fLoggerProc: TProc<String>;\n    fProfiles: TList<String>;\n    fSkipDefaultEnv: Boolean;\n    procedure DoLog(const Value: String);\n    procedure ReadEnvFile;\n    function GetDotEnvVar(const key: string): string;\n    function GetBuiltInVariable(const VarName: String; out Value: String): Boolean;\n    function ExplodePlaceholders(const Value: string): string;\n    procedure PopulateDictionary(const EnvDict: TDictionary<string, string>; const EnvFilePath: String);\n    procedure CheckAlreadyBuilt;\n    procedure ExplodeReferences;\n  strict protected\n    function UseStrategy(const Priority: TMVCDotEnvPriority = TMVCDotEnvPriority.EnvThenFile): IMVCDotEnvBuilder; overload;\n    function SkipDefaultEnv: IMVCDotEnvBuilder;\n    function UseProfile(const ProfileName: String): IMVCDotEnvBuilder; overload;\n    function UseProfile(const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder; overload;\n    function UseLogger(const LoggerProc: TProc<String>): IMVCDotEnvBuilder;\n    function ClearProfiles: IMVCDotEnvBuilder;\n    function Build(const DotEnvDirectory: string = ''): IMVCDotEnv; overload;\n    function Env(const Name: string): string; overload;\n    function Env(const Name: string; const DefaultValue: String): string; overload;\n    function Env(const Name: string; const DefaultValue: Integer): Integer; overload;\n    function Env(const Name: string; const DefaultValue: Boolean): Boolean; overload;\n    procedure RequireKeys(const Keys: TArray<String>);\n    function SaveToFile(const FileName: String): IMVCDotEnv;\n    function ToArray(): TArray<String>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n  end;\n\n\nfunction TMVCDotEnv.GetBuiltInVariable(const VarName: String;\n  out Value: String): Boolean;\nvar\n  lVarName: string;\nbegin\n  Result := False;\n  lVarName := VarName.ToLower.Remove(VarName.Length -2, 2).Remove(0,2);\n\n  if lVarName = 'os' then\n  begin\n    Value := TOSVersion.Name;\n    Exit(True);\n  end;\n\n  if lVarName = 'home' then\n  begin\n    Value := AppPath;\n    Exit(True);\n  end;\n\n  if lVarName = 'dmvc.version' then\n  begin\n    Value := DMVCFRAMEWORK_VERSION;\n    Exit(True);\n  end;\n  DoLog('Unknown built-in env var named ' + lVarName + '.');\nend;\n\nfunction TMVCDotEnv.GetDotEnvVar(const key: string): string;\nbegin\n  fEnvDict.TryGetValue(key, Result);\nend;\n\nfunction TMVCDotEnv.Env(const Name: string): string;\nvar\n  lTmp: String;\nbegin\n  if fState = TdotEnvEngineState.created then\n  begin\n    raise EMVCDotEnv.Create('dotEnv Engine not built');\n  end;\n\n  if fPriority in [TMVCDotEnvPriority.FileThenEnv, TMVCDotEnvPriority.OnlyFile] then\n  begin\n    Result := GetDotEnvVar(name);\n    if Result.Contains('${' + Name + '}') then\n    begin\n      raise EMVCDotEnv.CreateFmt('Configuration loop detected with key \"%s\"', [Name]);\n    end;\n\n    if fPriority = TMVCDotEnvPriority.OnlyFile then\n    begin\n      // OnlyFile\n      Exit;\n    end;\n    // FileThenEnv\n    if Result.IsEmpty then\n    begin\n      Exit(ExplodePlaceholders(GetEnvironmentVariable(Name)));\n    end;\n  end\n  else if fPriority in [TMVCDotEnvPriority.EnvThenFile, TMVCDotEnvPriority.OnlyEnv] then\n  begin\n    Result := ExplodePlaceholders(GetEnvironmentVariable(Name));\n    if fPriority = TMVCDotEnvPriority.OnlyEnv then\n    begin\n      // OnlyEnv\n      Exit;\n    end;\n    // EnvThenFile\n    if Result.IsEmpty then\n    begin\n      lTmp := GetDotEnvVar(Name);\n      if lTmp.Contains('${' + Name + '}') then\n      begin\n        raise EMVCDotEnv.CreateFmt('Configuration loop detected with key \"%s\"', [Name]);\n      end;\n      Exit(lTmp);\n    end;\n  end\n  else\n  begin\n    raise EMVCDotEnv.CreateFmt('Unknown dotEnv Priority: %s', [GetEnumName(TypeInfo(TMVCDotEnvPriority), Ord(fPriority))]);\n  end;\nend;\n\nfunction TMVCDotEnv.UseLogger(\n  const LoggerProc: TProc<String>): IMVCDotEnvBuilder;\nbegin\n  if Assigned(fLoggerProc) then\n  begin\n    raise EMVCDotEnv.Create('Logger already set');\n  end;\n  fLoggerProc := LoggerProc;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseProfile(\n  const ProfileDelegate: TFunc<String>): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Add(ProfileDelegate());\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseProfile(const ProfileName: String): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Add(ProfileName);\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.UseStrategy(const Priority: TMVCDotEnvPriority): IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  Result := Self;\n  fPriority := Priority;\nend;\n\nfunction TMVCDotEnv.Build(const DotEnvDirectory: string): IMVCDotEnv;\nvar\n  lAllProfiles: TArray<String>;\nbegin\n  if fState <> TdotEnvEngineState.created then\n  begin\n    raise EMVCDotEnv.Create('dotEnv engine already built');\n  end;\n  fState := TdotEnvEngineState.building;\n  Result := Self;\n  fEnvPath := TDirectory.GetParent(GetModuleName(HInstance));\n  if not DotEnvDirectory.IsEmpty then\n  begin\n    fEnvPath := TPath.Combine(fEnvPath, DotEnvDirectory);\n  end;\n  DoLog('Path = ' + fEnvPath);\n  fEnvDict.Clear;\n  lAllProfiles := ['default'] + fProfiles.ToArray();\n  if fSkipDefaultEnv then\n  begin\n    Delete(lAllProfiles, 0, 1);\n  end;\n  DoLog('Active profile/s priority = [' + String.Join(',', lAllProfiles) +\n    '] (Priority: ' + GetEnumName(TypeInfo(TMVCDotEnvPriority), Ord(fPriority)) + ')');\n  ReadEnvFile;\n  ExplodeReferences;\n  fState := TdotEnvEngineState.built;\nend;\n\nprocedure TMVCDotEnv.CheckAlreadyBuilt;\nbegin\n  if fState in [TdotEnvEngineState.built] then\n  begin\n    raise Exception.Create('DotEnv Engine Already Built');\n  end;\nend;\n\nfunction TMVCDotEnv.ClearProfiles: IMVCDotEnvBuilder;\nbegin\n  CheckAlreadyBuilt;\n  fProfiles.Clear;\n  Result := Self;\nend;\n\nconstructor TMVCDotEnv.Create;\nbegin\n  inherited;\n  fState := TdotEnvEngineState.created;\n  fProfiles := TList<String>.Create;\n  fEnvDict := TMVCDotEnvDictionary.Create;\n  fEnvPath := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0)));\n  fPriority := TMVCDotEnvPriority.EnvThenFile;\n  fSkipDefaultEnv := False;\nend;\n\ndestructor TMVCDotEnv.Destroy;\nbegin\n  FreeAndNil(fEnvDict);\n  fProfiles.Free;\n  inherited;\nend;\n\nprocedure TMVCDotEnv.DoLog(const Value: String);\nbegin\n  if Assigned(fLoggerProc) then\n  begin\n    fLoggerProc(Value);\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name, DefaultValue: String): string;\nbegin\n  Result := Env(Name);\n  if Result.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name: string;\n  const DefaultValue: Integer): Integer;\nvar\n  lTmp: string;\nbegin\n  lTmp := Env(Name);\n  if lTmp.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end\n  else\n  begin\n    if not TryStrToInt(lTmp.Trim, Result) then\n    begin\n      raise EMVCDotEnv.CreateFmt('Env \"%s\" is not a valid integer [Current Value: \"%s\"]', [Name, lTmp]);\n    end;\n  end;\nend;\n\nfunction TMVCDotEnv.Env(const Name: string;\n  const DefaultValue: Boolean): Boolean;\nvar\n  lTmp: string;\nbegin\n  lTmp := Env(Name);\n  if lTmp.IsEmpty then\n  begin\n    Result := DefaultValue;\n  end\n  else\n  begin\n    lTmp := lTmp.Trim.ToLower;\n    if (lTmp = 'yes') or (lTmp='1') or (lTmp='true') then\n    begin\n      Exit(True);\n    end;\n    if (lTmp = 'no') or (lTmp='0') or (lTmp='false') then\n    begin\n      Exit(False);\n    end;\n    if not TryStrToBool(lTmp, Result) then\n    begin\n      raise EMVCDotEnv.CreateFmt('Env \"%s\" is not a valid boolean [Current Value: \"%s\"]', [Name, lTmp]);\n    end;\n  end;\nend;\n\nfunction TMVCDotEnv.ExplodePlaceholders(const Value: string): string;\nvar\n  lStartPos, lEndPos: Integer;\n  lKey, lValue: string;\nbegin\n  Result := Value;\n  while Result.IndexOf('${') > -1 do\n  begin\n    lStartPos := Result.IndexOf('${');\n    lEndPos := Result.IndexOf('}');\n    if (lEndPos = -1) or (lEndPos < lStartPos) then\n    begin\n      raise EMVCDotEnv.Create('Unclosed expansion (${...}) at: ' + Value);\n    end;\n    lKey := Result.Substring(lStartPos + 2, lEndPos - (lStartPos + 2));\n\n    if lKey.StartsWith('__') and lKey.EndsWith('__') then\n    begin\n      if not GetBuiltInVariable(lKey, lValue) then\n      begin\n        lValue := Env(lKey);\n      end\n    end\n    else\n    begin\n      lValue := Env(lKey);\n    end;\n    Result := StringReplace(Result, '${' + lKey + '}', lValue, [rfReplaceAll]);\n  end;\nend;\n\nprocedure TMVCDotEnv.ExplodeReferences;\nvar\n  lKey: String;\nbegin\n  for lKey in fEnvDict.Keys do\n  begin\n    fEnvDict.AddOrSetValue(lKey, ExplodePlaceholders(fEnvDict[lKey]));\n  end;\nend;\n\nfunction TMVCDotEnv.SaveToFile(const FileName: String): IMVCDotEnv;\nvar\n  lKeys: TArray<String>;\n  lKey: String;\n  lSL: TStringList;\nbegin\n  lKeys := fEnvDict.Keys.ToArray;\n  TArray.Sort<String>(lKeys);\n  lSL := TStringList.Create;\n  try\n    for lKey in lKeys do\n    begin\n      lSL.Values[lKey] := GetDotEnvVar(lKey);\n    end;\n    lSL.SaveToFile(FileName);\n  finally\n    lSL.Free;\n  end;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.SkipDefaultEnv: IMVCDotEnvBuilder;\nbegin\n  fSkipDefaultEnv := True;\n  Result := Self;\nend;\n\nfunction TMVCDotEnv.ToArray: TArray<String>;\nvar\n  lKeys: TArray<String>;\n  lKey: String;\n  I: Integer;\nbegin\n  lKeys := fEnvDict.Keys.ToArray;\n  TArray.Sort<String>(lKeys);\n  SetLength(Result, Length(lKeys));\n  I := 0;\n  for lKey in lKeys do\n  begin\n    Result[I] := lKey + '=' + GetDotEnvVar(lKey);\n    Inc(I);\n  end;\nend;\n\nprocedure TMVCDotEnv.PopulateDictionary(const EnvDict: TDictionary<string, string>; const EnvFilePath: String);\nvar\n  lDotEnvCode: string;\n  lParser: TMVCDotEnvParser;\nbegin\n  if not TFile.Exists(EnvFilePath) then\n  begin\n    DoLog('Missed file ' + EnvFilePath);\n    Exit;\n  end;\n\n  lDotEnvCode := TFile.ReadAllText(EnvFilePath);\n  lParser := TMVCDotEnvParser.Create;\n  try\n    lParser.Parse(fEnvDict, lDotEnvCode);\n    DoLog('Applied file ' + EnvFilePath);\n  finally\n    lParser.Free;\n  end;\nend;\n\nprocedure TMVCDotEnv.ReadEnvFile;\nvar\n  lProfileEnvPath: string;\n  I: Integer;\nbegin\n  if not fSkipDefaultEnv then\n  begin\n    PopulateDictionary(fEnvDict, IncludeTrailingPathDelimiter(fEnvPath) + '.env');\n  end;\n  for I := 0 to fProfiles.Count - 1 do\n  begin\n    lProfileEnvPath := TPath.Combine(fEnvPath, '.env') + '.' + fProfiles[I];\n    PopulateDictionary(fEnvDict, lProfileEnvPath);\n  end;\nend;\n\nprocedure TMVCDotEnv.RequireKeys(const Keys: TArray<String>);\nvar\n  lKey: String;\n  lNotFoundKeys: TArray<String>;\n  lMsg: string;\nbegin\n  if Length(Keys) = 0 then\n  begin\n    Exit;\n  end;\n  DoLog('Checking required keys: ' + String.Join(', ', Keys));\n  lNotFoundKeys := [];\n  for lKey in Keys do\n  begin\n    if Env(lKey).IsEmpty then\n    begin\n      lNotFoundKeys := lNotFoundKeys + [lKey];\n    end;\n  end;\n  if Length(lNotFoundKeys) > 0 then\n  begin\n    lMsg := 'Required keys not found: ' + String.Join(', ', lNotFoundKeys);\n    DoLog(lMsg);\n    raise EMVCDotEnv.Create(lMsg);\n  end;\nend;\n\nfunction NewDotEnv: IMVCDotEnvBuilder;\nbegin\n  Result := TMVCDotEnv.Create;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace MVCFramework.DotEnv\n{\n    #region Exceptions and Enums\n\n    \n    public class DotEnvException : Exception\n    {\n        public DotEnvException(string message) : base(message) { }\n    }\n\n    public enum DotEnvPriority\n    {\n        FileThenEnv,\n        EnvThenFile,\n        OnlyFile,\n        OnlyEnv\n    }\n\n    #endregion\n\n    #region Interfaces\n\n    public interface IMVCDotEnv\n    {\n        string Env(string name);\n        string Env(string name, string defaultValue);\n        int Env(string name, int defaultValue);\n        bool Env(string name, bool defaultValue);\n        void RequireKeys(string[] keys);\n        IMVCDotEnv SaveToFile(string fileName);\n        string[] ToArray();\n    }\n\n    public interface IMVCDotEnvBuilder : IMVCDotEnv\n    {\n        IMVCDotEnvBuilder UseStrategy(DotEnvPriority strategy = DotEnvPriority.EnvThenFile);\n        IMVCDotEnvBuilder SkipDefaultEnv();\n        IMVCDotEnvBuilder UseLogger(Action<string> logger);\n        IMVCDotEnvBuilder UseProfile(string profileName);\n        IMVCDotEnvBuilder UseProfile(Func<string> profileDelegate);\n        IMVCDotEnvBuilder ClearProfiles();\n        IMVCDotEnv Build(string dotEnvDirectory = \"\");\n    }\n\n    #endregion\n\n    #region Public Static API\n\n    public static class DotEnv\n    {\n        private static IMVCDotEnvBuilder _instance;\n\n        public static IMVCDotEnvBuilder NewDotEnv()\n        {\n            if (_instance == null)\n            {\n                _instance = new MVCDotEnv();\n            }\n            return _instance;\n        }\n    }\n\n    #endregion\n\n    #region Implementation\n\n    internal class MVCDotEnv : IMVCDotEnvBuilder\n    {\n        #region Private Types and Fields\n\n        private enum DotEnvEngineState { Created, Building, Built }\n\n        private DotEnvEngineState _state;\n        private DotEnvPriority _priority;\n        private string _envPath;\n        private readonly Dictionary<string, string> _envDict;\n        private Action<string> _loggerProc;\n        private readonly List<string> _profiles;\n        private bool _skipDefaultEnv;\n\n        #endregion\n\n        #region Constructor / Destructor\n\n        public MVCDotEnv()\n        {\n            _state = DotEnvEngineState.Created;\n            _profiles = new List<string>();\n            _envDict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            _envPath = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) ?? \"\";\n            _envPath = Path.EndsInDirectorySeparator(_envPath) ? _envPath : _envPath + Path.DirectorySeparatorChar;\n            _priority = DotEnvPriority.EnvThenFile;\n            _skipDefaultEnv = false;\n        }\n\n        #endregion\n\n        #region Private Helper Methods\n\n        private void DoLog(string value)\n        {\n            _loggerProc?.Invoke(value);\n        }\n\n        private void CheckAlreadyBuilt()\n        {\n            if (_state == DotEnvEngineState.Built)\n            {\n                throw new Exception(\"DotEnv Engine Already Built\");\n            }\n        }\n\n        private void PopulateDictionary(Dictionary<string, string> envDict, string envFilePath)\n        {\n            if (!File.Exists(envFilePath))\n            {\n                DoLog($\"Missed file {envFilePath}\");\n                return;\n            }\n\n            string dotenvCode = File.ReadAllText(envFilePath);\n            DotEnvParser.Parse(envDict, dotenvCode);\n            DoLog($\"Applied file {envFilePath}\");\n        }\n\n        private void ReadEnvFile()\n        {\n            if (!_skipDefaultEnv)\n            {\n                PopulateDictionary(_envDict, Path.Combine(_envPath, \".env\"));\n            }\n            foreach (var profile in _profiles)\n            {\n                string profileEnvPath = Path.Combine(_envPath, $\".env.{profile}\");\n                PopulateDictionary(_envDict, profileEnvPath);\n            }\n        }\n\n        private string ExplodePlaceholders(string value)\n        {\n            string result = value;\n            while (result.Contains(\"${\"))\n            {\n                int startPos = result.IndexOf(\"${\", StringComparison.Ordinal);\n                int endPos = result.IndexOf(\"}\", startPos, StringComparison.Ordinal);\n                if (endPos == -1 || endPos < startPos)\n                {\n                    throw new DotEnvException(\"Unclosed expansion (${...}) at: \" + value);\n                }\n                string key = result.Substring(startPos + 2, endPos - (startPos + 2));\n\n                string replacement = \"\";\n                if (key.StartsWith(\"__\") && key.EndsWith(\"__\"))\n                {\n                    if (!GetBuiltInVariable(key, out replacement))\n                    {\n                        replacement = Env(key);\n                    }\n                }\n                else\n                {\n                    replacement = Env(key);\n                }\n                result = result.Replace($\"${{{key}}}\", replacement);\n            }\n            return result;\n        }\n\n        private void ExplodeReferences()\n        {\n            foreach (var key in _envDict.Keys.ToList())\n            {\n                _envDict[key] = ExplodePlaceholders(_envDict[key]);\n            }\n        }\n\n        private bool GetBuiltInVariable(string varName, out string value)\n        {\n            string lVarName = varName.ToLower(); \n            if (lVarName == \"__os__\")\n            {\n                value = System.Runtime.InteropServices.RuntimeInformation.OSDescription;\n                return true;\n            }\n            if (lVarName == \"__home__\")\n            {\n                value = AppPath();\n                return true;\n            }\n            if (lVarName == \"__dmvc.version__\")\n            {\n                value = DMVCFRAMEWORK_VERSION();\n                return true;\n            }\n            DoLog(\"Unknown built-in env var named \" + lVarName + \".\");\n            value = \"\";\n            return false;\n        }\n\n        private string AppPath()\n        {\n            return _envPath;\n        }\n\n        private string DMVCFRAMEWORK_VERSION()\n        {\n            return \"6.0.0\";\n        }\n\n        private string GetDotEnvVar(string key)\n        {\n            _envDict.TryGetValue(key, out string val);\n            return val ?? \"\";\n        }\n\n        #endregion\n\n        #region IMVCDotEnv Implementation\n\n        public string Env(string name)\n        {\n            if (_state == DotEnvEngineState.Created)\n            {\n                throw new DotEnvException(\"dotEnv Engine not built\");\n            }\n\n            string result = \"\";\n            if (_priority == DotEnvPriority.FileThenEnv || _priority == DotEnvPriority.OnlyFile)\n            {\n                result = GetDotEnvVar(name);\n                if (result.Contains($\"${{{name}}}\"))\n                {\n                    throw new DotEnvException($\"Configuration loop detected with key \\\"{name}\\\"\");\n                }\n                if (_priority == DotEnvPriority.OnlyFile)\n                {\n                    return result;\n                }\n                if (string.IsNullOrEmpty(result))\n                {\n                    result = ExplodePlaceholders(Environment.GetEnvironmentVariable(name) ?? \"\");\n                    return result;\n                }\n                return result;\n            }\n            else if (_priority == DotEnvPriority.EnvThenFile || _priority == DotEnvPriority.OnlyEnv)\n            {\n                result = ExplodePlaceholders(Environment.GetEnvironmentVariable(name) ?? \"\");\n                if (_priority == DotEnvPriority.OnlyEnv)\n                {\n                    return result;\n                }\n                if (string.IsNullOrEmpty(result))\n                {\n                    string tmp = GetDotEnvVar(name);\n                    if (tmp.Contains($\"${{{name}}}\"))\n                    {\n                        throw new DotEnvException($\"Configuration loop detected with key \\\"{name}\\\"\");\n                    }\n                    return tmp;\n                }\n                return result;\n            }\n            else\n            {\n                throw new DotEnvException($\"Unknown dotEnv Priority: {_priority}\");\n            }\n        }\n\n        public string Env(string name, string defaultValue)\n        {\n            string val = Env(name);\n            return string.IsNullOrEmpty(val) ? defaultValue : val;\n        }\n\n        public int Env(string name, int defaultValue)\n        {\n            string val = Env(name);\n            if (string.IsNullOrEmpty(val))\n                return defaultValue;\n            if (!int.TryParse(val.Trim(), out int result))\n            {\n                throw new DotEnvException($\"Env \\\"{name}\\\" is not a valid integer [Current Value: \\\"{val}\\\"]\");\n            }\n            return result;\n        }\n\n        public bool Env(string name, bool defaultValue)\n        {\n            string val = Env(name);\n            if (string.IsNullOrEmpty(val))\n                return defaultValue;\n            val = val.Trim().ToLower();\n            if (val == \"yes\" || val == \"1\" || val == \"true\")\n                return true;\n            if (val == \"no\" || val == \"0\" || val == \"false\")\n                return false;\n            if (!bool.TryParse(val, out bool result))\n            {\n                throw new DotEnvException($\"Env \\\"{name}\\\" is not a valid boolean [Current Value: \\\"{val}\\\"]\");\n            }\n            return result;\n        }\n\n        public void RequireKeys(string[] keys)\n        {\n            if (keys == null || keys.Length == 0) return;\n            DoLog(\"Checking required keys: \" + string.Join(\", \", keys));\n            List<string> notFoundKeys = new List<string>();\n            foreach (var key in keys)\n            {\n                if (string.IsNullOrEmpty(Env(key)))\n                    notFoundKeys.Add(key);\n            }\n            if (notFoundKeys.Any())\n            {\n                string msg = \"Required keys not found: \" + string.Join(\", \", notFoundKeys);\n                DoLog(msg);\n                throw new DotEnvException(msg);\n            }\n        }\n\n        public IMVCDotEnv SaveToFile(string fileName)\n        {\n            var keys = _envDict.Keys.ToList();\n            keys.Sort(StringComparer.OrdinalIgnoreCase);\n            StringBuilder sb = new StringBuilder();\n            foreach (var key in keys)\n            {\n                sb.AppendLine($\"{key}={GetDotEnvVar(key)}\");\n            }\n            File.WriteAllText(fileName, sb.ToString());\n            return this;\n        }\n\n        public string[] ToArray()\n        {\n            var keys = _envDict.Keys.ToList();\n            keys.Sort(StringComparer.OrdinalIgnoreCase);\n            return keys.Select(key => $\"{key}={GetDotEnvVar(key)}\").ToArray();\n        }\n\n        #endregion\n\n        #region IMVCDotEnvBuilder Implementation\n\n        public IMVCDotEnvBuilder UseStrategy(DotEnvPriority strategy = DotEnvPriority.EnvThenFile)\n        {\n            CheckAlreadyBuilt();\n            _priority = strategy;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder SkipDefaultEnv()\n        {\n            _skipDefaultEnv = true;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseLogger(Action<string> logger)\n        {\n            if (_loggerProc != null)\n                throw new DotEnvException(\"Logger already set\");\n            _loggerProc = logger;\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseProfile(string profileName)\n        {\n            CheckAlreadyBuilt();\n            _profiles.Add(profileName);\n            return this;\n        }\n\n        public IMVCDotEnvBuilder UseProfile(Func<string> profileDelegate)\n        {\n            CheckAlreadyBuilt();\n            _profiles.Add(profileDelegate());\n            return this;\n        }\n\n        public IMVCDotEnvBuilder ClearProfiles()\n        {\n            CheckAlreadyBuilt();\n            _profiles.Clear();\n            return this;\n        }\n\n        public IMVCDotEnv Build(string dotEnvDirectory = \"\")\n        {\n            if (_state != DotEnvEngineState.Created)\n            {\n                throw new DotEnvException(\"dotEnv engine already built\");\n            }\n            _state = DotEnvEngineState.Building;\n            _envPath = string.IsNullOrEmpty(dotEnvDirectory)\n                ? _envPath\n                : Path.Combine(_envPath, dotEnvDirectory);\n            DoLog(\"Path = \" + _envPath);\n            _envDict.Clear();\n\n            List<string> allProfiles = new List<string> { \"default\" };\n            allProfiles.AddRange(_profiles);\n            if (_skipDefaultEnv && allProfiles.Count > 0)\n            {\n                allProfiles.RemoveAt(0);\n            }\n            DoLog(\"Active profile/s priority = [\" + string.Join(\",\", allProfiles) +\n                $\"] (Priority: {_priority})\");\n            ReadEnvFile();\n            ExplodeReferences();\n            _state = DotEnvEngineState.Built;\n            return this;\n        }\n\n        #endregion\n\n    }\n\n    #endregion\n\n    #region Simple DotEnv Parser\n\n    public static class DotEnvParser\n    {\n        public static void Parse(Dictionary<string, string> envDict, string dotenvCode)\n        {\n            if (string.IsNullOrWhiteSpace(dotenvCode))\n                return;\n            var lines = dotenvCode.Split(new[] { \"\\r\\n\", \"\\n\" }, StringSplitOptions.RemoveEmptyEntries);\n            foreach (var line in lines)\n            {\n                string trimmed = line.Trim();\n                if (trimmed.StartsWith(\"#\") || string.IsNullOrEmpty(trimmed))\n                    continue;\n                int idx = trimmed.IndexOf('=');\n                if (idx > 0)\n                {\n                    string key = trimmed.Substring(0, idx).Trim();\n                    string value = trimmed.Substring(idx + 1).Trim();\n                    if ((value.StartsWith(\"\\\"\") && value.EndsWith(\"\\\"\")) ||\n                        (value.StartsWith(\"'\") && value.EndsWith(\"'\")))\n                    {\n                        value = value.Substring(1, value.Length - 2);\n                    }\n                    envDict[key] = value;\n                }\n            }\n        }\n    }\n\n    #endregion\n}"}
{"input": "unit BaseControllerU;\n\ninterface\n\nuses\n  MVCFramework, BaseDataModuleU, FireDAC.Comp.Client, MVCFramework.Serializer.Commons;\n\ntype\n  TBaseController = class(TMVCController)\n  private\n    FCommon: TBaseDataModule;\n\n  public\n    procedure OnBeforeAction(Context: TWebContext; const AActionNAme: string; var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionNAme: string); override;\n    function Connection: TFDConnection;\n    function CommonModule: TBaseDataModule;\n\n    // function CreateQuery(const SQL: String; Obj: TObject = nil): TFDQuery;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nfunction TBaseController.CommonModule: TBaseDataModule;\nbegin\n  if not Assigned(FCommon) then\n    FCommon := TBaseDataModule.Create(nil);\n  Result := FCommon;\nend;\n\nfunction TBaseController.Connection: TFDConnection;\nbegin\n  Result := CommonModule.Conn;\nend;\n\n// function TBaseController.CreateQuery(const SQL: String; Obj: TObject): TFDQuery;\n// var\n// qry: TFDQuery;\n// begin\n// qry := TFDQuery.Create(nil);\n// try\n// qry.Connection := Connection;\n// qry.SQL.Text := SQL;\n// qry.Prepare;\n// if Assigned(Obj) then\n// Mapper.ObjectToFDParameters(qry.Params, Obj);\n// Result := qry;\n// except\n// FreeAndNil(qry);\n// raise;\n// end;\n// end;\n\nprocedure TBaseController.OnAfterAction(Context: TWebContext; const AActionNAme: string);\nbegin\n  inherited;\n  FreeAndNil(FCommon);\nend;\n\nprocedure TBaseController.OnBeforeAction(Context: TWebContext; const AActionNAme: string; var Handled: Boolean);\nbegin\n  inherited;\n\nend;\n\nend.", "output": "using System;\nusing System.Data.Common;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace BaseControllerU\n{    public class BaseDataModule : IDisposable\n    {\n        public DbConnection Conn { get; private set; }\n\n        public BaseDataModule()\n        {\n            \n            Conn = null; \n        }\n\n        public void Dispose()\n        {\n            if (Conn != null)\n            {\n                Conn.Dispose();\n                Conn = null;\n            }\n        }\n    }\n\n    \n    public class BaseController : Controller\n    {\n        private BaseDataModule _common;\n\n        \n        protected BaseDataModule CommonModule()\n        {\n            if (_common == null)\n            {\n                _common = new BaseDataModule();\n            }\n            return _common;\n        }\n\n        \n        protected DbConnection Connection()\n        {\n            return CommonModule().Conn;\n        }\n\n        \n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            base.OnActionExecuting(context);\n            \n        }\n\n        \n        public override void OnActionExecuted(ActionExecutedContext context)\n        {\n            base.OnActionExecuted(context);\n            \n            if (_common != null)\n            {\n                _common.Dispose();\n                _common = null;\n            }\n        }\n\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.JWT;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.JWT,\n  JsonDataObjects,\n  MVCFramework.HMAC,\n  Web.HTTPApp;\n\ntype\n  TMVCJWTDefaults = class sealed\n  public const\n    /// <summary>\n    /// Default authorization header name (RFC 6750)\n    /// </summary>\n    AUTHORIZATION_HEADER = 'Authorization';\n    /// <summary>\n    /// Default username header name\n    /// </summary>\n    USERNAME_HEADER = 'jwtusername';\n    /// <summary>\n    /// Default password header name\n    /// </summary>\n    PASSWORD_HEADER = 'jwtpassword';\n    /// <summary>\n    /// Default AUTH schema\n    /// </summary>\n    AUTH_SCHEMA = 'Bearer';\n    /// <summary>\n    /// Default url authorization token\n    /// </summary>\n    AUTHORIZATION_ACCESS_TOKEN = 'access_token';\n  end;\n\n  TJWTClaimsSetup = reference to procedure(const JWT: TJWT);\n\n  TMVCJWTAuthenticationMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    FAuthenticationHandler: IMVCAuthenticationHandler;\n    FClaimsToChecks: TJWTCheckableClaims;\n    FSetupJWTClaims: TJWTClaimsSetup;\n    FSecret: string;\n    FLeewaySeconds: Cardinal;\n    FLoginURLSegment: string;\n    FAuthorizationHeaderName: string;\n    FAuthorizationAccessToken: string;\n    FUserNameHeaderName: string;\n    FPasswordHeaderName: string;\n    FHMACAlgorithm: String;\n    FUseHttpOnly: Boolean;\n    FTokenHttpOnlyExpires: TDateTime;\n    FLogoffURLSegment: string;\n    procedure SendLogoffRender(AContext: TWebContext);\n  protected\n    function NeedsToBeExtended(const JWTValue: TJWT): Boolean;\n    procedure ExtendExpirationTime(const JWTValue: TJWT);\n    procedure InternalRender(AJSONOb: TJDOJsonObject; AContentType: string; AContentEncoding: string;\n      AContext: TWebContext; AInstanceOwner: Boolean = True); virtual;\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean); virtual;\n    procedure OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName: string;\n      const AActionName: string; var AHandled: Boolean); virtual;\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean); virtual;\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean); virtual;\n  public\n    constructor Create(AAuthenticationHandler: IMVCAuthenticationHandler;\n      AConfigClaims: TJWTClaimsSetup;\n      ASecret: string = 'D3lph1MVCFram3w0rk';\n      ALoginURLSegment: string = '/login';\n      AClaimsToCheck: TJWTCheckableClaims = [];\n      ALeewaySeconds: Cardinal = 300;\n      AHMACAlgorithm: String = HMAC_HS512); overload; virtual;\n    constructor Create(AAuthenticationHandler: IMVCAuthenticationHandler;\n      AConfigClaims: TJWTClaimsSetup;\n      AUseHttpOnly: Boolean;\n      ALogoffURLSegment: string = '/logoff';\n      ASecret: string = 'D3lph1MVCFram3w0rk';\n      ALoginURLSegment: string = '/login';\n      AClaimsToCheck: TJWTCheckableClaims = [];\n      ALeewaySeconds: Cardinal = 300;\n      AHMACAlgorithm: String = HMAC_HS512); overload; virtual;\n    property AuthorizationHeaderName: string read FAuthorizationHeaderName;\n    property UserNameHeaderName: string read FUserNameHeaderName;\n    property PasswordHeaderName: string read FPasswordHeaderName;\n  end;\n\n  TMVCOnAcceptTokenProc = reference to procedure(AContext: TWebContext; AJWTToken: String;\n    var AAccepted: Boolean);\n  TMVCOnNewJWTToBlackList = reference to procedure(AContext: TWebContext; AJWTToken: String);\n\n  TMVCJWTBlackListMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fOnAcceptToken: TMVCOnAcceptTokenProc;\n    fOnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n    fBlackListRequestURLSegment: string;\n  protected\n    procedure OnBeforeRouting(\n      AContext: TWebContext;\n      var AHandled: Boolean\n      );\n\n    procedure OnBeforeControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string;\n      const AActionName: string;\n      var AHandled: Boolean\n      );\n\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(\n      AContext: TWebContext;\n      const AHandled: Boolean\n      );\n  public\n    constructor Create(\n      OnAcceptToken: TMVCOnAcceptTokenProc;\n      OnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n      BlackListRequestURLSegment: string = '/logout');\n  end;\n\n\nimplementation\n\nuses\n  System.NetEncoding,\n  System.DateUtils,\n  System.Math,\n  MVCFramework.Logger;\n\n{ TMVCJWTAuthenticationMiddleware }\n\nconstructor TMVCJWTAuthenticationMiddleware.Create(\n  AAuthenticationHandler: IMVCAuthenticationHandler;\n  AConfigClaims: TJWTClaimsSetup;\n  ASecret, ALoginURLSegment: string;\n  AClaimsToCheck: TJWTCheckableClaims;\n  ALeewaySeconds: Cardinal;\n  AHMACAlgorithm: String\n  );\nbegin\n  inherited Create;\n  FAuthenticationHandler := AAuthenticationHandler;\n  FSetupJWTClaims := AConfigClaims;\n  FClaimsToChecks := AClaimsToCheck;\n  FSecret := ASecret;\n  FLoginURLSegment := ALoginURLSegment;\n  FLeewaySeconds := ALeewaySeconds;\n  FAuthorizationHeaderName := TMVCJWTDefaults.AUTHORIZATION_HEADER;\n  FAuthorizationAccessToken := TMVCJWTDefaults.AUTHORIZATION_ACCESS_TOKEN;\n  FUserNameHeaderName := TMVCJWTDefaults.USERNAME_HEADER;\n  FPasswordHeaderName := TMVCJWTDefaults.PASSWORD_HEADER;\n  FHMACAlgorithm := AHMACAlgorithm;\n  FUseHttpOnly := False;\n  FTokenHttpOnlyExpires := Now;\nend;\n\nconstructor TMVCJWTAuthenticationMiddleware.Create(AAuthenticationHandler: IMVCAuthenticationHandler; AConfigClaims: TJWTClaimsSetup; AUseHttpOnly: Boolean; ALogoffURLSegment: string;\n  ASecret, ALoginURLSegment: string; AClaimsToCheck: TJWTCheckableClaims; ALeewaySeconds: Cardinal; AHMACAlgorithm: String);\nbegin\n  Create(AAuthenticationHandler, AConfigClaims, ASecret, ALoginURLSegment, AClaimsToCheck, ALeewaySeconds, AHMACAlgorithm);\n  FUseHttpOnly := AUseHttpOnly;\n  FLogoffURLSegment := ALogoffURLSegment;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.ExtendExpirationTime(const JWTValue: TJWT);\nbegin\n  JWTValue.Claims.ExpirationTime := Max(JWTValue.Claims.ExpirationTime, Now) +\n    (JWTValue.LeewaySeconds + JWTValue.LiveValidityWindowInSeconds) * OneSecond;\n  if FUseHttpOnly then\n  begin\n    FTokenHttpOnlyExpires := JWTValue.Claims.ExpirationTime;\n  end;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.InternalRender(AJSONOb: TJDOJsonObject;\n  AContentType, AContentEncoding: string; AContext: TWebContext; AInstanceOwner: Boolean);\nvar\n  Encoding: TEncoding;\n  ContentType, JValue: string;\n  Cookie: TCookie;\nbegin\n  JValue := AJSONOb.ToJSON;\n\n  if FUseHttpOnly then\n  begin\n    Cookie := AContext.Response.Cookies.Add;\n    Cookie.Expires := FTokenHttpOnlyExpires;\n    Cookie.Path := '/';\n    Cookie.Name := 'token';\n    Cookie.Value := AJSONOb.S['token'];\n    Cookie.HttpOnly := True;\n    // Cookie.Secure := True;\n    // Cookie.SameSite := 'none';\n  end;\n\n  AContext.Response.RawWebResponse.ContentType := AContentType + '; charset=' + AContentEncoding;\n  ContentType := AContentType + '; charset=' + AContentEncoding;\n\n  Encoding := TEncoding.GetEncoding(AContentEncoding);\n  try\n    AContext.Response.SetContentStream(TBytesStream.Create(TEncoding.Convert(TEncoding.Default, Encoding,\n      TEncoding.Default.GetBytes(JValue))), ContentType);\n  finally\n    Encoding.Free;\n  end;\n\n  if AInstanceOwner then\n    FreeAndNil(AJSONOb)\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.SendLogoffRender(AContext: TWebContext);\nconst\n  returnMessage = '{ \"message\": \"Successful logout\" }';\n  ContentType = 'application/json; charset=UTF-8';\n  AContentEncoding = 'UTF-8';\nvar\n  Encoding: TEncoding;\n  Cookie: TCookie;\nbegin\n  Cookie := AContext.Response.Cookies.Add;\n  Cookie.Name := 'token';\n  Cookie.Path := '/';\n\n  Encoding := TEncoding.GetEncoding(AContentEncoding);\n  try\n    AContext.Response.SetContentStream(TBytesStream.Create(TEncoding.Convert(TEncoding.Default, Encoding, TEncoding.Default.GetBytes(returnMessage))), ContentType);\n  finally\n    Encoding.Free;\n  end;\nend;\n\nfunction TMVCJWTAuthenticationMiddleware.NeedsToBeExtended(const JWTValue: TJWT): Boolean;\nvar\n  lWillExpireIn: Int64;\nbegin\n  lWillExpireIn := SecondsBetween(Now, JWTValue.Claims.ExpirationTime);\n  Result := lWillExpireIn <= JWTValue.LiveValidityWindowInSeconds;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnBeforeControllerAction(AContext: TWebContext;\n  const AControllerQualifiedClassName, AActionName: string; var AHandled: Boolean);\nvar\n  AuthRequired: Boolean;\n  IsAuthorized: Boolean;\n  JWTValue: TJWT;\n  AuthHeader: string;\n  AuthAccessToken: string;\n  AuthToken: string;\n  ErrorMsg: string;\n  CookieToken: string;\nbegin\n  // check if the resource is protected\n  if Assigned(FAuthenticationHandler) then\n  begin\n    FAuthenticationHandler.OnRequest(AContext, AControllerQualifiedClassName, AActionName, AuthRequired);\n    if not AuthRequired then\n    begin\n      AHandled := False;\n      { this section handles the case when the authenticated user (with a token) need to call an action which doesn't require\n        authentication. To make Context.LoggerdUser.IsValid works we need to load the JWT if present. In such way\n        the \"public\" action can distriminate is has been called by a not-authnticated user or an authenticated user.\n        If there isn't a token, we don't have to raise exceptions, just make sure that the LoggedUser doesn't contain\n        information.\n      }\n      // retrieve the token from the \"authentication Bearer\" header\n      AuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n      if AuthHeader.IsEmpty then\n        // retrieve the token from the \"access_token\" query param\n        AuthHeader := AContext.Request.Params[FAuthorizationAccessToken];\n\n      if not AuthHeader.IsEmpty then\n      begin\n        { load and verify token even for an action that doesn't require it }\n        JWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n        try\n          JWTValue.RegClaimsToChecks := Self.FClaimsToChecks;\n\n          // retrieve the token from the \"authentication Bearer\" header\n          AuthToken := '';\n          if AuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n          begin\n            AuthToken := AuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n            AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n          end;\n\n          if JWTValue.LoadToken(AuthToken, ErrorMsg) then\n          begin\n            { load token info only if the token is still valid }\n            AContext.LoggedUser.UserName := JWTValue.CustomClaims['username'];\n            AContext.LoggedUser.Roles.AddRange(JWTValue.CustomClaims['roles'].Split([',']));\n            AContext.LoggedUser.LoggedSince := JWTValue.Claims.IssuedAt;\n            AContext.LoggedUser.CustomData := JWTValue.CustomClaims.AsCustomData;\n          end;\n        finally\n          JWTValue.Free;\n        end;\n      end;\n      Exit;\n    end;\n  end;\n\n  // Checking token in subsequent requests\n  // ***************************************************\n  JWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n  try\n    JWTValue.RegClaimsToChecks := Self.FClaimsToChecks;\n    // retrieve the token from the \"authentication Bearer\" header\n    AuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n    if (not AuthHeader.IsEmpty) then\n    begin\n      AuthToken := '';\n      if AuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n      begin\n        AuthToken := AuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n        AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n      end;\n    end\n    else\n    begin\n      // retrieve the token from the \"access_token\" query param\n      AuthAccessToken := AContext.Request.Params[FAuthorizationAccessToken];\n      if (not AuthAccessToken.IsEmpty) then\n      begin\n        AuthToken := AuthAccessToken.Trim;\n        AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n      end\n      else\n      begin\n        if FUseHttpOnly then\n        begin\n          CookieToken := AContext.Request.Cookie('token');\n          if (not CookieToken.IsEmpty) then\n          begin\n            AuthToken := CookieToken.Trim;\n            AuthToken := Trim(TNetEncoding.URL.Decode(AuthToken));\n          end;\n        end;\n      end;\n    end;\n\n    if AuthToken.IsEmpty then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Authorization Required');\n    if not JWTValue.LoadToken(AuthToken, ErrorMsg) then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, ErrorMsg);\n\n    if JWTValue.CustomClaims['username'].IsEmpty then\n      raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid Token, Authorization Required');\n\n    AContext.LoggedUser.UserName := JWTValue.CustomClaims['username'];\n    AContext.LoggedUser.Roles.AddRange(JWTValue.CustomClaims['roles'].Split([',']));\n    AContext.LoggedUser.LoggedSince := JWTValue.Claims.IssuedAt;\n    AContext.LoggedUser.CustomData := JWTValue.CustomClaims.AsCustomData;\n\n    if Assigned(FAuthenticationHandler) then\n    begin\n      FAuthenticationHandler.OnAuthorization(AContext, AContext.LoggedUser.Roles, AControllerQualifiedClassName,\n        AActionName, IsAuthorized);\n      if not IsAuthorized then\n        raise EMVCJWTException.Create(HTTP_STATUS.Forbidden, 'Authorization Forbidden');\n    end;\n\n    if JWTValue.LiveValidityWindowInSeconds > 0 then\n    begin\n      if NeedsToBeExtended(JWTValue) then\n      begin\n        ExtendExpirationTime(JWTValue);\n        AContext.Response.SetCustomHeader(FAuthorizationHeaderName, 'Bearer ' + JWTValue.GetToken);\n      end;\n    end;\n\n    AHandled := False;\n  finally\n    JWTValue.Free;\n  end;\nend;\n\nprocedure TMVCJWTAuthenticationMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  LUsername: string;\n  LPassword: string;\n  LBasicAuthHeader: string;\n  LBasicAuthParts: TArray<string>;\n  LRolesList: TList<string>;\n  LSessionData: TSessionData;\n  LIsValid: Boolean;\n  LJWTValue: TJWT;\n  LCustomPair: TPair<string, string>;\n  LJsonObject: TJDOJsonObject;\n  lJObj: TJsonObject;\nbegin\n  if SameText(AContext.Request.PathInfo, FLoginURLSegment) then\n  begin\n    LBasicAuthHeader := AContext.Request.Headers[FAuthorizationHeaderName];\n    if LBasicAuthHeader.IsEmpty then\n    begin\n      // read from headers\n      LUsername := TNetEncoding.URL.Decode(AContext.Request.Headers[FUserNameHeaderName]);\n      LPassword := TNetEncoding.URL.Decode(AContext.Request.Headers[FPasswordHeaderName]);\n\n      // read from content\n      if LUsername.IsEmpty and not SameText(AContext.Request.ContentMediaType, TMVCMediaType.APPLICATION_JSON) then\n      begin\n        LUsername := AContext.Request.ContentParam(FUserNameHeaderName);\n        LPassword := AContext.Request.ContentParam(FPasswordHeaderName);\n      end;\n\n      // read from json content\n      if LUsername.IsEmpty then\n      begin\n        lJObj := StrToJSONObject(AContext.Request.Body, False);\n        try\n          if Assigned(lJObj) then\n          begin\n            LUsername := lJObj.S[FUserNameHeaderName];\n            LPassword := lJObj.S[FPasswordHeaderName];\n            if LUsername.IsEmpty then\n            begin\n              LUsername := lJObj.S['username'];\n              LPassword := lJObj.S['password'];\n            end;\n          end;\n        finally\n          lJObj.Free;\n        end;\n      end;\n\n      if (LUsername.IsEmpty) or (LPassword.IsEmpty) then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Username and password required');\n    end\n    else\n    begin\n      if not LBasicAuthHeader.StartsWith('basic', True) then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid authorization type');\n\n      LBasicAuthHeader := LBasicAuthHeader.Remove(0, 'basic'.Length).Trim;\n      LBasicAuthParts := TBase64Encoding.Base64.Decode(LBasicAuthHeader).Split([':']);\n\n      if Length(LBasicAuthParts) <> 2 then\n        raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Invalid authorization type');\n\n      LUsername := LBasicAuthParts[0];\n      LPassword := LBasicAuthParts[1];\n    end;\n\n    // check the authorization for the requested resource\n    LRolesList := TList<string>.Create;\n    try\n      LSessionData := TSessionData.Create;\n      try\n        if Assigned(FAuthenticationHandler) then\n        begin\n          FAuthenticationHandler.OnAuthentication(AContext, LUsername, LPassword, LRolesList, LIsValid, LSessionData);\n          if not LIsValid then\n            raise EMVCJWTException.Create(HTTP_STATUS.Unauthorized, 'Unauthorized');\n        end;\n\n        LJWTValue := TJWT.Create(FSecret, FLeewaySeconds);\n        try\n          // let's user config claims and custom claims\n          if not Assigned(FSetupJWTClaims) then\n            raise EMVCJWTException.Create('SetupJWTClaims not set');\n          LJWTValue.Data := AContext.Request;\n          FSetupJWTClaims(LJWTValue);\n\n          if FUseHttpOnly then\n          begin\n            FTokenHttpOnlyExpires := LJWTValue.Claims.ExpirationTime;\n          end;\n\n          // these claims are mandatory and managed by the middleware\n          if not LJWTValue.CustomClaims['username'].IsEmpty then\n            raise EMVCJWTException.Create\n              ('Custom claim \"username\" is reserved and cannot be modified in the JWT setup');\n\n          if not LJWTValue.CustomClaims['roles'].IsEmpty then\n            raise EMVCJWTException.Create('Custom claim \"roles\" is reserved and cannot be modified in the JWT setup');\n\n          LJWTValue.CustomClaims['username'] := LUsername;\n          LJWTValue.CustomClaims['roles'] := string.Join(',', LRolesList.ToArray);\n\n          if LJWTValue.LiveValidityWindowInSeconds > 0 then\n            if NeedsToBeExtended(LJWTValue) then\n              ExtendExpirationTime(LJWTValue);\n\n          // setup the current logged user from the JWT\n          AContext.LoggedUser.Roles.AddRange(LRolesList);\n          AContext.LoggedUser.UserName := LJWTValue.CustomClaims['username'];\n          AContext.LoggedUser.LoggedSince := LJWTValue.Claims.IssuedAt;\n          AContext.LoggedUser.Realm := LJWTValue.Claims.Subject;\n\n          if LSessionData.Count > 0 then\n          begin\n            AContext.LoggedUser.CustomData := TMVCCustomData.Create;\n            for LCustomPair in LSessionData do\n            begin\n              AContext.LoggedUser.CustomData.AddOrSetValue(LCustomPair.Key, LCustomPair.Value);\n              if not LJWTValue.CustomClaims.Items[LCustomPair.Key].IsEmpty then\n                raise EMVCJWTException.CreateFmt('JWT Error: \"%s\" is a reserved key name', [LCustomPair.Key]);\n              LJWTValue.CustomClaims.Items[LCustomPair.Key] := LCustomPair.Value;\n            end;\n          end;\n\n          LJsonObject := TJDOJsonObject.Create;\n          try\n            LJsonObject.S['token'] := LJWTValue.GetToken;\n            InternalRender(LJsonObject, TMVCMediaType.APPLICATION_JSON, TMVCConstants.DEFAULT_CONTENT_CHARSET,\n              AContext, False);\n          finally\n            LJsonObject.Free;\n          end;\n          AHandled := True;\n        finally\n          LJWTValue.Free;\n        end;\n      finally\n        LSessionData.Free;\n      end;\n    finally\n      LRolesList.Free;\n    end;\n  end\n  else\n  begin\n    if SameText(AContext.Request.PathInfo, FLogoffURLSegment) and (FUseHttpOnly) then\n    begin\n      SendLogoffRender(AContext);\n      AHandled := True;\n    end;\n  end;\nend;\n\n\nconstructor TMVCJWTBlackListMiddleware.Create(\n  OnAcceptToken: TMVCOnAcceptTokenProc;\n  OnNewJWTToBlackList: TMVCOnNewJWTToBlackList;\n  BlackListRequestURLSegment: string = '/logout');\nbegin\n  inherited Create;\n  fOnAcceptToken := OnAcceptToken;\n  fOnNewJWTToBlackList := OnNewJWTToBlackList;\n  fBlackListRequestURLSegment := BlackListRequestURLSegment;\n  Assert(Assigned(fOnAcceptToken));\n  Assert(not fBlackListRequestURLSegment.IsEmpty);\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // Implement as needed\nend;\n\nprocedure TMVCJWTBlackListMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  lAuthHeader: string;\n  lAuthToken: string;\n  lAccepted: Boolean;\nbegin\n  lAuthToken := '';\n  lAuthHeader := AContext.Request.Headers[TMVCJWTDefaults.AUTHORIZATION_HEADER];\n  if not lAuthHeader.IsEmpty then\n  begin\n    // retrieve the token from the \"authentication Bearer\" header\n    if lAuthHeader.Substring(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).ToLower = 'bearer' then\n    begin\n      lAuthToken := lAuthHeader.Remove(0, TMVCJWTDefaults.AUTH_SCHEMA.Length).Trim;\n      lAuthToken := Trim(TNetEncoding.URL.Decode(lAuthToken));\n    end;\n  end;\n\n  if SameText(AContext.Request.PathInfo, fBlackListRequestURLSegment) then\n  begin\n    // add the token in the blacklist\n    if lAuthToken.IsEmpty then\n    begin\n      raise EMVCException.Create(HTTP_STATUS.BadRequest,\n        'JWTToken required - cannot blacklist an unknown token');\n    end;\n    fOnNewJWTToBlackList(AContext, lAuthToken);\n    AContext.Response.StatusCode := HTTP_STATUS.NoContent;\n    AHandled := True;\n  end\n  else\n  begin\n    // just check if token is blacklisted.\n    // if the token is not available, just ignore the check\n    // remember, here jwtmiddleware already did its job.\n    if lAuthToken.IsEmpty then\n    begin\n      AHandled := False;\n    end\n    else\n    begin\n      lAccepted := True;\n      fOnAcceptToken(AContext, lAuthToken, lAccepted);\n      if not lAccepted then\n      begin\n        raise EMVCJWTException.Create(HTTP_STATUS.Forbidden, 'JWT not accepted');\n      end;\n    end;\n  end;\nend;\n\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.IO;\nusing Newtonsoft.Json.Linq; \nusing MVCFramework;         \nusing MVCFramework.Commons;  \nusing MVCFramework.JWT;      \nusing MVCFramework.HMAC;     \n\nnamespace MVCFramework.Middleware.JWT\n{\n    \n    public static class MVCJWTDefaults\n    {\n        public const string AUTHORIZATION_HEADER = \"Authorization\";\n        public const string USERNAME_HEADER = \"jwtusername\";\n        public const string PASSWORD_HEADER = \"jwtpassword\";\n        public const string AUTH_SCHEMA = \"Bearer\";\n        public const string AUTHORIZATION_ACCESS_TOKEN = \"access_token\";\n    }\n\n    \n    public delegate void JWTClaimsSetup(JWT jwt);\n\n    \n    public class MVCJWTAuthenticationMiddleware : IMVCMiddleware\n    {\n        private readonly IMVCAuthenticationHandler _authenticationHandler;\n        private readonly JWTCheckableClaims _claimsToCheck;\n        private readonly JWTClaimsSetup _setupJWTClaims;\n        private readonly string _secret;\n        private readonly uint _leewaySeconds;\n        private readonly string _loginURLSegment;\n        private readonly string _authorizationHeaderName;\n        private readonly string _authorizationAccessToken;\n        private readonly string _userNameHeaderName;\n        private readonly string _passwordHeaderName;\n        private readonly string _hmacAlgorithm;\n        private readonly bool _useHttpOnly;\n        private DateTime _tokenHttpOnlyExpires;\n        private readonly string _logoffURLSegment;\n\n        #region Constructors\n\n        public MVCJWTAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            JWTClaimsSetup configClaims,\n            string secret = \"D3lph1MVCFram3w0rk\",\n            string loginURLSegment = \"/login\",\n            JWTCheckableClaims claimsToCheck = JWTCheckableClaims.None,\n            uint leewaySeconds = 300,\n            string hmacAlgorithm = HMAC_HS512)\n        {\n            _authenticationHandler = authenticationHandler;\n            _setupJWTClaims = configClaims;\n            _claimsToCheck = claimsToCheck;\n            _secret = secret;\n            _loginURLSegment = loginURLSegment;\n            _leewaySeconds = leewaySeconds;\n            _authorizationHeaderName = MVCJWTDefaults.AUTHORIZATION_HEADER;\n            _authorizationAccessToken = MVCJWTDefaults.AUTHORIZATION_ACCESS_TOKEN;\n            _userNameHeaderName = MVCJWTDefaults.USERNAME_HEADER;\n            _passwordHeaderName = MVCJWTDefaults.PASSWORD_HEADER;\n            _hmacAlgorithm = hmacAlgorithm;\n            _useHttpOnly = false;\n            _tokenHttpOnlyExpires = DateTime.Now;\n        }\n\n        public MVCJWTAuthenticationMiddleware(\n            IMVCAuthenticationHandler authenticationHandler,\n            JWTClaimsSetup configClaims,\n            bool useHttpOnly,\n            string logoffURLSegment = \"/logoff\",\n            string secret = \"D3lph1MVCFram3w0rk\",\n            string loginURLSegment = \"/login\",\n            JWTCheckableClaims claimsToCheck = JWTCheckableClaims.None,\n            uint leewaySeconds = 300,\n            string hmacAlgorithm = HMAC_HS512)\n            : this(authenticationHandler, configClaims, secret, loginURLSegment, claimsToCheck, leewaySeconds, hmacAlgorithm)\n        {\n            _useHttpOnly = useHttpOnly;\n            _logoffURLSegment = logoffURLSegment;\n        }\n\n        #endregion\n\n        #region Helper Methods\n\n        \n        protected bool NeedsToBeExtended(JWT jwt)\n        {\n            double secondsToExpire = (jwt.Claims.ExpirationTime - DateTime.Now).TotalSeconds;\n            return secondsToExpire <= jwt.LiveValidityWindowInSeconds;\n        }\n\n        \n        protected void ExtendExpirationTime(JWT jwt)\n        {\n            \n            jwt.Claims.ExpirationTime = Max(jwt.Claims.ExpirationTime, DateTime.Now)\n                .AddSeconds(jwt.LeewaySeconds + jwt.LiveValidityWindowInSeconds);\n            if (_useHttpOnly)\n            {\n                _tokenHttpOnlyExpires = jwt.Claims.ExpirationTime;\n            }\n        }\n\n        private DateTime Max(DateTime a, DateTime b)\n        {\n            return (a > b) ? a : b;\n        }\n\n        \n        protected void InternalRender(JObject jsonObj, string contentType, string contentEncoding, WebContext context, bool instanceOwner = true)\n        {\n            string jValue = jsonObj.ToString();\n\n            if (_useHttpOnly)\n            {\n                \n                context.Response.Cookies.Add(new Cookie(\"token\", jsonObj[\"token\"]?.ToString())\n                {\n                    Expires = _tokenHttpOnlyExpires,\n                    Path = \"/\",\n                    HttpOnly = true\n                });\n            }\n\n            context.Response.RawWebResponse.ContentType = $\"{contentType}; charset={contentEncoding}\";\n            Encoding encoding = Encoding.GetEncoding(contentEncoding);\n            byte[] bytes = encoding.GetBytes(jValue);\n            context.Response.SetContentStream(new MemoryStream(bytes), $\"{contentType}; charset={contentEncoding}\");\n        }\n\n        #endregion\n\n        #region IMVCMiddleware Members\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            // No routing logic needed for JWT middleware.\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            \n            _authenticationHandler.OnRequest(context, controllerQualifiedClassName, actionName, out bool authRequired);\n            if (!authRequired)\n            {\n                handled = false;\n                \n                string authHeader = context.Request.Headers[_authorizationHeaderName];\n                if (!string.IsNullOrEmpty(authHeader))\n                {\n                    JWT jwtTemp = new JWT(_secret, _leewaySeconds);\n                    try\n                    {\n                        jwtTemp.RegClaimsToChecks = _claimsToCheck;\n                        string token = \"\";\n                        if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                        {\n                            token = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                            token = WebUtility.UrlDecode(token);\n                        }\n                        if (jwtTemp.LoadToken(token, out string errorMsg))\n                        {\n                            context.LoggedUser.UserName = jwtTemp.CustomClaims[\"username\"];\n                            context.LoggedUser.Roles.AddRange(jwtTemp.CustomClaims[\"roles\"].Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries));\n                            context.LoggedUser.LoggedSince = jwtTemp.Claims.IssuedAt;\n                            context.LoggedUser.CustomData = jwtTemp.CustomClaims.AsCustomData;\n                        }\n                    }\n                    finally\n                    {\n                        jwtTemp.Dispose();\n                    }\n                }\n                return;\n            }\n\n            \n            using (JWT jwt = new JWT(_secret, _leewaySeconds))\n            {\n                jwt.RegClaimsToChecks = _claimsToCheck;\n                string authHeader = context.Request.Headers[_authorizationHeaderName];\n                string authToken = \"\";\n                if (!string.IsNullOrEmpty(authHeader))\n                {\n                    if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                    {\n                        authToken = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                        authToken = WebUtility.UrlDecode(authToken);\n                    }\n                }\n                else\n                {\n                    \n                    string queryToken = context.Request.Params[_authorizationAccessToken];\n                    if (!string.IsNullOrEmpty(queryToken))\n                    {\n                        authToken = queryToken.Trim();\n                        authToken = WebUtility.UrlDecode(authToken);\n                    }\n                    else if (_useHttpOnly)\n                    {\n                        \n                        string cookieToken = context.Request.Cookie(\"token\");\n                        if (!string.IsNullOrEmpty(cookieToken))\n                        {\n                            authToken = cookieToken.Trim();\n                            authToken = WebUtility.UrlDecode(authToken);\n                        }\n                    }\n                }\n                if (string.IsNullOrEmpty(authToken))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, \"Authorization Required\");\n\n                if (!jwt.LoadToken(authToken, out string errorMsg))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, errorMsg);\n\n                if (string.IsNullOrEmpty(jwt.CustomClaims[\"username\"]))\n                    throw new MVCJWTException(HTTP_STATUS.Unauthorized, \"Invalid Token, Authorization Required\");\n\n                context.LoggedUser.UserName = jwt.CustomClaims[\"username\"];\n                context.LoggedUser.Roles.AddRange(jwt.CustomClaims[\"roles\"].Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries));\n                context.LoggedUser.LoggedSince = jwt.Claims.IssuedAt;\n                context.LoggedUser.CustomData = jwt.CustomClaims.AsCustomData;\n\n                if (_authenticationHandler != null)\n                {\n                    _authenticationHandler.OnAuthorization(context, context.LoggedUser.Roles, controllerQualifiedClassName, actionName, out bool isAuthorized);\n                    if (!isAuthorized)\n                        throw new MVCJWTException(HTTP_STATUS.Forbidden, \"Authorization Forbidden\");\n                }\n\n                \n                if (jwt.LiveValidityWindowInSeconds > 0 && NeedsToBeExtended(jwt))\n                {\n                    ExtendExpirationTime(jwt);\n                    context.Response.SetCustomHeader(_authorizationHeaderName, \"Bearer \" + jwt.GetToken());\n                }\n                handled = false;\n            }\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement if any after-action logic is needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Implement if any after-routing logic is needed.\n        }\n\n        #endregion\n\n        #region Exposed Properties\n\n        public string AuthorizationHeaderName => _authorizationHeaderName;\n        public string UserNameHeaderName => _userNameHeaderName;\n        public string PasswordHeaderName => _passwordHeaderName;\n\n        #endregion\n    }\n\n    \n    public class MVCJWTBlackListMiddleware : IMVCMiddleware\n    {\n        private readonly Action<WebContext, string, ref bool> _onAcceptToken;\n        private readonly Action<WebContext, string> _onNewJWTToBlackList;\n        private readonly string _blackListRequestURLSegment;\n\n        public MVCJWTBlackListMiddleware(\n            Action<WebContext, string, ref bool> onAcceptToken,\n            Action<WebContext, string> onNewJWTToBlackList,\n            string blackListRequestURLSegment = \"/logout\")\n        {\n            _onAcceptToken = onAcceptToken ?? throw new ArgumentNullException(nameof(onAcceptToken));\n            _onNewJWTToBlackList = onNewJWTToBlackList;\n            _blackListRequestURLSegment = blackListRequestURLSegment;\n            if (string.IsNullOrWhiteSpace(_blackListRequestURLSegment))\n                throw new ArgumentException(\"BlackListRequestURLSegment cannot be empty\", nameof(blackListRequestURLSegment));\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            string authHeader = context.Request.Headers[MVCJWTDefaults.AUTHORIZATION_HEADER];\n            string authToken = \"\";\n            if (!string.IsNullOrEmpty(authHeader))\n            {\n                if (authHeader.StartsWith(MVCJWTDefaults.AUTH_SCHEMA, StringComparison.OrdinalIgnoreCase))\n                {\n                    authToken = authHeader.Substring(MVCJWTDefaults.AUTH_SCHEMA.Length).Trim();\n                    authToken = WebUtility.UrlDecode(authToken);\n                }\n            }\n\n            if (string.Equals(context.Request.PathInfo, _blackListRequestURLSegment, StringComparison.OrdinalIgnoreCase))\n            {\n                if (string.IsNullOrEmpty(authToken))\n                    throw new Exception(\"JWTToken required - cannot blacklist an unknown token\");\n                _onNewJWTToBlackList(context, authToken);\n                context.Response.StatusCode = HTTP_STATUS.NoContent;\n                handled = true;\n            }\n            else\n            {\n                if (string.IsNullOrEmpty(authToken))\n                {\n                    handled = false;\n                }\n                else\n                {\n                    bool accepted = true;\n                    _onAcceptToken(context, authToken, ref accepted);\n                    if (!accepted)\n                        throw new MVCJWTException(HTTP_STATUS.Forbidden, \"JWT not accepted\");\n                }\n            }\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Implement as needed.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Implement as needed.\n        }\n\n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Implement as needed.\n        }\n    }\n}"}
{"input": "unit Services.InterfacesU;\n\ninterface\n\nuses Entities, System.Generics.Collections;\n\n\ntype\n  IPeopleService = interface\n    ['{347532A0-1B28-40C3-A2E9-51DF62365FE7}']\n    function GetAll: TObjectList<TPerson>;\n  end;\n\n  IConnectionService = interface\n    ['{146C21A5-07E8-456D-8E6D-A72820BD17AA}']\n    function GetConnectionName: String;\n  end;\n\nimplementation\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing Entities;\n\nnamespace Services.InterfacesU\n{\n    [Guid(\"347532A0-1B28-40C3-A2E9-51DF62365FE7\")]\n    public interface IPeopleService\n    {\n        IList<TPerson> GetAll();\n    }\n\n    [Guid(\"146C21A5-07E8-456D-8E6D-A72820BD17AA\")]\n    public interface IConnectionService\n    {\n        string GetConnectionName();\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Json.Schema.Common.Types;\n\ninterface\n\ntype\n  TSchemaKind = (skUnknown, skInteger, skInt64, skNumber, skDateTime, skDate, skTime, skEnumeration, skBoolean,\n     skObject, skArray, skString, skChar, skGuid);\n\n  ASchemaType = class(TCustomAttribute)\n  strict private\n    fKind: TSchemaKind;\n\n    const c_SchemaTypeBoolean = 'boolean';\n    const c_SchemaTypeInteger = 'integer';\n    const c_SchemaTypeNumber = 'number';\n    const c_SchemaTypeString = 'string';\n    const c_SchemaTypeArray = 'array';\n    const c_SchemaTypeObject = 'object';\n\n    function GetName: string;\n  public\n    constructor Create(const pKind: TSchemaKind);\n    property Name: string read GetName;\n    property Kind: TSchemaKind read fKind;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ ASchemaType }\n\nconstructor ASchemaType.Create(const pKind: TSchemaKind);\nbegin\n  inherited Create;\n  fKind := pKind;\nend;\n\nfunction ASchemaType.GetName: string;\nbegin\n  Result := EmptyStr;\n  case fKind of\n    skInteger, skInt64, skEnumeration: Result := c_SchemaTypeInteger;\n    skNumber: Result := c_SchemaTypeNumber;\n    skString, skChar, skGuid, skDateTime, skDate, skTime: Result := c_SchemaTypeString;\n    skBoolean: Result := c_SchemaTypeBoolean;\n    skObject: Result := c_SchemaTypeObject;\n    skArray: Result := c_SchemaTypeArray;\n  end;\nend;\n\nend.", "output": "using System;\n\nnamespace Json.Schema.Common.Types\n{\n    public enum SchemaKind\n    {\n        Unknown,\n        Integer,\n        Int64,\n        Number,\n        DateTime,\n        Date,\n        Time,\n        Enumeration,\n        Boolean,\n        Object,\n        Array,\n        String,\n        Char,\n        Guid\n    }\n\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\n    public class SchemaTypeAttribute : Attribute\n    {\n        private readonly SchemaKind _kind;\n\n        private const string SchemaTypeBoolean = \"boolean\";\n        private const string SchemaTypeInteger = \"integer\";\n        private const string SchemaTypeNumber = \"number\";\n        private const string SchemaTypeString = \"string\";\n        private const string SchemaTypeArray = \"array\";\n        private const string SchemaTypeObject = \"object\";\n\n        public SchemaTypeAttribute(SchemaKind kind)\n        {\n            _kind = kind;\n        }\n\n        public string Name\n        {\n            get\n            {\n                switch (_kind)\n                {\n                    case SchemaKind.Integer:\n                    case SchemaKind.Int64:\n                    case SchemaKind.Enumeration:\n                        return SchemaTypeInteger;\n                    case SchemaKind.Number:\n                        return SchemaTypeNumber;\n                    case SchemaKind.String:\n                    case SchemaKind.Char:\n                    case SchemaKind.Guid:\n                    case SchemaKind.DateTime:\n                    case SchemaKind.Date:\n                    case SchemaKind.Time:\n                        return SchemaTypeString;\n                    case SchemaKind.Boolean:\n                        return SchemaTypeBoolean;\n                    case SchemaKind.Object:\n                        return SchemaTypeObject;\n                    case SchemaKind.Array:\n                        return SchemaTypeArray;\n                    default:\n                        return string.Empty;\n                }\n            }\n        }\n\n        public SchemaKind Kind => _kind;\n    }\n}"}
{"input": "{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Sample.SwagDoc;\n\ninterface\n\nuses\n  Swag.Doc;\n\ntype\n  TSampleApiSwagDocBuilder = class(TObject)\n  strict private\n    fSwagDoc: TSwagDoc;\n    fDeployFolder: string;\n\n    procedure DocumentApiInfo;\n    procedure DocumentApiSettings;\n    procedure DocumentApi;\n    procedure DocumentApiEmployee;\n\n    procedure SaveSwaggerJson;\n  private\n    procedure SetDeployFolder(const Value: string);\n  public\n    function Generate: string;\n    property DeployFolder: string read fDeployFolder write SetDeployFolder;\n  end;\n\nimplementation\n\nuses\n  Json.Common.Helpers,\n  Swag.Common.Types,\n  Sample.Api.Employee;\n\n{ TSampleApiSwagDocBuilder }\n\nfunction TSampleApiSwagDocBuilder.Generate: string;\nbegin\n  fSwagDoc := TSwagDoc.Create;\n  try\n    DocumentApiInfo;\n    DocumentApiSettings;\n    DocumentApi;\n    fSwagDoc.GenerateSwaggerJson;\n    SaveSwaggerJson;\n    Result := fSwagDoc.SwaggerJson.Format;\n  finally\n    fSwagDoc.Free;\n  end;\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiInfo;\nbegin\n  fSwagDoc.Info.Title := 'Sample API';\n  fSwagDoc.Info.Version := 'v1';\n  fSwagDoc.Info.TermsOfService := 'http://www.apache.org/licenses/LICENSE-2.0.txt';\n  fSwagDoc.Info.Description := 'Sample API Description';\n  fSwagDoc.Info.Contact.Name := 'Marcelo Jaloto';\n  fSwagDoc.Info.Contact.Email := 'marcelojaloto@gmail.com';\n  fSwagDoc.Info.Contact.Url := 'https://github.com/marcelojaloto/SwagDoc';\n  fSwagDoc.Info.License.Name := 'Apache License - Version 2.0, January 2004';\n  fSwagDoc.Info.License.Url := 'http://www.apache.org/licenses/LICENSE-2.0';\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiSettings;\nbegin\n  fSwagDoc.Host := 'localhost';\n  fSwagDoc.BasePath := '/api';\n\n  fSwagDoc.Consumes.Add('application/json');\n  fSwagDoc.Produces.Add('application/json');\n\n  fSwagDoc.Schemes := [tpsHttp];\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApi;\nbegin\n  DocumentApiEmployee;\nend;\n\nprocedure TSampleApiSwagDocBuilder.DocumentApiEmployee;\nvar\n  vApiEmployee: TFakeApiEmployee;\nbegin\n  vApiEmployee := TFakeApiEmployee.Create;\n  try\n    vApiEmployee.DocumentApi(fSwagDoc);\n  finally\n    vApiEmployee.Free;\n  end;\nend;\n\nprocedure TSampleApiSwagDocBuilder.SaveSwaggerJson;\nbegin\n  fSwagDoc.SwaggerFilesFolder := fDeployFolder;\n  fSwagDoc.SaveSwaggerJsonToFile;\nend;\n\nprocedure TSampleApiSwagDocBuilder.SetDeployFolder(const Value: string);\nbegin\n  fDeployFolder := Value;\nend;\n\nend.", "output": "using System;\nusing Swag.Doc;\nusing Swag.Common.Types;\nusing Sample.Api.Employee;\n\nnamespace Sample\n{\n    public class SampleApiSwagDocBuilder\n    {\n        private TSwagDoc _swagDoc;\n        private string _deployFolder;\n        public string DeployFolder { get => _deployFolder; set => _deployFolder = value; }\n        public string Generate()\n        {\n            _swagDoc = new TSwagDoc();\n            try\n            {\n                DocumentApiInfo();\n                DocumentApiSettings();\n                DocumentApi();\n                _swagDoc.GenerateSwaggerJson();\n                SaveSwaggerJson();\n                return _swagDoc.SwaggerJson.Format;\n            }\n            finally\n            {\n                _swagDoc.Dispose();\n            }\n        }\n        private void DocumentApiInfo()\n        {\n            _swagDoc.Info.Title = \"Sample API\";\n            _swagDoc.Info.Version = \"v1\";\n            _swagDoc.Info.TermsOfService = \"http://www.apache.org/licenses/LICENSE-2.0.txt\";\n            _swagDoc.Info.Description = \"Sample API Description\";\n            _swagDoc.Info.Contact.Name = \"Marcelo Jaloto\";\n            _swagDoc.Info.Contact.Email = \"marcelojaloto@gmail.com\";\n            _swagDoc.Info.Contact.Url = \"https://github.com/marcelojaloto/SwagDoc\";\n            _swagDoc.Info.License.Name = \"Apache License - Version 2.0, January 2004\";\n            _swagDoc.Info.License.Url = \"http://www.apache.org/licenses/LICENSE-2.0\";\n        }\n        private void DocumentApiSettings()\n        {\n            _swagDoc.Host = \"localhost\";\n            _swagDoc.BasePath = \"/api\";\n            _swagDoc.Consumes.Add(\"application/json\");\n            _swagDoc.Produces.Add(\"application/json\");\n            _swagDoc.Schemes = new TSwagProtocol[] { TSwagProtocol.tpsHttp };\n        }\n        private void DocumentApi()\n        {\n            DocumentApiEmployee();\n        }\n        private void DocumentApiEmployee()\n        {\n            using (TFakeApiEmployee vApiEmployee = new TFakeApiEmployee())\n            {\n                vApiEmployee.DocumentApi(_swagDoc);\n            }\n        }\n        private void SaveSwaggerJson()\n        {\n            _swagDoc.SwaggerFilesFolder = _deployFolder;\n            _swagDoc.SaveSwaggerJsonToFile();\n        }\n    }\n}"}
{"input": "{\n *\tPROGRAM:\tObject oriented API samples.\n *\tMODULE:\t\t01.create.pas\n *\tDESCRIPTION:\tA sample of creating new database and new table in it.\n *\t\t\t\t\tRun second time (when database already exists) to see\n *\t\t\t\t\thow FbException is caught and handled by this code.\n *\n *\t\t\t\t\tExample for the following interfaces:\n *\t\t\t\t\tIMaster - main inteface to access all the rest\n *\t\t\t\t\tStatus - returns the status of executed command\n *\t\t\t\t\tProvider - main interface to access DB / service\n *\t\t\t\t\tAttachment - database attachment interface\n *\t\t\t\t\tTransaction - transaction interface\n *\t\t\t\t\tUtil - helper calls here and there\n *\t\t\t\t\tXpbBuilder - build various parameters blocks\n *\n *\t\t\t\t\tRun something like this to build: fpc -Fu<path-to-Firebird.pas> -Mdelphi 01.create.pas\n *\n *  The contents of this file are subject to the Initial\n *  Developer's Public License Version 1.0 (the \"License\");\n *  you may not use this file except in compliance with the\n *  License. You may obtain a copy of the License at\n *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.\n *\n *  Software distributed under the License is distributed AS IS,\n *  WITHOUT WARRANTY OF ANY KIND, either express or implied.\n *  See the License for the specific language governing rights\n *  and limitations under the License.\n *\n *  The Original Code was created by Alexander Peshkoff\n *  for the Firebird Open Source RDBMS project.\n *\n *  Copyright (c) 2015 Alexander Peshkoff <peshkoff@mail.ru>\n *  and all contributors signed below.\n *\n *  All Rights Reserved.\n *  Contributor(s): ______________________________________. }\n\nProgram create;\n\nuses Sysutils, Firebird;\n\nvar\n\t// Declare pointers to required interfaces\n\n\t// Status is used to return wide error description to user\n\tst : IStatus;\n\n\t// This is main interface of firebird, and the only one\n\t// for getting which there is special function in our API\n\tmaster : IMaster;\n\tutil : IUtil;\n\n\t// XpbBuilder helps to create various parameter blocks for API calls\n\tdpb : IXpbBuilder;\n\n\t// Provider is needed to start to work with database (or service)\n\tprov : IProvider;\n\n\t// Attachment and Transaction contain methods to work with\n\t// database attachment and transaction\n\tatt : IAttachment;\n\ttra : ITransaction;\n\n\tprocedure PrintError(s : IStatus);\n\tvar\n\t\tmaxMessage : Integer;\n\t\toutMessage : PAnsiChar;\n\tbegin\n\t\tmaxMessage := 256;\n\t\toutMessage := StrAlloc(maxMessage);\n\t\tutil.formatStatus(outMessage, maxMessage, s);\n\t\twriteln(outMessage);\n\t\tStrDispose(outMessage);\n\tend;\n\nbegin\n\t// Here we get access to master interface and helper utility interface\n\t// no error return may happen - these functions always succeed\n\tmaster := fb_get_master_interface;\n\tutil := master.getUtilInterface;\n\n\t// status vector and main dispatcher are returned by calls to IMaster functions\n\t// no error return may happen - these functions always succeed\n\tst := master.getStatus;\n\tprov := master.getDispatcher;\n\n\ttry\n\t\t// create DPB\n\t\tdpb := util.getXpbBuilder(st, IXpbBuilder.DPB, nil, 0);\n\t\tdpb.insertInt(st, isc_dpb_page_size, 4 * 1024);\n\t\tdpb.insertString(st, isc_dpb_user_name, 'sysdba');\n\t\tdpb.insertString(st, isc_dpb_password, 'masterkey');\n\n\t\t// create empty database\n\t\tatt := prov.createDatabase(st, 'fbtests.fdb', dpb.getBufferLength(st), dpb.getBuffer(st));\n\t\twriteln ('Database fbtests.fdb created');\n\n\t\t// detach from database\n\t\tatt.detach(st);\n\t\tatt := nil;\n\n\t\t// remove unneeded any more tag from DPB\n\t\tif dpb.findFirst(st, isc_dpb_page_size)\n\t\t\tthen dpb.removeCurrent(st);\n\n\t\t// attach it once again\n\t\tatt := prov.attachDatabase(st, 'fbtests.fdb', dpb.getBufferLength(st), dpb.getBuffer(st));\n\t\twriteln ('Re-attached database fbtests.fdb');\n\n\t\t// start transaction\n\t\ttra := att.startTransaction(st, 0, nil);\n\n\t\t// create table\n\t\tatt.execute(st, tra, 0, 'create table dates_table (d1 date)', 3,\n\t\t\tnil, nil, nil, nil);\t// Input parameters and output data not used\n\n\t\t// commit transaction retaining\n\t\ttra.commitRetaining(st);\n\t\twriteln ('Table dates_table created');\n\n\t\t// insert a record into dates_table\n\t\tatt.execute(st, tra, 0, 'insert into dates_table values (CURRENT_DATE)', 3,\n\t\t\tnil, nil, nil, nil);\t// Input parameters and output data not used\n\n\t\t// commit transaction (will close interface)\n\t\ttra.commit(st);\n\t\ttra := nil;\n\n\t\twriteln ('Record inserted into dates_table');\n\n\t\t// detach from database (will close interface)\n\t\tatt.detach(st);\n\t\tatt := nil;\n\n\t\tdpb.dispose;\n\t\tdpb := nil;\n\texcept\n\t\ton e: FbException do PrintError(e.getStatus);\n\tend;\n\n\tprov.release;\nend.", "output": "using System;\nusing System.IO;\nusing FirebirdSql.Data.FirebirdClient;\n\nnamespace CreateDatabaseSample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string connectionString = \"User=SYSDBA;\" +\n                                      \"Password=masterkey;\" +\n                                      \"Database=fbtests.fdb;\" +\n                                      \"DataSource=localhost;\" +\n                                      \"Port=3050;\" +\n                                      \"Dialect=3;\";\n            try\n            {\n                if (!File.Exists(\"fbtests.fdb\"))\n                {\n                    FbConnection.CreateDatabase(connectionString);\n                    Console.WriteLine(\"Database fbtests.fdb created\");\n                }\n                else\n                {\n                    Console.WriteLine(\"Database fbtests.fdb already exists. Re-attaching.\");\n                }\n\n                using (var connection = new FbConnection(connectionString))\n                {\n                    connection.Open();\n                    Console.WriteLine(\"Re-attached database fbtests.fdb\");\n\n                    using (var transaction = connection.BeginTransaction())\n                    {\n                        using (var command = new FbCommand(\"CREATE TABLE dates_table (d1 DATE)\", connection, transaction))\n                        {\n                            command.ExecuteNonQuery();\n                        }\n                        transaction.Commit();\n                        Console.WriteLine(\"Table dates_table created\");\n                    }\n\n                    using (var transaction = connection.BeginTransaction())\n                    {\n                        using (var command = new FbCommand(\"INSERT INTO dates_table VALUES (CURRENT_DATE)\", connection, transaction))\n                        {\n                            command.ExecuteNonQuery();\n                        }\n                        transaction.Commit();\n                        Console.WriteLine(\"Record inserted into dates_table\");\n                    }\n\n                    connection.Close();\n                }\n            }\n            catch (FbException ex)\n            {\n                Console.WriteLine(\"Error: \" + ex.Message);\n            }\n        }\n    }\n}"}
{"input": "unit Horse.WebModule;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fpWeb,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$ENDIF}\n  Horse.Core;\n\ntype\n{$IF DEFINED(FPC)}\n  THorseWebModule = class(TFPWebModule)\n    procedure DoOnRequest(ARequest: TRequest; AResponse: TResponse; var AHandled: Boolean); override;\n{$ELSE}\n  THorseWebModule = class(TWebModule)\n{$ENDIF}\n    procedure HandlerAction(const Sender: TObject; const Request: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}; const Response: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; var Handled: Boolean);\n  private\n    FHorse: THorseCore;\n    class var FInstance: THorseWebModule;\n  public\n    property Horse: THorseCore read FHorse write FHorse;\n    constructor Create(AOwner: TComponent); override;\n  \tclass function GetInstance: THorseWebModule;\n  end;\n\nvar\n{$IF DEFINED(FPC)}\n  HorseWebModule: THorseWebModule;\n{$ELSE}\n  WebModuleClass: TComponentClass = THorseWebModule;\n{$ENDIF}\n\nimplementation\n\nuses\n  Horse.Request,\n  Horse.Response,\n  Horse.Exception.Interrupted;\n\n{$IF DEFINED(FPC)}\n  {$R Horse.WebModule.lfm}\n{$ELSE}\n  {$R *.dfm}\n{$ENDIF}\n\nclass function THorseWebModule.GetInstance: THorseWebModule;\nbegin\n  Result := FInstance;\nend;\n\nconstructor THorseWebModule.Create(AOwner: TComponent);\nbegin\n{$IF DEFINED(FPC)}\n  inherited CreateNew(AOwner, 0);\n{$ELSE}\n  inherited;\n{$ENDIF}\n  FHorse := THorseCore.GetInstance;\n  FInstance := Self;\nend;\n\n{$IF DEFINED(FPC)}\nprocedure THorseWebModule.DoOnRequest(ARequest: {$IF DEFINED(FPC)}TRequest{$ELSE}  TWebRequest {$ENDIF}; AResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}  TWebResponse {$ENDIF}; var AHandled: Boolean);\nbegin\n  HandlerAction(Self, ARequest, AResponse, AHandled);\nend;\n{$ENDIF}\n\nprocedure THorseWebModule.HandlerAction(const Sender: TObject; const Request: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\n  const Response: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; var Handled: Boolean);\nvar\n  LRequest: THorseRequest;\n  LResponse: THorseResponse;\nbegin\n  Handled := True;\n  LRequest := THorseRequest.Create(Request);\n  LResponse := THorseResponse.Create(Response);\n  try\n    try\n      FHorse.Routes.Execute(LRequest, LResponse)\n    except\n      on E: Exception do\n        if not E.InheritsFrom(EHorseCallbackInterrupted) then\n          raise;\n    end;\n  finally\n    if LRequest.Body<TObject> = LResponse.Content then\n      LResponse.Content(nil);\n    LRequest.Free;\n    LResponse.Free;\n  end;\nend;\n\n{$IF DEFINED(FPC)}\ninitialization\n  RegisterHTTPModule(THorseWebModule);\n{$ENDIF}\n\nend.", "output": "using System;\nusing Horse.Request;     \nusing Horse.Response;    \nusing Horse.Core;        \nusing System.Web;       \n\nnamespace Horse.WebModule\n{\n    \n    public class HorseWebModule \n    {\n        private THorseCore _horse;\n        private static HorseWebModule _instance;\n\n        \n        public THorseCore Horse\n        {\n            get { return _horse; }\n            set { _horse = value; }\n        }\n\n       \n        public HorseWebModule(object owner = null)\n        {\n            \n            _horse = THorseCore.GetInstance();\n            _instance = this;\n        }\n\n        \n        public static HorseWebModule GetInstance()\n        {\n            return _instance;\n        }\n\n        \n        public void HandlerAction(object sender, TWebRequest request, TWebResponse response, ref bool handled)\n        {\n            handled = true;\n            \n            HorseRequest horseRequest = new HorseRequest(request);\n            HorseResponse horseResponse = new HorseResponse(response);\n            try\n            {\n                try\n                {\n                    \n                    _horse.Routes.Execute(horseRequest, horseResponse);\n                }\n                catch (Exception ex)\n                {\n                    \n                    if (!(ex is HorseCallbackInterruptedException))\n                    {\n                        throw;\n                    }\n                }\n            }\n            finally\n            {\n                \n                if (horseRequest.Body<object>() == horseResponse.Content())\n                {\n                    horseResponse.Content(null);\n                }\n                horseRequest.Dispose();\n                horseResponse.Dispose();\n            }\n        }\n    }\n}"}
{"input": "unit Horse.Core.Param.Field;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  DateUtils,\n  Generics.Collections,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  System.DateUtils,\n  System.Generics.Collections,\n  System.Rtti,\n{$ENDIF}\n  Horse.Exception,\n  Horse.Commons,\n  Horse.Core.Param.Field.Brackets,\n  Horse.Core.Param.Config;\n\ntype\n\n  THorseCoreParamField = class\n  private\n    FContains: Boolean;\n    FFieldName: string;\n    FRequired: Boolean;\n    FRequiredMessage: string;\n    FInvalidFormatMessage: string;\n    FDateFormat: string;\n    FTimeFormat: string;\n    FReturnUTC: Boolean;\n    FTrueValue: string;\n    FValue: string;\n    FStream: TStream;\n    FLhsBrackets: THorseCoreParamFieldLhsBrackets;\n\n    function GetFormatSettings: TFormatSettings;\n    procedure RaiseHorseException(const AMessage: string); overload;\n    procedure RaiseHorseException(const AMessage: string; const Args: array of const); overload;\n    function TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;\n    procedure InitializeLhsBrackets(const AParams: TDictionary<string, string>; const AFieldName: string);\n  public\n    function DateFormat(const AValue: string): THorseCoreParamField;\n    function InvalidFormatMessage(const AValue: string): THorseCoreParamField;\n    function Required: THorseCoreParamField; overload;\n    function Required(const AValue: Boolean): THorseCoreParamField; overload;\n    function RequiredMessage(const AValue: string): THorseCoreParamField;\n    function ReturnUTC(const AValue: Boolean): THorseCoreParamField;\n    function TimeFormat(const AValue: string): THorseCoreParamField;\n    function TrueValue(const AValue: string): THorseCoreParamField;\n    procedure SaveToFile(const AFileName: String);\n    function AsBoolean: Boolean;\n    function AsCurrency: Currency;\n    function AsDate: TDateTime;\n    function AsDateTime: TDateTime;\n    function AsExtended: Extended;\n    function AsFloat: Double;\n    function AsInteger: Integer;\n    function AsInt64: Int64;\n    function AsISO8601DateTime: TDateTime;\n    function AsStream: TStream;\n    function AsString: string;\n    function AsTime: TTime;\n    function AsList: TList<string>; overload;\n   {$IF NOT DEFINED(FPC)}\n    function AsList<T>: TList<T>; overload;\n   {$ENDIF}\n    property LhsBrackets:THorseCoreParamFieldLhsBrackets read FLhsBrackets;\n    constructor Create(const AParams: TDictionary<string, string>; const AFieldName: string); overload;\n    constructor Create(const AStream: TStream; const AFieldName: string); overload;\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseCoreParamField.AsBoolean: Boolean;\nvar\n  LStrParam: string;\nbegin\n  Result := False;\n  LStrParam := Trim(AsString);\n  if LStrParam <> EmptyStr then\n    Result := LowerCase(LStrParam) = LowerCase(FTrueValue);\nend;\n\nfunction THorseCoreParamField.AsCurrency: Currency;\nbegin\n  Result := AsFloat;\nend;\n\nfunction THorseCoreParamField.AsDate: TDateTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToDate(Copy(LStrParam, 1, Length(FDateFormat)), LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'date']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsDateTime: TDateTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToDateTime(LStrParam, LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'datetime']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsExtended: Extended;\nbegin\n  Result := AsFloat;\nend;\n\nfunction THorseCoreParamField.AsFloat: Double;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LStrParam := LStrParam.Replace(',', FormatSettings.DecimalSeparator).Replace('.', FormatSettings.DecimalSeparator);\n    Result := StrToFloat(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'numeric']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsInt64: Int64;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam <> EmptyStr then\n      Result := StrToInt64(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'int64']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsInteger: Integer;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam <> EmptyStr then\n      Result := StrToInt(LStrParam);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'integer']);\n  end;\nend;\n\nfunction THorseCoreParamField.AsISO8601DateTime: TDateTime;\nvar\n  LStrParam: string;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  if LStrParam = EmptyStr then\n    Exit;\n  if not TryISO8601ToDate(LStrParam, Result) then\n    RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'ISO8601 date']);\nend;\n\nfunction THorseCoreParamField.AsList: TList<string>;\nvar\n  ValueArray : TArray<string>;\n  i: Integer;\nbegin\n  Result := TList<string>.Create;\n  if FContains then\n  begin\n    ValueArray := FValue.Split([',']);\n    for i := 0 to High(ValueArray) do\n    begin\n      Result.Add(ValueArray[i]);\n    end;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\n{$IF NOT DEFINED(FPC)}\nfunction THorseCoreParamField.AsList<T>: TList<T>;\nvar\n  ValueArray : TArray<string>;\n  i: Integer;\nbegin\n  Result := TList<T>.Create;\n  if FContains then\n  begin\n    ValueArray := FValue.Split([',']);\n    for i := 0 to High(ValueArray) do\n    begin\n      case GetTypeKind(T) of\n        tkString, tkUString:\n          Result.Add(TValue.From<string>(ValueArray[i]).AsType<T>);\n        tkInteger:\n          Result.Add(TValue.From<Integer>(StrToInt(ValueArray[i])).AsType<T>);\n        tkInt64:\n          Result.Add(TValue.From<Int64>(StrToInt64(ValueArray[i])).AsType<T>);\n        tkFloat:\n          Result.Add(TValue.From<Double>(StrToFloat(ValueArray[i])).AsType<T>);\n        tkVariant:\n          Result.Add(TValue.From<variant>(ValueArray[i]).AsType<T>);\n      else\n        // Specific handling for Datetime, Date, and Time, as they are not present in the TypeKind list.\n        begin\n          if TypeInfo(T) = TypeInfo(TDateTime) then\n            Result.Add(TValue.From<TDateTime>(StrToDateTime(ValueArray[i])).AsType<T>)\n          else if TypeInfo(T) = TypeInfo(TDate) then\n            Result.Add(TValue.From<TDate>(StrToDate(ValueArray[i])).AsType<T>)\n          else if TypeInfo(T) = TypeInfo(TTime) then\n            Result.Add(TValue.From<TTime>(StrToTime(ValueArray[i])).AsType<T>)\n          else\n            raise EHorseException.New.Error('Unsupported type');\n        end;\n      end;\n    end;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n{$ENDIF}\n\nfunction THorseCoreParamField.AsStream: TStream;\nbegin\n  Result := nil;\n  if FContains then\n  begin\n    Result := FStream;\n    if Assigned(Result) then\n      Result.Position := 0;\n  end\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\nfunction THorseCoreParamField.AsString: string;\nbegin\n  Result := EmptyStr;\n  if FContains then\n    Result := FValue\n  else if FRequired then\n    RaiseHorseException(FRequiredMessage, [FFieldName]);\nend;\n\nfunction THorseCoreParamField.AsTime: TTime;\nvar\n  LStrParam: string;\n  LFormat: TFormatSettings;\nbegin\n  Result := 0;\n  LStrParam := Trim(AsString);\n  try\n    if LStrParam = EmptyStr then\n      Exit;\n    LFormat := GetFormatSettings;\n    Result := StrToTime(Copy(LStrParam, 1, Length(FTimeFormat)), LFormat);\n  except\n    on E: EConvertError do\n      RaiseHorseException(FInvalidFormatMessage, [FFieldName, LStrParam, 'time']);\n  end;\nend;\n\nconstructor THorseCoreParamField.Create(const AStream: TStream; const AFieldName: string);\nbegin\n  FContains := True;\n  FFieldName := AFieldName;\n  FValue := EmptyStr;\n  FRequired := False;\n  FStream := AStream;\nend;\n\nconstructor THorseCoreParamField.Create(const AParams: TDictionary<string, string>; const AFieldName: string);\nvar\n  LKey: string;\nbegin\n  FContains := False;\n  FFieldName := AFieldName;\n  FValue := EmptyStr;\n  FRequired := False;\n\n  for LKey in AParams.Keys do\n  begin\n    if AnsiCompareText(LKey, FFieldName) = 0 then\n    begin\n      FContains := True;\n      Break;\n    end;\n  end;\n\n  if FContains then\n    FValue := AParams.Items[LKey];\n\n  InitializeLhsBrackets(AParams, AFieldName);\nend;\n\ndestructor THorseCoreParamField.Destroy;\nbegin\n  FLhsBrackets.Free;\n  inherited Destroy;\nend;\n\nfunction THorseCoreParamField.DateFormat(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FDateFormat := AValue;\nend;\n\nfunction THorseCoreParamField.GetFormatSettings: TFormatSettings;\nbegin\n{$IF DEFINED(FPC)}\n  Result := DefaultFormatSettings;\n{$ELSE}\n  Result := TFormatSettings.Create;\n{$ENDIF}\n  if FDateFormat.IndexOf('-') > 0 then\n    Result.DateSeparator := '-';\n  Result.ShortDateFormat := FDateFormat;\n  Result.ShortTimeFormat := FTimeFormat;\nend;\n\nprocedure THorseCoreParamField.InitializeLhsBrackets(const AParams: TDictionary<string, string>; const AFieldName: string);\nvar\n  LLhsBracketType: TLhsBracketsType;\nbegin\n  FLhsBrackets := THorseCoreParamFieldLhsBrackets.Create;\n  if THorseCoreParamConfig.GetInstance.CheckLhsBrackets then\n  begin\n    for LLhsBracketType := Low(TLhsBracketsType) to High(TLhsBracketsType) do\n    begin\n      if AParams.ContainsKey(FFieldName + LLhsBracketType.ToString) then\n      begin\n        FLhsBrackets.SetValue(LLhsBracketType, AParams.Items[FFieldName+LLhsBracketType.ToString]);\n        FLhsBrackets.Types := FLhsBrackets.Types + [LLhsBracketType];\n      end;\n    end;\n  end;\nend;\n\nfunction THorseCoreParamField.InvalidFormatMessage(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FInvalidFormatMessage := AValue;\nend;\n\nprocedure THorseCoreParamField.RaiseHorseException(const AMessage: string; const Args: array of const);\nbegin\n  RaiseHorseException(Format(AMessage, Args));\nend;\n\nprocedure THorseCoreParamField.RaiseHorseException(const AMessage: string);\nvar\n  LException: EHorseException;\nbegin\n  LException := EHorseException.New.Status(THTTPStatus.BadRequest).Error(AMessage);\n  LException.Message := AMessage;\n  raise LException;\nend;\n\nfunction THorseCoreParamField.Required(const AValue: Boolean): THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequired := AValue;\nend;\n\nfunction THorseCoreParamField.Required: THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequired := True;\nend;\n\nfunction THorseCoreParamField.RequiredMessage(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FRequiredMessage := AValue;\nend;\n\nfunction THorseCoreParamField.ReturnUTC(const AValue: Boolean): THorseCoreParamField;\nbegin\n  Result := Self;\n  FReturnUTC := AValue;\nend;\n\nprocedure THorseCoreParamField.SaveToFile(const AFileName: String);\nvar\n  LMemoryStream: TMemoryStream;\nbegin\n  if AsStream = nil then\n    Exit;\n\n  LMemoryStream := TMemoryStream.Create;\n  try\n    LMemoryStream.LoadFromStream(AsStream);\n    LMemoryStream.Position := 0;\n    LMemoryStream.SaveToFile(AFileName);\n  finally\n    LMemoryStream.Free;\n  end;\nend;\n\nfunction THorseCoreParamField.TimeFormat(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FTimeFormat := AValue;\nend;\n\nfunction THorseCoreParamField.TrueValue(const AValue: string): THorseCoreParamField;\nbegin\n  Result := Self;\n  FTrueValue := AValue;\nend;\n\nfunction THorseCoreParamField.TryISO8601ToDate(const AValue: string; out Value: TDateTime): Boolean;\nbegin\n  Value := ISO8601ToDate(AValue, FReturnUTC);\n  Result := True;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\n\nnamespace Horse.Core.Param.Field\n{\n    #region Dependent Stubs\n\n    public class HorseException : Exception\n    {\n        public int Status { get; set; }\n        public HorseException(string message) : base(message) { }\n        public static HorseException New(int status, string message)\n        {\n            return new HorseException(message) { Status = status };\n        }\n    }\n\n    public static class HTTPStatus\n    {\n        public const int BadRequest = 400;\n    }\n\n    public class HorseCoreParamConfig\n    {\n        private static HorseCoreParamConfig _instance;\n        public bool CheckLhsBrackets { get; set; } = false;\n        private HorseCoreParamConfig() { }\n        public static HorseCoreParamConfig GetInstance()\n        {\n            if (_instance == null)\n                _instance = new HorseCoreParamConfig();\n            return _instance;\n        }\n    }\n\n    public enum TLhsBracketsType\n    {\n        Square, \n        Curly   \n        \n    }\n\n    \n    public class HorseCoreParamFieldLhsBrackets\n    {\n        public List<TLhsBracketsType> Types { get; } = new List<TLhsBracketsType>();\n        private readonly Dictionary<TLhsBracketsType, string> _values = new Dictionary<TLhsBracketsType, string>();\n        public void SetValue(TLhsBracketsType type, string value)\n        {\n            _values[type] = value;\n        }\n    }\n\n    #endregion\n\n    public class HorseCoreParamField : IDisposable\n    {\n        \n        private bool FContains;\n        private string FFieldName;\n        private bool FRequired;\n        private string FRequiredMessage;\n        private string FInvalidFormatMessage;\n        private string FDateFormat;\n        private string FTimeFormat;\n        private bool FReturnUTC;\n        private string FTrueValue;\n        private string FValue;\n        private Stream FStream;\n        private HorseCoreParamFieldLhsBrackets FLhsBrackets;\n\n        \n        public HorseCoreParamField(Dictionary<string, string> AParams, string AFieldName)\n        {\n            FFieldName = AFieldName;\n            FValue = \"\";\n            FRequired = false;\n            FContains = false;\n            \n            foreach (var key in AParams.Keys)\n            {\n                if (string.Equals(key, FFieldName, StringComparison.OrdinalIgnoreCase))\n                {\n                    FContains = true;\n                    FValue = AParams[key];\n                    break;\n                }\n            }\n            InitializeLhsBrackets(AParams, AFieldName);\n        }\n\n       \n        public HorseCoreParamField(Stream AStream, string AFieldName)\n        {\n            FFieldName = AFieldName;\n            FValue = \"\";\n            FRequired = false;\n            FContains = true;\n            FStream = AStream;\n        }\n\n        \n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                \n                FLhsBrackets = null;\n                \n            }\n        }\n        ~HorseCoreParamField() => Dispose(false);\n\n        #region Fluent Setters and Getters\n\n        public HorseCoreParamField DateFormat(string AValue)\n        {\n            FDateFormat = AValue;\n            return this;\n        }\n        public string DateFormat() => FDateFormat;\n\n        public HorseCoreParamField InvalidFormatMessage(string AValue)\n        {\n            FInvalidFormatMessage = AValue;\n            return this;\n        }\n        public string InvalidFormatMessage() => FInvalidFormatMessage;\n\n        public HorseCoreParamField Required()\n        {\n            FRequired = true;\n            return this;\n        }\n        public HorseCoreParamField Required(bool AValue)\n        {\n            FRequired = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField RequiredMessage(string AValue)\n        {\n            FRequiredMessage = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField ReturnUTC(bool AValue)\n        {\n            FReturnUTC = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField TimeFormat(string AValue)\n        {\n            FTimeFormat = AValue;\n            return this;\n        }\n\n        public HorseCoreParamField TrueValue(string AValue)\n        {\n            FTrueValue = AValue;\n            return this;\n        }\n\n        \n        public HorseCoreParamField CheckLhsBrackets(bool AValue)\n        {\n            \n            return this;\n        }\n\n        \n        public HorseCoreParamFieldLhsBrackets LhsBrackets => FLhsBrackets;\n\n        #endregion\n\n        #region Conversion Methods\n\n        public bool AsBoolean()\n        {\n            string LStrParam = AsString().Trim();\n            if (!string.IsNullOrEmpty(LStrParam))\n                return LStrParam.ToLowerInvariant() == FTrueValue.ToLowerInvariant();\n            return false;\n        }\n\n        public double AsCurrency() => AsFloat();\n\n        public DateTime AsDate()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            try\n            {\n                var fs = GetFormatSettings();\n                \n                string datePart = LStrParam.Substring(0, Math.Min(FDateFormat.Length, LStrParam.Length));\n                return DateTime.ParseExact(datePart, FDateFormat, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"date\" });\n                return default;\n            }\n        }\n\n        public DateTime AsDateTime()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            try\n            {\n                var fs = GetFormatSettings();\n                return DateTime.Parse(LStrParam, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"datetime\" });\n                return default;\n            }\n        }\n\n        public double AsExtended() => AsFloat();\n\n        public double AsFloat()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (string.IsNullOrEmpty(LStrParam))\n                    return 0;\n                var fs = GetFormatSettings();\n                \n                LStrParam = LStrParam.Replace(\",\", fs.NumberFormat.NumberDecimalSeparator)\n                                   .Replace(\".\", fs.NumberFormat.NumberDecimalSeparator);\n                return double.Parse(LStrParam, fs);\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"numeric\" });\n                return 0;\n            }\n        }\n\n        public long AsInt64()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (!string.IsNullOrEmpty(LStrParam))\n                    return long.Parse(LStrParam);\n                return 0;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"int64\" });\n                return 0;\n            }\n        }\n\n        public int AsInteger()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (!string.IsNullOrEmpty(LStrParam))\n                    return int.Parse(LStrParam);\n                return 0;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"integer\" });\n                return 0;\n            }\n        }\n\n        public DateTime AsISO8601DateTime()\n        {\n            string LStrParam = AsString().Trim();\n            if (string.IsNullOrEmpty(LStrParam))\n                return default;\n            DateTime dt;\n            if (!TryISO8601ToDate(LStrParam, out dt))\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"ISO8601 date\" });\n            return dt;\n        }\n\n        public Stream AsStream()\n        {\n            if (FContains)\n            {\n                if (FStream != null)\n                    FStream.Position = 0;\n                return FStream;\n            }\n            else if (FRequired)\n            {\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            }\n            return null;\n        }\n\n        public string AsString()\n        {\n            if (FContains)\n                return FValue;\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return \"\";\n        }\n\n        public TimeSpan AsTime()\n        {\n            string LStrParam = AsString().Trim();\n            try\n            {\n                if (string.IsNullOrEmpty(LStrParam))\n                    return default;\n                var fs = GetFormatSettings();\n                string timePart = LStrParam.Substring(0, Math.Min(FTimeFormat.Length, LStrParam.Length));\n                DateTime dt = DateTime.ParseExact(timePart, FTimeFormat, fs);\n                return dt.TimeOfDay;\n            }\n            catch (Exception)\n            {\n                RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, LStrParam, \"time\" });\n                return default;\n            }\n        }\n\n        public List<string> AsList()\n        {\n            if (FContains)\n            {\n                var arr = FValue.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                                .Select(s => s.Trim()).ToList();\n                return arr;\n            }\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return new List<string>();\n        }\n\n        public List<T> AsList<T>()\n        {\n            if (FContains)\n            {\n                var arr = FValue.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n                var list = new List<T>();\n                foreach (var s in arr)\n                {\n                    string trimmed = s.Trim();\n                    try\n                    {\n                        object converted = null;\n                        var targetType = typeof(T);\n                        if (targetType == typeof(string))\n                            converted = trimmed;\n                        else if (targetType == typeof(int))\n                            converted = int.Parse(trimmed);\n                        else if (targetType == typeof(long))\n                            converted = long.Parse(trimmed);\n                        else if (targetType == typeof(double))\n                            converted = double.Parse(trimmed, GetFormatSettings());\n                        else if (targetType == typeof(DateTime))\n                            converted = DateTime.Parse(trimmed, GetFormatSettings());\n                        else\n                        {\n                            if (targetType == typeof(DateTime)) \n                                converted = DateTime.Parse(trimmed, GetFormatSettings());\n                            else\n                                throw new Exception(\"Unsupported type\");\n                        }\n                        list.Add((T)converted);\n                    }\n                    catch (Exception)\n                    {\n                        RaiseHorseException(FInvalidFormatMessage, new object[] { FFieldName, trimmed, targetType.Name.ToLowerInvariant() });\n                    }\n                }\n                return list;\n            }\n            else if (FRequired)\n                RaiseHorseException(FRequiredMessage, new object[] { FFieldName });\n            return new List<T>();\n        }\n\n        #endregion\n\n        #region Helpers\n\n        \n        private CultureInfo GetFormatSettings()\n        {\n            CultureInfo ci = (CultureInfo)CultureInfo.CurrentCulture.Clone();\n            if (!string.IsNullOrEmpty(FDateFormat) && FDateFormat.Contains(\"-\"))\n                ci.DateTimeFormat.DateSeparator = \"-\";\n            ci.DateTimeFormat.ShortDatePattern = FDateFormat;\n            ci.DateTimeFormat.ShortTimePattern = FTimeFormat;\n            return ci;\n        }\n\n        private void RaiseHorseException(string AMessage, object[] Args)\n        {\n            string msg = string.Format(AMessage, Args);\n            RaiseHorseException(msg);\n        }\n\n        private void RaiseHorseException(string AMessage)\n        {\n            throw HorseException.New(HTTPStatus.BadRequest, AMessage);\n        }\n\n        \n        private bool TryISO8601ToDate(string AValue, out DateTime Value)\n        {\n            var style = FReturnUTC ? DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal : DateTimeStyles.None;\n            return DateTime.TryParse(AValue, null, style, out Value);\n        }\n\n        \n        private void InitializeLhsBrackets(Dictionary<string, string> AParams, string AFieldName)\n        {\n            FLhsBrackets = new HorseCoreParamFieldLhsBrackets();\n            if (HorseCoreParamConfig.GetInstance().CheckLhsBrackets)\n            {\n                foreach (TLhsBracketsType type in Enum.GetValues(typeof(TLhsBracketsType)))\n                {\n                    string key = FFieldName + type.ToString();\n                    if (AParams.ContainsKey(key))\n                    {\n                        FLhsBrackets.SetValue(type, AParams[key]);\n                        FLhsBrackets.Types.Add(type);\n                    }\n                }\n            }\n        }\n\n        #endregion\n\n        #region Fluent Setters (Additional)\n\n        public HorseCoreParamField RequiredMessage(string AValue)\n        {\n            FRequiredMessage = AValue;\n            return this;\n        }\n\n        #endregion\n       \n        #region Conversion of String Value\n\n        \n        private string Trim(string s)\n        {\n            return s?.Trim() ?? \"\";\n        }\n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit LiveServerTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  MVCFramework.RESTClient.Intf,\n  MVCFramework.RESTClient,\n  MVCFramework.JSONRPC.Client,\n  System.DateUtils,\n  System.Hash, System.Rtti, MVCFramework.Commons;\n\ntype\n\n  TBaseServerTest = class(TObject)\n  protected\n    RESTClient: IMVCRESTClient;\n    procedure DoLoginWith(UserName: string);\n    procedure DoLogout;\n  public\n    [Setup]\n    procedure Setup; virtual;\n    [TearDown]\n    procedure TearDown; virtual;\n\n  end;\n\n  [TestFixture]\n  TServerTest = class(TBaseServerTest)\n  public\n    [Test]\n    [TestCase('request url /fault', '/exception/fault')]\n    [TestCase('request url /fault2', '/exception/fault2')]\n    procedure TestControllerWithExceptionInCreate(const URLSegment: string);\n\n    [Test]\n    [TestCase('url \"/\"', '/')]\n    [TestCase('url \"/action1\"', '/action1')]\n    [TestCase('url \"/action2\"', '/action2')]\n    [TestCase('url \"/api/v1\"', '/api/v1')]\n    [TestCase('url \"/api/v1/action1\"', '/api/v1/action1')]\n    [TestCase('url \"/api/v1/action2\"', '/api/v1/action2')]\n    [TestCase('url \"/api/v2\"', '/api/v2')]\n    [TestCase('url \"/api/v2/action1\"', '/api/v2/action1')]\n    [TestCase('url \"/api/v2/action2\"', '/api/v2/action2')]\n    procedure TestMultiMVCPathOnControllerAndAction(const URLSegment: string);\n\n    [Test]\n    procedure TestReqWithParams;\n\n    // URL_MAPPED_PARAMS_ALLOWED_CHARS = ' \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd@\\[\\]\\{\\}\\(\\)\\=;&#\\.\\_\\,%\\w\\d\\x2D\\x3A';\n    [Test]\n    [TestCase('1', ' \ufffd,\ufffd')]\n    [TestCase('2', '\ufffd,\ufffd,\ufffd')]\n    [TestCase('3', '\ufffd,@,[')]\n    [TestCase('4', '],{,}')]\n    [TestCase('5', '(,),\\')]\n    [TestCase('6', '=,;,&')]\n    [TestCase('7', '#,.,_')]\n    [TestCase('8', '%, , ')]\n    procedure TestReqWithURLMappedParams(const par1, par2, par3: string);\n    [Test]\n    procedure TestPOSTWithParamsAndJSONBody;\n    [Test]\n    procedure TestPOSTWithObjectJSONBody;\n    [Test]\n    procedure TestCustomerEcho;\n    [Test]\n    procedure TestCustomerEchoWithRootNode;\n    [Test]\n    procedure TestEchoWithAllVerbs;\n    [Test]\n    procedure TestCustomerEchoBodyFor;\n    [Test]\n    procedure TestPOSTWithoutContentType;\n    [Test]\n    procedure TestXHTTPMethodOverride_POST_as_PUT;\n    [Test]\n    procedure TestPUTWithParamsAndJSONBody;\n    [Test]\n    procedure TestCookies;\n    [Test]\n    procedure TestSessionWithLogin;\n    [Test]\n    procedure TestSession;\n    [Test]\n    procedure TestInvalidateSession;\n    [Test]\n    procedure TestAsynchRequestPOST;\n    [Test]\n    procedure TestAsynchRequestPUT;\n    [Test]\n    procedure TestAsynchRequestGET;\n    [Test]\n    procedure TestAsynchRequestDELETE;\n    [Test]\n    procedure TestEncodingRenderJSONValue;\n    [Test]\n    procedure TestRenderWrappedList;\n    [Test]\n    procedure TestObjectDictIgnoredFields;\n    [Test]\n    procedure TestObjectDictIgnoredFieldsWithDataSets;\n    [Test]\n    procedure TestRenderActionInCollections;\n    [Test]\n    procedure TestRenderWrappedListWithCompression;\n    [Test]\n    procedure TestRenderStreamAndFreeWithOwnerFalse;\n    [Test]\n    procedure TestRenderStreamAndFreeWithOwnerTrue;\n    [Test]\n    procedure TestObjectDict;\n    [Test]\n    procedure TestGetImagePng;\n    [Test]\n    procedure TestProducesConsumes01;\n    [Test]\n    procedure TestProducesConsumes02;\n    [Test]\n    procedure TestProducesConsumes03;\n    [Test]\n    procedure TestProducesConsumesWithWrongAcceptHeader;\n    [Test]\n    procedure TestExceptionInMVCAfterCreate;\n    [Test]\n    procedure TestExceptionInMVCBeforeDestroy;\n    [Test]\n    procedure TestActionFiltersOnBeforeAction;\n    [Test]\n    procedure TestMiddlewareSpeedMiddleware;\n    [Test]\n    procedure TestMiddlewareHandler;\n    [Test]\n    procedure TestPostAListOfObjects;\n    // test authentication/authorization with BasicAuth\n    [Test]\n    procedure TestBasicAuth01;\n    [Test]\n    // [Category('this')]\n    procedure TestEntityWithArrays;\n    [Test]\n    // [Category('this')]\n    procedure TestEntityWithEmptyArrays;\n    [Test]\n    procedure TestEntityWithGUIDs;\n    [Test]\n    procedure TestEntityWithGUIDsEcho;\n    [Test]\n    procedure TestBasicAuth02;\n    [Test]\n    procedure TestBasicAuth03;\n    [Test]\n    procedure TestBasicAuth04;\n    [Test]\n    procedure TestBasicAuth05;\n    // test authentication/authorization with CustomAuth\n    [Test]\n    procedure TestCustomAuthRequestWithoutLogin;\n    [Test]\n    procedure TestCustomAuthRequestsWithValidLogin;\n    [Test]\n    procedure TestCustomAuthRequestsWithValidLogin_HTML;\n    [Test]\n    procedure TestCustomAuthWrongRequestBodies;\n    [Test]\n    procedure TestCustomAuthLoginLogout;\n\n    // typed actions\n    [Test]\n    procedure TestTypedString1;\n    [Test]\n    procedure TestTypedInteger1;\n    [Test]\n    procedure TestTypedInt641;\n    [Test]\n    procedure TestTypedSingle1;\n    [Test]\n    procedure TestTypedDouble1;\n    [Test]\n    procedure TestTypedExtended1;\n    [Test]\n    procedure TestTypedAll;\n    [Test]\n    [Category('datetime')]\n    procedure TestTypedDateTimeTypes;\n    [Test]\n    [Category('datetime')]\n    procedure TestTypedDateTimeTypes_UTC;\n    [Test]\n    procedure TestTypedBooleans;\n    [Test]\n    procedure TestTypedTGuid1;\n    [Test]\n    procedure TestStringDictionary;\n    [Test]\n    procedure TestWrongJSONBody;\n    [Test]\n    procedure TestTypedIntegerWrongParam1;\n\n    // test exceptions rendering\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException1;\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException2;\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException3;\n\n    [Test]\n    [Category('renders,exceptions')]\n    procedure TestEMVCException4;\n\n    [Test]\n    [Category('renders,exceptions')]\n    [TestCase('404'+'invalid_accept',               '404,/invalidurl,invalid_accept,' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('404'+TMVCMediaType.TEXT_HTML,        '404,/invalidurl,' + TMVCMediaType.TEXT_HTML + ',' + TMVCMediaType.TEXT_HTML)]\n    [TestCase('404'+TMVCMediaType.TEXT_PLAIN,       '404,/invalidurl,' +  TMVCMediaType.TEXT_PLAIN + ',' + TMVCMediaType.TEXT_PLAIN)]\n    [TestCase('404'+TMVCMediaType.APPLICATION_JSON, '404,/invalidurl,' + TMVCMediaType.APPLICATION_JSON + ',' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('500'+'invalid_accept',               '500,/exception/emvcexception1,invalid_accept,' + TMVCMediaType.APPLICATION_JSON)]\n    [TestCase('500'+TMVCMediaType.TEXT_HTML,        '500,/exception/emvcexception1,' + TMVCMediaType.TEXT_HTML + ',' + TMVCMediaType.TEXT_HTML)]\n    [TestCase('500'+TMVCMediaType.TEXT_PLAIN,       '500,/exception/emvcexception1,' +  TMVCMediaType.TEXT_PLAIN + ',' + TMVCMediaType.TEXT_PLAIN)]\n    [TestCase('500'+TMVCMediaType.APPLICATION_JSON, '500,/exception/emvcexception1,' + TMVCMediaType.APPLICATION_JSON + ',' + TMVCMediaType.APPLICATION_JSON)]\n\n    procedure TestResponseContentTypes(\n        const ExpectedStatus: Integer;\n        const URL: String;\n        const RequestAccept: String;\n        const ResponseContentType: String);\n\n    // test nullables\n    [Test]\n    procedure TestDeserializeNullablesWithValue;\n    [Test]\n    procedure TestDeserializeNullablesWithNulls;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables_ISSUE_362;\n    [Test]\n    procedure TestSerializeAndDeserializeNullables_Passing_Integers_InsteadOf_Floats;\n\n    //test sqids\n    [Test]\n    [TestCase('1', '1,Im1JUf')]\n    [TestCase('2','1234567890,LhXiwKz')]\n    [TestCase('3','9007199254740991,PTP7uQmcmk')]\n    procedure TestSqidSingle(IntValue: UInt64; Sqid: String);\n\n    [Test]\n    procedure TestWrongSqid;\n\n    [Test]\n    procedure TestInvalidConverter;\n\n    // test responses objects\n    [Test]\n    procedure TestResponseCreated;\n    [Test]\n    procedure TestResponseNoContent;\n    [Test]\n    procedure TestResponseAccepted;\n\n    // test web server\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryTraversal1;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryTraversal2;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestDirectoryRedirect;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestFileWithFolderName;\n    [Test]\n    [Category('staticfiles')]\n    procedure TestSPASupport;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestGetInject10;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestGetInject20;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject30;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject40;\n\n    [Test]\n    [Category('Injected')]\n    procedure TestPostInject50;\n\n    // test server side views\n    [Test]\n    procedure TestViewDataViewDataSet;\n\n    // test functional actions\n    [Test]\n    procedure TestFuncActionGetSingleRecord;\n\n    [Test]\n    procedure TestFuncActionGetMultipleRecords;\n\n    [Test]\n    procedure TestFuncActionGetDatasetSingle;\n\n    [Test]\n    procedure TestFuncActionGetDatasetMultiple;\n\n    [Test]\n    procedure TestFuncActionGetComplexObject;\n\n\n    // test functional actions with IMVCResponse and the MVCResponseBuilder\n    [Test]\n    procedure TestGetMVCResponseSimple;\n\n    [Test]\n    procedure TestGetMVCResponseWithJSON;\n\n    [Test]\n    procedure TestGetMVCResponseWithObjectList;\n\n    [Test]\n    procedure TestGetMVCResponseWithDataAndMessage;\n\n    [Test]\n    procedure TestGetMVCResponseSimpleBuilderWithHeaders;\n\n    // test issues\n    [Test]\n    [Category('renders')]\n    procedure TestIssue406;\n\n    [Test]\n    procedure TestIssue542;\n\n  end;\n\n  [TestFixture]\n  [Category('jsonrpc')]\n  TJSONRPCServerTest = class(TObject)\n  protected\n    FExecutor: IMVCJSONRPCExecutor;\n    FExecutor2: IMVCJSONRPCExecutor;\n    FExecutor3: IMVCJSONRPCExecutor;\n    procedure InitExecutors; virtual;\n  public\n    [Setup]\n    procedure Setup; virtual;\n    [Test]\n    procedure TestRequestWithoutParams;\n    [Test]\n    procedure TestNotificationWithoutParams;\n    [Test]\n    procedure TestNotificationWhichRaisesError;\n    [Test]\n    procedure TestRequestToNotFoundMethod;\n    [Test]\n    procedure TestRequestWithParams_I_I_ret_I;\n    [Test]\n    procedure TestRequestWithNamedParams_I_I_ret_I;\n    [Test]\n    procedure TestRequestWithParams_I_I_I_ret_O;\n    [Test]\n    procedure TestRequestWithNamedParams_I_I_I_ret_O;\n    [Test]\n    procedure TestRequestWithWrongNamedParams;\n    [Test]\n    procedure TestRequest_S_I_ret_S;\n    [Test]\n    procedure TestRequest_NamedParams_S_I_ret_S;\n    [Test]\n    procedure TestRequestWithParams_I_I_ret_A;\n    [Test]\n    procedure TestRequestWithParams_DT_T_ret_DT;\n    // objects tests\n    [Test]\n    procedure TestRequestWithObjectParameters;\n    // exception tests\n    [Test]\n    procedure TestRequestWithException;\n    // hooks tests\n    [Test]\n    procedure TestHooks;\n    [Test]\n    procedure TestHooksWhenMethodRaisesError;\n    [Test]\n    procedure TestHooksWhenOnAfterCallHookRaisesError;\n    [Test]\n    procedure TestHooksNotif;\n    [Test]\n    procedure TestHooksNotifWhenOnBeforeRoutingHookRaisesError;\n    [Test]\n    procedure TestHooksNotifWhenOnBeforeCallHookRaisesError;\n    [Test]\n    procedure TestHooksNotifWhenOnAfterCallHookRaisesError;\n    [Test]\n    procedure TestHooksWhenOnBeforeCallHookRaisesError;\n    [Test]\n    procedure TestHooksWhenOnBeforeRoutingHookRaisesError;\n    //record tests\n    [Test]\n    procedure TestRequest_NoParams_SingleRecordAsResult;\n    [Test]\n    procedure TestRequest_NoParams_SingleComplexRecordAsResult;\n    [Test]\n    procedure TestRequest_Echo_SingleRecordAsResult;\n    [Test]\n    procedure TestRequest_Echo_ComplexRecord;\n    [Test]\n    procedure TestRequest_Echo_ComplexRecords;\n    [Test]\n    procedure TestRequest_NoParams_DynamicArrayOfRecordAsResult;\n    //enum tests\n    [Test]\n    procedure TestEnum;\n    [Test]\n    procedure TestInvalidEnum;\n    //set tests\n    [Test]\n    procedure TestSet;\n    [Test]\n    procedure TestInvalidSet;\n\n    //test issues\n    [Test]\n    procedure TestGetTCustomer_ISSUE648;\n\n  end;\n\n  [TestFixture]\n  [Category('jsonrpc')]\n  TJSONRPCServerWithGETTest = class(TJSONRPCServerTest)\n  protected\n    procedure InitExecutors; override;\n  end;\n\nimplementation\n\nuses\n  System.TypInfo,\n  System.Math,\n  System.JSON,\n  MVCFramework.Serializer.Defaults,\n  JsonDataObjects,\n  MVCFramework.Serializer.JsonDataObjects,\n  System.SyncObjs,\n  System.Generics.Collections,\n  System.SysUtils,\n  BusinessObjectsU,\n  MVCFramework.Serializer.Commons,\n  Soap.EncdDecd,\n  System.Classes,\n  MVCFramework.SystemJSONUtils,\n  IdCookie,\n  MVCFramework.JSONRPC,\n  MVCFramework.Serializer.Intf\n{$IFDEF MSWINDOWS}\n    ,\n  MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes,\n  Vcl.Graphics\n{$ENDIF}\n    , TestConstsU, MVCFramework.Tests.Serializer.Entities,\n  MVCFramework.Logger, System.IOUtils, MVCFramework.Utils,\n  System.Net.HttpClient, System.Net.URLClient;\n\nfunction GetServer: string;\nbegin\n  Result := 'http://' + TEST_SERVER_ADDRESS + ':8888';\nend;\n\n{ TServerTest }\n\nprocedure TBaseServerTest.DoLogout;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/logout');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Logout Failed: ' + res.Content);\nend;\n\nprocedure TBaseServerTest.Setup;\nbegin\n  inherited;\n  RESTClient := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  RESTClient\n    .ReadTimeout(60 * 1000 * 30)\n    .ProxyServer('localhost')\n    .ProxyPort(8080);\nend;\n\nprocedure TBaseServerTest.TearDown;\nbegin\n  inherited;\n  RESTClient := nil;\nend;\n\nprocedure TServerTest.TestActionFiltersOnBeforeAction;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/actionfilters/beforeaction/alwayscalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n\n  res := RESTClient.Get('/actionfilters/beforeaction/nevercalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, res.StatusCode);\nend;\n\nprocedure TServerTest.TestAsynchRequestDELETE;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  OK: boolean;\nbegin\n  OK := false;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        OK := true;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n        OK := false;\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Delete('/req/with/params/($par1)/($par2)/($par3)');\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.areEqual(true, OK);\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestGET;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Get('/req/with/params/($par1)/($par2)/($par3)');\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('1', j.Get('par1').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestPOST;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Post('/echo/($par1)/($par2)/($par3)',\n      TSystemJSON.JSONValueToString(System.JSON.TJSONObject.Create(TJSONPair.Create('from client',\n      'hello world'))));\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('from server', j.Get('echo').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestAsynchRequestPUT;\nvar\n  evt: TEvent;\n  r: TWaitResult;\n  j: System.JSON.TJSONObject;\nbegin\n  j := nil;\n  evt := TEvent.Create;\n  try\n    RESTClient.Async(\n      procedure(Response: IMVCRESTResponse)\n      begin\n        try\n          j := TSystemJSON.StringAsJSONObject(Response.Content);\n        except\n          // test should not block...never!\n        end;\n        evt.SetEvent;\n      end,\n      procedure(E: Exception)\n      begin\n      end).AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n      .Put('/echo/($par1)/($par2)/($par3)',\n      TSystemJSON.JSONValueToString(System.JSON.TJSONObject.Create(System.JSON.TJSONPair.Create\n      ('from client', 'hello world'))));\n\n    // wait for thred finish\n    repeat\n      r := evt.WaitFor(2000);\n    until r = TWaitResult.wrSignaled;\n\n    Assert.isTrue(Assigned(j));\n    Assert.areEqual('from server', j.Get('echo').JsonValue.Value);\n    j.Free;\n  finally\n    evt.Free;\n  end;\nend;\n\nprocedure TServerTest.TestBasicAuth01;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  Assert.areEqual('Basic dXNlcjE6dXNlcjE=', RESTClient.Authorization);\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth02;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth03;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  lRes := RESTClient.Get('/private/role2');\n  Assert.areEqual<Integer>(HTTP_STATUS.Forbidden, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth04;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n  lRes := RESTClient.Get('/private/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/people');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestBasicAuth05;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  RESTClient.SetBasicAuthorization('user1', 'user1');\n\n  // first\n  lRes := RESTClient.Get('/private/role1session?value=danieleteti');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/private/role1session');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  Assert.areEqual('danieleteti', lRes.Content);\n\n  // second\n  lRes := RESTClient.Get('/private/role1session?value=johndoe');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  lRes := RESTClient.Get('/private/role1session');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  Assert.areEqual('johndoe', lRes.Content);\nend;\n\nprocedure TServerTest.TestControllerWithExceptionInCreate(const URLSegment: string);\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON).Get(URLSegment);\n  Assert.areEqual(HTTP_STATUS.InternalServerError, res.StatusCode);\n  // Assert.Contains(res.ContentType, 'text/plain', true, 'Is not a text/plain in case of error');\n  Assert.Contains(res.ContentType, 'application/json', true,\n    'Is not a application/json in case of error');\n  Assert.Contains(res.Content, 'Cannot create controller', true,\n    'Exception message in body is not correct');\n  // Assert.Contains(res.BodyAsString, 'Cannot create controller', true, 'Exception message in body is not correct');\nend;\n\nprocedure TServerTest.TestCookies;\nvar\n  res: IMVCRESTResponse;\n  I: Integer;\nbegin\n  res := RESTClient.Get('/lotofcookies');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual<Integer>(4, res.Cookies.Count, 'Wrong number of cookies');\n  for I := 0 to 3 do\n  begin\n    Assert.areEqual('usersettings' + IntToStr(I + 1), res.Cookies[I].Name);\n    Assert.areEqual('usersettings' + IntToStr(I + 1) + '-value', res.Cookies[I].Value);\n    Assert.areEqual('/usersettings' + IntToStr(I + 1) + '/', res.Cookies[I].Path);\n  end;\n\nend;\n\nprocedure TServerTest.TestCustomAuthRequestWithoutLogin;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/privatecustom/role1');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\n  Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGIN-URL'));\n  Assert.areEqual('POST', lRes.HeaderValue('X-LOGIN-METHOD'));\n\n  lRes := RESTClient.Get('/privatecustom/role2');\n  Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode);\n  Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGIN-URL'));\n  Assert.areEqual('POST', lRes.HeaderValue('X-LOGIN-METHOD'));\nend;\n\nprocedure TServerTest.TestCustomAuthRequestsWithValidLogin;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\n  lCookieValue: string;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    lJSON.AddPair('username', 'user1');\n    lJSON.AddPair('password', 'user1');\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n    Assert.areEqual('application/json', lRes.ContentType);\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n    Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGOUT-URL'));\n    Assert.areEqual('DELETE', lRes.HeaderValue('X-LOGOUT-METHOD'));\n    Assert.areEqual('{\"status\":\"OK\"}', lRes.Content);\n    lCookieValue := lRes.CookieByName(TMVCConstants.SESSION_TOKEN_NAME).Value;\n    Assert.AreNotEqual('', lCookieValue, 'Session cookie not returned after login');\n    Assert.IsFalse(lCookieValue.Contains('invalid'), 'Returned an invalid session token');\n\n    lRes := RESTClient.Get('/privatecustom/role2');\n    Assert.areEqual<Integer>(HTTP_STATUS.Forbidden, lRes.StatusCode,\n      'Authorization not respected for not allowed action');\n\n    lRes := RESTClient.Get('/privatecustom/role1');\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode,\n      'Authorization not respected for allowed action');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomAuthRequestsWithValidLogin_HTML;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\n  lCookieValue: string;\n  lContentType: string;\n  lContentCharset: string;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    lJSON.AddPair('username', 'user1');\n    lJSON.AddPair('password', 'user1');\n    lRes := RESTClient.Accept('text/html').Post('/system/users/logged',\n      TSystemJSON.JSONValueToString(lJSON, false));\n    SplitContentMediaTypeAndCharset(lRes.ContentType, lContentType, lContentCharset);\n    Assert.areEqual(lContentType, TMVCMediaType.APPLICATION_JSON);\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n    Assert.areEqual('/system/users/logged', lRes.HeaderValue('X-LOGOUT-URL'));\n    Assert.areEqual('DELETE', lRes.HeaderValue('X-LOGOUT-METHOD'));\n    Assert.areEqual('{\"status\":\"OK\"}', lRes.Content);\n    lCookieValue := lRes.CookieByName(TMVCConstants.SESSION_TOKEN_NAME).Value;\n    Assert.AreNotEqual('', lCookieValue, 'Session cookie not returned after login');\n    Assert.IsFalse(lCookieValue.Contains('invalid'), 'Returned an invalid session token');\n\n    lRes := RESTClient.Get('/privatecustom/role2');\n    Assert.areEqual<Integer>(HTTP_STATUS.Forbidden, lRes.StatusCode,\n      'Authorization not respected for not allowed action');\n\n    lRes := RESTClient.Get('/privatecustom/role1');\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode,\n      'Authorization not respected for allowed action');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomAuthWrongRequestBodies;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    // no request body\n    lRes := RESTClient.AddBody('', TMVCMediaType.APPLICATION_JSON).Post('/system/users/logged');\n    Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, lRes.StatusCode,\n      'Empty request body doesn''t return HTTP 400 Bad Request');\n\n    // wrong request body 1\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n    Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode,\n      'Invalid json doesn''t return HTTP 401 Unauthorized');\n\n    // wrong request body 2\n    lJSON.AddPair('username', '');\n    lJSON.AddPair('password', '');\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n    Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode,\n      'Empty username and password doesn''t return HTTP 401 Unauthorized');\n\n    // wrong username and password 3\n    lJSON.RemovePair('username').Free;\n    lJSON.RemovePair('password').Free;\n    lJSON.AddPair('username', 'notvaliduser');\n    lJSON.AddPair('password', 'notvalidpassword');\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n    Assert.areEqual<Integer>(HTTP_STATUS.Unauthorized, lRes.StatusCode,\n      'Wrong username and password doesn''t return HTTP 401 Unauthorized');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomerEcho;\nvar\n  r: IMVCRESTResponse;\n  lCustomer: TCustomer;\n  lSer: IMVCSerializer;\nbegin\n  lCustomer := TCustomer.Create;\n  try\n    lCustomer.Name := 'bit Time Professionals';\n    lCustomer.ContactFirst := 'Daniele'; // transient\n    lCustomer.ContactLast := 'Teti'; // transient\n    lCustomer.AddressLine1 := 'Via Roma 10';\n    lCustomer.AddressLine2 := '00100, ROMA';\n    lCustomer.Logo.SetSize(100, 100);\n    lCustomer.Logo.Canvas.FillRect(Rect(0, 0, 100, 100));\n    lCustomer.Logo.Canvas.Font.Color := clRed;\n    lCustomer.Logo.Canvas.TextOut(10, 50, 'From Client');\n    lCustomer.Logo.SaveToFile('customer_logo_before_to_send.bmp');\n    lSer := GetDefaultSerializer;\n    RegisterOptionalCustomTypesSerializers(lSer);\n    r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON)\n      .Post('/customerecho', lSer.SerializeObject(lCustomer));\n  finally\n    lCustomer.Free;\n  end;\n\n  lCustomer := TCustomer.Create;\n  try\n    lSer := GetDefaultSerializer;\n    RegisterOptionalCustomTypesSerializers(lSer);\n    lSer.DeserializeObject(r.Content, lCustomer);\n    Assert.areEqual('bit Time Professionals changed', lCustomer.Name);\n    Assert.areEqual('', lCustomer.ContactFirst);\n    Assert.areEqual('', lCustomer.ContactLast);\n    lCustomer.Logo.SaveToFile('customer_logo_after_received.bmp');\n    Assert.areEqual('9a4e150a92ecb68ad83e8ead27026dcc',\n      THashMD5.GetHashStringFromFile('customer_logo_after_received.bmp'));\n  finally\n    lCustomer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomerEchoBodyFor;\nvar\n  r: IMVCRESTResponse;\n  lCustomer: TCustomer;\n  lSer: IMVCSerializer;\nbegin\n  lCustomer := TCustomer.Create;\n  try\n    lCustomer.Name := 'bit Time Professionals';\n    lCustomer.ContactFirst := 'Daniele'; // transient\n    lCustomer.ContactLast := 'Teti'; // transient\n    lCustomer.AddressLine1 := 'Via Roma 10';\n    lCustomer.AddressLine2 := '00100, ROMA';\n    lCustomer.Logo.SetSize(100, 100);\n    lCustomer.Logo.Canvas.FillRect(Rect(0, 0, 100, 100));\n    lCustomer.Logo.Canvas.Font.Color := clRed;\n    lCustomer.Logo.Canvas.TextOut(10, 50, 'From Client');\n    lCustomer.Logo.SaveToFile('customer_logo_before_to_send.bmp');\n    lSer := GetDefaultSerializer;\n    RegisterOptionalCustomTypesSerializers(lSer);\n    r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON)\n      .Post('/customerechobodyfor', lSer.SerializeObject(lCustomer));\n  finally\n    lCustomer.Free;\n  end;\n\n  lCustomer := TCustomer.Create;\n  try\n    lSer := GetDefaultSerializer;\n    RegisterOptionalCustomTypesSerializers(lSer);\n    lSer.DeserializeObject(r.Content, lCustomer);\n    Assert.areEqual('bit Time Professionals changed', lCustomer.Name);\n    Assert.areEqual('', lCustomer.ContactFirst);\n    Assert.areEqual('', lCustomer.ContactLast);\n    lCustomer.Logo.SaveToFile('customer_logo_after_received.bmp');\n    Assert.areEqual('9a4e150a92ecb68ad83e8ead27026dcc',\n      THashMD5.GetHashStringFromFile('customer_logo_after_received.bmp'));\n  finally\n    lCustomer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomerEchoWithRootNode;\nvar\n  r: IMVCRESTResponse;\n  lCustomer1, lCustomer2: TCustomer;\n  lCustomers: TObjectList<TCustomer>;\n  lJSON: TJSONObject;\n  lSer: IMVCSerializer;\nbegin\n  lSer := GetDefaultSerializer;\n  RegisterOptionalCustomTypesSerializers(lSer);\n  lCustomers := TCustomer.GetList(2);\n  try\n    lJSON := TJsonObject.Create;\n    try\n    (lSer as TMVCJsonDataObjectsSerializer)\n      .ObjectToJsonObject(lCustomers[0], lJSON.O['customer1'], TMVCSerializationType.stDefault, []);\n    (lSer as TMVCJsonDataObjectsSerializer)\n      .ObjectToJsonObject(lCustomers[1], lJSON.O['customer2'], TMVCSerializationType.stDefault, []);\n    r := RESTClient\n      .Accept(TMVCMediaType.APPLICATION_JSON)\n      .Post('/customerecho2', lJSON.ToJSON);\n    finally\n      lJSON.Free;\n    end;\n\n\n    lJSON := StrToJSONObject(r.Content);\n    try\n      lCustomer1 := TCustomer.Create;\n      try\n        (lSer as TMVCJsonDataObjectsSerializer)\n          .JsonObjectToObject(\n            lJSON.O['customer1'],\n            lCustomer1,\n            TMVCSerializationType.stDefault,\n            []\n            );\n\n          Assert.AreEqual(lCustomers[0].name, lCustomer1.name);\n          Assert.AreEqual('', lCustomer1.ContactFirst);\n          Assert.AreEqual('', lCustomer1.ContactLast);\n          Assert.AreEqual(lCustomers[0].AddressLine1, lCustomer1.AddressLine1);\n          Assert.AreEqual(lCustomers[0].AddressLine2, lCustomer1.AddressLine2);\n          Assert.AreEqual(lCustomers[0].Logo.Width, lCustomer1.Logo.Width);\n          Assert.AreEqual(lCustomers[0].Logo.Height, lCustomer1.Logo.Height);\n\n        lCustomer2 := TCustomer.Create;\n        try\n          (lSer as TMVCJsonDataObjectsSerializer)\n            .JsonObjectToObject(\n              lJSON.O['customer2'],\n              lCustomer2,\n              TMVCSerializationType.stDefault,\n              []\n              );\n\n          Assert.AreEqual(lCustomers[1].name, lCustomer2.name);\n          Assert.AreEqual('', lCustomer2.ContactFirst);\n          Assert.AreEqual('', lCustomer2.ContactLast);\n          Assert.AreEqual(lCustomers[1].AddressLine1, lCustomer2.AddressLine1);\n          Assert.AreEqual(lCustomers[1].AddressLine2, lCustomer2.AddressLine2);\n          Assert.AreEqual(lCustomers[1].Logo.Width, lCustomer2.Logo.Width);\n          Assert.AreEqual(lCustomers[1].Logo.Height, lCustomer2.Logo.Height);\n\n        finally\n          lCustomer2.Free;\n        end;\n      finally\n        lCustomer1.Free;\n      end;\n    finally\n      lJSON.Free;\n    end;\n  finally\n    lCustomers.Free;\n  end;\nend;\n\nprocedure TServerTest.TestCustomAuthLoginLogout;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: System.JSON.TJSONObject;\n  lLogoutUrl: string;\n  lPass: boolean;\n  lCookie: TCookie;\nbegin\n  lJSON := System.JSON.TJSONObject.Create;\n  try\n    lJSON.AddPair('username', 'user1');\n    lJSON.AddPair('password', 'user1');\n    lRes := RESTClient.Post('/system/users/logged', TSystemJSON.JSONValueToString(lJSON, false));\n\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n    lLogoutUrl := lRes.HeaderValue('X-LOGOUT-URL');\n\n    lRes := RESTClient.Delete(lLogoutUrl);\n    lPass := false;\n    for lCookie in lRes.Cookies do\n    begin\n      if lCookie.Value.IsEmpty then\n      begin\n        lPass := true;\n        Break;\n      end;\n    end;\n    Assert.isTrue(lPass, 'No session cookie cleanup in the response');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEchoWithAllVerbs;\nvar\n  r: IMVCRESTResponse;\n  lPerson: TPerson;\n  lSer: IMVCSerializer;\n  lNewPerson: TPerson;\n  I: TMVCHTTPMethodType;\nbegin\n  lNewPerson := TPerson.Create;\n  try\n    lPerson := TPerson.GetNew('Daniele','Teti', EncodeDate(1979,11,4), True);\n    try\n      lSer := GetDefaultSerializer;\n      for I := httpGET to httpTRACE do\n      begin\n        r := RESTClient\n          .Accept(TMVCMediaType.APPLICATION_JSON)\n          .AddBody(lPerson, False)\n          .Execute(httpGET, '/echowithallverbs');\n        Assert.AreEqual(HTTP_STATUS.OK, r.StatusCode);\n          r.BodyFor(lNewPerson);\n          Assert.IsTrue(lPerson.Equals(lNewPerson),\n            GetEnumName(TypeInfo(TMVCHTTPMethodType),\n              Ord(I)) + ' doesn''t return the same object data');\n      end;\n    finally\n      lPerson.Free;\n    end;\n  finally\n    lNewPerson.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEMVCException1;\nvar\n  res: IMVCRESTResponse;\n  lJSON: TJSONObject;\nbegin\n  res := RESTClient.Get('/exception/emvcexception1');\n  Assert.areEqual<Integer>(HTTP_STATUS.InternalServerError, res.StatusCode);\n  Assert.areEqual('Internal Server Error', res.StatusText);\n  lJSON := StrToJSONObject(res.Content);\n  try\n    Assert.areEqual<string>('message', lJSON.S['message'], lJSON.ToJSON());\n    Assert.areEqual<string>('EMVCException', lJSON.S['classname'], lJSON.ToJSON());\n    Assert.areEqual(0, lJSON.A['items'].Count, lJSON.ToJSON());\n    Assert.isTrue(lJSON.IsNull('data'), lJSON.ToJSON());\n  finally\n    lJSON.Free;\n  end;\n\nend;\n\nprocedure TServerTest.TestEMVCException2;\nvar\n  res: IMVCRESTResponse;\n  lJSON: TJSONObject;\nbegin\n  res := RESTClient.Get('/exception/emvcexception2');\n  Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, res.StatusCode);\n  Assert.areEqual('Bad Request', res.StatusText);\n  lJSON := StrToJSONObject(res.Content);\n  try\n    Assert.areEqual<string>('message', lJSON.S['message'], lJSON.ToJSON());\n    Assert.areEqual<string>('EMVCException', lJSON.S['classname'], lJSON.ToJSON());\n    Assert.areEqual(0, lJSON.A['items'].Count, lJSON.ToJSON());\n    Assert.isTrue(lJSON.IsNull('data'), lJSON.ToJSON());\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEMVCException3;\nvar\n  res: IMVCRESTResponse;\n  lJSON: TJSONObject;\nbegin\n  res := RESTClient.Get('/exception/emvcexception3');\n  Assert.areEqual<Integer>(HTTP_STATUS.Created, res.StatusCode);\n  Assert.areEqual('Created', res.StatusText);\n  lJSON := StrToJSONObject(res.Content);\n  try\n    Assert.areEqual('message', lJSON.S['message'], lJSON.ToJSON());\n    Assert.areEqual('EMVCException', lJSON.S['classname'], lJSON.ToJSON());\n    Assert.areEqual(999, lJSON.I['apperrorcode'], lJSON.ToJSON());\n    Assert.areEqual(0, lJSON.A['items'].Count, lJSON.ToJSON());\n    Assert.isTrue(lJSON.IsNull('data'), lJSON.ToJSON());\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEMVCException4;\nvar\n  res: IMVCRESTResponse;\n  lJSON: TJSONObject;\nbegin\n  res := RESTClient.Get('/exception/emvcexception4');\n  Assert.areEqual<Integer>(HTTP_STATUS.Created, res.StatusCode);\n  Assert.areEqual('Created', res.StatusText);\n  lJSON := StrToJSONObject(res.Content);\n  try\n    Assert.areEqual('message', lJSON.S['message'], lJSON.ToJSON());\n    Assert.areEqual('detailedmessage', lJSON.S['detailedmessage'], lJSON.ToJSON());\n    Assert.areEqual('EMVCException', lJSON.S['classname'], lJSON.ToJSON());\n    Assert.areEqual(999, lJSON.I['apperrorcode'], lJSON.ToJSON());\n    Assert.areEqual(2, lJSON.A['items'].Count, lJSON.ToJSON());\n    Assert.areEqual('erritem1', lJSON.A['items'].O[0].S['message'], lJSON.ToJSON());\n    Assert.areEqual('erritem2', lJSON.A['items'].O[1].S['message'], lJSON.ToJSON());\n    Assert.isTrue(lJSON.IsNull('data'), lJSON.ToJSON());\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEncodingRenderJSONValue;\nvar\n  res: IMVCRESTResponse;\n  S: string;\n  lJSONObj: System.JSON.TJSONObject;\nbegin\n  res := RESTClient.Get('/encoding');\n\n  lJSONObj := TSystemJSON.StringAsJSONObject(res.Content);\n  S := lJSONObj.Get('name1').JsonValue.Value;\n  Assert.areEqual('j\ufffdrn', S);\n  lJSONObj.Free;\n\n  lJSONObj := TSystemJSON.StringAsJSONObject(res.Content);\n  S := lJSONObj.Get('name3').JsonValue.Value;\n  Assert.areEqual('\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd', S);\n  lJSONObj.Free;\n\n  lJSONObj := TSystemJSON.StringAsJSONObject(res.Content);\n  S := lJSONObj.Get('name2').JsonValue.Value;\n  Assert.areEqual('\ufffdto je Unicode?', S,\n    'If this test fail, check http://qc.embarcadero.com/wc/qcmain.aspx?d=119779');\n  lJSONObj.Free;\n  { WARNING!!! }\n  {\n    If this test fail, check\n    http://qc.embarcadero.com/wc/qcmain.aspx?d=119779\n  }\nend;\n\nprocedure TServerTest.TestEntityWithArrays;\nvar\n  lRes: IMVCRESTResponse;\n  lObj1, lObj2: TEntityWithArray;\n  lBody: String;\nbegin\n  lObj1 := TEntityWithArray.Create;\n  try\n    lObj1.Names := ['one', 'two', 'three'];\n    lObj1.Values := [1, 2, 3];\n    lObj1.Values8 := [4, 5, 6];\n    lObj1.Values64 := [7, 8, 9];\n    lObj1.Booleans := [true, false];\n    lBody := GetDefaultSerializer.SerializeObject(lObj1);\n\n    lRes := RESTClient.Post('/entitywitharrays', lBody);\n    lObj2 := TEntityWithArray.Create;\n    try\n      GetDefaultSerializer.DeserializeObject(lRes.Content, lObj2);\n\n      Assert.AreEqual<Integer>(4, Length(lObj2.Names));\n      Assert.areEqual(lObj1.Names[0], lObj2.Names[0]);\n      Assert.areEqual(lObj1.Names[1], lObj2.Names[1]);\n      Assert.areEqual(lObj1.Names[2], lObj2.Names[2]);\n      Assert.areEqual('added', lObj2.Names[3]);\n\n      Assert.AreEqual<Integer>(4, Length(lObj2.Values));\n      Assert.areEqual(lObj1.Values[0], lObj2.Values[0]);\n      Assert.areEqual(lObj1.Values[1], lObj2.Values[1]);\n      Assert.areEqual(lObj1.Values[2], lObj2.Values[2]);\n      Assert.areEqual(99, lObj2.Values[3]);\n\n      Assert.AreEqual<Integer>(3, Length(lObj2.Booleans));\n      Assert.areEqual(lObj1.Booleans[0], lObj2.Booleans[0]);\n      Assert.areEqual(lObj1.Booleans[1], lObj2.Booleans[1]);\n      Assert.areEqual(true, lObj2.Booleans[2]);\n    finally\n      lObj2.Free;\n    end;\n  finally\n    lObj1.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEntityWithEmptyArrays;\nvar\n  lRes: IMVCRESTResponse;\n  lObj1, lObj2: TEntityWithArray;\n  lBody: String;\nbegin\n  lObj1 := TEntityWithArray.Create;\n  try\n    lBody := GetDefaultSerializer.SerializeObject(lObj1);\n\n    lRes := RESTClient.Post('/entitywitharrays', lBody);\n    lObj2 := TEntityWithArray.Create;\n    try\n      GetDefaultSerializer.DeserializeObject(lRes.Content, lObj2);\n\n      Assert.AreEqual<Integer>(1, Length(lObj2.Names));\n      Assert.areEqual('added', lObj2.Names[0]);\n\n      Assert.AreEqual<Integer>(1, Length(lObj2.Values));\n      Assert.areEqual(99, lObj2.Values[0]);\n\n      Assert.AreEqual<Integer>(1, Length(lObj2.Booleans));\n      Assert.areEqual(true, lObj2.Booleans[0]);\n    finally\n      lObj2.Free;\n    end;\n  finally\n    lObj1.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEntityWithGUIDs;\nvar\n  lRes: IMVCRESTResponse;\n  lJOBJ: TJsonObject;\nbegin\n  lRes := RESTClient.Get('/issue552');\n  lJOBJ := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('{75ADE43E-F8C1-4F66-B714-D04726FD2C21}', lJOBJ.S['guid']);\n    Assert.AreEqual('{7B17F2DD-6ED5-40A4-A334-8ED877A6803E}', lJOBJ.S['nullableguid']);\n    Assert.IsTrue(lJOBJ.IsNull('nullableguid2'));\n  finally\n    lJOBJ.Free;\n  end;\nend;\n\nprocedure TServerTest.TestEntityWithGUIDsEcho;\nvar\n  lRes: IMVCRESTResponse;\n  lJOBJ: TJsonObject;\n  lObj: TEntityWithGUIDs;\nbegin\n  lObj := TEntityWithGUIDs.Create(False);\n  lObj.GUID := StringToGUID('{75ADE43E-F8C1-4F66-B714-D04726FD2C21}');\n  lObj.NullableGUID := StringToGUID('{7B17F2DD-6ED5-40A4-A334-8ED877A6803E}');\n  lObj.NullableGUID2.Clear;\n  lRes := RESTClient.Post('/guidserializationecho', lObj, True);\n  Assert.IsTrue(lRes.Success);\n  lJOBJ := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('{75ADE43E-F8C1-4F66-B714-D04726FD2C21}', lJOBJ.S['guid']);\n    Assert.AreEqual('{7B17F2DD-6ED5-40A4-A334-8ED877A6803E}', lJOBJ.S['nullableguid']);\n    Assert.IsTrue(lJOBJ.IsNull('nullableguid2'));\n  finally\n    lJOBJ.Free;\n  end;\n\n  lObj := TEntityWithGUIDs.Create(False);\n  lObj.GUID := StringToGUID('{75ADE43E-F8C1-4F66-B714-D04726FD2C21}');\n  lObj.NullableGUID := StringToGUID('{7B17F2DD-6ED5-40A4-A334-8ED877A6803E}');\n  lObj.NullableGUID2 := StringToGUID('{D6DC2A99-CFFE-43C8-A4DC-0492786AB303}');\n  lRes := RESTClient.Post('/guidserializationecho', lObj, True);\n  Assert.IsTrue(lRes.Success);\n  lJOBJ := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('{75ADE43E-F8C1-4F66-B714-D04726FD2C21}', lJOBJ.S['guid']);\n    Assert.AreEqual('{7B17F2DD-6ED5-40A4-A334-8ED877A6803E}', lJOBJ.S['nullableguid']);\n    Assert.AreEqual('{D6DC2A99-CFFE-43C8-A4DC-0492786AB303}', lJOBJ.S['nullableguid2']);\n  finally\n    lJOBJ.Free;\n  end;\nend;\n\nprocedure TServerTest.TestRenderActionInCollections;\nvar\n  lRes: IMVCRESTResponse;\n  lJArr: TJDOJsonArray;\n  I: Integer;\nbegin\n  lRes := RESTClient.Get('/people/renderaction');\n  lJArr := TJsonBaseObject.Parse(lRes.Content) as TJDOJsonArray;\n  try\n    for I := 0 to lJArr.Count - 1 do\n    begin\n      Assert.isTrue(lJArr[I].A[TMVCConstants.HATEOAS_PROP_NAME].Count = 2,\n        '_links doesn''t exists');\n      Assert.areEqual(lJArr[I].A[TMVCConstants.HATEOAS_PROP_NAME].O[0].S[HATEOAS.REL], 'test0');\n      Assert.areEqual(lJArr[I].A[TMVCConstants.HATEOAS_PROP_NAME].O[1].S[HATEOAS.REL], 'test1');\n    end;\n  finally\n    lJArr.Free;\n  end;\nend;\n\nprocedure TServerTest.TestRenderStreamAndFreeWithOwnerFalse;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/renderstreamandfreewithownerfalse');\n  Assert.areEqual<Integer>(200, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestRenderStreamAndFreeWithOwnerTrue;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/renderstreamandfreewithownertrue');\n  Assert.areEqual<Integer>(200, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestRenderWrappedList;\nvar\n  lRes: IMVCRESTResponse;\n  lJSONArr: System.JSON.TJSONArray;\n  I: Integer;\n  lJSONObj: System.JSON.TJSONObject;\nbegin\n  lRes := RESTClient.Get('/wrappedpeople');\n\n  lJSONArr := TSystemJSON.StringAsJSONArray(lRes.Content);\n  try\n    for I := 0 to lJSONArr.Count - 1 do\n    begin\n      lJSONObj := lJSONArr.Items[I] as System.JSON.TJSONObject;\n      Assert.IsFalse(lJSONObj.GetValue<string>('firstname').IsEmpty);\n    end;\n  finally\n    lJSONArr.Free;\n  end;\n\nend;\n\nprocedure TServerTest.TestRenderWrappedListWithCompression;\nvar\n  lRes: IMVCRESTResponse;\n  lJSONArr: TJDOJsonArray;\n  I: Integer;\n  lCompType: string;\n  j: Integer;\nconst\n  CompressionTypes: array [1 .. 9] of string = ('deflate', 'gzip', 'deflate,gzip', 'gzip,deflate',\n    'gzip,invalid', 'deflate,notvalid', 'notvalid,gzip', 'invalid', '');\n  CompressionTypeResult: array [1 .. 9] of string = ('deflate', 'gzip', 'deflate', 'gzip', 'gzip',\n    'deflate', 'gzip', '', '');\nbegin\n  j := 1;\n  for lCompType in CompressionTypes do\n  begin\n    RESTClient.AcceptEncoding(lCompType);\n    lRes := RESTClient.AddQueryStringParam('count', 100).Get('/wrappedpeople');\n    Assert.areEqual(CompressionTypeResult[j], lRes.HeaderValue('Content-Encoding'));\n    lJSONArr := TMVCJsonDataObjectsSerializer.ParseArray(lRes.Content);\n    try\n      for I := 0 to lJSONArr.Count - 1 do\n      begin\n        Assert.IsFalse(lJSONArr.O[I].S['firstname'].IsEmpty);\n        Assert.IsFalse(lJSONArr.O[I].S['lastname'].IsEmpty);\n        Assert.IsFalse(lJSONArr.O[I].S['dob'].IsEmpty);\n        Assert.areEqual<TJsonDataType>(jdtBool, lJSONArr.O[I].Types['married']);\n      end;\n    finally\n      lJSONArr.Free;\n    end;\n    Inc(j);\n  end;\nend;\n\nprocedure TServerTest.TestExceptionInMVCAfterCreate;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/exception/aftercreate/nevercalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.InternalServerError, res.StatusCode);\nend;\n\nprocedure TServerTest.TestExceptionInMVCBeforeDestroy;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/exception/beforedestroy/nevercalled');\n  Assert.areEqual<Integer>(HTTP_STATUS.InternalServerError, res.StatusCode);\nend;\n\nprocedure TServerTest.TestFileWithFolderName;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('doesn''t exist');\n  Assert.areEqual(404, lRes.StatusCode, '<empty>');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/index.html');\n  Assert.areEqual(200, lRes.StatusCode, '/static/index.html');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static.html');\n  Assert.areEqual(404, lRes.StatusCode, '/static.html');\n\n  lRes := RESTClient.HandleRedirects(false).Accept(TMVCMediaType.TEXT_HTML).Get('/static');\n  Assert.areEqual(301, lRes.StatusCode, '/static');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/');\n  Assert.areEqual(200, lRes.StatusCode, '/static/');\n\n  lRes := RESTClient.HandleRedirects(false).Accept(TMVCMediaType.TEXT_HTML).Get('/static/folder1');\n  Assert.areEqual(301, lRes.StatusCode, '/static/folder1');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/folder1/');\n  Assert.areEqual(200, lRes.StatusCode, '/static/folder1/');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/folder1.html');\n  Assert.areEqual(200, lRes.StatusCode, '/static/folder1.html');\n  Assert.areEqual('This is a TEXT file', lRes.Content, '/static/folder1.html');\nend;\n\nprocedure TServerTest.TestFuncActionGetComplexObject;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  lRes := c1.Get('/api/v1/actionresult/complex');\n  Assert.areEqual(200, lRes.StatusCode);\n  var lJSON := lRes.ToJSONObject;\n  try\n    Assert.AreEqual(3, lJSON.Count);\n    Assert.IsTrue(lJSON.Types['value'] = jdtInt);\n    Assert.IsTrue(lJSON.Types['person'] = jdtObject);\n    Assert.IsTrue(lJSON.Types['people'] = jdtArray);\n    Assert.AreEqual(6, lJSON.O['person'].Count);\n    Assert.AreEqual(3, lJSON.A['people'].Count);\n    Assert.AreEqual(6, lJSON.A['people'][0].ObjectValue.Count);\n    Assert.AreEqual(6, lJSON.A['people'][1].ObjectValue.Count);\n    Assert.AreEqual(6, lJSON.A['people'][2].ObjectValue.Count);\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestFuncActionGetDatasetMultiple;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  lRes := c1.Get('/api/v1/actionresult/dataset/multiple');\n  Assert.areEqual(200, lRes.StatusCode);\n  var lJSON := lRes.ToJSONObject;\n  try\n    Assert.AreEqual(2, lJSON.Count);\n    Assert.IsTrue(lJSON.Contains('ds1'));\n    Assert.IsTrue(lJSON.Contains('ds2'));\n    Assert.AreEqual(15, lJSON.A['ds1'].Count);\n    Assert.AreEqual(15, lJSON.A['ds2'].Count);\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestFuncActionGetDatasetSingle;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  lRes := c1.Get('/api/v1/actionresult/dataset/single');\n  Assert.areEqual(200, lRes.StatusCode);\n  var lJSON := lRes.ToJSONArray;\n  try\n    Assert.AreEqual(15, lJSON.Count);\n    for var I := 0 to lJSON.Count - 1 do\n    begin\n      Assert.IsTrue(lJSON[I].Typ = jdtObject);\n      Assert.AreEqual(12, lJSON[I].ObjectValue.Count);\n    end;\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestFuncActionGetMultipleRecords;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  lRes := c1.Get('/api/v1/actionresult/records/multiple');\n  Assert.areEqual(200, lRes.StatusCode);\n  var lJSON := lRes.ToJSONArray;\n  try\n    Assert.AreEqual(3, lJSON.Count);\n\n    Assert.AreEqual('Daniele', lJSON[0].S['firstName']);\n    Assert.AreEqual('Teti', lJSON[0].S['lastName']);\n    Assert.AreEqual(20, lJSON[0].I['age']);\n\n    Assert.AreEqual('Daniele', lJSON[1].S['firstName']);\n    Assert.AreEqual('Teti', lJSON[1].S['lastName']);\n    Assert.AreEqual(30, lJSON[1].I['age']);\n\n    Assert.AreEqual('Daniele', lJSON[2].S['firstName']);\n    Assert.AreEqual('Teti', lJSON[2].S['lastName']);\n    Assert.AreEqual(40, lJSON[2].I['age']);\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestFuncActionGetSingleRecord;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  lRes := c1.Get('/api/v1/actionresult/records/single');\n  Assert.areEqual(200, lRes.StatusCode);\n  var lJSON := lRes.ToJSONObject;\n  try\n    Assert.AreEqual(3, lJSON.Count);\n    Assert.AreEqual('Daniele', lJSON.S['firstName']);\n    Assert.AreEqual('Teti', lJSON.S['lastName']);\n    Assert.AreEqual(99, lJSON.I['age']);\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestGetImagePng;\nvar\n  c1: IMVCRESTClient;\n  lRes: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  // c1.Accept(TMVCMediaType.IMAGE_PNG);\n  lRes := c1.Get('/image/png');\n  Assert.areEqual(200, lRes.StatusCode);\n  Assert.areEqual('image/png', lRes.ContentType);\n  Assert.areEqual(249, Integer(lRes.ContentLength));\nend;\n\nprocedure TServerTest.TestGetInject10;\nvar\n  lResp: IMVCRESTResponse;\n  lJSON: TJSONObject;\n  lDateTime: TDateTime;\nbegin\n  lDateTime := EncodeDateTime(2011, 11, 17, 12, 11, 10, 9);\n  RESTClient.AddQueryStringParam('parstring', 'this is a string');\n  RESTClient.AddQueryStringParam('parinteger', 1234);\n  RESTClient.AddQueryStringParam('parint64', Int64(1234567890));\n  RESTClient.AddQueryStringParam('partdate', TDate(Trunc(lDateTime)));\n  RESTClient.AddQueryStringParam('parttime', TTime(Frac(lDateTime)));\n  RESTClient.AddQueryStringParam('partdatetime', lDateTime);\n  RESTClient.AddQueryStringParam('parbool', 'true');\n  lResp := RESTClient.Get('/injectable10');\n  lJSON := StrToJSONObject(lResp.Content);\n  try\n    Assert.areEqual('this is a string', lJSON.S['ParString'], 'wrong string: ' + lJSON.ToJSON());\n    Assert.areEqual(1234, lJSON.I['ParInteger'], 'wrong ParInteger');\n    Assert.areEqual<Int64>(1234567890, lJSON.L['ParInt64'], 'wrong ParInt64');\n    Assert.areEqual('2011-11-17', lJSON.S['ParTDate'], 'wrong ParTDate');\n    Assert.areEqual('12:11:10', lJSON.S['ParTTime'], 'wrong ParTTime');\n    Assert.areEqual(lDateTime, ISOTimeStampToDateTime(lJSON.S['ParTDateTime']),\n      'wrong ParTDateTime');\n    Assert.areEqual(true, lJSON.B['ParBool'], 'wrong ParBool');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestGetInject20;\nvar\n  lResp: IMVCRESTResponse;\n  lJSON: TJSONObject;\n  lDateTime: TDateTime;\nbegin\n  lDateTime := EncodeDateTime(2011, 11, 17, 12, 11, 10, 9);\n  RESTClient.AddHeader('parstring', 'this is a string');\n  RESTClient.AddHeader('parinteger', '1234');\n  RESTClient.AddHeader('parint64', '1234567890');\n  RESTClient.AddHeader('partdate', DateToISODate(lDateTime));\n  RESTClient.AddHeader('parttime', TimeToISOTime(lDateTime));\n  RESTClient.AddHeader('partdatetime', DateTimeToISOTimeStamp(lDateTime));\n  RESTClient.AddHeader('parbool', 'true');\n  lResp := RESTClient.Get('/injectable20');\n  lJSON := StrToJSONObject(lResp.Content);\n  try\n    Assert.areEqual('this is a string', lJSON.S['ParString'], 'wrong string');\n    Assert.areEqual(1234, lJSON.I['ParInteger'], 'wrong ParInteger');\n    Assert.areEqual<Int64>(1234567890, lJSON.L['ParInt64'], 'wrong ParInt64');\n    Assert.areEqual('2011-11-17', lJSON.S['ParTDate'], 'wrong ParTDate');\n    Assert.areEqual('12:11:10', lJSON.S['ParTTime'], 'wrong ParTTime');\n    Assert.areEqual(lDateTime, ISOTimeStampToDateTime(lJSON.S['ParTDateTime']),\n      'wrong ParTDateTime');\n    Assert.areEqual(true, lJSON.B['ParBool'], 'wrong ParBool');\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestGetMVCResponseSimple;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Get('/api/v1/actionresult/mvcresponse/message');\n  Assert.areEqual(HTTP_STATUS.OK, r.StatusCode);\n  Assert.areEqual('{\"message\":\"My Message\"}', r.Content, r.Content);\nend;\n\nprocedure TServerTest.TestGetMVCResponseSimpleBuilderWithHeaders;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Get('/api/v1/actionresult/mvcresponse/message/builder/headers');\n  Assert.areEqual(HTTP_STATUS.Created, r.StatusCode);\n  Assert.AreEqual('Hello World', r.HeaderValue('header1'));\n  Assert.AreEqual('foo bar', r.HeaderValue('header2'));\n  var lJ := r.ToJSONObject;\n  try\n    Assert.IsTrue(lJ.Contains('message'));\n  finally\n    lJ.Free;\n  end;\nend;\n\nprocedure TServerTest.TestGetMVCResponseWithDataAndMessage;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Get('/api/v1/actionresult/mvcresponse/data/message');\n  Assert.areEqual(HTTP_STATUS.OK, r.StatusCode);\n  var lJ := r.ToJSONObject;\n  try\n    Assert.IsTrue(lJ.Contains('data'));\n    Assert.IsTrue(lJ.Contains('message'));\n    Assert.IsTrue(lJ.Contains('person'));\n  finally\n    lJ.Free;\n  end;\nend;\n\nprocedure TServerTest.TestGetMVCResponseWithJSON;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Get('/api/v1/actionresult/mvcresponse/json');\n  Assert.areEqual(HTTP_STATUS.OK, r.StatusCode);\n  Assert.areEqual('{\"data\":{\"name\":\"Daniele\",\"surname\":\"Teti\"}}', r.Content, r.Content);\nend;\n\nprocedure TServerTest.TestGetMVCResponseWithObjectList;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Get('/api/v1/actionresult/mvcresponse/list');\n  Assert.areEqual(HTTP_STATUS.OK, r.StatusCode);\n  var lJ := r.ToJSONObject;\n  try\n    Assert.IsTrue(lJ.Contains('data'));\n    Assert.IsTrue(lJ.Types['data'] = jdtArray);\n    Assert.AreEqual(3, lJ.A['data'].Count)\n  finally\n    lJ.Free;\n  end;\nend;\n\nprocedure TServerTest.TestInvalidateSession;\nvar\n  c1: IMVCRESTClient;\n  res: IMVCRESTResponse;\nbegin\n  c1 := TMVCRESTClient.New.BaseURL(TEST_SERVER_ADDRESS, 8888);\n  c1.Accept(TMVCMediaType.APPLICATION_JSON);\n  c1.AddPathParam('param1', 'daniele teti').Post('/session/($param1)');\n  // imposto un valore in sessione\n  res := c1.Get('/session'); // rileggo il valore dalla sessione\n  Assert.areEqual('daniele teti', res.Content);\n  c1.SessionId('');\n  res := c1.Get('/session'); // rileggo il valore dalla sessione\n  Assert.areEqual('', res.Content);\nend;\n\nprocedure TServerTest.TestInvalidConverter;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/wrongconverter/1');\n  Assert.areEqual(500, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestIssue406;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON).Get('/issues/406');\n  Assert.areEqual(422, r.StatusCode);\n  Assert.areEqual('{\"message\":\"The Message\"}', r.Content, r.Content);\nend;\n\nprocedure TServerTest.TestIssue542;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: TJsonObject;\nbegin\n  lRes := RESTClient.Get('/issues/542?par1&par2');\n  lJSON := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('par1=,par2=', lJSON.S['QueryStringParams_DelimitedText']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par1'] = jdtString);\n    Assert.AreEqual('', lJSON.S['QueryStringParam_par1']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par2'] = jdtString);\n    Assert.AreEqual('', lJSON.S['QueryStringParam_par2']);\n\n    Assert.AreEqual(2, lJSON.I['QueryParams_Count']);\n    Assert.AreEqual('', lJSON.S['QueryParams_par1']);\n    Assert.AreEqual('', lJSON.S['QueryParams_par2']);\n  finally\n    lJSON.Free;\n  end;\n\n  lRes := RESTClient.Get('/issues/542?par1=123&par2');\n  lJSON := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('par1=123,par2=', lJSON.S['QueryStringParams_DelimitedText']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par1'] = jdtString);\n    Assert.AreEqual('123', lJSON.S['QueryStringParam_par1']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par2'] = jdtString);\n    Assert.AreEqual('', lJSON.S['QueryStringParam_par2']);\n\n    Assert.AreEqual(2, lJSON.I['QueryParams_Count']);\n    Assert.AreEqual('123', lJSON.S['QueryParams_par1']);\n    Assert.AreEqual('', lJSON.S['QueryParams_par2']);\n\n  finally\n    lJSON.Free;\n  end;\n\n  lRes := RESTClient.Get('/issues/542?par1=123&par2=234');\n  lJSON := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('par1=123,par2=234', lJSON.S['QueryStringParams_DelimitedText']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par1'] = jdtString);\n    Assert.AreEqual('123', lJSON.S['QueryStringParam_par1']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par2'] = jdtString);\n    Assert.AreEqual('234', lJSON.S['QueryStringParam_par2']);\n\n    Assert.AreEqual(2, lJSON.I['QueryParams_Count']);\n    Assert.AreEqual('123', lJSON.S['QueryParams_par1']);\n    Assert.AreEqual('234', lJSON.S['QueryParams_par2']);\n\n  finally\n    lJSON.Free;\n  end;\n\n  lRes := RESTClient.Get('/issues/542?par1&par2=234');\n  lJSON := StrToJSONObject(lRes.Content);\n  try\n    Assert.AreEqual('par1=,par2=234', lJSON.S['QueryStringParams_DelimitedText']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par1'] = jdtString);\n    Assert.AreEqual('', lJSON.S['QueryStringParam_par1']);\n    Assert.IsTrue(lJSON.Types['QueryStringParam_par2'] = jdtString);\n    Assert.AreEqual('234', lJSON.S['QueryStringParam_par2']);\n\n    Assert.AreEqual(2, lJSON.I['QueryParams_Count']);\n    Assert.AreEqual('', lJSON.S['QueryParams_par1']);\n    Assert.AreEqual('234', lJSON.S['QueryParams_par2']);\n\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestMiddlewareHandler;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON).Get('/handledbymiddleware');\n  Assert.areEqual('This is a middleware response', r.Content);\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, r.StatusCode);\nend;\n\nprocedure TServerTest.TestMiddlewareSpeedMiddleware;\nvar\n  r: IMVCRESTResponse;\n  P: TPerson;\nbegin\n  P := TPerson.Create;\n  try\n    P.FirstName := StringOfChar('*', 1000);\n    P.LastName := StringOfChar('*', 1000);\n    P.DOB := EncodeDate(1979, 1, 1);\n    P.Married := true;\n    r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON)\n      .Post('/objects', GetDefaultSerializer.SerializeObject(P));\n  finally\n    P.Free;\n  end;\n\n  Assert.AreNotEqual('', r.HeaderValue('request_gen_time'));\nend;\n\nprocedure TServerTest.TestMultiMVCPathOnControllerAndAction(\n  const URLSegment: string);\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get(URLSegment);\n  Assert.areEqual(HTTP_STATUS.OK, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestResponseContentTypes(\n  const ExpectedStatus: Integer;\n  const URL: String;\n  const RequestAccept: String;\n  const ResponseContentType: String);\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient\n    .ClearHeaders\n    .Accept(RequestAccept)\n    .Get(URL);\n  Assert.AreEqual<Integer>(ExpectedStatus, res.StatusCode);\n  Assert.StartsWith(ResponseContentType, res.ContentType);\nend;\n\nprocedure TServerTest.TestObjectDict;\nvar\n  lRes: IMVCRESTResponse;\n  lJSON: TJSONObject;\nbegin\n  lRes := RESTClient.Get('/objectdict');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode, lRes.Content);\n  lJSON := StrToJSONObject(lRes.Content);\n  try\n    Assert.isTrue(lJSON.Contains('ncCamelCase_Single'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncLowerCase_Single'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncPascalCase_Single'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncUpperCase_Single'), lJSON.ToJSON());\n\n    Assert.isTrue(lJSON.Contains('ncCamelCase_List'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncLowerCase_List'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncPascalCase_List'), lJSON.ToJSON());\n    Assert.isTrue(lJSON.Contains('ncUpperCase_List'), lJSON.ToJSON());\n\n    Assert.areEqual(jdtObject, lJSON.Types['ncCamelCase_Single']);\n    Assert.areEqual(jdtObject, lJSON.Types['ncLowerCase_Single']);\n    Assert.areEqual(jdtObject, lJSON.Types['ncPascalCase_Single']);\n    Assert.areEqual(jdtObject, lJSON.Types['ncUpperCase_Single']);\n\n    Assert.isTrue(lJSON.O['ncCamelCase_Single'].Contains('custNo'),\n      lJSON.O['ncCamelCase_Single'].ToJSON());\n    Assert.isTrue(lJSON.O['ncLowerCase_Single'].Contains('cust_no'),\n      lJSON.O['ncLowerCase_Single'].ToJSON());\n    Assert.isTrue(lJSON.O['ncPascalCase_Single'].Contains('CustNo'),\n      lJSON.O['ncPascalCase_Single'].ToJSON());\n    Assert.isTrue(lJSON.O['ncUpperCase_Single'].Contains('CUST_NO'),\n      lJSON.O['ncUpperCase_Single'].ToJSON());\n\n    Assert.areEqual(jdtArray, lJSON.Types['ncCamelCase_List']);\n    Assert.areEqual(jdtArray, lJSON.Types['ncLowerCase_List']);\n    Assert.areEqual(jdtArray, lJSON.Types['ncPascalCase_List']);\n    Assert.areEqual(jdtArray, lJSON.Types['ncUpperCase_List']);\n\n    Assert.isTrue(lJSON.A['ncCamelCase_List'][0].ObjectValue.Contains('custNo'),\n      lJSON.A['ncCamelCase_List'][0].ObjectValue.ToJSON());\n    Assert.isTrue(lJSON.A['ncLowerCase_List'][0].ObjectValue.Contains('cust_no'),\n      lJSON.A['ncLowerCase_List'][0].ObjectValue.ToJSON());\n    Assert.isTrue(lJSON.A['ncPascalCase_List'][0].ObjectValue.Contains('CustNo'),\n      lJSON.A['ncPascalCase_List'][0].ObjectValue.ToJSON());\n    Assert.isTrue(lJSON.A['ncUpperCase_List'][0].ObjectValue.Contains('CUST_NO'),\n      lJSON.A['ncUpperCase_List'][0].ObjectValue.ToJSON());\n\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestObjectDictIgnoredFields;\nvar\n  lRes: IMVCRESTResponse;\n  lJObj: TJsonObject;\nbegin\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','Married')\n    .Get('/ignoredfieldstest');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsFalse(lJObj.O['data'].Contains('married'), 'married exists when should not');\n    Assert.IsTrue(lJObj.O['data'].Contains('dob'), 'dob doesn''t exist when should');\n  finally\n    lJObj.Free;\n  end;\n\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','DOB')\n    .Get('/ignoredfieldstest');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsTrue(lJObj.O['data'].Contains('married'), 'married doesn''t exist when should');\n    Assert.IsFalse(lJObj.O['data'].Contains('dob'), 'dob exists when should not');\n  finally\n    lJObj.Free;\n  end;\n\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','DOB,Married')\n    .Get('/ignoredfieldstest');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsFalse(lJObj.O['data'].Contains('married'), 'married exists when should not');\n    Assert.IsFalse(lJObj.O['data'].Contains('dob'), 'dob exists when should not');\n  finally\n    lJObj.Free;\n  end;\nend;\n\nprocedure TServerTest.TestObjectDictIgnoredFieldsWithDataSets;\nvar\n  lRes: IMVCRESTResponse;\n  lJObj: TJsonObject;\nbegin\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','COUNTRY')\n    .Get('/ignoredfieldstestdataset');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsFalse(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('country'),'1');\n    Assert.IsTrue(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('phoneNo'),'2');\n  finally\n    lJObj.Free;\n  end;\n\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','PHONE_NO')\n    .Get('/ignoredfieldstestdataset');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsTrue(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('country'),'3');\n    Assert.IsFalse(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('phoneNo'),'4');\n  finally\n    lJObj.Free;\n  end;\n\n  lRes := RESTClient\n    .AddQueryStringParam('ignoredfieldscsv','COUNTRY,PHONE_NO')\n    .Get('/ignoredfieldstestdataset');\n\n  lJObj := lRes.ToJSONObject;\n  try\n    Assert.IsFalse(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('country'),'5');\n    Assert.IsFalse(lJObj.A['ncCamelCase_List'].Items[0].ObjectValue.Contains('phoneNo'),'6');\n  finally\n    lJObj.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPostAListOfObjects;\nvar\n  lRes: IMVCRESTResponse;\n  LCustomers: TObjectList<TCustomer>;\n  lSer: IMVCSerializer;\nbegin\n  LCustomers := TCustomer.GetList;\n  try\n    lSer := GetDefaultSerializer;\n    RegisterOptionalCustomTypesSerializers(lSer); // TBitmap\n    lRes := RESTClient.Post('/customers/list', lSer.SerializeCollection(LCustomers));\n    Assert.areEqual<Integer>(HTTP_STATUS.OK, lRes.StatusCode);\n  finally\n    LCustomers.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPostInject30;\nvar\n  lPerson: TPerson;\n  lResp: IMVCRESTResponse;\n  lJObj: TJSONObject;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lDeserPerson: TPerson;\nbegin\n  lPerson := TPerson.GetNew('Daniele', 'Teti', EncodeDate(1979, 11, 4), true);\n  try\n    lResp := RESTClient.AddBody(lPerson, false).Post('/injectable30');\n    lJObj := StrToJSONObject(lResp.Content);\n    try\n      lSer := TMVCJsonDataObjectsSerializer.Create;\n      try\n        lDeserPerson := TPerson.Create;\n        try\n          lSer.JsonObjectToObject(lJObj, lDeserPerson, TMVCSerializationType.stDefault, []);\n          Assert.isTrue(lPerson.Equals(lDeserPerson));\n        finally\n          lDeserPerson.Free;\n        end;\n      finally\n        lSer.Free;\n      end;\n    finally\n      lJObj.Free;\n    end;\n  finally\n    lPerson.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPostInject40;\nvar\n  lPerson: TPerson;\n  lResp: IMVCRESTResponse;\n  lJObj: TJSONObject;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lDeserPerson: TPerson;\nbegin\n  lPerson := TPerson.GetNew('Daniele', 'Teti', EncodeDate(1979, 11, 4), true);\n  try\n    lResp := RESTClient\n      .AddBody(lPerson, false)\n      .AddPathParam('married', 'false')\n      .AddPathParam('id', lPerson.ID)\n      .AddQueryStringParam('FirstName','Peter')\n      .AddHeader('LastName','Parker')\n      .AddCookie('DOB',DateToISODate(EncodeDate(1960,11,4)))\n      .Post('/injectable40/married/($married)/id/($id)');\n    lJObj := StrToJSONObject(lResp.Content);\n    try\n      lSer := TMVCJsonDataObjectsSerializer.Create;\n      try\n        lDeserPerson := TPerson.Create;\n        try\n          lSer.JsonObjectToObject(lJObj, lDeserPerson, TMVCSerializationType.stDefault, []);\n          Assert.AreEqual(lPerson.ID, lDeserPerson.ID);\n          Assert.AreEqual('Peter', lDeserPerson.FirstName);\n          Assert.AreEqual('Parker', lDeserPerson.LastName);\n          Assert.AreEqual('1960-11-04', DateToISODate(lDeserPerson.DOB));\n          Assert.IsFalse(lDeserPerson.Married);\n        finally\n          lDeserPerson.Free;\n        end;\n      finally\n        lSer.Free;\n      end;\n    finally\n      lJObj.Free;\n    end;\n  finally\n    lPerson.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPostInject50;\nvar\n  lResp: IMVCRESTResponse;\n  lJArr: TJsonArray;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lPeople, lDeserPeople: TObjectList<TPerson>;\nbegin\n  lPeople := TPerson.GetList();\n  try\n    lResp := RESTClient.AddBody(lPeople, false).Post('/injectable50');\n    lJArr := StrToJSONArray(lResp.Content);\n    try\n      lSer := TMVCJsonDataObjectsSerializer.Create;\n      try\n        lDeserPeople := TPerson.GetList(0); //empty list\n        try\n          lSer.JsonArrayToList(lJArr, WrapAsList(lDeserPeople), TPerson, TMVCSerializationType.stDefault, []);\n          Assert.AreEqual(lPeople.Count, lDeserPeople.Count);\n          for var I := 0 to lPeople.Count-1 do\n          begin\n            Assert.IsTrue(lPeople[I].Equals(lDeserPeople[I]));\n          end;\n        finally\n          lDeserPeople.Free;\n        end;\n      finally\n        lSer.Free;\n      end;\n    finally\n      lJArr.Free;\n    end;\n  finally\n    lPeople.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPOSTWithObjectJSONBody;\nvar\n  r: IMVCRESTResponse;\n  P: TPerson;\nbegin\n  P := TPerson.Create;\n  try\n    P.FirstName := 'Daniele';\n    P.LastName := '\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd';\n    P.DOB := EncodeDate(1979, 1, 1);\n    P.Married := true;\n    try\n      r := RESTClient.Accept(TMVCMediaType.APPLICATION_JSON)\n        .Post('/objects', GetDefaultSerializer.SerializeObject(P)\n      { Mapper.ObjectToJSONObject(P) }\n        );\n    except\n      Assert.Fail('If this test fail, check http://qc.embarcadero.com/wc/qcmain.aspx?d=119779');\n      { WARNING!!! }\n      {\n        If this test fail, check\n        http://qc.embarcadero.com/wc/qcmain.aspx?d=119779\n      }\n      raise;\n\n    end;\n  finally\n    P.Free;\n  end;\n\n  P := TPerson.Create;\n  try\n    GetDefaultSerializer.DeserializeObject(r.Content, P);\n    // P := Mapper.JSONObjectToObject<TPerson>(r.BodyAsJsonObject);\n    Assert.areEqual('Daniele', P.FirstName);\n    Assert.areEqual('\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd', P.LastName);\n    Assert.areEqual(true, P.Married);\n    Assert.areEqual(EncodeDate(1979, 1, 1), P.DOB);\n  finally\n    P.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPOSTWithoutContentType;\nvar\n  r: IMVCRESTResponse;\n  P: TPerson;\nbegin\n  P := TPerson.Create;\n  try\n    P.FirstName := 'Daniele';\n    P.LastName := '\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd';\n    P.DOB := EncodeDate(1979, 1, 1);\n    P.Married := true;\n    try\n      r := RESTClient\n        .Accept(TMVCMediaType.APPLICATION_JSON)\n        .Post('/objects', GetDefaultSerializer.SerializeObject(P), '');\n    except\n      Assert.Fail('If this test fail, check http://qc.embarcadero.com/wc/qcmain.aspx?d=119779');\n      { WARNING!!! }\n      {\n        If this test fail, check\n        http://qc.embarcadero.com/wc/qcmain.aspx?d=119779\n      }\n      raise;\n    end;\n  finally\n    P.Free;\n  end;\n\n  P := TPerson.Create;\n  try\n    GetDefaultSerializer.DeserializeObject(r.Content, P);\n    // P := Mapper.JSONObjectToObject<TPerson>(r.BodyAsJsonObject);\n    Assert.areEqual('Daniele', P.FirstName);\n    Assert.areEqual('\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd', P.LastName);\n    Assert.areEqual(true, P.Married);\n    Assert.areEqual(EncodeDate(1979, 1, 1), P.DOB);\n  finally\n    P.Free;\n  end;\nend;\n\nprocedure TServerTest.TestPOSTWithParamsAndJSONBody;\nvar\n  r: IMVCRESTResponse;\n  JSON: System.JSON.TJSONObject;\nbegin\n  JSON := System.JSON.TJSONObject.Create;\n  JSON.AddPair('client', 'clientdata');\n  r := RESTClient.AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n    .Post('/echo/($par1)/($par2)/($par3)', TSystemJSON.JSONValueToString(JSON));\n  JSON := TSystemJSON.StringAsJSONObject(r.Content);\n  try\n    Assert.areEqual('clientdata', JSON.Get('client').JsonValue.Value);\n    Assert.areEqual('from server', JSON.Get('echo').JsonValue.Value);\n  finally\n    JSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestProducesConsumesWithWrongAcceptHeader;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Accept('text/plain')\n  // action is waiting for a accept: application/json\n    .Post('/testconsumes', TSystemJSON.JSONValueToString(TJSONString.Create('Hello World')),\n    'application/json');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, res.StatusCode);\nend;\n\nprocedure TServerTest.TestProducesConsumes01;\nvar\n  res: IMVCRESTResponse;\n  lContentType: string;\n  lContentCharset: string;\nbegin\n  res := RESTClient.Accept('application/json').Post('/testconsumes',\n    TSystemJSON.JSONValueToString(TJSONString.Create('Hello World')),\n    BuildContentType('application/json', 'utf-8'));\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('Hello World', res.Content);\n\n  SplitContentMediaTypeAndCharset(res.ContentType, lContentType, lContentCharset);\n  Assert.areEqual(lContentType, TMVCMediaType.APPLICATION_JSON, true);\n  Assert.areEqual(lContentCharset, TMVCCharSet.UTF_8, true);\nend;\n\nprocedure TServerTest.TestProducesConsumes02;\nvar\n  res: IMVCRESTResponse;\n  lContentType: string;\n  lContentCharset: string;\nbegin\n  res := RESTClient.Accept('text/plain').Post('/testconsumes', 'Hello World', 'text/plain');\n  Assert.areEqual('Hello World', res.Content);\n  SplitContentMediaTypeAndCharset(res.ContentType, lContentType, lContentCharset);\n  Assert.areEqual(lContentType, TMVCMediaType.TEXT_PLAIN, true);\n  Assert.areEqual(lContentCharset, TMVCCharSet.UTF_8, true);\n\n  res := RESTClient.Accept('text/plain').Post('/testconsumes', '{\"name\": \"Daniele\"}');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, res.StatusCode);\nend;\n\nprocedure TServerTest.TestProducesConsumes03;\nvar\n  res: IMVCRESTResponse;\n  lContentType: string;\n  lContentCharset: string;\n  lVal: String;\n  lISO8859_1Encoding: TEncoding;\nbegin\n  lISO8859_1Encoding := TEncoding.GetEncoding('iso8859-1');\n  try\n    lVal :=\n      lISO8859_1Encoding\n        .GetString(\n          TEncoding.Convert(\n            TEncoding.Default,\n            lISO8859_1Encoding,\n            lISO8859_1Encoding.GetBytes('\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd')\n            )\n          );\n  finally\n    lISO8859_1Encoding.Free;\n  end;\n  res := RESTClient.Accept(TMVCMediaType.TEXT_PLAIN)\n    .Post('/testconsumes/textiso8859_1', lVal, BuildContentType(TMVCMediaType.TEXT_PLAIN, TMVCCharSet.ISO88591));\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  // Assert.AreNotEqual('\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd', res.Content, 'non iso8859-1 text is rendered ok whan should not');\n  SplitContentMediaTypeAndCharset(res.ContentType, lContentType, lContentCharset);\n  Assert.areEqual(lContentType, TMVCMediaType.TEXT_PLAIN);\n  Assert.areEqual(lContentCharset, TMVCCharSet.ISO88591);\n\n  res := RESTClient.Accept(TMVCMediaType.TEXT_PLAIN).Post('/testconsumes/textiso8859_1',\n    'this is an iso8859-1 text', BuildContentType(TMVCMediaType.TEXT_PLAIN, TMVCCharSet.ISO88591));\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  SplitContentMediaTypeAndCharset(res.ContentType, lContentType, lContentCharset);\n\n  Assert.areEqual('this is an iso8859-1 text', res.Content);\n  Assert.areEqual(lContentType, TMVCMediaType.TEXT_PLAIN);\n  Assert.areEqual(lContentCharset, TMVCCharSet.ISO88591);\nend;\n\nprocedure TServerTest.TestPUTWithParamsAndJSONBody;\nvar\n  r: IMVCRESTResponse;\n  JSON: System.JSON.TJSONObject;\nbegin\n  JSON := System.JSON.TJSONObject.Create;\n  JSON.AddPair('client', 'clientdata');\n  r := RESTClient.AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n    .Put('/echo/($par1)/($par2)/($par3)', TSystemJSON.JSONValueToString(JSON));\n\n  JSON := TSystemJSON.StringAsJSONObject(r.Content);\n  try\n    Assert.areEqual('clientdata', JSON.Get('client').JsonValue.Value);\n    Assert.areEqual('from server', JSON.Get('echo').JsonValue.Value);\n  finally\n    JSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestXHTTPMethodOverride_POST_as_PUT;\nvar\n  r: IMVCRESTResponse;\n  JSON: System.JSON.TJSONObject;\nbegin\n  JSON := System.JSON.TJSONObject.Create;\n  JSON.AddPair('client', 'clientdata');\n  r := RESTClient.AddHeader(TMVCConstants.X_HTTP_Method_Override, 'PUT').AddPathParam('par1', 1)\n    .AddPathParam('par2', 2).AddPathParam('par3', 3).Post('/echo/($par1)/($par2)/($par3)',\n    TSystemJSON.JSONValueToString(JSON));\n\n  JSON := TSystemJSON.StringAsJSONObject(r.Content);\n  try\n    Assert.areEqual('clientdata', JSON.Get('client').JsonValue.Value);\n    Assert.areEqual('from server', JSON.Get('echo').JsonValue.Value);\n  finally\n    JSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestReqWithParams;\nvar\n  ss: TStringStream;\n  lJSON: System.JSON.TJSONObject;\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.Get('/unknownurl/bla/bla');\n\n  ss := TStringStream.Create;\n  try\n    r.SaveContentToStream(ss);\n    Assert.areEqual(ss.DataString, r.Content,\n      'In case of protocol error, the body doesn''t contain the same of BodyAsString');\n  finally\n    ss.Free;\n  end;\n\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, r.StatusCode, '/unknownurl/bla/bla');\n\n  r := RESTClient.Get('/req/with/params/');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, r.StatusCode, '/req/with/params/');\n\n  r := RESTClient.Get('/req/with/params');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, r.StatusCode, '/req/with/params');\n\n  r := RESTClient.AddPathParam('par1', '1').AddPathParam('par2', '2').AddPathParam('par3', '3')\n    .Get('/req/with/params/($par1)/($par2)/($par3)');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, r.StatusCode);\n\n  lJSON := TSystemJSON.StringAsJSONObject(r.Content);\n  try\n    Assert.areEqual('1', lJSON.Get('par1').JsonValue.Value);\n    Assert.areEqual('2', lJSON.Get('par2').JsonValue.Value);\n    Assert.areEqual('3', lJSON.Get('par3').JsonValue.Value);\n    Assert.areEqual('GET', lJSON.Get('method').JsonValue.Value);\n  finally\n    lJSON.Free;\n  end;\n\n  r := RESTClient.AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n    .Post('/req/with/params/($par1)/($par2)/($par3)');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, r.StatusCode);\n\n  r := RESTClient.AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n    .Put('/req/with/params/($par1)/($par2)/($par3)');\n  Assert.areEqual<Integer>(HTTP_STATUS.NotFound, r.StatusCode);\n\n  r := RESTClient.AddPathParam('par1', 1).AddPathParam('par2', 2).AddPathParam('par3', 3)\n    .Delete('/req/with/params/($par1)/($par2)/($par3)');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, r.StatusCode);\n  lJSON := TSystemJSON.StringAsJSONObject(r.Content);\n  try\n    Assert.areEqual('1', lJSON.Get('par1').JsonValue.Value);\n    Assert.areEqual('2', lJSON.Get('par2').JsonValue.Value);\n    Assert.areEqual('3', lJSON.Get('par3').JsonValue.Value);\n    Assert.areEqual('DELETE', lJSON.Get('method').JsonValue.Value);\n  finally\n    lJSON.Free;\n  end;\n\nend;\n\nprocedure TServerTest.TestReqWithURLMappedParams(const par1, par2, par3: string);\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.AddPathParam('par1', par1).AddPathParam('par2', par2).AddPathParam('par3', par3)\n    .Get('/req/with/params/($par1)/($par2)/($par3)');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, r.StatusCode,\n    Format('URL mapped fails for these characters: \"%s\",\"%s\",\"%s\"', [par1, par2, par3]));\nend;\n\nprocedure TServerTest.TestResponseAccepted;\nvar\n  r: IMVCRESTResponse;\n  lJSON: TJDOJsonObject;\nbegin\n  r := RESTClient.Post('/responses/accepted');\n  Assert.areEqual<Integer>(HTTP_STATUS.Accepted, r.StatusCode);\n  Assert.isTrue(r.StatusText.Contains('thisisthereason'));\n  lJSON := StrToJSONObject(r.Content);\n  try\n    Assert.areEqual(2, lJSON.O['task'].Count);\n    Assert.areEqual('http://pippo.it/1234', lJSON.O['task'].S['href']);\n    Assert.areEqual('1234', lJSON.O['task'].S['id']);\n  finally\n    lJSON.Free;\n  end;\nend;\n\nprocedure TServerTest.TestResponseCreated;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.Post('/responses/created');\n  Assert.areEqual<Integer>(HTTP_STATUS.Created, r.StatusCode);\n  Assert.isTrue(r.StatusText.Contains('thisisthereason'));\n  Assert.IsEmpty(r.Content);\nend;\n\nprocedure TServerTest.TestResponseNoContent;\nvar\n  r: IMVCRESTResponse;\nbegin\n  r := RESTClient.Get('/responses/nocontent');\n  Assert.areEqual<Integer>(HTTP_STATUS.NoContent, r.StatusCode);\n  Assert.isTrue(r.StatusText.Contains('No Content'));\n  Assert.IsEmpty(r.Content);\nend;\n\n// procedure TServerTest.TestSerializationType;\n// var\n// LResp: IMVCRESTResponse;\n// LPersonProps, LPersonFlds: TPerson;\n// LObj: TObject;\n// begin\n// LResp := RESTClient.Get('/people', ['1']);\n// LPersonProps := Mapper.JSONObjectToObject<TPerson>(LResp.BodyAsJsonObject);\n// try\n// LResp := RESTClient.Get('/people', ['1', 'asfields']);\n// LObj := Mapper.JSONObjectFieldsToObject(LResp.BodyAsJsonObject);\n// try\n// Assert.AreEqual('BusinessObjectsU.TPerson', LObj.QualifiedClassName);\n// LPersonFlds := TPerson(LObj);\n// Assert.isTrue(LPersonFlds.Equals(LPersonProps),\n// 'Object tranferred using field serialization is different from the object serialized in the default way');\n// finally\n// LObj.Free;\n// end;\n// finally\n// LPersonProps.Free;\n// end;\n// end;\n\nprocedure TServerTest.TestDeserializeNullablesWithNulls;\nvar\n  lRes: IMVCRESTResponse;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lNullableTest: TNullablesTest;\nbegin\n  /// nullables/getsinglewithnulls\n\n  lRes := RESTClient.Get('/nullables/getsinglewithnulls');\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lNullableTest := TNullablesTest.Create();\n    try\n      lSer.DeserializeObject(lRes.Content, lNullableTest);\n      Assert.IsFalse(lNullableTest.f_int2.HasValue);\n      Assert.IsFalse(lNullableTest.f_int4.HasValue);\n      Assert.IsFalse(lNullableTest.f_int8.HasValue);\n      Assert.IsFalse(lNullableTest.f_date.HasValue);\n      Assert.IsFalse(lNullableTest.f_time.HasValue);\n      Assert.IsFalse(lNullableTest.f_datetime.HasValue);\n      Assert.IsFalse(lNullableTest.f_bool.HasValue);\n      Assert.IsFalse(lNullableTest.f_float4.HasValue);\n      Assert.IsFalse(lNullableTest.f_float8.HasValue);\n      Assert.IsFalse(lNullableTest.f_string.HasValue);\n      Assert.IsFalse(lNullableTest.f_currency.HasValue);\n      { TODO -oDanieleT -cGeneral : Compare streams too }\n      // Assert.AreEqual('0123456789', lNullableTest.f_blob.Value, 0);\n    finally\n      lNullableTest.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\n\nend;\n\nprocedure TServerTest.TestDeserializeNullablesWithValue;\nvar\n  lRes: IMVCRESTResponse;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lNullableTest: TNullablesTest;\nbegin\n  /// nullables/getsinglewithnulls\n\n  lRes := RESTClient.Get('/nullables/getsingle');\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lNullableTest := TNullablesTest.Create();\n    try\n      lSer.DeserializeObject(lRes.Content, lNullableTest);\n      Assert.areEqual<Int16>(2, lNullableTest.f_int2.Value);\n      Assert.areEqual(4, lNullableTest.f_int4.Value);\n      Assert.areEqual<Int32>(8, lNullableTest.f_int8.Value);\n      Assert.areEqual('2011-11-17', DateToISODate(lNullableTest.f_date.Value));\n      Assert.areEqual('12:24:36', TimeToISOTime(lNullableTest.f_time.Value));\n      Assert.areEqual('2011-11-17T12:24:36.048+01:00',\n        DateTimeToISOTimeStamp(lNullableTest.f_datetime.Value));\n      Assert.areEqual<boolean>(true, lNullableTest.f_bool.Value);\n      Assert.areEqual(10 / 4, lNullableTest.f_float4.Value, 0.0000009);\n      Assert.areEqual(10 / 8, lNullableTest.f_float8.Value, 0.0000000000009);\n      Assert.areEqual('0123456789', lNullableTest.f_string.Value);\n      Assert.areEqual(98765.4321, lNullableTest.f_currency.Value, 0);\n      { TODO -oDanieleT -cGeneral : Compare streams too }\n      // Assert.AreEqual('0123456789', lNullableTest.f_blob.Value, 0);\n    finally\n      lNullableTest.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestDirectoryRedirect;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/');\n  Assert.areEqual(200, lRes.StatusCode, '/static/');\n\n  lRes := RESTClient.HandleRedirects(false).Accept(TMVCMediaType.TEXT_HTML).Get('/static');\n  Assert.areEqual(301, lRes.StatusCode, '/static');\n  Assert.areEqual('/static/', lRes.HeaderValue('Location'), 'Wrong redirect');\nend;\n\nprocedure TServerTest.TestDirectoryTraversal1;\nvar\n  lRes: IMVCRESTResponse;\n  I: Integer;\n  lUrl: string;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/index.html');\n  Assert.areEqual(200, lRes.StatusCode);\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/..\\donotdeleteme.txt');\n  Assert.areEqual(404, lRes.StatusCode);\n\n  lUrl := 'Windows\\win.ini';\n  for I := 1 to 20 do\n  begin\n    lUrl := '..\\' + lUrl;\n    lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/' + lUrl);\n    Assert.areEqual(404, lRes.StatusCode, 'Fail with: ' + '/static/' + lUrl);\n  end;\nend;\n\nprocedure TServerTest.TestDirectoryTraversal2;\nvar\n  lRes: IMVCRESTResponse;\n  I: Integer;\n  lUrl: string;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/..\\..\\donotdeleteme.txt');\n  Assert.areEqual(404, lRes.StatusCode);\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/../../donotdeleteme.txt');\n  Assert.areEqual(404, lRes.StatusCode);\n\n  lUrl := 'Windows\\win.ini';\n  for I := 1 to 30 do\n  begin\n    lUrl := '..\\' + lUrl;\n    lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/static/' + lUrl);\n    Assert.areEqual(404, lRes.StatusCode, 'Fail with: ' + '/static/' + lUrl);\n  end;\nend;\n\nprocedure TServerTest.TestSerializeAndDeserializeNullables;\nvar\n  lRes: IMVCRESTResponse;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lNullableTest: TNullablesTest;\nbegin\n  lRes := RESTClient.Get('/nullables/getsingle');\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lNullableTest := TNullablesTest.Create();\n    try\n      lSer.DeserializeObject(lRes.Content, lNullableTest);\n      lRes := RESTClient.Post('/nullables/pingpong', lSer.SerializeObject(lNullableTest));\n    finally\n      lNullableTest.Free;\n    end;\n\n    lNullableTest := TNullablesTest.Create();\n    try\n      lSer.DeserializeObject(lRes.Content, lNullableTest);\n      Assert.areEqual<Int16>(2, lNullableTest.f_int2.Value);\n      Assert.areEqual(4, lNullableTest.f_int4.Value);\n      Assert.areEqual<Int32>(8, lNullableTest.f_int8.Value);\n      Assert.areEqual('2011-11-17', DateToISODate(lNullableTest.f_date.Value));\n      Assert.areEqual('12:24:36', TimeToISOTime(lNullableTest.f_time.Value));\n      Assert.areEqual('2011-11-17T12:24:36.048+01:00',\n        DateTimeToISOTimeStamp(lNullableTest.f_datetime.Value));\n      Assert.areEqual<boolean>(true, lNullableTest.f_bool.Value);\n      Assert.areEqual(10 / 4, lNullableTest.f_float4.Value, 0.0000009);\n      Assert.areEqual(10 / 8, lNullableTest.f_float8.Value, 0.0000000000009);\n      Assert.areEqual('0123456789', lNullableTest.f_string.Value);\n      Assert.areEqual(98765.4321, lNullableTest.f_currency.Value, 0);\n      { TODO -oDanieleT -cGeneral : Compare streams too }\n      // Assert.AreEqual('0123456789', lNullableTest.f_blob.Value, 0);\n    finally\n      lNullableTest.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestSerializeAndDeserializeNullables_ISSUE_362;\nconst\n  JSON1: string = '{\"f_int2\":2,\"f_int4\":4,\"f_int8\":8,\"f_string\":\"0123456789\",\"f_bool\":true, ' +\n    '\"f_date\":\"2011-11-17\",\"f_time\":\"12:24:36\",\"f_datetime\":\"2011-11-17T12:24:36.048Z\",' +\n    '\"f_float4\":2.5,\"f_float8\":1.25,\"f_currency\":98765.4321,\"f_blob\":\"0123456789\"}';\n  JSON2: string = '{\"f_int2\":2,\"f_int4\":4,\"f_int8\":8,\"f_string\":\"0123456789\",\"f_bool\":true, ' +\n    '\"f_date\":\"2011-11-17\",\"f_time\":\"12:24:36\",\"f_datetime\":\"2011-11-17T12:24:36.048Z\",' +\n    '\"f_float4\":2,\"f_float8\":3,\"f_currency\":4,\"f_blob\":\"0123456789\"}';\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lNullableTest: TNullablesTest;\nbegin\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lNullableTest := TNullablesTest.Create();\n    try\n      lSer.DeserializeObject(JSON1, lNullableTest);\n    finally\n      lNullableTest.Free;\n    end;\n    lNullableTest := TNullablesTest.Create();\n    try\n      { in this case nullable floats type actually contains integers... }\n      lSer.DeserializeObject(JSON2, lNullableTest);\n    finally\n      lNullableTest.Free;\n    end;\n    Assert.Pass();\n  finally\n    lSer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestSerializeAndDeserializeNullables_Passing_Integers_InsteadOf_Floats;\nconst\n  JSON1: string = '{\"f_int2\":2,\"f_int4\":4,\"f_int8\":8,\"f_string\":\"0123456789\",\"f_bool\":true, ' +\n    '\"f_date\":\"2011-11-17\",\"f_time\":\"12:24:36\",\"f_datetime\":\"2011-11-17T12:24:36.048Z\",' +\n    '\"f_float4_not_null\":1234,\"f_float8_not_null\":2345, ' +\n    '\"f_float4\":2.5,\"f_float8\":1.25,\"f_currency\":98765.4321,\"f_blob\":\"0123456789\"}';\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lNullableTest: TNullablesTest;\nbegin\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lNullableTest := TNullablesTest.Create();\n    try\n      { in this case not nullable floats type actually contains integers... }\n      lSer.DeserializeObject(JSON1, lNullableTest);\n      Assert.areEqual(1234, lNullableTest.f_float4_not_null, 0.0001);\n      Assert.areEqual(2345, lNullableTest.f_float8_not_null, 0.0001);\n    finally\n      lNullableTest.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestSession;\nvar\n  c1: IMVCRESTClient;\n  res: IMVCRESTResponse;\n  S: string;\n  lCookie: TCookie;\nbegin\n  c1 := TMVCRESTClient\n    .New\n    .BaseURL(TEST_SERVER_ADDRESS, 8888)\n    .Accept(TMVCMediaType.APPLICATION_JSON);\n  res := c1.Post('/session/daniele teti'); // imposto un valore in sessione\n  Assert.IsTrue(res.Cookies.Count > 0);\n  lCookie := res.CookieByName('dtsessionid', True);\n  Assert.AreEqual('dtsessionid', lCookie.Name);\n//  Assert.IsFalse(S.Contains('Expires'), 'Session cookie contains \"expires\" attribute');\n  res := c1\n    .AddCookie('dtsessionid', lCookie.Value)\n    .Get('/session'); // rileggo il valore dalla sessione\n  S := res.Content;\n  Assert.areEqual('daniele teti', res.Content);\n  c1.Accept(TMVCMediaType.TEXT_PLAIN);\n  res := c1.Get('/session');\n  // rileggo il valore dalla sessione\n  Assert.areEqual('daniele teti', res.Content);\n\n  // aggiungo altri cookies\n  res := c1.Get('/lotofcookies'); // rileggo il valore dalla sessione\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  c1.Accept(TMVCMediaType.TEXT_PLAIN);\n  res := c1.Get('/session'); // rileggo il valore dalla sessione\n  Assert.areEqual('daniele teti', res.Content);\nend;\n\nprocedure TServerTest.TestSessionWithLogin;\nbegin\n  DoLoginWith('daniele');\n  DoLogout;\nend;\n\nprocedure TServerTest.TestSPASupport;\nvar\n  lRes: IMVCRESTResponse;\n  I: Integer;\n  lUrl: string;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/spa/index.html');\n  Assert.areEqual(200, lRes.StatusCode);\n  Assert.Contains(lRes.Content, 'This is a TEXT file');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/spa/');\n  Assert.areEqual(200, lRes.StatusCode, '/static/');\n  Assert.Contains(lRes.Content, 'This is a TEXT file');\n\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/spa/pippo/pluto/paperino');\n  Assert.areEqual(200, lRes.StatusCode, '/spa/pippo/pluto/paperino');\n  Assert.Contains(lRes.Content, 'This is a TEXT file');\n\n  lUrl := 'Windows\\win.ini';\n  for I := 1 to 30 do\n  begin\n    { directory traversal attacks receive always 404 }\n    lUrl := '..\\' + lUrl;\n    lRes := RESTClient.Accept(TMVCMediaType.TEXT_HTML).Get('/spa/' + lUrl);\n    Assert.areEqual(404, lRes.StatusCode);\n    Assert.Contains(lRes.Content, '404', true);\n    Assert.Contains(lRes.Content, 'Not Found', true);\n  end;\nend;\n\nprocedure TServerTest.TestSqidSingle(IntValue: UInt64; Sqid: String);\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/sqids/itos/' + IntValue.ToString);\n  Assert.areEqual(200, lRes.StatusCode);\n  Assert.AreEqual(TMVCSqids.IntToSqid(IntValue), lRes.Content.Trim, '(local)');\n  Assert.AreEqual(Sqid, lRes.Content.Trim, '(remote)');\n  lRes := RESTClient.Get('/sqids/stoi/' + Sqid);\n  Assert.areEqual(200, lRes.StatusCode);\n  Assert.AreEqual<Int64>(IntValue, lRes.Content.Trim.ToInt64);\nend;\n\nprocedure TServerTest.TestStringDictionary;\nvar\n  lRes: IMVCRESTResponse;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lDict: TMVCStringDictionary;\nbegin\n  lRes := RESTClient.Post('/stringdictionary', '{\"prop1\":\"value1\",\"prop2\":\"value2\"}');\n  Assert.areEqual(200, lRes.StatusCode);\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lDict := TMVCStringDictionary.Create;\n    try\n      lSer.DeserializeObject(lRes.Content, lDict);\n      Assert.areEqual(3, lDict.Count);\n      Assert.areEqual('value1', lDict['prop1']);\n      Assert.areEqual('value2', lDict['prop2']);\n      Assert.areEqual('changed', lDict['fromserver']);\n    finally\n      lDict.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\nend;\n\nprocedure TServerTest.TestTypedAll;\nvar\n  res: IMVCRESTResponse;\n  lJObj: System.JSON.TJSONObject;\nbegin\n  // ----------------------'/typed/all/($ParString)/($ParInteger)/($ParInt64)/($ParSingle)/($ParDouble)/($ParExtended)')');\n  res := RESTClient.Get('/typed/all/mystring/1234/12345678/12.3/1234.5678/1234.5678');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  lJObj := TSystemJSON.StringAsJSONObject(res.Content);\n  try\n    Assert.areEqual('mystring', lJObj.GetValue('ParString').Value, 'ParString');\n    Assert.areEqual(1234, TJSONNumber(lJObj.GetValue('ParInteger')).AsInt, 'ParInteger');\n    Assert.areEqual(Int64(12345678), TJSONNumber(lJObj.GetValue('ParInt64')).AsInt64, 'ParInt64');\n    Assert.areEqual(12.3, RoundTo(TJSONNumber(lJObj.GetValue('ParSingle')).AsDouble, -1),\n      'ParSingle');\n    Assert.areEqual(1234.5678, RoundTo(TJSONNumber(lJObj.GetValue('ParDouble')).AsDouble, -4),\n      'ParDouble');\n    Assert.areEqual(1234.5678, RoundTo(TJSONNumber(lJObj.GetValue('ParExtended')).AsDouble, -4),\n      'ParExtended');\n  finally\n    lJObj.Free;\n  end;\nend;\n\nprocedure TServerTest.TestTypedBooleans;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/booleans/true/false/1/0');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('true.false.true.false', res.Content.ToLower);\nend;\n\nprocedure TServerTest.TestTypedDouble1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/double1/1234.5678');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('1234.5678 modified from server', res.Content);\n\nend;\n\nprocedure TServerTest.TestTypedExtended1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/extended1/1234.5678');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('1234.5678 modified from server', res.Content);\n\nend;\n\nprocedure TServerTest.TestTypedInt641;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/int641/12345678');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('12345678 modified from server', res.Content);\nend;\n\nprocedure TServerTest.TestTypedInteger1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/integer1/1234');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('1234 modified from server', res.Content);\nend;\n\nprocedure TServerTest.TestTypedIntegerWrongParam1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/integer1/boom');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.BadRequest, 'Cannot route');\n  Assert.Contains(res.Content, 'EConvertError');\n  Assert.Contains(res.Content, '''boom'' is not a valid');\nend;\n\nprocedure TServerTest.TestTypedSingle1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/single1/1234.5');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('1234.5 modified from server', res.Content);\n\nend;\n\nprocedure TServerTest.TestTypedString1;\nvar\n  res: IMVCRESTResponse;\n  lValues: array [0 .. 7] of string;\n  S: string;\nbegin\n  lValues[0] := 'daniele';\n  lValues[1] := 'dan''iele';\n  lValues[2] := '\"daniele\"';\n  lValues[3] := '\"daniele teti\"';\n  lValues[4] := '\"daniele\" \"teti\"';\n  lValues[5] := '\"daniele\" \"teti\"!';\n  lValues[6] := ' _\\\"daniele\" \"teti\"!_';\n\n  for S in lValues do\n  begin\n    res := RESTClient.AddPathParam('TypedString', S).Get('/typed/string1/{TypedString}');\n    Assert.areEqual(HTTP_STATUS.OK, res.StatusCode, 'Cannot route when param is [' + S + ']');\n    Assert.areEqual('*' + S + '*', res.Content);\n  end;\nend;\n\nprocedure TServerTest.TestTypedTGuid1;\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.Get('/typed/tguid1/{161BEA56-480B-40A8-AF0E-7FDF6B08E121}');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('{161BEA56-480B-40A8-AF0E-7FDF6B08E121} modified from server', res.Content);\n\n  res := RESTClient.Get('/typed/tguid1/161BEA56-480B-40A8-AF0E-7FDF6B08E121');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('{161BEA56-480B-40A8-AF0E-7FDF6B08E121} modified from server', res.Content);\n\n  res := RESTClient.Get('/typed/tguid1/161BEA56480B40A8AF0E7FDF6B08E121');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Cannot route');\n  Assert.areEqual('{161BEA56-480B-40A8-AF0E-7FDF6B08E121} modified from server', res.Content);\nend;\n\nprocedure TServerTest.TestViewDataViewDataSet;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Accept(TMVCMediaType.TEXT_PLAIN).Get('/website/list');\n  Assert.areEqual(HTTP_STATUS.OK, lRes.StatusCode, lRes.Content);\n  var lLines := lRes.Content.Split([sLineBreak]);\n  Assert.IsTrue(Length(lLines) > 5);\n  var lCount: Integer := 1001;\n  for var lLine in lLines do\n  begin\n    if lLine.IsEmpty then\n    begin\n      Continue;\n    end;\n    var lLinePieces := lLine.Split(['|']);\n    if Length(lLinePieces) = 1 then\n    begin\n      lCount := 1001;\n      Continue;\n    end;\n    Assert.AreEqual<Integer>(9, Length(lLinePieces));\n    Assert.areEqual(lCount, lLinePieces[0].ToInteger);\n    Inc(lCount);\n  end;\nend;\n\nprocedure TServerTest.TestWrongJSONBody;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Post('/stringdictionary', '{\"prop1\",\"value1\"}');\n  Assert.areEqual(HTTP_STATUS.BadRequest, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestWrongSqid;\nvar\n  lRes: IMVCRESTResponse;\nbegin\n  lRes := RESTClient.Get('/sqids/itos/123456789123456789123456789123456789');\n  Assert.areEqual(400, lRes.StatusCode);\nend;\n\nprocedure TServerTest.TestTypedDateTimeTypes;\nvar\n  res: IMVCRESTResponse;\nbegin\n  // TDate, wrong and correct\n  res := RESTClient.Get('/typed/tdate1/20161012');\n  Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, res.StatusCode, 'wrong TDate');\n\n  res := RESTClient.Get('/typed/tdate1/2016-10-12');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12 modified from server', res.Content);\n\n  // TDateTime, wrong and correct\n  res := RESTClient.Get('/typed/tdatetime1/20161');\n  Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, res.StatusCode, 'wrong TDateTime (1)');\n\n  // Wrong\n  res := RESTClient.Get('/typed/tdatetime1/20161012121212');\n  Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, res.StatusCode, 'wrong TDateTime (2)');\n\n  // Correct without 'T'\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12 12:12:12');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode, 'wrong TDateTime (3)');\n  Assert.areEqual('2016-10-12T12:12:12.000+02:00 modified from server', res.Content);\n\n  // Correct in extended form with zero UTC offset\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12T12:12:12Z');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12T14:12:12.000+02:00 modified from server', res.Content);\n\n  // Correct in extended form without timezone\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12T12:12:12');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12T12:12:12.000+02:00 modified from server', res.Content);\n\n  // Correct in extended form with timezone\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12T12:12:12.000Z');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12T14:12:12.000+02:00 modified from server', res.Content);\n\n  // TTime, wrong and correct\n  res := RESTClient.Get('/typed/ttime1/121212');\n  Assert.areEqual<Integer>(HTTP_STATUS.BadRequest, res.StatusCode, 'wrong TTime');\n\n  res := RESTClient.Get('/typed/ttime1/12:12:12');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('12:12:12 modified from server', res.Content);\n\nend;\n\nprocedure TServerTest.TestTypedDateTimeTypes_UTC;\nvar\n  res: IMVCRESTResponse;\nbegin\n  // If no UTC zone is defined, server must assume its local time zone\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12 12:12:12');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode, 'wrong TDateTime (3)');\n  Assert.areEqual('2016-10-12T12:12:12.000+02:00 modified from server', res.Content);\n\n  // With UTC zero offset, server must return time expressed as its local UTC\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12T12:12:12Z');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12T14:12:12.000+02:00 modified from server', res.Content);\n\n  // Correct in extended form with timezone\n  res := RESTClient.Get('/typed/tdatetime1/2016-10-12T12:12:12.000Z');\n  Assert.areEqual<Integer>(HTTP_STATUS.OK, res.StatusCode);\n  Assert.areEqual('2016-10-12T14:12:12.000+02:00 modified from server', res.Content);\nend;\n\nprocedure TBaseServerTest.DoLoginWith(UserName: string);\nvar\n  res: IMVCRESTResponse;\nbegin\n  res := RESTClient.AddPathParam('username', UserName).Get('/login/{username}');\n  Assert.isTrue(res.StatusCode = HTTP_STATUS.OK, 'Login Failed: ' + res.Content);\nend;\n\n{ TJSONRPCServerTest }\n\nprocedure TJSONRPCServerTest.InitExecutors;\nbegin\n  FExecutor := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS + ':8888/jsonrpc', false);\n  FExecutor2 := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS +\n    ':8888/jsonrpcclass', false);\n  FExecutor3 := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS +\n    ':8888/jsonrpcclass1', false);\nend;\n\nprocedure TJSONRPCServerTest.Setup;\nbegin\n  InitExecutors;\n  for var Ex in [FExecutor, FExecutor2, FExecutor3] do\n  begin\n    FExecutor.SetOnSendCommand(\n      procedure(JSONRPCObject: IJSONRPCObject)\n      begin\n        LogD('[JSONRPC REQUEST] : ' + JSONRPCObject.ToString(true));\n      end);\n\n    FExecutor.SetOnReceiveHTTPResponse(\n      procedure(HTTPResp: IHTTPResponse)\n      begin\n        LogD('[JSONRPC RESPONSE]: ' + HTTPResp.ContentAsString());\n      end);\n  end;\nend;\n\nprocedure TJSONRPCServerTest.TestEnum;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'ProcessEnums');\n  lRequest1.Params.Add('etValue1');\n  lRequest1.Params.Add('etValue2');\n  var lResp := FExecutor2.ExecuteRequest(lRequest1);\n  Assert.AreEqual(\n    GetEnumValue(TypeInfo(TEnumTest), 'etValue2'),\n    GetEnumValue(TypeInfo(TEnumTest), lResp.Result.AsString)\n    );\nend;\n\nprocedure TJSONRPCServerTest.TestGetTCustomer_ISSUE648;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'GetTCustomer_ISSUE648');\n  var lResp := FExecutor2.ExecuteRequest(lRequest1);\n  var lCustomer := TJSONUtils.JsonObjectToRecord<TCustomerIssue648>(lResp);\n  Assert.AreEqual(155, lCustomer.Id.Value);\n  Assert.AreEqual('Daniele Teti', lCustomer.Name.Value);\nend;\n\nprocedure TJSONRPCServerTest.TestHooks;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'request1');\n  var lResp := FExecutor3.ExecuteRequest(lRequest1);\n  Assert.areEqual('OnBeforeRoutingHook|OnBeforeCallHook|OnAfterCallHook',\n    FExecutor3.HTTPResponse.HeaderValue['x-history']);\nend;\n\nprocedure TJSONRPCServerTest.TestHooksNotif;\nvar\n  lResp: IJSONRPCResponse;\nbegin\n  var\n    lNotif: IJSONRPCNotification := TJSONRPCNotification.Create('Notif1');\n  lResp := FExecutor3.ExecuteNotification(lNotif);\n  Assert.areEqual('OnBeforeRoutingHook|OnBeforeCallHook|OnAfterCallHook',\n    FExecutor3.HTTPResponse.HeaderValue['x-history']);\n  Assert.IsFalse(lResp.IsError);\n  Assert.WillRaise(\n    procedure\n    begin\n      lResp.AsJSONString;\n    end, EMVCJSONRPCException);\nend;\n\nprocedure TJSONRPCServerTest.TestHooksNotifWhenOnAfterCallHookRaisesError;\nvar\n  lResp: IJSONRPCResponse;\nbegin\n  var\n    lNotif: IJSONRPCNotification := TJSONRPCNotification.Create('error_OnAfterCallHook');\n  lResp := FExecutor3.ExecuteNotification(lNotif);\n  Assert.areEqual('', FExecutor3.HTTPResponse.HeaderValue['x-history']);\n  Assert.isTrue(lResp.IsError);\n  Assert.WillNotRaise(\n    procedure\n    begin\n      lResp.AsJSONString;\n    end, EMVCJSONRPCException);\nend;\n\nprocedure TJSONRPCServerTest.TestHooksNotifWhenOnBeforeCallHookRaisesError;\nvar\n  lResp: IJSONRPCResponse;\nbegin\n  var\n    lNotif: IJSONRPCNotification := TJSONRPCNotification.Create('error_OnBeforeCallHook');\n  lResp := FExecutor3.ExecuteNotification(lNotif);\n  Assert.areEqual('', FExecutor3.HTTPResponse.HeaderValue['x-history']);\n  Assert.isTrue(lResp.IsError);\n  Assert.WillNotRaise(\n    procedure\n    begin\n      lResp.AsJSONString;\n    end, EMVCJSONRPCException);\nend;\n\nprocedure TJSONRPCServerTest.TestHooksNotifWhenOnBeforeRoutingHookRaisesError;\nvar\n  lResp: IJSONRPCResponse;\nbegin\n  var\n    lNotif: IJSONRPCNotification := TJSONRPCNotification.Create('error_OnBeforeRoutingHook');\n  lResp := FExecutor3.ExecuteNotification(lNotif);\n  Assert.areEqual('', FExecutor3.HTTPResponse.HeaderValue['x-history']);\n  Assert.isTrue(lResp.IsError);\n  Assert.WillNotRaise(\n    procedure\n    begin\n      lResp.AsJSONString;\n    end, EMVCJSONRPCException);\nend;\n\nprocedure TJSONRPCServerTest.TestHooksWhenMethodRaisesError;\nvar\n  lResp: IJSONRPCResponse;\nbegin\n  var\n    lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'RequestWithError');\n  lResp := FExecutor3.ExecuteRequest(lRequest1);\n  Assert.areEqual('OnBeforeRoutingHook|OnBeforeCallHook|OnAfterCallHook|error',\n    FExecutor3.HTTPResponse.HeaderValue['x-history']);\n  Assert.isTrue(lResp.IsError, 'Method raised error but response is not an error');\nend;\n\nprocedure TJSONRPCServerTest.TestHooksWhenOnAfterCallHookRaisesError;\nbegin\n  var\n    lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'error_OnAfterCallHook');\n  var\n  lResp := FExecutor3.ExecuteRequest(lRequest1);\n  Assert.isTrue(lResp.IsError, lResp.ToString(true));\n  Assert.areEqual(lResp.Error.ErrMessage, 'error_OnAfterCallHook');\nend;\n\nprocedure TJSONRPCServerTest.TestHooksWhenOnBeforeCallHookRaisesError;\nbegin\n  var\n    lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'error_OnBeforeCallHook');\n  var\n  lResp := FExecutor3.ExecuteRequest(lRequest1);\n  Assert.isTrue(lResp.IsError, lResp.ToString(true));\n  Assert.areEqual(lResp.Error.ErrMessage, 'error_OnBeforeCallHook');\n\nend;\n\nprocedure TJSONRPCServerTest.TestHooksWhenOnBeforeRoutingHookRaisesError;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'error_OnBeforeRoutingHook');\n  var lResp := FExecutor3.ExecuteRequest(lRequest1);\n  Assert.isTrue(lResp.IsError, lResp.ToString(true));\n  Assert.areEqual(lResp.Error.ErrMessage, 'error_OnBeforeRoutingHook');\nend;\n\nprocedure TJSONRPCServerTest.TestInvalidEnum;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'ProcessEnums');\n  lRequest1.Params.Add('etValue1');\n  lRequest1.Params.Add('blabla');  //invalid enum value\n  var lResp := FExecutor2.ExecuteRequest(lRequest1);\n  Assert.IsTrue(lResp.IsError);\nend;\n\nprocedure TJSONRPCServerTest.TestInvalidSet;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'ProcessSets');\n  lRequest1.Params.Add('etValue1,blabla');\n  lRequest1.Params.Add('etValue3');\n  var lResp := FExecutor2.ExecuteRequest(lRequest1);\n  var l := lResp.AsJSONString;\n  Assert.IsTrue(lResp.IsError);\nend;\n\nprocedure TJSONRPCServerTest.TestNotificationWhichRaisesError;\nvar\n  lReq: IJSONRPCNotification;\nbegin\n  lReq := TJSONRPCNotification.Create;\n  lReq.Method := 'NotifWithError';\n  var\n  lResp := FExecutor3.ExecuteNotification(lReq);\n  Assert.isTrue(lResp.IsError);\n  Assert.Contains(lResp.Error.ErrMessage, 'BOOM NOTIF');\nend;\n\nprocedure TJSONRPCServerTest.TestNotificationWithoutParams;\nvar\n  lReq: IJSONRPCNotification;\nbegin\n  lReq := TJSONRPCNotification.Create;\n  lReq.Method := 'mynotify';\n  FExecutor.ExecuteNotification(lReq);\n  FExecutor2.ExecuteNotification(lReq);\n  Assert.Pass();\nend;\n\nprocedure TJSONRPCServerTest.TestRequestToNotFoundMethod;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'nonexist';\n  lReq.RequestID := 1234;\n  lResp := FExecutor.ExecuteRequest(lReq);\n  Assert.IsNotNull(lResp.Error);\n  Assert.areEqual(-32601, lResp.Error.Code);\n  Assert.isTrue(lResp.Error.ErrMessage.StartsWith('Method [nonexist] not found.'));\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithParams_DT_T_ret_DT;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lRes: TDateTime;\n  lYear: Word;\n  lMonth: Word;\n  lDay: Word;\n  lHour: Word;\n  lMinute: Word;\n  lSecond: Word;\n  lMillisecond: Word;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'addtimetodatetime';\n  lReq.Params.Add(EncodeDate(2000, 10, 1) + EncodeTime(12, 0, 0, 0),\n    TJSONRPCParamDataType.pdtDateTime);\n  lReq.Params.Add(EncodeTime(1, 0, 0, 0), TJSONRPCParamDataType.pdtTime);\n  lReq.RequestID := 1234;\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lRes := ISOTimeStampToDateTime(lRPCResp.Result.AsString());\n  DecodeDateTime(lRes, lYear, lMonth, lDay, lHour, lMinute, lSecond, lMillisecond);\n  Assert.areEqual(2000, lYear);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithWrongNamedParams;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'add';\n  lReq.Params.AddByName('wrongname1', 3);\n  lReq.Params.AddByName('wrongname2', 4);\n  lReq.Params.AddByName('wrongname3', 5);\n  lReq.RequestID := 1234;\n\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  Assert.isTrue(lRPCResp.IsError);\n  Assert.Contains(lRPCResp.Error.ErrMessage, 'cannot find parameter', true);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithException;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\n  lPersSrc: TPerson;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'DoError';\n  lPersSrc := TPerson.GetNew('Daniele','Teti', EncodeDate(1979,12,1), True);\n  lReq.Params.AddByName('MyObj', lPersSrc);\n  lReq.RequestID := 1;\n  lResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.IsTrue(lResp.IsError);\n  Assert.AreEqual('BOOOM!! (TTestJSONRPCClass.DoError)', lResp.Error.ErrMessage);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithNamedParams_I_I_I_ret_O;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lS: string;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'add';\n  lReq.Params.AddByName('value1', 3);\n  lReq.Params.AddByName('value2', 4);\n  lReq.Params.AddByName('value3', 5);\n  lReq.RequestID := 1234;\n\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  lS := (lRPCResp.Result.AsObject as TJDOJsonObject).ToJSON();\n  Assert.areEqual(12, TJDOJsonObject(lRPCResp.Result.AsObject).I['res']);\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lS := (lRPCResp.Result.AsObject as TJDOJsonObject).ToJSON();\n  Assert.areEqual(12, TJDOJsonObject(lRPCResp.Result.AsObject).I['res']);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithNamedParams_I_I_ret_I;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.RequestID := 1234;\n  lReq.Method := 'subtract';\n  lReq.Params.AddByName('Value1', 18);\n  lReq.Params.AddByName('Value2', 8);\n\n  lResp := FExecutor.ExecuteRequest(lReq);\n  Assert.areEqual(10, lResp.Result.AsInteger);\n  Assert.areEqual(1234, lResp.RequestID.AsInteger);\n\n  lResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.areEqual(10, lResp.Result.AsInteger);\n  Assert.areEqual(1234, lResp.RequestID.AsInteger);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithObjectParameters;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\n  lPersSrc, lPersDst: TPerson;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'handlingobjects';\n  lPersSrc := TPerson.GetNew('Daniele','Teti', EncodeDate(1979,12,1), True);\n  lReq.Params.AddByName('MyObj', lPersSrc);\n  lReq.RequestID := 1;\n  lResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.IsFalse(lResp.IsError);\n\n  lPersDst := TPerson.Create;\n  try\n    lResp.ResultAs(lPersDst);\n    Assert.AreEqual(lPersSrc.ToString, lPersDst.ToString);\n  finally\n    lPersDst.Free;\n  end;\nend;\n\n\nprocedure TJSONRPCServerTest.TestRequestWithoutParams;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'MyRequest';\n  lReq.RequestID := 1234;\n  lResp := FExecutor.ExecuteRequest(lReq);\n  Assert.IsFalse(lResp.IsError);\n  Assert.isTrue(lResp.Result.AsBoolean);\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithParams_I_I_ret_I;\nvar\n  lReq: IJSONRPCRequest;\n  lResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.RequestID := 1234;\n  lReq.Method := 'subtract';\n  lReq.Params.Add(18);\n  lReq.Params.Add(8);\n\n  lResp := FExecutor.ExecuteRequest(lReq);\n  Assert.areEqual(10, lResp.Result.AsInteger, '(step1.1)');\n  Assert.areEqual(1234, lResp.RequestID.AsInteger, '(step1.2)');\n\n  lResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.areEqual(10, lResp.Result.AsInteger, '(step2.1)');\n  Assert.areEqual(1234, lResp.RequestID.AsInteger, '(step2.2)');\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithParams_I_I_ret_A;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lArr: TJDOJsonArray;\n  I: Integer;\n  x: Integer;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'GetListFromTo';\n  lReq.Params.Add(1);\n  lReq.Params.Add(5);\n  lReq.RequestID := 1234;\n\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  lArr := TJDOJsonArray(lRPCResp.Result.AsObject);\n  x := 1;\n  for I := 0 to lArr.Count - 1 do\n  begin\n    Assert.areEqual(x, lArr[I].IntValue);\n    Inc(x);\n  end;\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lArr := TJDOJsonArray(lRPCResp.Result.AsObject);\n  x := 1;\n  for I := 0 to lArr.Count - 1 do\n  begin\n    Assert.areEqual(x, lArr[I].IntValue);\n    Inc(x);\n  end;\n\nend;\n\nprocedure TJSONRPCServerTest.TestRequestWithParams_I_I_I_ret_O;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lS: string;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'add';\n  lReq.Params.Add(3);\n  lReq.Params.Add(4);\n  lReq.Params.Add(5);\n  lReq.RequestID := 1234;\n\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  lS := (lRPCResp.Result.AsObject as TJDOJsonObject).ToJSON();\n  Assert.areEqual(12, TJDOJsonObject(lRPCResp.Result.AsObject).I['res']);\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lS := (lRPCResp.Result.AsObject as TJDOJsonObject).ToJSON();\n  Assert.areEqual(12, TJDOJsonObject(lRPCResp.Result.AsObject).I['res']);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_Echo_ComplexRecord;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lComplexRecIn, lComplexRecOut: TComplexRecord;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'EchoSingleComplexRecord';\n  lReq.RequestID := 1234;\n  lComplexRecIn := TComplexRecord.Create;\n\n  lReq.Params.Add(TValue.From<TComplexRecord>(lComplexRecIn), pdtRecordOrArrayOfRecord);\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.IsFalse(lRPCResp.IsError, lRPCResp.AsJSONString);\n  lRPCResp.ResultAsJSONObject.SaveToFile('EchoSingleComplexRecord_RESPONSE.json', False);\n  lComplexRecOut := TJSONUtils.JSONObjectToRecord<TComplexRecord>(lRPCResp);\n  lComplexRecIn.Equals(lComplexRecOut);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_Echo_ComplexRecords;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lComplexRecIn, lComplexRecOut: TComplexRecordArray;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'EchoArrayOfRecords';\n  lReq.RequestID := 1234;\n  SetLength(lComplexRecIn, 2);\n  lComplexRecIn[0] := TComplexRecord.Create;\n  lComplexRecIn[1] := TComplexRecord.Create;\n  lComplexRecIn[0].StringProperty := 'firstone';\n  lComplexRecIn[1].StringProperty := 'secondone';\n\n  lReq.Params.Add(TValue.From<TComplexRecordArray>(lComplexRecIn), pdtRecordOrArrayOfRecord);\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.IsFalse(lRPCResp.IsError, lRPCResp.AsJSONString);\n  lRPCResp.ResultAsJSONArray.SaveToFile('TestRequest_Echo_ComplexRecords_RESPONSE.json', False);\n  lComplexRecOut := TJSONUtils.JSONArrayToArrayOfRecord<TComplexRecord>(lRPCResp);\n  lComplexRecIn[0].Equals(lComplexRecOut[0]);\n  lComplexRecIn[1].Equals(lComplexRecOut[1]);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_Echo_SingleRecordAsResult;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lSimpleRecIn, lSimpleRec: TSimpleRecord;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'EchoSingleRecord';\n  lReq.RequestID := 1234;\n\n  lSimpleRecIn := TSimpleRecord.Create;\n  lReq.Params.Add(TValue.From<TSimpleRecord>(lSimpleRecIn), pdtRecordOrArrayOfRecord);\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lSimpleRec := TJSONUtils.JsonObjectToRecord<TSimpleRecord>(lRPCResp);\n  Assert.IsTrue(lSimpleRecIn.Equals(lSimpleRec));\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_NamedParams_S_I_ret_S;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'MultiplyString';\n  lReq.Params.AddByName('aString', 'Daniele');\n  lReq.Params.AddByName('Multiplier', 4);\n  lReq.RequestID := 1234;\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  Assert.IsFalse(lRPCResp.IsError);\n  Assert.areEqual('DanieleDanieleDanieleDaniele', lRPCResp.Result.AsString);\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.areEqual('DanieleDanieleDanieleDaniele', lRPCResp.Result.AsString);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_NoParams_DynamicArrayOfRecordAsResult;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lSimpleRecArray: TArray<TSimpleRecord>;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'GetArrayOfRecords';\n  lReq.RequestID := 1234;\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lSimpleRecArray := TJSONUtils.JSONArrayToArrayOfRecord<TSimpleRecord>(lRPCResp);\n  Assert.AreEqual<Integer>(3, Length(lSimpleRecArray));\n  Assert.AreEqual(0, lSimpleRecArray[0].IntegerProperty);\n  Assert.AreEqual(1, lSimpleRecArray[1].IntegerProperty);\n  Assert.AreEqual(2, lSimpleRecArray[2].IntegerProperty);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_NoParams_SingleComplexRecordAsResult;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lRec: TComplexRecord;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'GetSingleComplexRecord';\n  lReq.RequestID := 1234;\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lRec := TJSONUtils.JsonObjectToRecord<TComplexRecord>(lRPCResp);\n\n  //1st level fields\n  Assert.AreEqual('the string property', lRec.StringProperty);\n  Assert.AreEqual(1234, lRec.IntegerProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5), lRec.DateProperty);\n  Assert.AreEqual(EncodeTime(12,13,14,0), lRec.TimeProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5) + EncodeTime(12,13,14,0), lRec.DateTimeProperty, 0.000001);\n  Assert.AreEqual(True, lRec.BooleanProperty);\n  Assert.AreEqual(EnumItem2, lRec.EnumProperty);\n  Assert.IsTrue([EnumItem1, EnumItem3] * lRec.SetProperty = [EnumItem1, EnumItem3]);\n  Assert.IsTrue(lRec.SetProperty - [EnumItem1, EnumItem3] = []);\n\n  //2nd level fields\n  Assert.AreEqual('the string property', lRec.SimpleRecord.StringProperty);\n  Assert.AreEqual(1234, lRec.SimpleRecord.IntegerProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5), lRec.SimpleRecord.DateProperty);\n  Assert.AreEqual(EncodeTime(12,13,14,0), lRec.SimpleRecord.TimeProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5) + EncodeTime(12,13,14,0), lRec.SimpleRecord.DateTimeProperty, 0.000001);\n  Assert.AreEqual(True, lRec.SimpleRecord.BooleanProperty);\n  Assert.AreEqual(EnumItem2, lRec.SimpleRecord.EnumProperty);\n  Assert.IsTrue([EnumItem1, EnumItem3] * lRec.SimpleRecord.SetProperty = [EnumItem1, EnumItem3]);\n  Assert.IsTrue(lRec.SimpleRecord.SetProperty - [EnumItem1, EnumItem3] = []);\n\n  //Dynamic Array Records\n  Assert.AreEqual<Integer>(2, Length(lRec.SimpleRecordDynArray), 'Wrong size for dynamic array');\n  Assert.AreEqual('1', lRec.SimpleRecordDynArray[0].StringProperty);\n  Assert.AreEqual('2', lRec.SimpleRecordDynArray[1].StringProperty);\n\n  //Static Array Records\n  Assert.AreEqual(3, Length(lRec.SimpleRecordStaticArray), 'Wrong size for static array');\n  Assert.AreEqual('3', lRec.SimpleRecordStaticArray[0].StringProperty);\n  Assert.AreEqual('4', lRec.SimpleRecordStaticArray[1].StringProperty);\n  Assert.AreEqual('5', lRec.SimpleRecordStaticArray[2].StringProperty);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_NoParams_SingleRecordAsResult;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\n  lSimpleRec: TSimpleRecord;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'GetSingleRecord';\n  lReq.RequestID := 1234;\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  lSimpleRec := TJSONUtils.JsonObjectToRecord<TSimpleRecord>(lRPCResp);\n  Assert.AreEqual('the string property', lSimpleRec.StringProperty);\n  Assert.AreEqual(1234, lSimpleRec.IntegerProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5), lSimpleRec.DateProperty);\n  Assert.AreEqual(EncodeTime(12,13,14,0), lSimpleRec.TimeProperty);\n  Assert.AreEqual(EncodeDate(2022,7,5) + EncodeTime(12,13,14,0), lSimpleRec.DateTimeProperty, 0.000001);\n  Assert.AreEqual(True, lSimpleRec.BooleanProperty);\n  Assert.AreEqual(EnumItem2, lSimpleRec.EnumProperty);\n  Assert.IsTrue([EnumItem1, EnumItem3] * lSimpleRec.SetProperty = [EnumItem1, EnumItem3]);\n  Assert.IsTrue(lSimpleRec.SetProperty - [EnumItem1, EnumItem3] = []);\nend;\n\nprocedure TJSONRPCServerTest.TestRequest_S_I_ret_S;\nvar\n  lReq: IJSONRPCRequest;\n  lRPCResp: IJSONRPCResponse;\nbegin\n  lReq := TJSONRPCRequest.Create;\n  lReq.Method := 'MultiplyString';\n  lReq.Params.Add('Daniele');\n  lReq.Params.Add(4);\n  lReq.RequestID := 1234;\n  lRPCResp := FExecutor.ExecuteRequest(lReq);\n  Assert.areEqual('DanieleDanieleDanieleDaniele', lRPCResp.Result.AsString);\n\n  lRPCResp := FExecutor2.ExecuteRequest(lReq);\n  Assert.areEqual('DanieleDanieleDanieleDaniele', lRPCResp.Result.AsString);\nend;\n\nprocedure TJSONRPCServerTest.TestSet;\nbegin\n  var lRequest1: IJSONRPCRequest := TJSONRPCRequest.Create(1234, 'ProcessSets');\n  lRequest1.Params.Add('etValue1,etValue2');\n  lRequest1.Params.Add('etValue3');\n  var lResp := FExecutor2.ExecuteRequest(lRequest1);\n  var l := lResp.AsJSONString;\n  Assert.AreEqual('etValue1,etValue2,etValue3', lResp.Result.AsString);\nend;\n\n{ TJSONRPCServerWithGETTest }\n\nprocedure TJSONRPCServerWithGETTest.InitExecutors;\nbegin\n  FExecutor := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS + ':8888/jsonrpcwithget',\n    false, jrpcGet);\n  FExecutor2 := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS +\n    ':8888/jsonrpcclasswithget', false, jrpcGet);\n  FExecutor3 := TMVCJSONRPCExecutor.Create('http://' + TEST_SERVER_ADDRESS +\n    ':8888/jsonrpcclass1withget', false, jrpcGet);\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TServerTest);\nTDUnitX.RegisterTestFixture(TJSONRPCServerTest);\nTDUnitX.RegisterTestFixture(TJSONRPCServerWithGETTest);\n\nend.", "output": "using System;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing NUnit.Framework;\nusing Newtonsoft.Json.Linq; \n\nnamespace LiveServerTests\n{\n    public interface IRestClient\n    {\n        \n        IRestClient BaseUrl(string host, int port);\n        IRestClient Accept(string mediaType);\n        IRestClient AddHeader(string name, string value);\n        IRestClient AddPathParam(string name, object value);\n        IRestClient AddQueryStringParam(string name, object value);\n        IRestClient AddCookie(string name, string value);\n        Task<IRestResponse> GetAsync(string url);\n        Task<IRestResponse> PostAsync(string url, string body, string contentType = null);\n        Task<IRestResponse> PutAsync(string url, string body, string contentType = null);\n        Task<IRestResponse> DeleteAsync(string url);\n        IRestClient ClearHeaders();\n        \n    }\n\n    public interface IRestResponse\n    {\n        int StatusCode { get; }\n        string StatusText { get; }\n        string Content { get; }\n        string ContentType { get; }\n        long ContentLength { get; }\n        string GetHeaderValue(string name);\n        \n        JObject ToJObject();\n        JArray ToJArray();\n    }\n\n    public abstract class BaseServerTest\n    {\n        protected IRestClient RestClient;\n        protected const string TEST_SERVER_ADDRESS = \"127.0.0.1\";\n\n        [SetUp]\n        public virtual void Setup()\n        {\n            \n            RestClient = RestClientFactory.Create()\n                          .BaseUrl(TEST_SERVER_ADDRESS, 8888);\n            \n        }\n\n        [TearDown]\n        public virtual void TearDown()\n        {\n            RestClient = null;\n        }\n\n        protected async Task DoLoginWithAsync(string userName)\n        {\n            \n            var response = await RestClient.AddPathParam(\"username\", userName)\n                                           .GetAsync(\"/login/{username}\");\n            Assert.That(response.StatusCode, Is.EqualTo(200), \"Login Failed: \" + response.Content);\n        }\n\n        protected async Task DoLogoutAsync()\n        {\n            var response = await RestClient.GetAsync(\"/logout\");\n            Assert.That(response.StatusCode, Is.EqualTo(200), \"Logout Failed: \" + response.Content);\n        }\n    }\n\n    [TestFixture]\n    public class ServerTest : BaseServerTest\n    {\n        \n        [Test]\n        [TestCase(\"/exception/fault\")]\n        [TestCase(\"/exception/fault2\")]\n        public async Task TestControllerWithExceptionInCreate(string urlSegment)\n        {\n            \n            var response = await RestClient.Accept(\"application/json\")\n                                           .GetAsync(urlSegment);\n            Assert.That(response.StatusCode, Is.EqualTo(500));\n            Assert.That(response.ContentType, Does.Contain(\"application/json\"));\n            Assert.That(response.Content, Does.Contain(\"Cannot create controller\"));\n        }\n\n        [Test]\n        [TestCase(\"/\")]\n        [TestCase(\"/action1\")]\n        [TestCase(\"/action2\")]\n        [TestCase(\"/api/v1\")]\n        [TestCase(\"/api/v1/action1\")]\n        [TestCase(\"/api/v1/action2\")]\n        [TestCase(\"/api/v2\")]\n        [TestCase(\"/api/v2/action1\")]\n        [TestCase(\"/api/v2/action2\")]\n        public async Task TestMultiMVCPathOnControllerAndAction(string urlSegment)\n        {\n            var response = await RestClient.GetAsync(urlSegment);\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n        }\n\n        [Test]\n        public async Task TestReqWithParams()\n        {\n            \n            var response = await RestClient.GetAsync(\"/unknownurl/bla/bla\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.GetAsync(\"/req/with/params/\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.GetAsync(\"/req/with/params\");\n            Assert.That(response.StatusCode, Is.EqualTo(404));\n\n            response = await RestClient.AddPathParam(\"par1\", \"1\")\n                                       .AddPathParam(\"par2\", \"2\")\n                                       .AddPathParam(\"par3\", \"3\")\n                                       .GetAsync(\"/req/with/params/($par1)/($par2)/($par3)\");\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n\n            \n            JObject json = response.ToJObject();\n            Assert.That(json.Value<string>(\"par1\"), Is.EqualTo(\"1\"));\n            Assert.That(json.Value<string>(\"par2\"), Is.EqualTo(\"2\"));\n            Assert.That(json.Value<string>(\"par3\"), Is.EqualTo(\"3\"));\n            Assert.That(json.Value<string>(\"method\"), Is.EqualTo(\"GET\"));\n\n            \n            response = await RestClient.AddPathParam(\"par1\", \"1\")\n                                       .AddPathParam(\"par2\", \"2\")\n                                       .AddPathParam(\"par3\", \"3\")\n                                       .DeleteAsync(\"/req/with/params/($par1)/($par2)/($par3)\");\n            Assert.That(response.StatusCode, Is.EqualTo(200));\n            json = response.ToJObject();\n            Assert.That(json.Value<string>(\"par1\"), Is.EqualTo(\"1\"));\n            Assert.That(json.Value<string>(\"par2\"), Is.EqualTo(\"2\"));\n            Assert.That(json.Value<string>(\"par3\"), Is.EqualTo(\"3\"));\n            Assert.That(json.Value<string>(\"method\"), Is.EqualTo(\"DELETE\"));\n        }\n\n        \n        [Test]\n        public async Task TestPOSTWithParamsAndJSONBody()\n        {\n            JObject jsonBody = new JObject\n            {\n                [\"client\"] = \"clientdata\"\n            };\n            var response = await RestClient.AddPathParam(\"par1\", 1)\n                                           .AddPathParam(\"par2\", 2)\n                                           .AddPathParam(\"par3\", 3)\n                                           .PostAsync(\"/echo/($par1)/($par2)/($par3)\",\n                                                      jsonBody.ToString());\n            JObject jsonResponse = JObject.Parse(response.Content);\n            Assert.That(jsonResponse.Value<string>(\"client\"), Is.EqualTo(\"clientdata\"));\n            Assert.That(jsonResponse.Value<string>(\"echo\"), Is.EqualTo(\"from server\"));\n        }\n\n        \n    }\n\n    [TestFixture]\n    [Category(\"jsonrpc\")]\n    public class JSONRPCServerTest\n    {\n        \n        private IJSONRPCExecutor _executor;\n        private IJSONRPCExecutor _executor2;\n        private IJSONRPCExecutor _executor3;\n\n        [SetUp]\n        public void Setup()\n        {\n            \n            _executor = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpc\", false);\n            _executor2 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass\", false);\n            _executor3 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass1\", false);\n\n            \n            _executor.SetOnSendCommand((jsonRequest) => Console.WriteLine(\"[JSONRPC REQUEST] : \" + jsonRequest));\n            _executor.SetOnReceiveHTTPResponse((httpResponse) => Console.WriteLine(\"[JSONRPC RESPONSE]: \" + httpResponse.Content));\n        }\n\n        [Test]\n        public void TestRequestWithoutParams()\n        {\n            var request = new JSONRPCRequest(1234, \"MyRequest\");\n            var response = _executor.ExecuteRequest(request);\n            Assert.IsFalse(response.IsError);\n            Assert.IsTrue(response.Result.AsBoolean);\n        }\n\n        \n    }\n\n    [TestFixture]\n    [Category(\"jsonrpc\")]\n    public class JSONRPCServerWithGETTest : JSONRPCServerTest\n    {\n        [SetUp]\n        public new void Setup()\n        {\n            \n            _executor = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcwithget\", false, JSONRPCMethodType.Get);\n            _executor2 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclasswithget\", false, JSONRPCMethodType.Get);\n            _executor3 = JSONRPCExecutorFactory.Create(\"http://\" + BaseServerTest.TEST_SERVER_ADDRESS + \":8888/jsonrpcclass1withget\", false, JSONRPCMethodType.Get);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Patches;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes\n{$IFDEF SYSTEMJSON}\n    , System.JSON\n{$ENDIF}\n{$IFNDEF SYSTEMJSON} // XE6\n    , Data.DBXJSON\n{$ENDIF}\n    ;\n\n{$IFNDEF TOJSON}\n\n\ntype\n  TJSONValueHelper = class helper for TJSONValue\n  public\n    function GetItem(const Index: Integer): TJSONValue;\n    function ToJSON: String;\n    function Count: Integer;\n    property Items[const Index: Integer]: TJSONValue read GetItem;\n  end;\n{$ENDIF}\n\nimplementation\n\n{ TJSONValueHelper }\n\n{$IFNDEF TOJSON}\n\n\nfunction TJSONValueHelper.Count: Integer;\nbegin\n  Result := Size;\nend;\n\nfunction TJSONValueHelper.GetItem(const Index: Integer): TJSONValue;\nbegin\n  Result := Get(Index);\nend;\n\nfunction TJSONValueHelper.ToJSON: String;\nbegin\n  Result := Self.ToString;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.Patches\n{\n    \n    public static class JsonValueExtensions\n    {\n        \n        public static JToken GetItem(this JToken token, int index)\n        {\n            if (token is JArray array)\n            {\n                return array[index];\n            }\n            throw new InvalidOperationException(\"JToken is not an array; cannot use indexer.\");\n        }\n\n        \n        public static string ToJSON(this JToken token)\n        {\n            \n            return token.ToString();\n        }\n\n        \n        public static int Count(this JToken token)\n        {\n            if (token is JArray array)\n            {\n                return array.Count;\n            }\n            if (token is JObject obj)\n            {\n                return obj.Count;\n            }\n            throw new InvalidOperationException(\"JToken does not have a count (not an array or object).\");\n        }\n    }\n}"}
{"input": "unit WinesBO;\n\n{ ** Note: In case of Delphi clients you can share the units containing the business objects\n  between client and server. This is not required, and could lead to difficult\n  dependencies schemas in buig project. In this demo this file is shared between\n  clients and server. }\n\ninterface\n\nuses System.Generics.Collections, MVCFramework.Serializer.Commons;\n\ntype\n\n  [MVCNameCase(ncLowerCase)]\n  TWine = class\n  private\n    FYEAR: string;\n    FNAME: string;\n    FPICTURE: string;\n    FGRAPES: string;\n    FID: integer;\n    FDESCRIPTION: string;\n    FCOUNTRY: string;\n    FREGION: string;\n    procedure SetCOUNTRY(const Value: string);\n    procedure SetDESCRIPTION(const Value: string);\n    procedure SetGRAPES(const Value: string);\n    procedure SetID(const Value: integer);\n    procedure SetNAME(const Value: string);\n    procedure SetPICTURE(const Value: string);\n    procedure SetREGION(const Value: string);\n    procedure SetYEAR(const Value: string);\n\n  public\n    property id: integer read FID write SetID;\n    property name: string read FNAME write SetNAME;\n    property year: string read FYEAR write SetYEAR;\n    property grapes: string read FGRAPES write SetGRAPES;\n    property country: string read FCOUNTRY write SetCOUNTRY;\n    property region: string read FREGION write SetREGION;\n    property description: string read FDESCRIPTION write SetDESCRIPTION;\n    property picture: string read FPICTURE write SetPICTURE;\n  end;\n\n  TWines = class(TObjectList<TWine>)\n    constructor Create;\n  end;\n\nimplementation\n\n{ TWine }\n\nprocedure TWine.SetCOUNTRY(const Value: string);\nbegin\n  FCOUNTRY := Value;\nend;\n\nprocedure TWine.SetDESCRIPTION(const Value: string);\nbegin\n  FDESCRIPTION := Value;\nend;\n\nprocedure TWine.SetGRAPES(const Value: string);\nbegin\n  FGRAPES := Value;\nend;\n\nprocedure TWine.SetID(const Value: integer);\nbegin\n  FID := Value;\nend;\n\nprocedure TWine.SetNAME(const Value: string);\nbegin\n  FNAME := Value;\nend;\n\nprocedure TWine.SetPICTURE(const Value: string);\nbegin\n  FPICTURE := Value;\nend;\n\nprocedure TWine.SetREGION(const Value: string);\nbegin\n  FREGION := Value;\nend;\n\nprocedure TWine.SetYEAR(const Value: string);\nbegin\n  FYEAR := Value;\nend;\n\n{ TWines }\n\nconstructor TWines.Create;\nbegin\n  inherited Create(True);\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing MVCFramework.Serializer.Commons;\n\nnamespace WinesBO\n{\n    [MVCNameCase(\"ncLowerCase\")]\n    public class Wine\n    {\n        private string _year;\n        private string _name;\n        private string _picture;\n        private string _grapes;\n        private int _id;\n        private string _description;\n        private string _country;\n        private string _region;\n\n        public int Id { get => _id; set => _id = value; }\n        public string Name { get => _name; set => _name = value; }\n        public string Year { get => _year; set => _year = value; }\n        public string Grapes { get => _grapes; set => _grapes = value; }\n        public string Country { get => _country; set => _country = value; }\n        public string Region { get => _region; set => _region = value; }\n        public string Description { get => _description; set => _description = value; }\n        public string Picture { get => _picture; set => _picture = value; }\n    }\n\n    public class Wines : List<Wine>\n    {\n        public Wines() : base() { }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.FileAppender;\n\n{$IF Defined(Android) or Defined(iOS)}\n{$DEFINE MOBILE}\n{$ENDIF}\n\ninterface\n\nuses\n  LoggerPro,\n  System.Generics.Collections,\n  System.Classes,\n  System.SysUtils;\n\ntype\n  {\n    @abstract(Logs to file using one different file for each different TAG used.)\n    @author(Daniele Teti - d.teti@bittime.it)\n    Implements log rotations.\n    This appender is the default appender when no configuration is done on the @link(TLogger) class.\n\n    Without any configuration LoggerPro uses the @link(TLoggerProFileAppender) with the default configuration.\n\n    So the following two blocks of code are equivalent:\n\n    @longcode(#\n    ...\n    TLogger.Initialize; //=> uses the TLoggerProFileAppender because no other configuration is provided\n    ...\n\n    ...\n    TLogger.AddAppender(TLoggerProFileAppender.Create);\n    TLogger.Initialize //=> uses the TLoggerProFileAppender as configured\n    ...\n    #)\n\n  }\n\n  { @abstract(The base class for different file appenders)\n    Do not use this class directly, but one of TLoggerProFileAppender or TLoggerProSimpleFileAppender.\n    Check the sample @code(file_appender.dproj)\n  }\n  TLoggerProFileAppenderBase = class(TLoggerProAppenderBase)\n  private\n    procedure RetryMove(const aFileSrc, aFileDest: string);\n    procedure RetryDelete(const aFileSrc: string);\n  protected\n    fEncoding: TEncoding;\n    fMaxBackupFileCount: Integer;\n    fMaxFileSizeInKiloByte: Integer;\n    fLogFileNameFormat: string;\n    fLogsFolder: string;\n    function CreateWriter(const aFileName: string; const aBufferSize: Integer = 32): TStreamWriter;\n    procedure CheckLogFileNameFormat(const LogFileNameFormat: String); virtual;\n    procedure EmitStartRotateLogItem(aWriter: TStreamWriter); virtual;\n    procedure EmitEndRotateLogItem(aWriter: TStreamWriter); virtual;\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; virtual;\n    procedure WriteToStream(const aStreamWriter: TStreamWriter; const aValue: string); inline;\n    procedure RotateFile(const aLogTag: string; out aNewFileName: string); virtual;\n    procedure InternalWriteLog(const aStreamWriter: TStreamWriter; const aLogItem: TLogItem);\n  public const\n    { @abstract(Defines the default format string used by the @link(TLoggerProFileAppender).)\n      The positional parameters are the following:\n      @orderedList(\n      @item Number\n      @item Module\n      @item Tag\n      )\n    }\n    DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n    DEFAULT_FILENAME_FORMAT_WITH_PID = '{module}.{number}.{pid}.{tag}.log';\n    DEFAULT_FILENAME_FORMAT_WITHOUT_TAG = '{module}.{number}.log';\n    { @abstract(Defines number of log file set to maintain during logs rotation) }\n    DEFAULT_MAX_BACKUP_FILE_COUNT = 5;\n    { @abstract(Defines the max size of each log file)\n      The actual meaning is: \"If the file size is > than @link(DEFAULT_MAX_FILE_SIZE_KB) then rotate logs. }\n    DEFAULT_MAX_FILE_SIZE_KB = 1000;\n    { @abstract(Milliseconds to wait between the RETRY_COUNT times. }\n    RETRY_DELAY = 200;\n    { @abstract(How many times do we have to retry if the file is locked?. }\n    RETRY_COUNT = 5;\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT;\n      aLogItemRenderer: ILogItemRenderer = nil;\n      aEncoding: TEncoding = nil);\n      reintroduce; virtual;\n    procedure Setup; override;\n  end;\n\n  { @abstract(The default file appender)\n    This file appender separates TLogItems with different tags into a log file for each tag.\n    To learn how to use this appender, check the sample @code(file_appender.dproj)\n  }\n  TLoggerProFileAppender = class(TLoggerProFileAppenderBase)\n  private\n    fWritersDictionary: TObjectDictionary<string, TStreamWriter>;\n    procedure AddWriter(const aLogTag: string; var aWriter: TStreamWriter; var aLogFileName: string);\n    procedure RotateLog(const aLogTag: string; aWriter: TStreamWriter);\n  public\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); overload; override;\n  end;\n\n  { @abstract(File appender with multiple tags)\n    This file appender writes all TLogItems into a single log file.\n    Combined with a @code(TLoggerProAppenderFilterImpl) you can filter out any log tags you like.\n    If you want to run several TLoggerProSimpleFileAppender in parallel you have to provide a different\n    LogFileFormat for each of them in the constructor in order to prevent name collisions.\n    To learn how to use this appender, check the sample @code(file_appender.dproj)\n  }\n  TLoggerProSimpleFileAppender = class(TLoggerProFileAppenderBase)\n  private\n    fFileWriter: TStreamWriter;\n    procedure RotateLog;\n  protected\n    procedure CheckLogFileNameFormat(const LogFileNameFormat: String); override;\n  public\n  const\n    DEFAULT_FILENAME_FORMAT = '{module}.{number}.log';\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); overload; override;\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT;\n      aLogItemRenderer: ILogItemRenderer = nil;\n      aEncoding: TEncoding = nil);\n      override;\n  end;\n\n\n  TMakeFileNameProc = reference to procedure(out AFileName: string);\n\n  { by an idea of Mark Lobanov <mark.v.lobanov@gmail.com> }\n  TLoggerProFileByFolderAppender = class(TLoggerProFileAppender)\n  private\n    fFileWriter: TStreamWriter;\n    fCurrentDate: TDateTime;\n    function GetLogFolder: string;\n    function GetFileFormat: string;\n    procedure RotateLog;\n    procedure ChangeLogFolder;\n    procedure RefreshCurrentDate;\n    procedure InternalRotateLog(aMakeFileNameProc: TMakeFileNameProc);\n  protected\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; override;\n    procedure CheckLogFileNameFormat(const aLogFileNameFormat: string); override;\n  public\n    constructor Create(\n      aMaxBackupFileCount: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppenderBase.DEFAULT_MAX_FILE_SIZE_KB;\n      const aLogsFolder: string = '';\n      const aLogItemRenderer: ILogItemRenderer = nil;\n      const aEncoding: TEncoding = nil); reintroduce;\n\n    procedure WriteLog(const ALogItem: TLogItem); override;\n    procedure Setup; override;\n    procedure TearDown; override;\n  end;\n\n  TLoggerProLogFmtFileAppender = class(TLoggerProSimpleFileAppender)\n  protected\n    function GetLogFileName(const aTag: string; const aFileNumber: Integer): string; override;\n    procedure EmitStartRotateLogItem(aWriter: TStreamWriter); override;\n    procedure EmitEndRotateLogItem(aWriter: TStreamWriter); override;\n  public\n    constructor Create(aMaxBackupFileCount: Integer = TLoggerProFileAppender.DEFAULT_MAX_BACKUP_FILE_COUNT;\n      aMaxFileSizeInKiloByte: Integer = TLoggerProFileAppender.DEFAULT_MAX_FILE_SIZE_KB; aLogsFolder: string = '';\n      aLogFileNameFormat: string = TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT; aEncoding: TEncoding = nil);\n      reintroduce;\n  end;\n\nimplementation\n\nuses\n  System.IOUtils,\n  System.StrUtils,\n  System.Math,\n  System.DateUtils,\n  LoggerPro.Renderers,\n  idGlobal\n{$IF Defined(Android)}\n    ,Androidapi.Helpers\n    ,Androidapi.JNI.GraphicsContentViewText\n    ,Androidapi.JNI.JavaTypes\n{$ENDIF}\n    ;\n\n\nfunction OccurrencesOfChar(const S: string; const C: char): integer;\nvar\n  i: Integer;\nbegin\n  result := 0;\n  for i := 1 to Length(S) do\n    if S[i] = C then\n      inc(result);\nend;\n\nprocedure TLoggerProFileAppenderBase.CheckLogFileNameFormat(const LogFileNameFormat: String);\nbegin\n  //DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n  if not (LogFileNameFormat.Contains('{number}') and LogFileNameFormat.Contains('{tag}')) then\n  begin\n    raise ELoggerPro.CreateFmt('Wrong FileFormat [%s] - [HINT] A correct file format for %s requires {number} and {tag} placeholders ({module} is optional). A valid file format is : %s',\n      [\n        ClassName,\n        LogFileNameFormat,\n        TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT\n      ]);\n  end;\nend;\n\n\n{ TLoggerProFileAppenderBase }\n\nfunction TLoggerProFileAppenderBase.GetLogFileName(const aTag: string; const aFileNumber: Integer): string;\nvar\n  lModuleName: string;\n  lPath: string;\n  lFormat: string;\nbegin\n{$IF Defined(Android)}\n  lModuleName := TAndroidHelper.ApplicationTitle.Replace(' ', '_', [rfReplaceAll]);\n{$ENDIF}\n{$IF not Defined(Mobile)}\n  lModuleName := TPath.GetFileNameWithoutExtension(GetModuleName(HInstance));\n{$ENDIF}\n{$IF Defined(IOS)}\n  raise Exception.Create('Platform not supported');\n{$ENDIF}\n  lFormat := fLogFileNameFormat;\n\n  lPath := fLogsFolder;\n  lFormat := lFormat\n    .Replace('{module}', lModuleName, [rfReplaceAll])\n    .Replace('{number}', aFileNumber.ToString.PadLeft(\n      Max(2,fMaxBackupFileCount.ToString.Length), //min padding 2\n      '0') , [rfReplaceAll])\n    .Replace('{tag}', aTag, [rfReplaceAll])\n    .Replace('{pid}', CurrentProcessId.ToString.PadLeft(8,'0'), [rfReplaceAll]);\n  Result := TPath.Combine(lPath, lFormat);\nend;\n\nprocedure TLoggerProFileAppenderBase.Setup;\nbegin\n  inherited;\n\n  if fLogsFolder = '' then\n  begin\n{$IF (Defined(MSWINDOWS) or Defined(POSIX)) and (not Defined(MOBILE))}\n    fLogsFolder := TPath.GetDirectoryName(GetModuleName(HInstance));\n{$ENDIF}\n{$IF Defined(Android) or Defined(IOS)}\n    fLogsFolder := TPath.GetSharedDocumentsPath();\n{$ENDIF}\n  end;\n  if not TDirectory.Exists(fLogsFolder) then\n    TDirectory.CreateDirectory(fLogsFolder);\nend;\n\nprocedure TLoggerProFileAppenderBase.WriteToStream(const aStreamWriter: TStreamWriter; const aValue: string);\nbegin\n  aStreamWriter.WriteLine(aValue);\n  aStreamWriter.Flush;\nend;\n\nprocedure TLoggerProFileAppenderBase.InternalWriteLog(const aStreamWriter: TStreamWriter; const aLogItem: TLogItem);\nbegin\n  WriteToStream(aStreamWriter, FormatLog(aLogItem));\nend;\n\nprocedure TLoggerProFileAppenderBase.RetryDelete(const aFileSrc: string);\nvar\n  lRetries: Integer;\nconst\n  MAX_RETRIES = 5;\nbegin\n  lRetries := 0;\n  repeat\n    try\n      Sleep(50);\n      // the incidence of \"Locked file goes to nearly zero...\"\n      TFile.Delete(aFileSrc);\n      if not TFile.Exists(aFileSrc) then\n      begin\n        Break;\n      end;\n    except\n      on E: Exception do\n      begin\n        Inc(lRetries);\n        Sleep(100);\n      end;\n    end;\n  until lRetries = MAX_RETRIES;\n\n  if lRetries = MAX_RETRIES then\n    raise ELoggerPro.CreateFmt('Cannot delete file %s', [aFileSrc]);\nend;\n\nprocedure TLoggerProFileAppenderBase.RetryMove(const aFileSrc, aFileDest: string);\nvar\n  lRetries: Integer;\nconst\n  MAX_RETRIES = 5;\nbegin\n  lRetries := 0;\n  repeat\n    try\n      Sleep(50);\n      // the incidence of \"Locked file goes to nearly zero...\"\n      TFile.Move(aFileSrc, aFileDest);\n      Break;\n    except\n      on E: EInOutError do\n      begin\n        Inc(lRetries);\n        Sleep(100);\n      end;\n      on E: Exception do\n      begin\n        raise;\n      end;\n    end;\n  until lRetries = MAX_RETRIES;\n\n  if lRetries = MAX_RETRIES then\n    raise ELoggerPro.CreateFmt('Cannot rename %s to %s', [aFileSrc, aFileDest]);\nend;\n\nprocedure TLoggerProFileAppenderBase.RotateFile(const aLogTag: string; out aNewFileName: string);\nvar\n  lRenamedFile: string;\n  I: Integer;\n  lCurrentFileName: string;\nbegin\n  aNewFileName := GetLogFileName(aLogTag, 0);\n  // remove the last file of backup set\n  lRenamedFile := GetLogFileName(aLogTag, fMaxBackupFileCount - 1);\n  if TFile.Exists(lRenamedFile) then\n  begin\n    TFile.Delete(lRenamedFile);\n    if TFile.Exists(lRenamedFile) then // double check for slow file systems\n    begin\n      RetryDelete(lRenamedFile);\n    end;\n  end;\n  // shift the files names\n  for I := fMaxBackupFileCount - 1 downto 1 do\n  begin\n    lCurrentFileName := GetLogFileName(aLogTag, I);\n    lRenamedFile := GetLogFileName(aLogTag, I + 1);\n    if TFile.Exists(lCurrentFileName) then\n    begin\n      RetryMove(lCurrentFileName, lRenamedFile);\n    end;\n  end;\n  lRenamedFile := GetLogFileName(aLogTag, 1);\n  RetryMove(aNewFileName, lRenamedFile);\nend;\n\nconstructor TLoggerProFileAppenderBase.Create(\n  aMaxBackupFileCount: Integer;\n  aMaxFileSizeInKiloByte: Integer;\n  aLogsFolder: string;\n  aLogFileNameFormat: string;\n  aLogItemRenderer: ILogItemRenderer;\n  aEncoding: TEncoding);\nbegin\n  inherited Create(aLogItemRenderer);\n  fLogsFolder := aLogsFolder;\n  fMaxBackupFileCount:= Max(1, aMaxBackupFileCount);\n  fMaxFileSizeInKiloByte := aMaxFileSizeInKiloByte;\n  CheckLogFileNameFormat(aLogFileNameFormat);\n  fLogFileNameFormat := aLogFileNameFormat;\n  if Assigned(aEncoding) then\n    fEncoding := aEncoding\n  else\n    fEncoding := TEncoding.DEFAULT;\nend;\n\nfunction TLoggerProFileAppenderBase.CreateWriter(const aFileName: string; const aBufferSize: Integer = 32): TStreamWriter;\nvar\n  lFileStream: TFileStream;\n  lFileAccessMode: Word;\n  lRetries: Integer;\nbegin\n  lFileAccessMode := fmOpenWrite or fmShareDenyNone;\n  if not TFile.Exists(aFileName) then\n    lFileAccessMode := lFileAccessMode or fmCreate;\n\n  // If the file si still blocked by a precedent execution or\n  // for some other reasons, we try to access the file for 5 times.\n  // If after 5 times (with a bit of delay in between) the file is still\n  // locked, then the exception is raised.\n  lRetries := 0;\n  while true do\n  begin\n    try\n      lFileStream := TFileStream.Create(aFileName, lFileAccessMode);\n      try\n        lFileStream.Seek(0, TSeekOrigin.soEnd);\n        Result := TStreamWriter.Create(lFileStream, fEncoding, aBufferSize);\n        Result.AutoFlush := true;\n        Result.OwnStream;\n        Break;\n      except\n        lFileStream.Free;\n        raise;\n      end;\n    except\n      if lRetries = RETRY_COUNT then\n      begin\n        raise;\n      end\n      else\n      begin\n        Inc(lRetries);\n        Sleep(RETRY_DELAY); // just wait a little bit\n      end;\n    end;\n  end;\nend;\n\n{ TLoggerProFileAppender }\n\nprocedure TLoggerProFileAppender.AddWriter(const aLogTag:string; var aWriter: TStreamWriter; var aLogFileName: string);\nbegin\n  aLogFileName := GetLogFileName(aLogTag, 0);\n  aWriter := CreateWriter(aLogFileName);\n  fWritersDictionary.Add(aLogTag, aWriter);\nend;\n\nprocedure TLoggerProFileAppenderBase.EmitEndRotateLogItem(aWriter: TStreamWriter);\nbegin\n  WriteToStream(aWriter, '#[ROTATE LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppenderBase.EmitStartRotateLogItem(aWriter: TStreamWriter);\nbegin\n  WriteToStream(aWriter, '#[START LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppender.RotateLog(const aLogTag: string; aWriter: TStreamWriter);\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(aWriter);\n  //WriteToStream(aWriter, '#[ROTATE LOG ' + datetimetostr(Now, FormatSettings) + ']');\n  // remove the writer during rename\n  fWritersDictionary.Remove(aLogTag);\n  RotateFile(aLogTag, lLogFileName);\n  // re-create the writer\n  AddWriter(aLogTag, aWriter, lLogFileName);\n  EmitStartRotateLogItem(aWriter);\n  //WriteToStream(aWriter, '#[START LOG ' + datetimetostr(Now, FormatSettings) + ']');\nend;\n\nprocedure TLoggerProFileAppender.Setup;\nbegin\n  inherited;\n  fWritersDictionary := TObjectDictionary<string, TStreamWriter>.Create([doOwnsValues]);\nend;\n\nprocedure TLoggerProFileAppender.TearDown;\nbegin\n  fWritersDictionary.Free;\n  inherited;\nend;\n\nprocedure TLoggerProFileAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lWriter: TStreamWriter;\n  lLogFileName:string;\nbegin\n  if not fWritersDictionary.TryGetValue(aLogItem.LogTag, lWriter) then\n  begin\n    AddWriter(aLogItem.LogTag, lWriter, lLogFileName);\n  end;\n\n  InternalWriteLog(lWriter, aLogItem);\n\n  if lWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog(aLogItem.LogTag, lWriter);\n  end;\nend;\n\n{ TLoggerProSimpleFileAppender }\n\nprocedure TLoggerProSimpleFileAppender.CheckLogFileNameFormat(const LogFileNameFormat: String);\nbegin\n  //DEFAULT_FILENAME_FORMAT = '{module}.{number}.{tag}.log';\n  if not LogFileNameFormat.Contains('{number}') then\n  begin\n    raise ELoggerPro.CreateFmt('Wrong FileFormat [%s] - [HINT] A correct file format for %s requires {number} placeholder ({module} is optional). A valid file format is : %s',\n      [\n        ClassName,\n        LogFileNameFormat,\n        TLoggerProSimpleFileAppender.DEFAULT_FILENAME_FORMAT\n      ]);\n  end;\nend;\n\nconstructor TLoggerProSimpleFileAppender.Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer;\n  aLogsFolder: string; aLogFileNameFormat: String;\n  aLogItemRenderer: ILogItemRenderer;\n  aEncoding: TEncoding);\nbegin\n  inherited Create(\n    aMaxBackupFileCount,\n    aMaxFileSizeInKiloByte,\n    aLogsFolder,\n    aLogFileNameFormat,\n    aLogItemRenderer,\n    aEncoding);\nend;\n\nprocedure TLoggerProSimpleFileAppender.RotateLog;\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(fFileWriter);\n  // remove the writer during rename\n  fFileWriter.Free;\n  RotateFile('', lLogFileName);\n  // re-create the writer\n  fFileWriter := CreateWriter(GetLogFileName('', 0));\n  EmitStartRotateLogItem(fFileWriter);\nend;\n\nprocedure TLoggerProSimpleFileAppender.Setup;\nbegin\n  inherited;\n  fFileWriter := CreateWriter(GetLogFileName('', 0));\nend;\n\nprocedure TLoggerProSimpleFileAppender.TearDown;\nbegin\n  fFileWriter.Free;\n  inherited;\nend;\n\nprocedure TLoggerProSimpleFileAppender.WriteLog(const aLogItem: TLogItem);\nbegin\n  InternalWriteLog(fFileWriter, aLogItem);\n  if fFileWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog;\n  end;\nend;\n\n{ TLoggerProFileByFolderAppender }\n\nconstructor TLoggerProFileByFolderAppender.Create(\n  aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer;\n  const aLogsFolder: string;\n  const aLogItemRenderer: ILogItemRenderer;\n  const aEncoding: TEncoding);\nvar\n  lEncoding: TEncoding;\nbegin\n  if AEncoding = nil then\n    LEncoding := TEncoding.UTF8\n  else\n    LEncoding := AEncoding;\n\n  inherited Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte,\n    aLogsFolder, GetFileFormat, aLogItemRenderer, LEncoding);\n  RefreshCurrentDate;\nend;\n\nprocedure TLoggerProFileByFolderAppender.CheckLogFileNameFormat(const ALogFileNameFormat: string);\nbegin\n  //do nothing, user cannot change filename format in this appender\nend;\n\nfunction TLoggerProFileByFolderAppender.GetLogFolder: string;\nconst\n  LOG_DIR = 'Logs';\nbegin\n  if fLogsFolder.IsEmpty then\n    fLogsFolder := TPath.Combine(TPath.GetDirectoryName({ParamStr(0)} GetModuleName(HInstance)), LOG_DIR)\n  else\n  if not EndsText(LOG_DIR, fLogsFolder) then\n    fLogsFolder := TPath.Combine(FLogsFolder, LOG_DIR);\n  if not TDirectory.Exists(fLogsFolder) then\n    TDirectory.CreateDirectory(fLogsFolder);\n\n  Result := TPath.Combine(fLogsFolder, FormatDateTime('yyyymmdd', Now));\n  if not TDirectory.Exists(Result) then\n    TDirectory.CreateDirectory(Result);\nend;\n\n\nprocedure TLoggerProFileByFolderAppender.InternalRotateLog(aMakeFileNameProc: TMakeFileNameProc);\nvar\n  lLogFileName: string;\nbegin\n  EmitEndRotateLogItem(fFileWriter);\n  FreeAndNil(fFileWriter);\n  aMakeFileNameProc(lLogFileName);\n  fFileWriter := CreateWriter(lLogFileName, 16 * 1024);\n  EmitStartRotateLogItem(fFileWriter);\nend;\n\nprocedure TLoggerProFileByFolderAppender.ChangeLogFolder;\nbegin\n  InternalRotateLog(\n    procedure(out AFileName: string)\n    begin\n      AFileName := GetLogFileName(EmptyStr, 0);\n    end\n );\nend;\n\nprocedure TLoggerProFileByFolderAppender.RotateLog;\nbegin\n  InternalRotateLog(\n    procedure(out AFileName: string)\n    begin\n      RotateFile(EmptyStr, AFileName);\n    end\n );\nend;\n\nfunction TLoggerProFileByFolderAppender.GetFileFormat: string;\nbegin\n  Result := TLoggerProFileAppenderBase.DEFAULT_FILENAME_FORMAT_WITHOUT_TAG;\nend;\n\nfunction TLoggerProFileByFolderAppender.GetLogFileName(const ATag: string; const AFileNumber: Integer): string;\nvar\n  lOnlyFileName: String;\nbegin\n  lOnlyFileName := TPath.GetFileName(inherited);\n  Result := TPath.Combine(GetLogFolder, lOnlyFileName);\nend;\n\n\nprocedure TLoggerProFileByFolderAppender.RefreshCurrentDate;\nbegin\n  fCurrentDate := Date;\nend;\n\nprocedure TLoggerProFileByFolderAppender.Setup;\nbegin\n  inherited;\n  fFileWriter := CreateWriter(GetLogFileName(EmptyStr, 0));\n  RefreshCurrentDate;\nend;\n\nprocedure TLoggerProFileByFolderAppender.TearDown;\nbegin\n  fFileWriter.Free;\n  inherited;\nend;\n\nprocedure TLoggerProFileByFolderAppender.WriteLog(const ALogItem: TLogItem);\nvar\n  lLogRow: string;\nbegin\n  if not SameDate(fCurrentDate, Date) then\n  begin\n    ChangeLogFolder;\n    RefreshCurrentDate;\n  end;\n\n  if Assigned(OnLogRow) then\n  begin\n    OnLogRow(ALogItem, lLogRow);\n  end\n  else\n  begin\n    lLogRow := LogItemRenderer.RenderLogItem(ALogItem);\n  end;\n\n  WriteToStream(fFileWriter, lLogRow);\n\n  if fFileWriter.BaseStream.Size > fMaxFileSizeInKiloByte * 1024 then\n  begin\n    RotateLog;\n  end;\nend;\n\n{ TLoggerProLogFmtFileAppender }\n\nconstructor TLoggerProLogFmtFileAppender.Create(aMaxBackupFileCount, aMaxFileSizeInKiloByte: Integer; aLogsFolder,\n  aLogFileNameFormat: string; aEncoding: TEncoding);\nbegin\n  inherited Create(\n    aMaxBackupFileCount,\n    aMaxFileSizeInKiloByte,\n    aLogsFolder,\n    aLogFileNameFormat,\n    TLogItemRendererLogFmt.Create,\n    aEncoding);\nend;\n\nprocedure TLoggerProLogFmtFileAppender.EmitEndRotateLogItem(aWriter: TStreamWriter);\nbegin\n  // do nothing\nend;\n\nprocedure TLoggerProLogFmtFileAppender.EmitStartRotateLogItem(aWriter: TStreamWriter);\nbegin\n  // do nothing\nend;\n\nfunction TLoggerProLogFmtFileAppender.GetLogFileName(const aTag: string; const aFileNumber: Integer): string;\nvar\n  lOrigFName, lOrigExt: string;\nbegin\n  lOrigFName := inherited;\n  lOrigExt := TPath.GetExtension(lOrigFName);\n  if lOrigExt.IsEmpty then\n  begin\n    lOrigExt := '.log';\n  end;\n  Result := TPath.ChangeExtension(lOrigFName, '.logfmt' + lOrigExt);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace LoggerPro.Appenders\n{\n   #region Base Class\n\n   \n   public abstract class LoggerProFileAppenderBase : LoggerProAppenderBase, ILogAppender\n   {\n      \n      public const int DEFAULT_MAX_BACKUP_FILE_COUNT = 5;\n      public const int DEFAULT_MAX_FILE_SIZE_KB = 1000;\n      public const string DEFAULT_FILENAME_FORMAT = \"{module}.{number}.{tag}.log\";\n      public const string DEFAULT_FILENAME_FORMAT_WITH_PID = \"{module}.{number}.{pid}.{tag}.log\";\n      public const string DEFAULT_FILENAME_FORMAT_WITHOUT_TAG = \"{module}.{number}.log\";\n      protected const int RETRY_DELAY = 200;\n      protected const int RETRY_COUNT = 5;\n\n      \n      protected Encoding FileEncoding;\n      protected int MaxBackupFileCount;\n      protected int MaxFileSizeInKiloByte;\n      protected string LogFileNameFormat;\n      protected string LogsFolder;\n      \n      protected virtual void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         if (!logFileNameFormat.Contains(\"{number}\") || !logFileNameFormat.Contains(\"{tag}\"))\n         {\n            throw new LoggerProException(\n               string.Format(\"Wrong FileFormat [{0}] - [HINT] A correct file format for {1} requires {{number}} and {{tag}} placeholders. A valid file format is : {2}\",\n                  logFileNameFormat, this.GetType().Name, DEFAULT_FILENAME_FORMAT));\n         }\n      }\n\n      \n      protected virtual string GetLogFileName(string tag, int fileNumber)\n      {\n         \n         string moduleName = Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location);\n         string fileFormat = LogFileNameFormat\n            .Replace(\"{module}\", moduleName)\n            .Replace(\"{number}\", fileNumber.ToString(\"D\" + Math.Max(2, MaxBackupFileCount.ToString().Length)))\n            .Replace(\"{tag}\", tag)\n            .Replace(\"{pid}\", Environment.ProcessId.ToString(\"D8\"));\n         \n         return Path.Combine(LogsFolder, fileFormat);\n      }\n\n      \n      protected virtual StreamWriter CreateWriter(string fileName, int bufferSize = 32)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               \n               FileStream fs = new FileStream(fileName, FileMode.Append, FileAccess.Write, FileShare.Read);\n               StreamWriter sw = new StreamWriter(fs, FileEncoding, bufferSize)\n               {\n                  AutoFlush = true\n               };\n               return sw;\n            }\n            catch (IOException)\n            {\n               if (++retries >= RETRY_COUNT)\n                  throw;\n               System.Threading.Thread.Sleep(RETRY_DELAY);\n            }\n         }\n      }\n\n      \n      protected virtual void EmitStartRotateLogItem(StreamWriter writer)\n      {\n         WriteToStream(writer, \"#[START LOG \" + DateTime.Now.ToString(\"o\") + \"]\");\n      }\n\n      \n      protected virtual void EmitEndRotateLogItem(StreamWriter writer)\n      {\n         WriteToStream(writer, \"#[ROTATE LOG \" + DateTime.Now.ToString(\"o\") + \"]\");\n      }\n\n      \n      protected virtual void WriteToStream(StreamWriter writer, string value)\n      {\n         writer.WriteLine(value);\n         writer.Flush();\n      }\n\n      \n      protected virtual void RotateFile(string logTag, out string newFileName)\n      {\n         newFileName = GetLogFileName(logTag, 0);\n         \n         string oldest = GetLogFileName(logTag, MaxBackupFileCount - 1);\n         if (File.Exists(oldest))\n         {\n            TryDeleteFile(oldest);\n         }\n         \n         for (int i = MaxBackupFileCount - 1; i >= 1; i--)\n         {\n            string src = GetLogFileName(logTag, i);\n            string dst = GetLogFileName(logTag, i + 1);\n            if (File.Exists(src))\n            {\n               TryMoveFile(src, dst);\n            }\n         }\n         \n         string firstBackup = GetLogFileName(logTag, 1);\n         TryMoveFile(newFileName, firstBackup);\n      }\n\n      protected void TryDeleteFile(string fileSrc)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               File.Delete(fileSrc);\n               if (!File.Exists(fileSrc))\n                  break;\n            }\n            catch\n            {\n               if (++retries == RETRY_COUNT)\n                  throw new LoggerProException($\"Cannot delete file {fileSrc}\");\n               System.Threading.Thread.Sleep(100);\n            }\n         }\n      }\n\n      protected void TryMoveFile(string fileSrc, string fileDest)\n      {\n         int retries = 0;\n         while (true)\n         {\n            try\n            {\n               File.Move(fileSrc, fileDest);\n               break;\n            }\n            catch (IOException)\n            {\n               if (++retries == RETRY_COUNT)\n                  throw new LoggerProException($\"Cannot rename {fileSrc} to {fileDest}\");\n               System.Threading.Thread.Sleep(100);\n            }\n         }\n      }\n\n      \n      protected virtual void InternalWriteLog(StreamWriter writer, TLogItem logItem)\n      {\n         WriteToStream(writer, FormatLog(logItem));\n      }\n\n      \n      public LoggerProFileAppenderBase(int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n                                       int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n                                       string logsFolder = \"\",\n                                       string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n                                       ILogItemRenderer logItemRenderer = null,\n                                       Encoding encoding = null)\n         : base(logItemRenderer)\n      {\n         LogsFolder = logsFolder;\n         MaxBackupFileCount = Math.Max(1, maxBackupFileCount);\n         MaxFileSizeInKiloByte = maxFileSizeInKiloByte;\n         CheckLogFileNameFormat(logFileNameFormat);\n         LogFileNameFormat = logFileNameFormat;\n         FileEncoding = encoding ?? Encoding.Default;\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         \n         if (string.IsNullOrEmpty(LogsFolder))\n         {\n#if WINDOWS\n            LogsFolder = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);\n#else\n            LogsFolder = Environment.CurrentDirectory;\n#endif\n         }\n         if (!Directory.Exists(LogsFolder))\n            Directory.CreateDirectory(LogsFolder);\n      }\n   }\n\n   #endregion\n\n   #region LoggerProFileAppender\n\n   \n   public class LoggerProFileAppender : LoggerProFileAppenderBase\n   {\n      \n      private readonly Dictionary<string, StreamWriter> _writersDictionary = new Dictionary<string, StreamWriter>();\n\n      private void AddWriter(string logTag, out StreamWriter writer, out string logFileName)\n      {\n         logFileName = GetLogFileName(logTag, 0);\n         writer = CreateWriter(logFileName);\n         _writersDictionary.Add(logTag, writer);\n      }\n\n      private void RotateLog(string logTag, StreamWriter writer)\n      {\n         string logFileName;\n         EmitEndRotateLogItem(writer);\n         _writersDictionary.Remove(logTag);\n         RotateFile(logTag, out logFileName);\n         AddWriter(logTag, out writer, out logFileName);\n         EmitStartRotateLogItem(writer);\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         \n      }\n\n      public override void TearDown()\n      {\n         foreach (var writer in _writersDictionary.Values)\n         {\n            writer.Dispose();\n         }\n         _writersDictionary.Clear();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         StreamWriter writer;\n         string logFileName;\n         if (!_writersDictionary.TryGetValue(logItem.LogTag, out writer))\n         {\n            AddWriter(logItem.LogTag, out writer, out logFileName);\n         }\n\n         InternalWriteLog(writer, logItem);\n\n         if (((FileStream)writer.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog(logItem.LogTag, writer);\n         }\n      }\n   }\n\n   #endregion\n\n   #region LoggerProSimpleFileAppender\n\n   \n   public class LoggerProSimpleFileAppender : LoggerProFileAppenderBase\n   {\n      private StreamWriter _fileWriter;\n\n      protected override void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         \n         if (!logFileNameFormat.Contains(\"{number}\"))\n         {\n            throw new LoggerProException(\n               string.Format(\"Wrong FileFormat [{0}] - [HINT] A correct file format for {1} requires the {{number}} placeholder. A valid file format is : {2}\",\n                  logFileNameFormat, this.GetType().Name, DEFAULT_FILENAME_FORMAT));\n         }\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n      }\n\n      public override void TearDown()\n      {\n         _fileWriter?.Dispose();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         InternalWriteLog(_fileWriter, logItem);\n         if (((FileStream)_fileWriter.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog();\n         }\n      }\n\n      private void RotateLog()\n      {\n         EmitEndRotateLogItem(_fileWriter);\n         _fileWriter.Dispose();\n         RotateFile(\"\", out string newFileName);\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n         EmitStartRotateLogItem(_fileWriter);\n      }\n\n      public LoggerProSimpleFileAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n         ILogItemRenderer logItemRenderer = null,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, logFileNameFormat, logItemRenderer, encoding)\n      {\n      }\n   }\n\n   #endregion\n\n   #region LoggerProFileByFolderAppender\n\n   \n   public class LoggerProFileByFolderAppender : LoggerProFileAppender\n   {\n      private StreamWriter _fileWriter;\n      private DateTime _currentDate;\n\n      private string GetLogFolder()\n      {\n         \n         string baseFolder = string.IsNullOrEmpty(LogsFolder)\n            ? Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)\n            : LogsFolder;\n\n         string logsDir = Path.Combine(baseFolder, \"Logs\");\n         if (!Directory.Exists(logsDir))\n            Directory.CreateDirectory(logsDir);\n\n         \n         string dayFolder = Path.Combine(logsDir, DateTime.Now.ToString(\"yyyyMMdd\"));\n         if (!Directory.Exists(dayFolder))\n            Directory.CreateDirectory(dayFolder);\n\n         return dayFolder;\n      }\n\n      \n      protected override string GetLogFileName(string tag, int fileNumber)\n      {\n         string moduleName = Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location);\n         string fileName = string.Format(\"{0}.{1}.log\", moduleName, fileNumber.ToString(\"D2\"));\n         return Path.Combine(GetLogFolder(), fileName);\n      }\n\n      protected override void CheckLogFileNameFormat(string logFileNameFormat)\n      {\n         // Do nothing, file format is fixed.\n      }\n\n      private void ChangeLogFolder()\n      {\n         InternalRotateLog(out string newFileName, () =>\n         {\n            newFileName = GetLogFileName(\"\", 0);\n         });\n      }\n\n      private void RotateLog()\n      {\n         InternalRotateLog(out string newFileName, () =>\n         {\n            RotateFile(\"\", out newFileName);\n         });\n      }\n\n      private void InternalRotateLog(out string newFileName, Action<TLoggerProFileByFolderAppender> makeFileNameProc = null)\n      {\n         EmitEndRotateLogItem(_fileWriter);\n         _fileWriter.Dispose();\n         if (makeFileNameProc != null)\n         {\n            \n            makeFileNameProc(this);\n         }\n         else\n         {\n            newFileName = GetLogFileName(\"\", 0);\n         }\n         _fileWriter = CreateWriter(newFileName, 16 * 1024);\n         EmitStartRotateLogItem(_fileWriter);\n      }\n\n      public override void Setup()\n      {\n         base.Setup();\n         _fileWriter = CreateWriter(GetLogFileName(\"\", 0));\n         _currentDate = DateTime.Today;\n      }\n\n      public override void TearDown()\n      {\n         _fileWriter?.Dispose();\n         base.TearDown();\n      }\n\n      public override void WriteLog(TLogItem logItem)\n      {\n         if (_currentDate != DateTime.Today)\n         {\n            ChangeLogFolder();\n            _currentDate = DateTime.Today;\n         }\n         string logRow;\n         if (OnLogRow != null)\n         {\n            OnLogRow(logItem, out logRow);\n         }\n         else\n         {\n            logRow = LogItemRenderer.RenderLogItem(logItem);\n         }\n         WriteToStream(_fileWriter, logRow);\n         if (((FileStream)_fileWriter.BaseStream).Length > MaxFileSizeInKiloByte * 1024)\n         {\n            RotateLog();\n         }\n      }\n\n      public LoggerProFileByFolderAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         ILogItemRenderer logItemRenderer = null,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, DEFAULT_FILENAME_FORMAT_WITHOUT_TAG, logItemRenderer, encoding)\n      {\n      }\n   }\n\n   #endregion\n\n   #region LoggerProLogFmtFileAppender\n\n   \n   public class LoggerProLogFmtFileAppender : LoggerProSimpleFileAppender\n   {\n      public LoggerProLogFmtFileAppender(\n         int maxBackupFileCount = DEFAULT_MAX_BACKUP_FILE_COUNT,\n         int maxFileSizeInKiloByte = DEFAULT_MAX_FILE_SIZE_KB,\n         string logsFolder = \"\",\n         string logFileNameFormat = DEFAULT_FILENAME_FORMAT,\n         Encoding encoding = null)\n         : base(maxBackupFileCount, maxFileSizeInKiloByte, logsFolder, logFileNameFormat, new LogItemRendererLogFmt(), encoding)\n      {\n      }\n\n      protected override void EmitEndRotateLogItem(StreamWriter writer)\n      {\n         // In this appender, do nothing\n      }\n\n      protected override void EmitStartRotateLogItem(StreamWriter writer)\n      {\n         // In this appender, do nothing\n      }\n\n      protected override string GetLogFileName(string tag, int fileNumber)\n      {\n        \n         string origFileName = base.GetLogFileName(tag, fileNumber);\n         string ext = Path.GetExtension(origFileName);\n         if (string.IsNullOrEmpty(ext))\n         {\n            ext = \".log\";\n         }\n         return Path.ChangeExtension(origFileName, \".logfmt\" + ext);\n      }\n   }\n\n   #endregion\n}"}
{"input": "unit uConfig.Module;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TConfigModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TConfigModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  uBase.Controller,\n  uMovie.Controller,\n  System.IOUtils,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.StaticFiles,\n  MVCFramework.HTMX,\n  JsonDataObjects,\n  MVCFramework.View.Renderers.Mustache;\n\nprocedure TConfigModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      \n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // enables or not system controllers loading (available only from localhost requests)\n      Config[TMVCConfigKey.LoadSystemControllers] := 'true';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'htmx';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'htmx_templates';\n      // Max Record Count for automatic Entities CRUD\n      Config[TMVCConfigKey.MaxEntitiesRecordCount] := '20';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n      // Enable X-Powered-By Header in response\n      Config[TMVCConfigKey.ExposeXPoweredBy] := 'true';\n      // Max request size in bytes\n      Config[TMVCConfigKey.MaxRequestSize] := IntToStr(TMVCConstants.DEFAULT_MAX_REQUEST_SIZE);\n    end);\n\n  (* Use Mustache View Engine *)\n  FMVC.SetViewEngine(TMVCMustacheViewEngine);\n\n  FMVC.AddMiddleware(TMVCStaticFilesMiddleware.Create('/img', TPath.Combine(ExtractFilePath(GetModuleName(HInstance)),\n    'www\\img')));\n\n  FMVC.AddController(TBaseController);\n  FMVC.AddController(TMovieController);\n\n  FMVC.SetExceptionHandler(\n    procedure(E: Exception; SelectedController: TMVCController; WebContext: TWebContext; var ExceptionHandled: Boolean)\n\n    function ProcessJSONErrors: TJsonObject;\n    var\n      Nested: Exception;\n      Errors: TJsonArray;\n      Error: TJsonObject;\n    begin\n      Result := TJsonObject.Create;\n      Errors := TJsonArray.Create;\n      Result.A['errors'] := Errors;\n      Nested := E;\n      while Nested <> nil do\n      begin\n        Error := TJsonObject.Create;\n        Error.S['className'] := Nested.ClassName;\n        Error.S['message'] := Nested.Message;\n        Errors.Add(Error);\n        Nested := Nested.InnerException;\n      end;\n    end;\n\n    begin\n      if WebContext.Request.IsHTMX then\n      begin\n        if SelectedController <> nil then\n        begin\n          SelectedController.Render(E.Message);\n          // else etc\n          ExceptionHandled := true;\n          WebContext.Response.StatusCode := 400;\n        end;\n\n      end;\n\n    end);\nend;\n\nprocedure TConfigModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Middleware.StaticFiles;\nusing MVCFramework.HTMX;\nusing JsonDataObjects;\nusing MVCFramework.View.Renderers.Mustache;\nusing uBase.Controller;\nusing uMovie.Controller;\n\nnamespace uConfigModule\n{\n    public class ConfigModule : WebModule\n    {\n        private MVCEngine _mvcEngine;\n        public override void OnCreate()\n        {\n            _mvcEngine = new MVCEngine(this, config =>\n            {\n                config[MVCCOnfigKey.DefaultContentType] = MVCConstants.DEFAULT_CONTENT_TYPE;\n                config[MVCCOnfigKey.DefaultContentCharset] = MVCConstants.DEFAULT_CONTENT_CHARSET;\n                config[MVCCOnfigKey.AllowUnhandledAction] = \"false\";\n                config[MVCCOnfigKey.LoadSystemControllers] = \"true\";\n                config[MVCCOnfigKey.DefaultViewFileExtension] = \"htmx\";\n                config[MVCCOnfigKey.ViewPath] = \"htmx_templates\";\n                config[MVCCOnfigKey.MaxEntitiesRecordCount] = \"20\";\n                config[MVCCOnfigKey.ExposeServerSignature] = \"true\";\n                config[MVCCOnfigKey.ExposeXPoweredBy] = \"true\";\n                config[MVCCOnfigKey.MaxRequestSize] = MVCConstants.DEFAULT_MAX_REQUEST_SIZE.ToString();\n            });\n            _mvcEngine.SetViewEngine(new MVCMustacheViewEngine());\n            string modulePath = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);\n            string imgPath = Path.Combine(modulePath, @\"www\\img\");\n            _mvcEngine.AddMiddleware(new MVCStaticFilesMiddleware(\"/img\", imgPath));\n            _mvcEngine.AddController<BaseController>();\n            _mvcEngine.AddController<MovieController>();\n            _mvcEngine.SetExceptionHandler((ex, selectedController, webContext, out bool exceptionHandled) =>\n            {\n                exceptionHandled = false;\n                if (webContext.Request.IsHTMX)\n                {\n                    if (selectedController != null)\n                    {\n                        selectedController.Render(ex.Message);\n                        exceptionHandled = true;\n                        webContext.Response.StatusCode = 400;\n                    }\n                }\n            });\n        }\n        public override void OnDestroy()\n        {\n            _mvcEngine.Dispose();\n        }\n    }\n}"}
{"input": "unit LoggerPro.DBAppender;\n\n// Abstract LoggerPro Appender that writes to a database\n// Subclass to use with DB connection stack of choice e.g. ADO, FireDAC etc\n// only supports parameterised stored procedures for security and performance\n\ninterface\n\nuses\n  System.Classes, LoggerPro, System.SysUtils, Data.DB;\n\ntype\n  TOnDBWriteError = reference to procedure(const Sender: TObject; const LogItem: TLogItem; const DBError: Exception;\n    var RetryCount: Integer);\n\n  TGetDBConnection = reference to function: TCustomConnection;\n\n  TGetStoredProc<T: class> = reference to function(Connection: TCustomConnection): T;\n\n  TSetParams<T: class> = reference to procedure(DataObject: T; LogItem: TLogItem);\n\n\n  ///<summary>Abstract class for writing logs to database</summary>\n  /// <remarks>Subclass with your choice of stored procedure class to get a working logger </remarks>\n  TLoggerProDBAppender<T: class> = class(TLoggerProAppenderBase)\n  protected\n    const MAX_RETRY_COUNT = 5;\n  protected\n    FOnDBWriteError: TOnDBWriteError;\n    FGetDBConnection: TGetDBConnection;\n    FGetStoredProc: TGetStoredProc<T>;\n    FSetParams: TSetParams<T>;\n\n    FDBConnection: TCustomConnection;\n    FDBObject: T;\n    procedure RefreshParams(DataObj: T); virtual; abstract;\n    procedure ExecuteDataObject(DataObj: T); virtual; abstract;\n  public\n    constructor Create(GetDBConnection: TGetDBConnection; GetStoredProc: TGetStoredProc<T>; SetParams: TSetParams<T>;\n      OnDBWriteError: TOnDBWriteError); reintroduce;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure TryToRestart(var Restarted: Boolean); override;\n    procedure WriteLog(const ALogItem: TLogItem); override;\n  end;\n\nimplementation\n\n{ TLoggerProDBAppender }\n\n///<summary>Create an instance of the DB logger</summary>\n/// <param name=\"GetDBConnection\">anonymous function that returns a configured DB Connection</param>\n/// <param name=\"GetStoredProc\">anonymous function that returns a stored proc that can write to the DB</param>\n/// <param name=\"SetParams\">anonymous procedure that populates parameters before the stored proc is executed</param>\n/// <param name=\"OnDBWriteError\">anonymous procedure to handle retry of a failed operaation</param>\nconstructor TLoggerProDBAppender<T>.Create(GetDBConnection: TGetDBConnection; GetStoredProc: TGetStoredProc<T>;\n  SetParams: TSetParams<T>; OnDBWriteError: TOnDBWriteError);\nbegin\n  inherited Create;\n  FGetDBConnection := GetDBConnection;\n  FGetStoredProc := GetStoredProc;\n  FSetParams := SetParams;\n  FOnDBWriteError := OnDBWriteError;\nend;\n\nprocedure TLoggerProDBAppender<T>.Setup;\nbegin\n  inherited;\n  FDBConnection := FGetDBConnection;\nend;\n\nprocedure TLoggerProDBAppender<T>.TearDown;\nbegin\n  inherited;\n  if FDBObject <> nil then\n    FDBObject.Free;\n\n  if FDBConnection <> nil then\n  begin\n    FDBConnection.Connected := False;\n    FDBConnection.Free;\n  end;\nend;\n\nprocedure TLoggerProDBAppender<T>.TryToRestart(var Restarted: Boolean);\nbegin\n  try\n    // remove the DB Object\n    if FDBObject <> nil then\n    begin\n      FDBObject.Free;\n      FDBObject := nil;\n    end;\n\n    // reset the DB connection\n    if FDBConnection <> nil then\n    begin\n      FDBConnection.Connected := False;\n      FDBConnection.Free;\n      FDBConnection := nil;\n    end;\n  except\n    // no point catching the exception\n  end;\n\n  // now try to restart it\n  FDBConnection := FGetDBConnection;\n  Restarted := True;\nend;\n\nprocedure TLoggerProDBAppender<T>.WriteLog(const ALogItem: TLogItem);\nvar\n  RetryCount: Integer;\nbegin\n  RetryCount := 0;\n  repeat\n    try\n      if FDBObject = nil then\n      begin\n        FDBConnection.Connected := True;  //force an exception if needed\n        FDBObject := FGetStoredProc(FDBConnection);\n        RefreshParams(FDBObject); //this may not raise unhandled exception even in case of disconnection\n      end;\n      FSetParams(FDBObject, ALogItem);\n      ExecuteDataObject(FDBObject);\n      Break;\n    except\n      on E: Exception do\n      begin\n        // if there is an event handler for DB exception, call it\n        if Assigned(FOnDBWriteError) then\n          FOnDBWriteError(Self, ALogItem, E, RetryCount);\n        Inc(RetryCount);\n        // if the handler has set FRetryCount to a positive value then retry the call\n        if RetryCount >= MAX_RETRY_COUNT then\n          raise;\n      end;\n    end;\n  until False;\nend;\n\nend.", "output": "using System;\nusing System.Data;\n\nnamespace LoggerPro.Appenders\n{\n    \n        public delegate void OnDBWriteError(object sender, TLogItem logItem, Exception dbError, ref int retryCount);\n\n    \n    public delegate IDbConnection GetDBConnection();\n\n   \n    public delegate T GetStoredProc<T>(IDbConnection connection) where T : class;\n\n    \n    public delegate void SetParams<T>(T dataObject, TLogItem logItem) where T : class;\n\n    \n    public abstract class LoggerProDBAppender<T> : LoggerProAppenderBase where T : class\n    {\n        protected const int MAX_RETRY_COUNT = 5;\n\n        protected OnDBWriteError OnDBWriteErrorCallback;\n        protected GetDBConnection GetDBConnectionCallback;\n        protected GetStoredProc<T> GetStoredProcCallback;\n        protected SetParams<T> SetParamsCallback;\n\n        protected IDbConnection DbConnection;\n        protected T DbObject;\n\n       \n        public LoggerProDBAppender(GetDBConnection getDBConnection, GetStoredProc<T> getStoredProc, SetParams<T> setParams,\n                                   OnDBWriteError onDBWriteError)\n        {\n            GetDBConnectionCallback = getDBConnection ?? throw new ArgumentNullException(nameof(getDBConnection));\n            GetStoredProcCallback = getStoredProc ?? throw new ArgumentNullException(nameof(getStoredProc));\n            SetParamsCallback = setParams ?? throw new ArgumentNullException(nameof(setParams));\n            OnDBWriteErrorCallback = onDBWriteError; \n        }\n\n                protected abstract void RefreshParams(T dataObject);\n\n        \n        protected abstract void ExecuteDataObject(T dataObject);\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            DbConnection = GetDBConnectionCallback();\n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            if (DbObject != null)\n            {\n                if (DbObject is IDisposable disposableObj)\n                {\n                    disposableObj.Dispose();\n                }\n                DbObject = null;\n            }\n            if (DbConnection != null)\n            {\n                try\n                {\n                    DbConnection.Close();\n                }\n                finally\n                {\n                    DbConnection.Dispose();\n                    DbConnection = null;\n                }\n            }\n        }\n\n        \n        public override void TryToRestart(out bool restarted)\n        {\n            restarted = false;\n            try\n            {\n                if (DbObject != null)\n                {\n                    if (DbObject is IDisposable disposableObj)\n                    {\n                        disposableObj.Dispose();\n                    }\n                    DbObject = null;\n                }\n                if (DbConnection != null)\n                {\n                    DbConnection.Close();\n                    DbConnection.Dispose();\n                    DbConnection = null;\n                }\n            }\n            catch\n            {\n                // Ignore exceptions during cleanup\n            }\n            DbConnection = GetDBConnectionCallback();\n            restarted = true;\n        }\n\n                public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            while (true)\n            {\n                try\n                {\n                    if (DbObject == null)\n                    {\n                        \n                        DbConnection.Open();\n                        DbObject = GetStoredProcCallback(DbConnection);\n                        RefreshParams(DbObject);\n                    }\n                    SetParamsCallback(DbObject, logItem);\n                    ExecuteDataObject(DbObject);\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    if (OnDBWriteErrorCallback != null)\n                    {\n                        OnDBWriteErrorCallback(this, logItem, ex, ref retryCount);\n                    }\n                    retryCount++;\n                    if (retryCount >= MAX_RETRY_COUNT)\n                    {\n                        throw;\n                    }\n                }\n            }\n        }\n    }\n}"}
{"input": "unit MVCFramework.Serializer.Defaults;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Intf;\n\nfunction GetDefaultSerializer: IMVCSerializer;\n\nimplementation\n\nuses\n  MVCFramework.Serializer.JsonDataObjects;\n\nfunction GetDefaultSerializer: IMVCSerializer;\nbegin\n  Result := TMVCJsonDataObjectsSerializer.Create;\nend;\n\nend.", "output": "using MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.JsonDataObjects;\n\nnamespace MVCFramework.Serializer.Defaults\n{\n    public static class SerializerDefaults\n    {\n        public static IMVCSerializer GetDefaultSerializer()\n        {\n            return new MVCJsonDataObjectsSerializer();\n        }\n    }\n}"}
{"input": "unit ServiceU;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.SvcMgr,\n  Vcl.Dialogs,\n  IdHTTPWebBrokerBridge;\n\ntype\n  TArticlesService = class(TService)\n    procedure ServiceCreate(Sender: TObject);\n    procedure ServiceExecute(Sender: TService);\n    procedure ServiceStart(Sender: TService; var Started: Boolean);\n    procedure ServiceStop(Sender: TService; var Stopped: Boolean);\n  private\n    fServer: TIdHTTPWebBrokerBridge;\n  public\n    function GetServiceController: TServiceController; override;\n  end;\n\nvar\n  ArticlesService: TArticlesService;\n\nimplementation\n\nuses\n  Web.WebReq,\n  WebModuleUnit1, MVCFramework.Commons;\n\n{$R *.DFM}\n\n\nprocedure ServiceController(CtrlCode: DWord); stdcall;\nbegin\n  ArticlesService.Controller(CtrlCode);\nend;\n\nfunction TArticlesService.GetServiceController: TServiceController;\nbegin\n  Result := ServiceController;\nend;\n\nprocedure TArticlesService.ServiceCreate(Sender: TObject);\nbegin\n  if WebRequestHandler <> nil then\n    WebRequestHandler.WebModuleClass := WebModuleClass;\nend;\n\nprocedure TArticlesService.ServiceExecute(Sender: TService);\nbegin\n  while not Terminated do\n  begin\n    ServiceThread.ProcessRequests(True);\n    Sleep(1000);\n  end;\nend;\n\nprocedure TArticlesService.ServiceStart(Sender: TService; var Started: Boolean);\nbegin\n  fServer := TIdHTTPWebBrokerBridge.Create(nil);\n  fServer.OnParseAuthentication := TMVCParseAuthentication.OnParseAuthentication;\n  fServer.DefaultPort := 8080;\n  fServer.Active := True;\nend;\n\nprocedure TArticlesService.ServiceStop(Sender: TService; var Stopped: Boolean);\nbegin\n  fServer.Free;\nend;\n\nend.", "output": "using System;\nusing System.ServiceProcess;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing Web.WebReq;\nusing WebModuleUnit1;\nusing IdHTTPWebBrokerBridge;\n\nnamespace REST.RestServer\n{\n    public class ArticlesService : ServiceBase\n    {\n        private HTTPWebBrokerBridge fServer;\n        private Thread serviceThread;\n        private volatile bool terminated;\n        public ArticlesService()\n        {\n            this.ServiceName = \"ArticlesService\";\n        }\n        protected override void OnStart(string[] args)\n        {\n            if (WebRequestHandler.Instance != null)\n            {\n                WebRequestHandler.Instance.WebModuleClass = typeof(WebModule);\n            }\n            fServer = new HTTPWebBrokerBridge();\n            fServer.OnParseAuthentication += MVCParseAuthentication.OnParseAuthentication;\n            fServer.DefaultPort = 8080;\n            fServer.Active = true;\n            terminated = false;\n            serviceThread = new Thread(ServiceExecute);\n            serviceThread.Start();\n        }\n        protected override void OnStop()\n        {\n            terminated = true;\n            serviceThread.Join();\n            if (fServer != null)\n            {\n                fServer.Active = false;\n                fServer.Dispose();\n                fServer = null;\n            }\n        }\n        private void ServiceExecute()\n        {\n            while (!terminated)\n            {\n                ServiceThread.ProcessRequests(true);\n                Thread.Sleep(1000);\n            }\n        }\n        public static void Main()\n        {\n            ServiceBase.Run(new ArticlesService());\n        }\n    }\n}"}
{"input": "unit AppControllerU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Logger,\n  Web.HTTPApp,\n  JsonDataObjects;\n\ntype\n\n  [MVCPath('/')]\n  TApp1MainController = class(TMVCController)\n  public\n    [MVCPath('/public')]\n    [MVCHTTPMethod([httpGET])]\n    function PublicSection: String;\n    [MVCPath('/')]\n    [MVCHTTPMethod([httpGET])]\n    function Index: String;\n  end;\n\n  [MVCPath('/admin')]\n  TAdminController = class(TMVCController)\n  public\n    [MVCPath('/role1')]\n    [MVCProduces('text/html')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole1: String;\n    [MVCPath('/role1')]\n    [MVCProduces('application/json')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole1EmittingJSON: TJSONObject;\n    [MVCPath('/role2')]\n    [MVCProduces('text/html')]\n    [MVCHTTPMethod([httpGET])]\n    function OnlyRole2: String;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, System.Classes;\n\n{ TApp1MainController }\n\nfunction TApp1MainController.Index: String;\nbegin\n  Redirect('/index.html');\nend;\n\nfunction TApp1MainController.PublicSection: String;\nbegin\n  Result := 'This is a public section';\nend;\n\n{ TAdminController }\n\nfunction TAdminController.OnlyRole1: String;\nbegin\n  ContentType := TMVCMediaType.TEXT_PLAIN;\n  Result := Context.LoggedUser.CustomData['mycustomvalue'] + sLineBreak +\n  'Hey! Hello ' + Context.LoggedUser.UserName + ', now you are a logged user and this is a protected content!' + sLineBreak +\n  'As logged user you have the following roles: ' + sLineBreak + string.Join(sLineBreak, Context.LoggedUser.Roles.ToArray);\nend;\n\nfunction TAdminController.OnlyRole1EmittingJSON: TJsonObject;\nvar\n  lJObj: TJSONObject;\n  lJArr: TJSONArray;\n  lQueryParams: TStrings;\n  I: Integer;\n  lItem: TJsonObject;\nbegin\n  ContentType := TMVCMediaType.APPLICATION_JSON;\n  lJObj := TJSONObject.Create;\n  try\n    lJObj.S['message'] := 'This is protected content accessible only by user1';\n    lJArr := lJObj.A['querystringparameters'];\n    lQueryParams := Context.Request.QueryStringParams;\n    for I := 0 to lQueryParams.Count - 1 do\n    begin\n      lItem := lJArr.AddObject;\n      lItem.S[lQueryParams.Names[I]] := lQueryParams.ValueFromIndex[I];\n    end;\n    Result := lJObj;\n  except\n    lJObj.Free;\n    raise;\n  end;\nend;\n\nfunction TAdminController.OnlyRole2: String;\nbegin\n  ContentType := TMVCMediaType.TEXT_PLAIN;\n  Result := Context.LoggedUser.CustomData['mycustomvalue'] + sLineBreak +\n    'Hey! Hello ' + Context.LoggedUser.UserName + ', now you are a logged user and this is a protected content!' + sLineBreak +\n    'As logged user you have the following roles: ' + sLineBreak + string.Join(sLineBreak, Context.LoggedUser.Roles.ToArray);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Primitives;\n\nnamespace AppControllerU\n{\n    \n    [Route(\"/\")]\n    [ApiController]\n    public class App1MainController : ControllerBase\n    {\n        \n        [HttpGet(\"public\")]\n        public IActionResult PublicSection()\n        {\n            return Content(\"This is a public section\", \"text/plain\");\n        }\n        \n        \n        [HttpGet(\"\")]\n        public IActionResult Index()\n        {\n            return Redirect(\"/index.html\");\n        }\n    }\n    \n    \n    [Route(\"admin\")]\n    [ApiController]\n    public class AdminController : ControllerBase\n    {\n        [HttpGet(\"role1\")]\n        public IActionResult OnlyRole1()\n        {\n            if (Request.Headers.TryGetValue(\"Accept\", out StringValues acceptHeader) &&\n                acceptHeader.Any(h => h.Contains(\"application/json\", StringComparison.OrdinalIgnoreCase)))\n            {\n                var response = new Dictionary<string, object>\n                {\n                    [\"message\"] = \"This is protected content accessible only by user1\"\n                };\n\n                var queryParams = Request.Query.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToString());\n                response[\"querystringparameters\"] = queryParams;\n                \n                return new JsonResult(response);\n            }\n            else\n            {\n                \n                var customValue = HttpContext.User?.FindFirst(\"custom\")?.Value ?? \"default_custom_value\";\n                var userName = HttpContext.User?.Identity?.Name ?? \"Anonymous\";\n                var roles = HttpContext.User?.FindAll(\"role\").Select(r => r.Value).ToArray() ?? new string[] { \"NoRoles\" };\n                var rolesText = string.Join(Environment.NewLine, roles);\n                \n                string result = $\"{customValue}{Environment.NewLine}\" +\n                                $\"Hey! Hello {userName}, now you are a logged user and this is a protected content!{Environment.NewLine}\" +\n                                $\"As logged user you have the following roles:{Environment.NewLine}{rolesText}\";\n                return Content(result, \"text/plain\");\n            }\n        }\n        \n        [HttpGet(\"role2\")]\n        [Produces(\"text/html\")]\n        public IActionResult OnlyRole2()\n        {\n            var customValue = HttpContext.User?.FindFirst(\"custom\")?.Value ?? \"default_custom_value\";\n            var userName = HttpContext.User?.Identity?.Name ?? \"Anonymous\";\n            var roles = HttpContext.User?.FindAll(\"role\").Select(r => r.Value).ToArray() ?? new string[] { \"NoRoles\" };\n            var rolesText = string.Join(Environment.NewLine, roles);\n            \n            string result = $\"{customValue}{Environment.NewLine}\" +\n                            $\"Hey! Hello {userName}, now you are a logged user and this is a protected content!{Environment.NewLine}\" +\n                            $\"As logged user you have the following roles:{Environment.NewLine}{rolesText}\";\n            return Content(result, \"text/plain\");\n        }\n    }\n}"}
{"input": "unit Horse.Core.RouterTree.NextCaller;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Generics.Collections,\n  fpHTTP,\n  httpprotocol,\n{$ELSE}\n  System.NetEncoding,\n  System.SysUtils,\n  Web.HTTPApp,\n  System.Generics.Collections,\n{$ENDIF}\n  Horse.Commons,\n  Horse.Request,\n  Horse.Response,\n  Horse.Callback;\n\ntype\n  TNextCaller = class\n  private\n    FIndex: Integer;\n    FIndexCallback: Integer;\n    FPath: TQueue<string>;\n    FHTTPType: TMethodType;\n    FRequest: THorseRequest;\n    FResponse: THorseResponse;\n    FMiddleware: TList<THorseCallback>;\n    FCallBack: TObjectDictionary<TMethodType, TList<THorseCallback>>;\n    FCallNextPath: TCallNextPath;\n    FIsGroup: Boolean;\n    FTag: string;\n    FIsParamsKey: Boolean;\n    FFound: ^Boolean;\n  public\n    function Init: TNextCaller;\n    function SetCallback(const ACallback: TObjectDictionary<TMethodType, TList<THorseCallback>>): TNextCaller;\n    function SetPath(const APath: TQueue<string>): TNextCaller;\n    function SetHTTPType(const AHTTPType: TMethodType): TNextCaller;\n    function SetRequest(const ARequest: THorseRequest): TNextCaller;\n    function SetResponse(const AResponse: THorseResponse): TNextCaller;\n    function SetIsGroup(const AIsGroup: Boolean): TNextCaller;\n    function SetMiddleware(const AMiddleware: TList<THorseCallback>): TNextCaller;\n    function SetTag(const ATag: string): TNextCaller;\n    function SetIsParamsKey(const AIsParamsKey: Boolean): TNextCaller;\n    function SetOnCallNextPath(const ACallNextPath: TCallNextPath): TNextCaller;\n    function SetFound(var AFound: Boolean): TNextCaller;\n    procedure Next;\n  end;\n\nimplementation\n\nuses\n  Horse.Exception,\n  Horse.Exception.Interrupted;\n\nfunction TNextCaller.Init: TNextCaller;\nvar\n  LCurrent: string;\nbegin\n  Result := Self;\n  if not FIsGroup then\n    LCurrent := FPath.Dequeue;\n  FIndex := -1;\n  FIndexCallback := -1;\n  if FIsParamsKey then\n    FRequest.Params.Dictionary.Add(FTag, {$IF DEFINED(FPC)}HTTPDecode(LCurrent){$ELSE}TNetEncoding.URL.Decode(LCurrent){$ENDIF});\nend;\n\nprocedure TNextCaller.Next;\nvar\n  LCallback: TList<THorseCallback>;\nbegin\n  Inc(FIndex);\n  if (FMiddleware.Count > FIndex) then\n  begin\n    FFound^ := True;\n    Self.FMiddleware.Items[FIndex](FRequest, FResponse, Next);\n    if (FMiddleware.Count > FIndex) then\n      Next;\n  end\n  else if (FPath.Count = 0) and Assigned(FCallBack) then\n  begin\n    Inc(FIndexCallback);\n    if FCallBack.TryGetValue(FHTTPType, LCallback) then\n    begin\n      if (LCallback.Count > FIndexCallback) then\n      begin\n        try\n          FFound^ := True;\n          LCallback.Items[FIndexCallback](FRequest, FResponse, Next);\n        except\n          on E: Exception do\n          begin\n            if (not(E is EHorseCallbackInterrupted)) and\n               (not(E is EHorseException)) and\n               (FResponse.Status < Integer(THTTPStatus.BadRequest))\n            then\n              FResponse.Send('Internal Application Error').Status(THTTPStatus.InternalServerError);\n            raise;\n          end;\n        end;\n        Next;\n      end;\n    end\n    else\n    begin\n      if FCallBack.Count > 0 then\n      begin\n        FFound^ := True;\n        FResponse.Send('Method Not Allowed').Status(THTTPStatus.MethodNotAllowed);\n      end\n      else\n        FResponse.Send('Not Found').Status(THTTPStatus.NotFound)\n    end;\n  end\n  else\n    FFound^ := FCallNextPath(FPath, FHTTPType, FRequest, FResponse);\n  if not FFound^ then\n    FResponse.Send('Not Found').Status(THTTPStatus.NotFound);\nend;\n\nfunction TNextCaller.SetCallback(const ACallback: TObjectDictionary<TMethodType, TList<THorseCallback>>): TNextCaller;\nbegin\n  FCallBack := ACallback;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetFound(var AFound: Boolean): TNextCaller;\nbegin\n  FFound := @AFound;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetHTTPType(const AHTTPType: TMethodType): TNextCaller;\nbegin\n  FHTTPType := AHTTPType;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetIsGroup(const AIsGroup: Boolean): TNextCaller;\nbegin\n  FIsGroup := AIsGroup;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetIsParamsKey(const AIsParamsKey: Boolean): TNextCaller;\nbegin\n  FIsParamsKey := AIsParamsKey;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetMiddleware(const AMiddleware: TList<THorseCallback>): TNextCaller;\nbegin\n  FMiddleware := AMiddleware;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetOnCallNextPath(const ACallNextPath: TCallNextPath): TNextCaller;\nbegin\n  FCallNextPath := ACallNextPath;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetPath(const APath: TQueue<string>): TNextCaller;\nbegin\n  FPath := APath;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetRequest(const ARequest: THorseRequest): TNextCaller;\nbegin\n  FRequest := ARequest;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetResponse(const AResponse: THorseResponse): TNextCaller;\nbegin\n  FResponse := AResponse;\n  Result := Self;\nend;\n\nfunction TNextCaller.SetTag(const ATag: string): TNextCaller;\nbegin\n  FTag := ATag;\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\n\nnamespace Horse.Core.RouterTree\n{\n    \n    public delegate void THorseCallback(THorseRequest request, THorseResponse response, Action next);\n\n    \n    public delegate bool TCallNextPath(Queue<string> path, TMethodType httpType, THorseRequest request, THorseResponse response);\n\n    \n    public enum TMethodType\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH\n    }\n\n    \n    public class THorseRequest\n    {\n        public Dictionary<string, string> Params { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n    }\n\n    \n    public class THorseResponse\n    {\n        public int Status { get; set; }\n        public THorseResponse Send(string message)\n        {\n            Console.WriteLine(\"Response: \" + message);\n            return this;\n        }\n        public THorseResponse StatusCode(int status)\n        {\n            Status = status;\n            Console.WriteLine(\"Status: \" + status);\n            return this;\n        }\n    }\n\n    \n    public class HorseCallbackInterrupted : Exception { }\n    public class HorseException : Exception\n    {\n        public int Status { get; set; }\n        public static HorseException New(int status, string message)\n        {\n            return new HorseException(message) { Status = status };\n        }\n        public HorseException(string message) : base(message) { }\n    }\n\n    \n    public class BooleanHolder\n    {\n        public bool Value { get; set; }\n    }\n\n    \n    public class TNextCaller\n    {\n        private int FIndex;\n        private int FIndexCallback;\n        private Queue<string> FPath;\n        private TMethodType FHTTPType;\n        private THorseRequest FRequest;\n        private THorseResponse FResponse;\n        private List<THorseCallback> FMiddleware;\n        private Dictionary<TMethodType, List<THorseCallback>> FCallBack;\n        private TCallNextPath FCallNextPath;\n        private bool FIsGroup;\n        private string FTag;\n        private bool FIsParamsKey;\n        private BooleanHolder FFound;\n        private object FHorseCore; \n\n        \n        public TNextCaller(object horseCore)\n        {\n            FHorseCore = horseCore;\n        }\n\n        \n        public TNextCaller Init()\n        {\n            if (!FIsGroup && FPath != null && FPath.Count > 0)\n            {\n                string LCurrent = FPath.Dequeue();\n                if (FIsParamsKey && FRequest != null)\n                {\n                    \n                    FRequest.Params[FTag] = WebUtility.UrlDecode(LCurrent);\n                }\n            }\n            FIndex = -1;\n            FIndexCallback = -1;\n            return this;\n        }\n\n        \n        public void Next()\n        {\n            FIndex++;\n            if (FMiddleware != null && FMiddleware.Count > FIndex)\n            {\n                FFound.Value = true;\n                FMiddleware[FIndex](FRequest, FResponse, Next);\n                if (FMiddleware.Count > FIndex)\n                    Next();\n            }\n            else if ((FPath == null || FPath.Count == 0) && FCallBack != null)\n            {\n                FIndexCallback++;\n                if (FCallBack.TryGetValue(FHTTPType, out List<THorseCallback> LCallback))\n                {\n                    if (LCallback.Count > FIndexCallback)\n                    {\n                        try\n                        {\n                            FFound.Value = true;\n                            LCallback[FIndexCallback](FRequest, FResponse, Next);\n                        }\n                        catch (Exception E)\n                        {\n                            if (!(E is HorseCallbackInterrupted) &&\n                                !(E is HorseException) &&\n                                FResponse.Status < (int)HttpStatusCode.BadRequest)\n                            {\n                                FResponse.Send(\"Internal Application Error\")\n                                         .StatusCode((int)HttpStatusCode.InternalServerError);\n                            }\n                            throw;\n                        }\n                        Next();\n                    }\n                }\n                else\n                {\n                    if (FCallBack.Count > 0)\n                    {\n                        FFound.Value = true;\n                        FResponse.Send(\"Method Not Allowed\")\n                                 .StatusCode((int)HttpStatusCode.MethodNotAllowed);\n                    }\n                    else\n                    {\n                        FResponse.Send(\"Not Found\")\n                                 .StatusCode((int)HttpStatusCode.NotFound);\n                    }\n                }\n            }\n            else\n            {\n                FFound.Value = FCallNextPath(FPath, FHTTPType, FRequest, FResponse);\n            }\n            if (!FFound.Value)\n                FResponse.Send(\"Not Found\")\n                         .StatusCode((int)HttpStatusCode.NotFound);\n        }\n\n        \n        public TNextCaller SetCallback(Dictionary<TMethodType, List<THorseCallback>> aCallback)\n        {\n            FCallBack = aCallback;\n            return this;\n        }\n\n        public TNextCaller SetFound(BooleanHolder aFound)\n        {\n            FFound = aFound;\n            return this;\n        }\n\n        public TNextCaller SetHTTPType(TMethodType aHTTPType)\n        {\n            FHTTPType = aHTTPType;\n            return this;\n        }\n\n        public TNextCaller SetIsGroup(bool aIsGroup)\n        {\n            FIsGroup = aIsGroup;\n            return this;\n        }\n\n        public TNextCaller SetIsParamsKey(bool aIsParamsKey)\n        {\n            FIsParamsKey = aIsParamsKey;\n            return this;\n        }\n\n        public TNextCaller SetMiddleware(List<THorseCallback> aMiddleware)\n        {\n            FMiddleware = aMiddleware;\n            return this;\n        }\n\n        public TNextCaller SetOnCallNextPath(TCallNextPath aCallNextPath)\n        {\n            FCallNextPath = aCallNextPath;\n            return this;\n        }\n\n        public TNextCaller SetPath(Queue<string> aPath)\n        {\n            FPath = aPath;\n            return this;\n        }\n\n        public TNextCaller SetRequest(THorseRequest aRequest)\n        {\n            FRequest = aRequest;\n            return this;\n        }\n\n        public TNextCaller SetResponse(THorseResponse aResponse)\n        {\n            FResponse = aResponse;\n            return this;\n        }\n\n        public TNextCaller SetTag(string aTag)\n        {\n            FTag = aTag;\n            return this;\n        }\n\n        \n        public T End<T>() where T : class\n        {\n            return FHorseCore as T;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// Contributors for this file: \n//    David Cornelius\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.VCLListBoxAppender;\n\ninterface\n\nuses\n  LoggerPro,\n  System.Classes,\n  Vcl.StdCtrls;\n\ntype\n  { @abstract(Appends formatted @link(TLogItem) to a TListBox in a VCL application) }\n  TVCLListBoxAppender = class(TLoggerProAppenderBase)\n  private\n    FLB: TListBox;\n    FMaxLogLines: Word;\n  public\n    constructor Create(aLB: TListBox; aMaxLogLines: Word = 500; aLogItemRenderer: ILogItemRenderer = nil); reintroduce;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TVCLListBoxAppender }\n\nconstructor TVCLListBoxAppender.Create(aLB: TListBox; aMaxLogLines: Word = 500; aLogItemRenderer: ILogItemRenderer = nil);\nbegin\n  inherited Create(aLogItemRenderer);\n  FLB := aLB;\n  FMaxLogLines := aMaxLogLines;\nend;\n\nprocedure TVCLListBoxAppender.Setup;\nbegin\n  inherited;\n  TThread.Synchronize(nil,\n    procedure\n    begin\n      FLB.Clear;\n    end);\nend;\n\nprocedure TVCLListBoxAppender.TearDown;\nbegin\n  // do nothing\nend;\n\nprocedure TVCLListBoxAppender.WriteLog(const aLogItem: TLogItem);\nvar\n  lText: string;\nbegin\n  lText := FormatLog(aLogItem);\n  TThread.Queue(nil,\n    procedure\n    var\n      Lines: integer;\n    begin\n      FLB.Items.BeginUpdate;\n      try\n        Lines := FLB.Items.Count;\n        if Lines > FMaxLogLines then\n          FLB.Items.Delete(0);\n        FLB.AddItem(lText, nil);\n        FLB.ItemIndex := FLB.Items.Count - 1;\n      finally\n        FLB.Items.EndUpdate;\n      end;\n    end);\nend;\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Windows.Forms;\nusing LoggerPro; \n\nnamespace LoggerPro\n{\n    \n    public class VCLListBoxAppender : LoggerProAppenderBase\n    {\n        private readonly ListBox _listBox;\n        private readonly int _maxLogLines;\n\n        public VCLListBoxAppender(ListBox listBox, int maxLogLines = 500, ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n            _listBox = listBox ?? throw new ArgumentNullException(nameof(listBox));\n            _maxLogLines = maxLogLines;\n        }\n        public override void Setup()\n        {\n            base.Setup();\n            \n            if (_listBox.InvokeRequired)\n            {\n                _listBox.Invoke(new Action(() => _listBox.Items.Clear()));\n            }\n            else\n            {\n                _listBox.Items.Clear();\n            }\n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public override void WriteLog(LogItem logItem)\n        {\n            \n            string formattedLog = FormatLog(logItem);\n\n            \n            if (_listBox.InvokeRequired)\n            {\n                _listBox.BeginInvoke(new Action(() => AppendLog(formattedLog)));\n            }\n            else\n            {\n                AppendLog(formattedLog);\n            }\n        }\n\n        private void AppendLog(string logText)\n        {\n            _listBox.BeginUpdate();\n            try\n            {\n                \n                while (_listBox.Items.Count >= _maxLogLines)\n                {\n                    _listBox.Items.RemoveAt(0);\n                }\n                _listBox.Items.Add(logText);\n                \n                _listBox.SelectedIndex = _listBox.Items.Count - 1;\n            }\n            finally\n            {\n                _listBox.EndUpdate();\n            }\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.SQLGenerators.MySQL;\n\ninterface\n\nuses\n  FireDAC.Phys.MySQLDef,\n  FireDAC.Phys.MySQL,\n  System.Rtti,\n  System.Generics.Collections,\n  MVCFramework.RQL.Parser,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Commons;\n\ntype\n  TMVCSQLGeneratorMySQL = class(TMVCSQLGenerator)\n  protected\n    function GetCompilerClass: TRQLCompilerClass; override;\n  public\n    function CreateInsertSQL(\n      const TableMap: TMVCTableMap;\n      const ARInstance: TMVCActiveRecord\n      ): string; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.RQL.AST2MySQL;\n\nfunction TMVCSQLGeneratorMySQL.CreateInsertSQL(\n  const TableMap: TMVCTableMap;\n  const ARInstance: TMVCActiveRecord\n  ): string;\nvar\n  lKeyValue: TPair<TRttiField, TFieldInfo>;\n  lSB: TStringBuilder;\n  lPKInInsert: Boolean;\n  lFieldName: String;\nbegin\n  lPKInInsert := (not TableMap.fPrimaryKeyFieldName.IsEmpty) and (not(TMVCActiveRecordFieldOption.foAutoGenerated in TableMap.fPrimaryKeyOptions));\n  lPKInInsert := lPKInInsert and (not(TMVCActiveRecordFieldOption.foReadOnly in TableMap.fPrimaryKeyOptions));\n  lSB := TStringBuilder.Create;\n  try\n    lSB.Append('INSERT INTO ' + GetTableNameForSQL(TableMap.fTableName) + '(');\n    if lPKInInsert then\n    begin\n      lSB.Append(GetFieldNameForSQL(TableMap.fPrimaryKeyFieldName) + ',');\n    end;\n\n    {partition}\n    for lFieldName in fPartitionInfo.FieldNames do\n    begin\n      lSB.Append(GetFieldNameForSQL(lFieldName) + ',');\n    end;\n    {end-partition}\n\n    for lKeyValue in TableMap.fMap do\n    begin\n      if lKeyValue.Value.Insertable then\n      begin\n        lSB.Append(GetFieldNameForSQL(lKeyValue.Value.FieldName) + ',');\n      end;\n    end;\n\n    lSB.Remove(lSB.Length - 1, 1);\n    lSB.Append(') values (');\n    if lPKInInsert then\n    begin\n      lSB.Append(':' + GetParamNameForSQL(TableMap.fPrimaryKeyFieldName) + ',');\n    end;\n\n    {partition}\n    for lFieldName in fPartitionInfo.FieldNames do\n    begin\n      lSB.Append(':' + GetParamNameForSQL(lFieldName) + ',');\n    end;\n    {end-partition}\n\n    for lKeyValue in TableMap.fMap do\n    begin\n      if lKeyValue.Value.IsVersion then\n      begin\n        lSB.Append(OBJECT_VERSION_STARTING_VALUE + ',');\n      end else if lKeyValue.Value.Insertable then\n      begin\n        lSB.Append(':' + GetParamNameForSQL(lKeyValue.Value.FieldName) + ',');\n      end;\n    end;\n    lSB.Remove(lSB.Length - 1, 1);\n    lSB.Append(')');\n\n    if TMVCActiveRecordFieldOption.foAutoGenerated in TableMap.fPrimaryKeyOptions then\n    begin\n      lSB.Append(';SELECT LAST_INSERT_ID() as ' + TableMap.fPrimaryKeyFieldName);\n    end;\n    Result := lSB.ToString;\n  finally\n    lSB.Free;\n  end;\nend;\n\nfunction TMVCSQLGeneratorMySQL.GetCompilerClass: TRQLCompilerClass;\nbegin\n  Result := TRQLMySQLCompiler;\nend;\n\ninitialization\n\nTMVCSQLGeneratorRegistry.Instance.RegisterSQLGenerator('mysql', TMVCSQLGeneratorMySQL);\n\nfinalization\n\nTMVCSQLGeneratorRegistry.Instance.UnRegisterSQLGenerator('mysql');\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing MVCFramework.RQL.Parser;       \nusing MVCFramework.ActiveRecord;    \nusing MVCFramework.Commons;          \n\nnamespace MVCFramework.SQLGenerators.MySQL\n{\n    \n    public class MVCSQLGeneratorMySQL : MVCSQLGenerator\n    {\n        \n        private const string OBJECT_VERSION_STARTING_VALUE = \"1\";\n\n        \n        protected override TRQLCompiler GetCompilerClass()\n        {\n           \n            return new TRQLMySQLCompiler();\n        }\n\n        \n        public override string CreateInsertSQL(MVCTableMap tableMap, MVCActiveRecord arInstance)\n        {\n            \n            bool pkInInsert = !string.IsNullOrEmpty(tableMap.PrimaryKeyFieldName) &&\n                              !tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.AutoGenerated);\n            pkInInsert = pkInInsert && !tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.ReadOnly);\n\n            StringBuilder sb = new StringBuilder();\n            try\n            {\n                sb.Append(\"INSERT INTO \" + GetTableNameForSQL(tableMap.TableName) + \"(\");\n                if (pkInInsert)\n                {\n                    sb.Append(GetFieldNameForSQL(tableMap.PrimaryKeyFieldName) + \",\");\n                }\n\n                foreach (string fieldName in this.PartitionInfo.FieldNames)\n                {\n                    sb.Append(GetFieldNameForSQL(fieldName) + \",\");\n                }\n\n                foreach (var keyValue in tableMap.Map)\n                {\n                    if (keyValue.Value.Insertable)\n                    {\n                        sb.Append(GetFieldNameForSQL(keyValue.Value.FieldName) + \",\");\n                    }\n                }\n\n                if (sb[sb.Length - 1] == ',')\n                    sb.Remove(sb.Length - 1, 1);\n\n                sb.Append(\") values (\");\n\n                if (pkInInsert)\n                {\n                    sb.Append(\":\" + GetParamNameForSQL(tableMap.PrimaryKeyFieldName) + \",\");\n                }\n\n                foreach (string fieldName in this.PartitionInfo.FieldNames)\n                {\n                    sb.Append(\":\" + GetParamNameForSQL(fieldName) + \",\");\n                }\n\n                foreach (var keyValue in tableMap.Map)\n                {\n                    if (keyValue.Value.IsVersion)\n                    {\n                        sb.Append(OBJECT_VERSION_STARTING_VALUE + \",\");\n                    }\n                    else if (keyValue.Value.Insertable)\n                    {\n                        sb.Append(\":\" + GetParamNameForSQL(keyValue.Value.FieldName) + \",\");\n                    }\n                }\n\n                if (sb[sb.Length - 1] == ',')\n                    sb.Remove(sb.Length - 1, 1);\n\n                sb.Append(\")\");\n\n                if (tableMap.PrimaryKeyOptions.Contains(MVCActiveRecordFieldOption.AutoGenerated))\n                {\n                    sb.Append(\";SELECT LAST_INSERT_ID() as \" + tableMap.PrimaryKeyFieldName);\n                }\n\n                return sb.ToString();\n            }\n            finally\n            {\n                // Dispose StringBuilder if needed.\n            }\n        }\n    }\n\n    \n    public static class MVCSQLGeneratorMySQLRegistration\n    {\n        static MVCSQLGeneratorMySQLRegistration()\n        {\n            MVCSQLGeneratorRegistry.Instance.RegisterSQLGenerator(\"mysql\", typeof(MVCSQLGeneratorMySQL));\n        }\n\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.Server;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  MVCFramework.Commons, MVCFramework;\n\ntype\n\n  EMVCServerException = class(Exception);\n\n  IMVCListenerProperties = interface\n    ['{82721C88-A308-4B2E-B94A-8E7CEEC4721F}']\n    function GetName: string;\n    function SetName(const AValue: string): IMVCListenerProperties;\n\n    function GetPort: Integer;\n    function SetPort(AValue: Integer): IMVCListenerProperties;\n\n    function GetMaxConnections: Integer;\n    function SetMaxConnections(AValue: Integer): IMVCListenerProperties;\n\n    function GetWebModuleClass: TComponentClass;\n    function SetWebModuleClass(AValue: TComponentClass): IMVCListenerProperties;\n\n    function GetSSLOptions(out SSLCertFile, SSLRootCertFile, SSLKeyFile, SSLPassword: String): Boolean;\n    function SetSSLOptions(const SSLCertFile, SSLRootCertFile, SSLKeyFile, SSLPassword: String): IMVCListenerProperties;\n  end;\n\n  IMVCListener = interface\n    ['{127A5E5D-D968-4409-BE9A-8D3AE08E6009}']\n    function GetActive: Boolean;\n\n    procedure Start;\n    procedure Stop;\n\n    property Active: Boolean read GetActive;\n  end;\n\n  IMVCListenersContext = interface\n    ['{9EA6BBDB-B5C1-462E-BBF4-AA30A4317F54}']\n    function Add(const AName: string; AListener: IMVCListener): IMVCListenersContext; overload;\n    function Add(AProperties: IMVCListenerProperties): IMVCListenersContext; overload;\n    function Remove(const AListenerName: string): IMVCListenersContext;\n\n    procedure StartAll;\n    procedure StopAll;\n\n    function FindByName(const AListenerName: string): IMVCListener;\n\n    procedure ForEach(AProc: TProc<string, IMVCListener>);\n    function Count: Integer;\n  end;\n\n  TMVCRequestDelegate = reference to procedure(const AControllerQualifiedClassName, AActionName: string;\n    var AAuthenticationRequired: Boolean);\n\n  TMVCAuthenticationDelegate = reference to procedure(const AUserName, APassword: string; AUserRoles: TList<string>;\n    var IsValid: Boolean; const ASessionData: TDictionary<String, String>);\n\n  TMVCAuthorizationDelegate = reference to procedure(AUserRoles: TList<string>; const AControllerQualifiedClassName: string;\n    const AActionName: string; var IsAuthorized: Boolean);\n\n  IMVCDefaultAuthenticationHandler = interface(IMVCAuthenticationHandler)\n    ['{0B292EEF-B871-4FA9-81AC-FED633C3A238}']\n    function SetOnRequest(AMethod: TMVCRequestDelegate): IMVCDefaultAuthenticationHandler;\n    function SetOnAuthentication(AMethod: TMVCAuthenticationDelegate): IMVCDefaultAuthenticationHandler;\n    function SetOnAuthorization(AMethod: TMVCAuthorizationDelegate): IMVCDefaultAuthenticationHandler;\n  end;\n\nimplementation\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace MVCFramework.Server\n{\n    public class MVCServerException : Exception\n    {\n        public MVCServerException() { }\n        public MVCServerException(string message) : base(message) { }\n        public MVCServerException(string message, Exception innerException) : base(message, innerException) { }\n    }\n\n    public interface IMVCListenerProperties\n    {\n        string Name { get; set; }\n        IMVCListenerProperties SetName(string value);\n\n        int Port { get; set; }\n        IMVCListenerProperties SetPort(int value);\n\n        int MaxConnections { get; set; }\n        IMVCListenerProperties SetMaxConnections(int value);\n\n        Type WebModuleClass { get; set; }\n        IMVCListenerProperties SetWebModuleClass(Type value);\n\n        \n        bool TryGetSSLOptions(out string sslCertFile, out string sslRootCertFile, out string sslKeyFile, out string sslPassword);\n        \n        IMVCListenerProperties SetSSLOptions(string sslCertFile, string sslRootCertFile, string sslKeyFile, string sslPassword);\n    }\n\n    \n    public interface IMVCListener\n    {\n        bool Active { get; }\n        void Start();\n        void Stop();\n    }\n\n    \n    public interface IMVCListenersContext\n    {\n        \n        IMVCListenersContext Add(string name, IMVCListener listener);\n        \n        IMVCListenersContext Add(IMVCListenerProperties properties);\n        \n        IMVCListenersContext Remove(string listenerName);\n\n        \n        void StartAll();\n        \n        void StopAll();\n\n        \n        IMVCListener FindByName(string listenerName);\n\n        \n        void ForEach(Action<string, IMVCListener> action);\n        \n        int Count { get; }\n    }\n\n    \n    public delegate void MVCRequestDelegate(string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n\n    \n    public delegate void MVCAuthenticationDelegate(string userName, string password, List<string> userRoles, ref bool isValid, IDictionary<string, string> sessionData);\n\n    \n    public delegate void MVCAuthorizationDelegate(List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized);\n\n    \n    public interface IMVCDefaultAuthenticationHandler : IMVCAuthenticationHandler\n    {\n        IMVCDefaultAuthenticationHandler SetOnRequest(MVCRequestDelegate method);\n        IMVCDefaultAuthenticationHandler SetOnAuthentication(MVCAuthenticationDelegate method);\n        IMVCDefaultAuthenticationHandler SetOnAuthorization(MVCAuthorizationDelegate method);\n    }\n\n    \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit AuthHandlersU;\n\ninterface\n\nuses\n  MVCFramework.Commons, System.Generics.Collections, MVCFramework;\n\ntype\n  TAuthHandlerBase = class abstract(TInterfacedObject, IMVCAuthenticationHandler)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); virtual; abstract;\n    procedure OnAuthentication(const AContext: TWebContext; const UserName: string; const Password: string;\n      UserRoles: System.Generics.Collections.TList<System.string>;\n      var IsValid: Boolean; const SessionData: TDictionary<string, string>); virtual;\n    procedure OnAuthorization(const AContext: TWebContext;\n      UserRoles: System.Generics.Collections.TList<System.string>;\n      const ControllerQualifiedClassName: string; const ActionName: string;\n      var IsAuthorized: Boolean); virtual;\n  end;\n\n  TBasicAuthHandler = class(TAuthHandlerBase)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); override;\n  end;\n\n  TCustomAuthHandler = class(TAuthHandlerBase)\n  public\n    procedure OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nprocedure TAuthHandlerBase.OnAuthentication(\n  const AContext: TWebContext;\n  const UserName: string; const Password: string;\n  UserRoles: System.Generics.Collections.TList<System.string>; var IsValid: Boolean;\n  const SessionData: TDictionary<string, string>);\nbegin\n  UserRoles.Clear;\n  IsValid := UserName = Password;\n  if not IsValid then\n    Exit;\n  if UserName = 'user1' then\n  begin\n    IsValid := True;\n    UserRoles.Add('role1');\n  end;\n  if UserName = 'user2' then\n  begin\n    IsValid := True;\n    UserRoles.Add('role2');\n  end;\nend;\n\nprocedure TAuthHandlerBase.OnAuthorization(\n  const AContext: TWebContext;\n  UserRoles: System.Generics.Collections.TList<System.string>;\n  const ControllerQualifiedClassName, ActionName: string;\n  var IsAuthorized: Boolean);\nbegin\n  IsAuthorized := False;\n  if (ActionName = 'OnlyRole1') or (ActionName = 'OnlyRole1Session') then\n    IsAuthorized := UserRoles.Contains('role1');\n  if ActionName = 'OnlyRole2' then\n    IsAuthorized := UserRoles.Contains('role2');\nend;\n\nprocedure TBasicAuthHandler.OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean);\nbegin\n  AuthenticationRequired := ControllerQualifiedClassName.EndsWith\n    ('TTestPrivateServerController');\nend;\n\nprocedure TCustomAuthHandler.OnRequest(const AContext: TWebContext; const ControllerQualifiedClassName: string;\n      const ActionName: string; var AuthenticationRequired: Boolean);\nbegin\n  AuthenticationRequired := ControllerQualifiedClassName.EndsWith\n    ('TTestPrivateServerControllerCustomAuth');\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace AuthHandlerU\n{\n    public class WebContext\n    {\n        // Add any context properties as needed.\n    }\n    \n    public interface IMVCAuthenticationHandler\n    {\n        void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n        void OnAuthentication(WebContext context, string userName, string password, List<string> userRoles, ref bool isValid, Dictionary<string, string> sessionData);\n        void OnAuthorization(WebContext context, List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized);\n    }\n    \n    public abstract class AuthHandlerBase : IMVCAuthenticationHandler\n    {\n        public abstract void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired);\n        \n        public virtual void OnAuthentication(WebContext context, string userName, string password, List<string> userRoles, ref bool isValid, Dictionary<string, string> sessionData)\n        {\n            userRoles.Clear();\n            isValid = userName == password;\n            if (!isValid)\n                return;\n            if (userName == \"user1\")\n            {\n                isValid = true;\n                userRoles.Add(\"role1\");\n            }\n            if (userName == \"user2\")\n            {\n                isValid = true;\n                userRoles.Add(\"role2\");\n            }\n        }\n        \n        public virtual void OnAuthorization(WebContext context, List<string> userRoles, string controllerQualifiedClassName, string actionName, ref bool isAuthorized)\n        {\n            isAuthorized = false;\n            if (actionName == \"OnlyRole1\" || actionName == \"OnlyRole1Session\")\n                isAuthorized = userRoles.Contains(\"role1\");\n            if (actionName == \"OnlyRole2\")\n                isAuthorized = userRoles.Contains(\"role2\");\n        }\n    }\n    \n    public class BasicAuthHandler : AuthHandlerBase\n    {\n        public override void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired)\n        {\n            authenticationRequired = controllerQualifiedClassName.EndsWith(\"TTestPrivateServerController\");\n        }\n    }\n    \n    public class CustomAuthHandler : AuthHandlerBase\n    {\n        public override void OnRequest(WebContext context, string controllerQualifiedClassName, string actionName, ref bool authenticationRequired)\n        {\n            authenticationRequired = controllerQualifiedClassName.EndsWith(\"TTestPrivateServerControllerCustomAuth\");\n        }\n    }\n}"}
{"input": "unit Service2U;\n\ninterface\n\nuses\n  ServicesInterfaceU, Spring.Container.Common;\n\ntype\n  TCustomersService = class(TInterfacedObject, ICustomersService)\n  protected\n    [Inject]\n    fCommonService: ICommonService;\n  public\n    function GetCustomerNameByID(const ID: Integer): string;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TCustomersService }\n\nfunction TCustomersService.GetCustomerNameByID(const ID: Integer): string;\nbegin\n  Result := Format('Customer #%d (CommonServiceID = %s)', [ID, fCommonService.GetID]);\nend;\n\nend.", "output": "using System;\nusing ServicesInterfaceU;\nusing Spring.Container.Common;\n\nnamespace ServiceNamespace\n{\n    public class CustomersService : ICustomersService\n    {\n        [Inject]\n        private ICommonService commonService;\n\n        public string GetCustomerNameByID(int id)\n        {\n            return string.Format(\"Customer #{0} (CommonServiceID = {1})\", id, commonService.GetID);\n        }\n    }\n}"}
{"input": "{ Invokable implementation File for TSOAPCustomer which implements ISOAPCustomer }\n\nunit SOAPCustomerImplU;\n\ninterface\n\nuses Soap.InvokeRegistry, System.Types, Soap.XSBuiltIns, SOAPCustomerIntfU;\n\ntype\n\n  { TSOAPCustomer }\n  TSOAPCustomer = class(TInvokableClass, ISOAPCustomer)\n  public\n    function GetCustomers: string; stdcall;\n  end;\n\nimplementation\n\nuses\n  BOCustomersU, WSHelperCustomersU, System.SysUtils, System.JSON, MVCFramework.Serializer.Defaults;\n\nfunction TSOAPCustomer.GetCustomers: string;\nvar\n  WSHelperCustomers: TWSHelperCustomers;\n  Customers: TCustomers;\nbegin\n  WSHelperCustomers := TWSHelperCustomers.Create;\n  try\n    begin\n      Customers := WSHelperCustomers.GetCustomers;\n      try\n        Result := GetDefaultSerializer.SerializeCollection(Customers);\n      finally\n        FreeAndNil(Customers);\n      end;\n    end;\n  finally\n    FreeAndNil(WSHelperCustomers);\n  end;\nend;\n\ninitialization\n\n{ Invokable classes must be registered }\nInvRegistry.RegisterInvokableClass(TSOAPCustomer);\n\nend.", "output": "using System;\nusing System.Web.Services;\nusing SOAPCustomerIntfU;\nusing BOCustomersU;\nusing WSHelperCustomersU;\nusing MVCFramework.Serializer.Defaults;\n\n[WebService(Namespace = \"http://tempuri.org/\")]\n[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]\npublic class SOAPCustomer : WebService, ISOAPCustomer\n{\n    [WebMethod]\n    public string GetCustomers()\n    {\n        WSHelperCustomers wsHelper = new WSHelperCustomers();\n        try\n        {\n            var customers = wsHelper.GetCustomers();\n            try\n            {\n                return GetDefaultSerializer().SerializeCollection(customers);\n            }\n            finally\n            {\n                if (customers is IDisposable disposableCustomers)\n                {\n                    disposableCustomers.Dispose();\n                }\n            }\n        }\n        finally\n        {\n            if (wsHelper is IDisposable disposableWsHelper)\n            {\n                disposableWsHelper.Dispose();\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MainControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/api')]\n  TMainController = class(TMVCController) \n  public\n    [MVCPath]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n\n    [MVCPath('/reversedstrings/($Value)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetReversedString(const Value: String);\n  protected\n    procedure OnBeforeAction(Context: TWebContext; const AActionName: string; var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionName: string); override;\n\n  public\n    //Sample CRUD Actions for a \"Customer\" entity\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomers;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetCustomer(id: Integer);\n\n    [MVCPath('/customers')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure CreateCustomer;\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    procedure UpdateCustomer(id: Integer);\n\n    [MVCPath('/customers/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    procedure DeleteCustomer(id: Integer);\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\nprocedure TMainController.Index;\nbegin\n  //use Context property to access to the HTTP request and response \n  Render('Hello DelphiMVCFramework World');\nend;\n\nprocedure TMainController.GetReversedString(const Value: String);\nbegin\n  Render(System.StrUtils.ReverseString(Value.Trim));\nend;\n\nprocedure TMainController.OnAfterAction(Context: TWebContext; const AActionName: string); \nbegin\n  { Executed after each action }\n  inherited;\nend;\n\nprocedure TMainController.OnBeforeAction(Context: TWebContext; const AActionName: string; var Handled: Boolean);\nbegin\n  { Executed before each action\n    if handled is true (or an exception is raised) the actual\n    action will not be called }\n  inherited;\nend;\n\n//Sample CRUD Actions for a \"Customer\" entity\nprocedure TMainController.GetCustomers;\nbegin\n  //todo: render a list of customers\nend;\n\nprocedure TMainController.GetCustomer(id: Integer);\nbegin\n  //todo: render the customer by id\nend;\n\nprocedure TMainController.CreateCustomer;\n\nbegin\n  //todo: create a new customer\nend;\n\nprocedure TMainController.UpdateCustomer(id: Integer);\nbegin\n  //todo: update customer by id\nend;\n\nprocedure TMainController.DeleteCustomer(id: Integer);\nbegin\n  //todo: delete customer by id\nend;\n\n\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing System;\nusing System.Linq;\n\nnamespace MyMvcApp.Controllers\n{\n    \n    [Route(\"api\")]\n    [ApiController]\n    public class MainController : ControllerBase\n    {\n        \n        [HttpGet]\n        public IActionResult Index()\n        {\n            \n            return Content(\"Hello DelphiMVCFramework World\");\n        }\n\n        \n        [HttpGet(\"reversedstrings/{value}\")]\n        public IActionResult GetReversedString(string value)\n        {\n            if (string.IsNullOrWhiteSpace(value))\n            {\n                return BadRequest(\"Value cannot be empty.\");\n            }\n            \n            string reversed = new string(value.Trim().Reverse().ToArray());\n            return Content(reversed);\n        }\n\n        \n        [HttpGet(\"customers\")]\n        public IActionResult GetCustomers()\n        {\n           \n            return Ok(\"GetCustomers not implemented\");\n        }\n\n        \n        [HttpGet(\"customers/{id:int}\")]\n        public IActionResult GetCustomer(int id)\n        {\n            \n            return Ok($\"GetCustomer {id} not implemented\");\n        }\n\n        \n        [HttpPost(\"customers\")]\n        public IActionResult CreateCustomer()\n        {\n            \n            return Ok(\"CreateCustomer not implemented\");\n        }\n\n        \n        [HttpPut(\"customers/{id:int}\")]\n        public IActionResult UpdateCustomer(int id)\n        {\n            \n            return Ok($\"UpdateCustomer {id} not implemented\");\n        }\n\n        \n        [HttpDelete(\"customers/{id:int}\")]\n        public IActionResult DeleteCustomer(int id)\n        {\n            \n            return Ok($\"DeleteCustomer {id} not implemented\");\n        }\n\n        \n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            \n            base.OnActionExecuting(context);\n        }\n\n        public override void OnActionExecuted(ActionExecutedContext context)\n        {\n            \n            base.OnActionExecuted(context);\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// Contributors for this file: \n//    Fulgan - https://github.com/Fulgan\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.NSQAppender;\n\ninterface\n\nuses Classes, SysUtils, LoggerPro, System.Net.HttpClient;\n\ntype\n\n{\n  Author: St\ufffdphane \"Fulgan\" GROBETY (https://github.com/Fulgan/)\n  Log appender for NSQ (https://nsq.io) (https://github.com/nsqio/nsq)\n  \"NSQ is a realtime message processing system designed to operate at bitly's\n  scale, handling billions of messages per day. It promotes distributed and\n  decentralized topologies without single points of failure, enabling fault\n  tolerance and high availability coupled with a reliable message delivery\n  guarantee\"\n\n  For testing, you can navigate to the NSQ folder and type the following commands:\n\n  This starts the NSQLookup service then starts a listener on the default\n  endpoint(http:/127.0.0.1:4151)\n\n  start nsqlookupd\n  start nsqd --lookupd-tcp-address=127.0.0.1:4160\n\n\n  This starts a consumer for the topic \"test\" that outputs the messages to the console:\n\n  start nsq_tail --topic=test --lookupd-http-address=127.0.0.1:4161\n\n  (optional) This starts a consumer for the ephemeral topic \"test\" that outputs the messages to the console:\n\n  start nsq_tail --topic=test#ephemeral --lookupd-http-address=127.0.0.1:4161\n\n  (optional) This starts a NSQAdmin web interface that can be reached on http://localhost:4171/\n\n  start nsqadmin --lookupd-http-address=127.0.0.1:4161\n\n  Note about consumers:\n  - If there is no consumer to received messages for a channel, NSQ will\n    save them to memory and disk unless the topic has been marked as Ephemeral.\n    Use NSQAdmin to delete any extra channel created.\n  - Ephemeral topics are not saved or cached and the topic will be deleted\n    once the last consumer disconnects\n  - Writing a consumer is more complex than writing a client. A list of available\n    client libraries can be found at https://nsq.io/clients/client_libraries.html\n}\n\n\n  TOnCreateData = procedure(const sender : TObject; const LogItem: TLogItem; var Data: TStream);\n  TOnNetSendError = procedure(const sender : TObject; const LogItem: TLogItem; const NetError: ENetHTTPClientException; var RetryCount: Integer);\n  TLoggerProNSQAppenderBase = class(TLoggerProAppenderBase, ILogAppender)\n  private\n    FOnCreateData: TOnCreateData;\n    FOnNetSendError: TOnNetSendError;\n    procedure SetOnCreateData(const Value: TOnCreateData);\n    procedure SetOnNetSendError(const Value: TOnNetSendError);\n  protected\n    FNSQUrl : string;\n    FTopic: String;\n    FUserName, FMachineName: string;\n    FEphemeral: Boolean;\n    FLastSignature: string;\n  public\n    const DEFAULT_NSQ_URL = 'http://127.0.0.1:4151';\n\n    function GetNSQUrl: string;\n    procedure SetNSQUrl(const Value: string);\n    function GetTopic: string;\n    procedure SetTopic(const Value: string);\n    procedure SetEphemeral(const Value: Boolean);\n    /// <summary>TLoggerProNSQAppenderBase.Create\n    /// </summary>\n    /// <param name=\"aTopic\"> (string) This is the \"topic\" of the channel. If left\n    /// empty, the LogItem's tag will be used. </param>\n    /// <param name=\"aEphemeral\"> (Boolean) If true, the NSQ channel will be marked as\n    /// Ephemeral: messages sent to this channel will neither be cached nor\n    /// queued</param>\n    /// <param name=\"aNSQUrl\"> (string) URL of the NSQD service (usually, http://127.0.\n    /// 0.1:4151)</param>\n    /// <param name=\"aLogFormat\"> (string) Log format to use if no custom log message\n    /// creation event is defined </param>\n    constructor Create(aTopic: string=''; aEphemeral: Boolean = False;\n        aNSQUrl: string=DEFAULT_NSQ_URL;\n        aLogItemRenderer: ILogItemRenderer = nil);\n        reintroduce;\n    property NSQUrl: string read GetNSQUrl write SetNSQUrl;\n    property Ephemeral: Boolean read FEphemeral write SetEphemeral;\n    property OnCreateData: TOnCreateData read FOnCreateData write SetOnCreateData;\n    property OnNetSendError: TOnNetSendError read FOnNetSendError write SetOnNetSendError;\n    property Topic: string read GetTopic write SetTopic;\n    procedure TearDown; override;\n    procedure Setup; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n    function CreateData(const SrcLogItem: TLogItem): TStream; virtual;\n  end;\n\nimplementation\n\nuses  System.NetEncoding;\n\nconstructor TLoggerProNSQAppenderBase.Create(aTopic: string; aEphemeral: Boolean;\n  aNSQUrl: string; aLogItemRenderer: ILogItemRenderer);\nbegin\n  inherited Create(aLogItemRenderer);\n  FEphemeral := aEphemeral;\n  FNSQUrl := 'http://127.0.0.1:4151';\n  FUserName := aNSQUrl;\n  FTopic := aTopic;\nend;\n\nfunction TLoggerProNSQAppenderBase.CreateData(\n  const SrcLogItem: TLogItem): TStream;\nbegin\n  result := nil;\n  try\n    if assigned(FOnCreateData) then\n    begin\n      FOnCreateData(Self, SrcLogItem, Result);\n    end\n    else\n    begin\n      result := TStringStream.Create(FormatLog(SrcLogItem), TEncoding.UTF8);\n    end;\n  except\n    on e: Exception do\n    begin\n      FreeAndNil(Result);\n      raise;\n    end;\n  end;\nend;\n\nfunction TLoggerProNSQAppenderBase.GetNSQUrl: string;\nbegin\n  result := FNSQUrl;\nend;\n\nfunction TLoggerProNSQAppenderBase.GetTopic: string;\nbegin\n  result := FTopic;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetEphemeral(const Value: Boolean);\nbegin\n  FEphemeral := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetNSQUrl(const Value: string);\nbegin\n  FNSQUrl := value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetOnCreateData(const Value: TOnCreateData);\nbegin\n  FOnCreateData := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetOnNetSendError(\n  const Value: TOnNetSendError);\nbegin\n  FOnNetSendError := Value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.SetTopic(const Value: string);\nbegin\n  FTopic := value;\nend;\n\nprocedure TLoggerProNSQAppenderBase.Setup;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProNSQAppenderBase.TearDown;\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProNSQAppenderBase.WriteLog(const aLogItem: TLogItem);\nvar\n  FHTTPCli: THTTPClient;\n  URI: string;\n  Data: TStream;\n  TopicName: string;\n  FRetryCount: Integer;\nbegin\n  FRetryCount := 0;\n  FHTTPCli := THTTPClient.Create;\n  try\n    if Topic.trim.IsEmpty then\n      TopicName := aLogItem.LogTag.Trim\n    else\n      TopicName := Topic.Trim;\n    URI :=NSQUrl + '/pub?topic=' + TNetEncoding.URL.Encode(TopicName);\n    if Ephemeral then\n      URI := URI + '#ephemeral';\n    Data := CreateData(aLogItem);\n    if Assigned(Data) then\n    begin\n      repeat\n        try\n          // Set very short timeouts: this is a local call and we don't want to block the queue for too long.\n{$IF CompilerVersion >= 31}\n          FHTTPCli.ConnectionTimeout := 100;\n          FHTTPCli.ResponseTimeout := 200;\n{$ENDIF}\n          Data.Seek(0, soFromBeginning);\n          // ignore the respnse: as long as NSQD has accepted the POST, it will handle the result\n          FHTTPCli.Post(URI, Data);\n          break;\n        except\n          on e: ENetHTTPClientException do\n          begin\n            // if there is an event handler for net exception, call it\n            if Assigned(FOnNetSendError) then\n              OnNetSendError(self, aLogItem, e, FRetryCount);\n            // if the handler has set FRetryCount to a positive value then retry the call\n            if FRetryCount <= 0 then\n              break;\n          end;\n        end;\n      until false;\n    end;\n  finally\n    FreeAndNil(FHTTPCli);\n  end;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Net.Http.Json;\nusing System.Text;\nusing LoggerPro; \nusing System.Threading.Tasks;\nusing System.Web;\n\nnamespace LoggerPro.Appenders\n{\n    \n    public delegate void OnCreateData(object sender, TLogItem logItem, out Stream data);\n    public delegate void OnNetSendError(object sender, TLogItem logItem, Exception netError, ref int retryCount);\n\n    \n    public class LoggerProNSQAppenderBase : LoggerProAppenderBase, ILogAppender\n    {\n        public const string DEFAULT_NSQ_URL = \"http://127.0.0.1:4151\";\n\n        \n        private OnCreateData _onCreateData;\n        private OnNetSendError _onNetSendError;\n\n        \n        private string _nsqUrl;\n        private string _topic;\n        private bool _ephemeral;\n        \n        private string _userName;\n        private string _machineName;\n        private string _lastSignature;\n\n        public LoggerProNSQAppenderBase(string topic = \"\", bool ephemeral = false, string nsqUrl = DEFAULT_NSQ_URL, ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n            \n            _ephemeral = ephemeral;\n            _nsqUrl = nsqUrl; \n            _userName = nsqUrl; \n            _topic = topic;\n        }\n\n       \n        public string NSQUrl\n        {\n            get => _nsqUrl;\n            set => _nsqUrl = value;\n        }\n\n        \n        public string Topic\n        {\n            get => _topic;\n            set => _topic = value;\n        }\n\n        \n        public bool Ephemeral\n        {\n            get => _ephemeral;\n            set => _ephemeral = value;\n        }\n\n        public OnCreateData OnCreateData\n        {\n            get => _onCreateData;\n            set => _onCreateData = value;\n        }\n\n        public OnNetSendError OnNetSendError\n        {\n            get => _onNetSendError;\n            set => _onNetSendError = value;\n        }\n\n        \n        public override void Setup()\n        {\n            base.Setup();\n            \n        }\n\n        \n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        \n        public virtual Stream CreateData(TLogItem srcLogItem)\n        {\n            try\n            {\n                if (OnCreateData != null)\n                {\n                    OnCreateData(this, srcLogItem, out Stream data);\n                    return data;\n                }\n                else\n                {\n                    \n                    string logText = FormatLog(srcLogItem);\n                    return new MemoryStream(Encoding.UTF8.GetBytes(logText));\n                }\n            }\n            catch (Exception)\n            {\n                \n                throw;\n            }\n        }\n\n        \n        public override void WriteLog(TLogItem logItem)\n        {\n            int retryCount = 0;\n            \n            using (HttpClient httpClient = new HttpClient())\n            {\n                \n                string topicName = string.IsNullOrWhiteSpace(Topic) ? logItem.LogTag.Trim() : Topic.Trim();\n\n                \n                string uri = NSQUrl.TrimEnd('/') + \"/pub?topic=\" + HttpUtility.UrlEncode(topicName);\n                if (Ephemeral)\n                {\n                    uri += \"#ephemeral\";\n                }\n\n                \n                Stream data = CreateData(logItem);\n                if (data != null)\n                {\n                    while (true)\n                    {\n                        try\n                        {\n                            \n                            httpClient.Timeout = TimeSpan.FromMilliseconds(200);\n                            data.Seek(0, SeekOrigin.Begin);\n                            \n                            using (var content = new StreamContent(data))\n                            {\n                                \n                                content.Headers.ContentType = new MediaTypeHeaderValue(\"text/plain\")\n                                {\n                                    CharSet = \"utf-8\"\n                                };\n                                \n                                HttpResponseMessage response = httpClient.PostAsync(uri, content).Result;\n                                response.EnsureSuccessStatusCode();\n                            }\n                            break;\n                        }\n                        catch (HttpRequestException ex)\n                        {\n                            \n                            if (OnNetSendError != null)\n                            {\n                                OnNetSendError(this, logItem, ex, ref retryCount);\n                            }\n                            retryCount++;\n                            if (retryCount >= 5) \n                            {\n                                \n                                throw;\n                            }\n                            \n                            System.Threading.Thread.Sleep(200);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"}
{"input": "unit MultipleLoggersU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,\n  System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, LoggerPro, Vcl.StdCtrls;\n\ntype\n  TMultipleLoggersForm = class(TForm)\n    Memo1: TMemo;\n    btnFormLocalLog: TButton;\n    btnApplicationLevelLog: TButton;\n    procedure FormCreate(Sender: TObject);\n    procedure btnFormLocalLogClick(Sender: TObject);\n    procedure btnApplicationLevelLogClick(Sender: TObject);\n  private\n    FLogWriter: ILogWriter;\n    function LocalLog: ILogWriter;\n  public\n    { Public declarations }\n  end;\n\nvar\n  MultipleLoggersForm: TMultipleLoggersForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender, LoggerProConfig;\n\n{$R *.dfm}\n\nprocedure TMultipleLoggersForm.btnApplicationLevelLogClick(Sender: TObject);\nbegin\n  Log.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the application level LoggerPro instance (random type)',\n    'APP');\nend;\n\nprocedure TMultipleLoggersForm.btnFormLocalLogClick(Sender: TObject);\nbegin\n  LocalLog.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the form local LoggerPro instance (random type)', 'tag');\nend;\n\nprocedure TMultipleLoggersForm.FormCreate(Sender: TObject);\nbegin\n  FLogWriter := BuildLogWriter([TVCLMemoLogAppender.Create(Memo1)], nil,\n    TLogType.Info);\n  FLogWriter.Info('Local log correctly initialized', 'tag');\nend;\n\nfunction TMultipleLoggersForm.LocalLog: ILogWriter;\nbegin\n  Result := FLogWriter;\nend;\n\nend.", "output": "unit MultipleLoggersU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,\n  System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, LoggerPro, Vcl.StdCtrls;\n\ntype\n  TMultipleLoggersForm = class(TForm)\n    Memo1: TMemo;\n    btnFormLocalLog: TButton;\n    btnApplicationLevelLog: TButton;\n    procedure FormCreate(Sender: TObject);\n    procedure btnFormLocalLogClick(Sender: TObject);\n    procedure btnApplicationLevelLogClick(Sender: TObject);\n  private\n    FLogWriter: ILogWriter;\n    function LocalLog: ILogWriter;\n  public\n    { Public declarations }\n  end;\n\nvar\n  MultipleLoggersForm: TMultipleLoggersForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender, LoggerProConfig;\n\n{$R *.dfm}\n\nprocedure TMultipleLoggersForm.btnApplicationLevelLogClick(Sender: TObject);\nbegin\n  Log.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the application level LoggerPro instance (random type)',\n    'APP');\nend;\n\nprocedure TMultipleLoggersForm.btnFormLocalLogClick(Sender: TObject);\nbegin\n  LocalLog.Log(TLogType(Random(Ord(TLogType.Fatal) + 1)),\n    'Message sent to the form local LoggerPro instance (random type)', 'tag');\nend;\n\nprocedure TMultipleLoggersForm.FormCreate(Sender: TObject);\nbegin\n  FLogWriter := BuildLogWriter([TVCLMemoLogAppender.Create(Memo1)], nil,\n    TLogType.Info);\n  FLogWriter.Info('Local log correctly initialized', 'tag');\nend;\n\nfunction TMultipleLoggersForm.LocalLog: ILogWriter;\nbegin\n  Result := FLogWriter;\nend;\n\nend."}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.RQL.AST2PostgreSQL;\n\ninterface\n\nuses\n  MVCFramework.RQL.Parser;\n\ntype\n  TRQLPostgreSQLCompiler = class(TRQLCompiler)\n  private\n    function RQLFilterToSQL(const aRQLFIlter: TRQLFilter): string;\n    function RQLSortToSQL(const aRQLSort: TRQLSort): string;\n    function RQLLimitToSQL(const aRQLLimit: TRQLLimit): string;\n    function RQLWhereToSQL(const aRQLWhere: TRQLWhere): string;\n    function RQLLogicOperatorToSQL(const aRQLFIlter: TRQLLogicOperator): string;\n  protected\n    function RQLCustom2SQL(const aRQLCustom: TRQLCustom): string; override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  FireDAC.Phys.PG;\n\n{ TRQLPostgreSQLCompiler }\n\nfunction TRQLPostgreSQLCompiler.RQLCustom2SQL(\n  const aRQLCustom: TRQLCustom): string;\nbegin\n  if aRQLCustom is TRQLFilter then\n  begin\n    Result := RQLFilterToSQL(TRQLFilter(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLLogicOperator then\n  begin\n    Result := RQLLogicOperatorToSQL(TRQLLogicOperator(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLSort then\n  begin\n    Result := RQLSortToSQL(TRQLSort(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLLimit then\n  begin\n    Result := RQLLimitToSQL(TRQLLimit(aRQLCustom));\n  end\n  else if aRQLCustom is TRQLWhere then\n  begin\n    Result := RQLWhereToSQL(TRQLWhere(aRQLCustom));\n  end\n  else\n    raise ERQLException.CreateFmt('Unknown token in compiler: %s', [aRQLCustom.ClassName]);\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLFilterToSQL(const aRQLFIlter: TRQLFilter): string;\nvar\n  lValue, lDBFieldName: string;\nbegin\n  if (aRQLFIlter.RightValueType = vtString) and not(aRQLFIlter.Token in [tkContains, tkStarts]) then\n    lValue := aRQLFIlter.OpRight.QuotedString('''')\n  else\n    lValue := aRQLFIlter.OpRight;\n\n  lDBFieldName := GetDatabaseFieldName(aRQLFIlter.OpLeft, True);\n\n  case aRQLFIlter.Token of\n    tkEq:\n      begin\n        if aRQLFIlter.RightValueType = vtNull then\n          Result := Format('(%s IS NULL)', [GetFieldNameForSQL(lDBFieldName)])\n        else\n          Result := Format('(%s = %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkLt:\n      begin\n        Result := Format('(%s < %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkLe:\n      begin\n        Result := Format('(%s <= %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkGt:\n      begin\n        Result := Format('(%s > %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkGe:\n      begin\n        Result := Format('(%s >= %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkNe:\n      begin\n        if aRQLFIlter.RightValueType = vtNull then\n          Result := Format('(%s IS NOT NULL)', [GetFieldNameForSQL(lDBFieldName)])\n        else\n          Result := Format('(%s != %s)', [GetFieldNameForSQL(lDBFieldName), lValue]);\n      end;\n    tkContains:\n      begin\n        lValue := Format('%%%s%%', [lValue]).QuotedString('''');\n        Result := Format('(%s ILIKE %s)', [GetFieldNameForSQL(lDBFieldName), lValue.ToLower])\n      end;\n    tkStarts:\n      begin\n        lValue := Format('%s%%', [lValue]).QuotedString('''');\n        Result := Format('(%s ILIKE %s)', [GetFieldNameForSQL(lDBFieldName), lValue.ToLower])\n      end;\n    tkIn:\n      begin\n        case aRQLFIlter.RightValueType of\n          vtIntegerArray: // if array is empty, RightValueType is always vtIntegerArray\n            begin\n              Result := Format('(%s IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', aRQLFIlter.OpRightArray)\n                ]);\n            end;\n          vtStringArray:\n            begin\n              Result := Format('(%s IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', QuoteStringArray(aRQLFIlter.OpRightArray))\n                ]);\n            end;\n        else\n          raise ERQLException.Create('Invalid RightValueType for tkIn');\n        end;\n      end;\n    tkOut:\n      begin\n        case aRQLFIlter.RightValueType of\n          vtIntegerArray:\n            begin\n              Result := Format('(%s NOT IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', aRQLFIlter.OpRightArray)\n                ]);\n            end;\n          vtStringArray:\n            begin\n              Result := Format('(%s NOT IN (%s))', [\n                GetFieldNameForSQL(lDBFieldName), string.Join(',', QuoteStringArray(aRQLFIlter.OpRightArray))\n                ]);\n            end;\n        else\n          raise ERQLException.Create('Invalid RightValueType for tkOut');\n        end;\n      end;\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLLimitToSQL(const aRQLLimit: TRQLLimit): string;\nbegin\n  if aRQLLimit.Start = 0 then\n  begin\n    Result := Format(' /*limit*/ LIMIT %d', [aRQLLimit.Count]);\n  end\n  else\n  begin\n    Result := Format(' /*limit*/ LIMIT %d OFFSET %d', [aRQLLimit.Count, aRQLLimit.Start]);\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLLogicOperatorToSQL(const aRQLFIlter: TRQLLogicOperator): string;\nvar\n  lJoin: string;\n  lRQLCustom: TRQLCustom;\n  lFirst: Boolean;\nbegin\n  case aRQLFIlter.Token of\n    tkAnd:\n      begin\n        lJoin := ' and ';\n      end;\n    tkOr:\n      begin\n        lJoin := ' or ';\n      end;\n  else\n    raise ERQLException.Create('Invalid token in RQLLogicOperator');\n  end;\n\n  Result := '';\n  lFirst := True;\n  for lRQLCustom in aRQLFIlter.FilterAST do\n  begin\n    if not lFirst then\n    begin\n      Result := Result + lJoin;\n    end;\n    lFirst := False;\n    Result := Result + RQLCustom2SQL(lRQLCustom);\n  end;\n  Result := '(' + Result + ')';\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLSortToSQL(const aRQLSort: TRQLSort): string;\nvar\n  I: Integer;\nbegin\n  Result := ' /*sort*/ ORDER BY';\n  for I := 0 to aRQLSort.Fields.Count - 1 do\n  begin\n    if I > 0 then\n      Result := Result + ',';\n    Result := Result + ' ' + GetFieldNameForSQL(GetDatabaseFieldName(aRQLSort.Fields[I], True));\n    if aRQLSort.Signs[I] = '+' then\n      Result := Result + ' ASC'\n    else\n      Result := Result + ' DESC';\n  end;\nend;\n\nfunction TRQLPostgreSQLCompiler.RQLWhereToSQL(const aRQLWhere: TRQLWhere): string;\nbegin\n  Result := ' WHERE ';\nend;\n\ninitialization\n\nTRQLCompilerRegistry.Instance.RegisterCompiler('postgresql', TRQLPostgreSQLCompiler);\n\nfinalization\n\nTRQLCompilerRegistry.Instance.UnRegisterCompiler('postgresql');\n\nend.", "output": "using System;\nusing System.Linq;\nusing System.Globalization;\nusing MVCFramework.RQL.Parser; \nusing MVCFramework.ActiveRecord; \n\nnamespace MVCFramework.RQL.AST2PostgreSQL\n{\n    \n    public class RQLPostgreSQLCompiler : RQLCompiler\n    {\n        \n        private string RQLFilterToSQL(TRQLFilter filter)\n        {\n            string value;\n            \n            if (filter.RightValueType == ValueTypeEnum.vtString &&\n                !(filter.Token == TokenType.tkContains || filter.Token == TokenType.tkStarts))\n            {\n                \n                value = QuoteString(filter.OpRight, \"'\");\n            }\n            else\n            {\n                value = filter.OpRight;\n            }\n\n            \n            string dbFieldName = GetDatabaseFieldName(filter.OpLeft, true);\n            string sqlField = GetFieldNameForSQL(dbFieldName);\n\n            switch (filter.Token)\n            {\n                case TokenType.tkEq:\n                    if (filter.RightValueType == ValueTypeEnum.vtNull)\n                        return $\"({sqlField} IS NULL)\";\n                    else\n                        return $\"({sqlField} = {value})\";\n\n                case TokenType.tkLt:\n                    return $\"({sqlField} < {value})\";\n\n                case TokenType.tkLe:\n                    return $\"({sqlField} <= {value})\";\n\n                case TokenType.tkGt:\n                    return $\"({sqlField} > {value})\";\n\n                case TokenType.tkGe:\n                    return $\"({sqlField} >= {value})\";\n\n                case TokenType.tkNe:\n                    if (filter.RightValueType == ValueTypeEnum.vtNull)\n                        return $\"({sqlField} IS NOT NULL)\";\n                    else\n                        return $\"({sqlField} != {value})\";\n\n                case TokenType.tkContains:\n                    {\n                        \n                        string likeValue = QuoteString($\"%{value.Trim('\\'')}%\", \"'\");\n                        \n                        return $\"({sqlField} ILIKE {likeValue.ToLowerInvariant()})\";\n                    }\n                case TokenType.tkStarts:\n                    {\n                        string likeValue = QuoteString($\"{value.Trim('\\'')}%\", \"'\");\n                        return $\"({sqlField} ILIKE {likeValue.ToLowerInvariant()})\";\n                    }\n                case TokenType.tkIn:\n                    {\n                        if (filter.RightValueType == ValueTypeEnum.vtIntegerArray)\n                        {\n                            string joined = string.Join(\",\", filter.OpRightArray);\n                            return $\"({sqlField} IN ({joined}))\";\n                        }\n                        else if (filter.RightValueType == ValueTypeEnum.vtStringArray)\n                        {\n                            string[] quotedArray = QuoteStringArray(filter.OpRightArray, \"'\");\n                            string joined = string.Join(\",\", quotedArray);\n                            return $\"({sqlField} IN ({joined}))\";\n                        }\n                        else\n                        {\n                            throw new RQLException(\"Invalid RightValueType for tkIn\");\n                        }\n                    }\n                case TokenType.tkOut:\n                    {\n                        if (filter.RightValueType == ValueTypeEnum.vtIntegerArray)\n                        {\n                            string joined = string.Join(\",\", filter.OpRightArray);\n                            return $\"({sqlField} NOT IN ({joined}))\";\n                        }\n                        else if (filter.RightValueType == ValueTypeEnum.vtStringArray)\n                        {\n                            string[] quotedArray = QuoteStringArray(filter.OpRightArray, \"'\");\n                            string joined = string.Join(\",\", quotedArray);\n                            return $\"({sqlField} NOT IN ({joined}))\";\n                        }\n                        else\n                        {\n                            throw new RQLException(\"Invalid RightValueType for tkOut\");\n                        }\n                    }\n                default:\n                    throw new RQLException($\"Unsupported filter token: {filter.Token}\");\n            }\n        }\n\n        \n        private string RQLLimitToSQL(TRQLLimit limit)\n        {\n            if (limit.Start == 0)\n            {\n                return $\" /*limit*/ LIMIT {limit.Count}\";\n            }\n            else\n            {\n                return $\" /*limit*/ LIMIT {limit.Count} OFFSET {limit.Start}\";\n            }\n        }\n\n        \n        private string RQLLogicOperatorToSQL(TRQLLogicOperator logicOp)\n        {\n            string joinOp = logicOp.Token == TokenType.tkAnd ? \" and \" :\n                            logicOp.Token == TokenType.tkOr ? \" or \" :\n                            throw new RQLException(\"Invalid token in RQLLogicOperator\");\n\n            bool first = true;\n            string sql = \"\";\n            foreach (TRQLCustom token in logicOp.FilterAST)\n            {\n                if (!first)\n                {\n                    sql += joinOp;\n                }\n                first = false;\n                sql += RQLCustom2SQL(token);\n            }\n            return \"(\" + sql + \")\";\n        }\n\n        \n        private string RQLSortToSQL(TRQLSort sort)\n        {\n            string sql = \" /*sort*/ ORDER BY\";\n            for (int i = 0; i < sort.Fields.Count; i++)\n            {\n                if (i > 0)\n                {\n                    sql += \",\";\n                }\n                string field = GetDatabaseFieldName(sort.Fields[i], true);\n                string sqlField = GetFieldNameForSQL(field);\n                sql += \" \" + sqlField;\n                sql += sort.Signs[i] == \"+\" ? \" ASC\" : \" DESC\";\n            }\n            return sql;\n        }\n\n        \n        private string RQLWhereToSQL(TRQLWhere where)\n        {\n            return \" WHERE \";\n        }\n\n        \n        protected override string RQLCustom2SQL(TRQLCustom rqlCustom)\n        {\n            if (rqlCustom is TRQLFilter filter)\n            {\n                return RQLFilterToSQL(filter);\n            }\n            else if (rqlCustom is TRQLLogicOperator logicOp)\n            {\n                return RQLLogicOperatorToSQL(logicOp);\n            }\n            else if (rqlCustom is TRQLSort sort)\n            {\n                return RQLSortToSQL(sort);\n            }\n            else if (rqlCustom is TRQLLimit limit)\n            {\n                return RQLLimitToSQL(limit);\n            }\n            else if (rqlCustom is TRQLWhere where)\n            {\n                return RQLWhereToSQL(where);\n            }\n            else\n            {\n                throw new RQLException($\"Unknown token in compiler: {rqlCustom.GetType().Name}\");\n            }\n        }\n    }\n\n    \n    public static class RQLPostgreSQLCompilerRegistration\n    {\n        static RQLPostgreSQLCompilerRegistration()\n        {\n            \n            RQLCompilerRegistry.Instance.RegisterCompiler(\"postgresql\", typeof(RQLPostgreSQLCompiler));\n        }\n\n        \n        public static void Unregister()\n        {\n            RQLCompilerRegistry.Instance.UnRegisterCompiler(\"postgresql\");\n        }\n    }\n}"}
{"input": "unit StorageU;\n\ninterface\n\nconst\n  TITLES: array [1 .. 4] of string = ('IBM', 'AAPL', 'GOOG', 'MSFT');\n\nfunction GetNextDataToSend(const LastID: Integer;\n  out CurrentEventID: Integer): string;\n\nimplementation\n\nuses\n  System.JSON;\n\nfunction GetNextDataToSend(const LastID: Integer;\n  out CurrentEventID: Integer): string;\nvar\n  lIndex: Integer;\n  lJOBJ: TJSONObject;\nbegin\n  // You can get the \"next\" event reading the LastID or, as in this case,\n  // just send another event\n\n  lIndex := LastID;\n  while lIndex = LastID do\n  begin\n    lIndex := Random(Length(Titles)) + 1;\n  end;\n\n  lJOBJ := TJSONObject.Create;\n  try\n    lJOBJ.AddPair('stock', TITLES[lIndex]);\n    lJOBJ.AddPair('value', TJSONNumber.Create((500 + Random(200)) +\n      (Random(50) / 100)));\n    Result := lJOBJ.ToJSON;\n    CurrentEventID := LastID + 1;\n  finally\n    lJOBJ.Free;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace YourNamespace\n{\n    public static class Storage\n    {\n        private static readonly string[] Titles = { \"IBM\", \"AAPL\", \"GOOG\", \"MSFT\" };\n        private static readonly Random RandomInstance = new Random();\n\n        public static string GetNextDataToSend(int lastID, out int currentEventID)\n        {\n            int index = lastID;\n            while (index == lastID)\n            {\n                index = RandomInstance.Next(1, Titles.Length + 1);\n            }\n            double value = (500 + RandomInstance.Next(0, 200)) + (RandomInstance.Next(0, 50) / 100.0);\n            var jsonData = new Dictionary<string, object>\n            {\n                { \"stock\", Titles[index - 1] },\n                { \"value\", value }\n            };\n            currentEventID = lastID + 1;\n            return JsonSerializer.Serialize(jsonData);\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n// \n// THIS FILE IS GENERATED BY \"inv generate-nullables\" DO NOT CHANGE MANUALLY!\n// \n// ***************************************************************************\n//\n// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nunit MVCFramework.Nullables;\n\ninterface\n\nuses\n  System.SysUtils, System.Classes, System.TypInfo, System.RTTI;\n\ntype\n  EMVCNullable = class(Exception)\n\n  end;\n\n//**************************\n// ** NullableString\n//**************************\n\n  NullableString = record\n  private\n    fValue: String;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: String;\n    procedure SetValue(const Value: String);\n    class operator Implicit(const Value: String): NullableString;\n    class operator Implicit(const Value: NullableString): String;\n    class operator Implicit(const Value: Pointer): NullableString;\t\n\t  class operator Equal(LeftValue: NullableString; RightValue: NullableString) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableString contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableString contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: String;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: String): String;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableString): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: String): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: String read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableCurrency\n//**************************\n\n  NullableCurrency = record\n  private\n    fValue: Currency;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Currency;\n    procedure SetValue(const Value: Currency);\n    class operator Implicit(const Value: Currency): NullableCurrency;\n    class operator Implicit(const Value: NullableCurrency): Currency;\n    class operator Implicit(const Value: Pointer): NullableCurrency;\t\n\t  class operator Equal(LeftValue: NullableCurrency; RightValue: NullableCurrency) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableCurrency contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableCurrency contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Currency;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Currency): Currency;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableCurrency): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Currency): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Currency read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableBoolean\n//**************************\n\n  NullableBoolean = record\n  private\n    fValue: Boolean;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Boolean;\n    procedure SetValue(const Value: Boolean);\n    class operator Implicit(const Value: Boolean): NullableBoolean;\n    class operator Implicit(const Value: NullableBoolean): Boolean;\n    class operator Implicit(const Value: Pointer): NullableBoolean;\t\n\t  class operator Equal(LeftValue: NullableBoolean; RightValue: NullableBoolean) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableBoolean contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableBoolean contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Boolean;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Boolean): Boolean;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableBoolean): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Boolean): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Boolean read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTDate\n//**************************\n\n  NullableTDate = record\n  private\n    fValue: TDate;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TDate;\n    procedure SetValue(const Value: TDate);\n    class operator Implicit(const Value: TDate): NullableTDate;\n    class operator Implicit(const Value: NullableTDate): TDate;\n    class operator Implicit(const Value: Pointer): NullableTDate;\t\n\t  class operator Equal(LeftValue: NullableTDate; RightValue: NullableTDate) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTDate contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTDate contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TDate;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TDate): TDate;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTDate): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TDate): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TDate read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTTime\n//**************************\n\n  NullableTTime = record\n  private\n    fValue: TTime;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TTime;\n    procedure SetValue(const Value: TTime);\n    class operator Implicit(const Value: TTime): NullableTTime;\n    class operator Implicit(const Value: NullableTTime): TTime;\n    class operator Implicit(const Value: Pointer): NullableTTime;\t\n\t  class operator Equal(LeftValue: NullableTTime; RightValue: NullableTTime) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTTime contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTTime contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TTime;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TTime): TTime;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTTime): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TTime): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TTime read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTDateTime\n//**************************\n\n  NullableTDateTime = record\n  private\n    fValue: TDateTime;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TDateTime;\n    procedure SetValue(const Value: TDateTime);\n    class operator Implicit(const Value: TDateTime): NullableTDateTime;\n    class operator Implicit(const Value: NullableTDateTime): TDateTime;\n    class operator Implicit(const Value: Pointer): NullableTDateTime;\t\n\t  class operator Equal(LeftValue: NullableTDateTime; RightValue: NullableTDateTime) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTDateTime contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTDateTime contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TDateTime;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TDateTime): TDateTime;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTDateTime): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TDateTime): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TDateTime read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableSingle\n//**************************\n\n  NullableSingle = record\n  private\n    fValue: Single;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Single;\n    procedure SetValue(const Value: Single);\n    class operator Implicit(const Value: Single): NullableSingle;\n    class operator Implicit(const Value: NullableSingle): Single;\n    class operator Implicit(const Value: Pointer): NullableSingle;\t\n\t  class operator Equal(LeftValue: NullableSingle; RightValue: NullableSingle) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableSingle contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableSingle contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Single;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Single): Single;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableSingle): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Single): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Single read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableDouble\n//**************************\n\n  NullableDouble = record\n  private\n    fValue: Double;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Double;\n    procedure SetValue(const Value: Double);\n    class operator Implicit(const Value: Double): NullableDouble;\n    class operator Implicit(const Value: NullableDouble): Double;\n    class operator Implicit(const Value: Pointer): NullableDouble;\t\n\t  class operator Equal(LeftValue: NullableDouble; RightValue: NullableDouble) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableDouble contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableDouble contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Double;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Double): Double;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableDouble): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Double): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Double read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableExtended\n//**************************\n\n  NullableExtended = record\n  private\n    fValue: Extended;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Extended;\n    procedure SetValue(const Value: Extended);\n    class operator Implicit(const Value: Extended): NullableExtended;\n    class operator Implicit(const Value: NullableExtended): Extended;\n    class operator Implicit(const Value: Pointer): NullableExtended;\t\n\t  class operator Equal(LeftValue: NullableExtended; RightValue: NullableExtended) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableExtended contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableExtended contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Extended;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Extended): Extended;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableExtended): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Extended): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Extended read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableInt16\n//**************************\n\n  NullableInt16 = record\n  private\n    fValue: Int16;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Int16;\n    procedure SetValue(const Value: Int16);\n    class operator Implicit(const Value: Int16): NullableInt16;\n    class operator Implicit(const Value: NullableInt16): Int16;\n    class operator Implicit(const Value: Pointer): NullableInt16;\t\n\t  class operator Equal(LeftValue: NullableInt16; RightValue: NullableInt16) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableInt16 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableInt16 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Int16;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Int16): Int16;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableInt16): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Int16): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Int16 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableUInt16\n//**************************\n\n  NullableUInt16 = record\n  private\n    fValue: UInt16;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: UInt16;\n    procedure SetValue(const Value: UInt16);\n    class operator Implicit(const Value: UInt16): NullableUInt16;\n    class operator Implicit(const Value: NullableUInt16): UInt16;\n    class operator Implicit(const Value: Pointer): NullableUInt16;\t\n\t  class operator Equal(LeftValue: NullableUInt16; RightValue: NullableUInt16) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableUInt16 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableUInt16 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: UInt16;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: UInt16): UInt16;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableUInt16): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: UInt16): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: UInt16 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableInt32\n//**************************\n\n  NullableInt32 = record\n  private\n    fValue: Int32;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Int32;\n    procedure SetValue(const Value: Int32);\n    class operator Implicit(const Value: Int32): NullableInt32;\n    class operator Implicit(const Value: NullableInt32): Int32;\n    class operator Implicit(const Value: Pointer): NullableInt32;\t\n\t  class operator Equal(LeftValue: NullableInt32; RightValue: NullableInt32) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableInt32 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableInt32 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Int32;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Int32): Int32;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableInt32): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Int32): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Int32 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableUInt32\n//**************************\n\n  NullableUInt32 = record\n  private\n    fValue: UInt32;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: UInt32;\n    procedure SetValue(const Value: UInt32);\n    class operator Implicit(const Value: UInt32): NullableUInt32;\n    class operator Implicit(const Value: NullableUInt32): UInt32;\n    class operator Implicit(const Value: Pointer): NullableUInt32;\t\n\t  class operator Equal(LeftValue: NullableUInt32; RightValue: NullableUInt32) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableUInt32 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableUInt32 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: UInt32;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: UInt32): UInt32;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableUInt32): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: UInt32): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: UInt32 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableInt64\n//**************************\n\n  NullableInt64 = record\n  private\n    fValue: Int64;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: Int64;\n    procedure SetValue(const Value: Int64);\n    class operator Implicit(const Value: Int64): NullableInt64;\n    class operator Implicit(const Value: NullableInt64): Int64;\n    class operator Implicit(const Value: Pointer): NullableInt64;\t\n\t  class operator Equal(LeftValue: NullableInt64; RightValue: NullableInt64) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableInt64 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableInt64 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: Int64;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: Int64): Int64;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableInt64): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: Int64): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: Int64 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableUInt64\n//**************************\n\n  NullableUInt64 = record\n  private\n    fValue: UInt64;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: UInt64;\n    procedure SetValue(const Value: UInt64);\n    class operator Implicit(const Value: UInt64): NullableUInt64;\n    class operator Implicit(const Value: NullableUInt64): UInt64;\n    class operator Implicit(const Value: Pointer): NullableUInt64;\t\n\t  class operator Equal(LeftValue: NullableUInt64; RightValue: NullableUInt64) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableUInt64 contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableUInt64 contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: UInt64;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: UInt64): UInt64;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableUInt64): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: UInt64): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: UInt64 read GetValue write SetValue;\n  end;\n\n//**************************\n// ** NullableTGUID\n//**************************\n\n  NullableTGUID = record\n  private\n    fValue: TGUID;\n    fHasValue: String;\n    function GetHasValue: Boolean;\n\tfunction GetIsNull: Boolean;\t\n  public\n    procedure CheckHasValue;\n    function GetValue: TGUID;\n    procedure SetValue(const Value: TGUID);\n    class operator Implicit(const Value: TGUID): NullableTGUID;\n    class operator Implicit(const Value: NullableTGUID): TGUID;\n    class operator Implicit(const Value: Pointer): NullableTGUID;\t\n\t  class operator Equal(LeftValue: NullableTGUID; RightValue: NullableTGUID) : Boolean;\t\n    ///<summary>\n    ///Returns `True` if the NullableTGUID contains a value\n    ///</summary>\t\n    property HasValue: Boolean read GetHasValue;\n    ///<summary>\n    ///Returns `True` if the NullableTGUID contains a null\n    ///</summary>\t\n    property IsNull: Boolean read GetIsNull;\t\n    ///<summary>\n    ///Alias of `SetNull`\n    ///</summary>\n    procedure Clear;\n    ///<summary>\n    ///Set the value to `null`\n    ///</summary>\n    procedure SetNull;\n    ///<summary>\n    ///Returns the value stored or the default value for the type if the value is not set\n    ///</summary>\t\n    function ValueOrDefault: TGUID;\n    ///<summary>\n    ///Returns the value stored or else the value passed as parameter if the value is not set\n    ///</summary>\t\n    function ValueOrElse(const ElseValue: TGUID): TGUID;\n    /// <summary>\n    /// Returns true is both item have the same value and that value is not null. \n    /// </summary>\n    function Equals(const Value: NullableTGUID): Boolean;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TGUID): Boolean; overload;\n    ///<summary>\n    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.\n    ///</summary>\t\n    function TryHasValue(out Value: TValue): Boolean; overload;\n    ///<summary>\n    ///Returns the value stored or raises exception if no value is stored\n    ///</summary>\t\n    property Value: TGUID read GetValue write SetValue;\n  end;\n\n  TNullableType = (\n     ntInvalidNullableType\n   , ntNullableString\n   , ntNullableCurrency\n   , ntNullableBoolean\n   , ntNullableTDate\n   , ntNullableTTime\n   , ntNullableTDateTime\n   , ntNullableSingle\n   , ntNullableDouble\n   , ntNullableExtended\n   , ntNullableInt16\n   , ntNullableUInt16\n   , ntNullableInt32\n   , ntNullableUInt32\n   , ntNullableInt64\n   , ntNullableUInt64\n   , ntNullableTGUID);\n\n\nfunction GetNullableType(const aTypeInfo: PTypeInfo): TNullableType;\n\nimplementation\n\nuses\n  System.Math, System.DateUtils, System.Types;\n\nfunction DateAreEquals(const DateA, DateB: TDate): Boolean;\nbegin\n  Result := CompareDate(DateA, DateB) = 0;\nend;\n\nfunction TimeAreEquals(const TimeA, TimeB: TTime): Boolean;\nbegin\n  Result := CompareValue(TimeA,TimeB, 0.000001) = 0;\nend;\n\n\n{ NullableString }\n\nprocedure NullableString.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableString value is null');\n  end;\nend;\n\nfunction NullableString.TryHasValue(out Value: String): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableString.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<String>(fValue);    \n  end;\nend;\n\n\nprocedure NullableString.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableString.Equals(const Value: NullableString): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableString.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableString.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableString.GetValue: String;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableString.Implicit(const Value: NullableString): String;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableString.Implicit(const Value: String): NullableString;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableString.Implicit(const Value: Pointer): NullableString;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableString.Equal(LeftValue: NullableString; RightValue: NullableString) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableString.SetNull;\nbegin\n  fValue := Default (String);\n  fHasValue := '';\nend;\n\nprocedure NullableString.SetValue(const Value: String);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableString.ValueOrDefault: String;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (String);\n  end;\nend;\n\nfunction NullableString.ValueOrElse(const ElseValue: String): String;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableCurrency }\n\nprocedure NullableCurrency.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableCurrency value is null');\n  end;\nend;\n\nfunction NullableCurrency.TryHasValue(out Value: Currency): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableCurrency.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Currency>(fValue);    \n  end;\nend;\n\n\nprocedure NullableCurrency.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableCurrency.Equals(const Value: NullableCurrency): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableCurrency.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableCurrency.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableCurrency.GetValue: Currency;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableCurrency.Implicit(const Value: NullableCurrency): Currency;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableCurrency.Implicit(const Value: Currency): NullableCurrency;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableCurrency.Implicit(const Value: Pointer): NullableCurrency;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableCurrency.Equal(LeftValue: NullableCurrency; RightValue: NullableCurrency) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableCurrency.SetNull;\nbegin\n  fValue := Default (Currency);\n  fHasValue := '';\nend;\n\nprocedure NullableCurrency.SetValue(const Value: Currency);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableCurrency.ValueOrDefault: Currency;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Currency);\n  end;\nend;\n\nfunction NullableCurrency.ValueOrElse(const ElseValue: Currency): Currency;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableBoolean }\n\nprocedure NullableBoolean.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableBoolean value is null');\n  end;\nend;\n\nfunction NullableBoolean.TryHasValue(out Value: Boolean): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableBoolean.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Boolean>(fValue);    \n  end;\nend;\n\n\nprocedure NullableBoolean.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableBoolean.Equals(const Value: NullableBoolean): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableBoolean.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableBoolean.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableBoolean.GetValue: Boolean;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableBoolean.Implicit(const Value: NullableBoolean): Boolean;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableBoolean.Implicit(const Value: Boolean): NullableBoolean;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableBoolean.Implicit(const Value: Pointer): NullableBoolean;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableBoolean.Equal(LeftValue: NullableBoolean; RightValue: NullableBoolean) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableBoolean.SetNull;\nbegin\n  fValue := Default (Boolean);\n  fHasValue := '';\nend;\n\nprocedure NullableBoolean.SetValue(const Value: Boolean);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableBoolean.ValueOrDefault: Boolean;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Boolean);\n  end;\nend;\n\nfunction NullableBoolean.ValueOrElse(const ElseValue: Boolean): Boolean;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableTDate }\n\nprocedure NullableTDate.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableTDate value is null');\n  end;\nend;\n\nfunction NullableTDate.TryHasValue(out Value: TDate): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableTDate.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<TDate>(fValue);    \n  end;\nend;\n\n\nprocedure NullableTDate.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableTDate.Equals(const Value: NullableTDate): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableTDate.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableTDate.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableTDate.GetValue: TDate;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableTDate.Implicit(const Value: NullableTDate): TDate;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableTDate.Implicit(const Value: TDate): NullableTDate;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableTDate.Implicit(const Value: Pointer): NullableTDate;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableTDate.Equal(LeftValue: NullableTDate; RightValue: NullableTDate) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (DateAreEquals(LeftValue.Value, RightValue.Value)));\nend;\n\nprocedure NullableTDate.SetNull;\nbegin\n  fValue := Default (TDate);\n  fHasValue := '';\nend;\n\nprocedure NullableTDate.SetValue(const Value: TDate);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableTDate.ValueOrDefault: TDate;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (TDate);\n  end;\nend;\n\nfunction NullableTDate.ValueOrElse(const ElseValue: TDate): TDate;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableTTime }\n\nprocedure NullableTTime.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableTTime value is null');\n  end;\nend;\n\nfunction NullableTTime.TryHasValue(out Value: TTime): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableTTime.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<TTime>(fValue);    \n  end;\nend;\n\n\nprocedure NullableTTime.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableTTime.Equals(const Value: NullableTTime): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableTTime.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableTTime.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableTTime.GetValue: TTime;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableTTime.Implicit(const Value: NullableTTime): TTime;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableTTime.Implicit(const Value: TTime): NullableTTime;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableTTime.Implicit(const Value: Pointer): NullableTTime;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableTTime.Equal(LeftValue: NullableTTime; RightValue: NullableTTime) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (TimeAreEquals(LeftValue.Value, RightValue.Value)));\nend;\n\nprocedure NullableTTime.SetNull;\nbegin\n  fValue := Default (TTime);\n  fHasValue := '';\nend;\n\nprocedure NullableTTime.SetValue(const Value: TTime);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableTTime.ValueOrDefault: TTime;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (TTime);\n  end;\nend;\n\nfunction NullableTTime.ValueOrElse(const ElseValue: TTime): TTime;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableTDateTime }\n\nprocedure NullableTDateTime.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableTDateTime value is null');\n  end;\nend;\n\nfunction NullableTDateTime.TryHasValue(out Value: TDateTime): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableTDateTime.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<TDateTime>(fValue);    \n  end;\nend;\n\n\nprocedure NullableTDateTime.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableTDateTime.Equals(const Value: NullableTDateTime): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableTDateTime.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableTDateTime.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableTDateTime.GetValue: TDateTime;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableTDateTime.Implicit(const Value: NullableTDateTime): TDateTime;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableTDateTime.Implicit(const Value: TDateTime): NullableTDateTime;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableTDateTime.Implicit(const Value: Pointer): NullableTDateTime;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableTDateTime.Equal(LeftValue: NullableTDateTime; RightValue: NullableTDateTime) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t (DateAreEquals(LeftValue.Value, RightValue.Value) and \n\t TimeAreEquals(LeftValue.Value, RightValue.Value)));\nend;\n\nprocedure NullableTDateTime.SetNull;\nbegin\n  fValue := Default (TDateTime);\n  fHasValue := '';\nend;\n\nprocedure NullableTDateTime.SetValue(const Value: TDateTime);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableTDateTime.ValueOrDefault: TDateTime;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (TDateTime);\n  end;\nend;\n\nfunction NullableTDateTime.ValueOrElse(const ElseValue: TDateTime): TDateTime;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableSingle }\n\nprocedure NullableSingle.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableSingle value is null');\n  end;\nend;\n\nfunction NullableSingle.TryHasValue(out Value: Single): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableSingle.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Single>(fValue);    \n  end;\nend;\n\n\nprocedure NullableSingle.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableSingle.Equals(const Value: NullableSingle): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableSingle.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableSingle.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableSingle.GetValue: Single;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableSingle.Implicit(const Value: NullableSingle): Single;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableSingle.Implicit(const Value: Single): NullableSingle;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableSingle.Implicit(const Value: Pointer): NullableSingle;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableSingle.Equal(LeftValue: NullableSingle; RightValue: NullableSingle) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t SameValue(LeftValue.Value, RightValue.Value, 0.000001));\nend;\n\nprocedure NullableSingle.SetNull;\nbegin\n  fValue := Default (Single);\n  fHasValue := '';\nend;\n\nprocedure NullableSingle.SetValue(const Value: Single);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableSingle.ValueOrDefault: Single;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Single);\n  end;\nend;\n\nfunction NullableSingle.ValueOrElse(const ElseValue: Single): Single;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableDouble }\n\nprocedure NullableDouble.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableDouble value is null');\n  end;\nend;\n\nfunction NullableDouble.TryHasValue(out Value: Double): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableDouble.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Double>(fValue);    \n  end;\nend;\n\n\nprocedure NullableDouble.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableDouble.Equals(const Value: NullableDouble): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableDouble.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableDouble.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableDouble.GetValue: Double;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableDouble.Implicit(const Value: NullableDouble): Double;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableDouble.Implicit(const Value: Double): NullableDouble;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableDouble.Implicit(const Value: Pointer): NullableDouble;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableDouble.Equal(LeftValue: NullableDouble; RightValue: NullableDouble) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t SameValue(LeftValue.Value, RightValue.Value, 0.000000001));\nend;\n\nprocedure NullableDouble.SetNull;\nbegin\n  fValue := Default (Double);\n  fHasValue := '';\nend;\n\nprocedure NullableDouble.SetValue(const Value: Double);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableDouble.ValueOrDefault: Double;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Double);\n  end;\nend;\n\nfunction NullableDouble.ValueOrElse(const ElseValue: Double): Double;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableExtended }\n\nprocedure NullableExtended.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableExtended value is null');\n  end;\nend;\n\nfunction NullableExtended.TryHasValue(out Value: Extended): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableExtended.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Extended>(fValue);    \n  end;\nend;\n\n\nprocedure NullableExtended.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableExtended.Equals(const Value: NullableExtended): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableExtended.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableExtended.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableExtended.GetValue: Extended;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableExtended.Implicit(const Value: NullableExtended): Extended;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableExtended.Implicit(const Value: Extended): NullableExtended;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableExtended.Implicit(const Value: Pointer): NullableExtended;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableExtended.Equal(LeftValue: NullableExtended; RightValue: NullableExtended) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and \n\t SameValue(LeftValue.Value, RightValue.Value, 0.000000001));\nend;\n\nprocedure NullableExtended.SetNull;\nbegin\n  fValue := Default (Extended);\n  fHasValue := '';\nend;\n\nprocedure NullableExtended.SetValue(const Value: Extended);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableExtended.ValueOrDefault: Extended;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Extended);\n  end;\nend;\n\nfunction NullableExtended.ValueOrElse(const ElseValue: Extended): Extended;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableInt16 }\n\nprocedure NullableInt16.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableInt16 value is null');\n  end;\nend;\n\nfunction NullableInt16.TryHasValue(out Value: Int16): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableInt16.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Int16>(fValue);    \n  end;\nend;\n\n\nprocedure NullableInt16.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableInt16.Equals(const Value: NullableInt16): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableInt16.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableInt16.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableInt16.GetValue: Int16;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableInt16.Implicit(const Value: NullableInt16): Int16;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableInt16.Implicit(const Value: Int16): NullableInt16;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableInt16.Implicit(const Value: Pointer): NullableInt16;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableInt16.Equal(LeftValue: NullableInt16; RightValue: NullableInt16) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableInt16.SetNull;\nbegin\n  fValue := Default (Int16);\n  fHasValue := '';\nend;\n\nprocedure NullableInt16.SetValue(const Value: Int16);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableInt16.ValueOrDefault: Int16;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Int16);\n  end;\nend;\n\nfunction NullableInt16.ValueOrElse(const ElseValue: Int16): Int16;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableUInt16 }\n\nprocedure NullableUInt16.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableUInt16 value is null');\n  end;\nend;\n\nfunction NullableUInt16.TryHasValue(out Value: UInt16): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableUInt16.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<UInt16>(fValue);    \n  end;\nend;\n\n\nprocedure NullableUInt16.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableUInt16.Equals(const Value: NullableUInt16): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableUInt16.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableUInt16.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableUInt16.GetValue: UInt16;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableUInt16.Implicit(const Value: NullableUInt16): UInt16;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableUInt16.Implicit(const Value: UInt16): NullableUInt16;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableUInt16.Implicit(const Value: Pointer): NullableUInt16;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableUInt16.Equal(LeftValue: NullableUInt16; RightValue: NullableUInt16) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableUInt16.SetNull;\nbegin\n  fValue := Default (UInt16);\n  fHasValue := '';\nend;\n\nprocedure NullableUInt16.SetValue(const Value: UInt16);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableUInt16.ValueOrDefault: UInt16;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (UInt16);\n  end;\nend;\n\nfunction NullableUInt16.ValueOrElse(const ElseValue: UInt16): UInt16;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableInt32 }\n\nprocedure NullableInt32.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableInt32 value is null');\n  end;\nend;\n\nfunction NullableInt32.TryHasValue(out Value: Int32): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableInt32.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Int32>(fValue);    \n  end;\nend;\n\n\nprocedure NullableInt32.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableInt32.Equals(const Value: NullableInt32): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableInt32.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableInt32.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableInt32.GetValue: Int32;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableInt32.Implicit(const Value: NullableInt32): Int32;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableInt32.Implicit(const Value: Int32): NullableInt32;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableInt32.Implicit(const Value: Pointer): NullableInt32;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableInt32.Equal(LeftValue: NullableInt32; RightValue: NullableInt32) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableInt32.SetNull;\nbegin\n  fValue := Default (Int32);\n  fHasValue := '';\nend;\n\nprocedure NullableInt32.SetValue(const Value: Int32);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableInt32.ValueOrDefault: Int32;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Int32);\n  end;\nend;\n\nfunction NullableInt32.ValueOrElse(const ElseValue: Int32): Int32;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableUInt32 }\n\nprocedure NullableUInt32.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableUInt32 value is null');\n  end;\nend;\n\nfunction NullableUInt32.TryHasValue(out Value: UInt32): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableUInt32.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<UInt32>(fValue);    \n  end;\nend;\n\n\nprocedure NullableUInt32.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableUInt32.Equals(const Value: NullableUInt32): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableUInt32.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableUInt32.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableUInt32.GetValue: UInt32;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableUInt32.Implicit(const Value: NullableUInt32): UInt32;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableUInt32.Implicit(const Value: UInt32): NullableUInt32;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableUInt32.Implicit(const Value: Pointer): NullableUInt32;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableUInt32.Equal(LeftValue: NullableUInt32; RightValue: NullableUInt32) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableUInt32.SetNull;\nbegin\n  fValue := Default (UInt32);\n  fHasValue := '';\nend;\n\nprocedure NullableUInt32.SetValue(const Value: UInt32);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableUInt32.ValueOrDefault: UInt32;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (UInt32);\n  end;\nend;\n\nfunction NullableUInt32.ValueOrElse(const ElseValue: UInt32): UInt32;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableInt64 }\n\nprocedure NullableInt64.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableInt64 value is null');\n  end;\nend;\n\nfunction NullableInt64.TryHasValue(out Value: Int64): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableInt64.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<Int64>(fValue);    \n  end;\nend;\n\n\nprocedure NullableInt64.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableInt64.Equals(const Value: NullableInt64): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableInt64.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableInt64.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableInt64.GetValue: Int64;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableInt64.Implicit(const Value: NullableInt64): Int64;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableInt64.Implicit(const Value: Int64): NullableInt64;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableInt64.Implicit(const Value: Pointer): NullableInt64;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableInt64.Equal(LeftValue: NullableInt64; RightValue: NullableInt64) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableInt64.SetNull;\nbegin\n  fValue := Default (Int64);\n  fHasValue := '';\nend;\n\nprocedure NullableInt64.SetValue(const Value: Int64);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableInt64.ValueOrDefault: Int64;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (Int64);\n  end;\nend;\n\nfunction NullableInt64.ValueOrElse(const ElseValue: Int64): Int64;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableUInt64 }\n\nprocedure NullableUInt64.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableUInt64 value is null');\n  end;\nend;\n\nfunction NullableUInt64.TryHasValue(out Value: UInt64): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableUInt64.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<UInt64>(fValue);    \n  end;\nend;\n\n\nprocedure NullableUInt64.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableUInt64.Equals(const Value: NullableUInt64): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableUInt64.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableUInt64.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableUInt64.GetValue: UInt64;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableUInt64.Implicit(const Value: NullableUInt64): UInt64;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableUInt64.Implicit(const Value: UInt64): NullableUInt64;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableUInt64.Implicit(const Value: Pointer): NullableUInt64;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableUInt64.Equal(LeftValue: NullableUInt64; RightValue: NullableUInt64) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableUInt64.SetNull;\nbegin\n  fValue := Default (UInt64);\n  fHasValue := '';\nend;\n\nprocedure NullableUInt64.SetValue(const Value: UInt64);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableUInt64.ValueOrDefault: UInt64;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (UInt64);\n  end;\nend;\n\nfunction NullableUInt64.ValueOrElse(const ElseValue: UInt64): UInt64;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\n\n{ NullableTGUID }\n\nprocedure NullableTGUID.CheckHasValue;\nbegin\n  if not GetHasValue then\n  begin\n    raise EMVCNullable.Create('NullableTGUID value is null');\n  end;\nend;\n\nfunction NullableTGUID.TryHasValue(out Value: TGUID): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := fValue;\n  end;\nend;\n\nfunction NullableTGUID.TryHasValue(out Value: TValue): Boolean;\nbegin\n  Result := HasValue;\n  if Result then\n  begin\n    Value := TValue.From<TGUID>(fValue);    \n  end;\nend;\n\n\nprocedure NullableTGUID.Clear;\nbegin\n  SetNull;\nend;\n\nfunction NullableTGUID.Equals(const Value: NullableTGUID): Boolean;\nbegin\n  Result := Self = Value;\nend;\n\nfunction NullableTGUID.GetHasValue: Boolean;\nbegin\n  Result := fHasValue = '_';\nend;\n\nfunction NullableTGUID.GetIsNull: Boolean;\nbegin\n  Result := not HasValue;\nend;\n\nfunction NullableTGUID.GetValue: TGUID;\nbegin\n  CheckHasValue;\n  Result := fValue;\nend;\n\nclass operator NullableTGUID.Implicit(const Value: NullableTGUID): TGUID;\nbegin\n  Result := Value.Value;\nend;\n\nclass operator NullableTGUID.Implicit(const Value: TGUID): NullableTGUID;\nbegin\n  Result.Value := Value;\nend;\n\nclass operator NullableTGUID.Implicit(const Value: Pointer): NullableTGUID;\nbegin\n  if Value = nil then\n  begin\n    Result.SetNull;\n  end\n  else\n  begin\n    raise EInvalidPointer.Create('Pointer value can only be \"nil\"');\n  end;\nend;\n\nclass operator NullableTGUID.Equal(LeftValue: NullableTGUID; RightValue: NullableTGUID) : Boolean;\nbegin\n  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));\nend;\n\nprocedure NullableTGUID.SetNull;\nbegin\n  fValue := Default (TGUID);\n  fHasValue := '';\nend;\n\nprocedure NullableTGUID.SetValue(const Value: TGUID);\nbegin\n  fValue := Value;\n  fHasValue := '_';\nend;\n\nfunction NullableTGUID.ValueOrDefault: TGUID;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := Default (TGUID);\n  end;\nend;\n\nfunction NullableTGUID.ValueOrElse(const ElseValue: TGUID): TGUID;\nbegin\n  if HasValue then\n  begin\n    Result := GetValue\n  end\n  else\n  begin\n    Result := ElseValue;\n  end;\nend;\n\n\n\nfunction GetNullableType(const aTypeInfo: PTypeInfo): TNullableType;\nbegin\n  if aTypeInfo = TypeInfo(NullableString) then \n    Exit(ntNullableString); \n  if aTypeInfo = TypeInfo(NullableCurrency) then \n    Exit(ntNullableCurrency); \n  if aTypeInfo = TypeInfo(NullableBoolean) then \n    Exit(ntNullableBoolean); \n  if aTypeInfo = TypeInfo(NullableTDate) then \n    Exit(ntNullableTDate); \n  if aTypeInfo = TypeInfo(NullableTTime) then \n    Exit(ntNullableTTime); \n  if aTypeInfo = TypeInfo(NullableTDateTime) then \n    Exit(ntNullableTDateTime); \n  if aTypeInfo = TypeInfo(NullableSingle) then \n    Exit(ntNullableSingle); \n  if aTypeInfo = TypeInfo(NullableDouble) then \n    Exit(ntNullableDouble); \n  if aTypeInfo = TypeInfo(NullableExtended) then \n    Exit(ntNullableExtended); \n  if aTypeInfo = TypeInfo(NullableInt16) then \n    Exit(ntNullableInt16); \n  if aTypeInfo = TypeInfo(NullableUInt16) then \n    Exit(ntNullableUInt16); \n  if aTypeInfo = TypeInfo(NullableInt32) then \n    Exit(ntNullableInt32); \n  if aTypeInfo = TypeInfo(NullableUInt32) then \n    Exit(ntNullableUInt32); \n  if aTypeInfo = TypeInfo(NullableInt64) then \n    Exit(ntNullableInt64); \n  if aTypeInfo = TypeInfo(NullableUInt64) then \n    Exit(ntNullableUInt64); \n  if aTypeInfo = TypeInfo(NullableTGUID) then \n    Exit(ntNullableTGUID); \n  Result := ntInvalidNullableType;\nend;\n\nend.", "output": "using System;\nusing System.Globalization;\n\nnamespace MVCFramework.Nullables\n{\n    \n    public class EMVCNullable : Exception\n    {\n        public EMVCNullable(string message) : base(message) { }\n    }\n\n    \n    public struct NullableString\n    {\n        private string _value;\n        private bool _hasValue;\n\n        \n        public bool HasValue => _hasValue;\n\n        \n        public bool IsNull => !_hasValue;\n\n        \n        public string Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableString value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        \n        public void Clear() => SetNull();\n\n        \n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n\n        \n        public string ValueOrDefault() => HasValue ? _value : default;\n\n        \n        public string ValueOrElse(string elseValue) => HasValue ? _value : elseValue;\n\n        \n        public bool TryHasValue(out string value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n\n        public override bool Equals(object obj) =>\n            obj is NullableString other && Equals(other);\n\n        public bool Equals(NullableString other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableString(string value) =>\n            new NullableString { _value = value, _hasValue = true };\n\n        public static implicit operator string(NullableString ns) => ns.Value;\n\n        public static bool operator ==(NullableString left, NullableString right) =>\n            left.Equals(right);\n\n        public static bool operator !=(NullableString left, NullableString right) =>\n            !left.Equals(right);\n\n        public override string ToString() => HasValue ? _value : \"\";\n    }\n\n    \n    public struct NullableCurrency\n    {\n        private decimal _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public decimal Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableCurrency value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public decimal ValueOrDefault() => HasValue ? _value : default;\n        public decimal ValueOrElse(decimal elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out decimal value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableCurrency other && Equals(other);\n        public bool Equals(NullableCurrency other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableCurrency(decimal value) =>\n            new NullableCurrency { _value = value, _hasValue = true };\n        public static implicit operator decimal(NullableCurrency nc) => nc.Value;\n\n        public static bool operator ==(NullableCurrency left, NullableCurrency right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableCurrency left, NullableCurrency right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableBoolean\n    {\n        private bool _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public bool Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableBoolean value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public bool ValueOrDefault() => HasValue ? _value : default;\n        public bool ValueOrElse(bool elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out bool value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableBoolean other && Equals(other);\n        public bool Equals(NullableBoolean other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableBoolean(bool value) =>\n            new NullableBoolean { _value = value, _hasValue = true };\n        public static implicit operator bool(NullableBoolean nb) => nb.Value;\n\n        public static bool operator ==(NullableBoolean left, NullableBoolean right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableBoolean left, NullableBoolean right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDate\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        \n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDate value is null\");\n                return _value.Date;\n            }\n            set\n            {\n                _value = value.Date;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value.Date : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value.Date : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value.Date;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDate other && Equals(other);\n        public bool Equals(NullableTDate other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Date.Equals(other._value.Date));\n        public override int GetHashCode() => HasValue ? _value.Date.GetHashCode() : 0;\n\n        public static implicit operator NullableTDate(DateTime value) =>\n            new NullableTDate { _value = value.Date, _hasValue = true };\n        public static implicit operator DateTime(NullableTDate ntd) => ntd.Value;\n\n        public static bool operator ==(NullableTDate left, NullableTDate right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDate left, NullableTDate right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTTime\n    {\n        private TimeSpan _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public TimeSpan Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public TimeSpan ValueOrDefault() => HasValue ? _value : default;\n        public TimeSpan ValueOrElse(TimeSpan elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out TimeSpan value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTTime other && Equals(other);\n        public bool Equals(NullableTTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTTime(TimeSpan value) =>\n            new NullableTTime { _value = value, _hasValue = true };\n        public static implicit operator TimeSpan(NullableTTime ntt) => ntt.Value;\n\n        public static bool operator ==(NullableTTime left, NullableTTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTTime left, NullableTTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDateTime\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDateTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDateTime other && Equals(other);\n        public bool Equals(NullableTDateTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTDateTime(DateTime value) =>\n            new NullableTDateTime { _value = value, _hasValue = true };\n        public static implicit operator DateTime(NullableTDateTime ntdt) => ntdt.Value;\n\n        public static bool operator ==(NullableTDateTime left, NullableTDateTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDateTime left, NullableTDateTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableSingle\n    {\n        private float _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public float Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableSingle value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public float ValueOrDefault() => HasValue ? _value : default;\n        public float ValueOrElse(float elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out float value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableSingle other && Equals(other);\n        public bool Equals(NullableSingle other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-6);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableSingle(float value) =>\n            new NullableSingle { _value = value, _hasValue = true };\n        public static implicit operator float(NullableSingle ns) => ns.Value;\n\n        public static bool operator ==(NullableSingle left, NullableSingle right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableSingle left, NullableSingle right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableDouble\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableDouble value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableDouble other && Equals(other);\n        public bool Equals(NullableDouble other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableDouble(double value) =>\n            new NullableDouble { _value = value, _hasValue = true };\n        public static implicit operator double(NullableDouble nd) => nd.Value;\n\n        public static bool operator ==(NullableDouble left, NullableDouble right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableDouble left, NullableDouble right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableExtended\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableExtended value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableExtended other && Equals(other);\n        public bool Equals(NullableExtended other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableExtended(double value) =>\n            new NullableExtended { _value = value, _hasValue = true };\n        public static implicit operator double(NullableExtended ne) => ne.Value;\n\n        public static bool operator ==(NullableExtended left, NullableExtended right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableExtended left, NullableExtended right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt16\n    {\n        private short _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public short Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public short ValueOrDefault() => HasValue ? _value : default;\n        public short ValueOrElse(short elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out short value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt16 other && Equals(other);\n        public bool Equals(NullableInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt16(short value) =>\n            new NullableInt16 { _value = value, _hasValue = true };\n        public static implicit operator short(NullableInt16 ni16) => ni16.Value;\n\n        public static bool operator ==(NullableInt16 left, NullableInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt16 left, NullableInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt16\n    {\n        private ushort _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ushort Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ushort ValueOrDefault() => HasValue ? _value : default;\n        public ushort ValueOrElse(ushort elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ushort value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt16 other && Equals(other);\n        public bool Equals(NullableUInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt16(ushort value) =>\n            new NullableUInt16 { _value = value, _hasValue = true };\n        public static implicit operator ushort(NullableUInt16 nu16) => nu16.Value;\n\n        public static bool operator ==(NullableUInt16 left, NullableUInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt16 left, NullableUInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt32\n    {\n        private int _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public int Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public int ValueOrDefault() => HasValue ? _value : default;\n        public int ValueOrElse(int elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out int value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt32 other && Equals(other);\n        public bool Equals(NullableInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt32(int value) =>\n            new NullableInt32 { _value = value, _hasValue = true };\n        public static implicit operator int(NullableInt32 ni32) => ni32.Value;\n\n        public static bool operator ==(NullableInt32 left, NullableInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt32 left, NullableInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt32\n    {\n        private uint _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public uint Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public uint ValueOrDefault() => HasValue ? _value : default;\n        public uint ValueOrElse(uint elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out uint value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt32 other && Equals(other);\n        public bool Equals(NullableUInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt32(uint value) =>\n            new NullableUInt32 { _value = value, _hasValue = true };\n        public static implicit operator uint(NullableUInt32 nu32) => nu32.Value;\n\n        public static bool operator ==(NullableUInt32 left, NullableUInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt32 left, NullableUInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt64\n    {\n        private long _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public long Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public long ValueOrDefault() => HasValue ? _value : default;\n        public long ValueOrElse(long elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out long value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt64 other && Equals(other);\n        public bool Equals(NullableInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt64(long value) =>\n            new NullableInt64 { _value = value, _hasValue = true };\n        public static implicit operator long(NullableInt64 ni64) => ni64.Value;\n\n        public static bool operator ==(NullableInt64 left, NullableInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt64 left, NullableInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt64\n    {\n        private ulong _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ulong Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ulong ValueOrDefault() => HasValue ? _value : default;\n        public ulong ValueOrElse(ulong elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ulong value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt64 other && Equals(other);\n        public bool Equals(NullableUInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt64(ulong value) =>\n            new NullableUInt64 { _value = value, _hasValue = true };\n        public static implicit operator ulong(NullableUInt64 nu64) => nu64.Value;\n\n        public static bool operator ==(NullableUInt64 left, NullableUInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt64 left, NullableUInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTGUID\n    {\n        private Guid _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public Guid Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTGUID value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public Guid ValueOrDefault() => HasValue ? _value : default;\n        public Guid ValueOrElse(Guid elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out Guid value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTGUID other && Equals(other);\n        public bool Equals(NullableTGUID other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTGUID(Guid value) =>\n            new NullableTGUID { _value = value, _hasValue = true };\n        public static implicit operator Guid(NullableTGUID ntguid) => ntguid.Value;\n\n        public static bool operator ==(NullableTGUID left, NullableTGUID right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTGUID left, NullableTGUID right) =>\n            !left.Equals(right);\n    }\n\n    \n    public enum NullableType\n    {\n        InvalidNullableType,\n        NullableString,\n        NullableCurrency,\n        NullableBoolean,\n        NullableTDate,\n        NullableTTime,\n        NullableTDateTime,\n        NullableSingle,\n        NullableDouble,\n        NullableExtended,\n        NullableInt16,\n        NullableUInt16,\n        NullableInt32,\n        NullableUInt32,\n        NullableInt64,\n        NullableUInt64,\n        NullableTGUID\n    }\n\n    \n    public static class NullableHelper\n    {\n        public static NullableType GetNullableType(Type type)\n        {\n            if (type == typeof(NullableString)) return NullableType.NullableString;\n            if (type == typeof(NullableCurrency)) return NullableType.NullableCurrency;\n            if (type == typeof(NullableBoolean)) return NullableType.NullableBoolean;\n            if (type == typeof(NullableTDate)) return NullableType.NullableTDate;\n            if (type == typeof(NullableTTime)) return NullableType.NullableTTime;\n            if (type == typeof(NullableTDateTime)) return NullableType.NullableTDateTime;\n            if (type == typeof(NullableSingle)) return NullableType.NullableSingle;\n            if (type == typeof(NullableDouble)) return NullableType.NullableDouble;\n            if (type == typeof(NullableExtended)) return NullableType.NullableExtended;\n            if (type == typeof(NullableInt16)) return NullableType.NullableInt16;\n            if (type == typeof(NullableUInt16)) return NullableType.NullableUInt16;\n            if (type == typeof(NullableInt32)) return NullableType.NullableInt32;\n            if (type == typeof(NullableUInt32)) return NullableType.NullableUInt32;\n            if (type == typeof(NullableInt64)) return NullableType.NullableInt64;\n            if (type == typeof(NullableUInt64)) return NullableType.NullableUInt64;\n            if (type == typeof(NullableTGUID)) return NullableType.NullableTGUID;\n            return NullableType.InvalidNullableType;\n        }\n    }\n}"}
{"input": "unit RESTServicesU;\n\ninterface\n\nuses\n  Generics.Collections, WinesBO, MVCFramework.RESTAdapter,\n  MVCFramework.Serializer.Commons, MVCFramework.Commons;\n\ntype\n\n  IWineResource = interface(IInvokable)\n    ['{068C51B2-F413-48ED-97CE-463234DB3E41}']\n\n    [RESTResource(HttpGet, '/api/wines')]\n    [MVCListOf(TWine)]\n    [Mapping(TWines)]\n    procedure GetWineList(AAsynchReq: IAsynchRequest);\n\n    [RESTResource(httpPOST, '/api/wines')]\n    procedure SaveWine([Body] AWine: TWine; AAsynchReq: IAsynchRequest);\n\n    [RESTResource(httpPUT, '/api/wines/{id}')]\n    procedure UpdateWineById([Param('id')] AID: integer; [Body] AWine: TWine;\n      AAsynchReq: IAsynchRequest);\n\n  end;\n\nimplementation\n\nend.", "output": "using System.Collections.Generic;\nusing WinesBO;\nusing MVCFramework.RESTAdapter;\nusing MVCFramework.Serializer.Commons;\nusing MVCFramework.Commons;\n\nnamespace RESTServicesU\n{\n    [RESTResource(HttpMethod.Get, \"/api/wines\")]\n    [MVCListOf(typeof(TWine))]\n    [Mapping(typeof(TWines))]\n    public interface IWineResource : IInvokable\n    {\n        void GetWineList(IAsynchRequest asynchReq);\n\n        [RESTResource(HttpMethod.Post, \"/api/wines\")]\n        void SaveWine([Body] TWine aWine, IAsynchRequest asynchReq);\n\n        [RESTResource(HttpMethod.Put, \"/api/wines/{id}\")]\n        void UpdateWineById([Param(\"id\")] int aId, [Body] TWine aWine, IAsynchRequest asynchReq);\n    }\n}"}
{"input": "unit MainWebModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Logger,\n  MVCFramework.DotEnv\n  ;\n\ntype\n  Twm = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n\n  private\n    MVCEngine: TMVCEngine;\n  end;\n\nvar\n  WebModuleClass: TComponentClass = Twm;\n\nimplementation\n\nuses\n  WineCellarAppControllerU,\n  MVCFramework.Middleware.StaticFiles,\n  MVCFramework.Middleware.CORS,\n  System.IOUtils;\n\n{$R *.dfm}\n\nprocedure Twm.WebModuleCreate(Sender: TObject);\nbegin\n  MVCEngine := TMVCEngine.Create(self,\n    procedure(Conf: TMVCConfig)\n    begin\n//      Conf.Value[tmvcconfigkey.PathPrefix] := '/dmvc';\n    end);\n  MVCEngine.AddController(TWineCellarApp);\n  MVCEngine.AddMiddleware(TMVCCORSMiddleware.Create);\n  if not IsLibrary then\n  begin\n    MVCEngine.AddMiddleware(TMVCStaticFilesMiddleware.Create('/app', { StaticFilesPath }\n      TPath.Combine(AppPath, '..\\..\\www'), { DocumentRoot }\n      'index.html' { IndexDocument - Before it was named fallbackresource }\n      ));\n  end;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.FileProviders;\nusing Microsoft.Extensions.Hosting;\nusing System.IO;\n\nnamespace WineCellarApp\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n\n            builder.Services.AddControllers();\n\n            builder.Services.AddCors(options =>\n            {\n                options.AddPolicy(\"CorsPolicy\", policyBuilder =>\n                {\n                    policyBuilder\n                      .AllowAnyOrigin()\n                      .AllowAnyHeader()\n                      .AllowAnyMethod();\n                });\n            });\n\n            var app = builder.Build();\n\n            app.UseCors(\"CorsPolicy\");\n\n            \n            var currentDir = Directory.GetCurrentDirectory();\n            var wwwPath = Path.Combine(currentDir, \"..\", \"..\", \"www\");\n            if (Directory.Exists(wwwPath))\n            {\n                app.UseStaticFiles(new StaticFileOptions\n                {\n                    RequestPath = \"/app\",\n                    FileProvider = new PhysicalFileProvider(Path.GetFullPath(wwwPath)),\n                    \n                });\n            }\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"Wine Cellar API is up!\");\n\n            System.Console.WriteLine(\"Server is running on: \" + string.Join(\", \", app.Urls));\n\n            app.Run();\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Some code in this file is from Thijs van Dien (https://stackoverflow.com/users/1163893/thijs-van-dien)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Crypt.Utils;\n\ninterface\n\nuses\n  System.SysUtils, System.Math, IdHMAC, IdHMACSHA1, IdGlobal;\n\ntype\n  TIdHMACClass = class of TIdHMAC;\nfunction PBKDF2(const Password: TBytes; const Salt: TBytes; const IterationsCount: Integer;\n  const KeyLengthInBytes: Integer; PRFC: TIdHMACClass = nil): TBytes;\nfunction BytesToHexString(const _B: TIdBytes): string; overload;\nfunction BytesToHexString(const _B: TBytes): string; overload;\nprocedure MVCCryptInit;\n\nimplementation\n\nuses\n  IdSSLOpenSSL, MVCFramework.Commons;\n\n{\n  PBKDF2 algorithm implementation from\n  https://stackoverflow.com/a/20134669/6825479\n  and then slighly modified. Copyright, if any, is from the original owner.\n}\n// Modeled after http://www.di-mgt.com.au/cryptoKDFs.html#PKCS5\nfunction PBKDF2(const Password: TBytes; const Salt: TBytes; const IterationsCount: Integer;\n  const KeyLengthInBytes: Integer; PRFC: TIdHMACClass = nil): TBytes;\nvar\n  PRF: TIdHMAC;\n  D: Integer;\n  I: Int32;\n  F: TIdBytes;\n  U: TIdBytes;\n  J: Integer;\n  T: TIdBytes;\n  lPassword, lSalt: TIdBytes;\n\n  function _ConcatenateBytes(const _B1: TIdBytes; const _B2: TIdBytes): TIdBytes; inline;\n  begin\n    SetLength(Result, Length(_B1) + Length(_B2));\n    if Length(_B1) > 0 then\n      Move(_B1[low(_B1)], Result[low(Result)], Length(_B1));\n    if Length(_B2) > 0 then\n      Move(_B2[low(_B2)], Result[low(Result) + Length(_B1)], Length(_B2));\n  end;\n\n  function _INT_32_BE(const _I: Int32): TIdBytes; inline;\n  begin\n    Result := TIdBytes.Create(_I shr 24, _I shr 16, _I shr 8, _I);\n  end;\n\n  procedure _XorBytes(var _B1: TIdBytes; const _B2: TIdBytes); inline;\n  var\n    _I: Integer;\n  begin\n    for _I := low(_B1) to high(_B1) do\n      _B1[_I] := _B1[_I] xor _B2[_I];\n  end;\n\nbegin\n  if not Assigned(PRFC) then\n    PRFC := TIdHMACSHA1;\n\n  try\n    PRF := PRFC.Create;\n  except\n    on E: Exception do\n    begin\n      if E.Message.Contains('is not available') then\n        raise EMVCException.Create(HTTP_STATUS.InternalServerError,\n          E.Message +\n          ' [HINT: May be OpenSSL is not been loaded yet. Did you invoked MVCCryptInit?]');\n      raise EMVCException.Create(HTTP_STATUS.InternalServerError, E.Message);\n    end;\n  end;\n  try\n    {\n      Conversion TBytes -> TidBytes as Remy Lebeau says\n      https://stackoverflow.com/a/18854367/6825479\n    }\n    lPassword := TIdBytes(Password);\n    lSalt := TIdBytes(Salt);\n\n    D := Ceil(KeyLengthInBytes / PRF.HashSize);\n    PRF.Key := lPassword;\n    for I := 1 to D do\n    begin\n      F := PRF.HashValue(_ConcatenateBytes(lSalt, _INT_32_BE(I)));\n      U := Copy(F);\n      for J := 2 to IterationsCount do\n      begin\n        U := PRF.HashValue(U);\n        _XorBytes(F, U);\n      end;\n      T := _ConcatenateBytes(T, F);\n    end;\n    Result := TBytes(Copy(T, low(T), KeyLengthInBytes));\n  finally\n    PRF.Free;\n  end;\nend;\n\nfunction BytesToHexString(const _B: TIdBytes): string; overload;\nvar\n  _I: Integer;\nbegin\n  for _I := low(_B) to high(_B) do\n    Result := Result + IntToHex(_B[_I], 2);\nend;\n\nfunction BytesToHexString(const _B: TBytes): string; overload;\nbegin\n  Result := BytesToHexString(TIdBytes(_B));\nend;\n\nprocedure MVCCryptInit;\nbegin\n  if not LoadOpenSSLLibrary then\n  begin\n    raise EMVCException.Create('Cannot load OpenSSL');\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace MVCFramework.Crypt.Utils\n{\n    public static class CryptUtils\n    {\n        \n        public static byte[] PBKDF2(byte[] password, byte[] salt, int iterationsCount, int keyLengthInBytes, HashAlgorithmName? prfc = null)\n        {\n            var algorithm = prfc ?? HashAlgorithmName.SHA1;\n            using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, iterationsCount, algorithm))\n            {\n                return deriveBytes.GetBytes(keyLengthInBytes);\n            }\n        }\n\n        public static string BytesToHexString(byte[] bytes)\n        {\n            if (bytes == null)\n                throw new ArgumentNullException(nameof(bytes));\n\n            var sb = new StringBuilder(bytes.Length * 2);\n            foreach (var b in bytes)\n            {\n                sb.AppendFormat(\"{0:x2}\", b);\n            }\n            return sb.ToString();\n        }\n\n        public static void MVCCryptInit()\n        {\n            \n            // If you need to enforce any checks (such as FIPS compliance), you could do so here.\n        }\n    }\n}"}
{"input": "{ Invokable interface ISOAPCustomer }\n\nunit SOAPCustomerIntfU;\n\ninterface\n\nuses Soap.InvokeRegistry, System.Types, Soap.XSBuiltIns;\n\ntype\n\n  { Invokable interfaces must derive from IInvokable }\n  ISOAPCustomer = interface(IInvokable)\n    ['{9D4C2E66-F0AB-470E-9A48-2084DAD75FD3}']\n    function GetCustomers: string; stdcall;\n    { Methods of Invokable interface must not use the default }\n    { calling convention; stdcall is recommended }\n  end;\n\nimplementation\n\ninitialization\n\n{ Invokable interfaces must be registered }\nInvRegistry.RegisterInterface(TypeInfo(ISOAPCustomer));\n\nend.", "output": "using System;\nusing System.Runtime.InteropServices;\nusing System.Web.Services;\nusing System.Web.Services.Protocols;\n\n[Guid(\"9D4C2E66-F0AB-470E-9A48-2084DAD75FD3\")]\n[WebServiceBinding(Name = \"ISOAPCustomerSoap\", Namespace = \"http://tempuri.org/\")]\npublic interface ISOAPCustomer\n{\n    [SoapDocumentMethod]\n    string GetCustomers();\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\n\nunit MVCFramework.Tests.AppController;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Generics.Collections,\n  System.Classes,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Server,\n  MVCFramework.Serializer.Commons;\n\ntype\n  [MVCNameCase(ncAsIs)]\n  TAppUser = class\n  strict private\n    FCod: Integer;\n    FName: string;\n    FPass: string;\n  public\n    property Cod: Integer read FCod write FCod;\n    property Name: string read FName write FName;\n    property Pass: string read FPass write FPass;\n  end;\n\n  [MVCPath('/')]\n  TAppController = class(TMVCController)\n  public\n    [MVCPath('/hello')]\n    [MVCHTTPMethod([httpGET])]\n    procedure HelloWorld(ctx: TWebContext);\n\n    [MVCPath('/user')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetUser(ctx: TWebContext);\n\n    [MVCPath('/user/save')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure PostUser(ctx: TWebContext);\n\n    [MVCPath('/users')]\n    [MVCHTTPMethod([httpGET])]\n    procedure GetUsers(ctx: TWebContext);\n\n    [MVCPath('/users/save')]\n    [MVCHTTPMethod([httpPOST])]\n    procedure PostUsers(ctx: TWebContext);\n\n    [MVCPath('/file/upload')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCConsumes(TMVCMediaType.MULTIPART_FORM_DATA)]\n    procedure ReceiveFile;\n\n    [MVCPath('/body-url-encoded')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCConsumes(TMVCMediaType.APPLICATION_FORM_URLENCODED)]\n    procedure PostBodyURLEncoded;\n  end;\n\nimplementation\n\nuses\n  System.Hash, JsonDataObjects;\n\n{ TAppController }\n\nprocedure TAppController.GetUser(ctx: TWebContext);\nvar\n  LUser: TAppUser;\nbegin\n  LUser := TAppUser.Create;\n  try\n    LUser.Cod := 1;\n    LUser.Name := 'Ezequiel';\n    LUser.Pass := '123';\n  finally\n    Render(LUser, True);\n  end;\nend;\n\nprocedure TAppController.GetUsers(ctx: TWebContext);\nvar\n  LUsers: TObjectList<TAppUser>;\n  LUser: TAppUser;\n  I: Integer;\nbegin\n  LUsers := TObjectList<TAppUser>.Create(True);\n\n  for I := 0 to 10 do\n  begin\n    LUser := TAppUser.Create;\n    LUser.Cod := I;\n    LUser.Name := 'Ezequiel ' + IntToStr(I);\n    LUser.Pass := IntToStr(I);\n\n    LUsers.Add(LUser);\n  end;\n\n  Self.Render<TAppUser>(LUsers, True);\nend;\n\nprocedure TAppController.HelloWorld(ctx: TWebContext);\nbegin\n  Render('Hello World called with GET');\nend;\n\nprocedure TAppController.PostBodyURLEncoded;\nvar\n  lResponse: TJDOJsonObject;\n  lParamValue: string;\nbegin\n  lResponse := TJDOJsonObject.Create;\n\n  if Context.Request.ContentFields.TryGetValue('field1', lParamValue) then\n    lResponse.S['field1'] := lParamValue\n  else\n    lResponse.S['field1'] := '';\n\n  if Context.Request.ContentFields.TryGetValue('field2', lParamValue) then\n    lResponse.S['field2'] := lParamValue\n  else\n    lResponse.S['field2'] := '';\n\n  if Context.Request.ContentFields.TryGetValue('field3', lParamValue) then\n    lResponse.S['field3'] := lParamValue\n  else\n    lResponse.S['field3'] := '';\n\n  Render(lResponse);\nend;\n\nprocedure TAppController.PostUser(ctx: TWebContext);\nvar\n  LUser: TAppUser;\nbegin\n  LUser := ctx.Request.BodyAs<TAppUser>();\n  try\n    if (LUser.Cod > 0) then\n      Render('Success!')\n    else\n      Render('Error!');\n  finally\n    LUser.Free;\n  end;\nend;\n\nprocedure TAppController.PostUsers(ctx: TWebContext);\nvar\n  LUsers: TObjectList<TAppUser>;\nbegin\n  LUsers := ctx.Request.BodyAsListOf<TAppUser>();\n  try\n    LUsers.OwnsObjects := True;\n\n    if (LUsers.Count > 0) then\n      Render('Success!')\n    else\n      Render('Error!');\n\n  finally\n    LUsers.Free;\n  end;\nend;\n\nprocedure TAppController.ReceiveFile;\nbegin\n  if Context.Request.Files.Count = 0 then\n  begin\n    Render(HTTP_STATUS.BadRequest, 'No file found!')\n  end\n  else\n  begin\n    Render(THashMD5.GetHashString(Context.Request.Files[0].Stream))\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Http;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.Tests\n{\n    // This model corresponds to the Delphi TAppUser\n    public class AppUser\n    {\n        public int Cod { get; set; }\n        public string Name { get; set; }\n        public string Pass { get; set; }\n    }\n\n    // The controller routes are defined using attributes.\n    // In Delphi they were defined with [MVCPath] and [MVCHTTPMethod]\n    [ApiController]\n    [Route(\"/\")]\n    public class AppController : ControllerBase\n    {\n        // GET /hello\n        [HttpGet(\"hello\")]\n        public IActionResult HelloWorld()\n        {\n            return Ok(\"Hello World called with GET\");\n        }\n\n        // GET /user\n        [HttpGet(\"user\")]\n        public IActionResult GetUser()\n        {\n            var user = new AppUser\n            {\n                Cod = 1,\n                Name = \"Ezequiel\",\n                Pass = \"123\"\n            };\n\n            // Render returns the user as JSON (automatically by ASP.NET Core)\n            return Ok(user);\n        }\n\n        // POST /user/save\n        [HttpPost(\"user/save\")]\n        public async Task<IActionResult> PostUser()\n        {\n            // The framework will bind the JSON body to an AppUser object.\n            // Using System.Text.Json (or you may use Newtonsoft.Json if preferred)\n            var user = await System.Text.Json.JsonSerializer.DeserializeAsync<AppUser>(Request.Body);\n            if (user != null && user.Cod > 0)\n            {\n                return Ok(\"Success!\");\n            }\n            else\n            {\n                return BadRequest(\"Error!\");\n            }\n        }\n\n        // GET /users\n        [HttpGet(\"users\")]\n        public IActionResult GetUsers()\n        {\n            var users = new List<AppUser>();\n            for (int i = 0; i <= 10; i++)\n            {\n                users.Add(new AppUser\n                {\n                    Cod = i,\n                    Name = $\"Ezequiel {i}\",\n                    Pass = i.ToString()\n                });\n            }\n\n            return Ok(users);\n        }\n\n        // POST /users/save\n        [HttpPost(\"users/save\")]\n        public async Task<IActionResult> PostUsers()\n        {\n            // Deserialize a JSON array of AppUser objects\n            var users = await System.Text.Json.JsonSerializer.DeserializeAsync<List<AppUser>>(Request.Body);\n            if (users != null && users.Count > 0)\n            {\n                return Ok(\"Success!\");\n            }\n            else\n            {\n                return BadRequest(\"Error!\");\n            }\n        }\n\n        // POST /file/upload\n        [HttpPost(\"file/upload\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ReceiveFile([FromForm] IFormFile file)\n        {\n            if (file == null)\n            {\n                return BadRequest(\"No file found!\");\n            }\n\n            // Compute the MD5 hash of the uploaded file stream\n            using (var md5 = MD5.Create())\n            using (var stream = file.OpenReadStream())\n            {\n                var hashBytes = await md5.ComputeHashAsync(stream);\n                // Convert hash to a hexadecimal string\n                var hashString = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLower();\n                return Ok(hashString);\n            }\n        }\n\n        // POST /body-url-encoded\n        [HttpPost(\"body-url-encoded\")]\n        [Consumes(\"application/x-www-form-urlencoded\")]\n        public IActionResult PostBodyURLEncoded([FromForm] Dictionary<string, string> formData)\n        {\n            var response = new JObject();\n            response[\"field1\"] = formData.TryGetValue(\"field1\", out var field1) ? field1 : \"\";\n            response[\"field2\"] = formData.TryGetValue(\"field2\", out var field2) ? field2 : \"\";\n            response[\"field3\"] = formData.TryGetValue(\"field3\", out var field3) ? field3 : \"\";\n            return Ok(response);\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\u00fcller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomTypesSerializersU;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Intf,\n  System.Rtti,\n  MVCFramework.Serializer.Commons;\n\ntype\n  // Custom serializer for TUserRoles type\n  TUserRolesSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    // procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n    // const AAttributes: TArray<TCustomAttribute>);\n    // procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n    // const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\n  // Custom serializer for TSysUserSerializer type\n  TSysUserSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction = nil);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\n\n  // Custom serializer for TNullableAliasSerializer type\n  TNullableAliasSerializer = class(TInterfacedObject, IMVCTypeSerializer)\n  public\n    procedure Serialize(const AElementValue: TValue; var ASerializerObject: TObject;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure Deserialize(const ASerializedObject: TObject; var AElementValue: TValue;\n      const AAttributes: TArray<TCustomAttribute>);\n    procedure SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>;\n      const ASerializationAction: TMVCSerializationAction);\n    procedure DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n      const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\n    procedure DeserializeRoot(const ASerializerObject: TObject; const AObject: TObject;\n      const AAttributes: System.TArray<System.TCustomAttribute>);\n  end;\n\nimplementation\n\nuses\n  JsonDataObjects,\n  CustomTypesU,\n  MVCFramework.Serializer.JsonDataObjects,\n  System.SysUtils;\n\n{ TUserPasswordSerializer }\n\nprocedure TUserRolesSerializer.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n  raise Exception.Create('To implement');\nend;\n\nprocedure TUserRolesSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TUserRolesSerializer.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nvar\n  lJSONArr: TJDOJsonArray;\n  lRole: string;\n  I: Integer;\nbegin\n  // I know that the selected serializer uses JsonDataObject as serialization engine.\n  // You have to check the serializer documentation to find out what are the\n  // correct objects to create here!\n\n  lJSONArr := (ASerializerObject as TJDOJsonObject).A[APropertyName];\n  { Here I want to serialize the userroles array as json array }\n  // reading from the AElementValue\n  lJSONArr.Add('--begin--'); { just to prove that the custom serialization happends }\n  for I := 0 to AElementValue.GetArrayLength - 1 do\n  begin\n    lRole := AElementValue.GetArrayElement(I).AsString;\n    lJSONArr.Add(lRole);\n  end;\n  lJSONArr.Add('--end--'); { just to prove that the custom serialization happends }\nend;\n\n{ TNullableAliasSerializer }\n\nprocedure TNullableAliasSerializer.Deserialize(const ASerializedObject: TObject;\n  var AElementValue: TValue;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.DeserializeAttribute(var AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.Serialize(const AElementValue: TValue;\n  var ASerializerObject: TObject;\n  const AAttributes: TArray<TCustomAttribute>);\nbegin\n  raise Exception.Create('TODO');\n  // ASerializerObject := TJsonValue.Create;\n  // TJsonValue(ASerializerObject).Value := AElementValue.AsType<TNullableRecordAlias>.Value;\nend;\n\nprocedure TNullableAliasSerializer.SerializeAttribute(const AElementValue: TValue;\n  const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TNullableAliasSerializer.SerializeRoot(const AObject: TObject;\n  out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction);\nbegin\n  raise EMVCSerializationException.CreateFmt('%s cannot be used as root object', [ClassName]);\nend;\n\nprocedure TUserRolesSerializer.SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>;\n  const ASerializationAction: TMVCSerializationAction = nil);\nbegin\n  raise EMVCSerializationException.CreateFmt('%s cannot be used as root object', [ClassName]);\nend;\n\n{ TSysUserSerializer }\n\nprocedure TSysUserSerializer.DeserializeAttribute(var AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TSysUserSerializer.DeserializeRoot(const ASerializerObject, AObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n\nend;\n\nprocedure TSysUserSerializer.SerializeAttribute(const AElementValue: TValue; const APropertyName: string;\n  const ASerializerObject: TObject; const AAttributes: System.TArray<System.TCustomAttribute>);\nbegin\n  (ASerializerObject as TJDOJsonObject).S['prop'] := 'hello there attribute';\nend;\n\nprocedure TSysUserSerializer.SerializeRoot(const AObject: TObject; out ASerializerObject: TObject;\n  const AAttributes: System.TArray<System.TCustomAttribute>; const ASerializationAction: TMVCSerializationAction);\nvar\n  lJObj: TJDOJsonObject;\nbegin\n  lJObj := (ASerializerObject as TJDOJsonObject);\n  lJObj.S['username'] := TSysUser(AObject).UserName;\n  lJObj.S['roles'] := String.Join(',', TSysUser(AObject).Roles);\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\n\nnamespace CustomTypesSerializersU\n{\n    public class MVCSerializationException : Exception\n    {\n        public MVCSerializationException(string message) : base(message) { }\n    }\n\n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes);\n    }\n\n    public class TUserRolesSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            JArray jArray = jObj[propertyName] as JArray;\n            if (jArray == null)\n            {\n                jArray = new JArray();\n                jObj[propertyName] = jArray;\n            }\n\n            jArray.Add(\"--begin--\");\n\n            if (elementValue is IEnumerable<string> roles)\n            {\n                foreach (var role in roles)\n                    jArray.Add(role);\n            }\n            else if (elementValue is string[] rolesArray)\n            {\n                foreach (var role in rolesArray)\n                    jArray.Add(role);\n            }\n\n            jArray.Add(\"--end--\");\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"To implement\");\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TSysUserSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            jObj[\"prop\"] = \"hello there attribute\";\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            JObject jObj = new JObject();\n            serializerObject = jObj;\n\n            if (!(obj is TSysUser user))\n                throw new Exception(\"obj is not of type TSysUser.\");\n\n            jObj[\"username\"] = user.UserName;\n            jObj[\"roles\"] = string.Join(\",\", user.Roles);\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TNullableAliasSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(object elementValue, ref object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"TODO\");\n        }\n\n        public void Deserialize(object serializedObject, ref object elementValue, Attribute[] attributes)\n        {\n            // No implementation.\n        }\n\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n    }\n\n    public class TSysUser\n    {\n        public string UserName { get; set; }\n        public List<string> Roles { get; set; }\n    }\n}"}
{"input": "unit EntitiesProcessors;\n\ninterface\n\nuses\n  MVCFramework.ActiveRecord,\n  MVCFramework,\n  MVCFramework.Serializer.Intf;\n\ntype\n  TArticleProcessor = class(TInterfacedObject, IMVCEntityProcessor)\n  public\n    procedure CreateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntities(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n  end;\n\n  TContactProcessor = class(TInterfacedObject, IMVCEntityProcessor)\n  public\n    procedure CreateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntities(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string;\n      var Handled: Boolean);\n    procedure GetEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure UpdateEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n    procedure DeleteEntity(const Context: TWebContext;\n      const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n      var Handled: Boolean);\n  end;\n\nimplementation\n\n{ TArticleProcessor }\n\nuses\n  System.SysUtils,\n  Entities,\n  MVCFramework.Serializer.JsonDataObjects,\n  JsonDataObjects,\n  MVCFramework.Serializer.Commons,\n  System.Generics.Collections,\n  MVCFramework.DuckTyping, MVCFramework.Commons, System.NetEncoding;\n\nprocedure TArticleProcessor.CreateEntity(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nvar\n  lArticle: TArticle;\nbegin\n  lArticle := Context.Request.BodyAs<TArticle>;\n  try\n    lArticle.Insert;\n    Renderer.Render(lArticle, False);\n  finally\n    lArticle.Free;\n  end;\n  Handled := True;\nend;\n\nprocedure TArticleProcessor.DeleteEntity(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; const id: Integer;\n  var Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\nprocedure TArticleProcessor.GetEntities(const Context: TWebContext;\n  const Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nbegin\n  Handled := True;\n  Renderer.Render(ObjectDict().Add('data', TMVCActiveRecord.All<TArticle>,\n    procedure(const AObject: TObject; const Links: IMVCLinks)\n    begin\n      Links.AddRefLink\n        .Add(HATEOAS.HREF, 'https://www.google.com/search?q=' + TNetEncoding.URL.EncodeQuery(TArticle(AObject).Description))\n        .Add(HATEOAS._TYPE, 'text/html')\n        .Add(HATEOAS.REL, 'googlesearch');\n    end));\nend;\n\nprocedure TArticleProcessor.GetEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\nprocedure TArticleProcessor.UpdateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False;\nend;\n\n{ TPeopleProcessor }\n\nprocedure TContactProcessor.CreateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lJSON: TJsonObject;\n  lPerson: TPerson;\n  lPhones: TObjectList<TPhone>;\n  lPhone: TPhone;\n  lID: Int64;\nbegin\n  Handled := True;\n\n  // If you have an entity already defined you can use the usual BodyAs<T>, if not\n  // you have to deserialize request body manually\n  lSer := TMVCJsonDataObjectsSerializer.Create;\n  try\n    lJSON := lSer.ParseObject(Context.Request.Body);\n    try\n      lPerson := TPerson.Create;\n      try\n        // deserialize person\n        lSer.JsonObjectToObject(lJSON, lPerson,\n          TMVCSerializationType.stDefault, nil);\n\n        lPhones := TObjectList<TPhone>.Create(True);\n        try\n          // deserialize phones\n          lSer.JsonArrayToList(lJSON.A['phones'], WrapAsList(lPhones), TPhone,\n            TMVCSerializationType.stDefault, nil);\n\n          // persist to database using transaction\n          TMVCActiveRecord.CurrentConnection.StartTransaction;\n          try\n            lPerson.Insert; // insert Person\n            lID := lPerson.id;\n            for lPhone in lPhones do\n            begin\n              lPhone.IDPerson := lPerson.id;\n              lPhone.Insert; // insert phone\n            end;\n            TMVCActiveRecord.CurrentConnection.Commit;\n          except\n            TMVCActiveRecord.CurrentConnection.Rollback;\n            raise;\n          end;\n\n        finally\n          lPhones.Free;\n        end;\n      finally\n        lPerson.Free;\n      end;\n    finally\n      lJSON.Free;\n    end;\n  finally\n    lSer.Free;\n  end;\n  Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo +\n    '/' + lID.ToString;\n  Renderer.Render(TMVCResponse.Create(201, 'Contact created with phones'));\nend;\n\nprocedure TContactProcessor.DeleteEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\nprocedure TContactProcessor.GetEntities(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; var Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\nprocedure TContactProcessor.GetEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nvar\n  lContact: TContact;\n  lSer: TMVCJsonDataObjectsSerializer;\n  lJSON: TJsonObject;\n  lPhones: TObjectList<TPhone>;\nbegin\n  // You can write your own entity which already load relations\n  // The following is the manual approach\n  lContact := TMVCActiveRecord.GetByPK<TContact>(id);\n  try\n    lPhones := TMVCActiveRecord.Where<TPhone>('id_person = ?', [id]);\n    try\n      lSer := TMVCJsonDataObjectsSerializer.Create;\n      try\n        lJSON := TJsonObject.Create;\n        try\n          lSer.ObjectToJsonObject(lContact, lJSON,\n            TMVCSerializationType.stDefault, nil);\n          lSer.ListToJsonArray(WrapAsList(lPhones), lJSON.A['phones'],\n            TMVCSerializationType.stDefault, nil);\n          Renderer.Render(lJSON, False);\n        finally\n          lJSON.Free;\n        end;\n      finally\n        lSer.Free;\n      end;\n    finally\n      lPhones.Free;\n    end;\n  finally\n    lContact.Free;\n  end;\n  Handled := True;\nend;\n\nprocedure TContactProcessor.UpdateEntity(const Context: TWebContext;\nconst Renderer: TMVCRenderer; const entityname: string; const id: Integer;\nvar Handled: Boolean);\nbegin\n  Handled := False; // inherit the default behaviour\nend;\n\ninitialization\n\nActiveRecordMappingRegistry.AddEntityProcessor('articles',\n  TArticleProcessor.Create);\nActiveRecordMappingRegistry.AddEntityProcessor('contacts',\n  TContactProcessor.Create);\n\nfinalization\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing Newtonsoft.Json.Linq;\nusing Newtonsoft.Json;\nusing System.Linq;\n\nnamespace EntitiesProcessors\n{\n    \n    public class WebContext\n    {\n        public RequestData Request { get; set; } = new RequestData();\n        public ResponseData Response { get; set; } = new ResponseData();\n    }\n\n    public class RequestData\n    {\n        \n        public T BodyAs<T>()\n        {\n            \n            return Activator.CreateInstance<T>();\n        }\n        public string PathInfo { get; set; } = \"/api/contacts\";\n        public string Body { get; set; }\n    }\n\n    public class ResponseData\n    {\n        public Dictionary<string, string> CustomHeaders { get; set; } = new Dictionary<string, string>();\n    }\n\n    \n    public class MVCRenderer\n    {\n        public void Render(object obj, bool formatted = true)\n        {\n            \n            Console.WriteLine(JsonConvert.SerializeObject(obj, Formatting.Indented));\n        }\n    }\n\n    \n    public class Link\n    {\n        public string HREF { get; set; }\n        public string TYPE { get; set; }\n        public string REL { get; set; }\n    }\n\n    \n    public class TArticle\n    {\n        public string Description { get; set; } = \"Default description\";\n        public List<Link> Links { get; set; } = new List<Link>();\n\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Article inserted.\");\n        }\n    }\n\n    \n    public class TContact\n    {\n        // Properties for a contact entity.\n    }\n\n    public class TPhone\n    {\n        public int IDPerson { get; set; }\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Phone inserted.\");\n        }\n    }\n\n    public class TPerson\n    {\n        public long id { get; set; }\n        public void Insert()\n        {\n            \n            Console.WriteLine(\"Person inserted.\");\n            \n            id = new Random().Next(1000, 9999);\n        }\n    }\n\n    \n    public static class TMVCActiveRecord\n    {\n        \n        public static List<T> All<T>() where T : new() => new List<T>();\n\n        \n        public static T GetByPK<T>(int id) where T : new() => new T();\n\n        public static List<T> Where<T>(string query, params object[] args) where T : new() => new List<T>();\n\n        public static ConnectionWrapper CurrentConnection { get; } = new ConnectionWrapper();\n    }\n\n    public class ConnectionWrapper\n    {\n        public void StartTransaction() { Console.WriteLine(\"Transaction started.\"); }\n        public void Commit() { Console.WriteLine(\"Transaction committed.\"); }\n        public void Rollback() { Console.WriteLine(\"Transaction rolled back.\"); }\n    }\n\n    public enum MVCSerializationType { stDefault }\n\n    public class MVCTJsonDataObjectsSerializer : IDisposable\n    {\n        public JObject ParseObject(string body)\n        {\n            return JObject.Parse(body);\n        }\n\n        public void JsonObjectToObject(JObject json, object target, MVCSerializationType serializationType, object options)\n        {\n            JsonConvert.PopulateObject(json.ToString(), target);\n        }\n\n        public void JsonArrayToList<T>(JArray jsonArray, List<T> list, MVCSerializationType serializationType, object options)\n        {\n            var items = jsonArray.ToObject<List<T>>();\n            list.AddRange(items);\n        }\n\n        public void ObjectToJsonObject(object obj, JObject json, MVCSerializationType serializationType, object options)\n        {\n            var temp = JObject.FromObject(obj);\n            json.Merge(temp);\n        }\n\n        public void ListToJsonArray<T>(List<T> list, JArray jsonArray, MVCSerializationType serializationType, object options)\n        {\n            jsonArray.Merge(JArray.FromObject(list));\n        }\n\n        public void Dispose()\n        {\n            // Dispose resources if needed.\n        }\n    }\n\n    public List<T> WrapAsList<T>(List<T> list) => list;\n\n    public class MVCRResponse\n    {\n        public int StatusCode { get; set; }\n        public string Message { get; set; }\n        public MVCRResponse(int statusCode, string message)\n        {\n            StatusCode = statusCode;\n            Message = message;\n        }\n    }\n\n    public static class ActiveRecordMappingRegistry\n    {\n        private static Dictionary<string, IMVCEntityProcessor> _processors = new Dictionary<string, IMVCEntityProcessor>();\n        public static void AddEntityProcessor(string entityName, IMVCEntityProcessor processor)\n        {\n            _processors[entityName] = processor;\n            Console.WriteLine($\"Entity processor for '{entityName}' registered.\");\n        }\n    }\n    public interface IMVCEntityProcessor\n    {\n        void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled);\n        void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled);\n        void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n        void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n        void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled);\n    }\n    public class ArticleProcessor : IMVCEntityProcessor\n    {\n        public void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            TArticle article = context.Request.BodyAs<TArticle>();\n            try\n            {\n                article.Insert();\n                renderer.Render(article, false);\n            }\n            finally\n            {\n                \n                (article as IDisposable)?.Dispose();\n            }\n            handled = true;\n        }\n\n        public void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = true;\n            \n            List<TArticle> articles = TMVCActiveRecord.All<TArticle>();\n\n            foreach (var article in articles)\n            {\n                string encoded = WebUtility.UrlEncode(article.Description);\n                article.Links.Add(new Link\n                {\n                    HREF = \"https://www.google.com/search?q=\" + encoded,\n                    TYPE = \"text/html\",\n                    REL = \"googlesearch\"\n                });\n            }\n\n            var dict = new Dictionary<string, object> { { \"data\", articles } };\n            renderer.Render(dict);\n        }\n\n        public void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n    }\n\n    public class ContactProcessor : IMVCEntityProcessor\n    {\n        public void CreateEntity(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = true;\n            long lID = 0;\n            using (var ser = new MVCTJsonDataObjectsSerializer())\n            {\n                JObject lJSON = ser.ParseObject(context.Request.Body);\n                try\n                {\n                    TPerson person = new TPerson();\n                    ser.JsonObjectToObject(lJSON, person, MVCSerializationType.stDefault, null);\n\n                    List<TPhone> phones = new List<TPhone>();\n                    ser.JsonArrayToList(lJSON[\"phones\"] as JArray, phones, MVCSerializationType.stDefault, null);\n\n                    TMVCActiveRecord.CurrentConnection.StartTransaction();\n                    try\n                    {\n                        person.Insert();\n                        lID = person.id;\n                        foreach (var phone in phones)\n                        {\n                            phone.IDPerson = (int)person.id;\n                            phone.Insert();\n                        }\n                        TMVCActiveRecord.CurrentConnection.Commit();\n                    }\n                    catch (Exception)\n                    {\n                        TMVCActiveRecord.CurrentConnection.Rollback();\n                        throw;\n                    }\n                }\n                finally\n                {\n                    // Free the JSON object if needed.\n                }\n            }\n            context.Response.CustomHeaders[\"X-REF\"] = context.Request.PathInfo + \"/\" + lID.ToString();\n            renderer.Render(new MVCRResponse(201, \"Contact created with phones\"));\n        }\n\n        public void GetEntities(WebContext context, MVCRenderer renderer, string entityname, ref bool handled)\n        {\n            handled = false; \n        }\n\n        public void GetEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            TContact contact = TMVCActiveRecord.GetByPK<TContact>(id);\n            List<TPhone> phones = TMVCActiveRecord.Where<TPhone>(\"id_person = ?\", id.ToString());\n            using (var ser = new MVCTJsonDataObjectsSerializer())\n            {\n                JObject lJSON = new JObject();\n                ser.ObjectToJsonObject(contact, lJSON, MVCSerializationType.stDefault, null);\n                if (lJSON[\"phones\"] == null)\n                    lJSON[\"phones\"] = new JArray();\n                ser.ListToJsonArray(phones, lJSON[\"phones\"] as JArray, MVCSerializationType.stDefault, null);\n                renderer.Render(lJSON, false);\n            }\n            handled = true;\n        }\n\n        public void UpdateEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n\n        public void DeleteEntity(WebContext context, MVCRenderer renderer, string entityname, int id, ref bool handled)\n        {\n            handled = false;\n        }\n    }\n\n\n    public static class EntitiesProcessorsRegistration\n    {\n        static EntitiesProcessorsRegistration()\n        {\n            ActiveRecordMappingRegistry.AddEntityProcessor(\"articles\", new ArticleProcessor());\n            ActiveRecordMappingRegistry.AddEntityProcessor(\"contacts\", new ContactProcessor());\n        }\n    }\n}"}
{"input": "unit MainDataModuleUnit;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  MVCFramework.Commons,\n  Data.DB,\n  Data.SqlExpr,\n  FireDAC.Stan.Intf,\n  FireDAC.Stan.Option,\n  FireDAC.Stan.Error,\n  FireDAC.UI.Intf,\n  FireDAC.Phys.Intf,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Phys,\n  FireDAC.Comp.Client,\n  FireDAC.Stan.Param,\n  FireDAC.DatS,\n  FireDAC.DApt.Intf,\n  FireDAC.DApt,\n  FireDAC.Comp.DataSet,\n  FireDAC.Phys.IBBase,\n  FireDAC.Phys.FB,\n  WinesBO,\n  FireDAC.Phys.FBDef,\n  FireDAC.VCLUI.Wait;\n\ntype\n  TWineCellarDataModule = class(TDataModule)\n    Connection: TFDConnection;\n    qryWines: TFDQuery;\n    updWines: TFDUpdateSQL;\n    FDPhysFBDriverLink1: TFDPhysFBDriverLink;\n    procedure ConnectionBeforeConnect(Sender: TObject);\n\n  public\n    function GetWineById(id: Integer): TDataSet;\n    function FindWines(Search: string): TDataSet;\n    function GetAllWines: TDataSet;\n    procedure AddWine(AWine: TWine);\n    procedure UpdateWine(AWine: TWine);\n    procedure DeleteWine(id: Integer);\n  end;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  System.StrUtils,\n  MVCFramework.FireDAC.Utils;\n\n{ TCellarSM }\n\nprocedure TWineCellarDataModule.AddWine(AWine: TWine);\nbegin\n  TFireDACUtils.ObjectToParameters(updWines.Commands[arInsert].Params, AWine, 'NEW_');\n  updWines.Commands[arInsert].Execute;\nend;\n\nprocedure TWineCellarDataModule.DeleteWine(id: Integer);\nbegin\n  updWines.Commands[arDelete].ParamByName('OLD_ID').AsInteger := id;\n  updWines.Commands[arDelete].Execute;\nend;\n\nprocedure TWineCellarDataModule.ConnectionBeforeConnect(Sender: TObject);\nvar\n  lDBPath: string;\nbegin\n  // if database is defined in .env use that, otherwise try to\n  // understand where the database is\n  if not dotEnv.Env('database.path').IsEmpty then\n  begin\n    Connection.Params.Values['Database'] := dotEnv.Env('database.path');\n  end\n  else\n  begin\n    if not IsLibrary then\n    begin\n      // Is compiled as EXE\n      Connection.Params.Values['Database'] := ExtractFilePath(ParamStr(0)) + '..\\..\\WINES_FB30.FDB';\n    end\n    else\n    begin\n      // compiled as apache module or isapi\n      lDBPath := ExtractFilePath(GetModuleName(HInstance)) + '..\\..\\..\\wine_cellar_sample\\winecellarserver\\WINES_FB30.FDB';\n      if lDBPath.StartsWith('\\\\?\\') then\n        lDBPath := lDBPath.Remove(0, 4);\n      Connection.Params.Values['Database'] := lDBPath;\n    end;\n  end;\nend;\n\nfunction TWineCellarDataModule.FindWines(Search: string): TDataSet;\nbegin\n  if Search.IsEmpty then\n    qryWines.Open('SELECT * FROM wine')\n  else\n    qryWines.Open('SELECT * FROM wine where NAME CONTAINING ?', [Search]);\n  Result := qryWines;\nend;\n\nfunction TWineCellarDataModule.GetAllWines: TDataSet;\nbegin\n  Result := FindWines('');\nend;\n\nfunction TWineCellarDataModule.GetWineById(id: Integer): TDataSet;\nbegin\n  qryWines.Open('SELECT * FROM wine where id = ?', [id]);\n  Result := qryWines;\nend;\n\nprocedure TWineCellarDataModule.UpdateWine(AWine: TWine);\nbegin\n  TFireDACUtils.ObjectToParameters(updWines.Commands[arUpdate].Params, AWine, 'NEW_');\n  updWines.Commands[arUpdate].Params.ParamByName('OLD_ID').AsInteger := AWine.id;\n  updWines.Commands[arUpdate].Execute;\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing System.IO;\nusing FirebirdSql.Data.FirebirdClient;\nusing WinesBO; \n\nnamespace MyApp.Data\n{\n    \n    public class WineCellarDataModule : IDisposable\n    {\n        \n        private FbConnection _connection;\n\n        \n        public WineCellarDataModule()\n        {\n            \n            _connection = new FbConnection();\n            _connection.ConnectionString = \"\"; \n            ConnectionBeforeConnect();\n        }\n\n       \n        private void ConnectionBeforeConnect()\n        {\n            string envDbPath = Environment.GetEnvironmentVariable(\"database.path\");\n            string dbPath;\n            if (!string.IsNullOrEmpty(envDbPath))\n            {\n                dbPath = envDbPath;\n            }\n            else\n            {\n                \n                string exePath = AppDomain.CurrentDomain.BaseDirectory;\n                dbPath = Path.Combine(exePath, @\"..\\..\\WINES_FB30.FDB\");\n            }\n\n            \n            _connection.ConnectionString =\n                $\"User=SYSDBA;Password=masterkey;Database={dbPath};DataSource=localhost;Port=3050;Dialect=3;Charset=NONE;Pooling=true;\";\n        }\n\n        \n        public DataSet GetAllWines()\n        {\n            return FindWines(\"\");\n        }\n\n        \n        public DataSet GetWineById(int id)\n        {\n            string sql = \"SELECT * FROM wine WHERE id = @id\";\n            return ExecuteQuery(sql, new FbParameter(\"@id\", id));\n        }\n\n        \n        public DataSet FindWines(string search)\n        {\n            string sql;\n            FbParameter param = null;\n            if (string.IsNullOrWhiteSpace(search))\n            {\n                sql = \"SELECT * FROM wine\";\n            }\n            else\n            {\n                sql = \"SELECT * FROM wine WHERE NAME CONTAINING @search\";\n                param = new FbParameter(\"@search\", search);\n            }\n            return ExecuteQuery(sql, param);\n        }\n\n        \n        public void AddWine(TWine wine)\n        {\n            \n            string sql = \"INSERT INTO wine (NAME, YEAR, DESCRIPTION) VALUES (@NEW_Name, @NEW_Year, @NEW_Description)\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                \n                cmd.Parameters.AddWithValue(\"@NEW_Name\", wine.Name);\n                cmd.Parameters.AddWithValue(\"@NEW_Year\", wine.Year);\n                cmd.Parameters.AddWithValue(\"@NEW_Description\", wine.Description);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        public void UpdateWine(TWine wine)\n        {\n            \n            string sql = \"UPDATE wine SET NAME = @NEW_Name, YEAR = @NEW_Year, DESCRIPTION = @NEW_Description WHERE id = @OLD_ID\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                cmd.Parameters.AddWithValue(\"@NEW_Name\", wine.Name);\n                cmd.Parameters.AddWithValue(\"@NEW_Year\", wine.Year);\n                cmd.Parameters.AddWithValue(\"@NEW_Description\", wine.Description);\n                cmd.Parameters.AddWithValue(\"@OLD_ID\", wine.Id);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        public void DeleteWine(int id)\n        {\n            string sql = \"DELETE FROM wine WHERE id = @OLD_ID\";\n            using (FbCommand cmd = new FbCommand(sql, _connection))\n            {\n                cmd.Parameters.AddWithValue(\"@OLD_ID\", id);\n                _connection.Open();\n                cmd.ExecuteNonQuery();\n                _connection.Close();\n            }\n        }\n\n        \n        private DataSet ExecuteQuery(string sql, params FbParameter[] parameters)\n        {\n            DataSet ds = new DataSet();\n            using (FbDataAdapter adapter = new FbDataAdapter(sql, _connection))\n            {\n                if (parameters != null && parameters.Length > 0)\n                {\n                    adapter.SelectCommand.Parameters.AddRange(parameters);\n                }\n                _connection.Open();\n                adapter.Fill(ds);\n                _connection.Close();\n            }\n            return ds;\n        }\n\n        #region IDisposable Support\n        private bool disposedValue = false;\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    \n                    if (_connection != null)\n                    {\n                        _connection.Dispose();\n                        _connection = null;\n                    }\n                }\n                \n                disposedValue = true;\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        #endregion\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.GlobalLogger;\n\ninterface\n\nuses\n  LoggerPro;\n{ @abstract(The global logger. Just uses @link(Logger.GlobalLogger) and you can start to log using @code(Log) function.)\n  The global logger is configured with a @link(TLoggerProFileAppender) using default settings.\n}\nfunction Log: ILogWriter;\n\n{ @abstract(Use only inside DLL because dll unloading is not a safe place to shutdown threads, so call this before unload DLL)\n  Use this also in ISAPI dll. Check the @code(loggerproisapisample.dll) sample\n}\nprocedure ReleaseGlobalLogger;\n\nimplementation\n\nuses\n  LoggerPro.FileAppender;\n\nvar\n  _Logger: ILogWriter;\n  _Lock: TObject = nil;\n  _ShuttedDown: boolean = false;\n\nfunction Log: ILogWriter;\nbegin\n  if _Logger = nil then\n  begin\n    if not _ShuttedDown then\n    begin\n      TMonitor.Enter(_Lock);\n      try\n        if _Logger = nil then // double check\n        begin\n          _Logger := BuildLogWriter([TLoggerProFileAppender.Create]);\n        end;\n      finally\n        TMonitor.Exit(_Lock);\n      end;\n    end;\n  end;\n  Result := _Logger;\nend;\n\nprocedure ReleaseGlobalLogger;\nbegin\n  if _Logger <> nil then\n  begin\n    TMonitor.Enter(_Lock);\n    try\n      if _Logger <> nil then // double check\n      begin\n        _Logger := nil;\n        _ShuttedDown := True;\n      end;\n    finally\n      TMonitor.Exit(_Lock);\n    end;\n  end;\nend;\n\ninitialization\n\n_Lock := TObject.Create;\n\nfinalization\n\n_Lock.Free;\n\nend.", "output": "using System;\nusing LoggerPro; \nusing LoggerPro.Appenders; \n\nnamespace LoggerPro\n{\n   \n   public static class GlobalLogger\n   {\n      private static ILogWriter _logger = null;\n      private static readonly object _lock = new object();\n      private static bool _shuttedDown = false;\n\n      \n      public static ILogWriter Log\n      {\n         get\n         {\n            if (_logger == null)\n            {\n               if (!_shuttedDown)\n               {\n                  lock (_lock)\n                  {\n                     \n                     if (_logger == null)\n                     {\n                        \n                        _logger = LoggerProBuilder.BuildLogWriter(\n                           new ILogAppender[] { new LoggerProFileAppender() }\n                        );\n                     }\n                  }\n               }\n            }\n            return _logger;\n         }\n      }\n\n      \n      public static void ReleaseGlobalLogger()\n      {\n         if (_logger != null)\n         {\n            lock (_lock)\n            {\n               if (_logger != null)\n               {\n                  _logger = null;\n                  _shuttedDown = true;\n               }\n            }\n         }\n      }\n   }\n}"}
{"input": "unit LoggerProTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework, LoggerPro, LoggerPro.Proxy, System.SysUtils;\n\ntype\n\n  [TestFixture]\n  TLoggerProTest = class(TObject)\n  public\n    [Setup]\n    procedure Setup;\n    [TearDown]\n    procedure TearDown;\n    [Test]\n    procedure TestTLogItemClone;\n    [Test]\n    [TestCase('Type DEBUG', '0,DEBUG')]\n    [TestCase('Type INFO', '1,INFO')]\n    [TestCase('Type WARN', '2,WARNING')]\n    [TestCase('Type ERROR', '3,ERROR')]\n    [TestCase('Type FATAL', '4,FATAL')]\n    procedure TestTLogItemTypeAsString(aLogType: Byte; aExpected: String);\n\n//    [Test]   {refactor this}\n//    procedure TestOnAppenderError;\n\n    [Test]\n    [TestCase('No proxy', 'false')]\n    [TestCase('With proxy', 'true')]\n    procedure TestLogLevel(UseProxy: boolean);\n\n    [Test]\n    procedure TestAddAndDeleteAppenders;\n\n    [Test]\n    [TestCase('Case1', '{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG')]\n    [TestCase('Case2', '{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG')]\n    [TestCase('Case3', '{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE')]\n    [TestCase('Case4', '{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]')]\n    procedure TestLogLayoutToLogIndices(const LogLayout, ResultOutput: string);\n\n  end;\n\nimplementation\n\nuses\n  TestSupportAppendersU, System.SyncObjs, LoggerPro.OutputDebugStringAppender;\n\nfunction LogItemAreEquals(A, B: TLogItem): Boolean;\nbegin\n  Assert.AreEqual(A.LogType, B.LogType, 'LogType is different');\n  Assert.AreEqual(A.LogMessage, B.LogMessage, 'LogMessage is different');\n  Assert.AreEqual(A.LogTag, B.LogTag, 'LogTag is different');\n  Assert.AreEqual(A.TimeStamp, B.TimeStamp, 'TimeStamp is different');\n  Assert.AreEqual(A.ThreadID, B.ThreadID, 'ThreadID is different');\n  Result := True;\nend;\n\nprocedure TLoggerProTest.Setup;\nbegin\nend;\n\nprocedure TLoggerProTest.TearDown;\nbegin\nend;\n\nprocedure TLoggerProTest.TestAddAndDeleteAppenders;\nvar\n  LAppender1, LAppender2: ILogAppender;\n  LLogWriter: ILogWriter;\nbegin\n  LAppender1 := TLoggerProOutputDebugStringAppender.Create();\n  LAppender2 := TLoggerProOutputDebugStringAppender.Create();\n\n  LLogWriter := BuildLogWriter([LAppender1, LAppender2]);\n  LLogWriter.Debug('Added Appenders', 'Appender');\n  Assert.AreEqual(2, LLogWriter.AppendersCount);\n\n  LLogWriter.DelAppender(LAppender1);\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\n  Assert.AreEqual(1, LLogWriter.AppendersCount);\n\n  LLogWriter.DelAppender(LAppender2);\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\n  Assert.AreEqual(0, LLogWriter.AppendersCount);\n\n  LLogWriter.Debug('Deleted Appenders', 'Appender');\nend;\n\nprocedure TLoggerProTest.TestLogLayoutToLogIndices(const LogLayout, ResultOutput: string);\nbegin\n  var lWithIndices := LogLayoutByPlaceHoldersToLogLayoutByIndexes(LogLayout);\n  var s := Format(\n    lWithIndices,\n    [\n      FormatDateTime('yyyy-mm-dd hh:nn:ss:zzz', encodedate(2020,3,15) + EncodeTime(12,30,20,123)),\n      '1234',\n      'LOGLEVEL',\n      'THIS IS THE MESSAGE',\n      'THE_TAG'\n    ]);\n  Assert.AreEqual(ResultOutput, s);\nend;\n\nprocedure TLoggerProTest.TestLogLevel(UseProxy: boolean);\nvar\n  lSetup, lTearDown: TProc;\n  lTearDownCalled, lSetupCalled: Boolean;\n  lWriteLog: TProc<TLogItem>;\n  lLogWriter: ILogWriter;\n  lLogItem: TLogItem;\n  lEvent: TEvent;\n  lLock: TObject;\n  lHistory: TArray<String>;\n  Appender: ILogAppender;\n  InvalidItemLogged: int64;\nconst\n  STR_FORBIDDEN = 'ignoredmessage';\nbegin\n  lHistory := [];\n  lLock := TObject.Create;\n  try\n    lSetup := procedure\n      begin\n        lHistory := lHistory + ['setup'];\n        lSetupCalled := True;\n      end;\n    lTearDown := procedure\n      begin\n        lHistory := lHistory + ['teardown'];\n        lTearDownCalled := True;\n      end;\n    lWriteLog := procedure(aLogItem: TLogItem)\n      begin\n        lHistory := lHistory + ['writelog' + aLogItem.LogTypeAsString];\n        // If the logged message is suppsed to be filtered, increase the \"InvalidItemLogged\" count\n        if aLogItem.LogMessage.Equals(STR_FORBIDDEN) then\n          TInterlocked.Increment(InvalidItemLogged);\n        TMonitor.Enter(lLock);\n        try\n          FreeAndNil(lLogItem);\n          lLogItem := aLogItem.Clone;\n          lEvent.SetEvent;\n        finally\n          TMonitor.Exit(lLock);\n        end;\n      end;\n    Appender := TMyAppender.Create(lSetup, lTearDown, lWriteLog);\n    if UseProxy then\n    begin\n      Appender := TLoggerProFilter.Build(Appender,\n        function (LogItem: TLogItem): Boolean\n        begin\n          result := not LogItem.LogMessage.Equals(STR_FORBIDDEN);\n        end\n      );\n    end;\n    InvalidItemLogged := 0;\n    lLogWriter := BuildLogWriter([Appender]);\n    lEvent := TEvent.Create(nil, True, false, '');\n    try\n      // debug message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Debug('debug message', 'debug');\n      if UseProxy then\n        lLogWriter.Debug('ignoredmessage', 'debug');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('debug message', lLogItem.LogMessage);\n      Assert.AreEqual('debug', lLogItem.LogTag);\n      Assert.AreEqual('DEBUG', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // info message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Info('info message', 'info');\n      if UseProxy then\n        lLogWriter.Info('ignoredmessage', 'info');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('info message', lLogItem.LogMessage);\n      Assert.AreEqual('info', lLogItem.LogTag);\n      Assert.AreEqual('INFO', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // warning message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Warn('warning message', 'warning');\n      if UseProxy then\n        lLogWriter.Warn('ignoredmessage', 'warning');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('warning message', lLogItem.LogMessage);\n      Assert.AreEqual('warning', lLogItem.LogTag);\n      Assert.AreEqual('WARNING', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // error message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Error('error message', 'error');\n      if UseProxy then\n        lLogWriter.Error('ignoredmessage', 'error');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('error message', lLogItem.LogMessage);\n      Assert.AreEqual('error', lLogItem.LogTag);\n      Assert.AreEqual('ERROR', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n      // fatal message\n      lEvent.ResetEvent;\n      InvalidItemLogged := 0;\n      lLogWriter.Fatal('fatal message', 'fatal');\n      if UseProxy then\n        lLogWriter.Fatal('ignoredmessage', 'fatal');\n      Assert.AreEqual(TWaitResult.wrSignaled, lEvent.WaitFor(5000),\n        'Event not released after 5 seconds');\n      Assert.AreEqual('fatal message', lLogItem.LogMessage);\n      Assert.AreEqual('fatal', lLogItem.LogTag);\n      Assert.AreEqual('FATAL', lLogItem.LogTypeAsString);\n      Assert.AreEqual(Int64(0), Int64(TInterlocked.Read(InvalidItemLogged)));\n\n\n      lLogWriter := nil;\n      Assert.AreEqual(7, Length(lHistory));\n      Assert.AreEqual('setup', lHistory[0]);\n      Assert.AreEqual('writelogDEBUG', lHistory[1]);\n      Assert.AreEqual('writelogINFO', lHistory[2]);\n      Assert.AreEqual('writelogWARNING', lHistory[3]);\n      Assert.AreEqual('writelogERROR', lHistory[4]);\n      Assert.AreEqual('writelogFATAL', lHistory[5]);\n      Assert.AreEqual('teardown', lHistory[6]);\n    finally\n      lEvent.Free;\n    end;\n  finally\n    lLock.Free;\n  end;\nend;\n\n//procedure TLoggerProTest.TestOnAppenderError;\n//var\n//  lLog: ILogWriter;\n//  I: Integer;\n//  lEventsHandlers: TLoggerProEventsHandler;\n//  lAppenders: TArray<String>;\n//  lSavedLoggerProAppenderQueueSize: Cardinal;\n//  lOldestsDiscarded: Int64;\n//  lNewestsSkipped: Int64;\n//  lCount: Int64;\n//  lTempCount: Int64;\n//begin\n//  lCount := 0;\n//  lSavedLoggerProAppenderQueueSize := DefaultLoggerProAppenderQueueSize;\n//  DefaultLoggerProMainQueueSize := 1;\n//  DefaultLoggerProAppenderQueueSize := 1;\n//\n//  lNewestsSkipped := 0;\n//  lOldestsDiscarded := 0;\n//  lEventsHandlers := TLoggerProEventsHandler.Create;\n//  try\n//    lEventsHandlers.OnAppenderError :=\n//        procedure(const AppenderClassName: String;\n//        const FailedLogItem: TLogItem; const Reason: TLogErrorReason;\n//        var Action: TLogErrorAction)\n//      var\n//        lLocalCount: Int64;\n//      begin\n//        lLocalCount := TInterlocked.Add(lCount, 1);\n//        if lLocalCount <= 20 then\n//        begin\n//          Action := TLogErrorAction.SkipNewest;\n//          TInterlocked.Increment(lNewestsSkipped);\n//        end\n//        else\n//        begin\n//          Action := TLogErrorAction.DiscardOlder;\n//          TInterlocked.Increment(lOldestsDiscarded);\n//        end;\n//      end;\n//\n//    lLog := BuildLogWriter([TMyVerySlowAppender.Create(1000)], lEventsHandlers);\n//    for I := 1 to 40 do\n//    begin\n//      lLog.Debug('log message ' + I.ToString, 'tag');\n//    end;\n//\n//    {TODO -oDanieleT -cGeneral : Refactor this test}\n////    while True do\n////    begin\n////      lTempCount := TInterlocked.Read(lNewestsSkipped);\n////      if lTempCount < 20 then\n////        Sleep(10)\n////      else\n////        break;\n////    end;\n//\n//    {TODO -oDanieleT -cGeneral : Refactor this test}\n////    while True do\n////    begin\n////      lTempCount := TInterlocked.Read(lOldestsDiscarded);\n////      if lTempCount < 20 then\n////        Sleep(10)\n////      else\n////        break;\n////    end;\n//\n////    while TInterlocked.Read(lCount) < 40 do\n////      Sleep(100);\n//\n//    lAppenders := lLog.GetAppendersClassNames;\n//    Assert.AreEqual(1, Length(lAppenders));\n//    Assert.AreEqual('TMyVerySlowAppender', lAppenders[0]);\n//    lLog := nil;\n//  finally\n//    DefaultLoggerProAppenderQueueSize := lSavedLoggerProAppenderQueueSize;\n//    lEventsHandlers.Free;\n//  end;\n//\n//end;\n\nprocedure TLoggerProTest.TestTLogItemClone;\nvar\n  lLogItem: TLogItem;\n  lClonedLogItem: TLogItem;\nbegin\n  lLogItem := TLogItem.Create(TLogType.Debug, 'message', 'tag');\n  try\n    lClonedLogItem := lLogItem.Clone;\n    try\n      LogItemAreEquals(lLogItem, lClonedLogItem);\n    finally\n      lClonedLogItem.Free;\n    end;\n  finally\n    lLogItem.Free;\n  end;\nend;\n\nprocedure TLoggerProTest.TestTLogItemTypeAsString(aLogType: Byte;\n  aExpected: String);\nvar\n  lLogItem: TLogItem;\nbegin\n  lLogItem := TLogItem.Create(TLogType(aLogType), 'message', 'tag');\n  try\n    Assert.AreEqual(aExpected, lLogItem.LogTypeAsString);\n  finally\n    lLogItem.Free;\n  end;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TLoggerProTest);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing NUnit.Framework;\nusing LoggerPro;            \nusing LoggerPro.Proxy;     \n\nnamespace LoggerPro.Tests\n{\n    \n    public static class TestHelpers\n    {\n        \n        public static bool LogItemAreEquals(LogItem a, LogItem b)\n        {\n            Assert.AreEqual(a.LogType, b.LogType, \"LogType is different\");\n            Assert.AreEqual(a.LogMessage, b.LogMessage, \"LogMessage is different\");\n            Assert.AreEqual(a.LogTag, b.LogTag, \"LogTag is different\");\n            Assert.AreEqual(a.TimeStamp, b.TimeStamp, \"TimeStamp is different\");\n            Assert.AreEqual(a.ThreadID, b.ThreadID, \"ThreadID is different\");\n            return true;\n        }\n    }\n\n    \n    public class TestAppender : ILogAppender\n    {\n        private readonly Action _onSetup;\n        private readonly Action _onTearDown;\n        private readonly Action<LogItem> _onWriteLog;\n\n        public TestAppender(Action onSetup, Action onTearDown, Action<LogItem> onWriteLog)\n        {\n            _onSetup = onSetup;\n            _onTearDown = onTearDown;\n            _onWriteLog = onWriteLog;\n        }\n\n        public void Setup() => _onSetup?.Invoke();\n\n        public void TearDown() => _onTearDown?.Invoke();\n\n        public void WriteLog(LogItem logItem) => _onWriteLog?.Invoke(logItem);\n\n        \n        public int AppendersCount => 1;\n\n        \n        public string[] GetAppendersClassNames() => new string[] { GetType().Name };\n    }\n\n    \n    [TestFixture]\n    public class LoggerProTest\n    {\n        \n        private LogItem _lastLogItem;\n\n        [SetUp]\n        public void Setup()\n        {\n            // Nothing needed here.\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            // Clean up if needed.\n        }\n\n        [Test]\n        public void TestTLogItemClone()\n        {\n            LogItem logItem = new LogItem(LogType.Debug, \"message\", \"tag\");\n            try\n            {\n                LogItem clonedLogItem = logItem.Clone();\n                try\n                {\n                    Assert.IsTrue(TestHelpers.LogItemAreEquals(logItem, clonedLogItem));\n                }\n                finally\n                {\n                    clonedLogItem.Dispose();\n                }\n            }\n            finally\n            {\n                logItem.Dispose();\n            }\n        }\n\n        [Test]\n        [TestCase(0, \"DEBUG\")]\n        [TestCase(1, \"INFO\")]\n        [TestCase(2, \"WARNING\")]\n        [TestCase(3, \"ERROR\")]\n        [TestCase(4, \"FATAL\")]\n        public void TestTLogItemTypeAsString(byte logType, string expected)\n        {\n            LogItem logItem = new LogItem((LogType)logType, \"message\", \"tag\");\n            try\n            {\n                Assert.AreEqual(expected, logItem.LogTypeAsString);\n            }\n            finally\n            {\n                logItem.Dispose();\n            }\n        }\n\n        [Test]\n        [TestCase(false)]\n        [TestCase(true)]\n        public void TestLogLevel(bool useProxy)\n        {\n            \n            List<string> history = new List<string>();\n            object syncLock = new object();\n            long invalidItemLogged = 0;\n            ManualResetEvent mre = new ManualResetEvent(false);\n\n            \n            TestAppender appender = new TestAppender(\n                onSetup: () => history.Add(\"setup\"),\n                onTearDown: () => history.Add(\"teardown\"),\n                onWriteLog: (logItem) =>\n                {\n                    history.Add(\"writelog\" + logItem.LogTypeAsString);\n                    \n                    if (logItem.LogMessage.Equals(\"ignoredmessage\", StringComparison.Ordinal))\n                    {\n                        Interlocked.Increment(ref invalidItemLogged);\n                    }\n                    \n                    lock (syncLock)\n                    {\n                        _lastLogItem?.Dispose();\n                        _lastLogItem = logItem.Clone();\n                        mre.Set();\n                    }\n                }\n            );\n\n            ILogAppender finalAppender = appender;\n            if (useProxy)\n            {\n                \n                finalAppender = LoggerProFilter.Build(appender, logItem =>\n                {\n                    return !logItem.LogMessage.Equals(\"ignoredmessage\", StringComparison.Ordinal);\n                });\n            }\n            invalidItemLogged = 0;\n            ILogWriter logWriter = LoggerProExtensions.BuildLogWriter(new ILogAppender[] { finalAppender });\n\n            \n            mre.Reset();\n            logWriter.Debug(\"debug message\", \"debug\");\n            if (useProxy)\n                logWriter.Debug(\"ignoredmessage\", \"debug\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"debug message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"debug\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"DEBUG\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Info(\"info message\", \"info\");\n            if (useProxy)\n                logWriter.Info(\"ignoredmessage\", \"info\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"info message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"info\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"INFO\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Warn(\"warning message\", \"warning\");\n            if (useProxy)\n                logWriter.Warn(\"ignoredmessage\", \"warning\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"warning message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"warning\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"WARNING\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Error(\"error message\", \"error\");\n            if (useProxy)\n                logWriter.Error(\"ignoredmessage\", \"error\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"error message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"error\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"ERROR\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            mre.Reset();\n            invalidItemLogged = 0;\n            logWriter.Fatal(\"fatal message\", \"fatal\");\n            if (useProxy)\n                logWriter.Fatal(\"ignoredmessage\", \"fatal\");\n            Assert.IsTrue(mre.WaitOne(5000), \"Event not released after 5 seconds\");\n            lock (syncLock)\n            {\n                Assert.AreEqual(\"fatal message\", _lastLogItem.LogMessage);\n                Assert.AreEqual(\"fatal\", _lastLogItem.LogTag);\n                Assert.AreEqual(\"FATAL\", _lastLogItem.LogTypeAsString);\n                Assert.AreEqual(0, invalidItemLogged);\n            }\n\n            \n            logWriter = null;\n            \n            Assert.AreEqual(7, history.Count);\n            Assert.AreEqual(\"setup\", history[0]);\n            Assert.AreEqual(\"writelogDEBUG\", history[1]);\n            Assert.AreEqual(\"writelogINFO\", history[2]);\n            Assert.AreEqual(\"writelogWARNING\", history[3]);\n            Assert.AreEqual(\"writelogERROR\", history[4]);\n            Assert.AreEqual(\"writelogFATAL\", history[5]);\n            Assert.AreEqual(\"teardown\", history[6]);\n        }\n\n        [Test]\n        public void TestAddAndDeleteAppenders()\n        {\n            \n            ILogAppender appender1 = new OutputDebugStringAppender();\n            ILogAppender appender2 = new OutputDebugStringAppender();\n\n            ILogWriter logWriter = LoggerProExtensions.BuildLogWriter(new ILogAppender[] { appender1, appender2 });\n            logWriter.Debug(\"Added Appenders\", \"Appender\");\n            Assert.AreEqual(2, logWriter.AppendersCount);\n\n            logWriter.DelAppender(appender1);\n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n            Assert.AreEqual(1, logWriter.AppendersCount);\n\n            logWriter.DelAppender(appender2);\n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n            Assert.AreEqual(0, logWriter.AppendersCount);\n\n            \n            logWriter.Debug(\"Deleted Appenders\", \"Appender\");\n        }\n\n        [Test]\n        [TestCase(\"{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\",\n                  \"{timestamp}|{threadid}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|    1234|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\")]\n        [TestCase(\"{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\",\n                  \"{timestamp}|{loglevel}|{message}|{tag},2020-03-15 12:30:20:123|LOGLEVEL|THIS IS THE MESSAGE|THE_TAG\")]\n        [TestCase(\"{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE\",\n                  \"{timestamp} -- {message},2020-03-15 12:30:20:123 -- THIS IS THE MESSAGE\")]\n        [TestCase(\"{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]\",\n                  \"{timestamp}[TID {threadid}][{loglevel}]{message}[{tag}],2020-03-15 12:30:20:123[TID     1234][LOGLEVEL]THIS IS THE MESSAGE[THE_TAG]\")]\n        public void TestLogLayoutToLogIndices(string logLayout, string expectedOutput)\n        {\n            \n            string layoutWithIndices = LoggerProExtensions.LogLayoutByPlaceHoldersToLogLayoutByIndexes(logLayout);\n\n            \n            DateTime dt = new DateTime(2020, 3, 15, 12, 30, 20, 123);\n            \n            string formatted = string.Format(layoutWithIndices,\n                dt.ToString(\"yyyy-MM-dd HH:mm:ss:fff\"),\n                \"    1234\",       \n                \"LOGLEVEL\",\n                \"THIS IS THE MESSAGE\",\n                \"THE_TAG\");\n\n            Assert.AreEqual(expectedOutput, formatted);\n        }\n    }\n}"}
{"input": "unit MainSenderFormU;\n\ninterface\n\nuses\n  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,\n  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, System.Net.URLClient,\n  System.Net.HttpClient, System.Net.HttpClientComponent;\n\ntype\n  TForm10 = class(TForm)\n    edtMessage: TEdit;\n    Label1: TLabel;\n    btnSend: TButton;\n    HTTPSend: TNetHTTPClient;\n    procedure btnSendClick(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nvar\n  Form10: TForm10;\n\nimplementation\n\nuses\n  JsonDataObjects;\n\n{$R *.dfm}\n\nprocedure TForm10.btnSendClick(Sender: TObject);\nvar\n  lStream: TStringStream;\n  lJSON: TJsonObject;\n  lRes: IHTTPResponse;\nbegin\n  lStream := TStringStream.Create;\n  try\n    lJSON := TJsonObject.Create;\n    try\n      lJSON.S['value'] := edtMessage.Text;\n      lStream.WriteString(lJSON.ToJSON());\n    finally\n      lJSON.Free;\n    end;\n    lStream.Position := 0;\n    lRes := HTTPSend.Post('http://localhost:8080/api/notifications', lStream, nil, [TNetHEader.Create('content-type', 'application/json')]);\n    if lRes.StatusCode <> 201 then\n    begin\n      ShowMessage(Format('%d: %s (%s)', [lRes.StatusCode, lres.StatusText, lres.ContentAsString]));\n    end;\n  finally\n    lStream.Free;\n  end;\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Windows.Forms;\n\nnamespace MainSenderFormApp\n{\n    public class MainSenderForm : Form\n    {\n        private TextBox edtMessage;\n        private Label lblMessage;\n        private Button btnSend;\n        private HttpClient httpClient;\n\n        public MainSenderForm()\n        {\n            \n            httpClient = new HttpClient();\n\n            \n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            \n            this.edtMessage = new TextBox();\n            this.lblMessage = new Label();\n            this.btnSend = new Button();\n\n            \n            this.lblMessage.Text = \"Enter Message:\";\n            this.lblMessage.Location = new Point(20, 33);\n            this.lblMessage.AutoSize = true;\n\n            \n            this.edtMessage.Location = new Point(100, 30);\n            this.edtMessage.Size = new Size(250, 20);\n\n            \n            this.btnSend.Text = \"Send Message\";\n            this.btnSend.Location = new Point(100, 70);\n            this.btnSend.Click += new EventHandler(btnSend_Click);\n\n            \n            this.ClientSize = new Size(400, 120);\n            this.Controls.Add(this.lblMessage);\n            this.Controls.Add(this.edtMessage);\n            this.Controls.Add(this.btnSend);\n            this.Text = \"Main Sender Form\";\n        }\n\n        private async void btnSend_Click(object sender, EventArgs e)\n        {\n            var jsonObject = new { value = edtMessage.Text };\n            string jsonString = JsonSerializer.Serialize(jsonObject);\n\n            using (var content = new StringContent(jsonString, Encoding.UTF8, \"application/json\"))\n            {\n                try\n                {\n                    HttpResponseMessage response = await httpClient.PostAsync(\"http://localhost:8080/api/notifications\", content);\n                    \n                    if (response.StatusCode != HttpStatusCode.Created)\n                    {\n                        string responseContent = await response.Content.ReadAsStringAsync();\n                        MessageBox.Show(\n                            $\"{(int)response.StatusCode}: {response.ReasonPhrase} ({responseContent})\",\n                            \"Error\",\n                            MessageBoxButtons.OK,\n                            MessageBoxIcon.Error);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message, \"Exception\", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                }\n            }\n        }\n\n        protected override void OnFormClosed(FormClosedEventArgs e)\n        {\n            httpClient.Dispose();\n            base.OnFormClosed(e);\n        }\n    }\n\n    static class Program\n    {\n        \n        [STAThread]\n        static void Main()\n        {\n            \n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new MainSenderForm());\n        }\n    }\n}"}
{"input": "unit Views.Main;\n\n{$MODE DELPHI}{$H+}\n\ninterface\n\nuses Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, Buttons, Horse;\n\ntype\n  TFrmMain = class(TForm)\n    btnStart: TBitBtn;\n    btnStop: TBitBtn;\n    edtPort: TEdit;\n    Label1: TLabel;\n    procedure btnStartClick(Sender: TObject);\n    procedure btnStopClick(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n  private\n    procedure Status;\n    procedure Start;\n    procedure Stop;\n  end;\n\nvar\n  FrmMain: TFrmMain;\n\nimplementation\n\nprocedure DoPing(Req: THorseRequest; Res: THorseResponse);\nbegin\n  Res.Send('pong');\nend;\n\n{$R *.lfm}\n\nprocedure TFrmMain.btnStartClick(Sender: TObject);\nbegin\n  Start;\n  Status;\nend;\n\nprocedure TFrmMain.btnStopClick(Sender: TObject);\nbegin\n  Stop;\n  Status;\nend;\n\nprocedure TFrmMain.FormCreate(Sender: TObject);\nbegin\n  THorse.Get('/ping', DoPing);\nend;\n\nprocedure TFrmMain.Status;\nbegin\n  btnStop.Enabled := THorse.IsRunning;\n  btnStart.Enabled := not THorse.IsRunning;\n  edtPort.Enabled := not THorse.IsRunning;\nend;\n\nprocedure TFrmMain.Start;\nbegin\n  // Need to set \"HORSE_LCL\" compilation directive\n  THorse.Listen(StrToInt(edtPort.Text));\nend;\n\nprocedure TFrmMain.Stop;\nbegin\n  THorse.StopListen;\nend;\n\nend.", "output": "namespace YourNamespace\n{\n    public interface IUsersService\n    {\n        string GetUserNameByID(int id);\n    }\n\n    public interface ICustomersService\n    {\n        string GetCustomerNameByID(int id);\n    }\n\n    public interface ICommonService\n    {\n        string GetID();\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Renderers.WebStencils;\n\n{$I dmvcframework.inc}\n\ninterface\n\n{$if Defined(WEBSTENCILS)}\n\n//This unit is usable from Delphi 12.2+\n\nuses\n  MVCFramework, System.Generics.Collections, System.SysUtils,\n  MVCFramework.Commons, System.IOUtils, System.Classes, Web.Stencils,\n  System.Rtti, MVCFramework.Nullables, System.DateUtils, System.TypInfo;\n\ntype\n  TMVCWebStencilsEvent = reference to procedure(const WebStencilsProcessor: TWebStencilsProcessor);\n\n  { This class implements the WebStencils view engine for server side views }\n  TMVCWebStencilsViewEngine = class(TMVCBaseViewEngine)\n  protected\n    procedure RegisterWSFunctions(WSProcessor: TWebStencilsProcessor);\n    procedure OnGetValue(Sender: TObject; const AObjectName, APropName: string; var AReplaceText: string; var AHandled: Boolean);\n    procedure OnGetFile(Sender: TObject; const AFilename: string; var AText: string; var AHandled: Boolean);\n  public\n    class function GetTValueVarAsString(const Value: TValue; const VarName: string; const Processor: TWebStencilsProcessor): String;\n    procedure Execute(const ViewName: string; const Builder: TStringBuilder); override;\n  end;\n\n  TMVCWebStencilsConfiguration = class sealed\n  private\n    class var fOnProcessorConfiguration: TMVCWebStencilsEvent;\n  public\n    class property OnProcessorConfiguration: TMVCWebStencilsEvent\n      read fOnProcessorConfiguration\n      write fOnProcessorConfiguration;\n  end;\n\n{$endif}\n\nimplementation\n\n\n{$if Defined(WEBSTENCILS)}\nuses\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.DuckTyping,\n  System.Bindings.EvalProtocol,\n  System.Bindings.Methods,\n  MVCFramework.Cache,\n  Data.DB,\n  JsonDataObjects;\n\n{$WARNINGS OFF}\n\nvar\n  gFunctionInitialized: Boolean = False;\n  gWSLock: TObject = nil;\n\nfunction GetDataSetOrObjectListCount(const aValue: TValue; const aParameters: TArray<string>): TValue;\nvar\n  lWrappedList: IMVCList;\nbegin\n  if aValue.IsEmpty or  (not aValue.IsObject) then\n  begin\n    Result := False;\n  end;\n\n  if Length(aParameters) <> 0 then\n  begin\n    Result := '(Error: Expected 0 params, got ' + Length(aParameters).ToString + ')';\n  end;\n\n  if aValue.AsObject is TDataSet then\n  begin\n    Result := TDataSet(aValue.AsObject).RecordCount;\n  end\n  else if aValue.AsObject is TJsonArray then\n  begin\n    Result := TJsonArray(aValue.AsObject).Count;\n  end\n  else if aValue.AsObject is TJsonObject then\n  begin\n    Result := TJsonObject(aValue.AsObject).Count;\n  end\n  else\n  begin\n    if (aValue.AsObject <> nil) and TDuckTypedList.CanBeWrappedAsList(aValue.AsObject, lWrappedList) then\n    begin\n      Result := lWrappedList.Count;\n    end\n    else\n    begin\n      Result := False;\n    end;\n  end;\nend;\n\nfunction DumpAsJSONString(const aValue: TValue; const aParameters: TArray<string>): TValue;\nvar\n  lWrappedList: IMVCList;\nbegin\n  if not aValue.IsObject then\n  begin\n    Result := '(Error: Cannot serialize non-object as JSON)';\n  end;\n\n  if TDuckTypedList.CanBeWrappedAsList(aValue.AsObject, lWrappedList) then\n  begin\n    Result := GetDefaultSerializer.SerializeCollection(lWrappedList)\n  end\n  else\n  begin\n    if aValue.AsObject is TDataSet then\n      Result := GetDefaultSerializer.SerializeDataSet(TDataSet(aValue.AsObject))\n    else\n      Result := GetDefaultSerializer.SerializeObject(aValue.AsObject);\n  end;\nend;\n\n\nfunction MakeMethodJSON: IInvokable;\nbegin\n  Result :=\n    MakeInvokable(function(Args: TArray<IValue>): IValue\n    begin\n      Result := TValueWrapper.Create(DumpAsJSONString(Args[0].GetValue.AsObject, []));\n    end);\nend;\n\nprocedure TMVCWebStencilsViewEngine.OnGetFile(Sender: TObject; const AFilename: string; var AText: string; var AHandled: Boolean);\nvar\n  lFName: String;\nbegin\n  AHandled := False;\n  if TPath.IsRelativePath(AFilename) then\n  begin\n    lFName := TPath.Combine(FViewPath, AFilename);\n    lFName := TPath.ChangeExtension(lfname, FDefaultViewFileExtension);\n    lFName := TPath.Combine(AppPath, lfname);\n    AText := TFile.ReadAllText(lfname);\n    AHandled := True;\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.OnGetValue(Sender: TObject; const AObjectName, APropName: string; var AReplaceText: string; var AHandled: Boolean);\nvar\n  lValue: TValue;\nbegin\n  AHandled := False;\n  if (ViewModel <> nil) and ViewModel.TryGetValue(AObjectName, lValue) then\n  begin\n    AReplaceText := GetTValueVarAsString(lValue, AObjectName, TWebStencilsProcessor(Sender));\n    AHandled := True;\n  end\n  else\n  begin\n    AReplaceText := '';\n    AHandled := True;\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.RegisterWSFunctions(WSProcessor: TWebStencilsProcessor);\nbegin\n  if gFunctionInitialized then Exit;\n  TMonitor.Enter(gWSLock);\n  try\n    if gFunctionInitialized then Exit;\n    gFunctionInitialized := True;\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EMVCSSVException.Create(500, 'Expected 1 parameter in \"JSON\" function, got ' + Length(Args).ToString);\n        end;\n        Result := TValueWrapper.Create(DumpAsJSONString(Args[0].GetValue.AsObject, []));\n      end) as IInvokable,\n      'json', 'json', '', True, 'Serialize an object to JSON', nil));\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EWebStencilsException.Create('Expected 1 parameter, got ' + Length(Args).ToString);\n        end;\n        Result := TValueWrapper.Create(TMVCWebStencilsViewEngine.GetTValueVarAsString(Args[0].GetValue, '', nil));\n      end),\n      'ValueOf', 'ValueOf', '', True, 'ValueOf returns the inner value of a nullable as string - the non-nullable types are returned as-is', nil));\n\n    TBindingMethodsFactory.RegisterMethod(\n     TMethodDescription.Create(\n      MakeInvokable(function(Args: TArray<IValue>): IValue\n      begin\n        if Length(Args) <> 1 then\n        begin\n          raise EWebStencilsException.Create('Expected 1 parameter, got ' + Length(Args).ToString);\n        end;\n        if (ViewModel <> nil) and ViewModel.ContainsKey(Args[0].GetValue.AsString) then\n          Result := TValueWrapper.Create(True)\n        else\n          Result := TValueWrapper.Create(False);\n      end),\n      'Defined', 'Defined', '', True, 'Defined returns true if variable is defined', nil));\n\n\n  finally\n    TMonitor.Exit(gWSLock);\n  end;\nend;\n\nprocedure TMVCWebStencilsViewEngine.Execute(const ViewName: string; const Builder: TStringBuilder);\nvar\n  lViewFileName: string;\n  lWebStencilsProcessor: TWebStencilsProcessor;\n  lPair: TPair<String, TValue>;\nbegin\n  lViewFileName := GetRealFileName(ViewName);\n  if lViewFileName.IsEmpty then\n    raise EMVCSSVException.CreateFmt('View [%s] not found', [ViewName]);\n\n  lWebStencilsProcessor := TWebStencilsProcessor.Create(nil);\n  try\n    RegisterWSFunctions(lWebStencilsProcessor);\n    try\n      if Assigned(TMVCWebStencilsConfiguration.fOnProcessorConfiguration) then\n      begin\n        TMVCWebStencilsConfiguration.OnProcessorConfiguration(lWebStencilsProcessor);\n      end;\n      lWebStencilsProcessor.OnValue := OnGetValue;\n      lWebStencilsProcessor.InputFileName := lViewFileName;\n      lWebStencilsProcessor.PathTemplate := Config[TMVCConfigKey.ViewPath];\n      lWebStencilsProcessor.WebRequest := WebContext.Request.RawWebRequest;\n      lWebStencilsProcessor.OnFile := OnGetFile;\n\n      if Assigned(ViewModel) then\n      begin\n        for lPair in ViewModel do\n        begin\n          if ViewModel[lPair.Key].IsObject then\n            lWebStencilsProcessor.AddVar(lPair.Key, ViewModel[lPair.Key].AsObject, False);\n        end;\n      end;\n      if Assigned(WebContext.LoggedUser) then\n      begin\n        lWebStencilsProcessor.UserLoggedIn := True;\n        lWebStencilsProcessor.UserRoles := WebContext.LoggedUser.Roles.ToString;\n      end;\n      if Assigned(FBeforeRenderCallback) then\n      begin\n        FBeforeRenderCallback(lWebStencilsProcessor);\n      end;\n      Builder.Append(lWebStencilsProcessor.Content);\n    except\n      on E: EWebStencilsException do\n      begin\n        raise EMVCViewError.CreateFmt('View [%s] error: %s (%s)',\n          [ViewName, E.Message, E.ClassName]);\n      end;\n    end;\n  finally\n    lWebStencilsProcessor.Free;\n  end;\nend;\n\nclass function TMVCWebStencilsViewEngine.GetTValueVarAsString(const Value: TValue; const VarName: string; const Processor: TWebStencilsProcessor): String;\nvar\n  lIsObject: Boolean;\n  lAsObject: TObject;\n  lNullableInt32: NullableInt32;\n  lNullableUInt32: NullableUInt32;\n  lNullableInt16: NullableInt16;\n  lNullableUInt16: NullableUInt16;\n  lNullableInt64: NullableInt64;\n  lNullableUInt64: NullableUInt64;\n  lNullableCurrency: NullableCurrency;\n  lNullableBoolean: NullableBoolean;\n  lNullableTDate: NullableTDate;\n  lNullableTTime: NullableTTime;\n  lNullableTDateTime: NullableTDateTime;\nbegin\n  if Value.IsEmpty then\n  begin\n    Exit('');\n  end;\n\n  lIsObject := False;\n  lAsObject := nil;\n  if Value.IsObject then\n  begin\n    lIsObject := True;\n    lAsObject := Value.AsObject;\n  end;\n\n  if lIsObject then\n  begin\n    if lAsObject is TField then\n      Result := TField(Value.AsObject).AsString\n    else if lAsObject is TJsonBaseObject then\n      Result := TJsonBaseObject(lAsObject).ToJSON()\n    else\n      Result := lAsObject.ToString;\n  end\n  else\n  begin\n    if Value.TypeInfo.Kind = tkRecord then\n    begin\n      Result := '';\n      if Value.TypeInfo = TypeInfo(NullableInt32) then\n      begin\n        lNullableInt32 := Value.AsType<NullableInt32>;\n        if lNullableInt32.HasValue then\n          Result := lNullableInt32.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt32) then\n      begin\n        lNullableUInt32 := Value.AsType<NullableUInt32>;\n        if lNullableUInt32.HasValue then\n          Result := lNullableUInt32.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableInt16) then\n      begin\n        lNullableInt16 := Value.AsType<NullableInt16>;\n        if lNullableInt16.HasValue then\n          Result := lNullableInt16.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt16) then\n      begin\n        lNullableUInt16 := Value.AsType<NullableUInt16>;\n        if lNullableUInt16.HasValue then\n          Result := lNullableUInt16.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableInt64) then\n      begin\n        lNullableInt64 := Value.AsType<NullableInt64>;\n        if lNullableInt64.HasValue then\n          Result := lNullableInt64.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableUInt64) then\n      begin\n        lNullableUInt64 := Value.AsType<NullableUInt64>;\n        if lNullableUInt64.HasValue then\n          Result := lNullableUInt64.Value.ToString\n      end\n      else if Value.TypeInfo = TypeInfo(NullableString) then\n      begin\n        Result := Value.AsType<NullableString>.ValueOrDefault;\n      end\n      else if Value.TypeInfo = TypeInfo(NullableCurrency) then\n      begin\n        lNullableCurrency := Value.AsType<NullableCurrency>;\n        if lNullableCurrency.HasValue then\n          Result := FloatToStr(lNullableCurrency.Value);\n          //Result := FloatToStr(lNullableCurrency.Value, fLocaleFormatSettings);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableBoolean) then\n      begin\n        lNullableBoolean := Value.AsType<NullableBoolean>;\n        if lNullableBoolean.HasValue then\n          Result := BoolToStr(lNullableBoolean.Value, True);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTDate) then\n      begin\n        lNullableTDate := Value.AsType<NullableTDate>;\n        if lNullableTDate.HasValue then\n          Result := DateToISO8601(lNullableTDate.Value);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTTime) then\n      begin\n        lNullableTTime := Value.AsType<NullableTTime>;\n        if lNullableTTime.HasValue then\n          Result := DateToISO8601(lNullableTTime.Value);\n      end\n      else if Value.TypeInfo = TypeInfo(NullableTDateTime) then\n      begin\n        lNullableTDateTime := Value.AsType<NullableTDateTime>;\n        if lNullableTDateTime.HasValue then\n          Result := DateToISO8601(lNullableTDateTime.Value);\n      end\n      else\n      begin\n        raise EWebStencilsException.Create('Unsupported type for variable \"' + VarName + '\"');\n      end;\n    end\n    else\n    begin\n      case Value.Kind of\n        tkInteger: Result := Value.AsInteger.ToString;\n        tkInt64: Result := Value.AsInt64.ToString;\n        tkString, tkUString, tkWString, tkLString: Result := Value.AsString;\n        tkWChar, tkChar: Result := Value.AsType<Char>;\n        tkFloat: begin\n          if Value.TypeInfo.Name = 'TDate' then\n          begin\n            //Result := DateToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := DateToStr(Value.AsExtended);\n          end\n          else if Value.TypeInfo.Name = 'TDateTime' then\n          begin\n            //Result := DateTimeToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := DateTimeToStr(Value.AsExtended);\n          end\n          else\n          begin\n            //Result := FloatToStr(Value.AsExtended, fLocaleFormatSettings);\n            Result := FloatToStr(Value.AsExtended);\n          end;\n        end;\n        tkEnumeration: Result := Value.ToString.ToLower;\n        else\n          raise EWebStencilsException.Create('Unsupported type for variable \"' + VarName + '\"');\n      end;\n    end;\n  end;\n\nend;\n\n\ninitialization\n\ngWSLock := TObject.Create;\n\nfinalization\n\nFreeAndNil(gWSLock);\n\n{$endif}\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.Serializer.Defaults;\nusing System.Linq;\n\nnamespace MVCFramework.View.Renderers\n{\n    #region Dummy/Placeholder Types\n\n    public abstract class MVCBaseViewEngine\n    {\n        protected MVCEngine Engine { get; }\n        protected TWebContext WebContext { get; }\n        protected MVCController Controller { get; }\n        protected MVCViewDataObject ViewModel { get; }\n        protected string ContentType { get; }\n        protected IDictionary<string, string> Config { get; } \n        protected Action<TWebStencilsProcessor> BeforeRenderCallback { get; set; }\n\n        protected MVCBaseViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller, MVCViewDataObject viewModel, string contentType)\n        {\n            Engine = engine;\n            WebContext = webContext;\n            Controller = controller;\n            ViewModel = viewModel;\n            ContentType = contentType;\n            Config = engine.Config;\n        }\n\n        public abstract void Execute(string viewName, StringBuilder builder);\n\n        protected virtual string GetRealFileName(string viewName)\n        {\n            string viewPath = Config.ContainsKey(\"ViewPath\") ? Config[\"ViewPath\"] : \"Views\";\n            string extension = Config.ContainsKey(\"DefaultViewFileExtension\") ? Config[\"DefaultViewFileExtension\"] : \"html\";\n            string fullPath = Path.Combine(AppPath, viewPath, $\"{viewName}.{extension}\");\n            return File.Exists(fullPath) ? fullPath : string.Empty;\n        }\n\n        protected string AppPath => AppDomain.CurrentDomain.BaseDirectory;\n    }\n\n    public class MVCEngine\n    {\n        public IDictionary<string, string> Config { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n        {\n            { \"ViewPath\", \"Views\" },\n            { \"DefaultViewFileExtension\", \"html\" },\n            { \"ViewCache\", \"true\" }\n        };\n    }\n\n    public class TWebContext\n    {\n        public TWebRequest Request { get; set; }\n        public TWebResponse Response { get; set; }\n        public MVCLoggedUser LoggedUser { get; set; }\n    }\n\n    public class TWebRequest\n    {\n        public object RawWebRequest { get; set; }\n    }\n\n    public class TWebResponse { }\n\n    public class MVCController { }\n\n    public class MVCViewDataObject : Dictionary<string, TValue> { }\n\n    public interface IMVCSerializer\n    {\n        string SerializeObject(object obj);\n        string SerializeCollection(object collection);\n    }\n\n    public static class MVCSerializerDefaults\n    {\n        public static IMVCSerializer GetDefaultSerializer() => new MVCJsonDataObjectsSerializer();\n    }\n\n    public class MVCJsonDataObjectsSerializer : IMVCSerializer\n    {\n        public string SerializeObject(object obj)\n        {\n            return Newtonsoft.Json.JsonConvert.SerializeObject(obj);\n        }\n        public string SerializeCollection(object collection)\n        {\n            return SerializeObject(collection);\n        }\n    }\n\n    public class TWebStencilsProcessor : IDisposable\n    {\n        public string InputFileName { get; set; }\n        public string PathTemplate { get; set; }\n        public object WebRequest { get; set; }\n        public bool UserLoggedIn { get; set; }\n        public string UserRoles { get; set; }\n        public event Action<object, string, ref string, ref bool> OnValue;\n        public event Action<object, string, ref string, ref bool> OnFile;\n\n        public string Content\n        {\n            get\n            {\n                return File.ReadAllText(InputFileName);\n            }\n        }\n\n        public void AddVar(string key, object value, bool flag)\n        {\n            // Implementation to add variable into the processor's model.\n        }\n\n        public void Dispose()\n        {\n            // Dispose resources if necessary.\n        }\n    }\n\n    public static class WebStencilsGlobalFunctions\n    {\n        public static bool Initialized { get; set; } = false;\n        public static readonly object LockObject = new object();\n\n        public static void RegisterMethod(string name, Func<IValue[], IValue> invokable, string description)\n        {\n            // Implementation for binding method registration.\n        }\n    }\n\n    public interface IValue\n    {\n        TValue GetValue();\n    }\n\n    public struct TValue\n    {\n        private object _value;\n        public TValue(object value) { _value = value; }\n        public bool IsEmpty => _value == null;\n        public bool IsObject => _value != null;\n        public object AsObject => _value;\n        public int AsInteger => Convert.ToInt32(_value);\n        public long AsInt64 => Convert.ToInt64(_value);\n        public double AsDouble => Convert.ToDouble(_value);\n        public string AsString => Convert.ToString(_value);\n        public bool AsBoolean => Convert.ToBoolean(_value);\n        public static implicit operator TValue(int value) => new TValue(value);\n        public static implicit operator TValue(string value) => new TValue(value);\n    }\n\n    public class TValueWrapper : IValue\n    {\n        private TValue _value;\n        public TValueWrapper(object value) { _value = new TValue(value); }\n        public TValue GetValue() => _value;\n    }\n\n    #endregion\n\n    #region MVCWebStencilsViewEngine\n\n    public class MVCWebStencilsViewEngine : MVCBaseViewEngine\n    {\n        private bool modelPrepared = false;\n        private string jsonModelAsString = \"\";\n        private static TSynMustachePartials partials;\n        private static TSynMustacheHelpers helpers;\n        private static readonly object globalLock = new object();\n        private static bool gPartialsLoaded = false;\n        private static bool gHelpersLoaded = false;\n\n        public MVCWebStencilsViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller,\n            MVCViewDataObject viewModel, string contentType)\n            : base(engine, webContext, controller, viewModel, contentType)\n        {\n            LoadPartials();\n            LoadHelpers();\n        }\n\n        \n        public void OnGetValue(object sender, string objectName, string propName, ref string replaceText, ref bool handled)\n        {\n            if (ViewModel != null && ViewModel.TryGetValue(objectName, out TValue value))\n            {\n                replaceText = GetTValueVarAsString(value, objectName, sender as TWebStencilsProcessor);\n                handled = true;\n            }\n            else\n            {\n                replaceText = \"\";\n                handled = true;\n            }\n        }\n\n        \n        public void OnGetFile(object sender, string filename, ref string text, ref bool handled)\n        {\n            if (!Path.IsPathRooted(filename))\n            {\n                string fullFileName = Path.Combine(Config[\"ViewPath\"], filename);\n                fullFileName = Path.ChangeExtension(fullFileName, Config[\"DefaultViewFileExtension\"]);\n                fullFileName = Path.Combine(AppPath, fullFileName);\n                text = File.ReadAllText(fullFileName);\n                handled = true;\n            }\n        }\n\n        \n        public static string GetTValueVarAsString(TValue value, string varName, TWebStencilsProcessor processor)\n        {\n            if (value.IsEmpty)\n                return \"\";\n            if (value.IsObject)\n            {\n                object obj = value.AsObject;\n                if (obj is System.Data.DataRowView) \n                    return obj.ToString();\n                else if (obj is JsonObject)\n                    return ((JsonObject)obj).ToJSON();\n                else\n                    return obj.ToString();\n            }\n            else\n            {\n                \n                if (value.AsObject is int)\n                    return value.AsInteger.ToString();\n                if (value.AsObject is long)\n                    return value.AsInt64.ToString();\n                if (value.AsObject is double)\n                    return value.AsDouble.ToString();\n                if (value.AsObject is bool)\n                    return value.AsBoolean.ToString().ToLower();\n                if (value.AsObject is string)\n                    return value.AsString;\n                throw new Exception($\"Unsupported type for variable \\\"{varName}\\\"\");\n            }\n        }\n\n        \n        private void RegisterWSFunctions(TWebStencilsProcessor processor)\n        {\n            if (WebStencilsGlobalFunctions.Initialized)\n                return;\n            lock (globalLock)\n            {\n                if (!WebStencilsGlobalFunctions.Initialized)\n                {\n                    WebStencilsGlobalFunctions.RegisterMethod(\"json\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'json' function\");\n                            object obj = args[0].GetValue().AsObject;\n                            return new TValueWrapper(GetDefaultSerializer().SerializeObject(obj));\n                        },\n                        \"Serialize an object to JSON\");\n\n                    WebStencilsGlobalFunctions.RegisterMethod(\"ValueOf\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'ValueOf' function\");\n                            return new TValueWrapper(GetTValueVarAsString(args[0].GetValue(), \"\", null));\n                        },\n                        \"Returns inner value of a nullable as string\");\n\n                    WebStencilsGlobalFunctions.RegisterMethod(\"Defined\",\n                        (args) =>\n                        {\n                            if (args.Length != 1)\n                                throw new Exception(\"Expected 1 parameter in 'Defined' function\");\n                            bool exists = (ViewModel != null && ViewModel.ContainsKey(args[0].GetValue().AsString));\n                            return new TValueWrapper(exists);\n                        },\n                        \"Returns true if variable is defined\");\n\n                    WebStencilsGlobalFunctions.Initialized = true;\n                }\n            }\n        }\n\n        private void LoadPartials()\n        {\n            if (gPartialsLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gPartialsLoaded)\n                {\n                    string viewsExtension = Config[\"DefaultViewFileExtension\"];\n                    string viewPath = Config[\"ViewPath\"];\n                    string[] files = Directory.GetFiles(viewPath, \"*.\" + viewsExtension, SearchOption.AllDirectories);\n                    partials?.Dispose();\n                    partials = new TSynMustachePartials();\n                    foreach (string file in files)\n                    {\n                        string partialName = file.Substring(0, file.Length - (viewsExtension.Length + 1))\n                            .Replace(Path.DirectorySeparatorChar, '/');\n                        partialName = partialName.Substring(viewPath.Length + 1);\n                        string content = File.ReadAllText(file);\n                        partials.Add(partialName, content);\n                    }\n                    gPartialsLoaded = string.Equals(Config[\"ViewCache\"], \"true\", StringComparison.OrdinalIgnoreCase);\n                }\n            }\n        }\n\n        private void LoadHelpers()\n        {\n            if (gHelpersLoaded)\n                return;\n            lock (globalLock)\n            {\n                if (!gHelpersLoaded)\n                {\n                    helpers = TSynMustache.HelpersGetStandardList();\n                    MVCWebStencilsHelpers.RegisterHandlers(ref helpers);\n                    gHelpersLoaded = true;\n                }\n            }\n        }\n\n        private void PrepareModels()\n        {\n            if (modelPrepared)\n                return;\n\n            IMVCSerializer serializer = serializerPool.GetFromPool(true) as IMVCSerializer;\n            try\n            {\n                var jsonModel = new JsonObject();\n                if (ViewModel != null)\n                {\n                    foreach (var pair in ViewModel)\n                    {\n                        ((MVCJsonDataObjectsSerializer)serializer).TValueToJSONObjectProperty(jsonModel, pair.Key, pair.Value,\n                            TMVCSerializationType.stDefault, null, null);\n                    }\n                }\n                jsonModelAsString = jsonModel.ToJSON();\n            }\n            finally\n            {\n                serializerPool.ReleaseToPool(serializer);\n            }\n            modelPrepared = true;\n        }\n    }\n\n    #endregion\n\n    #region MVCWebStencilsHelpers\n\n    public static class MVCWebStencilsHelpers\n    {\n        public delegate void LoadCustomHelpersProc(ref TSynMustacheHelpers mustacheHelpers);\n        private static LoadCustomHelpersProc onLoadCustomHelpers;\n        public static LoadCustomHelpersProc OnLoadCustomHelpers\n        {\n            get => onLoadCustomHelpers;\n            set => onLoadCustomHelpers = value;\n        }\n\n        public static void RegisterHandlers(ref TSynMustacheHelpers mustacheHelpers)\n        {\n            TSynMustache.HelperAdd(mustacheHelpers, \"UpperCase\", new TSynMustacheHelperDelegate(ToUpperCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"LowerCase\", new TSynMustacheHelperDelegate(ToLowerCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"Capitalize\", new TSynMustacheHelperDelegate(Capitalize));\n            TSynMustache.HelperAdd(mustacheHelpers, \"SnakeCase\", new TSynMustacheHelperDelegate(SnakeCase));\n            onLoadCustomHelpers?.Invoke(ref mustacheHelpers);\n        }\n\n        public static void ToLowerCase(object value, out object result)\n        {\n            result = value?.ToString().ToLower();\n        }\n\n        public static void ToUpperCase(object value, out object result)\n        {\n            result = value?.ToString().ToUpper();\n        }\n\n        public static void Capitalize(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (!string.IsNullOrEmpty(s))\n                result = char.ToUpper(s[0]) + s.Substring(1).ToLower();\n            else\n                result = s;\n        }\n\n        public static void SnakeCase(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (string.IsNullOrEmpty(s))\n            {\n                result = s;\n                return;\n            }\n            var sb = new StringBuilder();\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (char.IsUpper(s[i]))\n                {\n                    if (i > 0)\n                        sb.Append('_');\n                    sb.Append(char.ToLower(s[i]));\n                }\n                else\n                {\n                    sb.Append(s[i]);\n                }\n            }\n            result = sb.ToString();\n        }\n    }\n\n    #endregion\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\u00fcller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomTypesU;\n\ninterface\n\nuses\n  System.Generics.Defaults, System.Generics.Collections;\n\ntype\n  // custom serialization is by-type so we define a type alias\n  // useful to identify all the fields that must be serialized\n  // using the custom serializer defined for this type\n  TUserRoles = TArray<string>;\n\n  TNullableRecord<T> = record\n    Value: T;\n    HasValue: Boolean;\n  end;\n\n  TNullableRecordAlias = TNullableRecord<string>;\n\n  // This is the main object which uses the\n  // custom serialized type as property Roles\n  TSysUser = class\n  private\n    fUserName: string;\n    fRoles: TUserRoles;\n    fRecordAlias: TNullableRecordAlias;\n    procedure SetUserName(const Value: string);\n    function GetUserRoles: TUserRoles;\n  public\n    constructor Create(aUserName: string; aRoles: TUserRoles);\n    property UserName: string read FUserName write SetUserName;\n    // Here we are using the custom-serialized type TUserRoles\n    property Roles: TUserRoles read GetUserRoles;\n    property RecordAlias: TNullableRecordAlias read fRecordAlias write fRecordAlias;\n  end;\n\n  TSysUser2 = class\n  private\n    FUserName: string;\n    fRoles: TUserRoles;\n    fRecordAlias: TNullableRecordAlias;\n  public\n    constructor Create(aUserName: string; aRoles: TUserRoles);\n    property UserName: string read FUserName write FUserName;\n    // Here we are using the custom-serialized type TUserRoles\n    property Roles: TUserRoles read fRoles write fRoles;\n  end;\n\n\n  TArrayTest = class\n  private\n    fStrings: TArray<string>;\n    fIntegers: TArray<Integer>;\n    fDoubles: TArray<Double>;\n    fEmptyIntegers: TArray<Integer>;\n    fNilArrayOfIntegers: TArray<Integer>;\n  public\n    constructor Create;\n    property Integers: TArray<Integer> read fIntegers write fIntegers;\n    property Strings: TArray<string> read fStrings write fStrings;\n    property Doubles: TArray<Double> read fDoubles write fDoubles;\n    property EmptyIntegers: TArray<Integer> read fEmptyIntegers write fEmptyIntegers;\n    property NilArrayOfIntegers: TArray<Integer> read fNilArrayOfIntegers write fNilArrayOfIntegers;\n  end;\n\n  TSimpleListTest = class\n  private\n    fDoubles: TList<Double>;\n    fStrings: TList<string>;\n    fIntegers: TList<Integer>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    property Integers: TList<Integer> read fIntegers;\n    property Strings: TList<string> read fStrings;\n    property Doubles: TList<Double> read fDoubles;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, System.Math;\n\n{ TSysUser }\n\nconstructor TSysUser.Create(aUserName: string; aRoles: TUserRoles);\nbegin\n  inherited Create;\n  FUserName := aUserName;\n  FRoles := aRoles;\nend;\n\nfunction TSysUser.GetUserRoles: TUserRoles;\nbegin\n  Result := FRoles;\nend;\n\nprocedure TSysUser.SetUserName(const Value: string);\nbegin\n  FUserName := Value;\nend;\n\n{ TArrayTest }\n\nconstructor TArrayTest.Create;\nvar\n  I: Integer;\nbegin\n  inherited;\n  fNilArrayOfIntegers := nil;\n  SetLength(fEmptyIntegers, 0);\n  SetLength(fStrings, 5);\n  for I := 0 to Length(fStrings) - 1 do\n  begin\n    fStrings[I] := 'Value ' + I.ToString;\n  end;\n  SetLength(fIntegers, 5);\n  for I := 0 to Length(fIntegers) - 1 do\n  begin\n    fIntegers[I] := I;\n  end;\n  SetLength(fDoubles, 5);\n  for I := 0 to Length(fDoubles) - 1 do\n  begin\n    fDoubles[I] := Power(I, I) * 1.1;\n  end;\nend;\n\n{ TSimpleListTest }\n\nconstructor TSimpleListTest.Create;\nbegin\n  inherited;\n  fIntegers := TList<Integer>.Create();\n  fIntegers.AddRange([1, 2, 3, 4, 5]);\n  fStrings := TList<string>.Create();\n  fStrings.AddRange(['good', 'bye', 'cruel', 'world']);\n  fDoubles := TList<Double>.Create();\n  fDoubles.AddRange([1.2, 2.3, 3.4, 4.5, 5.6]);\nend;\n\ndestructor TSimpleListTest.Destroy;\nbegin\n  fIntegers.Free;\n  fStrings.Free;\n  fDoubles.Free;\n  inherited;\nend;\n\n{ TSysUser2 }\n\nconstructor TSysUser2.Create(aUserName: string; aRoles: TUserRoles);\nbegin\n  inherited Create;\n  FUserName := aUserName;\n  fRoles := aRoles;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\n\nnamespace CustomTypesU\n{\n    public class MVCSerializationException : Exception\n    {\n        public MVCSerializationException(string message) : base(message) { }\n    }\n\n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes);\n        void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes);\n    }\n\n    public class TUserRolesSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            JArray jArray = jObj[propertyName] as JArray;\n            if (jArray == null)\n            {\n                jArray = new JArray();\n                jObj[propertyName] = jArray;\n            }\n\n            jArray.Add(\"--begin--\");\n\n            if (elementValue is IEnumerable<string> roles)\n            {\n                foreach (var role in roles)\n                    jArray.Add(role);\n            }\n            else if (elementValue is string[] rolesArray)\n            {\n                foreach (var role in rolesArray)\n                    jArray.Add(role);\n            }\n\n            jArray.Add(\"--end--\");\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"To implement\");\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TSysUserSerializer : IMVCTypeSerializer\n    {\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            if (!(serializerObject is JObject jObj))\n                throw new Exception(\"serializerObject is not a JObject.\");\n\n            jObj[\"prop\"] = \"hello there attribute\";\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            JObject jObj = new JObject();\n            serializerObject = jObj;\n\n            if (!(obj is TSysUser user))\n                throw new Exception(\"obj is not of type TSysUser.\");\n\n            jObj[\"username\"] = user.UserName;\n            jObj[\"roles\"] = string.Join(\",\", user.Roles);\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // No implementation provided.\n        }\n    }\n\n    public class TNullableAliasSerializer : IMVCTypeSerializer\n    {\n        public void Serialize(object elementValue, ref object serializerObject, Attribute[] attributes)\n        {\n            throw new Exception(\"TODO\");\n        }\n\n        public void Deserialize(object serializedObject, ref object elementValue, Attribute[] attributes)\n        {\n            // No implementation.\n        }\n\n        public void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void SerializeRoot(object obj, out object serializerObject, Attribute[] attributes, object serializationAction = null)\n        {\n            throw new MVCSerializationException($\"{GetType().Name} cannot be used as root object\");\n        }\n\n        public void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n\n        public void DeserializeRoot(object serializerObject, object obj, Attribute[] attributes)\n        {\n            // Empty implementation.\n        }\n    }\n\n    public class TSysUser\n    {\n        public string UserName { get; set; }\n        public List<string> Roles { get; set; }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators with this file: Ezequiel Juliano M\ufffdller (ezequieljuliano@gmail.com)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit Person;\n\ninterface\n\ntype\n\n  TPerson = class\n  private\n    FId: Int64;\n    FName: string;\n    FAddress: string;\n    FBirthday: TDate;\n  public\n    property Id: Int64 read FId write FId;\n    property Name: string read FName write FName;\n    property Address: string read FAddress write FAddress;\n    property Birthday: TDate read FBirthday write FBirthday;\n  end;\n\nimplementation\n\nend.", "output": "namespace MyApp { public class Person { public long Id { get; set; } \n    public string Name { get; set; } \n    public string Address { get; set; } \n    public System.DateTime Birthday { get; set; } \n    \n    } \n}"}
{"input": "unit StatusesServiceU;\n\ninterface\n\nuses BaseServiceU, MainDMU, EntitiesU;\n\ntype\n  TStatusService = class(TBaseService)\n  private\n    fModule: TdmMain;\n\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure PersistStatus(aStatus: TNotificationEntity);\n    function GetCurrentStatus: TCurrentStatusEntity;\n    function GetLastPersistedStatus: TFullStatusEntity;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Commons, MVCFramework.Serializer.Commons,\n  Data.DB;\n\n{ TStatusService }\n\nconstructor TStatusService.Create;\nbegin\n  inherited;\n  fModule := TdmMain.Create(nil);\nend;\n\ndestructor TStatusService.Destroy;\nbegin\n  fModule.Free;\n  inherited;\nend;\n\nfunction TStatusService.GetCurrentStatus: TCurrentStatusEntity;\nvar\n  lInitializer: TFunc<TFullStatusEntity>;\nbegin\n  lInitializer := function: TFullStatusEntity\n    begin\n      Result := Self.GetLastPersistedStatus;\n      // Result := fModule.Connection.ExecSQLScalar\n      // ('SELECT\tTOP 1 CS.idStato FROM CambiStato CS ORDER BY CS.idRecord DESC');\n    end;\n  Result := TCurrentStatusEntity.GetInstance(lInitializer);\nend;\n\nfunction TStatusService.GetLastPersistedStatus: TFullStatusEntity;\nvar\n  lDataSet: TDataSet;\nbegin\n  fModule.Connection.ExecSQL('select id, value, created_at from notifications order by id desc limit 1', lDataSet);\n  try\n    Result := TFullStatusEntity.Create;\n    if lDataSet.Eof then\n    begin\n      Result.Id := -1;\n      Result.Value := '';\n      Result.PushedAt := '';\n    end\n    else\n    begin\n      Result := TFullStatusEntity.Create;\n      Result.Id := lDataSet.FieldByName('id').AsInteger;\n      Result.Value := lDataSet.FieldByName('value').AsString;\n      Result.PushedAt := lDataSet.FieldByName('created_at').AsString;\n    end;\n  finally\n    lDataSet.Free;\n  end;\nend;\n\nprocedure TStatusService.PersistStatus(aStatus: TNotificationEntity);\nbegin\n  fModule.qryInsertNotification.ExecSQL('', [aStatus.Value]);\n  TCurrentStatusEntity.GetInstance.SetStatus(GetLastPersistedStatus);\nend;\n\nend.", "output": "using System;\nusing System.Data;\nusing MVCFramework.Commons;\nusing MainDMU;\nusing EntitiesU;\n\nnamespace YourNamespace\n{\n    public class StatusService : BaseService, IDisposable\n    {\n        private dmMain _module;\n\n        public StatusService() : base()\n        {\n            _module = new dmMain();\n        }\n\n        public void PersistStatus(NotificationEntity aStatus)\n        {\n            _module.qryInsertNotification.ExecSQL(\"\", new object[] { aStatus.Value });\n            CurrentStatusEntity.GetInstance(() => GetLastPersistedStatus()).SetStatus(GetLastPersistedStatus());\n        }\n\n        public CurrentStatusEntity GetCurrentStatus()\n        {\n            return CurrentStatusEntity.GetInstance(() => GetLastPersistedStatus());\n        }\n\n        public FullStatusEntity GetLastPersistedStatus()\n        {\n            DataSet ds;\n            _module.Connection.ExecSQL(\"select id, value, created_at from notifications order by id desc limit 1\", out ds);\n            FullStatusEntity result = new FullStatusEntity();\n            if (ds.Tables.Count == 0 || ds.Tables[0].Rows.Count == 0)\n            {\n                result.Id = -1;\n                result.Value = \"\";\n                result.PushedAt = \"\";\n            }\n            else\n            {\n                DataRow row = ds.Tables[0].Rows[0];\n                result.Id = Convert.ToInt32(row[\"id\"]);\n                result.Value = row[\"value\"].ToString();\n                result.PushedAt = row[\"created_at\"].ToString();\n            }\n            ds.Dispose();\n            return result;\n        }\n\n        public void Dispose()\n        {\n            if (_module != null)\n            {\n                _module.Dispose();\n                _module = null;\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MyObjectU;\n\ninterface\n\nuses\n  JsonDataObjects,\n  System.Generics.Collections,\n  Data.DB,\n  BusinessObjectsU,\n  FireDAC.Comp.Client,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.Commons, MVCFramework,\n  MVCFramework.JSONRPC, CommonTypesU;\n\ntype\n\n  TMyObject = class\n  private\n    function GetCustomersDataset: TFDMemTable;\n    procedure FillCustomersDataset(const DataSet: TDataSet);\n    procedure FillPeopleDataset(const DataSet: TDataSet);\n  public\n    procedure OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJDOJsonObject);\n    procedure OnBeforeCallHook(const Context: TWebContext; const JSONRequest: TJDOJsonObject);\n    procedure OnAfterCallHook(const Context: TWebContext; const JSONResponse: TJDOJsonObject);\n  public\n    [MVCDoc('You know, returns aValue1 - aValue2')]\n    [MVCJSONRPCAllowGET]\n    function Subtract(Value1, Value2: Integer): Integer;\n    [MVCDoc('Returns the revers of the string passed as input')]\n    function ReverseString(const aString: string; const aUpperCase: Boolean): string;\n    [MVCDoc('Returns the next monday starting from aDate')]\n    function GetNextMonday(const aDate: TDate): TDate;\n    function PlayWithDatesAndTimes(const aJustAFloat: Double; const aTime: TTime;\n      const aDate: TDate; const aDateAndTime: TDateTime): TDateTime;\n    [MVCJSONRPCAllowGET]\n    function GetCustomers(FilterString: string): TDataSet;\n    [MVCJSONRPCAllowGET]\n    function GetMulti: TMultiDataset;\n    [MVCJSONRPCAllowGET]\n    function GetStringDictionary: TMVCStringDictionary;\n    function GetUser(aUserName: string): TPerson;\n    function SavePerson(const Person: TPerson): Integer;\n    function FloatsTest(const aDouble: Double; const aExtended: Extended): Extended;\n    procedure DoSomething;\n    procedure RaiseCustomException;\n    function RaiseGenericException(const ExceptionType: Integer): Integer;\n    function SaveObjectWithJSON(const WithJSON: TJsonObject): TJsonObject;\n\n    //enums and sets support\n    function PassingEnums(Value1: TEnumTest; Value2: TEnumTest): TEnumTest;\n    function GetSetBySet(Value: TSetTest): TSetTest;\n\n    //records support\n    function SavePersonRec(PersonRec: TTestRec): TTestRec;\n    function GetPeopleRecDynArray: TTestRecDynArray;\n    function GetPeopleRecStaticArray: TTestRecArray;\n    function GetPersonRec: TTestRec;\n    function GetComplex1: TNestedArraysRec;\n    function EchoComplexArrayOfRecords(PeopleList: TTestRecDynArray): TTestRecDynArray;\n    function EchoComplexArrayOfRecords2(VendorProxiesAndLinks: TNestedArraysRec): TNestedArraysRec;\n\n    // invalid parameters modifiers\n    procedure InvalidMethod1(var MyVarParam: Integer);\n    procedure InvalidMethod2(out MyOutParam: Integer);\n\n  end;\n\n  TUtils = class sealed\n    class function JSONObjectAs<T: constructor, class>(const JSON: TJsonObject): T;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  MVCFramework.Logger,\n  System.StrUtils,\n  System.DateUtils, MVCFramework.Serializer.JsonDataObjects;\n\nclass function TUtils.JSONObjectAs<T>(const JSON: TJsonObject): T;\nvar\n  lObj: TObject;\n  lSerializer: TMVCJsonDataObjectsSerializer;\nbegin\n  lObj := T.Create;\n  try\n    lSerializer := TMVCJsonDataObjectsSerializer.Create;\n    try\n      lSerializer.JsonObjectToObject(JSON, lObj, TMVCSerializationType.stProperties, []);\n    finally\n      lSerializer.Free;\n    end;\n  except\n    lObj.Free;\n    raise;\n  end;\n  Result := T(lObj);\nend;\n\n{ TMyDerivedController }\n\nprocedure TMyObject.DoSomething;\nbegin\n\nend;\n\nfunction TMyObject.PassingEnums(Value1, Value2: TEnumTest): TEnumTest;\nbegin\n  if Value1 = Value2 then\n  begin\n    Result := TEnumTest.ptEnumValue4;\n  end\n  else\n  begin\n    Result := TEnumTest.ptEnumValue3;\n  end;\nend;\n\nfunction TMyObject.EchoComplexArrayOfRecords(\n  PeopleList: TTestRecDynArray): TTestRecDynArray;\nbegin\n  Result := PeopleList;\nend;\n\nfunction TMyObject.EchoComplexArrayOfRecords2(\n  VendorProxiesAndLinks: TNestedArraysRec): TNestedArraysRec;\nbegin\n  Result := VendorProxiesAndLinks;\n  Result.TestRecProp.StringProp := VendorProxiesAndLinks.TestRecProp.StringProp + ' (changed from server)';\nend;\n\nprocedure TMyObject.FillCustomersDataset(const DataSet: TDataSet);\nbegin\n  DataSet.AppendRecord([1, 'Ford']);\n  DataSet.AppendRecord([2, 'Ferrari']);\n  DataSet.AppendRecord([3, 'Lotus']);\n  DataSet.AppendRecord([4, 'FCA']);\n  DataSet.AppendRecord([5, 'Hyundai']);\n  DataSet.AppendRecord([6, 'De Tomaso']);\n  DataSet.AppendRecord([7, 'Dodge']);\n  DataSet.AppendRecord([8, 'Tesla']);\n  DataSet.AppendRecord([9, 'Kia']);\n  DataSet.AppendRecord([10, 'Tata']);\n  DataSet.AppendRecord([11, 'Volkswagen']);\n  DataSet.AppendRecord([12, 'Audi']);\n  DataSet.AppendRecord([13, 'Skoda']);\n  DataSet.First;\nend;\n\nprocedure TMyObject.FillPeopleDataset(const DataSet: TDataSet);\nbegin\n  DataSet.AppendRecord(['Daniele', 'Teti']);\n  DataSet.AppendRecord(['Peter', 'Parker']);\n  DataSet.AppendRecord(['Bruce', 'Banner']);\n  DataSet.AppendRecord(['Scott', 'Summers']);\n  DataSet.AppendRecord(['Sue', 'Storm']);\n  DataSet.First;\nend;\n\nfunction TMyObject.FloatsTest(const aDouble: Double; const aExtended: Extended): Extended;\nbegin\n  Result := aDouble + aExtended;\nend;\n\nfunction TMyObject.GetComplex1: TNestedArraysRec;\nbegin\n  SetLength(Result.ArrayProp1, 2);\n  SetLength(Result.ArrayProp2, 2);\n\n  Result.ArrayProp1[0] := TTestRec.Create(1234);\n  Result.ArrayProp1[1] := TTestRec.Create(2345);\n\n  Result.ArrayProp2[0] := TTestRec.Create(3456);\n  Result.ArrayProp2[1] := TTestRec.Create(4567);\n\nend;\n\nfunction TMyObject.GetCustomers(FilterString: string): TDataSet;\nvar\n  lMT: TFDMemTable;\nbegin\n  lMT := GetCustomersDataset;\n  try\n    if not FilterString.IsEmpty then\n    begin\n      lMT.Filter := FilterString;\n      lMT.Filtered := True;\n    end;\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction TMyObject.GetCustomersDataset: TFDMemTable;\nvar\n  lMT: TFDMemTable;\nbegin\n  lMT := TFDMemTable.Create(nil);\n  try\n    lMT.FieldDefs.Clear;\n    lMT.FieldDefs.Add('Code', ftInteger);\n    lMT.FieldDefs.Add('Name', ftString, 20);\n    lMT.Active := True;\n    lMT.AppendRecord([1, 'Ford']);\n    lMT.AppendRecord([2, 'Ferrari']);\n    lMT.AppendRecord([3, 'Lotus']);\n    lMT.AppendRecord([4, 'FCA']);\n    lMT.AppendRecord([5, 'Hyundai']);\n    lMT.AppendRecord([6, 'De Tomaso']);\n    lMT.AppendRecord([7, 'Dodge']);\n    lMT.AppendRecord([8, 'Tesla']);\n    lMT.AppendRecord([9, 'Kia']);\n    lMT.AppendRecord([10, 'Tata']);\n    lMT.AppendRecord([11, 'Volkswagen']);\n    lMT.AppendRecord([12, 'Audi']);\n    lMT.AppendRecord([13, 'Skoda']);\n    lMT.First;\n    Result := lMT;\n  except\n    lMT.Free;\n    raise;\n  end;\nend;\n\nfunction TMyObject.GetMulti: TMultiDataset;\nbegin\n  Result := TMultiDataset.Create;\n  FillCustomersDataset(Result.Customers);\n  FillPeopleDataset(Result.People);\nend;\n\nfunction TMyObject.GetNextMonday(const aDate: TDate): TDate;\nvar\n  lDate: TDate;\nbegin\n  lDate := aDate + 1;\n  while DayOfTheWeek(lDate) <> 1 do\n  begin\n    lDate := lDate + 1;\n  end;\n  Result := lDate;\nend;\n\nfunction TMyObject.GetPeopleRecDynArray: TTestRecDynArray;\nbegin\n  SetLength(Result, 2);\n  Result[0] := TTestRec.Create(1);\n  Result[1] := TTestRec.Create(2);\nend;\n\nfunction TMyObject.GetPeopleRecStaticArray: TTestRecArray;\nbegin\n  Result[0] := TTestRec.Create(7);\n  Result[1] := TTestRec.Create(8);\nend;\n\nfunction TMyObject.GetPersonRec: TTestRec;\nbegin\n  Result := TTestRec.Create(99);\nend;\n\nfunction TMyObject.GetSetBySet(Value: TSetTest): TSetTest;\nbegin\n  Result := [];\n  for var lItem := ptEnumValue1 to ptEnumValue4 do\n  begin\n    if lItem in Value then\n    begin\n      Result := Result - [lItem];\n    end\n    else\n    begin\n      Result := Result + [lItem];\n    end;\n  end;\nend;\n\nfunction TMyObject.GetStringDictionary: TMVCStringDictionary;\nbegin\n  Result := TMVCStringDictionary.Create;\n  Result.Add('key1', 'value1');\n  Result.Add('key2', 'value2');\n  Result.Add('key3', 'value3');\n  Result.Add('key4', 'value4');\nend;\n\nfunction TMyObject.GetUser(aUserName: string): TPerson;\nbegin\n  Result := TPerson.Create;\n  Result.FirstName := 'Daniele (a.k.a. ' + aUserName + ')';\n  Result.LastName := 'Teti';\n  Result.DOB := EncodeDate(1932, 11, 4); // hey, it is a joke :-)\n  Result.Married := True;\nend;\n\nprocedure TMyObject.InvalidMethod1(var MyVarParam: Integer);\nbegin\n  // do nothing\nend;\n\nprocedure TMyObject.InvalidMethod2(out MyOutParam: Integer);\nbegin\n  // do nothing\nend;\n\nfunction TMyObject.PlayWithDatesAndTimes(const aJustAFloat: Double; const aTime: TTime;\n  const aDate: TDate; const aDateAndTime: TDateTime): TDateTime;\nbegin\n  Result := aDateAndTime + aDate + aTime + TDateTime(aJustAFloat);\nend;\n\nprocedure TMyObject.RaiseCustomException;\nbegin\n  raise EMVCJSONRPCError.Create(JSONRPC_USER_ERROR + 1, 'This is an exception message');\nend;\n\nfunction TMyObject.RaiseGenericException(const ExceptionType: Integer): Integer;\nvar\n  l: Integer;\nbegin\n  case ExceptionType of\n    1:\n      begin\n        l := 0;\n        Result := 10 div l;\n      end;\n    2:\n      begin\n        raise EInvalidPointer.Create('Fake Invalid Pointer Operation');\n      end;\n    else\n    begin\n      raise Exception.Create('BOOOOM!');\n    end;\n  end;\nend;\n\nfunction TMyObject.ReverseString(const aString: string; const aUpperCase: Boolean): string;\nbegin\n  Result := System.StrUtils.ReverseString(aString);\n  if aUpperCase then\n    Result := Result.ToUpper;\nend;\n\nfunction TMyObject.SaveObjectWithJSON(const WithJSON: TJsonObject): TJsonObject;\nvar\n  lObj: TObjectWithJSONObject;\nbegin\n  lObj := TUtils.JSONObjectAs<TObjectWithJSONObject>(WithJSON);\n  try\n    LogD(lObj);\n    Result := WithJSON.Clone as TJsonObject;\n  finally\n    lObj.Free;\n  end;\nend;\n\nfunction TMyObject.SavePerson(const Person: TPerson): Integer;\n// var\n// lPerson: TPerson;\nbegin\n  // lPerson := JSONObjectAs<TPerson>(aPerson);\n  // try\n  // // do something with lPerson\n  // finally\n  // lPerson.Free;\n  // end;\n\n  // this maybe the id of the newly created person\n  LogI(Person);\n  Result := Random(1000);\nend;\n\nfunction TMyObject.SavePersonRec(PersonRec: TTestRec): TTestRec;\nbegin\n  Result := PersonRec;\nend;\n\nfunction TMyObject.Subtract(Value1, Value2: Integer): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TMyObjectWithHooks }\n\nprocedure TMyObject.OnBeforeCallHook(const Context: TWebContext; const JSONRequest: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnBeforeCallHook >> ', 'jsonrpc');\n  Log.Info(sLineBreak + JSONRequest.ToJSON(False), 'jsonrpc');\n  Log.Info('TMyObjectWithHooks.OnBeforeCallHook << ', 'jsonrpc');\nend;\n\nprocedure TMyObject.OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnBeforeRoutingHook >> ', 'jsonrpc');\n  Log.Info(sLineBreak + JSON.ToJSON(False), 'jsonrpc');\n  Log.Info('TMyObjectWithHooks.OnBeforeRoutingHook << ', 'jsonrpc');\nend;\n\nprocedure TMyObject.OnAfterCallHook(const Context: TWebContext; const JSONResponse: TJDOJsonObject);\nbegin\n  Log.Info('TMyObjectWithHooks.OnAfterCallHook >> ', 'jsonrpc');\n  if Assigned(JSONResponse) then\n  begin\n    Log.Info(sLineBreak + JSONResponse.ToJSON(False), 'jsonrpc');\n  end;\n  Log.Info('TMyObjectWithHooks.OnAfterCallHook << ', 'jsonrpc');\nend;\n\nend.", "output": "[Flags]\npublic enum TSetTest\n{\n    None = 0,\n    ptEnumValue1 = 1,\n    ptEnumValue2 = 2,\n    ptEnumValue3 = 4,\n    ptEnumValue4 = 8\n}\n\npublic class TTestRec\n{\n    public int Value { get; set; }\n    public TTestRec(int value)\n    {\n        Value = value;\n    }\n}\n\npublic class TTestRecDynArray : List<TTestRec>\n{\n}\n\npublic class TTestRecArray\n{\n    public TTestRec[] Array;\n}\n\npublic class TNestedArraysRec\n{\n    public TTestRec[] ArrayProp1;\n    public TTestRec[] ArrayProp2;\n    public TTestRec TestRecProp;\n}\n\npublic class TMultiDataset\n{\n    public DataTable Customers { get; set; }\n    public DataTable People { get; set; }\n    public TMultiDataset()\n    {\n        Customers = new DataTable();\n        People = new DataTable();\n    }\n}\n\npublic class TMVCStringDictionary : Dictionary<string, string>\n{\n}\n\npublic class TPerson\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public DateTime DOB { get; set; }\n    public bool Married { get; set; }\n}\n\npublic class WebContext\n{\n}\n\npublic class MVCJSONRPCErrorException : Exception\n{\n    public int Code { get; }\n    public MVCJSONRPCErrorException(int code, string message) : base(message)\n    {\n        Code = code;\n    }\n}\n\npublic static class Constants\n{\n    public const int JSONRPC_USER_ERROR = 1000;\n}\n\npublic class MyObject\n{\n    DataTable GetCustomersDataset()\n    {\n        DataTable dt = new DataTable();\n        dt.Columns.Add(\"Code\", typeof(int));\n        dt.Columns.Add(\"Name\", typeof(string));\n        dt.Rows.Add(1, \"Ford\");\n        dt.Rows.Add(2, \"Ferrari\");\n        dt.Rows.Add(3, \"Lotus\");\n        dt.Rows.Add(4, \"FCA\");\n        dt.Rows.Add(5, \"Hyundai\");\n        dt.Rows.Add(6, \"De Tomaso\");\n        dt.Rows.Add(7, \"Dodge\");\n        dt.Rows.Add(8, \"Tesla\");\n        dt.Rows.Add(9, \"Kia\");\n        dt.Rows.Add(10, \"Tata\");\n        dt.Rows.Add(11, \"Volkswagen\");\n        dt.Rows.Add(12, \"Audi\");\n        dt.Rows.Add(13, \"Skoda\");\n        dt.AcceptChanges();\n        return dt;\n    }\n\n    void FillCustomersDataset(DataTable dataSet)\n    {\n        dataSet.Rows.Add(1, \"Ford\");\n        dataSet.Rows.Add(2, \"Ferrari\");\n        dataSet.Rows.Add(3, \"Lotus\");\n        dataSet.Rows.Add(4, \"FCA\");\n        dataSet.Rows.Add(5, \"Hyundai\");\n        dataSet.Rows.Add(6, \"De Tomaso\");\n        dataSet.Rows.Add(7, \"Dodge\");\n        dataSet.Rows.Add(8, \"Tesla\");\n        dataSet.Rows.Add(9, \"Kia\");\n        dataSet.Rows.Add(10, \"Tata\");\n        dataSet.Rows.Add(11, \"Volkswagen\");\n        dataSet.Rows.Add(12, \"Audi\");\n        dataSet.Rows.Add(13, \"Skoda\");\n        dataSet.AcceptChanges();\n    }\n\n    void FillPeopleDataset(DataTable dataSet)\n    {\n        dataSet.Rows.Add(\"Daniele\", \"Teti\");\n        dataSet.Rows.Add(\"Peter\", \"Parker\");\n        dataSet.Rows.Add(\"Bruce\", \"Banner\");\n        dataSet.Rows.Add(\"Scott\", \"Summers\");\n        dataSet.Rows.Add(\"Sue\", \"Storm\");\n        dataSet.AcceptChanges();\n    }\n\n    public void OnBeforeRoutingHook(WebContext context, JObject json)\n    {\n    }\n\n    public void OnBeforeCallHook(WebContext context, JObject jsonRequest)\n    {\n        Console.WriteLine(\"TMyObject.OnBeforeCallHook >>\");\n        Console.WriteLine(jsonRequest.ToString(Formatting.None));\n        Console.WriteLine(\"TMyObject.OnBeforeCallHook <<\");\n    }\n\n    public void OnAfterCallHook(WebContext context, JObject jsonResponse)\n    {\n        Console.WriteLine(\"TMyObject.OnAfterCallHook >>\");\n        if (jsonResponse != null)\n        {\n            Console.WriteLine(jsonResponse.ToString(Formatting.None));\n        }\n        Console.WriteLine(\"TMyObject.OnAfterCallHook <<\");\n    }\n\n    public int Subtract(int value1, int value2)\n    {\n        return value1 - value2;\n    }\n\n    public string ReverseString(string aString, bool aUpperCase)\n    {\n        char[] chars = aString.ToCharArray();\n        Array.Reverse(chars);\n        string result = new string(chars);\n        if (aUpperCase)\n        {\n            result = result.ToUpper();\n        }\n        return result;\n    }\n\n    public DateTime GetNextMonday(DateTime aDate)\n    {\n        DateTime lDate = aDate.AddDays(1);\n        while (lDate.DayOfWeek != DayOfWeek.Monday)\n        {\n            lDate = lDate.AddDays(1);\n        }\n        return lDate;\n    }\n\n    public DateTime PlayWithDatesAndTimes(double aJustAFloat, TimeSpan aTime, DateTime aDate, DateTime aDateAndTime)\n    {\n        return aDateAndTime.Add(aDate.TimeOfDay).Add(aTime).Add(TimeSpan.FromDays(aJustAFloat));\n    }\n\n    public DataTable GetCustomers(string filterString)\n    {\n        DataTable dt = GetCustomersDataset();\n        if (!string.IsNullOrEmpty(filterString))\n        {\n            dt.DefaultView.RowFilter = filterString;\n            dt = dt.DefaultView.ToTable();\n        }\n        dt.AcceptChanges();\n        return dt;\n    }\n\n    public TMultiDataset GetMulti()\n    {\n        TMultiDataset result = new TMultiDataset();\n        FillCustomersDataset(result.Customers);\n        FillPeopleDataset(result.People);\n        return result;\n    }\n\n    public TMVCStringDictionary GetStringDictionary()\n    {\n        var dict = new TMVCStringDictionary();\n        dict.Add(\"key1\", \"value1\");\n        dict.Add(\"key2\", \"value2\");\n        dict.Add(\"key3\", \"value3\");\n        dict.Add(\"key4\", \"value4\");\n        return dict;\n    }\n\n    public TPerson GetUser(string aUserName)\n    {\n        TPerson person = new TPerson();\n        person.FirstName = \"Daniele (a.k.a. \" + aUserName + \")\";\n        person.LastName = \"Teti\";\n        person.DOB = new DateTime(1932, 11, 4);\n        person.Married = true;\n        return person;\n    }\n\n    public int SavePerson(TPerson person)\n    {\n        Console.WriteLine(person.FirstName + \" \" + person.LastName);\n        return new Random().Next(1000);\n    }\n\n    public double FloatsTest(double aDouble, double aExtended)\n    {\n        return aDouble + aExtended;\n    }\n\n    public void DoSomething()\n    {\n    }\n\n    public void RaiseCustomException()\n    {\n        throw new MVCJSONRPCErrorException(Constants.JSONRPC_USER_ERROR + 1, \"This is an exception message\");\n    }\n\n    public int RaiseGenericException(int exceptionType)\n    {\n        switch (exceptionType)\n        {\n            case 1:\n                int l = 0;\n                return 10 / l;\n            case 2:\n                throw new NullReferenceException(\"Fake Invalid Pointer Operation\");\n            default:\n                throw new Exception(\"BOOOOM!\");\n        }\n    }\n\n    public JObject SaveObjectWithJSON(JObject withJSON)\n    {\n        var obj = Utils.JSONObjectAs<ObjectWithJSONObject>(withJSON);\n        Console.WriteLine(obj);\n        return (JObject)withJSON.DeepClone();\n    }\n\n    public TEnumTest PassingEnums(TEnumTest value1, TEnumTest value2)\n    {\n        if (value1 == value2)\n            return TEnumTest.ptEnumValue4;\n        else\n            return TEnumTest.ptEnumValue3;\n    }\n\n    public TSetTest GetSetBySet(TSetTest value)\n    {\n        TSetTest result = TSetTest.None;\n        foreach (TEnumTest item in Enum.GetValues(typeof(TEnumTest)))\n        {\n            if (value.HasFlag((TSetTest)(1 << (int)item)))\n                result &= ~(TSetTest)(1 << (int)item);\n            else\n                result |= (TSetTest)(1 << (int)item);\n        }\n        return result;\n    }\n\n    public TTestRec SavePersonRec(TTestRec personRec)\n    {\n        return personRec;\n    }\n\n    public TTestRecDynArray GetPeopleRecDynArray()\n    {\n        TTestRecDynArray arr = new TTestRecDynArray();\n        arr.Add(new TTestRec(1));\n        arr.Add(new TTestRec(2));\n        return arr;\n    }\n\n    public TTestRecArray GetPeopleRecStaticArray()\n    {\n        TTestRecArray result = new TTestRecArray();\n        result.Array = new TTestRec[2];\n        result.Array[0] = new TTestRec(7);\n        result.Array[1] = new TTestRec(8);\n        return result;\n    }\n\n    public TTestRec GetPersonRec()\n    {\n        return new TTestRec(99);\n    }\n\n    public TNestedArraysRec GetComplex1()\n    {\n        TNestedArraysRec result = new TNestedArraysRec();\n        result.ArrayProp1 = new TTestRec[2];\n        result.ArrayProp2 = new TTestRec[2];\n        result.ArrayProp1[0] = new TTestRec(1234);\n        result.ArrayProp1[1] = new TTestRec(2345);\n        result.ArrayProp2[0] = new TTestRec(3456);\n        result.ArrayProp2[1] = new TTestRec(4567);\n        return result;\n    }\n\n    public TTestRecDynArray EchoComplexArrayOfRecords(TTestRecDynArray peopleList)\n    {\n        return peopleList;\n    }\n\n    public TNestedArraysRec EchoComplexArrayOfRecords2(TNestedArraysRec vendorProxiesAndLinks)\n    {\n        vendorProxiesAndLinks.TestRecProp.Value += 0;\n        return vendorProxiesAndLinks;\n    }\n\n    public void InvalidMethod1(ref int myVarParam)\n    {\n    }\n\n    public void InvalidMethod2(out int myOutParam)\n    {\n        myOutParam = 0;\n    }\n}\n\npublic static class Utils\n{\n    public static T JSONObjectAs<T>(JObject json) where T : class, new()\n    {\n        T obj = new T();\n        string jsonStr = json.ToString(Formatting.None);\n        obj = JsonConvert.DeserializeObject<T>(jsonStr);\n        return obj;\n    }\n}\n\npublic class ObjectWithJSONObject\n{\n    public override string ToString()\n    {\n        return \"ObjectWithJSONObject\";\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file: David Moorhouse (info@moorhouse.net.nz)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Serializer.URLEncoded;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes, System.Rtti,\n  System.TypInfo, Data.DB,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Abstract,\n  MVCFramework.DuckTyping,\n  MVCFramework.Serializer.Commons,\n  System.SysUtils;\n\ntype\n  TMVCURLEncodedSerializer = class(TMVCAbstractSerializer, IMVCSerializer)\n  private\n    procedure DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember; const RawData: string;\n      const AName: string; var AValue: TValue; const AType: TMVCSerializationType; const AIgnored: TMVCIgnoredList;\n      const ACustomAttributes: TArray<TCustomAttribute>); overload;\n  procedure DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n    const RawDataArray: TArray<string>; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n    const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>); overload;\n\n  protected\n    procedure RaiseNotImplemented;\n  protected\n    { IMVCSerializer }\n    procedure RegisterTypeSerializer(const ATypeInfo: PTypeInfo; AInstance: IMVCTypeSerializer);\n\n    function SerializeObject(const AObject: TObject; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeObject(const AObject: IInterface; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeRecord(const ARecord: Pointer; const ARecordTypeInfo: PTypeInfo;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ASerializationAction: TMVCSerializationAction = nil): string; overload;\n\n    function SerializeCollection(const AList: TObject; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeCollection(const AList: IInterface; const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil; const ASerializationAction: TMVCSerializationAction = nil)\n      : string; overload;\n\n    function SerializeDataSet(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList = [];\n      const ANameCase: TMVCNameCase = ncAsIs; const ASerializationAction: TMVCDatasetSerializationAction = nil): string;\n\n    function SerializeDataSetRecord(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList = [];\n      const ANameCase: TMVCNameCase = ncAsIs; const ASerializationAction: TMVCDatasetSerializationAction = nil): string;\n\n    procedure DeserializeObject(const ASerializedObject: string; const AObject: TObject;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ARootNode: String = ''); overload;\n\n    procedure DeserializeObject(const ASerializedObject: string; const AObject: IInterface;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil); overload;\n\n    procedure DeserializeCollection(const ASerializedList: string; const AList: TObject; const AClazz: TClass;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ARootNode: String = ''); overload;\n\n    procedure DeserializeCollection(const ASerializedList: string; const AList: IInterface; const AClazz: TClass;\n      const AType: TMVCSerializationType = stDefault; const AIgnoredAttributes: TMVCIgnoredList = nil); overload;\n\n    procedure DeserializeDataSet(const ASerializedDataSet: string; const ADataSet: TDataSet;\n      const AIgnoredFields: TMVCIgnoredList = []; const ANameCase: TMVCNameCase = ncAsIs);\n\n    procedure DeserializeDataSetRecord(const ASerializedDataSetRecord: string; const ADataSet: TDataSet;\n      const AIgnoredFields: TMVCIgnoredList = []; const ANameCase: TMVCNameCase = ncAsIs);\n\n    function SerializeArrayOfRecord(\n      var ATValueContainingAnArray: TValue;\n      const AType: TMVCSerializationType = stDefault;\n      const AIgnoredAttributes: TMVCIgnoredList = nil;\n      const ASerializationAction: TMVCSerializationAction = nil\n      ): string; overload;\n\n  public\n    procedure URLEncodedStringToObject(\n      const Data: TStringList; const AObject: TObject;\n      const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\n\n  end;\n\nimplementation\n\nuses\n  System.NetEncoding, System.Math, JsonDataObjects, MVCFramework.Nullables;\n\n{ TMVCURLEncodedSerializer }\n\nprocedure TMVCURLEncodedSerializer.DeserializeCollection(const ASerializedList: string; const AList: IInterface;\n  const AClazz: TClass; const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeCollection(const ASerializedList: string; const AList: TObject;\n  const AClazz: TClass; const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList; const ARootNode: String);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeDataSet(const ASerializedDataSet: string; const ADataSet: TDataSet;\n  const AIgnoredFields: TMVCIgnoredList; const ANameCase: TMVCNameCase);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeDataSetRecord(const ASerializedDataSetRecord: string; const ADataSet: TDataSet;\n  const AIgnoredFields: TMVCIgnoredList; const ANameCase: TMVCNameCase);\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeObject(const ASerializedObject: string; const AObject: IInterface;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nbegin\n  // ??\nend;\n\nprocedure TMVCURLEncodedSerializer.DeserializeObject(const ASerializedObject: string; const AObject: TObject;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList; const ARootNode: String);\nvar\n  SL: TStringList;\n  lPieces: TArray<string>;\n  I: Integer;\n  lKeyValue: TArray<string>;\nbegin\n  if (ASerializedObject = EmptyStr) then\n    raise EMVCException.Create(HTTP_STATUS.BadRequest, 'Invalid body');\n\n  if not Assigned(AObject) then\n    Exit;\n\n  SL := TStringList.Create;\n  try\n    try\n      lPieces := ASerializedObject.Split(['&']);\n      for I := 0 to High(lPieces) do\n      begin\n        lKeyValue := lPieces[I].Split(['=']);\n        SL.AddPair(lKeyValue[0], URLDecode(lKeyValue[1]));\n      end;\n      if GetTypeSerializers.ContainsKey(AObject.ClassInfo) then\n      begin\n        RaiseNotImplemented;\n        // todo: do we handle custom type serialisers\n        // GetTypeSerializers.Items[AObject.ClassInfo].DeserializeRoot(SelectRootNodeOrWholeObject(ARootNode, JSONObject),\n        // AObject, [])\n      end\n      else\n      begin\n        URLEncodedStringToObject(SL, AObject, GetSerializationType(AObject, AType), AIgnoredAttributes);\n      end;\n    except\n      on E: Exception do\n        raise EMVCException.Create(HTTP_STATUS.BadRequest, E.Message);\n    end;\n  finally\n    SL.Free;\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.RaiseNotImplemented;\nbegin\n  raise EMVCException.Create('Not Implemented');\nend;\n\nprocedure TMVCURLEncodedSerializer.RegisterTypeSerializer(const ATypeInfo: PTypeInfo; AInstance: IMVCTypeSerializer);\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeCollection(const AList: TObject; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeArrayOfRecord(\n  var ATValueContainingAnArray: TValue; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList;\n  const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeCollection(const AList: IInterface; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeDataSet(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList;\n  const ANameCase: TMVCNameCase; const ASerializationAction: TMVCDatasetSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeDataSetRecord(const ADataSet: TDataSet; const AIgnoredFields: TMVCIgnoredList;\n  const ANameCase: TMVCNameCase; const ASerializationAction: TMVCDatasetSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeObject(const AObject: IInterface; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeObject(const AObject: TObject; const AType: TMVCSerializationType;\n  const AIgnoredAttributes: TMVCIgnoredList; const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nfunction TMVCURLEncodedSerializer.SerializeRecord(const ARecord: Pointer; const ARecordTypeInfo: PTypeInfo;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList;\n  const ASerializationAction: TMVCSerializationAction): string;\nbegin\n  RaiseNotImplemented;\nend;\n\nprocedure TMVCURLEncodedSerializer.URLEncodedStringToObject(\n  const Data: TStringList; const AObject: TObject;\n  const AType: TMVCSerializationType; const AIgnoredAttributes: TMVCIgnoredList);\nvar\n  lObjType: TRttiType;\n  lProp: TRttiProperty;\n  lFld: TRttiField;\n  lAttributeValue: TValue;\n  lKeyName: string;\n  lErrMsg: string;\n  I: Integer;\n  lArrValues: TArray<String>;\n  lCurrIdx: Integer;\n  lName: string;\n  lTmp: string;\nconst\n  INITIAL_ARRAY_SIZE = 5;\nbegin\n  if AObject = nil then\n  begin\n    Exit;\n  end;\n\n  if TypeInfo(tjsonobject) = AObject.ClassInfo then\n  begin\n    for I := 0 to Data.Count-1 do\n    begin\n      lName := Data.Names[I];\n      if TJsonObject(AObject).IsNull(lName) then\n      begin\n        TJsonObject(AObject).S[lName] := Data.ValueFromIndex[I];\n      end\n      else\n      begin\n        if TJsonObject(AObject).Types[lName] = jdtString then\n        begin\n          lTmp := TJsonObject(AObject).S[lName];\n          TJsonObject(AObject).Remove(lName);\n          TJsonObject(AObject).A[lName].Add(lTmp);\n        end;\n        TJsonObject(AObject).A[lName].Add(Data.ValueFromIndex[I]);\n      end;\n    end;\n    Exit;\n  end;\n\n  lProp := nil;\n  lFld := nil;\n\n  lObjType := GetRttiContext.GetType(AObject.ClassType);\n  case AType of\n    stDefault, stProperties:\n      begin\n        try\n          for lProp in lObjType.GetProperties do\n          begin\n{$IFDEF AUTOREFCOUNT}\n            if TMVCSerializerHelper.IsAPropertyToSkip(lProp.Name) then\n              continue;\n{$ENDIF}\n            if ((not TMVCSerializerHelper.HasAttribute<MVCDoNotDeserializeAttribute>(lProp)) and\n              (not IsIgnoredAttribute(AIgnoredAttributes, lProp.Name)) and (lProp.IsWritable or lProp.GetValue(AObject).IsObject))\n            then\n            begin\n              lAttributeValue := lProp.GetValue(AObject);\n              lKeyName := TMVCSerializerHelper.GetKeyName(lProp, lObjType);\n              if not lAttributeValue.IsArray then\n              begin\n                if Data.IndexOfName(lKeyName) > -1 then\n                begin\n                  DataValueToAttribute(AObject, lProp, Data.Values[lKeyName], lKeyName, lAttributeValue, AType, AIgnoredAttributes,\n                    lProp.GetAttributes);\n                  if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) and lProp.IsWritable then\n                  begin\n                    lProp.SetValue(AObject, lAttributeValue);\n                  end;\n                end;\n              end\n              else\n              begin\n                // there are multiple parameters with the same name\n                if Data.IndexOfName(lKeyName) > -1 then\n                begin\n                  SetLength(lArrValues, INITIAL_ARRAY_SIZE);\n                  lCurrIdx := -1;\n                  for I := 0 to Data.Count - 1 do\n                  begin\n                    if Data.Names[i] = lKeyName then\n                    begin\n                      Inc(lCurrIdx);\n                      if (lCurrIdx >= INITIAL_ARRAY_SIZE) and (lCurrIdx >= Length(lArrValues)) then {does short-circuit make it faster?}\n                      begin\n                        SetLength(lArrValues, Trunc(lCurrIdx * 2));\n                      end;\n                      lArrValues[lCurrIdx] := Data.ValueFromIndex[i];\n                    end;\n                  end;\n                  SetLength(lArrValues, lCurrIdx + 1); //trim\n                  DataValueToAttribute(AObject, lProp, lArrValues, lKeyName,\n                    lAttributeValue, AType, AIgnoredAttributes, lProp.GetAttributes);\n                  if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) and lProp.IsWritable then\n                  begin\n                    lProp.SetValue(AObject, lAttributeValue);\n                  end;\n                end;\n              end;\n            end;\n          end;\n        except\n          on E: EInvalidCast do\n          begin\n            if lProp <> nil then\n            begin\n              lErrMsg := Format('Invalid class typecast for property \"%s\" [Expected: %s, Data: %s]',\n                [lKeyName, lProp.PropertyType.ToString(), Data.Values[lKeyName]]);\n            end\n            else\n            begin\n              lErrMsg := Format('Invalid class typecast for property \"%s\" [Data: %s]', [lKeyName, Data.Values[lKeyName]]);\n            end;\n            raise EMVCException.Create(HTTP_STATUS.BadRequest, lErrMsg);\n          end;\n        end;\n      end;\n    stFields:\n      begin\n        try\n          for lFld in lObjType.GetFields do\n            if (not TMVCSerializerHelper.HasAttribute<MVCDoNotDeserializeAttribute>(lFld)) and\n              (not IsIgnoredAttribute(AIgnoredAttributes, lFld.Name)) then\n            begin\n              lAttributeValue := lFld.GetValue(AObject);\n              lKeyName := TMVCSerializerHelper.GetKeyName(lFld, lObjType);\n              if Data.IndexOfName(lKeyName) > -1 then\n              begin\n                DataValueToAttribute(AObject, lFld, Data.Values[lKeyName], lKeyName, lAttributeValue, AType, AIgnoredAttributes,\n                  lFld.GetAttributes);\n                if (not lAttributeValue.IsEmpty) and (not lAttributeValue.IsObject) then\n                  lFld.SetValue(AObject, lAttributeValue);\n              end;\n            end;\n        except\n          on E: EInvalidCast do\n          begin\n            if lFld <> nil then\n            begin\n              lErrMsg := Format('Invalid class typecast for field \"%s\" [Expected: %s, Data: %s]',\n                [lKeyName, lFld.FieldType.ToString(), Data.Values[lKeyName]]);\n            end\n            else\n            begin\n              lErrMsg := Format('Invalid class typecast for field \"%s\" [Data: %s]', [lKeyName, Data.Values[lKeyName]]);\n            end;\n            raise EMVCException.Create(HTTP_STATUS.BadRequest, lErrMsg);\n          end;\n        end;\n      end;\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n  const RawData: string; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n  const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>);\nvar\n  RttiType: TRttiType;\n  lValueTypeInfo: PTypeInfo;\n  lOutInteger: Integer;\n  lOutInteger64: Int64;\n  lOutUInteger64: UInt64;\n  lOutSingle: Double;\n  lOutDouble: Double;\n  lOutExtended: Extended;\n  lOutUInteger: Cardinal;\nbegin\n  RttiType := nil;\n  AValue.Empty;\n  case AType of\n    stUnknown, stDefault, stProperties:\n      RttiType := TRttiProperty(ARttiMember).PropertyType;\n    stFields:\n      RttiType := TRttiField(ARttiMember).FieldType;\n  end;\n\n\n  case RttiType.TypeKind of\n    tkString, tkWideString, tkAnsiString, tkUString:\n      AValue := TNetEncoding.URL.Decode(RawData);\n    tkInteger:\n      AValue := RawData.ToInteger;\n    tkInt64:\n      AValue := RawData.ToInt64;\n    tkFloat:\n      AValue := RawData.ToDouble;\n    tkEnumeration:\n      begin\n        if SameText(RttiType.ToString, 'boolean') then\n          AValue := RawData.ToBoolean;\n      end;\n    tkRecord:\n    begin\n      if String(RttiType.Handle^.Name).StartsWith('Nullable', True) then\n      begin\n        lValueTypeInfo := AValue.TypeInfo;\n        if lValueTypeInfo = TypeInfo(NullableString) then\n        begin\n          AValue := TValue.From<NullableString>(RawData);\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt32) then\n        begin\n          if TryStrToInt(RawData, lOutInteger) then\n            AValue := TValue.From<NullableInt32>(lOutInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt32) then\n        begin\n          if TryStrToUInt(RawData, lOutUInteger) then\n            AValue := TValue.From<NullableUInt32>(lOutUInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt16) then\n        begin\n          if TryStrToInt(RawData, lOutInteger) then\n            AValue := TValue.From<NullableInt16>(lOutInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt16) then\n        begin\n          if TryStrToUInt(RawData, lOutUInteger) then\n            AValue := TValue.From<NullableUInt16>(lOutUInteger)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableInt64) then\n        begin\n          if TryStrToInt64(RawData, lOutInteger64) then\n            AValue := TValue.From<NullableInt64>(lOutInteger64)\n          else\n            AValue := TValue.Empty;\n        end\n        else if lValueTypeInfo = TypeInfo(NullableUInt64) then\n        begin\n          if TryStrToUInt64(RawData, lOutUInteger64) then\n            AValue := TValue.From<NullableUInt64>(lOutUInteger64)\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableSingle)) then\n        begin\n          if TryStrToFloat(RawData, lOutSingle) then\n            AValue := TValue.From<NullableSingle>(lOutSingle)\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableDouble)) then\n        begin\n          if TryStrToFloat(RawData, lOutDouble) then\n            AValue := lOutDouble\n          else\n            AValue := TValue.Empty;\n        end\n        else if (lValueTypeInfo = TypeInfo(NullableExtended)) then\n        begin\n          if TryStrToFloat(RawData, lOutExtended) then\n            AValue := lOutExtended\n          else\n            AValue := TValue.Empty;\n        end\n        else\n        begin\n          raise EMVCDeserializationException.Create('(DataValueToAttribute) Cannot deserialize Nullable type ' + String(RttiType.Handle^.Name));\n        end;\n      end\n      else\n      begin\n        raise EMVCDeserializationException.Create('(DataValueToAttribute) Invalid Record Type ' + String(RttiType.Handle^.Name));\n      end;\n    end\n    else\n      raise EMVCDeserializationException.Create('(DataValueToAttribute) Invalid TypeKind: ' + GetEnumName(TypeInfo(TTypeKind), Ord(RttiType.TypeKind)));\n  end;\nend;\n\nprocedure TMVCURLEncodedSerializer.DataValueToAttribute(const AObject: TObject; const ARttiMember: TRttiMember;\n  const RawDataArray: TArray<string>; const AName: string; var AValue: TValue; const AType: TMVCSerializationType;\n  const AIgnored: TMVCIgnoredList; const ACustomAttributes: TArray<TCustomAttribute>);\nvar\n  RttiType: TRttiType;\n  //RttiArray: TRttiDynamicArrayType;\nbegin\n  RttiType := nil;\n  AValue.Empty;\n  case AType of\n    stUnknown, stDefault, stProperties:\n      RttiType := TRttiProperty(ARttiMember).PropertyType;\n    stFields:\n      RttiType := TRttiField(ARttiMember).FieldType;\n  end;\n\n  if RttiType.TypeKind <> tkDynArray then\n  begin\n    raise EMVCDeserializationException.Create('Expected DynArray in deserialization for ' + AName);\n  end;\n\n  //RttiArray := TRttiDynamicArrayType(RttiType);\n  AValue := TValue.From(RawDataArray)\nend;\n\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Web; \n\nnamespace MVCFramework.Serializer.URLEncoded\n{\n    \n    public enum TMVCSerializationType\n    {\n        Default,\n        Properties,\n        Fields,\n        Unknown\n    }\n\n    \n    public enum TMVCNameCase\n    {\n        AsIs,\n        LowerCase,\n        UpperCase\n    }\n\n    \n    public class EMVCException : Exception\n    {\n        public int StatusCode { get; }\n        public EMVCException(int statusCode, string message) : base(message) => StatusCode = statusCode;\n    }\n\n    \n    public class EMVCDeserializationException : Exception\n    {\n        public EMVCDeserializationException(string message) : base(message) { }\n    }\n\n    \n    public interface IMVCTypeSerializer\n    {\n        void SerializeAttribute(object elementValue, string propertyName, object serializerObject, Attribute[] customAttributes);\n        void SerializeRoot(object obj, out object serializerObject, Attribute[] customAttributes, Action serializationAction = null);\n        void DeserializeAttribute(ref object elementValue, string propertyName, object serializerObject, Attribute[] customAttributes);\n        void DeserializeRoot(object serializerObject, object target, Attribute[] customAttributes);\n    }\n\n    \n    public interface IMVCSerializer\n    {\n        void RegisterTypeSerializer(Type type, IMVCTypeSerializer serializer);\n        string SerializeObject(object obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeObject(IInterface obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeRecord(object record, Type recordType, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeCollection(object list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeCollection(IInterface list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n        string SerializeDataSet(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null);\n        string SerializeDataSetRecord(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null);\n        string SerializeArrayOfRecord(ref object arrayContainer, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null);\n\n        void DeserializeObject(string serializedObject, object target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\");\n        void DeserializeObject(string serializedObject, IInterface target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null);\n        void DeserializeCollection(string serializedList, object list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\");\n        void DeserializeCollection(string serializedList, IInterface list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null);\n        void DeserializeDataSet(string serializedDataSet, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs);\n        void DeserializeDataSetRecord(string serializedDataSetRecord, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs);\n    }\n\n    \n    public interface IInterface { }\n\n    \n    public class MVCURLEncodedSerializer : IMVCSerializer\n    {\n        \n\n        protected void RaiseNotImplemented()\n        {\n            throw new NotImplementedException(\"Not Implemented\");\n        }\n\n        protected Dictionary<string, string> ParseUrlEncodedString(string serializedObject)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            var pairs = serializedObject.Split('&');\n            foreach (var pair in pairs)\n            {\n                var keyValue = pair.Split('=');\n                if (keyValue.Length == 2)\n                {\n                    var key = keyValue[0];\n                    var value = HttpUtility.UrlDecode(keyValue[1]);\n                    dict[key] = value;\n                }\n            }\n            return dict;\n        }\n\n        protected object ConvertRawValue(string rawData, Type targetType)\n        {\n            \n            if (targetType == typeof(string))\n            {\n                return HttpUtility.UrlDecode(rawData);\n            }\n            \n            if (targetType == typeof(int) || targetType == typeof(int?))\n            {\n                if (int.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out int intVal))\n                    return intVal;\n                return null;\n            }\n            if (targetType == typeof(long) || targetType == typeof(long?))\n            {\n                if (long.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out long longVal))\n                    return longVal;\n                return null;\n            }\n            if (targetType == typeof(double) || targetType == typeof(double?))\n            {\n                if (double.TryParse(rawData, NumberStyles.Any, CultureInfo.InvariantCulture, out double doubleVal))\n                    return doubleVal;\n                return null;\n            }\n            if (targetType == typeof(bool) || targetType == typeof(bool?))\n            {\n                if (bool.TryParse(rawData, out bool boolVal))\n                    return boolVal;\n                if (rawData == \"0\") return false;\n                if (rawData == \"1\") return true;\n                return null;\n            }\n            if (targetType == typeof(DateTime) || targetType == typeof(DateTime?))\n            {\n                if (DateTime.TryParse(rawData, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dt))\n                    return dt;\n                return null;\n            }\n            if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(Nullable<>))\n            {\n                Type underlyingType = Nullable.GetUnderlyingType(targetType);\n                return ConvertRawValue(rawData, underlyingType);\n            }\n            throw new EMVCDeserializationException($\"Unsupported type for conversion: {targetType}\");\n        }\n\n        public void DataValueToAttribute(object target, MemberInfo member, string rawData, string name, out object value,\n            TMVCSerializationType serializationType, IList<string> ignoredAttributes, Attribute[] customAttributes)\n        {\n            value = null;\n            Type memberType = null;\n            if (member is PropertyInfo prop)\n            {\n                memberType = prop.PropertyType;\n            }\n            else if (member is FieldInfo fld)\n            {\n                memberType = fld.FieldType;\n            }\n            else\n            {\n                throw new Exception(\"Unsupported member type\");\n            }\n\n            try\n            {\n                value = ConvertRawValue(rawData, memberType);\n            }\n            catch (Exception ex)\n            {\n                throw new EMVCDeserializationException($\"Error converting value '{rawData}' for member '{name}': {ex.Message}\");\n            }\n        }\n\n        public void DataValueToAttribute(object target, MemberInfo member, string[] rawDataArray, string name, out object value,\n            TMVCSerializationType serializationType, IList<string> ignoredAttributes, Attribute[] customAttributes)\n        {\n            value = rawDataArray;\n        }\n\n\n        public void RegisterTypeSerializer(Type type, IMVCTypeSerializer serializer)\n        {\n            RaiseNotImplemented();\n        }\n\n        public string SerializeObject(object obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeObject(IInterface obj, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeRecord(object record, Type recordType, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeCollection(object list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeCollection(IInterface list, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeDataSet(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeDataSetRecord(System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs, Action datasetSerializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public string SerializeArrayOfRecord(ref object arrayContainer, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, Action serializationAction = null)\n        {\n            RaiseNotImplemented();\n            return string.Empty;\n        }\n\n        public void DeserializeObject(string serializedObject, object target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\")\n        {\n            if (string.IsNullOrEmpty(serializedObject))\n                throw new EMVCException(400, \"Invalid body\");\n\n            if (target == null)\n                return;\n\n            var dict = ParseUrlEncodedString(serializedObject);\n\n            URLEncodedStringToObject(dict, target, GetSerializationType(target, serializationType), ignoredAttributes);\n        }\n\n        public void DeserializeObject(string serializedObject, IInterface target, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeCollection(string serializedList, object list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null, string rootNode = \"\")\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeCollection(string serializedList, IInterface list, Type clazz, TMVCSerializationType serializationType = TMVCSerializationType.Default, IList<string> ignoredAttributes = null)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeDataSet(string serializedDataSet, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void DeserializeDataSetRecord(string serializedDataSetRecord, System.Data.DataSet dataSet, IList<string> ignoredFields = null, TMVCNameCase nameCase = TMVCNameCase.AsIs)\n        {\n            RaiseNotImplemented();\n        }\n\n        public void URLEncodedStringToObject(Dictionary<string, string> data, object target, TMVCSerializationType serializationType, IList<string> ignoredAttributes)\n        {\n            if (target == null)\n                return;\n\n            if (target is Newtonsoft.Json.Linq.JObject jObj)\n            {\n                foreach (var kvp in data)\n                {\n                    if (jObj[kvp.Key] == null)\n                    {\n                        jObj[kvp.Key] = kvp.Value;\n                    }\n                    else\n                    {\n                        var current = jObj[kvp.Key];\n                        jObj[kvp.Key] = new Newtonsoft.Json.Linq.JArray(current, kvp.Value);\n                    }\n                }\n                return;\n            }\n\n            Type targetType = target.GetType();\n            var props = targetType.GetProperties(BindingFlags.Public | BindingFlags.Instance);\n            foreach (var prop in props)\n            {\n                if (!prop.CanWrite) continue;\n                if (ignoredAttributes != null && ignoredAttributes.Contains(prop.Name)) continue;\n\n                string key = prop.Name;\n                if (data.ContainsKey(key))\n                {\n                    string rawData = data[key];\n                    object convertedValue;\n                    try\n                    {\n                        DataValueToAttribute(target, prop, rawData, key, out convertedValue, serializationType, ignoredAttributes, prop.GetCustomAttributes().ToArray());\n                        if (convertedValue != null)\n                        {\n                            prop.SetValue(target, convertedValue);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new EMVCException(400, $\"Invalid type conversion for property '{key}': {ex.Message}\");\n                    }\n                }\n            }\n\n            var fields = targetType.GetFields(BindingFlags.Public | BindingFlags.Instance);\n            foreach (var field in fields)\n            {\n                if (ignoredAttributes != null && ignoredAttributes.Contains(field.Name)) continue;\n                string key = field.Name;\n                if (data.ContainsKey(key))\n                {\n                    string rawData = data[key];\n                    object convertedValue;\n                    try\n                    {\n                        DataValueToAttribute(target, field, rawData, key, out convertedValue, serializationType, ignoredAttributes, field.GetCustomAttributes().ToArray());\n                        if (convertedValue != null)\n                        {\n                            field.SetValue(target, convertedValue);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        throw new EMVCException(400, $\"Invalid type conversion for field '{key}': {ex.Message}\");\n                    }\n                }\n            }\n        }\n\n        protected TMVCSerializationType GetSerializationType(object target, TMVCSerializationType type)\n        {\n            return type;\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n//\n// ***************************************************************************\n//\n// Sempare Template Engine\n//\n// Copyright (c) 2019-2023 Conrad Vermeulen and Sempare Limited\n//\n// https://github.com/sempare/sempare-delphi-template-engine\n//\n// NOTE: The Sempare Template Engine is available under GPL or commercial license.\n//\n// Free as in speech, NOT Free as in beer.\n//\n// ***************************************************************************\n//\n// This adaptor is licensed under the Apache License.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit CustomSempareHelpersU;\n\ninterface\n\n// For more information on custom functions in the Sempare Template Engine,\n// see https://github.com/sempare/sempare-delphi-template-engine/blob/main/docs/custom-functions.md\n\ntype\n  TMySempareHelpers = class sealed\n  public\n    class function MyHelper1(const Value: string): string; static;\n    class function MyHelper2(const Value: string): string; static;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TMySempareHelpers }\n\nclass function TMySempareHelpers.MyHelper1(const Value: string): string;\nbegin\n  Result := Value + ' (I''m The MyHelper1)';\nend;\n\nclass function TMySempareHelpers.MyHelper2(const Value: string): string;\nbegin\n  Result := Value + ' (I''m The MyHelper2)';\nend;\n\nend.", "output": "using System;\n\nnamespace CustomSempareHelpersU\n{\n    public static class MySempareHelpers\n    {\n        public static string MyHelper1(string value)\n        {\n            return value + \" (I'm The MyHelper1)\";\n        }\n\n        public static string MyHelper2(string value)\n        {\n            return value + \" (I'm The MyHelper2)\";\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2017 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MessagingExtensionsTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  MVCFramework.RESTClient,\n  LiveServerTestU;\n{\n  type\n  TMessagingExtensionsTestCase = class(TBaseServerTest)\n  published\n  procedure TestSubscribeOnATopic;\n  procedure TestMultipleSubscribeOnSameTopic;\n  procedure TestMultipleSubscribeAndUnsubscribe;\n  procedure TestMultipleSubscribeAndUnsubscribeHARD;\n  procedure TestSubscribeAndReceive;\n  end;\n\n}\n\nimplementation\n\n{$WARN SYMBOL_DEPRECATED OFF}\n\nuses\n  System.SysUtils,\n\n  {$IF CompilerVersion < 27}\n\n  Data.DBXJSON,\n\n  {$ELSE}\n\n  System.JSON,\n\n  {$ENDIF}\n\n  System.Classes,\n  MVCFramework.Logger, MVCFramework.Commons, Winapi.Windows;\n\n{ TMessagingExtensionsTestCase }\n{\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeAndUnsubscribe;\n  var\n  res: IRESTResponse;\n  x: string;\n  begin\n  RESTClient.ReadTimeout(- 1);\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test01', x);\n\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010']);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test01;/queue/test010', x);\n\n  res := RESTClient.doDELETE('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals('/queue/test010', x);\n\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeAndUnsubscribeHARD;\n  var\n  res: IRESTResponse;\n  x: string;\n  begin\n  RESTClient.ReadTimeout(-1);\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test01']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test0101']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test01010']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test010101']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue', ['test0101010']);\n\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals\n  ('/queue/test01;/queue/test010;/queue/test0101;/queue/test01010;/queue/test010101;/queue/test0101010',\n  x);\n\n  res := RESTClient.doDELETE('/messages/subscriptions/queue', ['test010']);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shod not return an error\n  res := RESTClient.doGET('/messages/subscriptions', []);\n  x := Trim(res.BodyAsString);\n  CheckEquals\n  ('/queue/test01;/queue/test0101;/queue/test01010;/queue/test010101;/queue/test0101010', x);\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestMultipleSubscribeOnSameTopic;\n  var\n  res: IRESTResponse;\n  begin\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  // server shoud not return an error\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestSubscribeAndReceive;\n  var\n  res: IRESTResponse;\n  messages: TJSONArray;\n  sid: string;\n  RMessageCount: Integer;\n  I: Integer;\n  o: TJSONObject;\n  J: Integer;\n  LUnique: string;\n  const\n  MSG_COUNT = 10;\n  begin\n  LUnique := GetTickCount.ToString;\n\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-' + LUnique]);\n  RESTClient.doPOST('/messages', ['subscriptions', 'queue', 'test01']);\n  RESTClient.doPOST('/messages', ['subscriptions', 'queue', 'test02']);\n  RESTClient.ReadTimeout(- 1);\n  sid := RESTClient.SessionID;\n  TThread.CreateAnonymousThread(\n  procedure\n  var\n  RESTC: TRESTClient;\n  I: Integer;\n  begin\n  TThread.Sleep(1000);\n  RESTC := TRESTClient.Create(TEST_SERVER_ADDRESS, 9999);\n  try\n  RESTC.doPOST('/messages/clients', ['my-other-unique-' + LUnique]);\n  RESTC.ReadTimeout(60 * 1000 * 30);\n  RESTC.doGET('/login', ['guest']);\n  for I := 1 to MSG_COUNT do\n  begin\n  RESTC.doPOST('/messages/queue/test02', [], TJSONObject.Create(TJSONPair.Create('hello',\n  TJSONNumber.Create(I))));\n  RESTC.doPOST('/messages/queue/test01', [], TJSONObject.Create(TJSONPair.Create('hello',\n  TJSONNumber.Create(I))));\n  end;\n  finally\n  RESTC.Free;\n  end;\n  end).Start;\n\n  RMessageCount := 0;\n  for J := 1 to MSG_COUNT * 2 do\n  begin\n  res := RESTClient.doGET('/messages', []);\n  if res.ResponseCode = HTTP_STATUS.OK then\n  begin\n  CheckIs(res.BodyAsJsonObject.Get('_timeout').JsonValue, TJSONFalse);\n  CheckNotNull(res.BodyAsJsonObject.Get('_timestamp'), '_timestamp is not set');\n  CheckNotNull(res.BodyAsJsonObject.Get('messages'), 'messages is not set');\n  CheckIs(res.BodyAsJsonObject.Get('messages').JsonValue, TJSONArray,\n  'Messages is not a TJSONArray');\n  messages := res.BodyAsJsonObject.Get('messages').JsonValue as TJSONArray;\n  if messages.Size > 0 then\n  for I := 0 to messages.Size - 1 do\n  begin\n  o := messages.Get(I) as TJSONObject;\n  logw(o.Get('message').ToString);\n  end;\n  RMessageCount := RMessageCount + messages.Size;\n  end;\n  if res.ResponseCode = HTTP_STATUS.RequestTimeout then // receive timeout\n  break;\n  end;\n  CheckEquals(MSG_COUNT * 2, RMessageCount, 'message count');\n  res := RESTClient.doGET('/messages', []);\n  CheckIs(res.BodyAsJsonObject.Get('_timeout').JsonValue, TJSONTrue);\n  DoLogout;\n  end;\n\n  procedure TMessagingExtensionsTestCase.TestSubscribeOnATopic;\n  var\n  res: IRESTResponse;\n  begin\n  DoLoginWith('guest');\n  RESTClient.doPOST('/messages/clients', ['my-unique-id']);\n  res := RESTClient.doPOST('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  res := RESTClient.doDELETE('/messages/subscriptions/queue/test01', []);\n  CheckEquals(HTTP_STATUS.OK, res.ResponseCode, res.ResponseText);\n  DoLogout;\n  end;\n}\ninitialization\n\n{$IFDEF USE_MESSAGING}\n\n  TDUnitX.RegisterTestFixture(TMessagingExtensionsTestCase);\n\n{$ENDIF}\n\nfinalization\n\nend.", "output": "using NUnit.Framework;\nusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json.Linq;\n\nnamespace MessagingExtensionsTests\n{\n    [TestFixture]\n    public class MessagingExtensionsTestCase\n    {\n        private HttpClient _client;\n        private const string BaseUrl = \"http://localhost:8080\";\n\n        [SetUp]\n        public void Setup()\n        {\n            \n            _client = new HttpClient();\n            _client.Timeout = TimeSpan.FromMinutes(30);\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            _client?.Dispose();\n        }\n\n        #region Helper Methods\n\n        private async Task DoLoginAsync(string username)\n        {\n            \n            var response = await _client.PostAsync($\"{BaseUrl}/login/{username}\", null);\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Login failed\");\n        }\n\n        private async Task DoLogoutAsync()\n        {\n            var response = await _client.PostAsync($\"{BaseUrl}/logout\", null);\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Logout failed\");\n        }\n\n        \n        private async Task<HttpResponseMessage> PostAsync(string url)\n        {\n            return await _client.PostAsync(url, null);\n        }\n\n        #endregion\n\n        #region Tests\n\n        [Test]\n        public async Task TestSubscribeOnATopic()\n        {\n            await DoLoginAsync(\"guest\");\n\n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription failed\");\n\n            \n            response = await _client.DeleteAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Unsubscription failed\");\n\n            await DoLogoutAsync();\n        }\n\n        [Test]\n        public async Task TestMultipleSubscribeOnSameTopic()\n        {\n            \n            await DoLoginAsync(\"guest\");\n\n           \n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"First subscription failed\");\n\n            response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Second subscription failed\");\n\n            \n\n            await DoLogoutAsync();\n        }\n\n        [Test]\n        public async Task TestMultipleSubscribeAndUnsubscribe()\n        {\n            await DoLoginAsync(\"guest\");\n\n            HttpResponseMessage response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription test01 failed\");\n\n            response = await PostAsync($\"{BaseUrl}/messages/subscriptions/queue/test010\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Subscription test010 failed\");\n\n            response = await _client.GetAsync($\"{BaseUrl}/messages/subscriptions\");\n            string subs = (await response.Content.ReadAsStringAsync()).Trim();\n            Assert.AreEqual(\"/queue/test01;/queue/test010\", subs, \"Subscription list incorrect\");\n\n\n            response = await _client.DeleteAsync($\"{BaseUrl}/messages/subscriptions/queue/test01\");\n            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, \"Unsubscription test01 failed\");\n\n            response = await _client.GetAsync($\"{BaseUrl}/messages/subscriptions\");\n            subs = (await response.Content.ReadAsStringAsync()).Trim();\n            Assert.AreEqual(\"/queue/test010\", subs, \"Subscription list after unsubscription incorrect\");\n\n            await DoLogoutAsync();\n        }\n\n        \n\n        #endregion\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.NewUnitWizardEx;\n\ninterface\n\nuses\n  ToolsApi,\n  VCL.Graphics,\n  PlatformAPI;\n\ntype\n  TDMVCNewUnitWizard = class\n  public\n    class procedure RegisterDMVCNewUnitWizard(const APersonality: string);\n  end;\n\nimplementation\n\n{$I ..\\sources\\dmvcframework.inc}\n\nuses\n  DMVC.Expert.Forms.NewUnitWizard,\n  DMVC.Expert.CodeGen.NewControllerUnit,\n  VCL.Controls,\n  VCL.Forms,\n  WinApi.Windows,\n  ExpertsRepository, JsonDataObjects;\n\nresourcestring\n  sNewDMVCUnitCaption = 'DelphiMVCFramework Controller';\n  sNewDMVCProjectHint = 'Create New DelphiMVCFramework Controller Unit';\n\nclass procedure TDMVCNewUnitWizard.RegisterDMVCNewUnitWizard(const APersonality: string);\nbegin\n  RegisterPackageWizard(TExpertsRepositoryProjectWizardWithProc.Create(APersonality, sNewDMVCProjectHint,\n    sNewDMVCUnitCaption, 'DMVC.Wizard.NewUnitWizard', // do not localize\n    'DelphiMVCFramework', 'DelphiMVCFramework Team - https://github.com/danieleteti/delphimvcframework', // do not localize\n    procedure\n    var\n      WizardForm: TfrmDMVCNewUnit;\n      ModuleServices: IOTAModuleServices;\n      Project: IOTAProject;\n      ControllerUnit: IOTAModule;\n      lJSON: TJSONObject;\n    begin\n      WizardForm := TfrmDMVCNewUnit.Create(Application);\n      try\n        if WizardForm.ShowModal = mrOk then\n        begin\n          lJSON := WizardForm.GetConfigModel;\n          ModuleServices := (BorlandIDEServices as IOTAModuleServices);\n          Project := GetActiveProject;\n          ControllerUnit := ModuleServices.CreateModule(\n            TNewControllerUnitEx.Create(lJSON, APersonality));\n          if Project <> nil then\n          begin\n            Project.AddFile(ControllerUnit.FileName, true);\n          end;\n        end;\n      finally\n        WizardForm.Free;\n      end;\n    end,\n    function: Cardinal\n    begin\n      Result := LoadIcon(HInstance, 'DMVCNewUnitIcon');\n    end, TArray<string>.Create(cWin32Platform, cWin64Platform\n    {$IF Defined(TOKYOORBETTER)}\n    , cLinux64Platform\n    {$ENDIF}\n    ), nil));\nend;\n\nend.", "output": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Newtonsoft.Json.Linq;\n\nnamespace DMVCExpertNewUnitWizardEx\n{\n\n    public interface IOTAModuleServices\n    {\n        IOTAModule CreateModule(TNewControllerUnitEx unit);\n    }\n    \n    public interface IOTAModule\n    {\n        string FileName { get; }\n    }\n    \n    public interface IOTAProject\n    {\n        void AddFile(string fileName, bool addToProject);\n    }\n    \n    public static class IDEHelper\n    {\n        public static IOTAProject GetActiveProject() => null; \n    }\n    \n    public static class BorlandIDEServices\n    {\n        public static object Instance { get; } = null;\n    }\n    \n    public class TNewControllerUnitEx\n    {\n        public TNewControllerUnitEx(JObject configModel, string personality)\n        {\n            // Initialization logic.\n        }\n        \n        public string FileName { get; } = \"NewControllerUnit.cs\";\n    }\n    \n    public class TfrmDMVCNewUnit : Form\n    {\n        public new DialogResult ShowDialog()\n        {\n            return DialogResult.OK;\n        }\n        \n        public JObject GetConfigModel()\n        {\n            return new JObject();\n        }\n    }\n    \n    public class ExpertsRepositoryProjectWizardWithProc\n    {\n        public ExpertsRepositoryProjectWizardWithProc(\n            string personality,\n            string projectHint,\n            string unitCaption,\n            string wizardId,\n            string vendorName,\n            string vendorDescription,\n            Action executeProc,\n            Func<IntPtr> getIconFunc,\n            string[] platforms,\n            object additionalParam)\n        {\n            // Store parameters as needed.\n        }\n        \n        public static void Register(ExpertsRepositoryProjectWizardWithProc wizard)\n        {\n            \n            Console.WriteLine(\"DMVC New Unit Wizard registered.\");\n        }\n    }\n    \n    public static class IconLoader\n    {\n        public static IntPtr LoadIcon(IntPtr instance, string iconName)\n        {\n            return IntPtr.Zero;\n        }\n    }\n    \n    public static class TDMVCNewUnitWizard\n    {\n        private const string sNewDMVCUnitCaption = \"DelphiMVCFramework Controller\";\n        private const string sNewDMVCProjectHint = \"Create New DelphiMVCFramework Controller Unit\";\n        \n        private static readonly string[] Platforms = { cWin32Platform, cWin64Platform  };\n        private const string cWin32Platform = \"Win32\";\n        private const string cWin64Platform = \"Win64\";\n        \n        private static IntPtr HInstance => IntPtr.Zero; \n        \n        \n        public static void RegisterDMVCNewUnitWizard(string personality)\n        {\n            ExpertsRepositoryProjectWizardWithProc.Register(\n                new ExpertsRepositoryProjectWizardWithProc(\n                    personality,\n                    sNewDMVCProjectHint,\n                    sNewDMVCUnitCaption,\n                    \"DMVC.Wizard.NewUnitWizard\", \n                    \"DelphiMVCFramework\",\n                    \"DelphiMVCFramework Team - https://github.com/danieleteti/delphimvcframework\",\n                    () =>\n                    {\n                        using (var wizardForm = new TfrmDMVCNewUnit())\n                        {\n                            if (wizardForm.ShowDialog() == DialogResult.OK)\n                            {\n                                JObject json = wizardForm.GetConfigModel();\n                                IOTAModuleServices moduleServices = BorlandIDEServices.Instance as IOTAModuleServices;\n                                IOTAProject project = IDEHelper.GetActiveProject();\n                                IOTAModule controllerUnit = moduleServices.CreateModule(new TNewControllerUnitEx(json, personality));\n                                if (project != null)\n                                {\n                                    project.AddFile(controllerUnit.FileName, true);\n                                }\n                            }\n                        }\n                    },\n                    () =>\n                    {\n                        return IconLoader.LoadIcon(HInstance, \"DMVCNewUnitIcon\");\n                    },\n                    Platforms,\n                    null\n                )\n            );\n        }\n    }\n}"}
{"input": "unit Horse.Provider.Console;\n\ninterface\n\n{$IF NOT DEFINED(FPC)}\nuses\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Provider.IOHandleSSL.Contract,\n  Horse.Provider.IOHandleSSL,\n  IdHTTPWebBrokerBridge,\n  IdSSLOpenSSL,\n  IdSSL,\n  IdContext,\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FEvent: TEvent;\n    class var FMaxConnections: Integer;\n    class var FListenQueue: Integer;\n    class var FKeepConnectionAlive: Boolean;\n    class var FIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\n    class var FHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\n    class function GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultEvent: TEvent;\n    class function HTTPWebBrokerIsNil: Boolean;\n    class procedure OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: String; var VUsername, VPassword: String; var VHandled: Boolean);\n    class procedure OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetMaxConnections(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL); static;\n    class procedure SetHost(const AValue: string); static;\n    class procedure SetKeepConnectionAlive(const AValue: Boolean); static;\n    class function GetListenQueue: Integer; static;\n    class function GetMaxConnections: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetIOHandleSSL: IHorseProviderIOHandleSSL; static;\n    class function GetHost: string; static;\n    class function GetKeepConnectionAlive: Boolean; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n    class procedure InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property MaxConnections: Integer read GetMaxConnections write SetMaxConnections;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class property KeepConnectionAlive: Boolean read GetKeepConnectionAlive write SetKeepConnectionAlive;\n    class property IOHandleSSL: IHorseProviderIOHandleSSL read GetIOHandleSSL write SetIOHandleSSL;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n    class destructor UnInitialize;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF NOT DEFINED(FPC)}\nuses\n  Web.WebReq,\n  Horse.WebModule,\n  IdCustomTCPServer;\n\nclass function THorseProvider.GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\nbegin\n  if HTTPWebBrokerIsNil then\n  begin\n    FIdHTTPWebBrokerBridge := TIdHTTPWebBrokerBridge.Create(nil);\n    FIdHTTPWebBrokerBridge.OnParseAuthentication := OnAuthentication;\n    FIdHTTPWebBrokerBridge.OnQuerySSLPort := OnQuerySSLPort;\n  end;\n  Result := FIdHTTPWebBrokerBridge;\nend;\n\nclass function THorseProvider.HTTPWebBrokerIsNil: Boolean;\nbegin\n  Result := FIdHTTPWebBrokerBridge = nil;\nend;\n\nclass procedure THorseProvider.OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\nbegin\n  VUseSSL := (FHorseProviderIOHandleSSL <> nil) and (FHorseProviderIOHandleSSL.Active);\nend;\n\nclass function THorseProvider.GetDefaultEvent: TEvent;\nbegin\n  if FEvent = nil then\n    FEvent := TEvent.Create;\n  Result := FEvent;\nend;\n\nclass function THorseProvider.GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  if FHorseProviderIOHandleSSL = nil then\n    FHorseProviderIOHandleSSL := THorseProviderIOHandleSSL.New;\n  Result := FHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetKeepConnectionAlive: Boolean;\nbegin\n  Result := FKeepConnectionAlive;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.GetIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  Result := GetDefaultHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetMaxConnections: Integer;\nbegin\n  Result := FMaxConnections;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\nvar\n  LIOHandleSSL: TIdServerIOHandlerSSLOpenSSL;\nbegin\n  LIOHandleSSL := TIdServerIOHandlerSSLOpenSSL.Create(AIdHTTPWebBrokerBridge);\n  LIOHandleSSL.SSLOptions.CertFile := AHorseProviderIOHandleSSL.CertFile;\n  LIOHandleSSL.SSLOptions.RootCertFile := AHorseProviderIOHandleSSL.RootCertFile;\n  LIOHandleSSL.SSLOptions.KeyFile := AHorseProviderIOHandleSSL.KeyFile;\n  LIOHandleSSL.SSLOptions.Method := AHorseProviderIOHandleSSL.Method;\n  LIOHandleSSL.SSLOptions.SSLVersions := AHorseProviderIOHandleSSL.SSLVersions;\n  LIOHandleSSL.SSLOptions.CipherList := AHorseProviderIOHandleSSL.CipherList;\n  LIOHandleSSL.SSLOptions.DHParamsFile := AHorseProviderIOHandleSSL.DHParamsFile;\n  LIOHandleSSL.OnGetPassword := AHorseProviderIOHandleSSL.OnGetPassword;\n  AIdHTTPWebBrokerBridge.IOHandler := LIOHandleSSL;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LAttach: string;\n  LIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n\n  LIdHTTPWebBrokerBridge := GetDefaultHTTPWebBroker;\n  WebRequestHandler.WebModuleClass := WebModuleClass;\n  try\n    if FMaxConnections > 0 then\n    begin\n      WebRequestHandler.MaxConnections := FMaxConnections;\n      GetDefaultHTTPWebBroker.MaxConnections := FMaxConnections;\n    end;\n\n    if FListenQueue = 0 then\n      FListenQueue := IdListenQueueDefault;\n\n    if FHorseProviderIOHandleSSL <> nil then\n      InitServerIOHandlerSSLOpenSSL(LIdHTTPWebBrokerBridge, GetDefaultHorseProviderIOHandleSSL);\n    LIdHTTPWebBrokerBridge.ListenQueue := FListenQueue;\n\n    LIdHTTPWebBrokerBridge.Bindings.Clear;\n    if FHost <> GetDefaultHost then\n    begin\n      LIdHTTPWebBrokerBridge.Bindings.Add;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].IP := FHost;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].Port := FPort;\n    end;\n\n    LIdHTTPWebBrokerBridge.KeepAlive := FKeepConnectionAlive;\n    LIdHTTPWebBrokerBridge.DefaultPort := FPort;\n    LIdHTTPWebBrokerBridge.Active := True;\n    LIdHTTPWebBrokerBridge.StartListening;\n    FRunning := True;\n    DoOnListen;\n\n    if IsConsole then\n    begin\n      while FRunning do\n        GetDefaultEvent.WaitFor();\n    end\n  except\n    on E: Exception do\n    begin\n      if IsConsole then\n      begin\n        Writeln(E.ClassName, ': ', E.Message);\n        Read(LAttach);\n      end\n      else\n{$IF CompilerVersion >= 32.0}\n        raise AcquireExceptionObject;\n{$ELSE}\n        raise;\n{$ENDIF}\n    end;\n  end;\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPWebBrokerIsNil then\n  begin\n    GetDefaultHTTPWebBroker.StopListening;\n    GetDefaultHTTPWebBroker.Active := False;\n    DoOnStopListen;\n    FRunning := False;\n    if FEvent <> nil then\n      GetDefaultEvent.SetEvent;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: String; var VUsername, VPassword: String; var VHandled: Boolean);\nbegin\n  VHandled := True;\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue.Trim;\nend;\n\nclass procedure THorseProvider.SetKeepConnectionAlive(const AValue: Boolean);\nbegin\n  FKeepConnectionAlive := AValue;\nend;\n\nclass procedure THorseProvider.SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL);\nbegin\n  FHorseProviderIOHandleSSL := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetMaxConnections(const AValue: Integer);\nbegin\n  FMaxConnections := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FIdHTTPWebBrokerBridge);\n  if FEvent <> nil then\n    FreeAndNil(FEvent);\nend;\n\ninitialization\n  THorseProvider.SetKeepConnectionAlive(True);\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Net;\nusing System.Linq;\n\nnamespace Horse.Provider.Console\n{\n    \n    public class IdHTTPWebBrokerBridge\n    {\n        public int MaxConnections { get; set; }\n        public int ListenQueue { get; set; }\n        public bool KeepAlive { get; set; }\n        public int DefaultPort { get; set; }\n        public bool Active { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n\n        \n        public Action<string, ref string, ref string, ref bool> OnParseAuthentication { get; set; }\n        public Action<ushort, ref bool> OnQuerySSLPort { get; set; }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine(\"Server started listening on port \" + DefaultPort);\n        }\n\n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"Server stopped listening\");\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        string Method { get; }\n        string SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    \n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public string Method => \"TLSv1.2\";\n        public string SSLVersions => \"TLSv1.2\";\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    \n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n        public class HorseCore\n    {\n        private static HorseCore _instance;\n        public static HorseCore GetInstance() => _instance ?? (_instance = new HorseCore());\n    }\n\n        public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    \n\n    public class HorseProvider : HorseProviderAbstract\n    {\n        \n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static EventWaitHandle _event;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static IdHTTPWebBrokerBridge _idHTTPWebBrokerBridge;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => GetMaxConnections(); set => SetMaxConnections(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n        public static bool KeepConnectionAlive { get => GetKeepConnectionAlive(); set => SetKeepConnectionAlive(value); }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetIOHandleSSL(); set => SetIOHandleSSL(value); }\n\n        \n        public override void Listen() => InternalListen();\n        public override void StopListen() => InternalStopListen();\n\n        \n        public static void Listen(int aPort, string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(aCallbackListen);\n            SetOnStopListen(aCallbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, aHost, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(aPort, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        \n        private static IdHTTPWebBrokerBridge GetDefaultHTTPWebBroker()\n        {\n            if (_idHTTPWebBrokerBridge == null)\n            {\n                _idHTTPWebBrokerBridge = new IdHTTPWebBrokerBridge();\n                \n            }\n            return _idHTTPWebBrokerBridge;\n        }\n\n        private static bool HTTPWebBrokerIsNil() => _idHTTPWebBrokerBridge == null;\n\n        private static EventWaitHandle GetDefaultEvent()\n        {\n            if (_event == null)\n                _event = new EventWaitHandle(false, EventResetMode.AutoReset);\n            return _event;\n        }\n\n        private static IHorseProviderIOHandleSSL GetDefaultHorseProviderIOHandleSSL()\n        {\n            if (_horseProviderIOHandleSSL == null)\n                _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New;\n            return _horseProviderIOHandleSSL;\n        }\n\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetHost() => _host;\n        private static bool GetKeepConnectionAlive() => _keepConnectionAlive;\n        private static IHorseProviderIOHandleSSL GetIOHandleSSL() => GetDefaultHorseProviderIOHandleSSL();\n        private static int GetListenQueue() => _listenQueue;\n        private static int GetMaxConnections() => _maxConnections;\n        private static int GetPort() => _port;\n\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static void SetMaxConnections(int value) => _maxConnections = value;\n        private static void SetPort(int value) => _port = value;\n        private static void SetIOHandleSSL(IHorseProviderIOHandleSSL value) => _horseProviderIOHandleSSL = value;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static void SetKeepConnectionAlive(bool value) => _keepConnectionAlive = value;\n\n        \n        private static Action _onListen;\n        private static Action _onStopListen;\n        public static void SetOnListen(Action callback) => _onListen = callback;\n        public static void SetOnStopListen(Action callback) => _onStopListen = callback;\n\n        private static void DoOnListen()\n        {\n            _onListen?.Invoke();\n        }\n\n        private static void DoOnStopListen()\n        {\n            _onStopListen?.Invoke();\n        }\n\n        \n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (GetDefaultHorseProviderIOHandleSSL() != null) && GetDefaultHorseProviderIOHandleSSL().Active;\n        }\n\n        \n        private static void OnAuthentication(object aContext, string aAuthType, string aAuthData, ref string vUsername, ref string vPassword, ref bool vHandled)\n        {\n            vHandled = true;\n        }\n\n        \n        private static void InitServerIOHandlerSSLOpenSSL(IdHTTPWebBrokerBridge bridge, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with certificate: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var bridge = GetDefaultHTTPWebBroker();\n\n            \n\n            try\n            {\n                if (_maxConnections > 0)\n                {\n                    WebRequestHandler.MaxConnections = _maxConnections;\n                    bridge.MaxConnections = _maxConnections;\n                }\n\n                if (_listenQueue == 0)\n                    _listenQueue = HorseConstants.IdListenQueueDefault;\n\n                if (_horseProviderIOHandleSSL != null)\n                    InitServerIOHandlerSSLOpenSSL(bridge, GetDefaultHorseProviderIOHandleSSL());\n\n                bridge.ListenQueue = _listenQueue;\n\n                bridge.Bindings.Clear();\n                if (_host != GetDefaultHost())\n                {\n                    bridge.Bindings.Add(new Binding { IP = _host, Port = _port });\n                }\n\n                bridge.KeepAlive = _keepConnectionAlive;\n                bridge.DefaultPort = _port;\n                bridge.Active = true;\n                bridge.StartListening();\n                _running = true;\n                DoOnListen();\n\n                if (IsConsole())\n                {\n                    while (_running)\n                    {\n                        GetDefaultEvent().WaitOne();\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                if (IsConsole())\n                {\n                    Console.WriteLine($\"{ex.GetType().Name}: {ex.Message}\");\n                    Console.ReadLine();\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPWebBrokerIsNil())\n            {\n                GetDefaultHTTPWebBroker().StopListening();\n                GetDefaultHTTPWebBroker().Active = false;\n                DoOnStopListen();\n                _running = false;\n                if (_event != null)\n                    GetDefaultEvent().Set();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static new void StopListen() => InternalStopListen();\n        public static new void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(aCallbackListen);\n            SetOnStopListen(aCallbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, aHost, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(aPort, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static void Listen(Action aCallbackListen, Action aCallbackStopListen)\n        {\n            Listen(_port, _host, aCallbackListen, aCallbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        public static void UnInitialize()\n        {\n            _idHTTPWebBrokerBridge = null;\n            if (_event != null)\n            {\n                _event.Dispose();\n                _event = null;\n            }\n        }\n\n        \n        private static bool IsConsole()\n        {\n            \n            return Environment.UserInteractive && Console.WindowHeight > 0;\n        }\n    }\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n    }\n}"}
{"input": "unit Tests.Api.Console;\n\ninterface\n\nuses\n  DUnitX.TestFramework, System.JSON, RESTRequest4D.Request, System.Classes,\n  Controllers.Api, Horse, Horse.Jhonson, SysUtils;\n\ntype\n  [TestFixture]\n  TApiTest = class(TObject)\n  private\n    FJSONObject: TJSONObject;\n    FJSONArray: TJSONArray;\n\n    procedure CreateApi;\n    procedure StartApiListen;\n    procedure StartApiListenPort;\n    procedure StartApiListenHost;\n    procedure StartApiListens;\n    procedure StartApiPortListens;\n    procedure StopApiListen;\n    procedure StopApi;\n  public\n    [TearDown]\n    procedure TearDown;\n\n    [Test]\n    procedure TestGet;\n    [Test]\n    [TestCase('Test01', 'POST request test')]\n    procedure TestPost(const AValue: string);\n    [Test]\n    [TestCase('Test01', 'PUT request test')]\n    procedure TestPut(const AValue: string);\n    [Test]\n    [TestCase('Test01', '1')]\n    procedure TestDelete(const AValue: string);\n    [Test]\n    procedure TestGStartApiPortListens;\n    [Test]\n    procedure TestCreateApi;\n    [Test]\n    procedure TestToHorse;\n  end;\n\nimplementation\n\n{ TApiTest }\n\nprocedure TApiTest.StartApiListen;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        THorse\n          .Use(Jhonson);\n\n        Controllers.Api.Registry;\n        THorse.MaxConnections := 10;\n        THorse.Listen;\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListenPort;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(9000);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListenHost;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen('0.0.0.0');\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiListens;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(\n          procedure(Horse: THorse)\n          begin\n          end,\n          procedure(Horse: THorse)\n          begin\n          end);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StartApiPortListens;\nbegin\n  if (not THorse.IsRunning) then\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      begin\n        Controllers.Api.Registry;\n        THorse.Listen(9000,\n          procedure(Horse: THorse)\n          begin\n          end,\n          procedure(Horse: THorse)\n          begin\n          end);\n      end).Start;\n  end;\nend;\n\nprocedure TApiTest.StopApiListen;\nbegin\n  THorse.StopListen;\nend;\n\nprocedure TApiTest.StopApi;\nbegin\n  // Warnings have been disabled for this segment as the stop has been depreciated.\n  {$WARNINGS OFF}\n  THorse.StopListen;\n  {$WARNINGS ON}\nend;\n\nprocedure TApiTest.TestGStartApiPortListens;\nbegin\n  StartApiPortListens;\n  StopApi;\nend;\n\nprocedure TApiTest.TestGet;\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListen;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .Get;\n\n  FJSONArray := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONArray;\n  Assert.AreEqual(9000, THorse.Port);\n  Assert.AreEqual('0.0.0.0', THorse.Host);\n  Assert.AreEqual(10, THorse.MaxConnections);\n  Assert.AreEqual(LResponse.StatusCode, 200);\n  Assert.AreEqual(FJSONArray.Count, 3);\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestPost(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListenPort;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .AddBody('{\"value\": \"' + AValue + '\"}')\n    .Post;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 201);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not without correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestPut(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListenHost;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test')\n    .Accept('application/json')\n    .AddBody('{\"value\": \"' + AValue + '\"}')\n    .Put;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 200);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not in the correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.TestDelete(const AValue: string);\nvar\n  LResponse: IResponse;\nbegin\n  StartApiListens;\n  LResponse := TRequest.New.BaseURL('http://localhost:9000/Api/Test/' + AValue)\n    .Accept('application/json')\n    .Delete;\n\n  FJSONObject := TJSONObject.ParseJSONValue(LResponse.Content) as TJSONObject;\n  Assert.AreEqual(LResponse.StatusCode, 200);\n\n  if (not FJSONObject.GetValue('value').Null) then\n    Assert.AreEqual(AValue, FJSONObject.GetValue('value').Value)\n  else\n    Assert.Fail('The return is not in the correct format.');\n  StopApiListen;\nend;\n\nprocedure TApiTest.CreateApi;\nbegin\n  // Warnings have been disabled for this segment as the create has been depreciated.\n  {$WARNINGS OFF}\n  THorse.Create;\n  {$WARNINGS ON}\nend;\n\nprocedure TApiTest.TearDown;\nbegin\n  FreeAndNil(FJSONObject);\n  FreeAndNil(FJSONArray);\nend;\n\nprocedure TApiTest.TestCreateApi;\nbegin\n  Assert.WillRaise(CreateApi, Exception, 'The Horse instance has already been created');\nend;\n\nprocedure TApiTest.TestToHorse;\nbegin\n  Assert.IsNotNull(THorse.ToModule.ToHorse, 'Module instance must not be null');\nend;\n\ninitialization\n  TDUnitX.RegisterTestFixture(TApiTest);\n\nend.", "output": "using NUnit.Framework;\nusing System;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json.Linq;\nusing RESTRequest4D.Request;\nusing Controllers.Api;\nusing Horse;\nusing Horse.Jhonson;\n\nnamespace Tests.Api.Console\n{\n    [TestFixture]\n    public class TApiTest\n    {\n        private JObject FJSONObject;\n        private JArray FJSONArray;\n\n        private void CreateApi()\n        {\n            Horse.Horse.Create();\n        }\n\n        private void StartApiListen()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Horse.Horse.Use(Jhonson.Jhonson);\n                    Controllers.Api.Registry();\n                    Horse.Horse.MaxConnections = 10;\n                    Horse.Horse.Listen();\n                });\n            }\n        }\n\n        private void StartApiListenPort()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(9000);\n                });\n            }\n        }\n\n        private void StartApiListenHost()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(\"0.0.0.0\");\n                });\n            }\n        }\n\n        private void StartApiListens()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(\n                        (horse) => { },\n                        (horse) => { }\n                    );\n                });\n            }\n        }\n\n        private void StartApiPortListens()\n        {\n            if (!Horse.Horse.IsRunning)\n            {\n                Task.Run(() =>\n                {\n                    Controllers.Api.Registry();\n                    Horse.Horse.Listen(9000,\n                        (horse) => { },\n                        (horse) => { }\n                    );\n                });\n            }\n        }\n\n        private void StopApiListen()\n        {\n            Horse.Horse.StopListen();\n        }\n\n        private void StopApi()\n        {\n            Horse.Horse.StopListen();\n        }\n\n        [TearDown]\n        public void TearDown()\n        {\n            FJSONObject?.Dispose();\n            FJSONArray?.Dispose();\n        }\n\n        [Test]\n        public void TestGet()\n        {\n            StartApiListen();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\").Get();\n            FJSONArray = JArray.Parse(response.Content);\n            Assert.AreEqual(9000, Horse.Horse.Port);\n            Assert.AreEqual(\"0.0.0.0\", Horse.Horse.Host);\n            Assert.AreEqual(10, Horse.Horse.MaxConnections);\n            Assert.AreEqual(200, response.StatusCode);\n            Assert.AreEqual(3, FJSONArray.Count);\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"POST request test\")]\n        public void TestPost(string AValue)\n        {\n            StartApiListenPort();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\")\n                .AddBody(\"{\\\"value\\\": \\\"\" + AValue + \"\\\"}\").Post();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(201, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not without correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"PUT request test\")]\n        public void TestPut(string AValue)\n        {\n            StartApiListenHost();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test\").Accept(\"application/json\")\n                .AddBody(\"{\\\"value\\\": \\\"\" + AValue + \"\\\"}\").Put();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(200, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not in the correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        [TestCase(\"1\")]\n        public void TestDelete(string AValue)\n        {\n            StartApiListens();\n            var response = RestRequest.New().BaseURL(\"http://localhost:9000/Api/Test/\" + AValue).Accept(\"application/json\").Delete();\n            FJSONObject = JObject.Parse(response.Content);\n            Assert.AreEqual(200, response.StatusCode);\n            if (FJSONObject[\"value\"] != null && FJSONObject[\"value\"].Type != JTokenType.Null)\n                Assert.AreEqual(AValue, FJSONObject[\"value\"].ToString());\n            else\n                Assert.Fail(\"The return is not in the correct format.\");\n            StopApiListen();\n        }\n\n        [Test]\n        public void TestGStartApiPortListens()\n        {\n            StartApiPortListens();\n            StopApi();\n        }\n\n        [Test]\n        public void TestCreateApi()\n        {\n            Assert.Throws<Exception>(() => CreateApi(), \"The Horse instance has already been created\");\n        }\n\n        [Test]\n        public void TestToHorse()\n        {\n            Assert.IsNotNull(Horse.Horse.ToModule.ToHorse(), \"Module instance must not be null\");\n        }\n    }\n}"}
{"input": "unit TestControllersU;\n\ninterface\n\nuses MVCFramework.Commons,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n\n  [MVCPath('/')]\n  TSimpleController = class(TMVCController)\n  private\n    FCalledActions: TStringList;\n    procedure AddCall(ActionName: string);\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n\n  public\n    [MVCPath('/')]\n    procedure Index(Context: TWebContext);\n\n    [MVCPath('/orders')]\n    [MVCProduces('application/json')]\n    procedure OrdersProduceJSON(Context: TWebContext);\n\n    [MVCPath('/orders')]\n    procedure Orders(Context: TWebContext);\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure OrderNumber(Context: TWebContext);\n\n    [MVCHTTPMethod([httpPOST, httpPUT])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure UpdateOrderNumber(Context: TWebContext);\n\n    [MVCHTTPMethod([httpPATCH])]\n    [MVCPath('/orders/($ordernumber)')]\n    procedure PatchOrder(Context: TWebContext);\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/patient/\\$match')]\n    procedure GetOrderIssue513;\n\n    [MVCHTTPMethod([httpGET])]\n    [MVCPath('/patient/\\$match/($par1)/($par2)')]\n    procedure GetOrderIssue513WithPars(par1: string; par2: string);\n\n    property CalledActions: TStringList read FCalledActions; // only for tests\n  end;\n\n  TNotSoSimpleController = class(TMVCController)\n  public\n    procedure Method1(CTX: TWebContext);\n  end;\n\nimplementation\n\n{ TSimpleController }\n\nprocedure TSimpleController.AddCall(ActionName: string);\nbegin\n  FCalledActions.Add(ActionName);\nend;\n\nprocedure TSimpleController.GetOrderIssue513;\nbegin\n  AddCall('GetOrderIssue513');\nend;\n\nprocedure TSimpleController.GetOrderIssue513WithPars(par1, par2: string);\nbegin\n  AddCall('GetOrderIssue513WithPars');\nend;\n\nprocedure TSimpleController.Index(Context: TWebContext);\nbegin\n  AddCall('Index');\nend;\n\nprocedure TSimpleController.MVCControllerAfterCreate;\nbegin\n  inherited;\n  FCalledActions := TStringList.Create;\nend;\n\nprocedure TSimpleController.MVCControllerBeforeDestroy;\nbegin\n  FCalledActions.Free;\n  inherited;\n\nend;\n\nprocedure TSimpleController.Orders(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.OrdersProduceJSON(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.PatchOrder(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.UpdateOrderNumber(Context: TWebContext);\nbegin\n\nend;\n\nprocedure TSimpleController.OrderNumber(Context: TWebContext);\nbegin\n\nend;\n\n{ TNotSoSimpleController }\n\nprocedure TNotSoSimpleController.Method1(CTX: TWebContext);\nbegin\n\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\n\nnamespace TestControllers\n{\n    [MVCPath(\"/\")]\n    public class SimpleController : MVCController\n    {\n        private List<string> _calledActions;\n\n        private void AddCall(string actionName)\n        {\n            _calledActions.Add(actionName);\n        }\n\n        protected override void MVCControllerAfterCreate()\n        {\n            base.MVCControllerAfterCreate();\n            _calledActions = new List<string>();\n        }\n\n        protected override void MVCControllerBeforeDestroy()\n        {\n            _calledActions.Clear();\n            base.MVCControllerBeforeDestroy();\n        }\n\n        [MVCPath(\"/\")]\n        public void Index(TWebContext context)\n        {\n            AddCall(\"Index\");\n        }\n\n        [MVCPath(\"/orders\")]\n        [MVCProduces(\"application/json\")]\n        public void OrdersProduceJSON(TWebContext context)\n        {\n        }\n\n        [MVCPath(\"/orders\")]\n        public void Orders(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void OrderNumber(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"POST,PUT\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void UpdateOrderNumber(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"PATCH\")]\n        [MVCPath(\"/orders/($ordernumber)\")]\n        public void PatchOrder(TWebContext context)\n        {\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/patient/$match\")]\n        public void GetOrderIssue513()\n        {\n            AddCall(\"GetOrderIssue513\");\n        }\n\n        [MVCHTTPMethod(\"GET\")]\n        [MVCPath(\"/patient/$match/($par1)/($par2)\")]\n        public void GetOrderIssue513WithPars(string par1, string par2)\n        {\n            AddCall(\"GetOrderIssue513WithPars\");\n        }\n\n        public List<string> CalledActions\n        {\n            get { return _calledActions; }\n        }\n    }\n\n    public class NotSoSimpleController : MVCController\n    {\n        public void Method1(TWebContext ctx)\n        {\n        }\n    }\n}"}
{"input": "unit Horse.Provider.VCL;\n\ninterface\n\n{$IF DEFINED(HORSE_VCL)}\nuses\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Provider.IOHandleSSL.Contract,\n  IdHTTPWebBrokerBridge,\n  IdSSLOpenSSL,\n  IdContext,\n  Horse.Provider.IOHandleSSL,\n  System.Classes,\n  System.SyncObjs,\n  System.SysUtils;\n\ntype\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FMaxConnections: Integer;\n    class var FListenQueue: Integer;\n    class var FKeepConnectionAlive: Boolean;\n    class var FIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\n    class var FHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\n    class function GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\n    class function HTTPWebBrokerIsNil: Boolean;\n    class procedure OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: string; var VUsername, VPassword: string; var VHandled: Boolean);\n    class procedure OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetMaxConnections(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL); static;\n    class procedure SetHost(const AValue: string); static;\n    class procedure SetKeepConnectionAlive(const AValue: Boolean); static;\n    class function GetKeepConnectionAlive: Boolean; static;\n    class function GetListenQueue: Integer; static;\n    class function GetMaxConnections: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetIOHandleSSL: IHorseProviderIOHandleSSL; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n    class procedure InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property MaxConnections: Integer read GetMaxConnections write SetMaxConnections;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class property KeepConnectionAlive: Boolean read GetKeepConnectionAlive write SetKeepConnectionAlive;\n    class property IOHandleSSL: IHorseProviderIOHandleSSL read GetIOHandleSSL write SetIOHandleSSL;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class function IsRunning: Boolean;\n    class destructor UnInitialize;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_VCL)}\nuses\n  Web.WebReq,\n  Horse.WebModule,\n  IdCustomTCPServer;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.GetDefaultHTTPWebBroker: TIdHTTPWebBrokerBridge;\nbegin\n  if HTTPWebBrokerIsNil then\n  begin\n    FIdHTTPWebBrokerBridge := TIdHTTPWebBrokerBridge.Create(nil);\n    FIdHTTPWebBrokerBridge.OnParseAuthentication := OnAuthentication;\n    FIdHTTPWebBrokerBridge.OnQuerySSLPort := OnQuerySSLPort;\n  end;\n  Result := FIdHTTPWebBrokerBridge;\nend;\n\nclass function THorseProvider.GetKeepConnectionAlive: Boolean;\nbegin\n  Result := FKeepConnectionAlive;\nend;\n\nclass procedure THorseProvider.SetKeepConnectionAlive(const AValue: Boolean);\nbegin\n  FKeepConnectionAlive := AValue;\nend;\n\nclass function THorseProvider.HTTPWebBrokerIsNil: Boolean;\nbegin\n  Result := FIdHTTPWebBrokerBridge = nil;\nend;\n\nclass procedure THorseProvider.OnQuerySSLPort(APort: Word; var VUseSSL: Boolean);\nbegin\n  VUseSSL := (FHorseProviderIOHandleSSL <> nil) and (FHorseProviderIOHandleSSL.Active);\nend;\n\nclass function THorseProvider.GetDefaultHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  if FHorseProviderIOHandleSSL = nil then\n    FHorseProviderIOHandleSSL := THorseProviderIOHandleSSL.New;\n  Result := FHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetIOHandleSSL: IHorseProviderIOHandleSSL;\nbegin\n  Result := GetDefaultHorseProviderIOHandleSSL;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetMaxConnections: Integer;\nbegin\n  Result := FMaxConnections;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InitServerIOHandlerSSLOpenSSL(const AIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge; const AHorseProviderIOHandleSSL: IHorseProviderIOHandleSSL);\nvar\n  LIOHandleSSL: TIdServerIOHandlerSSLOpenSSL;\nbegin\n  LIOHandleSSL := TIdServerIOHandlerSSLOpenSSL.Create(AIdHTTPWebBrokerBridge);\n  LIOHandleSSL.SSLOptions.CertFile := AHorseProviderIOHandleSSL.CertFile;\n  LIOHandleSSL.SSLOptions.RootCertFile := AHorseProviderIOHandleSSL.RootCertFile;\n  LIOHandleSSL.SSLOptions.KeyFile := AHorseProviderIOHandleSSL.KeyFile;\n  LIOHandleSSL.SSLOptions.Method := AHorseProviderIOHandleSSL.Method;\n  LIOHandleSSL.SSLOptions.SSLVersions := AHorseProviderIOHandleSSL.SSLVersions;\n  LIOHandleSSL.OnGetPassword := AHorseProviderIOHandleSSL.OnGetPassword;\n  AIdHTTPWebBrokerBridge.IOHandler := LIOHandleSSL;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LIdHTTPWebBrokerBridge: TIdHTTPWebBrokerBridge;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n\n  LIdHTTPWebBrokerBridge := GetDefaultHTTPWebBroker;\n  WebRequestHandler.WebModuleClass := WebModuleClass;\n  try\n    if FMaxConnections > 0 then\n    begin\n      WebRequestHandler.MaxConnections := FMaxConnections;\n      GetDefaultHTTPWebBroker.MaxConnections := FMaxConnections;\n    end;\n\n    if FListenQueue = 0 then\n      FListenQueue := IdListenQueueDefault;\n\n    if FHorseProviderIOHandleSSL <> nil then\n      InitServerIOHandlerSSLOpenSSL(LIdHTTPWebBrokerBridge, GetDefaultHorseProviderIOHandleSSL);\n\n    LIdHTTPWebBrokerBridge.ListenQueue := FListenQueue;\n\n    LIdHTTPWebBrokerBridge.Bindings.Clear;\n    if FHost <> GetDefaultHost then\n    begin\n      LIdHTTPWebBrokerBridge.Bindings.Add;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].IP := FHost;\n      LIdHTTPWebBrokerBridge.Bindings.Items[0].Port := FPort;\n    end;\n\n    LIdHTTPWebBrokerBridge.KeepAlive := FKeepConnectionAlive;\n    LIdHTTPWebBrokerBridge.DefaultPort := FPort;\n    LIdHTTPWebBrokerBridge.Active := True;\n    LIdHTTPWebBrokerBridge.StartListening;\n    FRunning := True;\n    DoOnListen;\n  except\n    raise;\n  end;\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPWebBrokerIsNil then\n  begin\n    GetDefaultHTTPWebBroker.Active := False;\n    FRunning := False;\n    DoOnStopListen;\n    GetDefaultHTTPWebBroker.StopListening;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.OnAuthentication(AContext: TIdContext; const AAuthType, AAuthData: string; var VUsername, VPassword: string; var VHandled: Boolean);\nbegin\n  VHandled := True;\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue.Trim;\nend;\n\nclass procedure THorseProvider.SetIOHandleSSL(const AValue: IHorseProviderIOHandleSSL);\nbegin\n  FHorseProviderIOHandleSSL := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetMaxConnections(const AValue: Integer);\nbegin\n  FMaxConnections := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FIdHTTPWebBrokerBridge);\nend;\n\ninitialization\n  THorseProvider.SetKeepConnectionAlive(True);\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Linq;\n\nnamespace Horse.Provider.VCL\n{\n    #region Stub Types\n\n    public class IdHTTPWebBrokerBridge\n    {\n        public int MaxConnections { get; set; }\n        public int ListenQueue { get; set; }\n        public bool KeepAlive { get; set; }\n        public int DefaultPort { get; set; }\n        public bool Active { get; set; }\n        public List<Binding> Bindings { get; } = new List<Binding>();\n        public object IOHandler { get; set; }\n        public Action OnParseAuthentication { get; set; }\n        public Action<ushort, ref bool> OnQuerySSLPort { get; set; }\n\n        public IdHTTPWebBrokerBridge()\n        {\n            // Initialize default values if needed.\n        }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"HTTP Web Broker Bridge listening on port {DefaultPort}.\");\n        }\n\n        public void StopListening()\n        {\n            \n            Console.WriteLine(\"HTTP Web Broker Bridge stopped listening.\");\n        }\n    }\n\n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    public class HorseWebModule\n    {\n        // Your web module implementation goes here.\n    }\n\n    public static class WebRequestHandler\n    {\n        public static Type WebModuleClass { get; set; }\n        public static int MaxConnections { get; set; }\n    }\n\n    public interface IHorseProviderIOHandleSSL\n    {\n        bool Active { get; }\n        string CertFile { get; }\n        string RootCertFile { get; }\n        string KeyFile { get; }\n        TIdSSLVersion Method { get; }\n        TIdSSLVersions SSLVersions { get; }\n        string CipherList { get; }\n        string DHParamsFile { get; }\n        Func<string> OnGetPassword { get; }\n    }\n\n    public enum TIdSSLVersion { TLSv1, TLSv1_1, TLSv1_2 }\n    [Flags]\n    public enum TIdSSLVersions { TLSv1 = 1, TLSv1_1 = 2, TLSv1_2 = 4 }\n\n    public class HorseProviderIOHandleSSL : IHorseProviderIOHandleSSL\n    {\n        public bool Active => true;\n        public string CertFile => \"cert.pem\";\n        public string RootCertFile => \"root.pem\";\n        public string KeyFile => \"key.pem\";\n        public TIdSSLVersion Method => TIdSSLVersion.TLSv1_2;\n        public TIdSSLVersions SSLVersions => TIdSSLVersions.TLSv1_2;\n        public string CipherList => \"HIGH:!aNULL:!MD5\";\n        public string DHParamsFile => \"dh.pem\";\n        public Func<string> OnGetPassword => () => \"password\";\n\n        public static IHorseProviderIOHandleSSL New => new HorseProviderIOHandleSSL();\n    }\n\n    public static class HorseConstants\n    {\n        public const string DEFAULT_HOST = \"0.0.0.0\";\n        public const int DEFAULT_PORT = 8080;\n        public const int IdListenQueueDefault = 15;\n    }\n\n    #endregion\n\n    #region Abstract Base Provider\n\n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n\n        protected static Action OnListenCallback;\n        protected static Action OnStopListenCallback;\n\n        protected static void DoOnListen() => OnListenCallback?.Invoke();\n        protected static void DoOnStopListen() => OnStopListenCallback?.Invoke();\n\n        public static void SetOnListen(Action callback) => OnListenCallback = callback;\n        public static void SetOnStopListen(Action callback) => OnStopListenCallback = callback;\n    }\n\n    #endregion\n\n    #region HorseProvider (VCL)\n\n    public static class HorseProvider : HorseProviderAbstract\n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _maxConnections;\n        private static int _listenQueue;\n        private static bool _keepConnectionAlive;\n        private static IdHTTPWebBrokerBridge _httpWebBrokerBridge;\n        private static IHorseProviderIOHandleSSL _horseProviderIOHandleSSL;\n\n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int MaxConnections { get => GetMaxConnections(); set => SetMaxConnections(value); }\n        public static int ListenQueue { get => GetListenQueue(); set => SetListenQueue(value); }\n        public static bool KeepConnectionAlive { get => GetKeepConnectionAlive(); set => SetKeepConnectionAlive(value); }\n        public static IHorseProviderIOHandleSSL IOHandleSSL { get => GetIOHandleSSL(); set => SetIOHandleSSL(value); }\n\n        public override void Listen() => InternalListen();\n\n        public override void StopListen() => InternalStopListen();\n\n        public static void Listen(int aPort, string aHost = \"0.0.0.0\", Action callbackListen = null, Action callbackStopListen = null)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(callbackListen);\n            SetOnStopListen(callbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value?.Trim();\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n        private static void SetListenQueue(int value) => _listenQueue = value;\n        private static int GetMaxConnections() => _maxConnections;\n        private static void SetMaxConnections(int value) => _maxConnections = value;\n        private static bool GetKeepConnectionAlive() => _keepConnectionAlive;\n        private static void SetKeepConnectionAlive(bool value) => _keepConnectionAlive = value;\n        private static int GetDefaultPort() => HorseConstants.DEFAULT_PORT;\n        private static string GetDefaultHost() => HorseConstants.DEFAULT_HOST;\n        private static IHorseProviderIOHandleSSL GetIOHandleSSL() => _horseProviderIOHandleSSL ?? ( _horseProviderIOHandleSSL = HorseProviderIOHandleSSL.New);\n\n        private static IdHTTPWebBrokerBridge GetDefaultHTTPWebBroker()\n        {\n            if (HTTPWebBrokerIsNil())\n            {\n                _httpWebBrokerBridge = new IdHTTPWebBrokerBridge();\n                _httpWebBrokerBridge.OnParseAuthentication = () => OnAuthentication(null, null, null, ref dummyUsername, ref dummyPassword, ref dummyHandled);\n                _httpWebBrokerBridge.OnQuerySSLPort = (port, ref boolUseSSL) => OnQuerySSLPort(port, ref boolUseSSL);\n            }\n            return _httpWebBrokerBridge;\n        }\n\n        private static string dummyUsername = \"\";\n        private static string dummyPassword = \"\";\n        private static bool dummyHandled = false;\n\n        private static bool HTTPWebBrokerIsNil() => _httpWebBrokerBridge == null;\n\n        private static void SetOnListen(Action callback) => SetOnListenCallback(callback);\n        private static void SetOnStopListen(Action callback) => SetOnStopListenCallback(callback);\n        private static void SetOnListenCallback(Action callback) => HorseProviderAbstract.SetOnListen(callback);\n        private static void SetOnStopListenCallback(Action callback) => HorseProviderAbstract.SetOnStopListen(callback);\n\n        private static void OnQuerySSLPort(ushort aPort, ref bool vUseSSL)\n        {\n            vUseSSL = (_horseProviderIOHandleSSL != null) && GetIOHandleSSL().Active;\n        }\n\n        private static void OnAuthentication(object aContext, string aAuthType, string aAuthData, ref string vUsername, ref string vPassword, ref bool vHandled)\n        {\n            vHandled = true;\n        }\n\n        private static void InitServerIOHandlerSSLOpenSSL(IdHTTPWebBrokerBridge bridge, IHorseProviderIOHandleSSL ioHandlerSSL)\n        {\n            \n            Console.WriteLine(\"Initializing SSL IOHandler with CertFile: \" + ioHandlerSSL.CertFile);\n            \n        }\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = GetDefaultPort();\n            if (string.IsNullOrEmpty(_host))\n                _host = GetDefaultHost();\n\n            var bridge = GetDefaultHTTPWebBroker();\n            \n            WebRequestHandler.WebModuleClass = typeof(Horse.WebModule.HorseWebModule);\n            try\n            {\n                if (_maxConnections > 0)\n                {\n                    WebRequestHandler.MaxConnections = _maxConnections;\n                    bridge.MaxConnections = _maxConnections;\n                }\n\n                if (_listenQueue == 0)\n                    _listenQueue = HorseConstants.IdListenQueueDefault;\n\n                if (_horseProviderIOHandleSSL != null)\n                    InitServerIOHandlerSSLOpenSSL(bridge, GetIOHandleSSL());\n\n                bridge.ListenQueue = _listenQueue;\n                bridge.Bindings.Clear();\n                if (_host != GetDefaultHost())\n                {\n                    \n                    bridge.Bindings.Add(new Binding { IP = _host, Port = _port });\n                }\n\n                bridge.KeepAlive = _keepConnectionAlive;\n                bridge.DefaultPort = _port;\n                bridge.Active = true;\n                bridge.StartListening();\n                _running = true;\n                HorseProviderAbstract.DoOnListen();\n            }\n            catch (Exception)\n            {\n                throw;\n            }\n        }\n\n        private static void InternalStopListen()\n        {\n            if (!HTTPWebBrokerIsNil())\n            {\n                var bridge = GetDefaultHTTPWebBroker();\n                bridge.Active = false;\n                _running = false;\n                HorseProviderAbstract.DoOnStopListen();\n                bridge.StopListening();\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static void StopListen() => InternalStopListen();\n\n        public static void Listen() => InternalListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            SetOnListen(callbackListen);\n            SetOnStopListen(callbackStopListen);\n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        class destructor UnInitialize()\n        {\n            _httpWebBrokerBridge = null;\n            return;\n        }\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// LoggerPro\n//\n// Copyright (c) 2010-2025 Daniele Teti\n//\n// https://github.com/danieleteti/loggerpro\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit LoggerPro.OutputDebugStringAppender;\n\ninterface\n\nuses\n  LoggerPro, System.Classes;\n\ntype\n  { @abstract(This appenders sends logs to the @code(OutputDebugString) function on Windows OSes)\n    To learn how to use this appender, check the sample @code(outputdebugstring_appender.dproj)\n  }\n  TLoggerProOutputDebugStringAppender = class(TLoggerProAppenderBase)\n  private\n    {$IFDEF MSWINDOWS}\n    FModuleName: string;\n    {$ENDIF}\n  public\n    constructor Create(aLogItemRenderer: ILogItemRenderer = nil); override;\n    procedure Setup; override;\n    procedure TearDown; override;\n    procedure WriteLog(const aLogItem: TLogItem); override;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.IOUtils\n{$IFDEF MSWINDOWS}\n    , Winapi.Windows\n    , Winapi.Messages\n{$ENDIF}\n  ;\n\n{ TLoggerProOutputDebugStringAppender }\n\nconstructor TLoggerProOutputDebugStringAppender.Create(aLogItemRenderer: ILogItemRenderer);\nbegin\n  inherited;\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.Setup;\nbegin\n  inherited;\n{$IFDEF MSWINDOWS}\n  FModuleName := TPath.GetFileName(GetModuleName(HInstance));\n{$ENDIF}\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.TearDown;\nbegin\n  // do nothing\nend;\n\nprocedure TLoggerProOutputDebugStringAppender.WriteLog(const aLogItem : TLogItem);\n{$IFDEF MSWINDOWS}\nvar\n  lLog: string;\n{$ENDIF}\nbegin\n{$IFDEF MSWINDOWS}\n  lLog := '(' + FModuleName + ') ' + FormatLog(aLogItem);\n  OutputDebugString(PChar(lLog));\n{$ENDIF}\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.IO.Path;\nusing LoggerPro; \n\nnamespace LoggerPro.Appenders\n{\n    \n    public class LoggerProOutputDebugStringAppender : LoggerProAppenderBase, ILogAppender\n    {\n#if WINDOWS\n        private string _moduleName;\n#endif\n\n        public LoggerProOutputDebugStringAppender(ILogItemRenderer logItemRenderer = null)\n            : base(logItemRenderer)\n        {\n        }\n\n        public override void Setup()\n        {\n            base.Setup();\n#if WINDOWS\n            \n            try\n            {\n                string fullPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;\n                _moduleName = Path.GetFileName(fullPath);\n            }\n            catch\n            {\n                _moduleName = \"UnknownModule\";\n            }\n#endif\n        }\n\n        public override void TearDown()\n        {\n            base.TearDown();\n            \n        }\n\n        public override void WriteLog(LogItem logItem)\n        {\n#if WINDOWS\n            \n            string logText = $\"({_moduleName}) {FormatLog(logItem)}\";\n            OutputDebugString(logText);\n#endif\n        }\n\n        \n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]\n        private static extern void OutputDebugString(string lpOutputString);\n    }\n}"}
{"input": "unit WSHelperCustomersU;\n\ninterface\n\nuses\n  BOCustomersU;\n\ntype\n  TWSHelperCustomers = class\n  public\n    function GetCustomers: TCustomers; overload;\n  end;\n\nimplementation\n\nuses\n   System.SysUtils;\n\n{ TWSHelperCustomers }\n\nfunction TWSHelperCustomers.GetCustomers: TCustomers;\nvar\n  Customer: TCustomer;\nbegin\n  Result := TCustomers.Create;\n\n  Customer := TCustomer.Create;\n  Customer.FirstName := 'Joe';\n  Customer.MiddleName := 'M';\n  Customer.Surname := 'Bloggs';\n\n  Result.Add(Customer);\n\n  Customer := TCustomer.Create;\n  Customer.FirstName := 'Mary';\n  Customer.MiddleName := 'J';\n  Customer.Surname := 'Jones';\n\n  Result.Add(Customer);\n\nend;\n\n\nend.", "output": "using BOCustomersU;\n\nnamespace YourNamespace\n{\n    public class WSHelperCustomers\n    {\n        public TCustomers GetCustomers()\n        {\n            TCustomers customers = new TCustomers();\n            TCustomer customer = new TCustomer();\n            customer.FirstName = \"Joe\";\n            customer.MiddleName = \"M\";\n            customer.Surname = \"Bloggs\";\n            customers.Add(customer);\n            customer = new TCustomer();\n            customer.FirstName = \"Mary\";\n            customer.MiddleName = \"J\";\n            customer.Surname = \"Jones\";\n            customers.Add(customer);\n            return customers;\n        }\n    }\n}"}
{"input": "unit CustomersControllerU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Commons,\n  System.Generics.Collections,\n  EntitiesU,\n  CustomerServiceU;\n\ntype\n\n  [MVCPath('/api/customers')]\n  TCustomersController = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethods([httpGET])]\n    function GetCustomers(\n      [MVCFromQueryString('rql','')] RQLFilter: String;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/($ID:sqids)')]\n    [MVCHTTPMethods([httpGET])]\n    function GetCustomerByID(\n      const ID: Integer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/($ID:sqids)')]\n    [MVCHTTPMethods([httpPUT])]\n    function UpdateCustomerByID(\n      const ID: Integer;\n      [MVCFromBody] const Customer: TCustomer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath]\n    [MVCHTTPMethods([httpPOST])]\n    function CreateCustomer(\n      [MVCFromBody] const Customer: TCustomer;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n\n    [MVCPath('/_bulk')]\n    [MVCHTTPMethods([httpPOST])]\n    function BulkCreateCustomers(\n      [MVCFromBody] const Customers: TObjectList<TCustomer>;\n      [MVCInject] CustomersService: ICustomersService): IMVCResponse;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\n{ TCustomersController }\n\nfunction TCustomersController.CreateCustomer(const Customer: TCustomer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  var lID := CustomersService.CreateCustomer(Customer);\n  Result := CreatedResponse('/api/customers/' + lID.ToString);\nend;\n\nfunction TCustomersController.GetCustomerByID(const ID: Integer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  Result := OKResponse(CustomersService.GetByID(ID));\nend;\n\nfunction TCustomersController.GetCustomers(RQLFilter: String; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  Result := OKResponse(CustomersService.GetByRQL(RQLFilter));\nend;\n\nfunction TCustomersController.UpdateCustomerByID(const ID: Integer; const Customer: TCustomer; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  CustomersService.UpdateByID(ID, Customer);\n  Result := OKResponse;\nend;\n\nfunction TCustomersController.BulkCreateCustomers(const Customers: TObjectList<TCustomer>; CustomersService: ICustomersService): IMVCResponse;\nbegin\n  CustomersService.CreateCustomers(Customers);\n  Result := CreatedResponse();\nend;\n\nend.", "output": "using System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing EntitiesU;          \nusing CustomerServiceU;  \n\nnamespace CustomersControllerU\n{\n    [Route(\"api/customers\")]\n    [ApiController]\n    public class CustomersController : ControllerBase\n    {\n        \n        [HttpGet]\n        public IActionResult GetCustomers(\n            [FromQuery(Name = \"rql\")] string rqlFilter = \"\",\n            [FromServices] ICustomersService customersService)\n        {\n            var result = customersService.GetByRQL(rqlFilter);\n            return Ok(result);\n        }\n\n        \n        [HttpGet(\"{id}\")]\n        public IActionResult GetCustomerByID(\n            int id,\n            [FromServices] ICustomersService customersService)\n        {\n            var customer = customersService.GetByID(id);\n            return Ok(customer);\n        }\n\n        \n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateCustomerByID(\n            int id,\n            [FromBody] TCustomer customer,\n            [FromServices] ICustomersService customersService)\n        {\n            customersService.UpdateByID(id, customer);\n            return Ok();\n        }\n\n        \n        [HttpPost]\n        public IActionResult CreateCustomer(\n            [FromBody] TCustomer customer,\n            [FromServices] ICustomersService customersService)\n        {\n            var newId = customersService.CreateCustomer(customer);\n            return Created($\"/api/customers/{newId}\", null);\n        }\n\n        \n        [HttpPost(\"_bulk\")]\n        public IActionResult BulkCreateCustomers(\n            [FromBody] List<TCustomer> customers,\n            [FromServices] ICustomersService customersService)\n        {\n            customersService.CreateCustomers(customers);\n            return Created(string.Empty, null);\n        }\n    }\n}"}
{"input": "unit VCLAppendersFormU;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls,\n  LoggerPro,\n  Vcl.ComCtrls,\n  System.ImageList,\n  Vcl.ImgList;\n\ntype\n  TMainForm = class(TForm)\n    Button1: TButton;\n    Button2: TButton;\n    Button3: TButton;\n    Button4: TButton;\n    Button5: TButton;\n    PageControl1: TPageControl;\n    tsListViewAppender: TTabSheet;\n    tsMemoAppender: TTabSheet;\n    Memo1: TMemo;\n    ListView1: TListView;\n    Button6: TButton;\n    procedure Button1Click(Sender: TObject);\n    procedure Button2Click(Sender: TObject);\n    procedure Button3Click(Sender: TObject);\n    procedure Button4Click(Sender: TObject);\n    procedure Button5Click(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n    procedure Button6Click(Sender: TObject);\n  private\n    FLog: ILogWriter;\n    { Private declarations }\n  public\n    function Log: ILogWriter;\n  end;\n\nvar\n  MainForm: TMainForm;\n\nimplementation\n\nuses\n  LoggerPro.VCLMemoAppender,\n  LoggerPro.VCLListViewAppender;\n\n{$R *.dfm}\n\nprocedure TMainForm.Button1Click(Sender: TObject);\nbegin\n  Log.Debug('This is a debug message with TAG1', 'TAG1');\n  Log.Debug('This is a debug message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button2Click(Sender: TObject);\nbegin\n  Log.Info('This is a info message with TAG1', 'TAG1');\n  Log.Info('This is a info message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button3Click(Sender: TObject);\nbegin\n  Log.Warn('This is a warning message with TAG1', 'TAG1');\n  Log.Warn('This is a warning message with TAG2', 'TAG2');\n\nend;\n\nprocedure TMainForm.Button4Click(Sender: TObject);\nbegin\n  Log.Error('This is an error message with TAG1', 'TAG1');\n  Log.Error('This is an error message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.Button5Click(Sender: TObject);\nvar\n  lThreadProc: TProc;\nbegin\n  lThreadProc := procedure\n    var\n      I: Integer;\n      lThreadID: String;\n    begin\n      lThreadID := IntToStr(TThread.CurrentThread.ThreadID);\n      for I := 1 to 50 do\n      begin\n        Log.Debug('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Info('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Warn('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Error('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n        Log.Fatal('log message ' + TimeToStr(now) + ' ThreadID: ' + lThreadID, 'MULTITHREADING');\n      end;\n    end;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\n  TThread.CreateAnonymousThread(lThreadProc).Start;\nend;\n\nprocedure TMainForm.Button6Click(Sender: TObject);\nbegin\n  Log.Fatal('This is a fatal message with TAG1', 'TAG1');\n  Log.Fatal('This is a fatal message with TAG2', 'TAG2');\nend;\n\nprocedure TMainForm.FormCreate(Sender: TObject);\nbegin\n  // Let's create the local loggers for this form\n  FLog := BuildLogWriter([TVCLListViewAppender.Create(ListView1), TVCLMemoLogAppender.Create(Memo1)])\nend;\n\nfunction TMainForm.Log: ILogWriter;\nbegin\n  Result := FLog;\nend;\n\nend.", "output": "using System;\nusing System.Threading;\nusing System.Windows.Forms;\nusing LoggerPro;\nusing LoggerPro.VCLMemoAppender;\nusing LoggerPro.VCLListViewAppender;\n\nnamespace VCLAppenders\n{\n    public partial class MainForm : Form\n    {\n        private ILogWriter _log;\n        public MainForm()\n        {\n            InitializeComponent();\n            Load += MainForm_Load;\n        }\n        private void MainForm_Load(object sender, EventArgs e)\n        {\n            _log = BuildLogWriter(new ILogAppender[] { new VCLListViewAppender(ListView1), new VCLMemoLogAppender(Memo1) });\n        }\n        public ILogWriter Log() => _log;\n        private void Button1_Click(object sender, EventArgs e)\n        {\n            Log().Debug(\"This is a debug message with TAG1\", \"TAG1\");\n            Log().Debug(\"This is a debug message with TAG2\", \"TAG2\");\n        }\n        private void Button2_Click(object sender, EventArgs e)\n        {\n            Log().Info(\"This is a info message with TAG1\", \"TAG1\");\n            Log().Info(\"This is a info message with TAG2\", \"TAG2\");\n        }\n        private void Button3_Click(object sender, EventArgs e)\n        {\n            Log().Warn(\"This is a warning message with TAG1\", \"TAG1\");\n            Log().Warn(\"This is a warning message with TAG2\", \"TAG2\");\n        }\n        private void Button4_Click(object sender, EventArgs e)\n        {\n            Log().Error(\"This is an error message with TAG1\", \"TAG1\");\n            Log().Error(\"This is an error message with TAG2\", \"TAG2\");\n        }\n        private void Button5_Click(object sender, EventArgs e)\n        {\n            Action threadProc = () =>\n            {\n                string threadID = Thread.CurrentThread.ManagedThreadId.ToString();\n                for (int i = 1; i <= 50; i++)\n                {\n                    Log().Debug(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Info(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Warn(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Error(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                    Log().Fatal(\"log message \" + DateTime.Now.ToLongTimeString() + \" ThreadID: \" + threadID, \"MULTITHREADING\");\n                }\n            };\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n            new Thread(new ThreadStart(threadProc)).Start();\n        }\n        private void Button6_Click(object sender, EventArgs e)\n        {\n            Log().Fatal(\"This is a fatal message with TAG1\", \"TAG1\");\n            Log().Fatal(\"This is a fatal message with TAG2\", \"TAG2\");\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerExceptionU;\n\ninterface\n\nuses\n  MVCFramework, System.SysUtils;\n\ntype\n\n  EMyException = class(Exception)\n\n  end;\n\n  [MVCPath('/exception/aftercreate')]\n  TTestServerControllerExceptionAfterCreate = class(TMVCController)\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n  public\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\n  [MVCPath('/exception/beforedestroy')]\n  TTestServerControllerExceptionBeforeDestroy = class(TMVCController)\n\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n  public\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\n  [MVCPath('/actionfilters/beforeaction')]\n  TTestServerControllerActionFilters = class(TMVCController)\n  protected\n    procedure OnBeforeAction(Context: TWebContext; const aActionName: string;\n      var Handled: Boolean); override;\n  public\n    [MVCPath('/alwayscalled')]\n    procedure AlwaysCalled(CTX: TWebContext);\n    [MVCPath('/nevercalled')]\n    procedure NeverCalled(CTX: TWebContext);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Commons;\n\n{ TTestServerControllerException }\n\nprocedure TTestServerControllerExceptionAfterCreate.MVCControllerAfterCreate;\nbegin\n  inherited;\n  raise EMyException.Create('This is an exception raised in the MVCControllerAfterCreate');\nend;\n\nprocedure TTestServerControllerExceptionAfterCreate.MVCControllerBeforeDestroy;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerControllerExceptionAfterCreate.NeverCalled(CTX: TWebContext);\nbegin\n  Render(500, 'This method should not be called...');\nend;\n\n{ TTestServerControllerExceptionBeforeDestroy }\n\nprocedure TTestServerControllerExceptionBeforeDestroy.MVCControllerAfterCreate;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerControllerExceptionBeforeDestroy.MVCControllerBeforeDestroy;\nbegin\n  inherited;\n  raise EMyException.Create('This is an exception raised in the MVCControllerBeforeDestroy');\nend;\n\nprocedure TTestServerControllerExceptionBeforeDestroy.NeverCalled(CTX: TWebContext);\nbegin\n\nend;\n\n{ TTestServerControllerActionFilters }\n\nprocedure TTestServerControllerActionFilters.AlwaysCalled(CTX: TWebContext);\nbegin\n  StatusCode := 200;\nend;\n\nprocedure TTestServerControllerActionFilters.NeverCalled(CTX: TWebContext);\nbegin\n  raise Exception.Create('Should never be called!');\nend;\n\nprocedure TTestServerControllerActionFilters.OnBeforeAction(\n  Context: TWebContext; const aActionName: string; var Handled: Boolean);\nbegin\n  inherited;\n  if SameText(aActionName, 'NeverCalled') then\n  begin\n    Context.Response.StatusCode := 404;\n    Handled := True;\n  end;\nend;\n\nend.", "output": "using System;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace TestServer.Controllers\n{\n    public class EMyException : Exception\n    {\n        public EMyException(string message) : base(message) { }\n    }\n\n    [Route(\"exception/aftercreate\")]\n    public class TestServerControllerExceptionAfterCreate : ControllerBase\n    {\n        public TestServerControllerExceptionAfterCreate()\n        {\n            MVCControllerAfterCreate();\n        }\n\n        protected virtual void MVCControllerAfterCreate()\n        {\n            throw new EMyException(\"This is an exception raised in the MVCControllerAfterCreate\");\n        }\n\n        protected virtual void MVCControllerBeforeDestroy() { }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            return StatusCode(500, \"This method should not be called...\");\n        }\n    }\n\n    [Route(\"exception/beforedestroy\")]\n    public class TestServerControllerExceptionBeforeDestroy : ControllerBase\n    {\n        protected virtual void MVCControllerAfterCreate() { }\n\n        protected virtual void MVCControllerBeforeDestroy()\n        {\n            throw new EMyException(\"This is an exception raised in the MVCControllerBeforeDestroy\");\n        }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            return Ok();\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                MVCControllerBeforeDestroy();\n            }\n            base.Dispose(disposing);\n        }\n    }\n\n    [Route(\"actionfilters/beforeaction\")]\n    public class TestServerControllerActionFilters : ControllerBase\n    {\n        public override void OnActionExecuting(ActionExecutingContext context)\n        {\n            if (string.Equals(context.ActionDescriptor.RouteValues[\"action\"], \"NeverCalled\", StringComparison.OrdinalIgnoreCase))\n            {\n                context.Result = new StatusCodeResult(404);\n            }\n            base.OnActionExecuting(context);\n        }\n\n        [HttpGet(\"alwayscalled\")]\n        public IActionResult AlwaysCalled()\n        {\n            Response.StatusCode = 200;\n            return Ok();\n        }\n\n        [HttpGet(\"nevercalled\")]\n        public IActionResult NeverCalled()\n        {\n            throw new Exception(\"Should never be called!\");\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Swag.Doc.SecurityDefinitionApiKey;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.JSON,\n  Swag.Common.Types,\n  Swag.Doc.SecurityDefinition;\n\ntype\n  TSwagSecurityDefinitionApiKeyInLocation = (kilNotDefined, kilQuery, kilHeader);\n\ntype\n  /// <summary>\n  /// The security scheme object API key (either as a header or as a query parameter)\n  /// </summary>\n  [ASecurityDefinition(ssdApiKey)]\n  TSwagSecurityDefinitionApiKey = class(TSwagSecurityDefinition)\n  private\n    fName: string;\n    fInLocation: TSwagSecurityDefinitionApiKeyInLocation;\n  protected\n    function GetTypeSecurity: TSwagSecurityDefinitionType; override;\n  public\n    function GenerateJsonObject: TJSONObject; override;\n    procedure Load(pJson: TJSONObject); override;\n    /// <summary>\n    /// Required The location of the API key. Valid values are \"query\" or \"header\".\n    /// </summary>\n    property InLocation: TSwagSecurityDefinitionApiKeyInLocation read fInLocation write fInLocation;\n\n    /// <summary>\n    /// Required. The name of the header or query parameter to be used.\n    /// </summary>\n    property Name: string read fName write fName;\n  end;\n\nimplementation\n\nuses\n  System.Classes;\n\nconst\n  c_SwagSecurityDefinitionApiKeyType = 'type';\n  c_SwagSecurityDefinitionApiKeyDescription = 'description';\n  c_SwagSecurityDefinitionApiKeyIn = 'in';\n  c_SwagSecurityDefinitionApiKeyName = 'name';\n\n  c_SwagSecurityDefinitionApiKeyInLocation: array[TSwagSecurityDefinitionApiKeyInLocation] of string =\n    ('', 'query', 'header');\n\n{ TSwagSecurityDefinitionApiKey }\n\nfunction TSwagSecurityDefinitionApiKey.GenerateJsonObject: TJSONObject;\nvar\n  vJsonItem: TJsonObject;\nbegin\n  vJsonItem := TJsonObject.Create;\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyType, ReturnTypeSecurityToString);\n  if fDescription.Length > 0 then\n    vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyDescription, fDescription);\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyIn, c_SwagSecurityDefinitionApiKeyInLocation[fInLocation]);\n  vJsonItem.AddPair(c_SwagSecurityDefinitionApiKeyName, fName);\n\n  Result := vJsonItem;\nend;\n\nfunction TSwagSecurityDefinitionApiKey.GetTypeSecurity: TSwagSecurityDefinitionType;\nbegin\n  Result := ssdApiKey;\nend;\n\nprocedure TSwagSecurityDefinitionApiKey.Load(pJson: TJSONObject);\nvar\n  vIn: string;\nbegin\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyDescription]) then\n    fDescription := pJson.Values[c_SwagSecurityDefinitionApiKeyDescription].Value;\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyName]) then\n    fName := pJson.Values[c_SwagSecurityDefinitionApiKeyName].Value;\n  if Assigned(pJson.Values[c_SwagSecurityDefinitionApiKeyIn]) then\n  begin\n    vIn := pJson.Values[c_SwagSecurityDefinitionApiKeyIn].Value;\n    if vIn.ToLower = c_SwagSecurityDefinitionApiKeyInLocation[kilQuery] then\n      fInLocation := kilQuery\n    else if vIn.ToLower = c_SwagSecurityDefinitionApiKeyInLocation[kilHeader] then\n      fInLocation := kilHeader\n    else\n      fInLocation := kilNotDefined;\n  end;\nend;\n\ninitialization\n  RegisterClass(TSwagSecurityDefinitionApiKey);\n\nend.", "output": "using System;\nusing System.Text.Json.Nodes;\n\nnamespace Swag.Doc\n{\n    public enum SwagSecurityDefinitionApiKeyInLocation\n    {\n        NotDefined,\n        Query,\n        Header\n    }\n\n    [SecurityDefinition(SwagSecurityDefinitionType.ApiKey)]\n    public class SwagSecurityDefinitionApiKey : SwagSecurityDefinition\n    {\n        private string _name;\n        private SwagSecurityDefinitionApiKeyInLocation _inLocation;\n\n        public override SwagSecurityDefinitionType GetTypeSecurity()\n        {\n            return SwagSecurityDefinitionType.ApiKey;\n        }\n\n        public override JsonObject GenerateJsonObject()\n        {\n            var json = new JsonObject();\n            json[\"type\"] = ReturnTypeSecurityToString();\n            if (!string.IsNullOrEmpty(Description))\n                json[\"description\"] = Description;\n            json[\"in\"] = InLocationToString(_inLocation);\n            json[\"name\"] = _name;\n            return json;\n        }\n\n        public override void Load(JsonObject json)\n        {\n            if (json.TryGetPropertyValue(\"description\", out JsonNode desc))\n                Description = desc.ToString();\n            if (json.TryGetPropertyValue(\"name\", out JsonNode name))\n                _name = name.ToString();\n            if (json.TryGetPropertyValue(\"in\", out JsonNode inNode))\n            {\n                string val = inNode.ToString().ToLower();\n                if (val == \"query\")\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.Query;\n                else if (val == \"header\")\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.Header;\n                else\n                    _inLocation = SwagSecurityDefinitionApiKeyInLocation.NotDefined;\n            }\n        }\n\n        public SwagSecurityDefinitionApiKeyInLocation InLocation\n        {\n            get => _inLocation;\n            set => _inLocation = value;\n        }\n\n        public string Name\n        {\n            get => _name;\n            set => _name = value;\n        }\n\n        private string InLocationToString(SwagSecurityDefinitionApiKeyInLocation location)\n        {\n            return location switch\n            {\n                SwagSecurityDefinitionApiKeyInLocation.Query => \"query\",\n                SwagSecurityDefinitionApiKeyInLocation.Header => \"header\",\n                _ => \"\"\n            };\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit IntfObjectPoolTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework;\n\ntype\n\n  [TestFixture]\n  TTestTIntfObjectPool = class\n  public\n    [Test]\n    procedure TestFixedSize;\n    [Test]\n    procedure TestGrowing;\n    [Test]\n    procedure TestFactory;\n    [Test]\n    procedure TestMultiThreading;\n    [Test]\n    procedure TestRaiseExceptionWhenPoolIsEmpty;\n    [Test]\n    procedure TestNotRaiseExceptionWhenPoolIsEmpty;\n  end;\n\nimplementation\n\nuses\n  System.Generics.Collections, MVCFramework.IntfObjectPool, System.SysUtils, System.Classes, SyncObjs;\n\nvar\n  GNumReleased: integer;\n\ntype\n  IPoolObject = Interface\n    ['{CA1012E7-5639-48A9-B26B-D94218C28508}']\n  End;\n\ntype\n  TPoolObject = class(TInterfacedObject, IPoolObject)\n  strict private\n    FValue: integer;\n  public\n    constructor Create; overload;\n    constructor Create(value: integer); overload;\n    destructor Destroy; override;\n    property value: integer read FValue;\n  end;\n\ntype\n  TCustomInterfaceCreator = TFunc<IInterface>;\n\n  { TTestTObjectPool }\n\nprocedure TTestTIntfObjectPool.TestFixedSize;\nvar\n  i: integer;\n  lObjs: array [1 .. 5] of IPoolObject;\n  lPool: IIntfObjectPool;\n  lRpt: integer;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreatePool(3, 3, 0, lCustomFactory);\n  for lRpt := 1 to 3 do\n  begin\n    for i := Low(lObjs) to High(lObjs) do\n      lObjs[i] := lPool.GetFromPool as IPoolObject;\n\n    for i := 1 to 3 do\n      Assert.IsTrue(nil <> lObjs[i]);\n    for i := 4 to 5 do\n      Assert.IsTrue(nil = lObjs[i]);\n\n    Assert.IsTrue(lObjs[1] <> lObjs[2]);\n    Assert.IsTrue(lObjs[1] <> lObjs[3]);\n    Assert.IsTrue(lObjs[2] <> lObjs[3]);\n\n    GNumReleased := 0;\n\n    for i := 1 to 3 do\n      lPool.ReleaseToPool(lObjs[i]);\n\n    Assert.AreEqual(0, GNumReleased);\n  end;\n\n  // lPool := nil;\n\n  // Assert.AreEqual(3, GNumReleased);\nend;\n\nprocedure TTestTIntfObjectPool.TestGrowing;\nvar\n  i: integer;\n  lObjs: array [1 .. 5] of IPoolObject;\n  lPool: IIntfObjectPool;\n  lRpt: integer;\n  j: integer;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreateUnlimitedPool(0, 0, lCustomFactory);\n\n  for lRpt := 1 to 3 do\n  begin\n    for i := Low(lObjs) to High(lObjs) do\n    begin\n      lObjs[i] := lPool.GetFromPool as IPoolObject;\n    end;\n\n    for i := 1 to 5 do\n    begin\n      Assert.IsTrue(nil <> lObjs[i]);\n      for j := i + 1 to 5 do\n      begin\n        Assert.IsTrue(lObjs[i] <> lObjs[j]);\n      end;\n    end;\n\n    GNumReleased := 0;\n\n    for i := 1 to 5 do\n    begin\n      lPool.ReleaseToPool(lObjs[i]);\n    end;\n\n    Assert.AreEqual(0, GNumReleased);\n  end;\n  // lPool := nil; //actually releases internal instances\n  // Assert.AreEqual(5, GNumReleased);\nend;\n\nprocedure TTestTIntfObjectPool.TestMultiThreading;\nvar\n  lPool: IIntfObjectPool;\n  i: integer;\n  lCount: Int64;\n  lMax: Int64;\n  lCustomFactory: TCustomInterfaceCreator;\nconst\n  POOL_SIZE = 10;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfPoolFactory.CreatePool(POOL_SIZE, 10, 0, lCustomFactory);\n  lCount := 100;\n  lMax := lCount;\n  for i := 1 to lMax do\n  begin\n    TThread.CreateAnonymousThread(\n      procedure\n      var\n        j: integer;\n        lObj: IPoolObject;\n      begin\n        for j := 1 to 2 do\n        begin\n          repeat\n            Sleep(1);\n            lObj := lPool.GetFromPool as IPoolObject;\n          until Assigned(lObj);\n          try\n            Sleep(1);\n          finally\n            lPool.ReleaseToPool(lObj);\n          end;\n        end;\n        TInterlocked.Decrement(lCount);\n      end).Start;\n  end;\n\n  while TInterlocked.Read(lCount) > 0 do\n  begin\n    TThread.Sleep(100);\n  end;\n\n  Assert.AreEqual(POOL_SIZE, lPool.Size);\n\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestNotRaiseExceptionWhenPoolIsEmpty;\nvar\n  lPool: IIntfObjectPool;\n  lObj1, lObj2: IPoolObject;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lObj1 := nil;\n  lObj2 := nil;\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(2, 0, 0, lCustomFactory);\n  try\n    lObj1 := lPool.GetFromPool(False) as IPoolObject;\n    lObj2 := lPool.GetFromPool(False) as IPoolObject;\n    Assert.IsNull(lPool.GetFromPool(False));\n  finally\n    lPool.ReleaseToPool(lObj1);\n    lPool.ReleaseToPool(lObj2);\n  end;\n\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestRaiseExceptionWhenPoolIsEmpty;\nvar\n  lPool: IIntfObjectPool;\n  lObj1, lObj2: IPoolObject;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lObj1 := nil;\n  lObj2 := nil;\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(2, 0, 0, lCustomFactory);\n  try\n    lObj1 := lPool.GetFromPool(True) as IPoolObject;\n    lObj2 := lPool.GetFromPool(True) as IPoolObject;\n    Assert.WillRaise(\n      procedure\n      begin\n        lPool.GetFromPool(True);\n      end, EObjectPool);\n  finally\n    lPool.ReleaseToPool(lObj1);\n    lPool.ReleaseToPool(lObj2);\n  end;\n  lPool := nil;\nend;\n\nprocedure TTestTIntfObjectPool.TestFactory;\nvar\n  lPoolObject: IPoolObject;\n  lPool: TIntfObjectPool;\n  lCustomFactory: TCustomInterfaceCreator;\nbegin\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create();\n    end;\n  lPool := TIntfObjectPool.Create(0, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(1, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lPool := TIntfObjectPool.Create(3, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(1, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lCustomFactory := function: IInterface\n    begin\n      Result := TPoolObject.Create(79);\n    end;\n\n  lPool := TIntfObjectPool.Create(0, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(79, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\n\n  lPool := TIntfObjectPool.Create(3, 0, 0, lCustomFactory);\n  try\n    lPoolObject := lPool.GetFromPool as IPoolObject;\n    Assert.AreEqual(79, TPoolObject(lPoolObject).value);\n  finally\n    FreeAndNil(lPool);\n  end;\nend;\n\n{ TPoolObject }\n\nconstructor TPoolObject.Create;\nbegin\n  Create(1);\nend;\n\nconstructor TPoolObject.Create(value: integer);\nbegin\n  inherited Create;\n  FValue := value;\nend;\n\ndestructor TPoolObject.Destroy;\nbegin\n  Inc(GNumReleased);\n  inherited;\nend;\n\ninitialization\n\nGObjectPoolSamplingIntervalMS := 1000;\nTDUnitX.RegisterTestFixture(TTestTIntfObjectPool);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace Horse.Request\n{\n    #region Stub Types and Helpers\n\n    public class WebRequest\n    {\n        public string Content { get; set; } = \"\";\n        public byte[] RawContent { get; set; } = new byte[0];\n        public string Host { get; set; } = \"\";\n        public string ContentType { get; set; } = \"\";\n        public string PathInfo { get; set; } = \"\";\n        public List<WebFile> Files { get; set; } = new List<WebFile>();\n        public Dictionary<string, string> ContentFields { get; set; } = new Dictionary<string, string>();\n        public List<string> CookieFields { get; set; } = new List<string>();\n        public List<string> QueryFields { get; set; } = new List<string>();\n\n        public TWebRequestMethod MethodType { get; set; } = TWebRequestMethod.GET;\n        public string Method { get; set; } = \"GET\";\n    }\n\n    public class WebFile\n    {\n        public string FieldName { get; set; }\n        public Stream Stream { get; set; }\n    }\n\n    public enum TWebRequestMethod\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH,\n        OPTIONS\n    }\n\n    public class HorseCoreParam\n    {\n        public Dictionary<string, string> Dictionary { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public HorseCoreParam(List<string> list)\n        {\n            // Optionally use 'list' if needed.\n        }\n\n        public HorseCoreParam Required(bool req)\n        {\n            return this;\n        }\n\n        public void AddStream(string fieldName, Stream stream)\n        {\n            // Implementation depends on your requirements.\n            \n        }\n    }\n\n    public static class HorseCoreParamHeader\n    {\n        public static HorseCoreParam GetHeaders(WebRequest request)\n        {\n            return new HorseCoreParam(new List<string>());\n        }\n    }\n\n    public class HorseSessions\n    {\n        // Implement session handling as needed.\n    }\n\n    #endregion\n\n    public class HorseRequest : IDisposable\n    {\n        private WebRequest _webRequest;\n        private HorseCoreParam _headers;\n        private HorseCoreParam _query;\n        private HorseCoreParam _params;\n        private HorseCoreParam _contentFields;\n        private HorseCoreParam _cookie;\n        private object _body;\n        private object _session;\n        private HorseSessions _sessions;\n\n        public HorseRequest(WebRequest webRequest)\n        {\n            _webRequest = webRequest;\n            _sessions = new HorseSessions();\n        }\n\n        public virtual string Body()\n        {\n            return _webRequest.Content;\n        }\n\n        public T Body<T>() where T : class\n        {\n            return _body as T;\n        }\n\n        public virtual HorseRequest Body(object body)\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _body = body;\n            return this;\n        }\n\n        public virtual string Body(Encoding encoding)\n        {\n            if (_webRequest.RawContent != null && _webRequest.RawContent.Length > 0)\n            {\n                return encoding.GetString(_webRequest.RawContent);\n            }\n            else\n            {\n                return _webRequest.Content;\n            }\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        public virtual HorseCoreParam Headers()\n        {\n            if (_headers == null)\n            {\n                _headers = new HorseCoreParam(HorseCoreParamHeader.GetHeaders(_webRequest).Dictionary.ToList()).Required(false);\n            }\n            return _headers;\n        }\n\n        public virtual HorseCoreParam Query()\n        {\n            if (_query == null)\n                InitializeQuery();\n            return _query;\n        }\n\n        public virtual HorseCoreParam Params()\n        {\n            if (_params == null)\n                InitializeParams();\n            return _params;\n        }\n\n        public virtual HorseCoreParam Cookie()\n        {\n            if (_cookie == null)\n                InitializeCookie();\n            return _cookie;\n        }\n\n        public virtual HorseCoreParam ContentFields()\n        {\n            if (_contentFields == null)\n                InitializeContentFields();\n            return _contentFields;\n        }\n\n        public virtual HorseSessions Sessions()\n        {\n            return _sessions;\n        }\n\n        public virtual TWebRequestMethod MethodType()\n        {\n            return _webRequest.MethodType;\n        }\n\n        public virtual string ContentType()\n        {\n            return _webRequest.ContentType;\n        }\n\n        public virtual string Host()\n        {\n            return _webRequest.Host;\n        }\n\n        public virtual string PathInfo()\n        {\n            string prefix = string.IsNullOrEmpty(_webRequest.PathInfo) ? \"/\" : \"/\";\n            return prefix + _webRequest.PathInfo;\n        }\n\n        public virtual WebRequest RawWebRequest()\n        {\n            return _webRequest;\n        }\n\n        #region Initialization Methods\n\n        private void InitializeQuery()\n        {\n            _query = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var item in _webRequest.QueryFields)\n            {\n                int equalPos = item.IndexOf('=');\n                if (equalPos > 0)\n                {\n                    string key = item.Substring(0, equalPos);\n                    string value = item.Substring(equalPos + 1);\n                    if (!_query.Dictionary.ContainsKey(key))\n                        _query.Dictionary[key] = value;\n                    else\n                        _query.Dictionary[key] = _query.Dictionary[key] + \",\" + value;\n                }\n            }\n        }\n\n        private void InitializeParams()\n        {\n            _params = new HorseCoreParam(new List<string>()).Required(true);\n        }\n\n        private void InitializeContentFields()\n        {\n            _contentFields = new HorseCoreParam(new List<string>()).Required(false);\n            if (!CanLoadContentFields())\n                return;\n\n            foreach (var file in _webRequest.Files)\n            {\n                _contentFields.AddStream(file.FieldName, file.Stream);\n            }\n\n            foreach (var kvp in _webRequest.ContentFields)\n            {\n                string name = kvp.Key;\n                string value = kvp.Value;\n                if (!string.IsNullOrEmpty(name))\n                    _contentFields.Dictionary[name] = value;\n            }\n        }\n\n        private void InitializeCookie()\n        {\n            _cookie = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var cookieField in _webRequest.CookieFields)\n            {\n                var parts = cookieField.Split(new[] { '=' }, 2);\n                if (parts.Length >= 2)\n                    _cookie.Dictionary[parts[0]] = parts[1];\n            }\n        }\n\n        private bool CanLoadContentFields()\n        {\n            return IsMultipartForm() || IsFormURLEncoded();\n        }\n\n        private bool IsFormURLEncoded()\n        {\n            string contentType = _webRequest.ContentType;\n            string formUrlEncoded = \"application/x-www-form-urlencoded\";\n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(formUrlEncoded, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private bool IsMultipartForm()\n        {\n            string contentType = _webRequest.ContentType;\n            string multipart = \"multipart/form-data\";\n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(multipart, StringComparison.OrdinalIgnoreCase);\n        }\n\n        #endregion\n\n        public virtual HorseRequest Body(string body)\n        {\n            _body = body;\n            return this;\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public virtual T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        public override string ToString()\n        {\n            return Body();\n        }\n\n        public void Dispose()\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n        }\n    }\n}"}
{"input": "unit PersonBO;\n\ninterface\n\nuses\n  MVCFramework.Serializer.Commons;\n\ntype\n  [MVCNameCase(ncCamelCase)]\n  TPerson = class\n  private\n    FWORK_PHONE_NUMBER: String;\n    FEMAIL: String;\n    FFIRST_NAME: String;\n    FID: Integer;\n    FMOBILE_PHONE_NUMBER: String;\n    FLAST_NAME: String;\n    procedure SetEMAIL(const Value: String);\n    procedure SetFIRST_NAME(const Value: String);\n    procedure SetID(const Value: Integer);\n    procedure SetLAST_NAME(const Value: String);\n    procedure SetMOBILE_PHONE_NUMBER(const Value: String);\n    procedure SetWORK_PHONE_NUMBER(const Value: String);\n  public\n    property ID: Integer read FID write SetID;\n    property FIRST_NAME: String read FFIRST_NAME write SetFIRST_NAME;\n    property LAST_NAME: String read FLAST_NAME write SetLAST_NAME;\n    property WORK_PHONE_NUMBER: String read FWORK_PHONE_NUMBER write SetWORK_PHONE_NUMBER;\n    property MOBILE_PHONE_NUMBER: String read FMOBILE_PHONE_NUMBER write SetMOBILE_PHONE_NUMBER;\n    property EMAIL: String read FEMAIL write SetEMAIL;\n  end;\n\nimplementation\n\n{ TPerson }\n\nprocedure TPerson.SetEMAIL(const Value: String);\nbegin\n  FEMAIL := Value;\nend;\n\nprocedure TPerson.SetFIRST_NAME(const Value: String);\nbegin\n  FFIRST_NAME := Value;\nend;\n\nprocedure TPerson.SetID(const Value: Integer);\nbegin\n  FID := Value;\nend;\n\nprocedure TPerson.SetLAST_NAME(const Value: String);\nbegin\n  FLAST_NAME := Value;\nend;\n\nprocedure TPerson.SetMOBILE_PHONE_NUMBER(const Value: String);\nbegin\n  FMOBILE_PHONE_NUMBER := Value;\nend;\n\nprocedure TPerson.SetWORK_PHONE_NUMBER(const Value: String);\nbegin\n  FWORK_PHONE_NUMBER := Value;\nend;\n\nend.", "output": "[JsonProperty(\"id\")]\n    public int ID\n    {\n        get => _id;\n        set => _id = value;\n    }\n\n    [JsonProperty(\"firstName\")]\n    public string FIRST_NAME\n    {\n        get => _firstName;\n        set => _firstName = value;\n    }\n\n    [JsonProperty(\"lastName\")]\n    public string LAST_NAME\n    {\n        get => _lastName;\n        set => _lastName = value;\n    }\n\n    [JsonProperty(\"workPhoneNumber\")]\n    public string WORK_PHONE_NUMBER\n    {\n        get => _workPhoneNumber;\n        set => _workPhoneNumber = value;\n    }\n\n    [JsonProperty(\"mobilePhoneNumber\")]\n    public string MOBILE_PHONE_NUMBER\n    {\n        get => _mobilePhoneNumber;\n        set => _mobilePhoneNumber = value;\n    }\n\n    [JsonProperty(\"email\")]\n    public string EMAIL\n    {\n        get => _email;\n        set => _email = value;\n    }\n}"}
{"input": "unit Services.RegistrationU;\n\ninterface\n\nuses\n  MVCFramework.Container;\n\nprocedure RegisterServices(Container: IMVCServiceContainer);\n\nimplementation\n\nuses\n  Services.PeopleU, Services.InterfacesU, Services.ConnectionU;\n\nprocedure RegisterServices(Container: IMVCServiceContainer);\nbegin\n  Container.RegisterType(TPeopleService, IPeopleService);\n  Container.RegisterType(TConnectionService, IConnectionService, TRegistrationType.SingletonPerRequest)\nend;\n\nend.", "output": "using MVCFramework.Container;\nusing Services.PeopleU;\nusing Services.InterfacesU;\nusing Services.ConnectionU;\n\nnamespace Services.RegistrationU\n{\n    public static class ServicesRegistration\n    {\n        public static void RegisterServices(IMVCServiceContainer container)\n        {\n            container.RegisterType<IPeopleService, PeopleService>();\n            container.RegisterType<IConnectionService, ConnectionService>(RegistrationType.SingletonPerRequest);\n        }\n    }\n}"}
{"input": "unit BusinessObjectsU;\n\ninterface\n\ntype\n  TPerson = class\n  private\n    FLastName: String;\n    FDOB: TDate;\n    FFirstName: String;\n    FMarried: boolean;\n    procedure SetDOB(const Value: TDate);\n    procedure SetFirstName(const Value: String);\n    procedure SetLastName(const Value: String);\n    procedure SetMarried(const Value: boolean);\n  public\n    property FirstName: String read FFirstName write SetFirstName;\n    property LastName: String read FLastName write SetLastName;\n    property DOB: TDate read FDOB write SetDOB;\n    property Married: boolean read FMarried write SetMarried;\n  end;\n\nimplementation\n\n{ TPerson }\n\nprocedure TPerson.SetDOB(const Value: TDate);\nbegin\n  FDOB := Value;\nend;\n\nprocedure TPerson.SetFirstName(const Value: String);\nbegin\n  FFirstName := Value;\nend;\n\nprocedure TPerson.SetLastName(const Value: String);\nbegin\n  FLastName := Value;\nend;\n\nprocedure TPerson.SetMarried(const Value: boolean);\nbegin\n  FMarried := Value;\nend;\n\nend.", "output": "using System;\n\nnamespace BusinessObjectsU\n{\n    public class Person\n    {\n        private string _firstName;\n        private string _lastName;\n        private DateTime _dob;\n        private bool _married;\n\n        public string FirstName\n        {\n            get => _firstName;\n            set => SetFirstName(value);\n        }\n\n        public string LastName\n        {\n            get => _lastName;\n            set => SetLastName(value);\n        }\n\n        public DateTime DOB\n        {\n            get => _dob;\n            set => SetDOB(value);\n        }\n\n        public bool Married\n        {\n            get => _married;\n            set => SetMarried(value);\n        }\n\n        private void SetFirstName(string value)\n        {\n            _firstName = value;\n        }\n\n        private void SetLastName(string value)\n        {\n            _lastName = value;\n        }\n\n        private void SetDOB(DateTime value)\n        {\n            _dob = value;\n        }\n\n        private void SetMarried(bool value)\n        {\n            _married = value;\n        }\n    }\n}"}
{"input": "unit Horse.Response;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  fpHTTP,\n  HTTPDefs,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$IF CompilerVersion > 32.0}\n  Web.ReqMulti,\n{$ENDIF}\n{$ENDIF}\n  Horse.Commons,\n  Horse.Core.Files,\n  Horse.Mime;\n\ntype\n  THorseResponse = class\n  private\n    FWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF};\n    FContent: TObject;\n  public\n    function Send(const AContent: string): THorseResponse; overload; virtual;\n    function Send<T{$IF NOT DEFINED(FPC)}: class{$ENDIF}>(AContent: T): THorseResponse; overload;\n    function RedirectTo(const ALocation: string): THorseResponse; overload; virtual;\n    function RedirectTo(const ALocation: string; const AStatus: THTTPStatus): THorseResponse; overload; virtual;\n    function Status(const AStatus: Integer): THorseResponse; overload; virtual;\n    function Status(const AStatus: THTTPStatus): THorseResponse; overload; virtual;\n    function SendFile(const AFileStream: TStream; const AFileName: string = ''; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function SendFile(const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Download(const AFileStream: TStream; const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Download(const AFileName: string; const AContentType: string = ''): THorseResponse; overload; virtual;\n    function Render(const AFileStream: TStream; const AFileName: string): THorseResponse; overload; virtual;\n    function Render(const AFileName: string): THorseResponse; overload; virtual;\n    function Status: Integer; overload; virtual;\n    function AddHeader(const AName, AValue: string): THorseResponse; virtual;\n    function RemoveHeader(const AName: string): THorseResponse; virtual;\n    function Content: TObject; overload; virtual;\n    function Content(const AContent: TObject): THorseResponse; overload; virtual;\n    function ContentType(const AContentType: string): THorseResponse; virtual;\n    function RawWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF}; virtual;\n    constructor Create(const AWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF});\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseResponse.AddHeader(const AName, AValue: string): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader(AName, AValue);\n  Result := Self;\nend;\n\nfunction THorseResponse.Content(const AContent: TObject): THorseResponse;\nbegin\n  Result := Self;\n  FContent := AContent;\nend;\n\nfunction THorseResponse.Content: TObject;\nbegin\n  Result := FContent;\nend;\n\nfunction THorseResponse.ContentType(const AContentType: string): THorseResponse;\nbegin\n  FWebResponse.ContentType := AContentType;\n  Result := Self;\nend;\n\nconstructor THorseResponse.Create(const AWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF});\nbegin\n  FWebResponse := AWebResponse;\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := THTTPStatus.Ok.ToInteger;\n{$IF DEFINED(FPC)}\n  FWebResponse.FreeContentStream := True;\n{$ENDIF}\nend;\n\ndestructor THorseResponse.Destroy;\nbegin\n  if Assigned(FContent) then\n    FContent.Free;\n  inherited;\nend;\n\nfunction THorseResponse.RawWebResponse: {$IF DEFINED(FPC)}TResponse{$ELSE}TWebResponse{$ENDIF};\nbegin\n  Result := FWebResponse;\nend;\n\nfunction THorseResponse.Send(const AContent: string): THorseResponse;\nbegin\n  FWebResponse.Content := AContent;\n  Result := Self;\nend;\n\nfunction THorseResponse.Send<T>(AContent: T): THorseResponse;\nbegin\n  FContent := AContent;\n  Result := Self;\nend;\n\nfunction THorseResponse.RedirectTo(const ALocation: string): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader('Location', ALocation);\n  Result := Status(THTTPStatus.SeeOther);\nend;\n\nfunction THorseResponse.RedirectTo(const ALocation: string; const AStatus: THTTPStatus): THorseResponse;\nbegin\n  FWebResponse.SetCustomHeader('Location', ALocation);\n  Result := Status(AStatus);\nend;\n\nfunction THorseResponse.RemoveHeader(const AName: string): THorseResponse;\nvar\n  I: Integer;\nbegin\n  I := FWebResponse.CustomHeaders.IndexOfName(AName);\n  if I <> -1 then\n    FWebResponse.CustomHeaders.Delete(I);\n  Result := Self;\nend;\n\nfunction THorseResponse.Status(const AStatus: THTTPStatus): THorseResponse;\nbegin\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := AStatus.ToInteger;\n  Result := Self;\nend;\n\nfunction THorseResponse.SendFile(const AFileStream: TStream; const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFileName: string;\nbegin\n  Result := Self;\n  AFileStream.Position := 0;\n  LFileName := ExtractFileName(AFileName);\n\n  FWebResponse.FreeContentStream := False;\n  FWebResponse.ContentLength := AFileStream.Size;\n  FWebResponse.ContentStream := AFileStream;\n  FWebResponse.SetCustomHeader('Content-Disposition', Format('inline; filename=\"%s\"', [LFileName]));\n\n  FWebResponse.ContentType := AContentType;\n  if (AContentType = EmptyStr) then\n    FWebResponse.ContentType := Horse.Mime.THorseMimeTypes.GetFileType(LFileName);\n\n{$IF DEFINED(FPC)}\n  FWebResponse.SendContent;\n{$ELSE}\n  FWebResponse.SendResponse;\n{$ENDIF}\nend;\n\nfunction THorseResponse.SendFile(const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFile: THorseCoreFile;\n  LContentType: string;\nbegin\n  Result := Self;\n\n  LFile := THorseCoreFile.Create(AFileName);\n  LFile.FreeContentStream := True;\n  try\n    LContentType := AContentType;\n    if (AContentType = EmptyStr) then\n      LContentType := LFile.ContentType;\n    SendFile(LFile.ContentStream, LFile.Name, LContentType);\n  finally\n    LFile.Free;\n  end;\nend;\n\nfunction THorseResponse.Download(const AFileStream: TStream; const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFileName: string;\nbegin\n  Result := Self;\n  AFileStream.Position := 0;\n  LFileName := ExtractFileName(AFileName);\n\n  FWebResponse.FreeContentStream := False;\n  FWebResponse.ContentLength := AFileStream.Size;\n  FWebResponse.ContentStream := AFileStream;\n  FWebResponse.SetCustomHeader('Content-Disposition', Format('attachment; filename=\"%s\"', [LFileName]));\n\n  FWebResponse.ContentType := AContentType;\n  if (AContentType = EmptyStr) then\n    FWebResponse.ContentType := Horse.Mime.THorseMimeTypes.GetFileType(LFileName);\n\n{$IF DEFINED(FPC)}\n  FWebResponse.SendContent;\n{$ELSE}\n  FWebResponse.SendResponse;\n{$ENDIF}\nend;\n\nfunction THorseResponse.Download(const AFileName: string; const AContentType: string): THorseResponse;\nvar\n  LFile: THorseCoreFile;\n  LContentType: string;\nbegin\n  Result := Self;\n\n  LFile := THorseCoreFile.Create(AFileName);\n  LFile.FreeContentStream := True;\n  try\n    LContentType := AContentType;\n    if (AContentType = EmptyStr) then\n      LContentType := LFile.ContentType;\n    Download(LFile.ContentStream, LFile.Name, LContentType);\n  finally\n    LFile.Free;\n  end;\nend;\n\nfunction THorseResponse.Render(const AFileStream: TStream;\n  const AFileName: string): THorseResponse;\nbegin\n  Result := Self;\n  SendFile(AFileStream, AFileName, Horse.Commons.TMimeTypes.TextHTML.ToString);\nend;\n\nfunction THorseResponse.Render(const AFileName: string): THorseResponse;\nbegin\n  Result := Self;\n  SendFile(AFileName, Horse.Commons.TMimeTypes.TextHTML.ToString);\nend;\n\nfunction THorseResponse.Status: Integer;\nbegin\n  Result := {$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF};\nend;\n\nfunction THorseResponse.Status(const AStatus: Integer): THorseResponse;\nbegin\n{$IF DEFINED(FPC)}FWebResponse.Code{$ELSE}FWebResponse.StatusCode{$ENDIF} := AStatus;\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing Horse.Core.Files;      \nusing Horse.Mime;           \n\nnamespace Horse.Response\n{\n    \n    public class WebResponse\n    {\n        public string Content { get; set; }\n        public int StatusCode { get; set; }\n        public string ContentType { get; set; }\n        public long ContentLength { get; set; }\n        public Stream ContentStream { get; set; }\n        public bool FreeContentStream { get; set; }\n        public Dictionary<string, string> CustomHeaders { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public void SetCustomHeader(string name, string value)\n        {\n            CustomHeaders[name] = value;\n        }\n\n        public void SendResponse()\n        {\n            \n            Console.WriteLine(\"Response sent.\");\n        }\n    }\n\n    \n    public enum THTTPStatus\n    {\n        Ok = 200,\n        SeeOther = 303,\n        \n    }\n\n    public static class THTTPStatusExtensions\n    {\n        public static int ToInteger(this THTTPStatus status) => (int)status;\n    }\n\n    public class HorseResponse : IDisposable\n    {\n        private WebResponse _webResponse;\n        private object _content; \n\n        public HorseResponse(WebResponse webResponse)\n        {\n            _webResponse = webResponse;\n            _webResponse.StatusCode = THTTPStatus.Ok.ToInteger();\n            \n            _webResponse.FreeContentStream = true;\n        }\n\n        \n        public HorseResponse AddHeader(string name, string value)\n        {\n            _webResponse.SetCustomHeader(name, value);\n            return this;\n        }\n\n        \n        public HorseResponse Content(object content)\n        {\n            _content = content;\n            return this;\n        }\n\n        public object Content() => _content;\n\n       \n        public HorseResponse ContentType(string contentType)\n        {\n            _webResponse.ContentType = contentType;\n            return this;\n        }\n\n        \n        public WebResponse RawWebResponse() => _webResponse;\n\n        \n        public HorseResponse Send(string content)\n        {\n            _webResponse.Content = content;\n            return this;\n        }\n\n        \n        public HorseResponse Send<T>(T content) where T : class\n        {\n            _content = content;\n            return this;\n        }\n\n        \n        public HorseResponse RedirectTo(string location)\n        {\n            _webResponse.SetCustomHeader(\"Location\", location);\n            return Status(THTTPStatus.SeeOther);\n        }\n\n        \n        public HorseResponse RedirectTo(string location, THTTPStatus status)\n        {\n            _webResponse.SetCustomHeader(\"Location\", location);\n            return Status(status);\n        }\n\n        \n        public HorseResponse RemoveHeader(string name)\n        {\n            if (_webResponse.CustomHeaders.ContainsKey(name))\n                _webResponse.CustomHeaders.Remove(name);\n            return this;\n        }\n\n        \n        public HorseResponse Status(int status)\n        {\n            _webResponse.StatusCode = status;\n            return this;\n        }\n\n        \n        public HorseResponse Status(THTTPStatus status)\n        {\n            _webResponse.StatusCode = status.ToInteger();\n            return this;\n        }\n\n        \n        public HorseResponse SendFile(Stream fileStream, string fileName, string contentType)\n        {\n            fileStream.Position = 0;\n            string lFileName = System.IO.Path.GetFileName(fileName);\n            _webResponse.FreeContentStream = false;\n            _webResponse.ContentLength = fileStream.Length;\n            _webResponse.ContentStream = fileStream;\n            _webResponse.SetCustomHeader(\"Content-Disposition\", string.Format(\"inline; filename=\\\"{0}\\\"\", lFileName));\n            _webResponse.ContentType = contentType;\n            if (string.IsNullOrEmpty(contentType))\n                _webResponse.ContentType = Horse.Mime.HorseMimeTypes.GetFileType(lFileName);\n            _webResponse.SendResponse();\n            return this;\n        }\n\n        \n        public HorseResponse SendFile(string fileName, string contentType)\n        {\n            using (var file = new HorseCoreFile(fileName))\n            {\n                file.FreeContentStream = true;\n                string lContentType = contentType;\n                if (string.IsNullOrEmpty(contentType))\n                    lContentType = Horse.Mime.HorseMimeTypes.GetFileType(file.Name);\n                return SendFile(file.ContentStream, file.Name, lContentType);\n            }\n        }\n\n        \n        public HorseResponse Download(Stream fileStream, string fileName, string contentType)\n        {\n            fileStream.Position = 0;\n            string lFileName = System.IO.Path.GetFileName(fileName);\n            _webResponse.FreeContentStream = false;\n            _webResponse.ContentLength = fileStream.Length;\n            _webResponse.ContentStream = fileStream;\n            _webResponse.SetCustomHeader(\"Content-Disposition\", string.Format(\"attachment; filename=\\\"{0}\\\"\", lFileName));\n            _webResponse.ContentType = contentType;\n            if (string.IsNullOrEmpty(contentType))\n                _webResponse.ContentType = Horse.Mime.HorseMimeTypes.GetFileType(lFileName);\n            _webResponse.SendResponse();\n            return this;\n        }\n\n        \n        public HorseResponse Download(string fileName, string contentType)\n        {\n            using (var file = new HorseCoreFile(fileName))\n            {\n                file.FreeContentStream = true;\n                string lContentType = contentType;\n                if (string.IsNullOrEmpty(contentType))\n                    lContentType = Horse.Mime.HorseMimeTypes.GetFileType(file.Name);\n                return Download(file.ContentStream, file.Name, lContentType);\n            }\n        }\n\n        \n        public HorseResponse Render(Stream fileStream, string fileName)\n        {\n            return SendFile(fileStream, fileName, Horse.Commons.TMimeTypes.TextHTML.ToString());\n        }\n\n        \n        public HorseResponse Render(string fileName)\n        {\n            return SendFile(fileName, Horse.Commons.TMimeTypes.TextHTML.ToString());\n        }\n\n        \n        public int Status() => _webResponse.StatusCode;\n\n        public void Dispose()\n        {\n            if (_content is IDisposable disposable)\n            {\n                disposable.Dispose();\n            }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Cache;\n\n{$I dmvcframework.inc}\n\ninterface\n\nimplementation\n\nend.", "output": "namespace MVCFramework.View\n{\n    \n    public static class Cache\n    {\n        // No implementation provided.\n    }\n}"}
{"input": "unit SSEControllerU;\n\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.SSEController;\n\ntype\n  [MVCPath('/stocks')]\n  TMySSEController = class(TMVCSSEController)\n  protected\n    function GetServerSentEvents(const LastEventID: String): TMVCSSEMessages; override;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger, System.SysUtils, StorageU, System.DateUtils;\n\n{ TMySSEController }\n\nfunction TMySSEController.GetServerSentEvents(const LastEventID: String): TMVCSSEMessages;\nvar\n  lCurrentEventID: Integer;\n  lSSEMessage: TSSEMessage;\nbegin\n  Sleep(500 + Random(2000));\n  lSSEMessage.Event := 'stockupdate';\n  lSSEMessage.Data := GetNextDataToSend(StrToIntDef(LastEventID, 0), lCurrentEventID);\n  lSSEMessage.Id := lCurrentEventID.ToString;\n  Result := [\n    lSSEMessage\n  ];\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.SSEController;\nusing StorageU;\n\n[Route(\"stocks\")]\npublic class MySSEController : MVCSSEController\n{\n    protected override List<SSEMessage> GetServerSentEvents(string lastEventId)\n    {\n        Thread.Sleep(500 + new Random().Next(2000));\n        int currentEventId;\n        SSEMessage sseMessage = new SSEMessage();\n        sseMessage.Event = \"stockupdate\";\n        sseMessage.Data = Storage.GetNextDataToSend(ParseIntOrDefault(lastEventId, 0), out currentEventId);\n        sseMessage.Id = currentEventId.ToString();\n        return new List<SSEMessage> { sseMessage };\n    }\n\n    private int ParseIntOrDefault(string s, int defaultValue)\n    {\n        return int.TryParse(s, out int result) ? result : defaultValue;\n    }\n}"}
{"input": "// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ActiveRecordController;\n\ninterface\n\nuses\n  System.SysUtils,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.ActiveRecord,\n  FireDAC.Stan.Def,\n  FireDAC.Stan.Pool,\n  FireDAC.Stan.Async,\n  FireDAC.Comp.Client,\n  MVCFramework.RQL.Parser,\n  System.Generics.Collections,\n  MVCFramework.Serializer.Commons, MVCFramework.Swagger.Commons;\n\ntype\n{$SCOPEDENUMS ON}\n  TMVCActiveRecordAction = (Create, Retrieve, Update, Delete);\n  TMVCActiveRecordAuthFunc = TFunc<TWebContext, TMVCActiveRecordClass, TMVCActiveRecordAction, Boolean>;\n\n  TMVCActiveRecordController = class(TMVCController)\n  private\n    fAuthorization: TMVCActiveRecordAuthFunc;\n    fURLSegment: string;\n  protected\n    function GetMaxRecordCount: Integer;\n    function CheckAuthorization(aClass: TMVCActiveRecordClass; aAction: TMVCActiveRecordAction): Boolean; virtual;\n  public\n    constructor Create(\n      const aAuthorization: TMVCActiveRecordAuthFunc = nil;\n      const aURLSegment: String = ''); reintroduce; overload;\n    destructor Destroy; override;\n\n    function GetURLSegment: String;\n\n    [MVCPath('/($entityname)')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Retrieve a list of {singularmodel}', 'Get{pluralmodel}')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntities(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/searches')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Searches through {pluralmodel} and returns a list of {singularmodel}', 'Get{pluralmodel}BySearch')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntitiesByRQL(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/searches')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Searches through {pluralmodel} and returns a list of {singularmodel}', 'Get{pluralmodel}BySearchAsPOST')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'List of {singularmodel}', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plQuery, 'rql', 'RQL filter used to filter the list of {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, False)]\n    procedure GetEntitiesByRQLwithPOST(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Gets a {singularmodel} entity or 404 not found', 'Get{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'One {singularmodel}', SWAGUseDefaultControllerModel)]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    procedure GetEntity(const entityname: string; const id: Integer); virtual;\n\n    [MVCPath('/($entityname)')]\n    [MVCHTTPMethod([httpPOST])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Creates a {singularmodel} and returns a new id', 'Create{singularmodel}')]\n    [MVCSwagResponses(HTTP_STATUS.Created, 'One {singularmodel}', '')]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plBody, '{singularmodel}', 'A single entity of type {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, True)]\n    procedure CreateEntity(const entityname: string); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpPUT])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Updates a {singularmodel} by id', 'Update{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.OK, 'One {singularmodel}', SWAGUseDefaultControllerModel)]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    [MVCSwagParam(TMVCSwagParamLocation.plBody, '{singularmodel}', 'A single entity of type {singularmodel}', SWAGUseDefaultControllerModel, TMVCSwagParamType.ptString, True)]\n    procedure UpdateEntity(const entityname: string; const id: Integer); virtual;\n\n    [MVCPath('/($entityname)/($id)')]\n    [MVCHTTPMethod([httpDELETE])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'Deletes a {singularmodel} by id', 'Delete{singularmodel}ByID')]\n    [MVCSwagResponses(HTTP_STATUS.NoContent, '')]\n    [MVCSwagResponses(HTTP_STATUS.NotFound, 'Error', TMVCErrorResponse)]\n    [MVCSwagResponses(HTTP_STATUS.BadRequest, '', TMVCErrorResponse)]\n    procedure DeleteEntity(const entityname: string; const id: Integer); virtual;\n\n  end;\n\n  [MVCNameCase(ncLowerCase)]\n  TMVCActiveRecordListResponse = class\n  private\n    FList: TMVCActiveRecordList;\n    FMetadata: TMVCStringDictionary;\n    FOwns: Boolean;\n  public\n    constructor Create(AList: TMVCActiveRecordList; AOwns: Boolean = True); virtual;\n    destructor Destroy; override;\n    [MVCListOf(TMVCActiveRecord)]\n    [MVCNameAs('data')]\n    property Items: TMVCActiveRecordList read FList;\n    [MVCNameAs('meta')]\n    property Metadata: TMVCStringDictionary read FMetadata;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger,\n  JsonDataObjects,\n  Data.DB;\n\nprocedure TMVCActiveRecordController.GetEntities(const entityname: string);\nvar\n  lARClassRef: TMVCActiveRecordClass;\n  lRQL: string;\n  lInstance: TMVCActiveRecord;\n  lMapping: TMVCFieldsMapping;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\n  lARResp: TMVCActiveRecordList;\n  lStrDict : TMVCStringDictionary;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.GetEntities(Context, self, entityname, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClassRef) then\n  begin\n    raise EMVCException.CreateFmt('Cannot find entity nor processor for entity \"%s\"', [entityname]);\n  end;\n  if not CheckAuthorization(lARClassRef, TMVCActiveRecordAction.Retrieve) then\n  begin\n    Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot read ' + entityname));\n    Exit;\n  end;\n\n  lRQL := Context.Request.QueryStringParam('rql');\n  try\n    LogD('[RQL PARSE]: ' + lRQL);\n    lInstance := lARClassRef.Create(True);\n    try\n      lMapping := lInstance.GetMapping;\n    finally\n      lInstance.Free;\n    end;\n\n    lARResp := TMVCActiveRecord.SelectRQL(lARClassRef, lRQL, GetMaxRecordCount);\n    try\n      lStrDict := StrDict(['page_size'],[lARResp.Count.ToString]);\n      try\n        if Context.Request.QueryStringParam('count').ToLower = 'true' then\n        begin\n          lStrDict.Add('count', TMVCActiveRecord.Count(lARClassRef, lRQL).ToString);\n        end;\n        Render(ObjectDict(False)\n          .Add('data', lARResp,\n            procedure(const AObject: TObject; const Links: IMVCLinks)\n            begin\n              //Links.AddRefLink.Add(HATEOAS.HREF, fURLSegment + '/' + )\n              case TMVCActiveRecord(AObject).GetPrimaryKeyFieldType of\n                ftInteger:\n                  Links.AddRefLink.Add(HATEOAS.HREF, fURLSegment + '/' + TMVCActiveRecord(AObject).GetPK.AsInt64.ToString)\n              end;\n            end)\n          .Add('meta', lStrDict));\n      finally\n        lStrDict.Free;\n      end;\n    finally\n      lARResp.Free;\n    end;\n\n  except\n    on E: ERQLCompilerNotFound do\n    begin\n      LogE('RQL Compiler not found. Did you included MVCFramework.RQL.AST2<yourdatabase>.pas?');\n      raise;\n    end;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.GetEntitiesByRQL(const entityname: string);\nbegin\n  GetEntities(entityname);\nend;\n\nprocedure TMVCActiveRecordController.GetEntitiesByRQLwithPOST(const entityname: string);\nvar\n  lRQL: string;\n  lJSON: TJsonObject;\nbegin\n  lJSON := TJsonObject.Parse(Context.Request.Body) as TJsonObject;\n  try\n    if Assigned(lJSON) then\n    begin\n      lRQL := lJSON.s['rql'];\n    end\n    else\n    begin\n      lRQL := '';\n    end;\n  finally\n    lJSON.Free;\n  end;\n  Context.Request.QueryStringParams.Values['rql'] := lRQL;\n  GetEntities(entityname);\nend;\n\n\nprocedure TMVCActiveRecordController.GetEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\n  lResponse: IMVCResponse;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.GetEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Retrieve) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot read ' + entityname));\n      Exit;\n    end;\n\n    if lAR.LoadByPK(id) then\n    begin\n      lResponse := MVCResponseBuilder\n          .StatusCode(HTTP_STATUS.OK)\n          .Body(ObjectDict(false).Add('data', lAR))\n          .Build;\n    end\n    else\n    begin\n      lResponse := MVCResponseBuilder\n          .StatusCode(HTTP_STATUS.NotFound)\n          .Body(entityname.ToLower + ' not found')\n          .Build;\n    end;\n    TMVCRenderer.InternalRenderMVCResponse(Self, TMVCResponse(lResponse));\n  finally\n    lAR.Free;\n  end;\nend;\n\nfunction TMVCActiveRecordController.GetMaxRecordCount: Integer;\nbegin\n  Result := StrToIntDef(Config[TMVCConfigKey.MaxEntitiesRecordCount], 20);\nend;\n\nfunction TMVCActiveRecordController.GetURLSegment: String;\nbegin\n  Result := fURLSegment;\nend;\n\nfunction TMVCActiveRecordController.CheckAuthorization(aClass: TMVCActiveRecordClass;\n  aAction: TMVCActiveRecordAction): Boolean;\nbegin\n  if Assigned(fAuthorization) then\n  begin\n    Result := fAuthorization(Context, aClass, aAction);\n  end\n  else\n  begin\n    Result := True;\n  end;\nend;\n\nconstructor TMVCActiveRecordController.Create(\n  const aAuthorization: TMVCActiveRecordAuthFunc;\n  const aURLSegment: String);\nbegin\n  inherited Create;\n  fURLSegment := aURLSegment;\n  fAuthorization := aAuthorization;\nend;\n\nprocedure TMVCActiveRecordController.CreateEntity(const entityname: string);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.CreateEntity(Context, self, entityname, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Create) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot create ' + entityname));\n      Exit;\n    end;\n\n    Context.Request.BodyFor<TMVCActiveRecord>(lAR);\n    lAR.Insert;\n    Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo + '/' + lAR.GetPK.AsInt64.ToString;\n    if Context.Request.QueryStringParam('refresh').ToLower = 'true' then\n    begin\n      RenderStatusMessage(HTTP_STATUS.Created, entityname.ToLower + ' created', '', lAR, False);\n    end\n    else\n    begin\n      RenderStatusMessage(HTTP_STATUS.Created, entityname.ToLower + ' created');\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.UpdateEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.UpdateEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find class for entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType), TMVCActiveRecordAction.Update) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot update ' + entityname));\n      Exit;\n    end;\n    lAR.CheckAction(TMVCEntityAction.eaUpdate);\n    if not lAR.LoadByPK(id) then\n      raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find entity %s', [entityname]);\n    Context.Request.BodyFor<TMVCActiveRecord>(lAR);\n    lAR.SetPK(id);\n    lAR.Update;\n    Context.Response.CustomHeaders.Values['X-REF'] := Context.Request.PathInfo;\n    if Context.Request.QueryStringParam('refresh').ToLower = 'true' then\n    begin\n      RenderStatusMessage(HTTP_STATUS.OK, entityname.ToLower + ' updated', '', lAR, False);\n    end\n    else\n    begin\n      RenderStatusMessage(HTTP_STATUS.OK, entityname.ToLower + ' updated');\n    end;\n  finally\n    lAR.Free;\n  end;\nend;\n\nprocedure TMVCActiveRecordController.DeleteEntity(const entityname: string; const id: Integer);\nvar\n  lAR: TMVCActiveRecord;\n  lARClass: TMVCActiveRecordClass;\n  lProcessor: IMVCEntityProcessor;\n  lHandled: Boolean;\nbegin\n  lProcessor := nil;\n  if ActiveRecordMappingRegistry.FindProcessorByURLSegment(entityname, lProcessor) then\n  begin\n    lHandled := False;\n    lProcessor.DeleteEntity(Context, self, entityname, id, lHandled);\n    if lHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  if not ActiveRecordMappingRegistry.FindEntityClassByURLSegment(entityname, lARClass) then\n  begin\n    raise EMVCException.CreateFmt(HTTP_STATUS.NotFound, 'Cannot find class for entity %s', [entityname]);\n  end;\n  lAR := lARClass.Create;\n  try\n    if not CheckAuthorization(TMVCActiveRecordClass(lAR.ClassType),\n      TMVCActiveRecordAction.Delete) then\n    begin\n      Render(TMVCErrorResponse.Create(HTTP_STATUS.Forbidden, 'Cannot delete ' + entityname));\n      Exit;\n    end;\n    {\n      HTTP DELETE is an idempotent operation. Invoking it multiple times consecutively must result in\n      the same behavior as the first. Meaning: you shouldn't return HTTP 404.\n    }\n    if lAR.LoadByPK(id) then\n    begin\n      lAR.SetPK(id);\n      lAR.Delete;\n    end;\n    Render(HTTP_STATUS.OK, entityname.ToLower + ' deleted');\n  finally\n    lAR.Free;\n  end;\nend;\n\ndestructor TMVCActiveRecordController.Destroy;\nbegin\n  inherited;\nend;\n\n{ TObjectListSetHolder }\n\nconstructor TMVCActiveRecordListResponse.Create(AList: TMVCActiveRecordList; AOwns: Boolean = True);\nbegin\n  inherited Create;\n  FOwns := AOwns;\n  FList := AList;\n  FMetadata := TMVCStringDictionary.Create;\nend;\n\ndestructor TMVCActiveRecordListResponse.Destroy;\nbegin\n  if FOwns then\n  begin\n    FList.Free\n  end;\n  FMetadata.Free;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing MVCFramework.ActiveRecord; \nusing MVCFramework.Commons;\nusing MVCFramework.Swagger.Commons; \n\nnamespace MVCFramework.ActiveRecordController\n{\n    \n    public delegate bool MVCActiveRecordAuthFunc(\n        WebContext context, \n        Type activeRecordType, \n        MVCActiveRecordAction action);\n\n    \n    public enum MVCActiveRecordAction\n    {\n        Create,\n        Retrieve,\n        Update,\n        Delete\n    }\n\n    \n    [ApiController]\n    [Route(\"[controller]\")]\n    public class MVCActiveRecordController : ControllerBase\n    {\n        private readonly ILogger<MVCActiveRecordController> _logger;\n        private readonly MVCActiveRecordAuthFunc _authorization;\n        private readonly string _urlSegment;\n\n        public MVCActiveRecordController(ILogger<MVCActiveRecordController> logger,\n                                           MVCActiveRecordAuthFunc authorization = null,\n                                           string urlSegment = \"\")\n        {\n            _logger = logger;\n            _authorization = authorization;\n            _urlSegment = urlSegment;\n        }\n\n        protected virtual int GetMaxRecordCount()\n        {\n            \n            return 20;\n        }\n\n        protected virtual bool CheckAuthorization(Type activeRecordType, MVCActiveRecordAction action)\n        {\n            if (_authorization != null)\n            {\n                return _authorization(new WebContext(HttpContext), activeRecordType, action);\n            }\n            return true;\n        }\n\n        [HttpGet(\"{entityname}\")]\n        public IActionResult GetEntities(string entityname)\n        {\n            try\n            {\n                \n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.GetEntities(new WebContext(HttpContext), this, entityname, ref handled);\n                    if (handled)\n                    {\n                        return Ok();\n                    }\n                }\n\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity nor processor for entity '{entityname}'.\");\n                }\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Retrieve))\n                {\n                    return Forbid(\"Not authorized to read \" + entityname);\n                }\n\n                string rql = Request.Query[\"rql\"];\n                _logger.LogDebug(\"[RQL PARSE]: {RQL}\", rql);\n\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType, true);\n                var mapping = arInstance.GetMapping();\n\n                var arList = MVCActiveRecord.SelectRQL(arType, rql, GetMaxRecordCount());\n\n                var meta = new Dictionary<string, string>\n                {\n                    [\"page_size\"] = arList.Count.ToString()\n                };\n                if (Request.Query[\"count\"].ToString().ToLower() == \"true\")\n                {\n                    meta.Add(\"count\", MVCActiveRecord.Count(arType, rql).ToString());\n                }\n\n                var response = new\n                {\n                    data = arList,\n                    meta = meta\n                };\n                return Ok(response);\n            }\n            catch (RQLCompilerNotFoundException ex)\n            {\n                _logger.LogError(ex, \"RQL Compiler not found. Did you include the appropriate RQL parser?\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error retrieving entities for {EntityName}\", entityname);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpGet(\"{entityname}/searches\")]\n        public IActionResult GetEntitiesByRQL(string entityname)\n        {\n            return GetEntities(entityname);\n        }\n\n        [HttpPost(\"{entityname}/searches\")]\n        public IActionResult GetEntitiesByRQLwithPOST(string entityname, [FromBody] dynamic body)\n        {\n            string rql = body?.rql ?? \"\";\n            Request.QueryString = new Microsoft.AspNetCore.Http.QueryString(\"?rql=\" + Uri.EscapeDataString(rql));\n            return GetEntities(entityname);\n        }\n\n        [HttpGet(\"{entityname}/{id:int}\")]\n        public IActionResult GetEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.GetEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Retrieve))\n                {\n                    return Forbid(\"Not authorized to read \" + entityname);\n                }\n                if (arInstance.LoadByPK(id))\n                {\n                    return Ok(new { data = arInstance });\n                }\n                else\n                {\n                    return NotFound($\"{entityname.ToLower()} not found\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error retrieving entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPost(\"{entityname}\")]\n        public IActionResult CreateEntity(string entityname)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.CreateEntity(new WebContext(HttpContext), this, entityname, ref handled);\n                    if (handled)\n                        return Created(\"\", null);\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Create))\n                {\n                    return Forbid(\"Not authorized to create \" + entityname);\n                }\n\n                Request.BindBody(arInstance);\n\n                arInstance.Insert();\n                Response.Headers[\"X-REF\"] = $\"{Request.Path}/{arInstance.GetPK().ToString()}\";\n                if (Request.Query[\"refresh\"].ToString().ToLower() == \"true\")\n                {\n                    return Created(Request.Path, arInstance);\n                }\n                else\n                {\n                    return Created(Request.Path, null);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating entity {EntityName}\", entityname);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpPut(\"{entityname}/{id:int}\")]\n        public IActionResult UpdateEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.UpdateEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find class for entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Update))\n                {\n                    return Forbid(\"Not authorized to update \" + entityname);\n                }\n                if (!arInstance.LoadByPK(id))\n                {\n                    return NotFound($\"Cannot find entity {entityname}\");\n                }\n                Request.BindBody(arInstance);\n                arInstance.SetPK(id);\n                arInstance.Update();\n                Response.Headers[\"X-REF\"] = Request.Path;\n                if (Request.Query[\"refresh\"].ToString().ToLower() == \"true\")\n                {\n                    return Ok(new { data = arInstance });\n                }\n                else\n                {\n                    return Ok($\"{entityname.ToLower()} updated\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n\n        [HttpDelete(\"{entityname}/{id:int}\")]\n        public IActionResult DeleteEntity(string entityname, int id)\n        {\n            try\n            {\n                if (ActiveRecordMappingRegistry.Instance.TryGetProcessor(entityname, out var processor))\n                {\n                    bool handled = false;\n                    processor.DeleteEntity(new WebContext(HttpContext), this, entityname, id, ref handled);\n                    if (handled)\n                        return Ok();\n                }\n                if (!ActiveRecordMappingRegistry.Instance.TryGetEntityClass(entityname, out Type arType))\n                {\n                    return NotFound($\"Cannot find class for entity {entityname}\");\n                }\n                var arInstance = (MVCActiveRecord)Activator.CreateInstance(arType);\n                if (!CheckAuthorization(arType, MVCActiveRecordAction.Delete))\n                {\n                    return Forbid(\"Not authorized to delete \" + entityname);\n                }\n                if (arInstance.LoadByPK(id))\n                {\n                    arInstance.SetPK(id);\n                    arInstance.Delete();\n                }\n                return Ok($\"{entityname.ToLower()} deleted\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting entity {EntityName} with ID {Id}\", entityname, id);\n                return BadRequest(ex.Message);\n            }\n        }\n    }\n\n    \n    public class MVCActiveRecordListResponse\n    {\n        public TMVCActiveRecordList Items { get; }\n        public Dictionary<string, string> Metadata { get; }\n        public bool Owns { get; }\n\n        public MVCActiveRecordListResponse(TMVCActiveRecordList list, bool owns = true)\n        {\n            Items = list;\n            Owns = owns;\n            Metadata = new Dictionary<string, string>();\n        }\n    }\n\n    #region Stub Types and Extensions\n\n    \n    public class WebContext\n    {\n        public Microsoft.AspNetCore.Http.HttpContext HttpContext { get; }\n        public WebContext(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            HttpContext = httpContext;\n        }\n    }\n\n    \n    public class ActiveRecordMappingRegistry\n    {\n        private static readonly ActiveRecordMappingRegistry _instance = new ActiveRecordMappingRegistry();\n        public static ActiveRecordMappingRegistry Instance => _instance;\n\n        private readonly Dictionary<string, Type> _entityMap = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);\n        private readonly Dictionary<string, IMVCEntityProcessor> _processorMap = new Dictionary<string, IMVCEntityProcessor>(StringComparer.OrdinalIgnoreCase);\n\n        public bool TryGetEntityClass(string urlSegment, out Type activeRecordType)\n        {\n            return _entityMap.TryGetValue(urlSegment.ToLower(), out activeRecordType);\n        }\n\n        public bool TryGetProcessor(string urlSegment, out IMVCEntityProcessor processor)\n        {\n            return _processorMap.TryGetValue(urlSegment.ToLower(), out processor);\n        }\n\n        \n    }\n\n    \n    public class TMVCActiveRecordList : List<MVCActiveRecord>\n    {\n    }\n\n    \n    public static class RequestExtensions\n    {\n        public static void BindBody<T>(this Microsoft.AspNetCore.Http.HttpRequest request, T instance)\n        {\n            \n            // This is just a stub.\n        }\n    }\n\n    #endregion\n}"}
{"input": "unit MainWMU;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TMyWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TMyWebModule;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  LogsCollectorControllerU,\n  System.IOUtils,\n  MVCFramework.Commons;\n\nprocedure TMyWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      Config[TMVCConfigKey.SessionTimeout] := '0';\n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'false';\n    end);\n  FMVC.AddController(TLogsCollectorController);\nend;\n\nprocedure TMyWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing System;\n\nnamespace MyWebModuleApp\n{\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            \n            var builder = WebApplication.CreateBuilder(args);\n\n            \n            builder.Services.AddControllersWithViews();\n\n            \n            var app = builder.Build();\n\n            if (!app.Environment.IsDevelopment())\n            {\n                app.UseExceptionHandler(\"/Home/Error\");\n            }\n\n            app.UseStaticFiles();\n\n            app.UseRouting();\n\n            app.MapControllerRoute(\n                name: \"default\",\n                pattern: \"{controller=LogsCollector}/{action=Index}/{id?}\");\n\n            app.MapGet(\"/\", () => \"Welcome to the Municipal Logs Collector API\");\n\n            Console.WriteLine(\"Web module started on: \");\n            foreach (var url in app.Urls)\n            {\n                Console.WriteLine(url);\n            }\n\n            app.Run();\n        }\n    }\n}"}
{"input": "unit Horse.Request;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils,\n  Classes,\n  fpHTTP,\n  HTTPDefs,\n{$ELSE}\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n{$IF CompilerVersion > 32.0}\n  Web.ReqMulti,\n{$ENDIF}\n{$ENDIF}\n  Horse.Core.Param,\n  Horse.Core.Param.Header,\n  Horse.Commons,\n  Horse.Session;\n\ntype\n  THorseRequest = class\n  private\n    FWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\n    FHeaders: THorseCoreParam;\n    FQuery: THorseCoreParam;\n    FParams: THorseCoreParam;\n    FContentFields: THorseCoreParam;\n    FCookie: THorseCoreParam;\n    FBody: TObject;\n    FSession: TObject;\n    FSessions: THorseSessions;\n    procedure InitializeQuery;\n    procedure InitializeParams;\n    procedure InitializeContentFields;\n    procedure InitializeCookie;\n    function IsMultipartForm: Boolean;\n    function IsFormURLEncoded: Boolean;\n    function CanLoadContentFields: Boolean;\n  public\n    function Body: string; overload; virtual;\n    function Body<T: class>: T; overload;\n    function Body(const ABody: TObject): THorseRequest; overload; virtual;\n    function Body(const Encoding: TEncoding): string; overload; virtual;\n    function Session<T: class>: T; overload;\n    function Session(const ASession: TObject): THorseRequest; overload; virtual;\n    function Headers: THorseCoreParam; virtual;\n    function Query: THorseCoreParam; virtual;\n    function Params: THorseCoreParam; virtual;\n    function Cookie: THorseCoreParam; virtual;\n    function ContentFields: THorseCoreParam; virtual;\n    function Sessions: THorseSessions; virtual;\n    function MethodType: TMethodType; virtual;\n    function ContentType: string; virtual;\n    function Host: string; virtual;\n    function PathInfo: string; virtual;\n    function RawWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF}; virtual;\n    constructor Create(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF});\n    destructor Destroy; override;\n  end;\n\nimplementation\n\nfunction THorseRequest.Body: string;\nbegin\n  Result := FWebRequest.Content;\nend;\n\nfunction THorseRequest.Body(const ABody: TObject): THorseRequest;\nbegin\n  Result := Self;\n  if Assigned(FBody) then\n    FBody.Free;\n  FBody := ABody;\nend;\n\nfunction THorseRequest.Body(const Encoding: TEncoding): string;\n{$IF DEFINED(FPC)}\nvar\n  lContent: TStringStream;\n{$ENDIF}\nbegin\n  {$IF DEFINED(FPC)}\n  try\n    lContent := TStringStream.Create(FWebRequest.Content, Encoding);\n    Result   := lContent.DataString;\n  finally\n    lContent.Free;\n  end;\n  {$ELSE}\n  {$IF CompilerVersion <= 31.0}\n  Result := Encoding.GetString(BytesOf(FWebRequest.RawContent));\n  {$ELSE}\n  Result := Encoding.GetString(FWebRequest.RawContent);\n  {$ENDIF}\n  {$ENDIF}\nend;\n\nfunction THorseRequest.Body<T>: T;\nbegin\n  Result := T(FBody);\nend;\n\nfunction THorseRequest.CanLoadContentFields: Boolean;\nbegin\n  Result := IsMultipartForm or IsFormURLEncoded;\nend;\n\nfunction THorseRequest.ContentFields: THorseCoreParam;\nbegin\n  if not Assigned(FContentFields) then\n    InitializeContentFields;\n  Result := FContentFields;\nend;\n\nfunction THorseRequest.Cookie: THorseCoreParam;\nbegin\n  if not Assigned(FCookie) then\n    InitializeCookie;\n  Result := FCookie;\nend;\n\nconstructor THorseRequest.Create(const AWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF});\nbegin\n  FWebRequest := AWebRequest;\n  FSessions := THorseSessions.Create;\nend;\n\ndestructor THorseRequest.Destroy;\nbegin\n  if Assigned(FHeaders) then\n    FreeAndNil(FHeaders);\n  if Assigned(FQuery) then\n    FreeAndNil(FQuery);\n  if Assigned(FParams) then\n    FreeAndNil(FParams);\n  if Assigned(FContentFields) then\n    FreeAndNil(FContentFields);\n  if Assigned(FCookie) then\n    FreeAndNil(FCookie);\n  if Assigned(FBody) then\n    FBody.Free;\n  if Assigned(FSessions) then\n    FSessions.Free;\n  inherited;\nend;\n\nfunction THorseRequest.Headers: THorseCoreParam;\nvar\n  LParam: THorseList;\nbegin\n  if not Assigned(FHeaders) then\n  begin\n    LParam := THorseCoreParamHeader.GetHeaders(FWebRequest);\n    FHeaders := THorseCoreParam.Create(LParam).Required(False);\n  end;\n  Result := FHeaders;\nend;\n\nfunction THorseRequest.Host: string;\nbegin\n  Result := FWebRequest.Host;\nend;\n\nfunction THorseRequest.ContentType: string;\nbegin\n  Result := FWebRequest.ContentType;\nend;\n\nfunction THorseRequest.PathInfo: string;\nvar\n  LPrefix: string;\nbegin\n  LPrefix := EmptyStr;\n  if FWebRequest.PathInfo = EmptyStr then\n    LPrefix := '/';\n  Result := LPrefix + FWebRequest.PathInfo;\nend;\n\nprocedure THorseRequest.InitializeContentFields;\n{$IF NOT DEFINED(FPC)}\nconst\n  CONTENT_DISPOSITION = 'Content-Disposition: form-data; name=';\n{$ENDIF}\nvar\n  I: Integer;\n  LName: String;\n  LValue: String;\nbegin\n  FContentFields := THorseCoreParam.Create(THorseList.Create).Required(False);\n  if (not CanLoadContentFields) then\n    Exit;\n\n  for I := 0 to Pred(FWebRequest.Files.Count) do\n    FContentFields.AddStream(FWebRequest.Files[I].FieldName, FWebRequest.Files[I].Stream);\n\n  for I := 0 to Pred(FWebRequest.ContentFields.Count) do\n  begin\n    if IsMultipartForm then\n    begin\n{$IF DEFINED(FPC)}\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n{$ELSE}\n{$IF CompilerVersion <= 31.0}\n      if FWebRequest.ContentFields[I].StartsWith(CONTENT_DISPOSITION) then\n      begin\n        LName := FWebRequest.ContentFields[I]\n          .Replace(CONTENT_DISPOSITION, EmptyStr)\n          .Replace('\"', EmptyStr);\n        LValue := FWebRequest.ContentFields[I + 1];\n      end;\n{$ELSE}\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n{$ENDIF}\n{$ENDIF}\n    end\n    else\n    begin\n      LName := FWebRequest.ContentFields.Names[I];\n      LValue := FWebRequest.ContentFields.ValueFromIndex[I];\n    end;\n\n    if LName <> EmptyStr then\n      FContentFields.Dictionary.AddOrSetValue(LName, LValue);\n\n    LName := EmptyStr;\n    LValue := EmptyStr;\n  end;\nend;\n\nprocedure THorseRequest.InitializeCookie;\nconst\n  KEY = 0;\n  VALUE = 1;\nvar\n  LParam: TArray<string>;\n  LItem: string;\nbegin\n  FCookie := THorseCoreParam.Create(THorseList.Create).Required(False);\n  for LItem in FWebRequest.CookieFields do\n  begin\n    LParam := LItem.Split(['=']);\n    FCookie.Dictionary.AddOrSetValue(LParam[KEY], LParam[VALUE]);\n  end;\nend;\n\nprocedure THorseRequest.InitializeParams;\nbegin\n  FParams := THorseCoreParam.Create(THorseList.Create).Required(True);\nend;\n\nprocedure THorseRequest.InitializeQuery;\nvar\n  LItem, LKey, LValue: string;\n  LEqualFirstPos: Integer;\nbegin\n  FQuery := THorseCoreParam.Create(THorseList.Create).Required(False);\n  for LItem in FWebRequest.QueryFields do\n  begin\n    LEqualFirstPos := Pos('=', LItem);\n    LKey := Copy(LItem, 1, LEqualFirstPos - 1);\n    LValue := Copy(LItem, LEqualFirstPos + 1, Length(LItem));\n    if not FQuery.Dictionary.ContainsKey(LKey) then\n      FQuery.Dictionary.AddOrSetValue(LKey, LValue)\n    else\n      FQuery.Dictionary[LKey] := FQuery.Dictionary[LKey] +','+ LValue;\n  end;\nend;\n\nfunction THorseRequest.IsFormURLEncoded: Boolean;\nvar\n  LContentType, LFormUrlEncoded: string;\nbegin\n  LContentType := FWebRequest.ContentType;\n  LFormUrlEncoded := TMimeTypes.ApplicationXWWWFormURLEncoded.ToString;\n{$IF DEFINED(FPC)}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormUrlEncoded), Length(LFormUrlEncoded)) = 0;\n{$ELSE}\n{$IF CompilerVersion <= 30}\n  Result := LContentType = PChar(LFormUrlEncoded);\n{$ELSE}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormUrlEncoded), Length(LFormUrlEncoded)) = 0;\n{$IFEND}\n{$ENDIF}\nend;\n\nfunction THorseRequest.IsMultipartForm: Boolean;\nvar\n  LContentType, LFormData: string;\nbegin\n  LContentType := FWebRequest.ContentType;\n  LFormData := TMimeTypes.MultiPartFormData.ToString;\n{$IF DEFINED(FPC)}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormData), Length(PChar(LFormData))) = 0;\n{$ELSE}\n{$IF CompilerVersion <= 30}\n  Result := LContentType = PChar(LFormData);\n{$ELSE}\n  Result := StrLIComp(PChar(LContentType), PChar(LFormData), Length(PChar(LFormData))) = 0;\n{$IFEND}\n{$ENDIF}\nend;\n\nfunction THorseRequest.MethodType: TMethodType;\nbegin\n  Result := {$IF DEFINED(FPC)}StringCommandToMethodType(FWebRequest.Method); {$ELSE}FWebRequest.MethodType; {$ENDIF}\nend;\n\nfunction THorseRequest.Params: THorseCoreParam;\nbegin\n  if not Assigned(FParams) then\n    InitializeParams;\n  Result := FParams;\nend;\n\nfunction THorseRequest.Query: THorseCoreParam;\nbegin\n  if not Assigned(FQuery) then\n    InitializeQuery;\n  Result := FQuery;\nend;\n\nfunction THorseRequest.RawWebRequest: {$IF DEFINED(FPC)}TRequest{$ELSE}TWebRequest{$ENDIF};\nbegin\n  Result := FWebRequest;\nend;\n\nfunction THorseRequest.Session(const ASession: TObject): THorseRequest;\nbegin\n  Result := Self;\n  FSession := ASession;\nend;\n\nfunction THorseRequest.Session<T>: T;\nbegin\n  Result := T(FSession);\nend;\n\nfunction THorseRequest.Sessions: THorseSessions;\nbegin\n  Result := FSessions;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nnamespace Horse.Request\n{\n    #region Stub Types and Helpers\n\n    \n    public class WebRequest\n    {\n        public string Content { get; set; } = \"\";\n        public byte[] RawContent { get; set; }\n        public string Host { get; set; } = \"\";\n        public string ContentType { get; set; } = \"\";\n        public string PathInfo { get; set; } = \"\";\n        \n        public List<WebFile> Files { get; set; } = new List<WebFile>();\n        public List<KeyValuePair<string, string>> ContentFields { get; set; } = new List<KeyValuePair<string, string>>();\n        public List<string> CookieFields { get; set; } = new List<string>();\n        public List<string> QueryFields { get; set; } = new List<string>();\n#if !FPC\n        public TWebRequestMethod MethodType { get; set; } = TWebRequestMethod.GET;\n#endif\n        public string Method { get; set; } = \"GET\";\n    }\n\n    \n    public class WebFile\n    {\n        public string FieldName { get; set; }\n        public Stream Stream { get; set; }\n    }\n\n    \n    public enum TWebRequestMethod\n    {\n        GET,\n        POST,\n        PUT,\n        DELETE,\n        HEAD,\n        PATCH,\n        OPTIONS\n    }\n\n    \n    public class HorseCoreParam\n    {\n        public Dictionary<string, string> Dictionary { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public HorseCoreParam(List<string> list)\n        {\n            // In a real implementation, 'list' may be used.\n        }\n\n        \n        public HorseCoreParam Required(bool req)\n        {\n            // You can store the required flag if needed.\n            return this;\n        }\n\n        \n        public void AddStream(string fieldName, Stream stream)\n        {\n            // Implementation depends on your requirements.\n           \n        }\n    }\n\n    \n    public static class HorseCoreParamHeader\n    {\n        public static HorseCoreParam GetHeaders(WebRequest request)\n        {\n            \n            return new HorseCoreParam(new List<string>());\n        }\n    }\n\n    \n    public class HorseSessions\n    {\n        // Implement session handling as needed.\n    }\n\n    #endregion\n\n    public class HorseRequest : IDisposable\n    {\n        private WebRequest _webRequest;\n        private HorseCoreParam _headers;\n        private HorseCoreParam _query;\n        private HorseCoreParam _params;\n        private HorseCoreParam _contentFields;\n        private HorseCoreParam _cookie;\n        private object _body;\n        private object _session;\n        private HorseSessions _sessions;\n\n        \n        public HorseRequest(WebRequest webRequest)\n        {\n            _webRequest = webRequest;\n            _sessions = new HorseSessions();\n        }\n\n        \n        public void Dispose()\n        {\n            \n            _headers = null;\n            _query = null;\n            _params = null;\n            _contentFields = null;\n            _cookie = null;\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _sessions = null;\n        }\n\n        #region Body Methods\n\n        \n        public virtual string Body()\n        {\n            return _webRequest.Content;\n        }\n\n        \n        public T Body<T>() where T : class\n        {\n            return _body as T;\n        }\n\n        \n        public virtual HorseRequest Body(object body)\n        {\n            if (_body is IDisposable disposableBody)\n                disposableBody.Dispose();\n            _body = body;\n            return this;\n        }\n\n        \n        public virtual string Body(Encoding encoding)\n        {\n            if (_webRequest.RawContent != null && _webRequest.RawContent.Length > 0)\n            {\n                return encoding.GetString(_webRequest.RawContent);\n            }\n            else\n            {\n                return _webRequest.Content;\n            }\n        }\n\n        #endregion\n\n        #region Session Methods\n\n        \n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n       \n        public T Session<T>() where T : class\n        {\n            return _session as T;\n        }\n\n        #endregion\n\n        #region Parameter Accessors\n\n        \n        public virtual HorseCoreParam Headers()\n        {\n            if (_headers == null)\n            {\n                _headers = new HorseCoreParam(HorseCoreParamHeader.GetHeaders(_webRequest).Dictionary).Required(false);\n            }\n            return _headers;\n        }\n\n                public virtual HorseCoreParam Query()\n        {\n            if (_query == null)\n                InitializeQuery();\n            return _query;\n        }\n\n        \n        public virtual HorseCoreParam Params()\n        {\n            if (_params == null)\n                InitializeParams();\n            return _params;\n        }\n\n        \n        public virtual HorseCoreParam Cookie()\n        {\n            if (_cookie == null)\n                InitializeCookie();\n            return _cookie;\n        }\n\n        \n        public virtual HorseCoreParam ContentFields()\n        {\n            if (_contentFields == null)\n                InitializeContentFields();\n            return _contentFields;\n        }\n\n        \n        public virtual HorseSessions Sessions()\n        {\n            return _sessions;\n        }\n\n        #endregion\n\n        #region Request Information\n\n        \n        public virtual TWebRequestMethod MethodType()\n        {\n#if FPC\n            return StringCommandToMethodType(_webRequest.Method);\n#else\n            return _webRequest.MethodType;\n#endif\n        }\n\n        \n        public virtual string ContentType()\n        {\n            return _webRequest.ContentType;\n        }\n\n        \n        public virtual string Host()\n        {\n            return _webRequest.Host;\n        }\n\n        \n        public virtual string PathInfo()\n        {\n            string prefix = string.IsNullOrEmpty(_webRequest.PathInfo) ? \"/\" : \"/\";\n            return prefix + _webRequest.PathInfo;\n        }\n\n        \n        public virtual WebRequest RawWebRequest()\n        {\n            return _webRequest;\n        }\n\n        #endregion\n\n        #region Initialization Methods\n\n        \n        private void InitializeQuery()\n        {\n            _query = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var item in _webRequest.QueryFields)\n            {\n                int equalPos = item.IndexOf('=');\n                if (equalPos > 0)\n                {\n                    string key = item.Substring(0, equalPos);\n                    string value = item.Substring(equalPos + 1);\n                    if (!_query.Dictionary.ContainsKey(key))\n                        _query.Dictionary[key] = value;\n                    else\n                        _query.Dictionary[key] = _query.Dictionary[key] + \",\" + value;\n                }\n            }\n        }\n\n        \n        private void InitializeParams()\n        {\n            _params = new HorseCoreParam(new List<string>()).Required(true);\n        }\n\n        \n        private void InitializeContentFields()\n        {\n            _contentFields = new HorseCoreParam(new List<string>()).Required(false);\n            if (!CanLoadContentFields())\n                return;\n\n            \n            foreach (var file in _webRequest.Files)\n            {\n                _contentFields.AddStream(file.FieldName, file.Stream);\n            }\n\n            \n            foreach (var kvp in _webRequest.ContentFields)\n            {\n                string lName = kvp.Key;\n                string lValue = kvp.Value;\n                if (!string.IsNullOrEmpty(lName))\n                    _contentFields.Dictionary[lName] = lValue;\n            }\n        }\n\n        \n        private void InitializeCookie()\n        {\n            _cookie = new HorseCoreParam(new List<string>()).Required(false);\n            foreach (var cookieField in _webRequest.CookieFields)\n            {\n                var parts = cookieField.Split('=');\n                if (parts.Length >= 2)\n                    _cookie.Dictionary[parts[0]] = parts[1];\n            }\n        }\n\n        \n        private bool CanLoadContentFields()\n        {\n            return IsMultipartForm() || IsFormURLEncoded();\n        }\n\n        \n        private bool IsFormURLEncoded()\n        {\n            string contentType = _webRequest.ContentType;\n            string formUrlEncoded = \"application/x-www-form-urlencoded\"; \n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(formUrlEncoded, StringComparison.OrdinalIgnoreCase);\n        }\n\n        \n        private bool IsMultipartForm()\n        {\n            string contentType = _webRequest.ContentType;\n            string multipart = \"multipart/form-data\"; \n            return !string.IsNullOrEmpty(contentType) &&\n                   contentType.StartsWith(multipart, StringComparison.OrdinalIgnoreCase);\n        }\n\n        \n        private TWebRequestMethod StringCommandToMethodType(string method)\n        {\n            if (Enum.TryParse<TWebRequestMethod>(method, true, out var result))\n                return result;\n            return TWebRequestMethod.GET;\n        }\n\n        #endregion\n\n        #region Overloads for Session and Body\n\n        public virtual HorseRequest Session<T>() where T : class\n        {\n            return Session(_session);\n        }\n\n        public virtual HorseRequest Session(object session)\n        {\n            _session = session;\n            return this;\n        }\n\n        public virtual HorseRequest Body(string body)\n        {\n            _body = body;\n            return this;\n        }\n\n        #endregion\n\n        \n        public override string ToString()\n        {\n            return Body();\n        }\n\n        #region Additional Overloads\n\n\n        #endregion\n    }\n}"}
{"input": "unit Horse.Exception.Interrupted;\n\n{$IF DEFINED(FPC)}\n  {$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\nuses\n{$IF DEFINED(FPC)}\n  SysUtils;\n{$ELSE}\n  System.SysUtils;\n{$ENDIF}\n\ntype\n  EHorseCallbackInterrupted = class(Exception)\n    constructor Create; reintroduce; overload;\n    constructor Create(const AMessage: string); reintroduce; overload;\n  end;\n\nimplementation\n\nconstructor EHorseCallbackInterrupted.Create;\nbegin\n  inherited Create(EmptyStr);\nend;\n\nconstructor EHorseCallbackInterrupted.Create(const AMessage: string);\nbegin\n  inherited Create(AMessage);\nend;\n\nend.", "output": "using System;\n\nnamespace Horse.Exception.Interrupted\n{\n    public class HorseCallbackInterruptedException : Exception\n    {\n        public HorseCallbackInterruptedException() : base(string.Empty)\n        {\n        }\n\n        public HorseCallbackInterruptedException(string message) : base(message)\n        {\n        }\n    }\n}"}
{"input": "unit OtherControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n  TOtherController = class(TMVCController)\n  public\n    [MVCPath]\n    [MVCHTTPMethods([httpGET])]\n    function GetSomethings: String;\n    [MVCPath('/else')]\n    [MVCHTTPMethods([httpGET])]\n    function GetSomethingElse: String;\n  end;\n\nimplementation\n\n{ TCustomController }\n\nfunction TOtherController.GetSomethingElse: String;\nbegin\n  Result := 'Hello There, it''s \"GetSomethingElse\" here';\nend;\n\nfunction TOtherController.GetSomethings: String;\nbegin\n  Result := 'Hello There, it''s \"GetSomethings\" here';\nend;\n\nend.", "output": "[HttpGet]\n[Route(\"else\")]\npublic string GetSomethingElse()\n{\n    return \"Hello There, it's \\\"GetSomethingElse\\\" here\";\n}"}
{"input": "unit WebModuleUnit1;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework,\n  MVCFramework.Commons;\n\ntype\n  TWebModule1 = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n\n  private\n    MVC: TMVCEngine;\n\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TWebModule1;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  AppControllerU,\n  System.Generics.Collections,\n  AuthenticationU,\n  MVCFramework.Middleware.JWT,\n  MVCFramework.JWT,\n  MVCFramework.HMAC,\n  MVCFramework.Middleware.StaticFiles,\n  System.DateUtils;\n\nprocedure TWebModule1.WebModuleCreate(Sender: TObject);\nvar\n  lClaimsSetup: TJWTClaimsSetup;\nbegin\n  lClaimsSetup := procedure(const JWT: TJWT)\n    begin\n      JWT.Claims.Issuer := 'Delphi MVC Framework JWT Middleware Sample';\n      JWT.Claims.NotBefore := Now - OneMinute * 5; // valid since 5 minutes ago\n      JWT.Claims.IssuedAt := Now;\n      JWT.Claims.ExpirationTime := Now + OneSecond * 30;\n      JWT.CustomClaims['mycustomvalue'] := 'THIS IS A CUSTOM CLAIM!';\n      // Here we dont use a fixed ExpirationTime but a LiveValidityWindowInSeconds\n      // to make the ExpirationTime dynamic, incrementing the\n      // ExpirationTime by LiveValidityWindowInSeconds seconds at each request\n      JWT.LiveValidityWindowInSeconds := 10; // 60 * 60;\n    end;\n\n  MVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      Config[TMVCConfigKey.DefaultContentType] := 'text/html';\n    end);\n  MVC\n    .AddController(TApp1MainController)\n    .AddController(TAdminController)\n    .AddMiddleware(TMVCJWTAuthenticationMiddleware.Create(\n      TAuthenticationSample.Create,\n      lClaimsSetup,\n      'mys3cr37',\n      '/login',\n      [TJWTCheckableClaim.ExpirationTime, TJWTCheckableClaim.NotBefore, TJWTCheckableClaim.IssuedAt],\n      0,\n      HMAC_HS512\n    // just for test, Leeway seconds is zero.\n    ));\nend;\n\nend.", "output": "using System;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing AppControllerU;\nusing AuthenticationU;\nusing MVCFramework.Middleware.JWT;\nusing MVCFramework.JWT;\nusing MVCFramework.HMAC;\nusing MVCFramework.Middleware.StaticFiles;\n\nnamespace WebModuleUnit1\n{\n    public class WebModule1 : WebModule\n    {\n        private TMVCEngine MVC;\n\n        public void WebModuleCreate(object sender)\n        {\n            Action<TJWT> lClaimsSetup = (JWT) =>\n            {\n                JWT.Claims.Issuer = \"Delphi MVC Framework JWT Middleware Sample\";\n                JWT.Claims.NotBefore = DateTime.Now.AddMinutes(-5);\n                JWT.Claims.IssuedAt = DateTime.Now;\n                JWT.Claims.ExpirationTime = DateTime.Now.AddSeconds(30);\n                JWT.CustomClaims[\"mycustomvalue\"] = \"THIS IS A CUSTOM CLAIM!\";\n                JWT.LiveValidityWindowInSeconds = 10;\n            };\n\n            MVC = new TMVCEngine(this, config =>\n            {\n                config[TMVCConfigKey.DefaultContentType] = \"text/html\";\n            });\n            MVC.AddController(typeof(TApp1MainController))\n               .AddController(typeof(TAdminController))\n               .AddMiddleware(new TMVCJWTAuthenticationMiddleware(\n                   new TAuthenticationSample(),\n                   lClaimsSetup,\n                   \"mys3cr37\",\n                   \"/login\",\n                   new TJWTCheckableClaim[] { TJWTCheckableClaim.ExpirationTime, TJWTCheckableClaim.NotBefore, TJWTCheckableClaim.IssuedAt },\n                   0,\n                   HMAC_HS512\n               ));\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n//\n// This IDE expert is based off of the one included with the DUnitX\n// project.  Original source by Robert Love.  Adapted by Nick Hodges and Daniele Teti.\n//\n// The DUnitX project is run by Vincent Parrett and can be found at:\n//\n// https://github.com/VSoftTechnologies/DUnitX\n// ***************************************************************************\n\nunit DMVC.Expert.CodeGen.SourceFile;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  JsonDataObjects,\n  ToolsAPI,\n  DMVC.Expert.CodeGen.Executor;\n\ntype\n  TSourceFile = class(TInterfacedObject, IOTAFile)\n  private\n    fGeneratorCallback: TProc<TMVCCodeGenerator>;\n    fJSON: TJsonObject;\n  public\n    function GetSource: string;\n    function GetAge: TDateTime;\n    constructor Create(const GeneratorCallback: TProc<TMVCCodeGenerator>; const Args: TJsonObject);\n    destructor Destroy; override;\n  end;\n\nimplementation\n\n{ TSourceFile }\n\nconstructor TSourceFile.Create(const GeneratorCallback: TProc<TMVCCodeGenerator>; const Args: TJsonObject);\nbegin\n  inherited Create;\n  fGeneratorCallback := GeneratorCallback;\n  fJSON := Args.Clone as TJsonObject;\nend;\n\ndestructor TSourceFile.Destroy;\nbegin\n  fJSON.Free;\n  inherited;\nend;\n\nfunction TSourceFile.GetAge: TDateTime;\nbegin\n  Result := Now;\nend;\n\nfunction TSourceFile.GetSource: string;\nbegin\n  Result := TMVCCodeGenerator.GenerateSource(fJSON,\n                        procedure (Gen: TMVCCodeGenerator)\n                        begin\n                          fGeneratorCallback(Gen)\n                        end);\nend;\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\nusing DMVC.Expert.CodeGen.Executor;  \n\nnamespace DMVCExpertCodeGenSourceFile\n{\n    public interface IOTAFile\n    {\n        string GetSource();\n        DateTime GetAge();\n    }\n\n    public class TSourceFile : IOTAFile, IDisposable\n    {\n        private readonly Action<TMVCCodeGenerator> _generatorCallback;\n        private JObject _json;\n        private bool _disposed;\n\n        public TSourceFile(Action<TMVCCodeGenerator> generatorCallback, JObject args)\n        {\n            _generatorCallback = generatorCallback;\n            _json = (JObject)args.DeepClone();\n        }\n\n        public string GetSource()\n        {\n            return TMVCCodeGenerator.GenerateSource(_json, gen => _generatorCallback(gen));\n        }\n\n        public DateTime GetAge()\n        {\n            return DateTime.Now;\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    \n                    _json = null;\n                }\n                _disposed = true;\n            }\n        }\n\n        ~TSourceFile()\n        {\n            Dispose(false);\n        }\n    }\n}"}
{"input": "unit Commands.TemplatesU;\n\ninterface\n\nuses\n  System.Generics.Collections, CommonsU, ProjectGeneratorU;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\n\nimplementation\n\nuses CommandsU;\n\nprocedure FillProgramTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitProgramCommand.Create,\n    TUnitRunServerProcBody.Create,\n    TUnitMainBeginEndCommand.Create\n  ]);\nend;\n\nprocedure FillControllerTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitControllerCommand.Create,\n    TUnitControllerEntityDeclarationCommand.Create,\n    TUnitControllerControllerDeclarationCommand.Create,\n    TUnitFooterCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitWebModuleDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillJSONRPCTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TUnitJSONRPCDeclarationCommand.Create\n    ]);\nend;\n\nprocedure FillWebModuleDFMTemplates(Gen: TMVCCodeGenerator);\nbegin\n  Gen.Commands.AddRange([\n    TWebModuleDFMCommand.Create\n    ]);\nend;\n\n\nend.", "output": "using System.Collections.Generic;\nusing CommonsU;\nusing ProjectGeneratorU;\nusing CommandsU;\n\nnamespace CommandsTemplatesU\n{\n    public static class CommandsTemplates\n    {\n        public static void FillProgramTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitProgramCommand(),\n                new TUnitRunServerProcBody(),\n                new TUnitMainBeginEndCommand()\n            });\n        }\n\n        public static void FillControllerTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitControllerCommand(),\n                new TUnitControllerEntityDeclarationCommand(),\n                new TUnitControllerControllerDeclarationCommand(),\n                new TUnitFooterCommand()\n            });\n        }\n\n        public static void FillWebModuleTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitWebModuleDeclarationCommand()\n            });\n        }\n\n        public static void FillJSONRPCTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TUnitJSONRPCDeclarationCommand()\n            });\n        }\n\n        public static void FillWebModuleDFMTemplates(TMVCCodeGenerator gen)\n        {\n            gen.Commands.AddRange(new List<ICommand>\n            {\n                new TWebModuleDFMCommand()\n            });\n        }\n    }\n}"}
{"input": "unit Horse.Provider.FPC.Daemon;\n\n{$IF DEFINED(FPC)}\n{$MODE DELPHI}{$H+}\n{$ENDIF}\n\ninterface\n\n{$IF DEFINED(HORSE_DAEMON) AND DEFINED(FPC)}\nuses\n  SysUtils,\n  Classes,\n  httpdefs,\n  fpHTTP,\n  fphttpserver,\n  Horse.Request,\n  Horse.Response,\n  Horse.Core,\n  Horse.Provider.Abstract,\n  Horse.Constants,\n  Horse.Proc,\n  Horse.Commons;\n\ntype\n  THTTPServerThread = class(TThread)\n  private\n    FStartServer: Boolean;\n    FHost: string;\n    FPort: Integer;\n    FListenQueue: Word;\n    FServer: TFPHTTPServer;\n    FHorse: THorseCore;\n  public\n    constructor Create(const ACreateSuspended: Boolean; const AStackSize: SizeUInt = DefaultStackSize);\n    destructor Destroy; override;\n    procedure StartServer;\n    procedure StopServer;\n    property Port: Integer read FPort write FPort;\n    property Host: String read FHost write FHost;\n    property ListenQueue: Word read FListenQueue write FListenQueue;\n    procedure Execute; override;\n    procedure OnRequest(Sender: TObject; var ARequest: TFPHTTPConnectionRequest; var AResponse: TFPHTTPConnectionResponse);\n  end;\n\n  THorseProvider = class(THorseProviderAbstract)\n  private\n    class var FPort: Integer;\n    class var FHost: string;\n    class var FRunning: Boolean;\n    class var FListenQueue: Integer;\n    class var FHTTPServerThread: THTTPServerThread;\n    class function GetDefaultHTTPServerThread: THTTPServerThread;\n    class function HTTPServerThreadIsNil: Boolean;\n    class procedure SetListenQueue(const AValue: Integer); static;\n    class procedure SetPort(const AValue: Integer); static;\n    class procedure SetHost(const AValue: string); static;\n    class function GetListenQueue: Integer; static;\n    class function GetPort: Integer; static;\n    class function GetDefaultPort: Integer; static;\n    class function GetDefaultHost: string; static;\n    class function GetHost: string; static;\n    class procedure InternalListen; virtual;\n    class procedure InternalStopListen; virtual;\n  public\n    class property Host: string read GetHost write SetHost;\n    class property Port: Integer read GetPort write SetPort;\n    class property ListenQueue: Integer read GetListenQueue write SetListenQueue;\n    class procedure StopListen; override;\n    class procedure Listen; overload; override;\n    class procedure Listen(const APort: Integer; const AHost: string = '0.0.0.0'; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const APort: Integer; const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const AHost: string; const ACallbackListen: TProc = nil; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class procedure Listen(const ACallbackListen: TProc; const ACallbackStopListen: TProc = nil); reintroduce; overload; static;\n    class destructor UnInitialize;\n    class function IsRunning: Boolean;\n  end;\n{$ENDIF}\n\nimplementation\n\n{$IF DEFINED(HORSE_DAEMON) AND DEFINED(FPC)}\nuses\n  Horse.WebModule,\n  Horse.Exception.Interrupted;\n\nclass function THorseProvider.GetDefaultHTTPServerThread: THTTPServerThread;\nbegin\n  if HTTPServerThreadIsNil then\n    FHTTPServerThread := THTTPServerThread.Create(True);\n  Result := FHTTPServerThread;\nend;\n\nclass function THorseProvider.IsRunning: Boolean;\nbegin\n  Result := FRunning;\nend;\n\nclass function THorseProvider.HTTPServerThreadIsNil: Boolean;\nbegin\n  Result := FHTTPServerThread = nil;\nend;\n\nclass procedure THorseProvider.StopListen;\nbegin\n  InternalStopListen;\nend;\n\nclass function THorseProvider.GetDefaultHost: string;\nbegin\n  Result := DEFAULT_HOST;\nend;\n\nclass function THorseProvider.GetDefaultPort: Integer;\nbegin\n  Result := DEFAULT_PORT;\nend;\n\nclass function THorseProvider.GetHost: string;\nbegin\n  Result := FHost;\nend;\n\nclass function THorseProvider.GetListenQueue: Integer;\nbegin\n  Result := FListenQueue;\nend;\n\nclass function THorseProvider.GetPort: Integer;\nbegin\n  Result := FPort;\nend;\n\nclass procedure THorseProvider.InternalListen;\nvar\n  LHTTPServerThread: THTTPServerThread;\nbegin\n  inherited;\n  if FPort <= 0 then\n    FPort := GetDefaultPort;\n  if FHost.IsEmpty then\n    FHost := GetDefaultHost;\n  if FListenQueue = 0 then\n    FListenQueue := 15;\n  LHTTPServerThread := GetDefaultHTTPServerThread;\n  LHTTPServerThread.Port := FPort;\n  LHTTPServerThread.Host := FHost;\n  LHTTPServerThread.ListenQueue := FListenQueue;\n  LHTTPServerThread.StartServer;\n  FRunning := True;\n  DoOnListen;\nend;\n\nclass procedure THorseProvider.Listen;\nbegin\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  SetPort(APort);\n  SetHost(AHost);\n  SetOnListen(ACallbackListen);\n  SetOnStopListen(ACallbackStopListen);\n  InternalListen;\nend;\n\nclass procedure THorseProvider.Listen(const AHost: string; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, AHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(FPort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.Listen(const APort: Integer; const ACallbackListen, ACallbackStopListen: TProc);\nbegin\n  Listen(APort, FHost, ACallbackListen, ACallbackStopListen);\nend;\n\nclass procedure THorseProvider.SetHost(const AValue: string);\nbegin\n  FHost := AValue;\nend;\n\nclass procedure THorseProvider.SetListenQueue(const AValue: Integer);\nbegin\n  FListenQueue := AValue;\nend;\n\nclass procedure THorseProvider.SetPort(const AValue: Integer);\nbegin\n  FPort := AValue;\nend;\n\nclass destructor THorseProvider.UnInitialize;\nbegin\n  FreeAndNil(FHTTPServerThread);\nend;\n\nclass procedure THorseProvider.InternalStopListen;\nbegin\n  if not HTTPServerThreadIsNil then\n  begin\n    GetDefaultHTTPServerThread.StopServer;\n    DoOnStopListen;\n    FRunning := False;\n  end\n  else\n    raise Exception.Create('Horse not listen');\nend;\n\nprocedure THTTPServerThread.OnRequest(Sender: TObject; var ARequest: TFPHTTPConnectionRequest; var AResponse: TFPHTTPConnectionResponse);\nvar\n  LRequest: THorseRequest;\n  LResponse: THorseResponse;\nbegin\n  LRequest := THorseRequest.Create(ARequest);\n  LResponse := THorseResponse.Create(AResponse);\n  try\n    try\n      if not FHorse.Routes.Execute(LRequest, LResponse) then\n      begin\n        AResponse.Content := 'Not Found';\n        AResponse.Code := THTTPStatus.NotFound.ToInteger;\n      end;\n    except\n      on E: Exception do\n        if not E.InheritsFrom(EHorseCallbackInterrupted) then\n          raise;\n    end;\n  finally\n    if LRequest.Body<TObject> = LResponse.Content then\n      LResponse.Content(nil);\n    LRequest.Free;\n    LResponse.Free;\n  end;\nend;\n\nconstructor THTTPServerThread.Create(const ACreateSuspended: Boolean; const AStackSize: SizeUInt = DefaultStackSize);\nbegin\n  inherited Create(ACreateSuspended, AStackSize);\n  FreeOnTerminate := True;\n  FStartServer := False;\n  FServer := TFPHTTPServer.Create(Nil);\n  FServer.OnRequest := OnRequest;\n  FHorse := THorseCore.GetInstance;\nend;\n\ndestructor THTTPServerThread.Destroy;\nbegin\n  if Assigned(FServer) then\n    FServer.Active := False;\n  FreeAndNil(FServer);\n  inherited Destroy;\nend;\n\nprocedure THTTPServerThread.StartServer;\nbegin\n  Start;\n  FStartServer := True;\nend;\n\nprocedure THTTPServerThread.StopServer;\nbegin\n  FStartServer := False;\n  FServer.Active := FStartServer;\nend;\n\nprocedure THTTPServerThread.Execute;\nbegin\n  while not Terminated do\n  begin\n    if FStartServer then\n    begin\n      FServer.HostName := FHost;\n      FServer.Port := FPort;\n      FServer.Threaded := True;\n      FServer.QueueSize := FListenQueue;\n      FServer.Active := True;\n    end;\n  end;\nend;\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\n\nnamespace Horse.Provider.FPC.Daemon\n{\n    #region Stub Classes and Interfaces\n\n    \n    public class FPHTTPServer\n    {\n        public string HostName { get; set; }\n        public int Port { get; set; }\n        public bool Threaded { get; set; }\n        public int QueueSize { get; set; }\n        public bool Active { get; set; }\n\n        \n        public event Action<object, FPHTTPConnectionRequest, FPHTTPConnectionResponse> OnRequest;\n\n        \n        public List<Binding> Bindings { get; } = new List<Binding>();\n\n        public FPHTTPServer()\n        {\n            // Initialize as needed.\n        }\n\n        public void StartListening()\n        {\n            \n            Console.WriteLine($\"FPHTTPServer listening on {HostName}:{Port} with queue size {QueueSize}.\");\n            Active = true;\n        }\n\n        public void StopListening()\n        {\n           \n            Console.WriteLine(\"FPHTTPServer stopped listening.\");\n            Active = false;\n        }\n    }\n\n    \n    public class Binding\n    {\n        public string IP { get; set; }\n        public int Port { get; set; }\n    }\n\n    \n    public class FPHTTPConnectionRequest\n    {\n        public string Content { get; set; }\n    }\n\n    \n    public class FPHTTPConnectionResponse\n    {\n        public string Content { get; set; }\n        public int Code { get; set; }\n    }\n\n    \n    public class THorseRequest : IDisposable\n    {\n        public THorseRequest(FPHTTPConnectionRequest req)\n        {\n            // Wrap the request.\n        }\n        public void Dispose()\n        {\n            // Clean up.\n        }\n    }\n\n    public class THorseResponse : IDisposable\n    {\n        public THorseResponse(FPHTTPConnectionResponse resp)\n        {\n            // Wrap the response.\n        }\n        public void Send(string content)\n        {\n            Console.WriteLine(\"Response sent: \" + content);\n        }\n        public void Status(int code)\n        {\n            Console.WriteLine(\"Response status: \" + code);\n        }\n        public void Dispose()\n        {\n            // Clean up.\n        }\n    }\n\n    \n    public class HorseCore\n    {\n        private static HorseCore _instance;\n        public static HorseCore GetInstance() => _instance ?? (_instance = new HorseCore());\n        public RoutesCollection Routes { get; } = new RoutesCollection();\n    }\n\n    \n    public class RoutesCollection\n    {\n        \n        public bool Execute(THorseRequest request, THorseResponse response)\n        {\n            \n            return false;\n        }\n    }\n\n    \n    public static class HTTPStatus\n    {\n        public static int NotFound => 404;\n    }\n\n    #endregion\n\n    #region HTTPServerThread\n\n    \n    public class HTTPServerThread\n    {\n        private Thread _thread;\n        private volatile bool _startServer;\n        private readonly FPHTTPServer _server;\n        private readonly HorseCore _horse;\n        public string Host { get; set; }\n        public int Port { get; set; }\n        public ushort ListenQueue { get; set; }\n\n        public HTTPServerThread(bool createSuspended)\n        {\n            _server = new FPHTTPServer();\n            \n            _server.OnRequest += OnRequest;\n            _horse = HorseCore.GetInstance();\n            _startServer = false;\n\n            \n            _thread = new Thread(Execute) { IsBackground = true };\n            if (!createSuspended)\n            {\n                _thread.Start();\n            }\n        }\n\n        \n        public void StartServer()\n        {\n            _startServer = true;\n            if (!_thread.IsAlive)\n                _thread.Start();\n        }\n\n        \n        public void StopServer()\n        {\n            _startServer = false;\n            _server.Active = _startServer;\n        }\n\n        \n        private void Execute()\n        {\n            while (true)\n            {\n                if (_startServer)\n                {\n                    _server.HostName = Host;\n                    _server.Port = Port;\n                    _server.Threaded = true;\n                    _server.QueueSize = ListenQueue;\n                    _server.Active = true;\n                    _server.StartListening();\n                }\n                \n                Thread.Sleep(100);\n            }\n        }\n\n        \n        private void OnRequest(object sender, FPHTTPConnectionRequest req, FPHTTPConnectionResponse resp)\n        {\n            using (var horseReq = new THorseRequest(req))\n            using (var horseResp = new THorseResponse(resp))\n            {\n                try\n                {\n                    if (!_horse.Routes.Execute(horseReq, horseResp))\n                    {\n                        resp.Content = \"Not Found\";\n                        resp.Code = HTTPStatus.NotFound;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    \n                    Console.WriteLine(\"Exception in OnRequest: \" + ex.Message);\n                }\n            }\n        }\n    }\n\n    #endregion\n\n    #region HorseProvider\n\n    \n    public abstract class HorseProviderAbstract\n    {\n        public abstract void Listen();\n        public abstract void StopListen();\n    }\n\n    \n    public static class HorseProvider : HorseProviderAbstract\n    {\n        private static int _port;\n        private static string _host;\n        private static bool _running;\n        private static int _listenQueue;\n        private static HTTPServerThread _httpServerThread;\n\n        \n        public static string Host { get => GetHost(); set => SetHost(value); }\n        public static int Port { get => GetPort(); set => SetPort(value); }\n        public static int ListenQueue { get => _listenQueue; set => _listenQueue = value; }\n\n        public override void Listen() => InternalListen();\n\n        public override void StopListen() => InternalStopListen();\n\n        public static void Listen(int aPort, string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            SetPort(aPort);\n            SetHost(aHost);\n            \n            InternalListen();\n        }\n\n        public static void Listen(string aHost, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, aHost, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(int aPort, Action callbackListen, Action callbackStopListen)\n        {\n            Listen(aPort, _host, callbackListen, callbackStopListen);\n        }\n\n        public static void Listen(Action callbackListen, Action callbackStopListen)\n        {\n            Listen(_port, _host, callbackListen, callbackStopListen);\n        }\n\n        public static bool IsRunning() => _running;\n\n        private static string GetHost() => _host;\n        private static void SetHost(string value) => _host = value;\n        private static int GetPort() => _port;\n        private static void SetPort(int value) => _port = value;\n        private static int GetListenQueue() => _listenQueue;\n\n        private static void InternalListen()\n        {\n            if (_port <= 0)\n                _port = DEFAULT_PORT;\n            if (string.IsNullOrEmpty(_host))\n                _host = DEFAULT_HOST;\n            if (_listenQueue == 0)\n                _listenQueue = 15;\n\n            if (_httpServerThread == null)\n            {\n                _httpServerThread = new HTTPServerThread(createSuspended: true);\n            }\n            _httpServerThread.Port = _port;\n            _httpServerThread.Host = _host;\n            _httpServerThread.ListenQueue = (ushort)_listenQueue;\n            _httpServerThread.StartServer();\n            _running = true;\n            \n        }\n\n        private static void InternalStopListen()\n        {\n            if (_httpServerThread != null)\n            {\n                _httpServerThread.StopServer();\n                _running = false;\n            }\n            else\n            {\n                throw new Exception(\"Horse not listen\");\n            }\n        }\n\n        public static void UnInitialize()\n        {\n            _httpServerThread = null;\n        }\n\n        \n        private const string DEFAULT_HOST = \"0.0.0.0\";\n        private const int DEFAULT_PORT = 8080;\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Session;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Session,\n  MVCFramework.Middleware.Session.Internal\n  ;\n\n  function UseMemorySessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\n  function UseFileSessionMiddleware(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'): TMVCSessionMiddleware;\n  function UseDatabaseSessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\n\nimplementation\n\nuses\n  MVCFramework.Session.Database;\n\n\nfunction UseMemorySessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(TMVCWebSessionMemoryFactory.Create(aTimeoutInMinutes));\nend;\n\nfunction UseFileSessionMiddleware(aTimeoutInMinutes: Integer = 0; aSessionFolder: String = 'dmvc_sessions'): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(TMVCWebSessionFileFactory.Create(aTimeoutInMinutes, aSessionFolder));\nend;\n\nfunction UseDatabaseSessionMiddleware(aTimeoutInMinutes: Integer = 0): TMVCSessionMiddleware;\nbegin\n  Result := TMVCSessionMiddleware.Create(\n    TMVCWebSessionDatabaseFactory.Create(aTimeoutInMinutes, 'notused'));\nend;\n\n\n\n\nend.", "output": "using System;\nusing MVCFramework.Session;\nusing MVCFramework.Middleware.Session.Internal;\nusing MVCFramework.Session.Database; \n\nnamespace MVCFramework.Middleware.Session\n{\n    public static class SessionMiddlewareExtensions\n    {\n        \n        public static SessionMiddleware UseMemorySessionMiddleware(int timeoutInMinutes = 0)\n        {\n            return new SessionMiddleware(MVCWebSessionMemoryFactory.Create(timeoutInMinutes));\n        }\n\n        \n        public static SessionMiddleware UseFileSessionMiddleware(int timeoutInMinutes = 0, string sessionFolder = \"dmvc_sessions\")\n        {\n            \n            return new SessionMiddleware(MVCWebSessionFileFactory.Create(timeoutInMinutes, sessionFolder));\n        }\n\n        \n        public static SessionMiddleware UseDatabaseSessionMiddleware(int timeoutInMinutes = 0)\n        {\n            \n            return new SessionMiddleware(MVCWebSessionDatabaseFactory.Create(timeoutInMinutes, \"notused\"));\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file:\n// Jo\ufffdo Ant\ufffdnio Duarte (https://github.com/joaoduarte19)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.StaticFiles;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  System.Generics.Collections;\n\ntype\n  TMVCStaticFilesDefaults = class sealed\n  public const\n    /// <summary>\n    /// URL segment that represents the path to static files\n    /// </summary>\n    STATIC_FILES_PATH = '/static';\n\n    /// <summary>\n    /// Physical path of the root folder that contains the static files\n    /// </summary>\n    DOCUMENT_ROOT = '.\\www';\n\n    /// <summary>\n    /// Default static file\n    /// </summary>\n    INDEX_DOCUMENT = 'index.html';\n\n    /// <summary>\n    /// Charset of static files\n    /// </summary>\n    STATIC_FILES_CONTENT_CHARSET = TMVCConstants.DEFAULT_CONTENT_CHARSET;\n  end;\n\n  TMVCStaticFileRulesProc = reference to procedure(const Context: TWebContext; var PathInfo: String; var Handled: Boolean);\n  TMVCStaticFileMediaTypesCustomizer = reference to procedure(const MediaTypes: TMVCStringDictionary);\n  TMVCStaticFilesMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fSanityCheckOK: Boolean;\n    fMediaTypes: TMVCStringDictionary;\n    fStaticFilesPath: string;\n    fDocumentRoot: string;\n    fIndexDocument: string;\n    fStaticFilesCharset: string;\n    fSPAWebAppSupport: Boolean;\n    fRules: TMVCStaticFileRulesProc;\n    procedure AddMediaTypes;\n    // function IsStaticFileRequest(const APathInfo: string; out AFileName: string;\n    // out AIsDirectoryTraversalAttach: Boolean): Boolean;\n    function SendStaticFileIfPresent(const AContext: TWebContext; const AFileName: string): Boolean;\n    procedure DoSanityCheck;\n  public\n    constructor Create(\n      const AStaticFilesPath: string = TMVCStaticFilesDefaults.STATIC_FILES_PATH;\n      const ADocumentRoot: string = TMVCStaticFilesDefaults.DOCUMENT_ROOT;\n      const AIndexDocument: string = TMVCStaticFilesDefaults.INDEX_DOCUMENT;\n      const ASPAWebAppSupport: Boolean = True;\n      const AStaticFilesCharset: string = TMVCStaticFilesDefaults.STATIC_FILES_CONTENT_CHARSET;\n      const ARules: TMVCStaticFileRulesProc = nil;\n      const AMediaTypesCustomizer: TMVCStaticFileMediaTypesCustomizer = nil);\n    destructor Destroy; override;\n\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName: string;\n      const AActionName: string; var AHandled: Boolean);\n\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  end;\n\nimplementation\n\nuses\n  MVCFramework.Logger,\n  System.SysUtils,\n  System.NetEncoding,\n  System.IOUtils,\n  System.Classes;\n\n{ TMVCStaticFilesMiddleware }\n\nprocedure TMVCStaticFilesMiddleware.AddMediaTypes;\nbegin\n  fMediaTypes.Add('.html', TMVCMediaType.TEXT_HTML);\n  fMediaTypes.Add('.htm', TMVCMediaType.TEXT_HTML);\n  fMediaTypes.Add('.txt', TMVCMediaType.TEXT_PLAIN);\n  fMediaTypes.Add('.text', TMVCMediaType.TEXT_PLAIN);\n  fMediaTypes.Add('.csv', TMVCMediaType.TEXT_CSV);\n  fMediaTypes.Add('.css', TMVCMediaType.TEXT_CSS);\n  fMediaTypes.Add('.js', TMVCMediaType.TEXT_JAVASCRIPT);\n  fMediaTypes.Add('.json', TMVCMediaType.APPLICATION_JSON);\n  fMediaTypes.Add('.jpg', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.jpeg', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.jpe', TMVCMediaType.IMAGE_JPEG);\n  fMediaTypes.Add('.png', TMVCMediaType.IMAGE_PNG);\n  fMediaTypes.Add('.ico', TMVCMediaType.IMAGE_X_ICON);\n  fMediaTypes.Add('.appcache', TMVCMediaType.TEXT_CACHEMANIFEST);\n  fMediaTypes.Add('.svg', TMVCMediaType.IMAGE_SVG_XML);\n  fMediaTypes.Add('.xml', TMVCMediaType.TEXT_XML);\n  fMediaTypes.Add('.pdf', TMVCMediaType.APPLICATION_PDF);\n  fMediaTypes.Add('.svgz', TMVCMediaType.IMAGE_SVG_XML);\n  fMediaTypes.Add('.gif', TMVCMediaType.IMAGE_GIF);\nend;\n\nconstructor TMVCStaticFilesMiddleware.Create(\n      const AStaticFilesPath: string;\n      const ADocumentRoot: string;\n      const AIndexDocument: string;\n      const ASPAWebAppSupport: Boolean;\n      const AStaticFilesCharset: string;\n      const ARules: TMVCStaticFileRulesProc;\n      const AMediaTypesCustomizer: TMVCStaticFileMediaTypesCustomizer);\nbegin\n  inherited Create;\n  fSanityCheckOK := False;\n  fStaticFilesPath := AStaticFilesPath.Trim;\n  if not fStaticFilesPath.EndsWith('/') then\n    fStaticFilesPath := fStaticFilesPath + '/';\n\n  if TDirectory.Exists(ADocumentRoot) then\n  begin\n    fDocumentRoot := TPath.GetFullPath(ADocumentRoot);\n  end\n  else\n  begin\n    fDocumentRoot := TPath.Combine(AppPath, ADocumentRoot);\n  end;\n  fIndexDocument := AIndexDocument;\n  fStaticFilesCharset := AStaticFilesCharset;\n  fSPAWebAppSupport := ASPAWebAppSupport;\n  fMediaTypes := TMVCStringDictionary.Create;\n  fRules := ARules;\n  AddMediaTypes;\n  if Assigned(AMediaTypesCustomizer) then\n  begin\n    AMediaTypesCustomizer(fMediaTypes);\n  end;\nend;\n\ndestructor TMVCStaticFilesMiddleware.Destroy;\nbegin\n  fMediaTypes.Free;\n\n  inherited Destroy;\nend;\n\nprocedure TMVCStaticFilesMiddleware.DoSanityCheck;\nbegin\n  if not fStaticFilesPath.StartsWith('/') then\n  begin\n    raise EMVCException.Create('StaticFilePath must begin with \"/\" and cannot be empty');\n  end;\n  if not TDirectory.Exists(fDocumentRoot) then\n  begin\n    raise EMVCException.CreateFmt('TMVCStaticFilesMiddleware Error: DocumentRoot [%s] is not a valid directory', [fDocumentRoot]);\n  end;\n  fSanityCheckOK := True;\nend;\n\n// function TMVCStaticFilesMiddleware.IsStaticFileRequest(const APathInfo: string; out AFileName: string;\n// out AIsDirectoryTraversalAttach: Boolean): Boolean;\n// begin\n// Result := TMVCStaticContents.IsStaticFile(fDocumentRoot, APathInfo, AFileName,\n// AIsDirectoryTraversalAttach);\n// end;\n\nprocedure TMVCStaticFilesMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnBeforeControllerAction(AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCStaticFilesMiddleware.OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\nvar\n  lPathInfo: string;\n  lFileName: string;\n  lIsDirectoryTraversalAttach: Boolean;\n  lFullPathInfo: string;\n  lRealFileName: string;\n  lAllow: Boolean;\nbegin\n//  if not fSanityCheckOK then\n//  begin\n//    DoSanityCheck;\n//  end;\n\n  lPathInfo := AContext.Request.PathInfo;\n\n  if not lPathInfo.StartsWith(fStaticFilesPath, True) then\n  begin\n    { In case of folder request without the trailing \"/\" }\n    if not lPathInfo.EndsWith('/') then\n    begin\n      lPathInfo := lPathInfo + '/';\n      if not lPathInfo.StartsWith(fStaticFilesPath, True) then\n      begin\n        AHandled := False;\n        Exit;\n      end;\n    end\n    else\n    begin\n      AHandled := False;\n      Exit;\n    end;\n  end;\n\n  if Assigned(fRules) then\n  begin\n    lAllow := True;\n    fRules(AContext, lPathInfo, lAllow);\n    if not lAllow then\n    begin\n      AHandled := True;\n      Exit;\n    end;\n  end;\n\n  // calculate the actual requested path\n  if lPathInfo.StartsWith(fStaticFilesPath, True) then\n  begin\n    lPathInfo := lPathInfo.Remove(0, fStaticFilesPath.Length);\n  end;\n  lPathInfo := lPathInfo.Replace('/', PathDelim, [rfReplaceAll]);\n  if lPathInfo.StartsWith(PathDelim) then\n  begin\n    lPathInfo := lPathInfo.Remove(0, 1);\n  end;\n  lFullPathInfo := TPath.Combine(fDocumentRoot, lPathInfo);\n\n  { Now the actual requested path is in lFullPathInfo }\n\n  if not fSanityCheckOK then\n  begin\n    DoSanityCheck;\n  end;\n\n  if TMVCStaticContents.IsStaticFile(fDocumentRoot, lPathInfo, lRealFileName,\n    lIsDirectoryTraversalAttach) then\n  begin\n    // check if it's a direct file request\n    // lIsFileRequest := TMVCStaticContents.IsStaticFile(fDocumentRoot, lPathInfo, lRealFileName,\n    // lIsDirectoryTraversalAttach);\n    if lIsDirectoryTraversalAttach then\n    begin\n      AContext.Response.StatusCode := HTTP_STATUS.NotFound;\n      AHandled := True;\n      Exit;\n    end;\n\n    AHandled := SendStaticFileIfPresent(AContext, lRealFileName);\n    if AHandled then\n    begin\n      Exit;\n    end;\n  end;\n\n  // check if a directory request\n  if TDirectory.Exists(lFullPathInfo) then\n  begin\n    if not AContext.Request.PathInfo.EndsWith('/') then\n    begin\n      AContext.Response.StatusCode := HTTP_STATUS.MovedPermanently;\n      AContext.Response.CustomHeaders.Values['Location'] := AContext.Request.PathInfo + '/';\n      AHandled := True;\n      Exit;\n    end;\n\n    if not fIndexDocument.IsEmpty then\n    begin\n      AHandled := SendStaticFileIfPresent(AContext, TPath.Combine(lFullPathInfo, fIndexDocument));\n      Exit;\n    end;\n  end;\n\n  // if SPA support is enabled, return the first index.html found in the path.\n  // This allows to host multiple SPA application in subfolders\n  if (not AHandled) and fSPAWebAppSupport and (not fIndexDocument.IsEmpty) then\n  begin\n    while (not lFullPathInfo.IsEmpty) and (not TDirectory.Exists(lFullPathInfo)) do\n    begin\n      lFullPathInfo := TDirectory.GetParent(lFullPathInfo);\n    end;\n    lFileName := TPath.GetFullPath(TPath.Combine(lFullPathInfo, fIndexDocument));\n    AHandled := SendStaticFileIfPresent(AContext, lFileName);\n  end;\nend;\n\nfunction TMVCStaticFilesMiddleware.SendStaticFileIfPresent(const AContext: TWebContext;\n  const AFileName: string): Boolean;\nvar\n  lContentType: string;\nbegin\n  Result := False;\n  if TFile.Exists(AFileName) then\n  begin\n    if fMediaTypes.TryGetValue(LowerCase(ExtractFileExt(AFileName)), lContentType) then\n    begin\n      lContentType := BuildContentType(lContentType, fStaticFilesCharset);\n    end\n    else\n    begin\n      lContentType := BuildContentType(TMVCMediaType.APPLICATION_OCTETSTREAM, '');\n    end;\n    TMVCStaticContents.SendFile(AFileName, lContentType, AContext);\n    Result := True;\n    LogI(AContext.Request.HTTPMethodAsString + ':' +\n      AContext.Request.PathInfo + ' [' + AContext.Request.ClientIp + '] -> ' +\n      ClassName + ' - ' + IntToStr(AContext.Response.StatusCode) + ' ' +\n      AContext.Response.ReasonString);\n  end;\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;   \nusing MVCFramework.Logger;    \n\nnamespace MVCFramework.Middleware\n{\n    \n    public static class MvcStaticFilesDefaults\n    {\n        \n        public const string StaticFilesPath = \"/static\";\n\n        \n        public const string DocumentRoot = @\".\\www\";\n\n        \n        public const string IndexDocument = \"index.html\";\n\n        \n        public const string StaticFilesContentCharset = MVCConstants.DefaultContentCharset;\n    }\n\n    \n    public delegate void MvcStaticFileRulesProc(IWebContext context, ref string pathInfo, ref bool handled);\n\n    \n    public delegate void MvcStaticFileMediaTypesCustomizer(Dictionary<string, string> mediaTypes);\n\n    \n    public class MvcStaticFilesMiddleware : IMiddleware\n    {\n        private bool sanityCheckOK;\n        private readonly Dictionary<string, string> mediaTypes;\n        private readonly string staticFilesPath;\n        private readonly string documentRoot;\n        private readonly string indexDocument;\n        private readonly string staticFilesCharset;\n        private readonly bool spaWebAppSupport;\n        private readonly MvcStaticFileRulesProc rules;\n\n        \n        public MvcStaticFilesMiddleware(\n            string staticFilesPath = MvcStaticFilesDefaults.StaticFilesPath,\n            string documentRoot = MvcStaticFilesDefaults.DocumentRoot,\n            string indexDocument = MvcStaticFilesDefaults.IndexDocument,\n            bool spaWebAppSupport = true,\n            string staticFilesCharset = MvcStaticFilesDefaults.StaticFilesContentCharset,\n            MvcStaticFileRulesProc rules = null,\n            MvcStaticFileMediaTypesCustomizer mediaTypesCustomizer = null)\n        {\n            sanityCheckOK = false;\n            this.staticFilesPath = staticFilesPath.Trim();\n            if (!this.staticFilesPath.EndsWith(\"/\"))\n            {\n                this.staticFilesPath += \"/\";\n            }\n\n            \n            if (Directory.Exists(documentRoot))\n            {\n                this.documentRoot = Path.GetFullPath(documentRoot);\n            }\n            else\n            {\n                \n                this.documentRoot = Path.Combine(MVCConstants.AppPath, documentRoot);\n            }\n\n            this.indexDocument = indexDocument;\n            this.staticFilesCharset = staticFilesCharset;\n            this.spaWebAppSupport = spaWebAppSupport;\n            this.rules = rules;\n\n            mediaTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            AddMediaTypes();\n            mediaTypesCustomizer?.Invoke(mediaTypes);\n        }\n\n        private void AddMediaTypes()\n        {\n            mediaTypes[\".html\"] = MVCMediaType.TextHtml;\n            mediaTypes[\".htm\"] = MVCMediaType.TextHtml;\n            mediaTypes[\".txt\"] = MVCMediaType.TextPlain;\n            mediaTypes[\".text\"] = MVCMediaType.TextPlain;\n            mediaTypes[\".csv\"] = MVCMediaType.TextCsv;\n            mediaTypes[\".css\"] = MVCMediaType.TextCss;\n            mediaTypes[\".js\"] = MVCMediaType.TextJavascript;\n            mediaTypes[\".json\"] = MVCMediaType.ApplicationJson;\n            mediaTypes[\".jpg\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".jpeg\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".jpe\"] = MVCMediaType.ImageJpeg;\n            mediaTypes[\".png\"] = MVCMediaType.ImagePng;\n            mediaTypes[\".ico\"] = MVCMediaType.ImageXIcon;\n            mediaTypes[\".appcache\"] = MVCMediaType.TextCacheManifest;\n            mediaTypes[\".svg\"] = MVCMediaType.ImageSvgXml;\n            mediaTypes[\".xml\"] = MVCMediaType.TextXml;\n            mediaTypes[\".pdf\"] = MVCMediaType.ApplicationPdf;\n            mediaTypes[\".svgz\"] = MVCMediaType.ImageSvgXml;\n            mediaTypes[\".gif\"] = MVCMediaType.ImageGif;\n        }\n\n        private void DoSanityCheck()\n        {\n            if (!staticFilesPath.StartsWith(\"/\"))\n            {\n                throw new Exception(\"StaticFilePath must begin with '/' and cannot be empty\");\n            }\n            if (!Directory.Exists(documentRoot))\n            {\n                throw new Exception($\"MvcStaticFilesMiddleware Error: DocumentRoot [{documentRoot}] is not a valid directory\");\n            }\n            sanityCheckOK = true;\n        }\n\n        \n        private bool SendStaticFileIfPresent(IWebContext context, string fileName)\n        {\n            if (File.Exists(fileName))\n            {\n                string contentType;\n                string ext = Path.GetExtension(fileName).ToLower();\n                if (!mediaTypes.TryGetValue(ext, out contentType))\n                {\n                    contentType = BuildContentType(MVCMediaType.ApplicationOctetStream, \"\");\n                }\n                else\n                {\n                    contentType = BuildContentType(contentType, staticFilesCharset);\n                }\n                \n                MvcStaticContents.SendFile(fileName, contentType, context);\n                Log.Info($\"{context.Request.HttpMethod}:{context.Request.PathInfo} [{context.Request.ClientIp}] -> {GetType().Name} - {context.Response.StatusCode} {context.Response.ReasonPhrase}\");\n                return true;\n            }\n            return false;\n        }\n\n        \n        private string BuildContentType(string baseContentType, string charset)\n        {\n            if (string.IsNullOrEmpty(charset))\n            {\n                return baseContentType;\n            }\n            return $\"{baseContentType}; charset={charset}\";\n        }\n\n        public void OnBeforeRouting(IWebContext context, ref bool handled)\n        {\n            \n            string pathInfo = context.Request.PathInfo;\n\n            \n            if (!pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n            {\n                if (!pathInfo.EndsWith(\"/\"))\n                {\n                    \n                    pathInfo += \"/\";\n                    if (!pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n                    {\n                        handled = false;\n                        return;\n                    }\n                }\n                else\n                {\n                    handled = false;\n                    return;\n                }\n            }\n\n            \n            if (rules != null)\n            {\n                bool allow = true;\n                rules(context, ref pathInfo, ref allow);\n                if (!allow)\n                {\n                    handled = true;\n                    return;\n                }\n            }\n\n            \n            if (pathInfo.StartsWith(staticFilesPath, StringComparison.OrdinalIgnoreCase))\n            {\n                pathInfo = pathInfo.Substring(staticFilesPath.Length);\n            }\n            \n            pathInfo = pathInfo.Replace(\"/\", Path.DirectorySeparatorChar.ToString());\n            if (pathInfo.StartsWith(Path.DirectorySeparatorChar.ToString()))\n            {\n                pathInfo = pathInfo.Substring(1);\n            }\n            \n            string fullPathInfo = Path.Combine(documentRoot, pathInfo);\n\n            if (!sanityCheckOK)\n            {\n                DoSanityCheck();\n            }\n\n            \n            bool isDirTraversal;\n            string realFileName = MvcStaticContents.IsStaticFile(documentRoot, pathInfo, out isDirTraversal);\n            if (!string.IsNullOrEmpty(realFileName))\n            {\n                if (isDirTraversal)\n                {\n                    context.Response.StatusCode = (int)System.Net.HttpStatusCode.NotFound;\n                    handled = true;\n                    return;\n                }\n                handled = SendStaticFileIfPresent(context, realFileName);\n                if (handled)\n                {\n                    return;\n                }\n            }\n\n            \n            if (Directory.Exists(fullPathInfo))\n            {\n                \n                if (!context.Request.PathInfo.EndsWith(\"/\"))\n                {\n                    context.Response.StatusCode = (int)System.Net.HttpStatusCode.MovedPermanently;\n                    context.Response.CustomHeaders[\"Location\"] = context.Request.PathInfo + \"/\";\n                    handled = true;\n                    return;\n                }\n                \n                if (!string.IsNullOrEmpty(indexDocument))\n                {\n                    handled = SendStaticFileIfPresent(context, Path.Combine(fullPathInfo, indexDocument));\n                    return;\n                }\n            }\n\n            \n            if (!handled && spaWebAppSupport && !string.IsNullOrEmpty(indexDocument))\n            {\n                while (!string.IsNullOrEmpty(fullPathInfo) && !Directory.Exists(fullPathInfo))\n                {\n                    DirectoryInfo parent = Directory.GetParent(fullPathInfo);\n                    fullPathInfo = parent?.FullName ?? \"\";\n                }\n                string fileName = Path.GetFullPath(Path.Combine(fullPathInfo, indexDocument));\n                handled = SendStaticFileIfPresent(context, fileName);\n            }\n        }\n\n        public void OnBeforeControllerAction(IWebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // No action needed here.\n        }\n\n        public void OnAfterControllerAction(IWebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // No action needed here.\n        }\n\n        public void OnAfterRouting(IWebContext context, bool handled)\n        {\n            // No action needed here.\n        }\n    }\n}"}
{"input": "unit frmGenerate;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  System.Json,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls;\n\ntype\n  TForm1 = class(TForm)\n    Memo1: TMemo;\n    btnGenerate: TButton;\n    procedure btnGenerateClick(Sender: TObject);\n  private\n    function CreateJsonSomeSubType: TJsonObject;\n    function CreateJsonSomeType(pJsonObjectSubType: TJsonObject): TJsonObject;\n  public\n    { Public declarations }\n  end;\n\nvar\n  Form1: TForm1;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  Json.Common.Helpers,\n  Swag.Common.Types,\n  Swag.Doc.Path,\n  Swag.Doc.Path.Operation,\n  Swag.Doc.Path.Operation.RequestParameter,\n  Swag.Doc.Path.Operation.Response,\n  Swag.Doc.Path.Operation.ResponseHeaders,\n  Swag.Doc.Definition,\n  Swag.Doc;\n\nprocedure TForm1.btnGenerateClick(Sender: TObject);\nvar\n  vSwagDoc: TSwagDoc;\n  vPath: TSwagPath;\n  vOperation: TSwagPathOperation;\n  vParam: TSwagRequestParameter;\n  vResponse: TSwagResponse;\n  vDefinitionSomeType: TSwagDefinition;\n  vDefinitionResponseSomeType: TSwagDefinition;\n  vDefinitionSomeSubType: TSwagDefinition;\n  vResponseHeader: TSwagHeaders;\nbegin\n  vSwagDoc := TSwagDoc.Create;\n  try\n    vSwagDoc.Info.Title := 'Sample API';\n    vSwagDoc.Info.Version := 'v1.2';\n    vSwagDoc.Info.TermsOfService := 'https://example.com/someurl/tos';\n    vSwagDoc.Info.Description := 'Sample API Description';\n    vSwagDoc.Info.Contact.Name := 'John Smith';\n    vSwagDoc.Info.Contact.Email := 'jsmith@example.com';\n    vSwagDoc.Info.Contact.Url := 'https://example.com/contact';\n    vSwagDoc.Info.License.Name := 'Some License';\n    vSwagDoc.Info.License.Url := 'https://example.com/license';\n\n    vSwagDoc.Host := 'example.com';\n    vSwagDoc.BasePath := '/basepath';\n\n    vSwagDoc.Consumes.Add('application/json');\n\n    vSwagDoc.Produces.Add('text/xml');\n    vSwagDoc.Produces.Add('application/json');\n\n    vSwagDoc.Schemes := [tpsHttps];\n\n    vDefinitionSomeSubType := TSwagDefinition.Create;\n    vDefinitionSomeSubType.Name := 'SomeSubType';\n    vDefinitionSomeSubType.JsonSchema := CreateJsonSomeSubType;\n    vSwagDoc.Definitions.Add(vDefinitionSomeSubType);\n\n    vDefinitionSomeType := TSwagDefinition.Create;\n    vDefinitionSomeType.Name := 'SomeType';\n    vDefinitionSomeType.JsonSchema := CreateJsonSomeType(vDefinitionSomeSubType.GenerateJsonRefDefinition);\n    vSwagDoc.Definitions.Add(vDefinitionSomeType);\n\n    vPath := TSwagPath.Create;\n    vPath.Uri := '/path/request/{param1}';\n\n    vOperation := TSwagPathOperation.Create;\n    vOperation.Operation := ohvPost;\n    vOperation.OperationId := 'RequestData';\n    vOperation.Description := 'Requests some data';\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param1';\n    vParam.InLocation := rpiPath;\n    vParam.Description := 'A param required';\n    vParam.Required := True;\n    vParam.TypeParameter := stpString;\n    vOperation.Parameters.Add(vParam);\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param2';\n    vParam.InLocation := rpiQuery;\n    vParam.Description := 'A param that is not required';\n    vParam.Required := False;\n    vParam.TypeParameter := stpString;\n    vOperation.Parameters.Add(vParam);\n\n    vParam := TSwagRequestParameter.Create;\n    vParam.Name := 'param3';\n    vParam.InLocation := rpiBody;\n    vParam.Required := True;\n    vParam.Schema.Name := 'SomeType';\n    vOperation.Parameters.Add(vParam);\n\n    vResponse := TSwagResponse.Create;\n    vResponse.StatusCode := '200';\n    vResponse.Description := 'Successfully retrieved data';\n    vResponse.Schema.Name := 'SomeType';\n    vOperation.Responses.Add('200', vResponse);\n\n    vResponseHeader := TSwagHeaders.Create;\n    vResponseHeader.Name := 'X-Rate-Limit-Limit';\n    vResponseHeader.Description := 'The number of allowed requests in the current period';\n    vResponseHeader.ValueType := 'integer';\n    vResponse.Headers.Add(vResponseHeader);\n    \n    vResponse := TSwagResponse.Create;\n    vResponse.StatusCode := 'default';\n    vResponse.Description := 'Error occured';\n\n    vOperation.Responses.Add('default',vResponse);\n\n    vOperation.Tags.Add('TagName');\n        \n    vPath.Operations.Add(vOperation);\n    vSwagDoc.Paths.Add(vPath);\n\n    vSwagDoc.GenerateSwaggerJson;\n    Memo1.Lines.Add(vSwagDoc.SwaggerJson.Format);\n  finally\n    FreeAndNil(vSwagDoc);\n  end;\nend;\n\nfunction TForm1.CreateJsonSomeSubType: TJsonObject;\nvar\n  vJsonType: TJsonObject;\n  vJsonProperities: TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n\n  Result.AddPair('type','object');\n\n  vJsonType := TJsonObject.Create;\n  vJsonType.AddPair('type', 'string');\n\n  vJsonProperities := TJsonObject.Create;\n  vJsonProperities.AddPair('id', vJsonType);\n\n  Result.AddPair('properties', vJsonProperities);\nend;\n\nfunction TForm1.CreateJsonSomeType(pJsonObjectSubType: TJsonObject): TJsonObject;\nvar\n  vJsonId: TJsonObject;\n  vJsonCost: TJsonObject;\n  vJsonProperities: TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.AddPair('type', 'object');\n\n  vJsonId := TJsonObject.Create;\n  vJsonId.AddPair('type', 'integer');\n  vJsonId.AddPair('format', 'int64');\n\n  vJsonProperities := TJsonObject.Create;\n  vJsonProperities.AddPair('id', vJsonId);\n\n  vJsonProperities.AddPair('subType', pJsonObjectSubType);\n\n  vJsonCost := TJsonObject.Create;\n  vJsonCost.AddPair('type', 'string');\n  vJsonCost.AddPair('format', 'decimel');\n  vJsonCost.AddPair('multipleOf', TJsonNumber.Create(0.01));\n  vJsonCost.AddPair('minimum', TJsonNumber.Create(-9999999999.99));\n  vJsonCost.AddPair('maximum', TJsonNumber.Create(9999999999.99));\n  vJsonCost.AddPair('title', 'Total Cost');\n  vJsonCost.AddPair('description', 'Total Cost');\n  vJsonCost.AddPair('example', TJsonNumber.Create(9999999999.99));\n  vJsonProperities.AddPair('cost', vJsonCost);\n\n  Result.AddPair('properties', vJsonProperities);\nend;\n\ninitialization\n  ReportMemoryLeaksOnShutdown := True;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing System.Net;\n\nnamespace frmGenerate\n{\n\n    public class SwagDoc\n    {\n        public SwagInfo Info { get; set; } = new SwagInfo();\n        public string Host { get; set; }\n        public string BasePath { get; set; }\n        public List<string> Consumes { get; set; } = new List<string>();\n        public List<string> Produces { get; set; } = new List<string>();\n        public List<string> Schemes { get; set; } = new List<string>();\n        public List<SwagDefinition> Definitions { get; set; } = new List<SwagDefinition>();\n        public List<SwagPath> Paths { get; set; } = new List<SwagPath>();\n        public JObject SwaggerJson { get; set; }\n\n        public void GenerateSwaggerJson()\n        {\n            \n            var doc = new JObject\n            {\n                [\"swagger\"] = \"2.0\",\n                [\"info\"] = Info.ToJObject(),\n                [\"host\"] = Host,\n                [\"basePath\"] = BasePath,\n                [\"consumes\"] = new JArray(Consumes),\n                [\"produces\"] = new JArray(Produces),\n                [\"schemes\"] = new JArray(Schemes)\n            };\n\n            var defs = new JObject();\n            foreach (var def in Definitions)\n            {\n                defs[def.Name] = def.JsonSchema;\n            }\n            doc[\"definitions\"] = defs;\n\n            var paths = new JObject();\n            foreach (var path in Paths)\n            {\n                paths[path.Uri] = path.ToJObject();\n            }\n            doc[\"paths\"] = paths;\n\n            SwaggerJson = doc;\n        }\n    }\n\n    public class SwagInfo\n    {\n        public string Title { get; set; }\n        public string Version { get; set; }\n        public string TermsOfService { get; set; }\n        public string Description { get; set; }\n        public SwagContact Contact { get; set; } = new SwagContact();\n        public SwagLicense License { get; set; } = new SwagLicense();\n\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"title\"] = Title,\n                [\"version\"] = Version,\n                [\"termsOfService\"] = TermsOfService,\n                [\"description\"] = Description,\n                [\"contact\"] = Contact.ToJObject(),\n                [\"license\"] = License.ToJObject()\n            };\n        }\n    }\n\n    public class SwagContact\n    {\n        public string Name { get; set; }\n        public string Email { get; set; }\n        public string Url { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"name\"] = Name,\n                [\"email\"] = Email,\n                [\"url\"] = Url\n            };\n        }\n    }\n\n    public class SwagLicense\n    {\n        public string Name { get; set; }\n        public string Url { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"name\"] = Name,\n                [\"url\"] = Url\n            };\n        }\n    }\n\n    public class SwagDefinition\n    {\n        public string Name { get; set; }\n        public JObject JsonSchema { get; set; }\n        public JObject GenerateJsonRefDefinition()\n        {\n            return new JObject(new JProperty(\"$ref\", \"#/definitions/\" + Name));\n        }\n    }\n\n    public class SwagPath\n    {\n        public string Uri { get; set; }\n        public List<SwagPathOperation> Operations { get; set; } = new List<SwagPathOperation>();\n        public JObject ToJObject()\n        {\n            var obj = new JObject();\n            foreach (var op in Operations)\n            {\n                obj[op.Operation.ToLower()] = op.ToJObject();\n            }\n            return obj;\n        }\n    }\n\n    public class SwagPathOperation\n    {\n        public string Operation { get; set; } \n        public string OperationId { get; set; }\n        public string Description { get; set; }\n        public List<SwagRequestParameter> Parameters { get; set; } = new List<SwagRequestParameter>();\n        public Dictionary<string, SwagResponse> Responses { get; set; } = new Dictionary<string, SwagResponse>();\n        public List<string> Tags { get; set; } = new List<string>();\n\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"operationId\"] = OperationId,\n                [\"description\"] = Description,\n                [\"tags\"] = new JArray(Tags)\n            };\n\n            var jParams = new JArray();\n            foreach (var param in Parameters)\n            {\n                jParams.Add(param.ToJObject());\n            }\n            obj[\"parameters\"] = jParams;\n\n            var jResponses = new JObject();\n            foreach (var kvp in Responses)\n            {\n                jResponses[kvp.Key] = kvp.Value.ToJObject();\n            }\n            obj[\"responses\"] = jResponses;\n\n            return obj;\n        }\n    }\n\n    public class SwagRequestParameter\n    {\n        public string Name { get; set; }\n        public string InLocation { get; set; }   \n        public string Description { get; set; }\n        public bool Required { get; set; }\n        public string TypeParameter { get; set; }  \n        public SwagSchema Schema { get; set; } = new SwagSchema();\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"name\"] = Name,\n                [\"in\"] = InLocation,\n                [\"description\"] = Description,\n                [\"required\"] = Required\n            };\n\n            if (!string.IsNullOrEmpty(TypeParameter))\n            {\n                obj[\"type\"] = TypeParameter;\n            }\n            if (!string.IsNullOrEmpty(Schema.Name))\n            {\n                obj[\"schema\"] = new JObject { [\"$ref\"] = \"#/definitions/\" + Schema.Name };\n            }\n            return obj;\n        }\n    }\n\n    public class SwagSchema\n    {\n        public string Name { get; set; }\n    }\n\n    public class SwagResponse\n    {\n        public string StatusCode { get; set; }\n        public string Description { get; set; }\n        public SwagSchema Schema { get; set; } = new SwagSchema();\n        public List<SwagHeaders> Headers { get; set; } = new List<SwagHeaders>();\n        public JObject ToJObject()\n        {\n            var obj = new JObject\n            {\n                [\"description\"] = Description\n            };\n\n            if (!string.IsNullOrEmpty(Schema.Name))\n            {\n                obj[\"schema\"] = new JObject { [\"$ref\"] = \"#/definitions/\" + Schema.Name };\n            }\n\n            if (Headers.Count > 0)\n            {\n                var jHeaders = new JObject();\n                foreach (var header in Headers)\n                {\n                    jHeaders[header.Name] = header.ToJObject();\n                }\n                obj[\"headers\"] = jHeaders;\n            }\n            return obj;\n        }\n    }\n\n    public class SwagHeaders\n    {\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public string ValueType { get; set; }\n        public JObject ToJObject()\n        {\n            return new JObject\n            {\n                [\"description\"] = Description,\n                [\"type\"] = ValueType\n            };\n        }\n    }\n\n    public class Form1 : Form\n    {\n        private TextBox memo1;\n        private Button btnGenerate;\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            this.memo1 = new TextBox();\n            this.btnGenerate = new Button();\n            \n            this.memo1.Multiline = true;\n            this.memo1.ScrollBars = ScrollBars.Both;\n            this.memo1.Location = new Point(12, 12);\n            this.memo1.Size = new Size(760, 400);\n            this.memo1.Font = new Font(\"Consolas\", 10);\n            \n            this.btnGenerate.Location = new Point(12, 420);\n            this.btnGenerate.Size = new Size(150, 30);\n            this.btnGenerate.Text = \"Generate\";\n            this.btnGenerate.Click += new EventHandler(this.btnGenerate_Click);\n             \n            this.ClientSize = new Size(784, 461);\n            this.Controls.Add(this.memo1);\n            this.Controls.Add(this.btnGenerate);\n            this.Text = \"Swagger Generator\";\n        }\n\n        private void btnGenerate_Click(object sender, EventArgs e)\n        {\n            \n            SwagDoc swagDoc = new SwagDoc();\n\n            \n            swagDoc.Info.Title = \"Sample API\";\n            swagDoc.Info.Version = \"v1.2\";\n            swagDoc.Info.TermsOfService = \"https://example.com/someurl/tos\";\n            swagDoc.Info.Description = \"Sample API Description\";\n            swagDoc.Info.Contact.Name = \"John Smith\";\n            swagDoc.Info.Contact.Email = \"jsmith@example.com\";\n            swagDoc.Info.Contact.Url = \"https://example.com/contact\";\n            swagDoc.Info.License.Name = \"Some License\";\n            swagDoc.Info.License.Url = \"https://example.com/license\";\n\n            \n            swagDoc.Host = \"example.com\";\n            swagDoc.BasePath = \"/basepath\";\n\n            \n            swagDoc.Consumes.Add(\"application/json\");\n            swagDoc.Produces.Add(\"text/xml\");\n            swagDoc.Produces.Add(\"application/json\");\n\n            \n            swagDoc.Schemes.Add(\"https\");\n\n            \n            SwagDefinition defSomeSubType = new SwagDefinition\n            {\n                Name = \"SomeSubType\",\n                JsonSchema = CreateJsonSomeSubType()\n            };\n            swagDoc.Definitions.Add(defSomeSubType);\n\n            SwagDefinition defSomeType = new SwagDefinition\n            {\n                Name = \"SomeType\",\n                JsonSchema = CreateJsonSomeType(defSomeSubType.GenerateJsonRefDefinition())\n            };\n            swagDoc.Definitions.Add(defSomeType);\n\n            \n            SwagPath path = new SwagPath\n            {\n                Uri = \"/path/request/{param1}\"\n            };\n\n            \n            SwagPathOperation operation = new SwagPathOperation\n            {\n                Operation = \"post\",\n                OperationId = \"RequestData\",\n                Description = \"Requests some data\"\n            };\n\n            \n            SwagRequestParameter param1 = new SwagRequestParameter\n            {\n                Name = \"param1\",\n                InLocation = \"path\",\n                Description = \"A param required\",\n                Required = true,\n                TypeParameter = \"string\"\n            };\n            operation.Parameters.Add(param1);\n\n            \n            SwagRequestParameter param2 = new SwagRequestParameter\n            {\n                Name = \"param2\",\n                InLocation = \"query\",\n                Description = \"A param that is not required\",\n                Required = false,\n                TypeParameter = \"string\"\n            };\n            operation.Parameters.Add(param2);\n\n           \n            SwagRequestParameter param3 = new SwagRequestParameter\n            {\n                Name = \"param3\",\n                InLocation = \"body\",\n                Required = true\n            };\n            param3.Schema.Name = \"SomeType\";\n            operation.Parameters.Add(param3);\n\n            SwagResponse response200 = new SwagResponse\n            {\n                StatusCode = \"200\",\n                Description = \"Successfully retrieved data\"\n            };\n            response200.Schema.Name = \"SomeType\";\n\n            SwagHeaders header = new SwagHeaders\n            {\n                Name = \"X-Rate-Limit-Limit\",\n                Description = \"The number of allowed requests in the current period\",\n                ValueType = \"integer\"\n            };\n            response200.Headers.Add(header);\n            operation.Responses.Add(\"200\", response200);\n\n            SwagResponse responseDefault = new SwagResponse\n            {\n                StatusCode = \""}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit PublicControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/')]\n  TPublicController = class(TMVCController)\n  public\n    [MVCPath('/')]\n    [MVCHTTPMethod([httpGET])]\n    procedure Index;\n\n  end;\n\nimplementation\n\nprocedure TPublicController.Index;\nbegin\n  // use Context property to access to the HTTP request and response\n  Render('Hello World');\n\nend;\n\nend.", "output": "namespace MyApp.Controllers { \n    [RoutePrefix(\"\")] \n    public class PublicController : ApiController { [HttpGet] [Route(\"\")] \n        public IHttpActionResult Index() { \n        \n            return Ok(\"Hello World\"); \n        } \n    } \n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit TestServerControllerJSONRPCU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, MVCFramework.JSONRPC, JsonDataObjects,\n  BusinessObjectsU;\n\ntype\n  TTestJSONRPCController = class(TMVCJSONRPCController)\n  public\n    [MVCInheritable]\n    function Subtract(Value1, Value2: Int64): Integer;\n    [MVCInheritable]\n    procedure MyNotify;\n    [MVCInheritable]\n    function MyRequest: Boolean;\n    [MVCInheritable]\n    function Add(Value1, Value2, Value3: Int64): TJsonObject;\n    [MVCInheritable]\n    function GetListFromTo(aFrom, aTo: Int64): TJsonArray;\n    [MVCInheritable]\n    function MultiplyString(aString: string; Multiplier: Int64): string;\n\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCControllerWithGet = class(TTestJSONRPCController)\n\n  end;\n\n  TTestJSONRPCClass = class(TObject)\n  public\n    [MVCInheritable]\n    function Subtract(Value1, Value2: Int64): Integer;\n    [MVCInheritable]\n    procedure MyNotify;\n    [MVCInheritable]\n    function Add(Value1, Value2, Value3: Int64): TJsonObject;\n    [MVCInheritable]\n    function GetListFromTo(aFrom, aTo: Int64): TJsonArray;\n    [MVCInheritable]\n    function MultiplyString(aString: string; Multiplier: Int64): string;\n    [MVCInheritable]\n    function AddTimeToDateTime(aDateTime: TDateTime; aTime: TTime): TDateTime;\n\n    //exceptions\n    [MVCInheritable]\n    function DoError(MyObj: TPerson): TPerson;\n\n    //objects support\n    [MVCInheritable]\n    function HandlingObjects(MyObj: TPerson): TPerson;\n\n\n    //enums support\n    [MVCInheritable]\n    function ProcessEnums(Value1: TEnumTest; Value2: TEnumTest): TEnumTest;\n\n    //sets support\n    [MVCInheritable]\n    function ProcessSets(Value1: TSetOfEnumTest; Value2: TEnumTest): TSetOfEnumTest;\n\n    //records support\n    [MVCInheritable]\n    function GetSingleRecord: TSimpleRecord;\n    [MVCInheritable]\n    function GetArrayOfRecords: TArray<TSimpleRecord>;\n    [MVCInheritable]\n    function EchoSingleRecord(const SimpleRecord: TSimpleRecord): TSimpleRecord;\n    [MVCInheritable]\n    function GetSingleComplexRecord: TComplexRecord;\n    [MVCInheritable]\n    function EchoSingleComplexRecord(const ComplexRecord: TComplexRecord): TComplexRecord;\n    [MVCInheritable]\n    function EchoArrayOfRecords(const ComplexRecordArray: TComplexRecordArray): TComplexRecordArray;\n\n    //issues\n    [MVCInheritable]\n    function GetTCustomer_ISSUE648: TCustomerIssue648;\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCClassWithGET = class(TTestJSONRPCClass)\n\n  end;\n\n  TTestJSONRPCHookClass = class(TObject)\n  private\n    fJSONReq: TJsonObject;\n    fHistory: string;\n    fJSONRPCKind: TJSONRPCRequestType;\n  public\n    procedure OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJsonObject);\n    procedure OnBeforeCallHook(const Context: TWebContext; const JSON: TJsonObject);\n    procedure OnAfterCallHook(const Context: TWebContext; const JSON: TJsonObject);\n    [MVCInheritable]\n    function error_OnBeforeRoutingHook: Boolean;\n    [MVCInheritable]\n    function error_OnBeforeCallHook: Boolean;\n    [MVCInheritable]\n    function error_OnAfterCallHook: Boolean;\n    [MVCInheritable]\n    procedure Notif1;\n    [MVCInheritable]\n    procedure NotifWithError;\n    [MVCInheritable]\n    function Request1: string;\n    [MVCInheritable]\n    function RequestWithError: string;\n  end;\n\n  [MVCJSONRPCAllowGET]\n  TTestJSONRPCHookClassWithGet = class(TTestJSONRPCHookClass)\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Logger, System.StrUtils;\n\n{ TTestJSONRPCController }\n\nfunction TTestJSONRPCController.Add(Value1, Value2, Value3: Int64): TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.I['res'] := Value1 + Value2 + Value3;\nend;\n\nfunction TTestJSONRPCController.GetListFromTo(aFrom, aTo: Int64): TJsonArray;\nvar\n  I: Cardinal;\nbegin\n  Result := TJsonArray.Create;\n  for I := aFrom to aTo do\n    Result.Add(I);\nend;\n\nfunction TTestJSONRPCClass.GetSingleComplexRecord: TComplexRecord;\nbegin\n  Result := TComplexRecord.Create;\nend;\n\nfunction TTestJSONRPCClass.GetSingleRecord: TSimpleRecord;\nbegin\n  Result := TSimpleRecord.Create;\nend;\n\nfunction TTestJSONRPCClass.GetTCustomer_ISSUE648: TCustomerIssue648;\nbegin\n  Result.Id := 155;\n  Result.Added := Now;\n  Result.Name := 'Daniele Teti';\n  Result.ExpirationDate := Now + 7;\n  Result.MaxUpdateDate.Clear;\n  Result.AppVersion.Clear;\n  Result.Activated.Clear;\nend;\n\nfunction TTestJSONRPCClass.HandlingObjects(MyObj: TPerson): TPerson;\nbegin\n  Result := TPerson.Create;\n  Result.ID := MyObj.ID;\n  Result.FirstName := MyObj.FirstName;\n  Result.LastName := MyObj.LastName;\n  Result.DOB := MyObj.DOB;\n  Result.Married := MyObj.Married;\nend;\n\nfunction TTestJSONRPCController.MultiplyString(aString: string; Multiplier: Int64): string;\nvar\n  I: Integer;\nbegin\n  Result := aString;\n  for I := 2 to Multiplier do\n  begin\n    Result := Result + aString;\n  end;\nend;\n\nprocedure TTestJSONRPCController.MyNotify;\nbegin\n  // this is a notify with no parameters and no result code\n  Self.ClassName;\nend;\n\nfunction TTestJSONRPCController.MyRequest: Boolean;\nbegin\n  Result := True;\nend;\n\nfunction TTestJSONRPCController.Subtract(Value1, Value2: Int64): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TTestJSONRPCClass }\n\nfunction TTestJSONRPCClass.Add(Value1, Value2, Value3: Int64): TJsonObject;\nbegin\n  Result := TJsonObject.Create;\n  Result.I['res'] := Value1 + Value2 + Value3;\nend;\n\nfunction TTestJSONRPCClass.AddTimeToDateTime(aDateTime: TDateTime; aTime: TTime): TDateTime;\nbegin\n  Result := aDateTime + aTime;\nend;\n\nfunction TTestJSONRPCClass.DoError(MyObj: TPerson): TPerson;\nbegin\n  raise Exception.Create('BOOOM!! (TTestJSONRPCClass.DoError)');\nend;\n\nfunction TTestJSONRPCClass.EchoArrayOfRecords(\n  const ComplexRecordArray: TComplexRecordArray): TComplexRecordArray;\nbegin\n  Result := ComplexRecordArray;\nend;\n\nfunction TTestJSONRPCClass.EchoSingleComplexRecord(\n  const ComplexRecord: TComplexRecord): TComplexRecord;\nbegin\n  Result := ComplexRecord;\nend;\n\nfunction TTestJSONRPCClass.EchoSingleRecord(\n  const SimpleRecord: TSimpleRecord): TSimpleRecord;\nbegin\n  Result := SimpleRecord;\nend;\n\nfunction TTestJSONRPCClass.GetArrayOfRecords: TArray<TSimpleRecord>;\nbegin\n  SetLength(Result, 3);\n  Result[0] := TSimpleRecord.Create;\n  Result[1] := TSimpleRecord.Create;\n  Result[2] := TSimpleRecord.Create;\n\n  Result[0].IntegerProperty := 0;\n  Result[1].IntegerProperty := 1;\n  Result[2].IntegerProperty := 2;\nend;\n\nfunction TTestJSONRPCClass.GetListFromTo(aFrom, aTo: Int64): TJsonArray;\nvar\n  I: Cardinal;\nbegin\n  Result := TJsonArray.Create;\n  for I := aFrom to aTo do\n    Result.Add(I);\nend;\n\nfunction TTestJSONRPCClass.MultiplyString(aString: string; Multiplier: Int64): string;\nvar\n  I: Integer;\nbegin\n  Result := aString;\n  for I := 2 to Multiplier do\n  begin\n    Result := Result + aString;\n  end;\nend;\n\nprocedure TTestJSONRPCClass.MyNotify;\nbegin\n  // this is a notify with no parameters and no result code\n  Self.ClassName;\nend;\n\nfunction TTestJSONRPCClass.ProcessEnums(Value1, Value2: TEnumTest): TEnumTest;\nbegin\n  Result := TEnumTest((Ord(Value1) + Ord(Value2)) mod 3);\nend;\n\nfunction TTestJSONRPCClass.ProcessSets(Value1: TSetOfEnumTest;\n  Value2: TEnumTest): TSetOfEnumTest;\nbegin\n  Include(Value1, Value2);\n  Result := Value1;\nend;\n\nfunction TTestJSONRPCClass.Subtract(Value1, Value2: Int64): Integer;\nbegin\n  Result := Value1 - Value2;\nend;\n\n{ TTestJSONRPCHookClass }\n\nfunction TTestJSONRPCHookClass.error_OnAfterCallHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nfunction TTestJSONRPCHookClass.error_OnBeforeCallHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nfunction TTestJSONRPCHookClass.error_OnBeforeRoutingHook: Boolean;\nbegin\n  // do nothing\n  Result := True;\nend;\n\nprocedure TTestJSONRPCHookClass.Notif1;\nbegin\n  // do nothing\nend;\n\nprocedure TTestJSONRPCHookClass.NotifWithError;\nbegin\n  raise Exception.Create('BOOM NOTIF');\nend;\n\nprocedure TTestJSONRPCHookClass.OnAfterCallHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  try\n    if SameText(fJSONReq.S['method'], 'error_OnAfterCallHook') then\n      raise Exception.Create('error_OnAfterCallHook');\n\n    fHistory := fHistory + '|OnAfterCallHook';\n\n    // do nothing\n    if fJSONRPCKind = TJSONRPCRequestType.Request then\n    begin\n      Assert(Assigned(JSON));\n      LogD('TTestJSONRPCHookClass.OnAfterCallHook: ' + JSON.ToJSON());\n    end\n    else\n    begin\n      if Assigned(JSON) then\n        Assert(JSON.Contains('error'), 'ERROR! Notification has a response but is not an error');\n      LogD('TTestJSONRPCHookClass.OnAfterCallHook: Param is nil');\n    end;\n    if Assigned(JSON) then\n      if JSON.Contains('error') then\n        fHistory := fHistory + '|error';\n    Context.Response.CustomHeaders.Values['x-history'] := fHistory;\n  finally\n    FreeAndNil(fJSONReq);\n  end;\nend;\n\nprocedure TTestJSONRPCHookClass.OnBeforeCallHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  if SameText(JSON.S['method'], 'error_OnBeforeCallHook') then\n    raise Exception.Create('error_OnBeforeCallHook');\n\n  fHistory := fHistory + '|OnBeforeCallHook';\n  Assert(Assigned(JSON), 'JSON not assigned in OnBeforeCallHook');\n  LogD('TTestJSONRPCHookClass.OnBeforeCallHook: ' + JSON.ToJSON());\nend;\n\nprocedure TTestJSONRPCHookClass.OnBeforeRoutingHook(const Context: TWebContext; const JSON: TJsonObject);\nbegin\n  fJSONReq := JSON.Clone as TJsonObject;\n\n  if SameText(JSON.S['method'], 'error_OnBeforeRoutingHook') then\n    raise Exception.Create('error_OnBeforeRoutingHook');\n\n  fHistory := 'OnBeforeRoutingHook';\n  // do nothing\n  Assert(Assigned(JSON), 'JSON not assigned in OnBeforeRoutingHook');\n  LogD('TTestJSONRPCHookClass.OnBeforeRoutingHook: ' + JSON.ToJSON());\n  if JSON.Contains('id') then\n    fJSONRPCKind := TJSONRPCRequestType.Request\n  else\n    fJSONRPCKind := TJSONRPCRequestType.Notification;\nend;\n\nfunction TTestJSONRPCHookClass.Request1: string;\nbegin\n  Result := 'empty';\nend;\n\nfunction TTestJSONRPCHookClass.RequestWithError: string;\nbegin\n  raise Exception.Create('BOOM REQUEST');\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Newtonsoft.Json.Linq;\n\nnamespace TestServer.JSONRPC\n{\n    public enum TEnumTest\n    {\n        ptEnumValue0,\n        ptEnumValue1,\n        ptEnumValue2,\n        ptEnumValue3\n    }\n\n    public class TSetOfEnumTest : HashSet<TEnumTest>\n    {\n    }\n\n    public class TSimpleRecord\n    {\n        public int IntegerProperty { get; set; }\n    }\n\n    public class TComplexRecord\n    {\n        public TComplexRecord() { }\n    }\n\n    public class TCustomerIssue648\n    {\n        public int Id { get; set; }\n        public DateTime Added { get; set; }\n        public string Name { get; set; }\n        public DateTime ExpirationDate { get; set; }\n        public DateTime? MaxUpdateDate { get; set; }\n        public string AppVersion { get; set; }\n        public string Activated { get; set; }\n    }\n\n    public class TPerson\n    {\n        public int ID { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        public DateTime DOB { get; set; }\n        public bool Married { get; set; }\n    }\n\n    public enum JSONRPCRequestType\n    {\n        Request,\n        Notification\n    }\n\n    [Route(\"api/jsonrpc\")]\n    [ApiController]\n    public class TestJsonRpcController : ControllerBase\n    {\n        [HttpPost(\"subtract\")]\n        [MVCInheritable]\n        public ActionResult<int> Subtract(long value1, long value2)\n        {\n            return (int)(value1 - value2);\n        }\n\n        [HttpPost(\"mynotify\")]\n        [MVCInheritable]\n        public IActionResult MyNotify()\n        {\n            var _ = GetType().Name;\n            return Ok();\n        }\n\n        [HttpPost(\"myrequest\")]\n        [MVCInheritable]\n        public ActionResult<bool> MyRequest()\n        {\n            return true;\n        }\n\n        [HttpPost(\"add\")]\n        [MVCInheritable]\n        public ActionResult<JObject> Add(long value1, long value2, long value3)\n        {\n            var obj = new JObject();\n            obj[\"res\"] = value1 + value2 + value3;\n            return obj;\n        }\n\n        [HttpPost(\"getlistfromto\")]\n        [MVCInheritable]\n        public ActionResult<JArray> GetListFromTo(long aFrom, long aTo)\n        {\n            var arr = new JArray();\n            for (long i = aFrom; i <= aTo; i++)\n                arr.Add(i);\n            return arr;\n        }\n\n        [HttpPost(\"multiplystring\")]\n        [MVCInheritable]\n        public ActionResult<string> MultiplyString(string aString, long multiplier)\n        {\n            var result = aString;\n            for (int i = 2; i <= multiplier; i++)\n                result += aString;\n            return result;\n        }\n    }\n\n    [Route(\"api/jsonrpcwithget\")]\n    [ApiController]\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcControllerWithGet : TestJsonRpcController\n    {\n    }\n\n    public class TestJsonRpcClass\n    {\n        [MVCInheritable]\n        public int Subtract(long value1, long value2)\n        {\n            return (int)(value1 - value2);\n        }\n\n        [MVCInheritable]\n        public void MyNotify()\n        {\n            var _ = GetType().Name;\n        }\n\n        [MVCInheritable]\n        public JObject Add(long value1, long value2, long value3)\n        {\n            var obj = new JObject();\n            obj[\"res\"] = value1 + value2 + value3;\n            return obj;\n        }\n\n        [MVCInheritable]\n        public JArray GetListFromTo(long aFrom, long aTo)\n        {\n            var arr = new JArray();\n            for (long i = aFrom; i <= aTo; i++)\n                arr.Add(i);\n            return arr;\n        }\n\n        [MVCInheritable]\n        public string MultiplyString(string aString, long multiplier)\n        {\n            var result = aString;\n            for (int i = 2; i <= multiplier; i++)\n                result += aString;\n            return result;\n        }\n\n        [MVCInheritable]\n        public DateTime AddTimeToDateTime(DateTime aDateTime, TimeSpan aTime)\n        {\n            return aDateTime + aTime;\n        }\n\n        [MVCInheritable]\n        public TPerson DoError(TPerson myObj)\n        {\n            throw new Exception(\"BOOOM!! (TestJsonRpcClass.DoError)\");\n        }\n\n        [MVCInheritable]\n        public TPerson HandlingObjects(TPerson myObj)\n        {\n            return new TPerson\n            {\n                ID = myObj.ID,\n                FirstName = myObj.FirstName,\n                LastName = myObj.LastName,\n                DOB = myObj.DOB,\n                Married = myObj.Married\n            };\n        }\n\n        [MVCInheritable]\n        public TEnumTest ProcessEnums(TEnumTest value1, TEnumTest value2)\n        {\n            return (TEnumTest)(((int)value1 + (int)value2) % 3);\n        }\n\n        [MVCInheritable]\n        public TSetOfEnumTest ProcessSets(TSetOfEnumTest value1, TEnumTest value2)\n        {\n            value1.Add(value2);\n            return value1;\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord GetSingleRecord()\n        {\n            return new TSimpleRecord();\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord[] GetArrayOfRecords()\n        {\n            return new TSimpleRecord[] { new TSimpleRecord(), new TSimpleRecord(), new TSimpleRecord() };\n        }\n\n        [MVCInheritable]\n        public TSimpleRecord EchoSingleRecord(TSimpleRecord simpleRecord)\n        {\n            return simpleRecord;\n        }\n\n        [MVCInheritable]\n        public TComplexRecord GetSingleComplexRecord()\n        {\n            return new TComplexRecord();\n        }\n\n        [MVCInheritable]\n        public TComplexRecord EchoSingleComplexRecord(TComplexRecord complexRecord)\n        {\n            return complexRecord;\n        }\n\n        [MVCInheritable]\n        public TComplexRecord[] EchoArrayOfRecords(TComplexRecord[] complexRecordArray)\n        {\n            return complexRecordArray;\n        }\n\n        [MVCInheritable]\n        public TCustomerIssue648 GetTCustomer_ISSUE648()\n        {\n            return new TCustomerIssue648\n            {\n                Id = 155,\n                Added = DateTime.Now,\n                Name = \"Daniele Teti\",\n                ExpirationDate = DateTime.Now.AddDays(7),\n                MaxUpdateDate = null,\n                AppVersion = null,\n                Activated = null\n            };\n        }\n    }\n\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcClassWithGet : TestJsonRpcClass\n    {\n    }\n\n    public class TestJsonRpcHookClass\n    {\n        private JObject fJSONReq;\n        private string fHistory;\n        private JSONRPCRequestType fJSONRPCKind;\n        public void OnBeforeRoutingHook(WebContext context, JObject json)\n        {\n            fJSONReq = (JObject)json.DeepClone();\n            if (string.Equals(json.Value<string>(\"method\"), \"error_OnBeforeRoutingHook\", StringComparison.OrdinalIgnoreCase))\n                throw new Exception(\"error_OnBeforeRoutingHook\");\n            fHistory = \"OnBeforeRoutingHook\";\n            if (json.ContainsKey(\"id\"))\n                fJSONRPCKind = JSONRPCRequestType.Request;\n            else\n                fJSONRPCKind = JSONRPCRequestType.Notification;\n        }\n        public void OnBeforeCallHook(WebContext context, JObject json)\n        {\n            if (string.Equals(json.Value<string>(\"method\"), \"error_OnBeforeCallHook\", StringComparison.OrdinalIgnoreCase))\n                throw new Exception(\"error_OnBeforeCallHook\");\n            fHistory += \"|OnBeforeCallHook\";\n        }\n        public void OnAfterCallHook(WebContext context, JObject json)\n        {\n            try\n            {\n                if (string.Equals(fJSONReq.Value<string>(\"method\"), \"error_OnAfterCallHook\", StringComparison.OrdinalIgnoreCase))\n                    throw new Exception(\"error_OnAfterCallHook\");\n                fHistory += \"|OnAfterCallHook\";\n                if (fJSONRPCKind == JSONRPCRequestType.Request)\n                {\n                    if (json == null)\n                        throw new Exception(\"JSON is null\");\n                }\n                else\n                {\n                    if (json != null)\n                        if (!json.ContainsKey(\"error\"))\n                            throw new Exception(\"ERROR! Notification has a response but is not an error\");\n                }\n                if (json != null && json.ContainsKey(\"error\"))\n                    fHistory += \"|error\";\n                context.Response.Headers[\"x-history\"] = fHistory;\n            }\n            finally\n            {\n                fJSONReq = null;\n            }\n        }\n        [MVCInheritable]\n        public bool error_OnBeforeRoutingHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public bool error_OnBeforeCallHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public bool error_OnAfterCallHook()\n        {\n            return true;\n        }\n        [MVCInheritable]\n        public void Notif1()\n        {\n        }\n        [MVCInheritable]\n        public void NotifWithError()\n        {\n            throw new Exception(\"BOOM NOTIF\");\n        }\n        [MVCInheritable]\n        public string Request1()\n        {\n            return \"empty\";\n        }\n        [MVCInheritable]\n        public string RequestWithError()\n        {\n            throw new Exception(\"BOOM REQUEST\");\n        }\n    }\n\n    [MVCJSONRPCAllowGET]\n    public class TestJsonRpcHookClassWithGet : TestJsonRpcHookClass\n    {\n    }\n}"}
{"input": "unit BOCustomersU;\n\ninterface\n\nuses MVCFramework.Serializer.Commons, System.Generics.Collections;\n\ntype\n\n  {$M+}\n\n  [MVCNameCase(ncLowerCase)]\n  TCustomer = class\n  private\n    FSurname: string;\n    FMiddleName: string;\n    FFirstName: string;\n    procedure SetFirstName(const Value: string);\n    procedure SetMiddleName(const Value: string);\n    procedure SetSurname(const Value: string);\n  published\n    property FirstName: string read FFirstName write SetFirstName;\n    property MiddleName: string read FMiddleName write SetMiddleName;\n    property Surname: string read FSurname write SetSurname;\n\n  end;\n\ntype\n  TCustomers = TObjectList<TCustomer>;\n\nimplementation\n\n{ TCustomer }\n\nprocedure TCustomer.SetFirstName(const Value: string);\nbegin\n  FFirstName := Value;\nend;\n\nprocedure TCustomer.SetMiddleName(const Value: string);\nbegin\n  FMiddleName := Value;\nend;\n\nprocedure TCustomer.SetSurname(const Value: string);\nbegin\n  FSurname := Value;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\n\nnamespace BOCustersU\n{\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCNameCaseAttribute : Attribute\n    {\n        public string NameCase { get; }\n        public MVCNameCaseAttribute(string nameCase)\n        {\n            NameCase = nameCase;\n        }\n    }\n\n   \n    [MVCNameCase(\"lowercase\")]\n    public class Customer\n    {\n        private string _firstName;\n        private string _middleName;\n        private string _surname;\n\n        public string FirstName\n        {\n            get { return _firstName; }\n            set { _firstName = value; }\n        }\n\n        public string MiddleName\n        {\n            get { return _middleName; }\n            set { _middleName = value; }\n        }\n\n        public string Surname\n        {\n            get { return _surname; }\n            set { _surname = value; }\n        }\n    }\n\n        public class Customers : List<Customer>\n    {\n    }\n}"}
{"input": "unit frmLoadSwaggerJson;\n\ninterface\n\nuses\n  Winapi.Windows,\n  Winapi.Messages,\n  System.SysUtils,\n  System.Variants,\n  System.Classes,\n  Vcl.Graphics,\n  Vcl.Controls,\n  Vcl.Forms,\n  Vcl.Dialogs,\n  Vcl.StdCtrls,\n  Swag.Common.Types,\n  Swag.Doc,\n  Swag.Doc.Definition,\n  Swag.Doc.Path,\n  Swag.Doc.Path.Operation;\n\ntype\n  TfrmSimpleSwaggerDocDemo = class(TForm)\n    Memo1: TMemo;\n    btnLoadJSON: TButton;\n    lblApiDescription: TLabel;\n    procedure btnLoadJSONClick(Sender: TObject);\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nvar\n  frmSimpleSwaggerDocDemo: TfrmSimpleSwaggerDocDemo;\n\nimplementation\n\n{$R *.dfm}\n\nuses\n  Json.Common.Helpers,\n  System.IOUtils;\n\nprocedure TfrmSimpleSwaggerDocDemo.btnLoadJSONClick(Sender: TObject);\nvar\n  vSwagDoc: TSwagDoc;\nbegin\n  vSwagDoc := TSwagDoc.Create;\n  try\n    vSwagDoc.LoadFromFile('swagger.json');\n    lblApiDescription.Caption := vSwagDoc.Info.Description;\n    vSwagDoc.GenerateSwaggerJson;\n    Memo1.Lines.Clear;\n    Memo1.Lines.Add(vSwagDoc.SwaggerJson.Format);\n  finally\n    FreeAndNil(vSwagDoc);\n  end;\nend;\n\ninitialization\n  ReportMemoryLeaksOnShutdown := True;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.IO;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\nnamespace frmLoadSwaggerJson\n{\n    public class SwagInfo\n    {\n        public string Title { get; set; } = \"\";\n        public string Version { get; set; } = \"\";\n        public string TermsOfService { get; set; } = \"\";\n        public string Description { get; set; } = \"\";\n    }\n\n    public class SwagDoc\n    {\n        public SwagInfo Info { get; set; } = new SwagInfo();\n        public string Host { get; set; } = \"\";\n        public string BasePath { get; set; } = \"\";\n        public List<string> Consumes { get; set; } = new List<string>();\n        public List<string> Produces { get; set; } = new List<string>();\n        public List<string> Schemes { get; set; } = new List<string>();\n        public List<object> Definitions { get; set; } = new List<object>();\n        public List<object> Paths { get; set; } = new List<object>();\n\n        public JObject SwaggerJson { get; set; }\n\n        \n        public void LoadFromFile(string filename)\n        {\n            string content = File.ReadAllText(filename);\n            \n            SwaggerJson = JObject.Parse(content);\n            \n            if (SwaggerJson[\"info\"] is JObject infoObj)\n            {\n                Info = new SwagInfo\n                {\n                    Title = infoObj.Value<string>(\"title\") ?? \"\",\n                    Version = infoObj.Value<string>(\"version\") ?? \"\",\n                    TermsOfService = infoObj.Value<string>(\"termsOfService\") ?? \"\",\n                    Description = infoObj.Value<string>(\"description\") ?? \"\"\n                };\n            }\n        }\n\n        \n        public void GenerateSwaggerJson()\n        {\n            var doc = new JObject\n            {\n                [\"swagger\"] = \"2.0\",\n                [\"info\"] = new JObject\n                {\n                    [\"title\"] = Info.Title,\n                    [\"version\"] = Info.Version,\n                    [\"termsOfService\"] = Info.TermsOfService,\n                    [\"description\"] = Info.Description\n                },\n                [\"host\"] = Host,\n                [\"basePath\"] = BasePath,\n                [\"consumes\"] = new JArray(Consumes),\n                [\"produces\"] = new JArray(Produces),\n                [\"schemes\"] = new JArray(Schemes),\n                [\"definitions\"] = new JObject(), \n                [\"paths\"] = new JObject()        \n            };\n\n            SwaggerJson = doc;\n        }\n    }\n    public class SimpleSwaggerDocDemoForm : Form\n    {\n        private TextBox memo1;\n        private Button btnLoadJSON;\n        private Label lblApiDescription;\n\n        public SimpleSwaggerDocDemoForm()\n        {\n            InitializeComponent();\n        }\n\n        private void InitializeComponent()\n        {\n            this.memo1 = new TextBox();\n            this.btnLoadJSON = new Button();\n            this.lblApiDescription = new Label();\n            \n            this.memo1.Multiline = true;\n            this.memo1.ScrollBars = ScrollBars.Both;\n            this.memo1.Location = new Point(12, 50);\n            this.memo1.Size = new Size(760, 400);\n            this.memo1.Font = new Font(\"Consolas\", 10);\n             \n            this.btnLoadJSON.Location = new Point(12, 10);\n            this.btnLoadJSON.Size = new Size(120, 30);\n            this.btnLoadJSON.Text = \"Load JSON\";\n            this.btnLoadJSON.Click += new EventHandler(this.btnLoadJSON_Click);\n             \n            this.lblApiDescription.Location = new Point(150, 10);\n            this.lblApiDescription.Size = new Size(400, 30);\n            this.lblApiDescription.Text = \"API Description\";\n            \n            this.ClientSize = new Size(784, 461);\n            this.Controls.Add(this.memo1);\n            this.Controls.Add(this.btnLoadJSON);\n            this.Controls.Add(this.lblApiDescription);\n            this.Text = \"Swagger JSON Loader\";\n        }\n\n        private void btnLoadJSON_Click(object sender, EventArgs e)\n        {\n            try\n            {\n                SwagDoc swagDoc = new SwagDoc();\n                swagDoc.LoadFromFile(\"swagger.json\");\n                lblApiDescription.Text = swagDoc.Info.Description;\n                swagDoc.GenerateSwaggerJson();\n                memo1.Text = swagDoc.SwaggerJson.ToString(Formatting.Indented);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(\"Error loading JSON: \" + ex.Message);\n            }\n        }\n    }\n    static class Program\n    {\n        [STAThread]\n        static void Main()\n        {\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new SimpleSwaggerDocDemoForm());\n        }\n    }\n}"}
{"input": "unit ActionFiltersControllerU;\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons;\n\ntype\n\n  [MVCPath('/')]\n  TActionFiltersController = class(TMVCController)\n  protected\n    procedure MVCControllerAfterCreate; override;\n    procedure MVCControllerBeforeDestroy; override;\n\n    procedure OnBeforeAction(Context: TWebContext; const AActionNAme: string;\n      var Handled: Boolean); override;\n    procedure OnAfterAction(Context: TWebContext; const AActionNAme: string);\n      override;\n\n  public\n    [MVCHTTPMethod([httpGet])]\n    [MVCPath('/people/($id)')]\n    [MVCProduces('application/json')]\n    { This action cannot be called by a browser address bar because requires the\n      ACCEPT header to be application/json. Use Postman or RAD Studio's RESTDebugger. }\n    procedure GetPerson(id: Integer);\n\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, BusinessObjectsU, Data.DBXJSON, MVCFramework.Logger;\n\n{ TActionFiltersController }\n\nprocedure TActionFiltersController.GetPerson(id: Integer);\nvar\n  P: TPerson;\nbegin\n  {\n    Use ID to load the person from a database...\n    In this example, we're creating a fake person\n  }\n  P := TPerson.Create;\n  P.FirstName := 'Daniele';\n  P.LastName := 'Teti';\n  P.DOB := EncodeDate(1975, 5, 2);\n  P.Married := True;\n  Render(P);\nend;\n\nprocedure TActionFiltersController.MVCControllerAfterCreate;\nbegin\n  inherited;\n  // raise Exception.Create('Error Message');\n  Log.Info('MVCControllerAfterCreate', 'ACTIONFILTERS');\nend;\n\nprocedure TActionFiltersController.MVCControllerBeforeDestroy;\nbegin\n  inherited;\nend;\n\nprocedure TActionFiltersController.OnAfterAction(Context: TWebContext;\n  const AActionNAme: string);\nbegin\n  inherited;\n  Log.Info('ACTION CALLED: ' + AActionNAme +\n    ' mapped to ' + Context.Request.PathInfo +\n    ' from ' + Context.Request.ClientIP, 'ACTIONFILTERS');\nend;\n\nprocedure TActionFiltersController.OnBeforeAction(Context: TWebContext;\n  const AActionNAme: string; var Handled: Boolean);\nbegin\n  inherited;\n  if DayOfWeek(date) in [1, 7] then\n    raise Exception.Create('You cannot use this service in the WeekEnd');\n  // if handled = true (or exception raised) then actual action will not be called\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ActionFiltersControllerU\n{\n    [Route(\"/\")]\n    [ApiController]\n    public class ActionFiltersController : ControllerBase\n    {\n        private readonly ILogger<ActionFiltersController> _logger;\n\n        public ActionFiltersController(ILogger<ActionFiltersController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"MVCControllerAfterCreate\");\n        }\n\n        public override async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)\n        {\n            if (DateTime.Now.DayOfWeek == DayOfWeek.Saturday || DateTime.Now.DayOfWeek == DayOfWeek.Sunday)\n            {\n                \n                context.Result = BadRequest(\"You cannot use this service in the Weekend\");\n                return;\n            }\n\n            var resultContext = await next();\n\n            var actionName = context.ActionDescriptor.DisplayName;\n            var path = context.HttpContext.Request.Path;\n            var clientIp = context.HttpContext.Connection.RemoteIpAddress?.ToString();\n            _logger.LogInformation($\"ACTION CALLED: {actionName} mapped to {path} from {clientIp}\");\n        }\n\n\n        [HttpGet(\"people/{id}\")]\n        [Produces(\"application/json\")]\n        public IActionResult GetPerson(int id)\n        {\n            var person = new Person\n            {\n                Id = id,\n                FirstName = \"Daniele\",\n                LastName = \"Teti\",\n                DOB = new DateTime(1975, 5, 2),\n                Married = true\n            };\n\n            return Ok(person);\n        }\n\n        protected override void Dispose(bool disposing)\n        {\n            base.Dispose(disposing);\n        }\n    }\n\n    public class Person\n    {\n        public int Id { get; set; } \n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        public DateTime DOB { get; set; }\n        public bool Married { get; set; }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.ObjectPool;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Generics.Collections,\n  System.DateUtils;\n\n\nconst\n  AVG_SAMPLES_COUNT = 10;\ntype\n  EObjectPool = class(Exception)\n\n  end;\n\n  IObjectPool<T: class, constructor> = interface\n    ['{0E79863D-D6F9-4426-9D80-F4C215233582}']\n    function GetFromPool(const RaiseExceptionIfNotAvailable: Boolean = False): T;\n    procedure ReleaseToPool(const Obj: T);\n    function Size: UInt32;\n  end;\n\n\n  TCleanupThread<T: class, constructor> = class;\n  TObjectPool<T: class, constructor> = class(TInterfacedObject, IObjectPool<T>)\n  private\n    fFactory: TFunc<T>;\n    fMaxSize: Integer;\n    fPool: TStack<T>;\n    fSize: Integer;\n    fShrinkTargetSize: Integer;\n    fShrinkTriggerSize: Integer;\n    fCleanupThread: TCleanupThread<T>;\n    fLastGetFromPool: TDateTime;\n    fOnResetState: TProc<T>;\n  protected\n    procedure Lock;\n    procedure UnLock;\n    procedure ShrinkPoolTo(const TargetSize: Integer);\n  public\n    constructor Create(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil);\n    destructor Destroy; override;\n    function GetFromPool(const RaiseExceptionIfNotAvailable: Boolean = False): T;\n    procedure ReleaseToPool(const Obj: T);\n    function Size: UInt32;\n    property OnResetState: TProc<T> read fOnResetState write fOnResetState;\n  end;\n\n  TCleanupThread<T: class, constructor> = class(TThread)\n  private\n    fObjectPool: TObjectPool<T>;\n    type\n      TPoolSizeSamples = array [0..AVG_SAMPLES_COUNT-1] of Integer;\n    function GetAveragePoolSize(var SizeSamples: TPoolSizeSamples): Integer;\n  protected\n    procedure Execute; override;\n  public\n    constructor Create(ObjectPool: TObjectPool<T>);\n  end;\n\n  TPoolFactory = class\n  public\n    class function CreatePool<T: class, constructor>(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil): IObjectPool<T>;\n    class function CreateUnlimitedPool<T: class, constructor>(ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T> = nil): IObjectPool<T>;\n  end;\n\n\nvar\n  GObjectPoolSamplingIntervalMS: UInt32 = 10000;\n\nimplementation\n\n{ TObjectPool<T> }\n\nconstructor TObjectPool<T>.Create(MaxSize: Integer; ShrinkTriggerSize, ShrinkTargetSize: Integer; const Factory: TFunc<T>);\nbegin\n  inherited Create;\n  fOnResetState := nil;\n  fLastGetFromPool := 0;\n  fFactory := Factory;\n  fMaxSize := MaxSize;\n  fShrinkTargetSize := ShrinkTargetSize;\n  fShrinkTriggerSize := ShrinkTriggerSize;\n  fPool := TStack<T>.Create;\n  fCleanupThread := nil;\n  if fShrinkTriggerSize > 0 then\n  begin\n    fCleanupThread := TCleanupThread<T>.Create(Self);\n  end;\nend;\n\ndestructor TObjectPool<T>.Destroy;\nbegin\n  if Assigned(fCleanupThread) then\n  begin\n    fCleanupThread.Terminate;\n    fCleanupThread.Free;\n  end;\n  while fPool.Count > 0 do\n    fPool.Pop.Free;\n  FreeAndNil(fPool);\n  inherited;\nend;\n\nfunction TObjectPool<T>.GetFromPool(const RaiseExceptionIfNotAvailable: Boolean): T;\nbegin\n  MonitorEnter(Self);\n  try\n    fLastGetFromPool := Now();\n    if fPool.Count > 0 then\n    begin\n      Exit(fPool.Pop);\n    end;\n\n    if (fMaxSize > 0) and (fSize >= fMaxSize) then\n    begin\n      if RaiseExceptionIfNotAvailable then\n        raise EObjectPool.CreateFmt('Pool cannot provide an instance of %s', [T.ClassName]);\n      Exit(nil);\n    end;\n\n    if Assigned(fFactory) then\n    begin\n      Result := fFactory()\n    end\n    else\n    begin\n      Result := T.Create;\n    end;\n\n    Inc(fSize);\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.Lock;\nbegin\n  MonitorEnter(Self);\nend;\n\nprocedure TObjectPool<T>.ReleaseToPool(const Obj: T);\nbegin\n  if Assigned(fOnResetState) then\n  begin\n    fOnResetState(Obj);\n  end;\n  MonitorEnter(Self);\n  try\n    fPool.Push(Obj);\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.ShrinkPoolTo(const TargetSize: Integer);\nbegin\n  MonitorEnter(Self);\n  try\n    while fSize > TargetSize do\n    begin\n      fPool.Pop.Free;\n      Dec(fSize);\n    end;\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nfunction TObjectPool<T>.Size: UInt32;\nbegin\n  MonitorEnter(Self);\n  try\n    Result := fPool.Count;\n  finally\n    MonitorExit(Self);\n  end;\nend;\n\nprocedure TObjectPool<T>.UnLock;\nbegin\n  MonitorExit(Self);\nend;\n\nconstructor TCleanupThread<T>.Create(ObjectPool: TObjectPool<T>);\nbegin\n  fObjectPool := ObjectPool;\n  inherited Create(False);\nend;\n\nprocedure TCleanupThread<T>.Execute;\nvar\n  lAvgSize: TPoolSizeSamples;\n  lArrIndex: Integer;\n  lSampleTick: Integer;\nbegin\n  lSampleTick := 0;\n  while not Terminated do\n  begin\n    Inc(lSampleTick);\n    lArrIndex := lSampleTick mod AVG_SAMPLES_COUNT;\n    lAvgSize[lArrIndex] := fObjectPool.Size;\n    if (lAvgSize[lArrIndex] > 0) and (GetAveragePoolSize(lAvgSize) >= fObjectPool.fShrinkTriggerSize) then\n    begin\n      fObjectPool.Lock;\n      try\n        fObjectPool.ShrinkPoolTo(fObjectPool.fShrinkTargetSize);\n        FillChar(lAvgSize, SizeOf(lAvgSize), 0);\n      finally\n        fObjectPool.UnLock;\n      end;\n    end\n    else\n    begin\n      Sleep(GObjectPoolSamplingIntervalMS);\n      if lSampleTick = MaxInt  then\n      begin\n        lSampleTick := 0;\n      end;\n    end;\n  end;\nend;\n\nfunction TCleanupThread<T>.GetAveragePoolSize(\n  var SizeSamples: TPoolSizeSamples): Integer;\nvar\n  I: Integer;\nbegin\n  Result := 0;\n  for I := Low(TPoolSizeSamples) to High(TPoolSizeSamples) do\n  begin\n    Inc(Result, SizeSamples[I]);\n  end;\n  Result := Result div Length(SizeSamples);\nend;\n\n{ TPoolFactory }\n\nclass function TPoolFactory.CreatePool<T>(MaxSize, ShrinkTriggerSize,\n  ShrinkTargetSize: Integer; const Factory: TFunc<T>): IObjectPool<T>;\nbegin\n  Result := TObjectPool<T>.Create(MaxSize, ShrinkTriggerSize,\n    ShrinkTargetSize, Factory);\nend;\n\nclass function TPoolFactory.CreateUnlimitedPool<T>(ShrinkTriggerSize,\n  ShrinkTargetSize: Integer; const Factory: TFunc<T>): IObjectPool<T>;\nbegin\n  Result := CreatePool<T>(0, ShrinkTriggerSize,\n    ShrinkTargetSize, Factory);\nend;\n\nend.", "output": "using System;\nusing System.Globalization;\n\nnamespace MVCFramework.Nullables\n{\n   \n    public class EMVCNullable : Exception\n    {\n        public EMVCNullable(string message) : base(message) { }\n    }\n\n    \n    public struct NullableString\n    {\n        private string _value;\n        private bool _hasValue;\n\n        \n        public bool HasValue => _hasValue;\n\n        \n        public bool IsNull => !_hasValue;\n\n        \n        public string Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableString value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        \n        public void Clear() => SetNull();\n\n        \n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n\n        \n        public string ValueOrDefault() => HasValue ? _value : default;\n\n        \n        public string ValueOrElse(string elseValue) => HasValue ? _value : elseValue;\n\n        \n        public bool TryHasValue(out string value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n\n        public override bool Equals(object obj) =>\n            obj is NullableString other && Equals(other);\n\n        public bool Equals(NullableString other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableString(string value) =>\n            new NullableString { _value = value, _hasValue = true };\n\n        public static implicit operator string(NullableString ns) => ns.Value;\n\n        public static bool operator ==(NullableString left, NullableString right) =>\n            left.Equals(right);\n\n        public static bool operator !=(NullableString left, NullableString right) =>\n            !left.Equals(right);\n\n        public override string ToString() => HasValue ? _value : \"\";\n    }\n\n    \n    public struct NullableCurrency\n    {\n        private decimal _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public decimal Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableCurrency value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public decimal ValueOrDefault() => HasValue ? _value : default;\n        public decimal ValueOrElse(decimal elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out decimal value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableCurrency other && Equals(other);\n        public bool Equals(NullableCurrency other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableCurrency(decimal value) =>\n            new NullableCurrency { _value = value, _hasValue = true };\n        public static implicit operator decimal(NullableCurrency nc) => nc.Value;\n\n        public static bool operator ==(NullableCurrency left, NullableCurrency right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableCurrency left, NullableCurrency right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableBoolean\n    {\n        private bool _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public bool Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableBoolean value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public bool ValueOrDefault() => HasValue ? _value : default;\n        public bool ValueOrElse(bool elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out bool value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableBoolean other && Equals(other);\n        public bool Equals(NullableBoolean other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableBoolean(bool value) =>\n            new NullableBoolean { _value = value, _hasValue = true };\n        public static implicit operator bool(NullableBoolean nb) => nb.Value;\n\n        public static bool operator ==(NullableBoolean left, NullableBoolean right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableBoolean left, NullableBoolean right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDate\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        \n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDate value is null\");\n                return _value.Date;\n            }\n            set\n            {\n                _value = value.Date;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value.Date : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value.Date : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value.Date;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDate other && Equals(other);\n        public bool Equals(NullableTDate other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Date.Equals(other._value.Date));\n        public override int GetHashCode() => HasValue ? _value.Date.GetHashCode() : 0;\n\n        public static implicit operator NullableTDate(DateTime value) =>\n            new NullableTDate { _value = value.Date, _hasValue = true };\n        public static implicit operator DateTime(NullableTDate ntd) => ntd.Value;\n\n        public static bool operator ==(NullableTDate left, NullableTDate right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDate left, NullableTDate right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTTime\n    {\n        private TimeSpan _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public TimeSpan Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public TimeSpan ValueOrDefault() => HasValue ? _value : default;\n        public TimeSpan ValueOrElse(TimeSpan elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out TimeSpan value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTTime other && Equals(other);\n        public bool Equals(NullableTTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTTime(TimeSpan value) =>\n            new NullableTTime { _value = value, _hasValue = true };\n        public static implicit operator TimeSpan(NullableTTime ntt) => ntt.Value;\n\n        public static bool operator ==(NullableTTime left, NullableTTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTTime left, NullableTTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTDateTime\n    {\n        private DateTime _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public DateTime Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTDateTime value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public DateTime ValueOrDefault() => HasValue ? _value : default;\n        public DateTime ValueOrElse(DateTime elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out DateTime value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTDateTime other && Equals(other);\n        public bool Equals(NullableTDateTime other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTDateTime(DateTime value) =>\n            new NullableTDateTime { _value = value, _hasValue = true };\n        public static implicit operator DateTime(NullableTDateTime ntdt) => ntdt.Value;\n\n        public static bool operator ==(NullableTDateTime left, NullableTDateTime right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTDateTime left, NullableTDateTime right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableSingle\n    {\n        private float _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public float Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableSingle value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public float ValueOrDefault() => HasValue ? _value : default;\n        public float ValueOrElse(float elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out float value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableSingle other && Equals(other);\n        public bool Equals(NullableSingle other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-6);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableSingle(float value) =>\n            new NullableSingle { _value = value, _hasValue = true };\n        public static implicit operator float(NullableSingle ns) => ns.Value;\n\n        public static bool operator ==(NullableSingle left, NullableSingle right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableSingle left, NullableSingle right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableDouble\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableDouble value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableDouble other && Equals(other);\n        public bool Equals(NullableDouble other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableDouble(double value) =>\n            new NullableDouble { _value = value, _hasValue = true };\n        public static implicit operator double(NullableDouble nd) => nd.Value;\n\n        public static bool operator ==(NullableDouble left, NullableDouble right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableDouble left, NullableDouble right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableExtended\n    {\n        private double _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public double Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableExtended value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public double ValueOrDefault() => HasValue ? _value : default;\n        public double ValueOrElse(double elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out double value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableExtended other && Equals(other);\n        public bool Equals(NullableExtended other) =>\n            (IsNull && other.IsNull) ||\n            (HasValue && other.HasValue && Math.Abs(_value - other._value) < 1e-9);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableExtended(double value) =>\n            new NullableExtended { _value = value, _hasValue = true };\n        public static implicit operator double(NullableExtended ne) => ne.Value;\n\n        public static bool operator ==(NullableExtended left, NullableExtended right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableExtended left, NullableExtended right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt16\n    {\n        private short _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public short Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public short ValueOrDefault() => HasValue ? _value : default;\n        public short ValueOrElse(short elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out short value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt16 other && Equals(other);\n        public bool Equals(NullableInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt16(short value) =>\n            new NullableInt16 { _value = value, _hasValue = true };\n        public static implicit operator short(NullableInt16 ni16) => ni16.Value;\n\n        public static bool operator ==(NullableInt16 left, NullableInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt16 left, NullableInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt16\n    {\n        private ushort _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ushort Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt16 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ushort ValueOrDefault() => HasValue ? _value : default;\n        public ushort ValueOrElse(ushort elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ushort value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt16 other && Equals(other);\n        public bool Equals(NullableUInt16 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt16(ushort value) =>\n            new NullableUInt16 { _value = value, _hasValue = true };\n        public static implicit operator ushort(NullableUInt16 nu16) => nu16.Value;\n\n        public static bool operator ==(NullableUInt16 left, NullableUInt16 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt16 left, NullableUInt16 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt32\n    {\n        private int _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public int Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public int ValueOrDefault() => HasValue ? _value : default;\n        public int ValueOrElse(int elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out int value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt32 other && Equals(other);\n        public bool Equals(NullableInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt32(int value) =>\n            new NullableInt32 { _value = value, _hasValue = true };\n        public static implicit operator int(NullableInt32 ni32) => ni32.Value;\n\n        public static bool operator ==(NullableInt32 left, NullableInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt32 left, NullableInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt32\n    {\n        private uint _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public uint Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt32 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public uint ValueOrDefault() => HasValue ? _value : default;\n        public uint ValueOrElse(uint elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out uint value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt32 other && Equals(other);\n        public bool Equals(NullableUInt32 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt32(uint value) =>\n            new NullableUInt32 { _value = value, _hasValue = true };\n        public static implicit operator uint(NullableUInt32 nu32) => nu32.Value;\n\n        public static bool operator ==(NullableUInt32 left, NullableUInt32 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt32 left, NullableUInt32 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableInt64\n    {\n        private long _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public long Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public long ValueOrDefault() => HasValue ? _value : default;\n        public long ValueOrElse(long elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out long value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableInt64 other && Equals(other);\n        public bool Equals(NullableInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableInt64(long value) =>\n            new NullableInt64 { _value = value, _hasValue = true };\n        public static implicit operator long(NullableInt64 ni64) => ni64.Value;\n\n        public static bool operator ==(NullableInt64 left, NullableInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableInt64 left, NullableInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableUInt64\n    {\n        private ulong _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public ulong Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableUInt64 value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public ulong ValueOrDefault() => HasValue ? _value : default;\n        public ulong ValueOrElse(ulong elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out ulong value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableUInt64 other && Equals(other);\n        public bool Equals(NullableUInt64 other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value == other._value);\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableUInt64(ulong value) =>\n            new NullableUInt64 { _value = value, _hasValue = true };\n        public static implicit operator ulong(NullableUInt64 nu64) => nu64.Value;\n\n        public static bool operator ==(NullableUInt64 left, NullableUInt64 right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableUInt64 left, NullableUInt64 right) =>\n            !left.Equals(right);\n    }\n\n    \n    public struct NullableTGUID\n    {\n        private Guid _value;\n        private bool _hasValue;\n\n        public bool HasValue => _hasValue;\n        public bool IsNull => !_hasValue;\n\n        public Guid Value\n        {\n            get\n            {\n                if (!HasValue)\n                    throw new EMVCNullable(\"NullableTGUID value is null\");\n                return _value;\n            }\n            set\n            {\n                _value = value;\n                _hasValue = true;\n            }\n        }\n\n        public void Clear() => SetNull();\n        public void SetNull()\n        {\n            _value = default;\n            _hasValue = false;\n        }\n        public Guid ValueOrDefault() => HasValue ? _value : default;\n        public Guid ValueOrElse(Guid elseValue) => HasValue ? _value : elseValue;\n        public bool TryHasValue(out Guid value)\n        {\n            value = _value;\n            return _hasValue;\n        }\n        public override bool Equals(object obj) =>\n            obj is NullableTGUID other && Equals(other);\n        public bool Equals(NullableTGUID other) =>\n            (IsNull && other.IsNull) || (HasValue && other.HasValue && _value.Equals(other._value));\n        public override int GetHashCode() => HasValue ? _value.GetHashCode() : 0;\n\n        public static implicit operator NullableTGUID(Guid value) =>\n            new NullableTGUID { _value = value, _hasValue = true };\n        public static implicit operator Guid(NullableTGUID ntguid) => ntguid.Value;\n\n        public static bool operator ==(NullableTGUID left, NullableTGUID right) =>\n            left.Equals(right);\n        public static bool operator !=(NullableTGUID left, NullableTGUID right) =>\n            !left.Equals(right);\n    }\n\n    \n    public enum NullableType\n    {\n        InvalidNullableType,\n        NullableString,\n        NullableCurrency,\n        NullableBoolean,\n        NullableTDate,\n        NullableTTime,\n        NullableTDateTime,\n        NullableSingle,\n        NullableDouble,\n        NullableExtended,\n        NullableInt16,\n        NullableUInt16,\n        NullableInt32,\n        NullableUInt32,\n        NullableInt64,\n        NullableUInt64,\n        NullableTGUID\n    }\n\n    \n    public static class NullableHelper\n    {\n        public static NullableType GetNullableType(Type type)\n        {\n            if (type == typeof(NullableString)) return NullableType.NullableString;\n            if (type == typeof(NullableCurrency)) return NullableType.NullableCurrency;\n            if (type == typeof(NullableBoolean)) return NullableType.NullableBoolean;\n            if (type == typeof(NullableTDate)) return NullableType.NullableTDate;\n            if (type == typeof(NullableTTime)) return NullableType.NullableTTime;\n            if (type == typeof(NullableTDateTime)) return NullableType.NullableTDateTime;\n            if (type == typeof(NullableSingle)) return NullableType.NullableSingle;\n            if (type == typeof(NullableDouble)) return NullableType.NullableDouble;\n            if (type == typeof(NullableExtended)) return NullableType.NullableExtended;\n            if (type == typeof(NullableInt16)) return NullableType.NullableInt16;\n            if (type == typeof(NullableUInt16)) return NullableType.NullableUInt16;\n            if (type == typeof(NullableInt32)) return NullableType.NullableInt32;\n            if (type == typeof(NullableUInt32)) return NullableType.NullableUInt32;\n            if (type == typeof(NullableInt64)) return NullableType.NullableInt64;\n            if (type == typeof(NullableUInt64)) return NullableType.NullableUInt64;\n            if (type == typeof(NullableTGUID)) return NullableType.NullableTGUID;\n            return NullableType.InvalidNullableType;\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file:\n// Jo\ufffdo Ant\ufffdnio Duarte (https://github.com/joaoduarte19)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.RESTClient;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  System.Classes,\n  System.SysUtils,\n  System.Net.HttpClient,\n  System.Net.Mime,\n  System.Net.URLClient,\n  System.Generics.Collections,\n  System.Rtti,\n  System.TypInfo,\n  MVCFramework.Commons,\n  MVCFramework.RESTClient.Indy,\n  MVCFramework.RESTClient.Intf,\n  MVCFramework.RESTClient.Commons,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  Data.DB,\n  JsonDataObjects;\n\ntype\n  /// <summary>\n  /// Alias for the Indy-based TRESTClient. The implementation of TRESTClient has been discontinued, it remains for\n  /// compatibility only.\n  /// </summary>\n  TRESTClient = MVCFramework.RESTClient.Indy.TRESTClient deprecated\n    'Moved to the MVCFramework.RESTClient.Indy unit. It is highly recommended to migrate to the TMVCRESTClient implementation.';\n\n  IRESTResponse = MVCFramework.RESTClient.Indy.IRESTResponse deprecated\n    'Moved to the MVCFramework.RESTClient.Indy unit. It is highly recommended to migrate to the TMVCRESTClient implementation.';\n\n  IMVCRESTClient = MVCFramework.RESTClient.Intf.IMVCRESTClient;\n  IMVCRESTResponse = MVCFramework.RESTClient.Intf.IMVCRESTResponse;\n\n  TCookie = System.Net.HttpClient.TCookie;\n  TCookies = System.Net.HttpClient.TCookies;\n  TURLRequest = System.Net.URLClient.TURLRequest;\n  TCertificate = System.Net.URLClient.TCertificate;\n  TCertificateList = System.Net.URLClient.TCertificateList;\n  TNameValuePair = System.Net.URLClient.TNameValuePair;\n  TNameValueArray = System.Net.URLClient.TNameValueArray;\n  IHTTPRequest = System.Net.HttpClient.IHTTPRequest;\n  IHTTPResponse = System.Net.HttpClient.IHTTPResponse;\n\n{$IF defined(TOKYOORBETTER)}\n  THTTPSecureProtocol = System.Net.HttpClient.THTTPSecureProtocol;\n  THTTPSecureProtocols = System.Net.HttpClient.THTTPSecureProtocols;\n{$ENDIF}\n\n  TMVCRESTClient = class(TInterfacedObject, IMVCRESTClient)\n  private\n    fLock: TObject;\n    fHTTPClient: THTTPClient;\n    fBaseURL: string;\n    fResource: string;\n    fProxySettings: TProxySettings;\n    fParameters: TList<TMVCRESTParam>;\n    fRawBody: TMemoryStream;\n    fBodyFormData: TMultipartFormData;\n    fSerializer: IMVCSerializer;\n    fRttiContext: TRttiContext;\n    fNextRequestIsAsync: Boolean;\n    fAsyncCompletionHandler: TProc<IMVCRESTResponse>;\n    fAsyncCompletionHandlerWithError: TProc<Exception>;\n    fAsyncSynchronized: Boolean;\n    fNeedClientCertificate: TNeedClientCertificateProc;\n    fValidateServerCertificate: TValidateServerCertificateProc;\n    fBeforeRequestProc: TBeforeRequestProc;\n    fRequestCompletedProc: TRequestCompletedProc;\n    fResponseCompletedProc: TResponseCompletedProc;\n    fSendDataProc: TSendDataProc;\n    [Weak] fClientCertificate: TStream;\n    fClientCertPassword: string;\n    fClientCertPath: string;\n    procedure DoNeedClientCertificate(const aSender: TObject; const aRequest: TURLRequest;\n      const aCertificateList: TCertificateList; var aIndex: Integer);\n    procedure DoValidateServerCertificate(const aSender: TObject; const aRequest: TURLRequest;\n      const aCertificate: TCertificate; var aAccepted: Boolean);\n    procedure DoBeforeRequest(aRequest: IHTTPRequest);\n    procedure DoRequestCompleted(aResponse: IHTTPResponse; var aHandled: Boolean);\n    procedure DoResponseCompleted(aMVCRESTResponse: IMVCRESTResponse);\n{$IF defined(SYDNEYORBETTER)}\n    procedure DoOnSendDataEvent(const Sender: TObject; AContentLength, AWriteCount: Int64; var AAbort: Boolean);\n{$ENDIF}\n    function GetBodyFormData: TMultipartFormData;\n    function ObjectIsList(aObject: TObject): Boolean;\n    function SerializeObject(aObject: TObject): string;\n    procedure SetContentType(const aContentType: string);\n    procedure SetParameter(const aParamType: TMVCRESTParamType; const aName, aValue: string);\n    procedure ClearParameters(const aParamType: TMVCRESTParamType);\n    function InsertHTTPSchema(const aURL: string): string;\n    function GetFullURL: string;\n    function HTTPMethodName(const aHTTPMethod: TMVCHTTPMethodType): string;\n    /// <summary>\n    /// Convert path parameters of type ($xxx) to {xxx}\n    /// </summary>\n    procedure DoConvertMVCPathParamsToRESTParams(var aURL: string);\n    procedure DoApplyPathParams(var aURL: string);\n    procedure DoApplyQueryParams(var aURL: string);\n    procedure DoApplyCookies(const aURL: string);\n    procedure DoApplyHeaders;\n    procedure DoEncodeURL(var aURL: string);\n    procedure DoPrepareBodyRequest(var aBodyStream: TStream);\n\n    procedure ExecuteAsyncRequest(const aMethod: TMVCHTTPMethodType);\n    function InternalExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\n    function ExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\n  public\n    constructor Create;\n    destructor Destroy; override;\n\n    class function New: IMVCRESTClient;\n\n    { IMVCRESTClient }\n\n    function BaseURL(const aBaseURL: string): IMVCRESTClient; overload;\n    function BaseURL(const aHost: string; const aPort: Integer): IMVCRESTClient; overload;\n    function BaseURL: string; overload;\n\n    function ProxyServer(const aProxyServer: string): IMVCRESTClient; overload;\n    function ProxyServer: string; overload;\n    function ProxyPort(const aProxyPort: Integer): IMVCRESTClient; overload;\n    function ProxyPort: Integer; overload;\n    function ProxyUsername(const aProxyUsername: string): IMVCRESTClient; overload;\n    function ProxyUsername: string; overload;\n    function ProxyPassword(const aProxyPassword: string): IMVCRESTClient; overload;\n    function ProxyPassword: string; overload;\n    function ProxyScheme(const aProxyScheme: string): IMVCRESTClient; overload;\n    function ProxyScheme: string; overload;\n\n{$IF defined(TOKYOORBETTER)}\n    function SecureProtocols(const aSecureProtocols: THTTPSecureProtocols): IMVCRESTClient; overload;\n    function SecureProtocols: THTTPSecureProtocols; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Method called when a ClientCertificate is needed.\n    /// </summary>\n    function SetNeedClientCertificateProc(aNeedClientCertificateProc: TNeedClientCertificateProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Add a custom SSL certificate validation. By default all certificates are accepted.\n    /// </summary>\n    function SetValidateServerCertificateProc(aValidateCertificateProc: TValidateServerCertificateProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes before send the request\n    /// </summary>\n    function SetBeforeRequestProc(aBeforeRequestProc: TBeforeRequestProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes after send the request\n    /// </summary>\n    function SetRequestCompletedProc(aRequestCompletedProc: TRequestCompletedProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes after the response is processed.\n    /// </summary>\n    function SetResponseCompletedProc(aResponseCompletedProc: TResponseCompletedProc): IMVCRESTClient;\n\n    /// <summary>\n    /// Executes while sending data\n    /// </summary>\n    {$IF defined(SYDNEYORBETTER)}\n    function SetSendDataProc(aSendDataProc: TSendDataProc): IMVCRESTClient;\n    {$ENDIF}\n\n    ///<summary>\n    /// Set the client certificate for the request</summary>\n    /// </summary>\n    function SetClientCertificate(const aCertStream: TStream; const aPassword: string): IMVCRESTClient; overload;\n\n{$IF defined(TOKYOORBETTER)}\n    /// <summary>\n    /// Set the path containing a client certificate for the request (iOS, Linux, Windows, Android).\n    /// Note, on Android the Path is certificate fingerprint or imported name, not a file path.\n    /// Password is not used.\n    /// </summary>\n    function SetClientCertificate(const aCertPath, aPassword: string): IMVCRESTClient; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Clears all parameters (headers, body, path params and query params). This method is executed after each\n    /// request is completed.\n    /// </summary>\n    /// <remarks>\n    /// Cookies and authorization set in SetBasicAuthorization or SetBearerAuthorization is not removed\n    /// </remarks>\n    function ClearAllParams: IMVCRESTClient;\n\n{$IF defined(BERLINORBETTER)}\n    /// <summary>\n    /// Connection timeout in milliseconds to be used for the requests.\n    /// </summary>\n    function ConnectTimeout(const aConnectTimeout: Integer): IMVCRESTClient; overload;\n    function ConnectTimeout: Integer; overload;\n\n    /// <summary>\n    /// Response reading timeout in milliseconds to be used for the requests.\n    /// </summary>\n    function ReadTimeout(const aReadTimeout: Integer): IMVCRESTClient; overload;\n    function ReadTimeout: Integer; overload;\n{$ENDIF}\n\n    /// <summary>\n    /// Add basic authorization header. Authorization = Basic &lt;Username:Password&gt; (encoded in Base64)\n    /// </summary>\n    function SetBasicAuthorization(const aUsername, aPassword: string): IMVCRESTClient;\n\n    /// <summary>\n    /// Add bearer authorization header. Authorization = Bearer &lt;Token&gt;\n    /// </summary>\n    function SetBearerAuthorization(const aAccessToken: string): IMVCRESTClient;\n\n    /// <summary>\n    /// Returns the stored authorization. Includes Basic or Bearer prefix\n    /// </summary>\n    function Authorization: string;\n\n    /// <summary>\n    /// Removes the authorization header defined in <see cref=\"MVCFramework.RESTClient.Intf|IMVCRESTClient.SetBasicAuthorization(string,string)\">\n    /// SetBasicAuthorization</see> or <see cref=\"MVCFramework.RESTClient.Intf|IMVCRESTClient.SetBearerAuthorization(string)\">\n    /// SetBearerAuthorization</see>\n    /// </summary>\n    function ClearAuthorization: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a header.\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Header name\n    /// </param>\n    /// <param name=\"aValue\">\n    /// Header value\n    /// </param>\n    /// <param name=\"aDoNotEncode\">\n    /// Indicates whether the value of this header should be used as is (True), or encoded by the component (False)\n    /// </param>\n    function AddHeader(const aName, aValue: string): IMVCRESTClient; overload;\n    function HeaderValue(const aName: string): string;\n    function Headers: TNameValueArray;\n\n    /// <summary>\n    /// Clears all headers.\n    /// </summary>\n    function ClearHeaders: IMVCRESTClient;\n\n    function AllowCookies(const aAllowCookies: Boolean): IMVCRESTClient; overload;\n    function AllowCookies: Boolean; overload;\n\n    /// <summary>\n    /// Add DMVC session cookie\n    /// </summary>\n    function SessionId(const aSessionId: string): IMVCRESTClient; overload;\n    function SessionId: string; overload;\n\n    /// <summary>\n    /// Add a cookie header.\n    /// </summary>\n    function AddCookie(const aName, aValue: string): IMVCRESTClient;\n    /// <summary>\n    /// Clear all cookie headers.\n    /// </summary>\n    function ClearCookies: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a URL segment parameter. The parameters of your url path may be enclosed in braces or in\n    /// parentheses starting with a money sign. <c>/api/{param1}/($param2)</c>\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Parameter name\n    /// </param>\n    /// <param name=\"aValue\">\n    /// Parameter value\n    /// </param>\n    function AddPathParam(const aName, aValue: string): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Integer): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Int64): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TGUID): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TDateTime): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TDate): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: TTime): IMVCRESTClient; overload;\n    function AddPathParam(const aName: string; aValue: Double): IMVCRESTClient; overload;\n    function ClearPathParams: IMVCRESTClient;\n\n    /// <summary>\n    /// Add a QueryString parameter. <c>/api/person?para1=value&amp;param2=value</c>\n    /// </summary>\n    function AddQueryStringParam(const aName, aValue: string): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Integer): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Int64): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TGUID): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TDateTime): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TDate): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: TTime): IMVCRESTClient; overload;\n    function AddQueryStringParam(const aName: string; aValue: Double): IMVCRESTClient; overload;\n    function ClearQueryParams: IMVCRESTClient;\n\n    function Accept(const aAccept: string): IMVCRESTClient; overload;\n    function Accept: string; overload;\n    function AcceptCharset(const aAcceptCharset: string): IMVCRESTClient; overload;\n    function AcceptCharset: string; overload;\n    function AcceptEncoding(const aAcceptEncoding: string): IMVCRESTClient; overload;\n    function AcceptEncoding: string; overload;\n    function HandleRedirects(const aHandleRedirects: Boolean): IMVCRESTClient; overload;\n    function HandleRedirects: Boolean; overload;\n    function MaxRedirects(const aMaxRedirects: Integer): IMVCRESTClient; overload;\n    function MaxRedirects: Integer; overload;\n    function UserAgent(const aUserAgent: string): IMVCRESTClient; overload;\n    function UserAgent: string; overload;\n\n    function Resource(const aResource: string): IMVCRESTClient; overload;\n    function Resource: string; overload;\n\n    /// <summary>\n    /// Add a body to the requisition.\n    /// </summary>\n    /// <param name=\"aBody\">\n    /// Body in string format.\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// Body content type.\n    /// </param>\n    function AddBody(const aBody: string; const aContentType: string = ''): IMVCRESTClient; overload;\n    /// <summary>\n    /// Add a body to the requisition\n    /// </summary>\n    /// <param name=\"aBodyStream\">\n    /// Body in Stream format\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// Body content type\n    /// </param>\n    /// <param name=\"aOwnsStream\">\n    /// If OwnsStream is true, Stream will be destroyed by IMVCRESTClient.\n    /// </param>\n    function AddBody(aBodyStream: TStream; const aOwnsStream: Boolean = True;\n      const aContentType: string = ''): IMVCRESTClient; overload;\n    /// <summary>\n    /// Add a body to the requisition\n    /// </summary>\n    /// <param name=\"aBodyObject\">\n    /// Body in Object format. The object will be serialized to a JSON string.\n    /// </param>\n    /// <param name=\"aOwnsObject\">\n    /// If OwnsObject is true, BodyObject will be destroyed by IMVCRESTClient.\n    /// </param>\n    function AddBody(aBodyObject: TObject; const aOwnsObject: Boolean = True): IMVCRESTClient; overload;\n\n    /// <summary>\n    /// Adds a file as the request body. Several files can be added in the same request. In this case the request\n    /// will be of the multipart/form-data type\n    /// </summary>\n    /// <param name=\"aName\">\n    /// Field name\n    /// </param>\n    /// <param name=\"aFileName\">\n    /// File path\n    /// </param>\n    /// <param name=\"aContentType\">\n    /// File content type\n    /// </param>\n    function AddFile(const aName, aFileName: string; const aContentType: string = ''): IMVCRESTClient; overload;\n    function AddFile(const aFileName: string; const aContentType: string = ''): IMVCRESTClient; overload;\n{$IF defined(RIOORBETTER)}\n    function AddFile(const aName: string; aFileStreamValue: TStream; const aFileName: string = '';\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n{$IF defined(ATHENSORBETTER)}\n    function AddFile(const aName: string; aFileStreamValue: TStream; aOwnsStream: Boolean; const aFileName: string = '';\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n\n    function AddBodyFieldFormData(const aName, aValue: string): IMVCRESTClient; overload;\n{$IF defined(RIOORBETTER)}\n    function AddBodyFieldFormData(const aName: string; aStreamValue: TStream;\n      const aContentType: string = ''): IMVCRESTClient; overload;\n{$ENDIF}\n    /// <summary>\n    /// Add a field to the x-www-form-urlencoded body. You must set ContentType to application/x-www-form-urlencoded\n    /// </summary>\n    function AddBodyFieldURLEncoded(const aName, aValue: string): IMVCRESTClient;\n\n    function ClearBody: IMVCRESTClient;\n\n    /// <summary>\n    /// Executes the next request asynchronously.\n    /// </summary>\n    /// <param name=\"aCompletionHandler\">\n    /// An anonymous method that will be run after the execution completed.\n    /// </param>\n    /// <param name=\"aSynchronized\">\n    /// Specifies if aCompletioHandler will be run in the main thread's (True) or execution thread's (False) context.\n    /// </param>\n    /// <param name=\"aCompletionHandlerWithError\">\n    /// An anonymous method that will be run if an exception is raised during execution.\n    /// </param>\n    function Async(aCompletionHandler: TProc<IMVCRESTResponse>; aCompletionHandlerWithError: TProc<Exception> = nil;\n      const aSynchronized: Boolean = False): IMVCRESTClient;\n\n    /// <summary>\n    /// Execute a Get request.\n    /// </summary>\n    function Get(const aResource: string): IMVCRESTResponse; overload;\n    function Get: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Head request.\n    /// </summary>\n    function Head(const aResource: string): IMVCRESTResponse; overload;\n    function Head: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Options request.\n    /// </summary>\n    function Options(const aResource: string): IMVCRESTResponse; overload;\n    function Options: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Post request.\n    /// </summary>\n    /// <param name=\"aResource\">\n    /// Resource path\n    /// </param>\n    /// <param name=\"aBody\">\n    /// Object to be serialized. It can be a simple object or a list of objects (TObjectList &lt;T&gt;)\n    /// </param>\n    /// <param name=\"aOwnsBody\">\n    /// If OwnsBody is true, Body will be destroyed by IMVCRESTClient. <br />\n    /// </param>\n    function Post(const aResource: string; aBody: TObject; const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Post(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Post: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Patch request.\n    /// </summary>\n    function Patch(const aResource: string; aBody: TObject;\n      const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Patch(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Patch: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Put request.\n    /// </summary>\n    function Put(const aResource: string; aBody: TObject; const aOwnsBody: Boolean = True): IMVCRESTResponse; overload;\n    function Put(const aResource: string; const aBody: string = '';\n      const aContentType: string = TMVCMediaType.APPLICATION_JSON): IMVCRESTResponse; overload;\n    function Put: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Execute a Delete request.\n    /// </summary>\n    function Delete(const aResource: string): IMVCRESTResponse; overload;\n    function Delete: IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Executes any type of HTTP request\n    /// </summary>\n    function Execute(const aMethod: TMVCHTTPMethodType; const aResource: string): IMVCRESTResponse; overload;\n    function Execute(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse; overload;\n\n    /// <summary>\n    /// Serialize the current dataset record and execute a POST request.\n    /// </summary>\n    function DataSetInsert(const aResource: string; aDataSet: TDataSet; const aIgnoredFields: TMVCIgnoredList = [];\n      const aNameCase: TMVCNameCase = ncAsIs): IMVCRESTResponse;\n    /// <summary>\n    /// Serialize the current dataset record and execute a PUT request.\n    /// </summary>\n    function DataSetUpdate(const aResource, aKeyValue: string; aDataSet: TDataSet;\n      const aIgnoredFields: TMVCIgnoredList = []; const aNameCase: TMVCNameCase = ncAsIs): IMVCRESTResponse;\n    /// <summary>\n    /// Delete the current dataset record by executing a delete request.\n    /// </summary>\n    function DataSetDelete(const aResource, aKeyValue: string): IMVCRESTResponse;\n\n    /// <summary>\n    /// Access the RESTClient serializer\n    /// </summary>\n    function Serializer: IMVCSerializer; overload;\n    /// <summary>\n    /// Add a serializer to the RESTClient\n    /// </summary>\n    function Serializer(const aSerializer: IMVCSerializer): IMVCRESTClient; overload;\n\n    /// <summary>\n    /// Register a custom serializer to the RESTClient serializer.\n    /// </summary>\n    function RegisterTypeSerializer(const aTypeInfo: PTypeInfo; aInstance: IMVCTypeSerializer): IMVCRESTClient;\n  end;\n\n  /// <summary>\n  /// Provides access to the REST request response.\n  /// </summary>\n  TMVCRESTResponse = class(TInterfacedObject, IMVCRESTResponse)\n  private\n    fRESTClient: IMVCRESTClient;\n    fSuccess: Boolean;\n    fStatusCode: Integer;\n    fStatusText: string;\n    fHeaders: TStrings;\n    fCookies: TCookies;\n    fServer: string;\n    fContentType: string;\n    fContentEncoding: string;\n    fContentLength: Integer;\n    fContent: string;\n    fContentRawBytes: TBytes;\n    fContentAvailableAsString: Boolean;\n\n    procedure FillResponse(const aHTTPResponse: IHTTPResponse);\n  public\n    constructor Create(const aRESTClient: IMVCRESTClient; const aHTTPResponse: IHTTPResponse);\n    destructor Destroy; override;\n\n    { IMVCRESTResponse }\n    function Success: Boolean;\n    function StatusCode: Integer;\n    function StatusText: string;\n    function Headers: TStrings;\n    function HeaderValue(const aName: string): string;\n    function Cookies: TCookies;\n    function CookieByName(const aName: string; const RaiseExceptionIfNotFound: Boolean = False): TCookie;\n    function Server: string;\n    function ContentType: string;\n    function ContentEncoding: string;\n    function ContentLength: Integer;\n    function Content: string;\n    function ContentRawBytes: TBytes;\n    procedure SaveContentToStream(aStream: TStream);\n    procedure SaveContentToFile(const aFileName: string);\n    function ToJSONObject: TJDOJsonObject;\n    function ToJSONArray: TJDOJsonArray;\n    procedure BodyFor(const aObject: TObject; const aRootNode: string = '');\n    procedure BodyForListOf(const aObjectList: TObject; const aObjectClass: TClass; const aRootNode: string = '');\n  end;\n\nimplementation\n\nuses\n  System.NetConsts,\n  System.NetEncoding,\n  MVCFramework.Serializer.JsonDataObjects,\n  System.RegularExpressions;\n\n{$IF not defined(RIOORBETTER)}\n\ntype\n  TCookieManagerHelper = class helper for TCookieManager\n  private\n    function CookieList: TCookies;\n  end;\n{$ENDIF}\n\n{ TMVCRESTClient }\n\nfunction TMVCRESTClient.Accept: string;\nbegin\n  Result := HeaderValue(sAccept);\nend;\n\nfunction TMVCRESTClient.Accept(const aAccept: string): IMVCRESTClient;\nbegin\n  Result := AddHeader(sAccept, aAccept);\nend;\n\nfunction TMVCRESTClient.AcceptCharset: string;\nbegin\n  Result := HeaderValue(sAcceptCharset);\nend;\n\nfunction TMVCRESTClient.AcceptCharset(const aAcceptCharset: string): IMVCRESTClient;\nbegin\n  Result := AddHeader(sAcceptCharset, aAcceptCharset);\nend;\n\nfunction TMVCRESTClient.AcceptEncoding(const aAcceptEncoding: string): IMVCRESTClient;\nbegin\n  Result := AddHeader(sAcceptEncoding, aAcceptEncoding);\nend;\n\nfunction TMVCRESTClient.AcceptEncoding: string;\nbegin\n  Result := HeaderValue(sAcceptEncoding);\nend;\n\nfunction TMVCRESTClient.AddBody(const aBody: string; const aContentType: string): IMVCRESTClient;\nvar\n  lContentCharset: string;\n  lEncoding: TEncoding;\n  lBytes: TArray<Byte>;\n  lContentType: string;\nbegin\n  Result := Self;\n\n  SplitContentMediaTypeAndCharset(aContentType, lContentType, lContentCharset);\n\n  if lContentCharset.IsEmpty then\n  begin\n    lContentCharset := TMVCCharSet.UTF_8;\n  end;\n  lEncoding := TEncoding.GetEncoding(lContentCharset);\n  try\n    fRawBody.Clear;\n\n    lBytes := lEncoding.GetBytes(aBody);\n    fRawBody.WriteData(lBytes, Length(lBytes));\n    SetContentType(BuildContentType(lContentType, lContentCharset));\n  finally\n    FreeAndNil(lEncoding);\n  end;\nend;\n\nfunction TMVCRESTClient.AddBody(aBodyStream: TStream; const aOwnsStream: Boolean;\n  const aContentType: string): IMVCRESTClient;\nbegin\n  Result := Self;\n\n  if aBodyStream = nil then\n    raise EMVCRESTClientException.Create('You need a valid body!');\n\n  SetContentType(aContentType);\n\n  fRawBody.Clear;\n  fRawBody.CopyFrom(aBodyStream, 0);\n\n  if aOwnsStream then\n    FreeAndNil(aBodyStream);\nend;\n\nfunction TMVCRESTClient.AddBody(aBodyObject: TObject; const aOwnsObject: Boolean): IMVCRESTClient;\nbegin\n  if aBodyObject = nil then\n    raise EMVCRESTClientException.Create('You need a valid body!');\n\n  Result := AddBody(SerializeObject(aBodyObject), TMVCMediaType.APPLICATION_JSON);\n\n  if aOwnsObject then\n    aBodyObject.Free;\nend;\n\nfunction TMVCRESTClient.AddBodyFieldFormData(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  GetBodyFormData.AddField(aName, aValue);\n  SetContentType(TMVCMediaType.MULTIPART_FORM_DATA);\nend;\n\n{$IF defined(RIOORBETTER)}\n\nfunction TMVCRESTClient.AddBodyFieldFormData(const aName: string; aStreamValue: TStream;\n  const aContentType: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  {$IF Defined(ATHENSORBETTER)}\n  GetBodyFormData.AddStream(aName, aStreamValue, False, '', aContentType);\n  {$ELSE}\n  GetBodyFormData.AddStream(aName, aStreamValue, '', aContentType);\n  {$ENDIF}\n  SetContentType(TMVCMediaType.MULTIPART_FORM_DATA);\nend;\n{$ENDIF}\n\n\nfunction TMVCRESTClient.AddBodyFieldURLEncoded(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fParameters.Add(TMVCRESTParam.Create(TMVCRESTParamType.FormURLEncoded, aName, aValue));\n  SetContentType(TMVCMediaType.APPLICATION_FORM_URLENCODED);\nend;\n\nfunction TMVCRESTClient.AddCookie(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  SetParameter(TMVCRESTParamType.Cookie, aName, aValue);\nend;\n\nfunction TMVCRESTClient.AddFile(const aFileName, aContentType: string): IMVCRESTClient;\nbegin\n  Result := AddFile(TMVCRESTClientConsts.DEFAULT_FILE_NAME, aFileName, aContentType);\nend;\n\nfunction TMVCRESTClient.AddFile(const aName, aFileName, aContentType: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  GetBodyFormData.AddFile(aName, aFileName {$IF defined(RIOORBETTER)}, aContentType{$ENDIF});\n  SetContentType(TMVCMediaType.MULTIPART_FORM_DATA);\nend;\n\n{$IF defined(RIOORBETTER)}\nfunction TMVCRESTClient.AddFile(const aName: string; aFileStreamValue: TStream; const aFileName, aContentType: string): IMVCRESTClient;\nbegin\n  Result := Self;\n{$WARNINGS OFF}\n  GetBodyFormData.AddStream(aName, aFileStreamValue, aFileName, aContentType);\n{$WARNINGS ON}\n  SetContentType(TMVCMediaType.MULTIPART_FORM_DATA);\nend;\n{$ENDIF}\n\n{$IF defined(ATHENSORBETTER)}\nfunction TMVCRESTClient.AddFile(const aName: string; aFileStreamValue: TStream; aOwnsStream: Boolean; const aFileName, aContentType: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  GetBodyFormData.AddStream(aName, aFileStreamValue, aOwnsStream, aFileName, aContentType);\n  SetContentType(TMVCMediaType.MULTIPART_FORM_DATA);\nend;\n{$ENDIF}\n\nfunction TMVCRESTClient.AddHeader(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n\n  SetParameter(TMVCRESTParamType.Header, aName, aValue);\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: Double): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  SetParameter(TMVCRESTParamType.Path, aName, aValue);\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: TDate): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, DateToISODate(aValue));\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: TTime): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, TimeToISOTime(aValue));\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: TDateTime): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, DateTimeToISOTimeStamp(aValue));\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: Int64): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: TGUID): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddPathParam(const aName: string; aValue: Integer): IMVCRESTClient;\nbegin\n  Result := AddPathParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: Double): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: TTime): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, TimeToISOTime(aValue));\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: TDate): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, DateToISODate(aValue));\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: TDateTime): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, DateTimeToISOTimeStamp(aValue));\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: TGUID): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: Int64): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName, aValue: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  SetParameter(TMVCRESTParamType.Query, aName, aValue);\nend;\n\nfunction TMVCRESTClient.AddQueryStringParam(const aName: string; aValue: Integer): IMVCRESTClient;\nbegin\n  Result := AddQueryStringParam(aName, aValue.ToString);\nend;\n\nfunction TMVCRESTClient.AllowCookies: Boolean;\nbegin\n  Result := fHTTPClient.AllowCookies;\nend;\n\nfunction TMVCRESTClient.AllowCookies(const aAllowCookies: Boolean): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.AllowCookies := aAllowCookies;\nend;\n\nfunction TMVCRESTClient.Async(aCompletionHandler: TProc<IMVCRESTResponse>;\n  aCompletionHandlerWithError: TProc<Exception>; const aSynchronized: Boolean): IMVCRESTClient;\nbegin\n  Result := Self;\n  fNextRequestIsAsync := True;\n  fAsyncCompletionHandler := aCompletionHandler;\n  fAsyncCompletionHandlerWithError := aCompletionHandlerWithError;\n  fAsyncSynchronized := aSynchronized;\nend;\n\nfunction TMVCRESTClient.Authorization: string;\nbegin\n  Result := HeaderValue(TMVCRESTClientConsts.AUTHORIZATION_HEADER);\nend;\n\nfunction TMVCRESTClient.BaseURL(const aBaseURL: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fBaseURL := InsertHTTPSchema(aBaseURL);\nend;\n\nfunction TMVCRESTClient.BaseURL(const aHost: string; const aPort: Integer): IMVCRESTClient;\nbegin\n  Result := BaseURL(aHost + ':' + aPort.ToString);\nend;\n\nfunction TMVCRESTClient.BaseURL: string;\nbegin\n  Result := fBaseURL;\nend;\n\nfunction TMVCRESTClient.ClearAllParams: IMVCRESTClient;\nvar\n  lAuthorization: string;\nbegin\n  Result := Self;\n\n  lAuthorization := HeaderValue(TMVCRESTClientConsts.AUTHORIZATION_HEADER);\n  fParameters.Clear;\n  ClearBody;\n\n  AddHeader(sAccept, TMVCRESTClientConsts.DEFAULT_ACCEPT);\n  AddHeader(sAcceptEncoding, TMVCRESTClientConsts.DEFAULT_ACCEPT_ENCODING);\n  AddHeader(sUserAgent, TMVCRESTClientConsts.DEFAULT_USER_AGENT);\n  AddHeader(TMVCRESTClientConsts.AUTHORIZATION_HEADER, lAuthorization);\n\n  fNextRequestIsAsync := False;\n  fAsyncCompletionHandler := nil;\n  fAsyncCompletionHandlerWithError := nil;\n  fAsyncSynchronized := False;\nend;\n\nfunction TMVCRESTClient.ClearAuthorization: IMVCRESTClient;\nbegin\n  Result := Self;\n  AddHeader(TMVCRESTClientConsts.AUTHORIZATION_HEADER, '');\nend;\n\nfunction TMVCRESTClient.ClearBody: IMVCRESTClient;\nbegin\n  fRawBody.Clear;\n  if Assigned(fBodyFormData) then\n    FreeAndNil(fBodyFormData);\n\n  Result := Self;\n  ClearParameters(TMVCRESTParamType.FormURLEncoded);\n  AddHeader(sContentType, '');\nend;\n\nfunction TMVCRESTClient.ClearCookies: IMVCRESTClient;\nbegin\n  Result := Self;\n  ClearParameters(TMVCRESTParamType.Cookie);\n{$IF defined(RIOORBETTER)}\n  fHTTPClient.CookieManager.Clear;\n{$ELSE}\n  if fHTTPClient.CookieManager.CookieList <> nil then\n    fHTTPClient.CookieManager.CookieList.Clear;\n{$ENDIF}\nend;\n\nfunction TMVCRESTClient.ClearHeaders: IMVCRESTClient;\nbegin\n  Result := Self;\n  ClearParameters(TMVCRESTParamType.Header);\nend;\n\nprocedure TMVCRESTClient.ClearParameters(const aParamType: TMVCRESTParamType);\nvar\n  I: Integer;\nbegin\n  for I := Pred(fParameters.Count) downto 0 do\n  begin\n    if fParameters[I].&Type = aParamType then\n      fParameters.Delete(I);\n  end;\nend;\n\nfunction TMVCRESTClient.ClearPathParams: IMVCRESTClient;\nbegin\n  Result := Self;\n  ClearParameters(TMVCRESTParamType.Path);\nend;\n\nfunction TMVCRESTClient.ClearQueryParams: IMVCRESTClient;\nbegin\n  Result := Self;\n  ClearParameters(TMVCRESTParamType.Query);\nend;\n\n{$IF defined(BERLINORBETTER)}\nfunction TMVCRESTClient.ConnectTimeout: Integer;\nbegin\n  Result := fHTTPClient.ConnectionTimeout;\nend;\n\nfunction TMVCRESTClient.ConnectTimeout(const aConnectTimeout: Integer): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.ConnectionTimeout := aConnectTimeout;\nend;\n{$ENDIF}\n\nconstructor TMVCRESTClient.Create;\nbegin\n  inherited Create;\n\n  fHTTPClient := THTTPClient.Create;\n  fHTTPClient.OnNeedClientCertificate := DoNeedClientCertificate;\n  fHTTPClient.OnValidateServerCertificate := DoValidateServerCertificate;\n  fHTTPClient.HandleRedirects := True;\n  fHTTPClient.MaxRedirects := TMVCRESTClientConsts.DEFAULT_MAX_REDIRECTS;\n{$IF defined(SYDNEYORBETTER)}\n  fHTTPClient.OnSendData := DoOnSendDataEvent;\n{$ENDIF}\n{$IF defined(TOKYOORBETTER)}\n  fHTTPClient.SecureProtocols := CHTTPDefSecureProtocols;\n{$ENDIF}\n  fNeedClientCertificate := nil;\n  fValidateServerCertificate := nil;\n  fBeforeRequestProc := nil;\n  fRequestCompletedProc := nil;\n  fResponseCompletedProc := nil;\n  fSendDataProc := nil;\n  fParameters := TList<TMVCRESTParam>.Create;\n  fRawBody := TMemoryStream.Create;\n  fBodyFormData := nil;\n  fSerializer := nil;\n  fRttiContext := TRttiContext.Create;\n  fLock := TObject.Create;\n  fBaseURL := '';\n  fResource := '';\n  fClientCertificate := nil;\n  fClientCertPassword := '';\n  fClientCertPath := '';\n\n  ClearAllParams;\nend;\n\nfunction TMVCRESTClient.DataSetDelete(const aResource, aKeyValue: string): IMVCRESTResponse;\nvar\n  lResource: string;\nbegin\n  lResource := aResource;\n  if not aKeyValue.IsEmpty then\n  begin\n    lResource := aResource + '/' + aKeyValue;\n  end;\n  Result := Delete(lResource);\nend;\n\nfunction TMVCRESTClient.DataSetInsert(const aResource: string; aDataSet: TDataSet;\n  const aIgnoredFields: TMVCIgnoredList; const aNameCase: TMVCNameCase): IMVCRESTResponse;\nbegin\n  Result := Post(aResource, Serializer.SerializeDataSetRecord(aDataSet, aIgnoredFields, aNameCase));\nend;\n\nfunction TMVCRESTClient.DataSetUpdate(const aResource, aKeyValue: string; aDataSet: TDataSet;\n  const aIgnoredFields: TMVCIgnoredList; const aNameCase: TMVCNameCase): IMVCRESTResponse;\nvar\n  lResource: string;\nbegin\n  lResource := aResource;\n  if not aKeyValue.IsEmpty then\n  begin\n    lResource := aResource + '/' + aKeyValue;\n  end;\n\n  Result := Put(lResource, Serializer.SerializeDataSetRecord(aDataSet, aIgnoredFields, aNameCase));\nend;\n\nfunction TMVCRESTClient.Delete(const aResource: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  Result := Delete;\nend;\n\nfunction TMVCRESTClient.Delete: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpDELETE);\nend;\n\ndestructor TMVCRESTClient.Destroy;\nbegin\n  FreeAndNil(fHTTPClient);\n  FreeAndNil(fParameters);\n\n  if Assigned(fBodyFormData) then\n    FreeAndNil(fBodyFormData);\n  FreeAndNil(fRawBody);\n  FreeAndNil(fLock);\n  fSerializer := nil;\n  fRttiContext.Free;\n  inherited;\nend;\n\nprocedure TMVCRESTClient.DoApplyCookies(const aURL: string);\nvar\n  lParam: TMVCRESTParam;\n  lName: string;\n  lValue: string;\nbegin\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Cookie then\n    begin\n      lName := TMVCRESTClientHelper.URIEncode(lParam.Name);\n      lValue := TMVCRESTClientHelper.URIEncode(lParam.Value);\n      fHTTPClient.CookieManager.AddServerCookie(lName + '=' + lValue, aURL);\n    end;\n  end;\nend;\n\n{$IF not defined(SYDNEYORBETTER)}\n\ntype\n  THackURLClient = class(TURLClient);\n{$ENDIF}\n\n\nprocedure TMVCRESTClient.DoApplyHeaders;\nvar\n  lParam: TMVCRESTParam;\nbegin\n{$IF defined(SYDNEYORBETTER)}\n  fHTTPClient.CustHeaders.Clear;\n{$ELSE}\n  SetLength(THackURLClient(fHTTPClient).FCustomHeaders, 0);\n{$ENDIF}\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Header then\n    begin\n      fHTTPClient.CustomHeaders[lParam.Name] := lParam.Value;\n    end;\n  end;\nend;\n\nprocedure TMVCRESTClient.DoApplyPathParams(var aURL: string);\nvar\n  lParam: TMVCRESTParam;\n  lReplace: string;\n  lEncodedParam: string;\nbegin\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Path then\n    begin\n      lReplace := '{' + lParam.Name + '}';\n      lEncodedParam := TNetEncoding.URL.Encode(lParam.Value\n{$IF defined(BERLINORBETTER)}\n        ,TMVCRESTClientConsts.PATH_UNSAFE_CHARS, [TURLEncoding.TEncodeOption.EncodePercent]\n{$ENDIF}\n        );\n      aURL := aURL.Replace(lReplace, lEncodedParam, [rfReplaceAll, rfIgnoreCase]);\n    end;\n  end;\nend;\n\nprocedure TMVCRESTClient.DoApplyQueryParams(var aURL: string);\nvar\n  lParam: TMVCRESTParam;\n  lName: string;\n  lValue: string;\n  lConcat: string;\nbegin\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Query then\n    begin\n      lName := TMVCRESTClientHelper.URIEncode(lParam.Name);\n{$IF defined(BERLINORBETTER)}\n      lValue := TNetEncoding.URL.EncodeForm(lParam.Value);\n{$ELSE}\n      lValue := TNetEncoding.URL.Encode(lParam.Value);\n{$ENDIF}\n\n      if aURL.Contains('?') then\n        lConcat := '&'\n      else\n        lConcat := '?';\n\n      aURL := aURL + lConcat + lName + '=' + lValue;\n    end;\n  end;\nend;\n\nprocedure TMVCRESTClient.DoBeforeRequest(aRequest: IHTTPRequest);\nbegin\n  if Assigned(fBeforeRequestProc) then\n    fBeforeRequestProc(aRequest);\nend;\n\nprocedure TMVCRESTClient.DoConvertMVCPathParamsToRESTParams(var aURL: string);\nbegin\n  aURL := TRegEx.Replace(aURL, '(\\([($])([\\w_]+)([)])', '{\\2}', [TRegExOption.roIgnoreCase]);\nend;\n\nprocedure TMVCRESTClient.DoEncodeURL(var aURL: string);\nbegin\n  // It is necessary to encode the dots because the HTTPClient removes dotted URL segments.\n  // See https://tools.ietf.org/html/rfc3986#section-5.2.4\n  aURL := aURL.Replace('\\', '/', [rfReplaceAll]);\n  aURL := aURL.Replace('../', '%2E%2E/', [rfReplaceAll]);\n  aURL := aURL.Replace('./', '%2E/', [rfReplaceAll]);\n\n{$IF defined(RIOORBETTER)}\n  aURL := TURI.Create(aURL).Encode;\n{$ELSE}\n  aURL := TURI.Create(aURL).ToString;\n{$ENDIF}\nend;\n\nprocedure TMVCRESTClient.DoNeedClientCertificate(const aSender: TObject; const aRequest: TURLRequest; const aCertificateList: TCertificateList; var aIndex: Integer);\nbegin\n  if Assigned(fNeedClientCertificate) then\n    fNeedClientCertificate(aSender, aRequest, aCertificateList, aIndex);\nend;\n\nprocedure TMVCRESTClient.DoPrepareBodyRequest(var aBodyStream: TStream);\nvar\n  lCurrentContentType: string;\n  lContentType: string;\n  lContentCharset: string;\n  lParam: TMVCRESTParam;\n  lName: string;\n  lValue: string;\n  lBody: string;\nbegin\n  lCurrentContentType := HeaderValue(sContentType);\n  SplitContentMediaTypeAndCharset(lCurrentContentType, lContentType, lContentCharset);\n\n  if SameText(lContentType, TMVCMediaType.MULTIPART_FORM_DATA) then\n  begin\n    aBodyStream := GetBodyFormData.Stream;\n    SetContentType(GetBodyFormData.MimeTypeHeader);\n  end\n  else if SameText(lContentType, TMVCMediaType.APPLICATION_FORM_URLENCODED) then\n  begin\n    lBody := '';\n    for lParam in fParameters do\n    begin\n      if lParam.&Type = TMVCRESTParamType.FormURLEncoded then\n      begin\n        lName := TMVCRESTClientHelper.URIEncode(lParam.Name);\n{$IF defined(BERLINORBETTER)}\n        lValue := TNetEncoding.URL.EncodeForm(lParam.Value);\n{$ELSE}\n        lValue := TNetEncoding.URL.Encode(lParam.Value);\n{$ENDIF}\n        if not lBody.IsEmpty then\n          lBody := lBody + '&';\n        lBody := lBody + lName + '=' + lValue;\n      end;\n    end;\n    AddBody(lBody, lCurrentContentType);\n    aBodyStream := fRawBody;\n  end\n  else\n  begin\n    aBodyStream := fRawBody;\n  end;\n  aBodyStream.Position := 0;\nend;\n\nprocedure TMVCRESTClient.DoRequestCompleted(aResponse: IHTTPResponse; var aHandled: Boolean);\nbegin\n  if Assigned(fRequestCompletedProc) then\n    fRequestCompletedProc(aResponse, aHandled);\nend;\n\nprocedure TMVCRESTClient.DoResponseCompleted(aMVCRESTResponse: IMVCRESTResponse);\nbegin\n  if Assigned(fResponseCompletedProc) then\n    fResponseCompletedProc(aMVCRESTResponse);\nend;\n\nfunction TMVCRESTClient.Execute(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(aMethod);\nend;\n\nfunction TMVCRESTClient.Execute(const aMethod: TMVCHTTPMethodType; const aResource: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  Result := Execute(aMethod);\nend;\n\nprocedure TMVCRESTClient.ExecuteAsyncRequest(const aMethod: TMVCHTTPMethodType);\nvar\n  lThread: TThread;\n  lRESTClient: IMVCRESTClient;\nbegin\n  // This is necessary for the thread to be able to access the RESTClient fields\n  lRESTClient := Self;\n  lThread := TThread.CreateAnonymousThread(\n    procedure\n    var\n      lResponse: IMVCRESTResponse;\n    begin\n      try\n        lResponse := TMVCRESTClient(lRESTClient).InternalExecuteRequest(aMethod);\n        TMonitor.Enter(TObject(lResponse));\n        try\n          if Assigned(fAsyncCompletionHandler) then\n          begin\n            if fAsyncSynchronized then\n            begin\n              TThread.Synchronize(nil,\n                procedure\n                begin\n                  fAsyncCompletionHandler(lResponse);\n                end\n                );\n            end\n            else\n            begin\n              fAsyncCompletionHandler(lResponse);\n            end;\n          end;\n        finally\n          TMonitor.Exit(TObject(lResponse));\n        end;\n      except\n        on E: Exception do\n        begin\n          if Assigned(fAsyncCompletionHandlerWithError) then\n          begin\n            if fAsyncSynchronized then\n            begin\n              TThread.Synchronize(nil,\n                procedure\n                begin\n                  fAsyncCompletionHandlerWithError(E);\n                end\n                );\n            end\n            else\n            begin\n              fAsyncCompletionHandlerWithError(E);\n            end;\n          end;\n        end;\n      end;\n      ClearAllParams;\n    end\n    );\n  lThread.Start;\nend;\n\nfunction TMVCRESTClient.ExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\nbegin\n  if fNextRequestIsAsync then\n  begin\n    Result := nil;\n    ExecuteAsyncRequest(aMethod);\n  end\n  else\n  begin\n    Result := InternalExecuteRequest(aMethod);\n    ClearAllParams;\n  end;\nend;\n\nfunction TMVCRESTClient.Get: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpGET);\nend;\n\nfunction TMVCRESTClient.GetBodyFormData: TMultipartFormData;\nbegin\n  if not Assigned(fBodyFormData) then\n  begin\n    fBodyFormData := TMultipartFormData.Create;\n  end;\n  Result := fBodyFormData;\nend;\n\nfunction TMVCRESTClient.GetFullURL: string;\nvar\n  lResource: string;\nbegin\n  Result := fBaseURL;\n\n  lResource := fResource;\n  if not lResource.IsEmpty then\n  begin\n    if not (Result.IsEmpty or Result.EndsWith('/')) and\n      not CharInSet(lResource.Chars[0], ['/', '?', '#']) then\n    begin\n      Result := Result + '/';\n    end;\n\n    Result := Result + lResource;\n  end;\n\n  Result := InsertHTTPSchema(Result);\nend;\n\nfunction TMVCRESTClient.Get(const aResource: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpGET);\nend;\n\nfunction TMVCRESTClient.HandleRedirects(const aHandleRedirects: Boolean): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.HandleRedirects := aHandleRedirects;\nend;\n\nfunction TMVCRESTClient.HandleRedirects: Boolean;\nbegin\n  Result := fHTTPClient.HandleRedirects;\nend;\n\nfunction TMVCRESTClient.Head: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpHEAD);\nend;\n\nfunction TMVCRESTClient.Head(const aResource: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  Result := Head;\nend;\n\nfunction TMVCRESTClient.Headers: TNameValueArray;\nvar\n  lHeaders: TList<TNameValuePair>;\n  lParam: TMVCRESTParam;\nbegin\n  lHeaders := TList<TNameValuePair>.Create;\n  try\n    for lParam in fParameters do\n    begin\n      if lParam.&Type = TMVCRESTParamType.Header then\n      begin\n        lHeaders.Add(TNameValuePair.Create(lParam.Name, lParam.Value));\n      end;\n    end;\n    Result := lHeaders.ToArray;\n  finally\n    FreeAndNil(lHeaders);\n  end;\nend;\n\nfunction TMVCRESTClient.HeaderValue(const aName: string): string;\nvar\n  lParam: TMVCRESTParam;\nbegin\n  Result := '';\n\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Header then\n    begin\n      if SameText(lParam.Name, aName) then\n        Exit(lParam.Value);\n    end;\n  end;\nend;\n\nfunction TMVCRESTClient.HTTPMethodName(const aHTTPMethod: TMVCHTTPMethodType): string;\nbegin\n  case aHTTPMethod of\n    httpGET:\n      Result := 'GET';\n    httpPOST:\n      Result := 'POST';\n    httpPUT:\n      Result := 'PUT';\n    httpDELETE:\n      Result := 'DELETE';\n    httpHEAD:\n      Result := 'HEAD';\n    httpOPTIONS:\n      Result := 'OPTIONS';\n    httpPATCH:\n      Result := 'PATCH';\n    httpTRACE:\n      Result := 'TRACE';\n  end;\nend;\n\nfunction TMVCRESTClient.InsertHTTPSchema(const aURL: string): string;\nbegin\n  Result := aURL;\n  if not (Result.IsEmpty or Result.Contains('://')) then\n    Result := 'http://' + Result;\nend;\n\nfunction TMVCRESTClient.InternalExecuteRequest(const aMethod: TMVCHTTPMethodType): IMVCRESTResponse;\nvar\n  lURL: string;\n  lResponse: IHTTPResponse;\n  lBodyStream: TStream;\n  lURI: TURI;\n  lRequest: IHTTPRequest;\n  lHandled: Boolean;\nbegin\n  fHTTPClient.ProxySettings := fProxySettings;\n\n  lURL := GetFullURL;\n  DoConvertMVCPathParamsToRESTParams(lURL);\n  DoApplyPathParams(lURL);\n  DoApplyQueryParams(lURL);\n  DoEncodeURL(lURL);\n  DoApplyCookies(lURL);\n  lURI := TURI.Create(lURL);\n\n  lBodyStream := nil;\n  DoPrepareBodyRequest(lBodyStream);\n  DoApplyHeaders;\n\n  lRequest := fHTTPClient.GetRequest(HTTPMethodName(aMethod), lURI);\n  lRequest.SourceStream := lBodyStream;\n\n  if Assigned(fClientCertificate) then\n  begin\n    lRequest.SetClientCertificate(fClientCertificate, fClientCertPassword);\n  end\n{$IF defined(TOKYOORBETTER)}\n  else if not fClientCertPath.IsEmpty then\n  begin\n    lRequest.SetClientCertificate(fClientCertPath, fClientCertPassword);\n  end\n{$ENDIF}\n  ;\n\n  DoBeforeRequest(lRequest);\n\n  try\n    lResponse := fHTTPClient.Execute(lRequest, nil, []);\n  except\n    on E: Exception do\n    begin\n      raise EMVCRESTClientException.Create(E.Message);\n    end;\n  end;\n\n  lHandled := False;\n  DoRequestCompleted(lResponse, lHandled);\n\n  if not lHandled then\n  begin\n    Result := TMVCRESTResponse.Create(Self, lResponse);\n    DoResponseCompleted(Result);\n  end\n  else\n  begin\n    Result := nil;\n  end;\nend;\n\nfunction TMVCRESTClient.MaxRedirects(const aMaxRedirects: Integer): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.MaxRedirects := aMaxRedirects;\nend;\n\nfunction TMVCRESTClient.MaxRedirects: Integer;\nbegin\n  Result := fHTTPClient.MaxRedirects;\nend;\n\nclass function TMVCRESTClient.New: IMVCRESTClient;\nbegin\n  Result := TMVCRESTClient.Create;\nend;\n\nfunction TMVCRESTClient.ObjectIsList(aObject: TObject): Boolean;\nbegin\n  Result := fRttiContext.GetType(aObject.ClassType).GetMethod('GetEnumerator') <> nil;\nend;\n\n{$IF defined(SYDNEYORBETTER)}\nprocedure TMVCRESTClient.DoOnSendDataEvent(const Sender: TObject; AContentLength,\n  AWriteCount: Int64; var AAbort: Boolean);\nbegin\n  if Assigned(fSendDataProc) then\n  begin\n    fSendDataProc(AContentLength, AWriteCount, AAbort);\n  end;\nend;\n{$ENDIF}\n\nfunction TMVCRESTClient.Options: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpOPTIONS);\nend;\n\nfunction TMVCRESTClient.Options(const aResource: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  Result := Options;\nend;\n\nprocedure TMVCRESTClient.DoValidateServerCertificate(const aSender: TObject; const aRequest: TURLRequest;\nconst aCertificate: TCertificate; var aAccepted: Boolean);\nbegin\n  if Assigned(fValidateServerCertificate) then\n    fValidateServerCertificate(aSender, aRequest, aCertificate, aAccepted)\n  else\n    aAccepted := True;\nend;\n\nfunction TMVCRESTClient.Patch(const aResource, aBody: string; const aContentType: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  if not aBody.isEmpty then\n  begin\n    ClearBody;\n    AddBody(aBody, aContentType);\n  end;\n\n  Result := Patch;\nend;\n\nfunction TMVCRESTClient.Patch: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpPATCH);\nend;\n\nfunction TMVCRESTClient.Patch(const aResource: string; aBody: TObject; const aOwnsBody: Boolean): IMVCRESTResponse;\nbegin\n  if aBody = nil then\n    raise EMVCRESTClientException.Create('You need a valid body!');\n\n  Result := Patch(aResource, SerializeObject(aBody));\n\n  if aOwnsBody then\n    aBody.Free;\nend;\n\nfunction TMVCRESTClient.Post(const aResource, aBody, aContentType: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  if not aBody.IsEmpty then\n  begin\n    ClearBody;\n    AddBody(aBody, aContentType);\n  end;\n  Result := Post;\nend;\n\nfunction TMVCRESTClient.Post(const aResource: string; aBody: TObject; const aOwnsBody: Boolean): IMVCRESTResponse;\nbegin\n  if aBody = nil then\n    raise EMVCRESTClientException.Create('You need a valid body!');\n\n  Result := Post(aResource, SerializeObject(aBody));\n\n  if aOwnsBody then\n    aBody.Free;\nend;\n\nfunction TMVCRESTClient.Post: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpPOST);\nend;\n\nfunction TMVCRESTClient.ProxyPassword: string;\nbegin\n  Result := fProxySettings.Password;\nend;\n\nfunction TMVCRESTClient.ProxyPassword(const aProxyPassword: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fProxySettings.Password := aProxyPassword;\nend;\n\nfunction TMVCRESTClient.ProxyPort: Integer;\nbegin\n  Result := fProxySettings.Port;\nend;\n\nfunction TMVCRESTClient.ProxyPort(const aProxyPort: Integer): IMVCRESTClient;\nbegin\n  Result := Self;\n  fProxySettings.Port := aProxyPort;\nend;\n\nfunction TMVCRESTClient.ProxyServer(const aProxyServer: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fProxySettings.Host := aProxyServer;\nend;\n\nfunction TMVCRESTClient.ProxyScheme: string;\nbegin\n  Result := fProxySettings.Scheme;\nend;\n\nfunction TMVCRESTClient.ProxyScheme(const aProxyScheme: string): IMVCRESTClient;\nbegin\n  fProxySettings.Scheme := aProxyScheme;\n  Result := Self;\nend;\n\nfunction TMVCRESTClient.ProxyServer: string;\nbegin\n  Result := fProxySettings.Host;\nend;\n\nfunction TMVCRESTClient.ProxyUsername(const aProxyUsername: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fProxySettings.UserName := aProxyUsername;\nend;\n\nfunction TMVCRESTClient.ProxyUsername: string;\nbegin\n  Result := fProxySettings.UserName;\nend;\n\nfunction TMVCRESTClient.Put: IMVCRESTResponse;\nbegin\n  Result := ExecuteRequest(TMVCHTTPMethodType.httpPUT);\nend;\n\nfunction TMVCRESTClient.Put(const aResource, aBody, aContentType: string): IMVCRESTResponse;\nbegin\n  Resource(aResource);\n  if not aBody.IsEmpty then\n  begin\n    ClearBody;\n    AddBody(aBody, aContentType);\n  end;\n  Result := Put;\nend;\n\nfunction TMVCRESTClient.Put(const aResource: string; aBody: TObject; const aOwnsBody: Boolean): IMVCRESTResponse;\nbegin\n  if aBody = nil then\n    raise EMVCRESTClientException.Create('You need a valid body!');\n\n  Result := Put(aResource, SerializeObject(aBody));\n\n  if aOwnsBody then\n    aBody.Free;\nend;\n\n{$IF defined(BERLINORBETTER)}\nfunction TMVCRESTClient.ReadTimeout: Integer;\nbegin\n  Result := fHTTPClient.ResponseTimeout;\nend;\n\nfunction TMVCRESTClient.ReadTimeout(const aReadTimeout: Integer): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.ResponseTimeout := aReadTimeout;\nend;\n{$ENDIF}\n\nfunction TMVCRESTClient.RegisterTypeSerializer(const aTypeInfo: PTypeInfo;\naInstance: IMVCTypeSerializer): IMVCRESTClient;\nbegin\n  Result := Self;\n  Serializer.RegisterTypeSerializer(aTypeInfo, aInstance);\nend;\n\nfunction TMVCRESTClient.Resource(const aResource: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fResource := aResource;\nend;\n\nfunction TMVCRESTClient.Resource: string;\nbegin\n  Result := fResource;\nend;\n\n{$IF defined(TOKYOORBETTER)}\n\n\nfunction TMVCRESTClient.SecureProtocols: THTTPSecureProtocols;\nbegin\n  Result := fHTTPClient.SecureProtocols;\nend;\n\nfunction TMVCRESTClient.SecureProtocols(const aSecureProtocols: THTTPSecureProtocols): IMVCRESTClient;\nbegin\n  Result := Self;\n  fHTTPClient.SecureProtocols := aSecureProtocols;\nend;\n{$ENDIF}\n\n\nfunction TMVCRESTClient.SerializeObject(aObject: TObject): string;\nbegin\n  if ObjectIsList(aObject) then\n    Result := Serializer.SerializeCollection(aObject)\n  else\n    Result := Serializer.SerializeObject(aObject);\nend;\n\nfunction TMVCRESTClient.Serializer(const aSerializer: IMVCSerializer): IMVCRESTClient;\nbegin\n  Result := Self;\n  TMonitor.Enter(fLock);\n  try\n    fSerializer := nil;\n    fSerializer := aSerializer;\n  finally\n    TMonitor.Exit(fLock);\n  end;\nend;\n\nfunction TMVCRESTClient.Serializer: IMVCSerializer;\nbegin\n  if not Assigned(fSerializer) then\n  begin\n    TMonitor.Enter(fLock);\n    try\n      if not Assigned(fSerializer) then\n      begin\n        fSerializer := TMVCJsonDataObjectsSerializer.Create;\n      end;\n    finally\n      TMonitor.Exit(fLock);\n    end;\n  end;\n  Result := fSerializer;\nend;\n\nfunction TMVCRESTClient.SessionId: string;\nvar\n  lCookie: TCookie;\n  lParam: TMVCRESTParam;\nbegin\n  Result := '';\n\n  for lParam in fParameters do\n  begin\n    if lParam.&Type = TMVCRESTParamType.Cookie then\n    begin\n      if SameText(lParam.Name, TMVCConstants.SESSION_TOKEN_NAME) then\n      begin\n        Result := lParam.Value;\n        Break;\n      end;\n    end;\n  end;\n\n  if Result.IsEmpty then\n  begin\n    for lCookie in fHTTPClient.CookieManager.Cookies do\n    begin\n      if SameText(lCookie.Name, TMVCConstants.SESSION_TOKEN_NAME) then\n      begin\n        Result := lCookie.Value;\n        Break;\n      end;\n    end;\n    Result := lCookie.Value;\n  end;\n\n  if Result.Contains('invalid') then\n    Result := '';\nend;\n\nfunction TMVCRESTClient.SessionId(const aSessionId: string): IMVCRESTClient;\nbegin\n  Result := Self;\n\n  AddCookie(TMVCConstants.SESSION_TOKEN_NAME, aSessionId);\nend;\n\nfunction TMVCRESTClient.SetBasicAuthorization(const aUsername, aPassword: string): IMVCRESTClient;\nvar\n  lBase64: TNetEncoding;\nbegin\n  Result := Self;\n  // Do not use TNetEncoding.Base64 here, because it may break long line\n  lBase64 := TBase64Encoding.Create(0, '');\n  try\n    AddHeader(TMVCRESTClientConsts.AUTHORIZATION_HEADER,\n      TMVCRESTClientConsts.BASIC_AUTH_PREFIX + lBase64.Encode(aUsername + ':' + aPassword));\n  finally\n    FreeAndNil(lBase64);\n  end;\nend;\n\nfunction TMVCRESTClient.SetBearerAuthorization(const aAccessToken: string): IMVCRESTClient;\nbegin\n  Result := AddHeader(TMVCRESTClientConsts.AUTHORIZATION_HEADER,\n    TMVCRESTClientConsts.BEARER_AUTH_PREFIX + aAccessToken);\nend;\n\nfunction TMVCRESTClient.SetBeforeRequestProc(aBeforeRequestProc: TBeforeRequestProc): IMVCRESTClient;\nbegin\n  Result := Self;\n  fBeforeRequestProc := aBeforeRequestProc;\nend;\n\n{$IF defined(TOKYOORBETTER)}\nfunction TMVCRESTClient.SetClientCertificate(const aCertPath, aPassword: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fClientCertPath := aCertPath;\n  fClientCertPassword := aPassword;\n  fClientCertificate := nil;\nend;\n{$ENDIF}\n\nfunction TMVCRESTClient.SetClientCertificate(const aCertStream: TStream; const aPassword: string): IMVCRESTClient;\nbegin\n  Result := Self;\n  fClientCertPath := '';\n  fClientCertificate := aCertStream;\n  fClientCertPassword := aPassword;\nend;\n\nprocedure TMVCRESTClient.SetContentType(const aContentType: string);\nbegin\n  AddHeader(sContentType, aContentType);\nend;\n\nfunction TMVCRESTClient.SetNeedClientCertificateProc(aNeedClientCertificateProc: TNeedClientCertificateProc): IMVCRESTClient;\nbegin\n  Result := Self;\n  fNeedClientCertificate := aNeedClientCertificateProc;\nend;\n\nprocedure TMVCRESTClient.SetParameter(const aParamType: TMVCRESTParamType; const aName, aValue: string);\nvar\n  I: Integer;\nbegin\n  for I := Pred(fParameters.Count) downto 0 do\n  begin\n    if (fParameters[I].&Type = aParamType) and SameText(fParameters[I].Name, aName) then\n    begin\n      fParameters.Delete(I);\n      Break;\n    end;\n  end;\n  fParameters.Add(TMVCRESTParam.Create(aParamType, aName, aValue));\nend;\n\nfunction TMVCRESTClient.SetRequestCompletedProc(aRequestCompletedProc: TRequestCompletedProc): IMVCRESTClient;\nbegin\n  Result := Self;\n  fRequestCompletedProc := aRequestCompletedProc;\nend;\n\nfunction TMVCRESTClient.SetResponseCompletedProc(aResponseCompletedProc: TResponseCompletedProc): IMVCRESTClient;\nbegin\n  Result := Self;\n  fResponseCompletedProc := aResponseCompletedProc;\nend;\n\n{$IF Defined(SYDNEYORBETTER)}\nfunction TMVCRESTClient.SetSendDataProc(\n  aSendDataProc: TSendDataProc): IMVCRESTClient;\nbegin\n  fSendDataProc := aSendDataProc;\nend;\n{$ENDIF}\n\nfunction TMVCRESTClient.SetValidateServerCertificateProc(\n  aValidateCertificateProc: TValidateServerCertificateProc): IMVCRESTClient;\nbegin\n  Result := Self;\n  fValidateServerCertificate := aValidateCertificateProc;\nend;\n\nfunction TMVCRESTClient.UserAgent(const aUserAgent: string): IMVCRESTClient;\nbegin\n  Result := AddHeader(sUserAgent, aUserAgent);\nend;\n\nfunction TMVCRESTClient.UserAgent: string;\nbegin\n  Result := HeaderValue(sUserAgent);\nend;\n\n{ TMVCRESTResponse }\n\nfunction TMVCRESTResponse.ToJSONArray: TJDOJsonArray;\nbegin\n  Result := StrTOJSONArray(Content, True);\nend;\n\nfunction TMVCRESTResponse.ToJSONObject: TJDOJsonObject;\nbegin\n  Result := StrTOJSONObject(Content, True);\nend;\n\nprocedure TMVCRESTResponse.BodyFor(const aObject: TObject; const aRootNode: string);\nbegin\n  fRESTClient.Serializer.DeserializeObject(Content, aObject, TMVCSerializationType.stDefault, [], aRootNode);\nend;\n\nprocedure TMVCRESTResponse.BodyForListOf(const aObjectList: TObject; const aObjectClass: TClass; const aRootNode: string);\nbegin\n  fRESTClient.Serializer.DeserializeCollection(Content, aObjectList, aObjectClass, TMVCSerializationType.stDefault, [], aRootNode);\nend;\n\nfunction TMVCRESTResponse.Content: string;\nbegin\n  if not fContentAvailableAsString then\n  begin\n    fContent := TMVCRESTClientHelper.GetResponseContentAsString(fContentRawBytes, fContentType);\n    fContentAvailableAsString := True;\n  end;\n  Result := fContent;\nend;\n\nfunction TMVCRESTResponse.ContentEncoding: string;\nbegin\n  Result := fContentEncoding;\nend;\n\nfunction TMVCRESTResponse.ContentLength: Integer;\nbegin\n  Result := fContentLength;\nend;\n\nfunction TMVCRESTResponse.ContentType: string;\nbegin\n  Result := fContentType;\nend;\n\nfunction TMVCRESTResponse.CookieByName(const aName: string; const RaiseExceptionIfNotFound: Boolean): TCookie;\nvar\n  lCookie: TCookie;\nbegin\n  Result := Default (TCookie);\n  for lCookie in fCookies do\n  begin\n    if SameText(lCookie.Name, aName) then\n      Exit(lCookie);\n  end;\n  if RaiseExceptionIfNotFound then\n  begin\n    raise EMVCRESTClientException.CreateFmt('Cookie \"%s\" not found', [aName]);\n  end;\n\nend;\n\nfunction TMVCRESTResponse.Cookies: TCookies;\nbegin\n  Result := fCookies;\nend;\n\nconstructor TMVCRESTResponse.Create(const aRESTClient: IMVCRESTClient; const aHTTPResponse: IHTTPResponse);\nbegin\n  fHeaders := TStringList.Create;\n  SetLength(fContentRawBytes, 0);\n  fCookies := TCookies.Create;\n  fRESTClient := aRESTClient;\n  fContentAvailableAsString := False;\n  FillResponse(aHTTPResponse);\nend;\n\ndestructor TMVCRESTResponse.Destroy;\nbegin\n  SetLength(fContentRawBytes, 0);\n  FreeAndNil(fHeaders);\n  FreeAndNil(fCookies);\n  inherited Destroy;\nend;\n\nprocedure TMVCRESTResponse.FillResponse(const aHTTPResponse: IHTTPResponse);\nvar\n  lHeader: TNetHeader;\nbegin\n  fSuccess := (aHTTPResponse.StatusCode >= 200) and (aHTTPResponse.StatusCode < 300);\n  fStatusCode := aHTTPResponse.StatusCode;\n  fStatusText := aHTTPResponse.StatusText;\n\n  for lHeader in aHTTPResponse.Headers do\n  begin\n    fHeaders.Values[lHeader.Name] := lHeader.Value;\n  end;\n  fCookies.AddRange(aHTTPResponse.Cookies.ToArray);\n  fServer := aHTTPResponse.HeaderValue[TMVCRESTClientConsts.SERVER_HEADER];\n  fContentRawBytes := TMVCRESTClientHelper.GetResponseContentAsRawBytes(aHTTPResponse.ContentStream,\n    aHTTPResponse.ContentEncoding);\n  fContent := '';\n  fContentType := aHTTPResponse.HeaderValue[sContentType];\n  fContentEncoding := aHTTPResponse.ContentEncoding;\n  fContentLength := aHTTPResponse.ContentLength;\n  fContentAvailableAsString := False;\nend;\n\nfunction TMVCRESTResponse.Headers: TStrings;\nbegin\n  Result := fHeaders;\nend;\n\nfunction TMVCRESTResponse.HeaderValue(const aName: string): string;\nbegin\n  Result := fHeaders.Values[aName];\nend;\n\nfunction TMVCRESTResponse.ContentRawBytes: TBytes;\nbegin\n  Result := fContentRawBytes;\nend;\n\nprocedure TMVCRESTResponse.SaveContentToFile(const aFileName: string);\nvar\n  lStream: TFileStream;\nbegin\n  lStream := TFileStream.Create(aFileName, fmCreate or fmOpenWrite);\n  try\n    SaveContentToStream(lStream);\n  finally\n    lStream.Free;\n  end;\nend;\n\nprocedure TMVCRESTResponse.SaveContentToStream(aStream: TStream);\nbegin\n  if aStream = nil then\n    raise EMVCRESTClientException.Create('Stream not assigned');\n  aStream.Write(fContentRawBytes, Length(fContentRawBytes));\nend;\n\nfunction TMVCRESTResponse.Server: string;\nbegin\n  Result := fServer;\nend;\n\nfunction TMVCRESTResponse.StatusCode: Integer;\nbegin\n  Result := fStatusCode;\nend;\n\nfunction TMVCRESTResponse.StatusText: string;\nbegin\n  Result := fStatusText;\nend;\n\nfunction TMVCRESTResponse.Success: Boolean;\nbegin\n  Result := fSuccess;\nend;\n\n{$IF not defined(RIOORBETTER)}\n\n{ TCookieManagerHelper }\n\nfunction TCookieManagerHelper.CookieList: TCookies;\nvar\n  lRttiContext: TRttiContext;\n  lField: TRttiField;\nbegin\n  lRttiContext := TRttiContext.Create;\n  try\n    lField := lRttiContext.GetType(Self.ClassType).GetField('FCookies');\n    Result := nil;\n    if Assigned(lField) then\n      Result := lField.GetValue(Self).AsObject as TCookies;\n  finally\n    lRttiContext.Free;\n  end;\nend;\n\n{$ENDIF}\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\n\nnamespace MVCFramework.RESTClient\n{\n    \n    public interface IMVCRESTClient : IDisposable\n    {\n        string BaseURL { get; set; }\n        string Resource { get; set; }\n        IDictionary<string, string> Headers { get; }\n        IMVCRESTClient AddHeader(string name, string value);\n        IMVCRESTClient SetBasicAuthorization(string username, string password);\n        IMVCRESTClient SetBearerAuthorization(string token);\n        IMVCRESTClient ClearAuthorization();\n        \n\n        Task<IMVCRESTResponse> GetAsync(string resource = null);\n        Task<IMVCRESTResponse> PostAsync(string resource, object body);\n        Task<IMVCRESTResponse> PutAsync(string resource, object body);\n        Task<IMVCRESTResponse> DeleteAsync(string resource);\n    }\n\n    \n    public interface IMVCRESTResponse\n    {\n        bool Success { get; }\n        int StatusCode { get; }\n        string StatusText { get; }\n        string Content { get; }\n        T ToObject<T>();\n        \n    }\n\n\n    public class MVCRESTClient : IMVCRESTClient\n    {\n        private readonly HttpClient _httpClient;\n        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>();\n        public string BaseURL { get; set; }\n        public string Resource { get; set; }\n\n        public IDictionary<string, string> Headers => _headers;\n\n        public MVCRESTClient()\n        {\n            _httpClient = new HttpClient();\n        }\n\n        public IMVCRESTClient AddHeader(string name, string value)\n        {\n            if (_headers.ContainsKey(name))\n                _headers[name] = value;\n            else\n                _headers.Add(name, value);\n            return this;\n        }\n\n        public IMVCRESTClient SetBasicAuthorization(string username, string password)\n        {\n            string credentials = Convert.ToBase64String(Encoding.UTF8.GetBytes($\"{username}:{password}\"));\n            return AddHeader(\"Authorization\", \"Basic \" + credentials);\n        }\n\n        public IMVCRESTClient SetBearerAuthorization(string token)\n        {\n            return AddHeader(\"Authorization\", \"Bearer \" + token);\n        }\n\n        public IMVCRESTClient ClearAuthorization()\n        {\n            if (_headers.ContainsKey(\"Authorization\"))\n                _headers.Remove(\"Authorization\");\n            return this;\n        }\n\n        private HttpRequestMessage CreateRequest(HttpMethod method, string resource)\n        {\n            var url = new Uri(new Uri(BaseURL), resource ?? Resource);\n            var request = new HttpRequestMessage(method, url);\n            foreach (var header in _headers)\n            {\n                request.Headers.TryAddWithoutValidation(header.Key, header.Value);\n            }\n            return request;\n        }\n\n        public async Task<IMVCRESTResponse> GetAsync(string resource = null)\n        {\n            var request = CreateRequest(HttpMethod.Get, resource);\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> PostAsync(string resource, object body)\n        {\n            var request = CreateRequest(HttpMethod.Post, resource);\n            string json = JsonConvert.SerializeObject(body);\n            request.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> PutAsync(string resource, object body)\n        {\n            var request = CreateRequest(HttpMethod.Put, resource);\n            string json = JsonConvert.SerializeObject(body);\n            request.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public async Task<IMVCRESTResponse> DeleteAsync(string resource)\n        {\n            var request = CreateRequest(HttpMethod.Delete, resource);\n            var response = await _httpClient.SendAsync(request);\n            return new MVCRESTResponse(response);\n        }\n\n        public void Dispose()\n        {\n            _httpClient?.Dispose();\n        }\n    }\n\n    \n    public class MVCRESTResponse : IMVCRESTResponse\n    {\n        private readonly HttpResponseMessage _response;\n        private string _content;\n\n        public bool Success => _response.IsSuccessStatusCode;\n        public int StatusCode => (int)_response.StatusCode;\n        public string StatusText => _response.ReasonPhrase;\n\n        public string Content\n        {\n            get\n            {\n                if (_content == null)\n                {\n                    _content = _response.Content.ReadAsStringAsync().Result;\n                }\n                return _content;\n            }\n        }\n\n        public MVCRESTResponse(HttpResponseMessage response)\n        {\n            _response = response;\n        }\n\n        public T ToObject<T>()\n        {\n            return JsonConvert.DeserializeObject<T>(Content);\n        }\n    }\n}"}
{"input": "/// Framework Core Low-Level Cross-Compiler RTTI Definitions\n// - this unit is a part of the Open Source Synopse mORMot framework 2,\n// licensed under a MPL/GPL/LGPL three license - see LICENSE.md\nunit mormot.core.rtti;\n\n{\n  *****************************************************************************\n\n   Cross-Compiler RTTI Definitions shared by all framework units\n    - Low-Level Cross-Compiler RTTI Definitions\n    - Enumerations RTTI\n    - Published Class Properties and Methods RTTI\n    - IInvokable Interface RTTI\n    - Efficient Dynamic Arrays and Records Process\n    - Managed Types Finalization, Random or Copy\n    - RTTI Value Types used for JSON Parsing\n    - RTTI-based Registration for Custom JSON Parsing\n    - High Level TObjectWithID and TObjectWithCustomCreate Class Types\n    - Redirect Most Used FPC RTL Functions to Optimized x86_64 Assembly\n\n     Purpose of this unit is to avoid any direct use of TypInfo.pas RTL unit,\n    which is not exactly compatible between compilers, and lack of direct\n    RTTI access with no memory allocation. We define pointers to RTTI\n    record/object to access TypeInfo() via a set of explicit methods.\n     Here fake record/objects are just wrappers around pointers defined in\n    Delphi/FPC RTL's TypInfo.pas with the magic of inlining.\n     We redefined all RTTI definitions as TRtti* types to avoid confusion\n    with type names as published by the TypInfo unit.\n     TRttiCustom class is the main cached entry of our customizable RTTI,\n    accessible from the global Rtti.* methods.\n\n    See mormot.core.rtti.fpc.inc and mormot.core.rtti.delphi.inc for\n    compiler-specific code.\n\n  *****************************************************************************\n}\n\n\ninterface\n\n{$I mormot.defines.inc}\n\nuses\n  sysutils,\n  classes,\n  contnrs,\n  typinfo,  // use official RTL for accurate layouts (especially FPC unaligned)\n  mormot.core.base,\n  mormot.core.os,\n  mormot.core.unicode,\n  mormot.core.text; // ESynException, and text process (e.g. for enums)\n\n\n{ ************* Low-Level Cross-Compiler RTTI Definitions }\n\ntype\n  /// the kind of Exception raised by this unit\n  ERttiException = class(ESynException);\n\n  /// map TOrdType, to specify ordinal (rkInteger and rkEnumeration) storage size and sign\n  // - note: on FPC, Int64 is stored as its own TRttiKind, not as rkInteger\n  TRttiOrd = (\n    roSByte,\n    roUByte,\n    roSWord,\n    roUWord,\n    roSLong,\n    roULong\n    {$ifdef FPC_NEWRTTI} ,\n    roSQWord,\n    roUQWord\n    {$endif FPC_NEWRTTI});\n\n  /// map TFloatType, to specify floating point (ftFloat) storage size and precision\n  TRttiFloat = (\n    rfSingle,\n    rfDouble,\n    rfExtended,\n    rfComp,\n    rfCurr);\n\n{$ifdef FPC}\n\n  /// map TTypeKind, to specify available type families for FPC RTTI values\n  // - FPC types differs from Delphi, and are taken from FPC typinfo.pp unit\n  // - here below,  we defined rkLString instead of rkAString to match Delphi -\n  // see https://lists.freepascal.org/pipermail/fpc-devel/2013-June/032360.html\n  // \"Compiler uses internally some LongStrings which is not possible to use\n  // for variable declarations\" so rkLStringOld seems never used in practice\n  TRttiKind = (\n    rkUnknown,\n    rkInteger,\n    rkChar,\n    rkEnumeration,\n    rkFloat,\n    rkSet,\n    rkMethod,\n    rkSString,\n    rkLStringOld {=rkLString},\n    rkLString    {=rkAString},\n    rkWString,\n    rkVariant,\n    rkArray,\n    rkRecord,\n    rkInterface,\n    rkClass,\n    rkObject,\n    rkWChar,\n    rkBool,\n    rkInt64,\n    rkQWord,\n    rkDynArray,\n    rkInterfaceRaw,\n    rkProcVar,\n    rkUString,\n    rkUChar,\n    rkHelper,\n    rkFile,\n    rkClassRef,\n    rkPointer);\n\nconst\n  /// potentially managed types in TRttiKind enumerates\n  rkManagedTypes = [rkLStringOld,\n                    rkLString,\n                    rkWString,\n                    rkUString,\n                    rkArray,\n                    rkObject,\n                    rkRecord,\n                    rkDynArray,\n                    rkInterface,\n                    rkVariant];\n\n  /// maps record or object in TRttiKind enumerates\n  rkRecordTypes = [rkObject,\n                   rkRecord];\n\ntype\n  ///  TTypeKind enumerate as defined in Delphi 6 and up\n  // - dkUString and following appear only since Delphi 2009\n  TDelphiType = (\n    dkUnknown,\n    dkInteger,\n    dkChar,\n    dkEnumeration,\n    dkFloat,\n    dkString,\n    dkSet,\n    dkClass,\n    dkMethod,\n    dkWChar,\n    dkLString,\n    dkWString,\n    dkVariant,\n    dkArray,\n    dkRecord,\n    dkInterface,\n    dkInt64,\n    dkDynArray,\n    dkUString,\n    dkClassRef,\n    dkPointer,\n    dkProcedure,\n    dkMRecord);\n\nconst\n  /// convert our TRttiKind to Delphi's TTypeKind enumerate\n  // - used internally for cross-compiler TDynArray binary serialization\n  FPCTODELPHI: array[TRttiKind] of TDelphiType = (\n    dkUnknown,\n    dkInteger,\n    dkChar,\n    dkEnumeration,\n    dkFloat,\n    dkSet,\n    dkMethod,\n    dkString,\n    dkLString,\n    dkLString,\n    dkWString,\n    dkVariant,\n    dkArray,\n    dkRecord,\n    dkInterface,\n    dkClass,\n    dkRecord,\n    dkWChar,\n    dkEnumeration,\n    dkInt64,\n    dkInt64,\n    dkDynArray,\n    dkInterface,\n    dkProcedure,\n    dkUString,\n    dkWChar,\n    dkPointer,\n    dkPointer,\n    dkClassRef,\n    dkPointer);\n\n  /// convert Delphi's TTypeKind to our TRttiKind enumerate\n  DELPHITOFPC: array[TDelphiType] of TRttiKind = (\n    rkUnknown,     //  dkUnknown\n    rkInteger,     //  dkInteger\n    rkChar,        //  dkChar\n    rkEnumeration, //  dkEnumeration\n    rkFloat,       //  dkFloat\n    rkSString,     //  dkString\n    rkSet,         //  dkSet\n    rkClass,       //  dkClass\n    rkMethod,      //  dkMethod\n    rkWChar,       //  dkWChar\n    rkLString,     //  dkLString\n    rkWString,     //  dkWString\n    rkVariant,     //  dkVariant\n    rkArray,       //  dkArray\n    rkRecord,      //  dkRecord\n    rkInterface,   //  dkInterface\n    rkInt64,       //  dkInt64\n    rkDynArray,    //  dkDynArray\n    rkUString,     //  dkUString\n    rkClassRef,    //  dkClassRef\n    rkPointer,     //  dkPointer\n    rkProcVar,     //  dkProcedure\n    rkRecord);     //  dkMRecord\n\n{$else}\n\n  /// available type families for Delphi 6 and up, similar to typinfo.pas\n  // - redefined here to leverage FPC and Delphi compatibility as much as possible\n  TRttiKind = (\n    rkUnknown,\n    rkInteger,\n    rkChar,\n    rkEnumeration,\n    rkFloat,\n    rkSString,\n    rkSet,\n    rkClass,\n    rkMethod,\n    rkWChar,\n    rkLString,\n    rkWString,\n    rkVariant,\n    rkArray,\n    rkRecord,\n    rkInterface,\n    rkInt64,\n    rkDynArray\n    {$ifdef UNICODE},\n    rkUString,\n    rkClassRef,\n    rkPointer,\n    rkProcedure,\n    rkMRecord // managed records from newest Delphi are partially supported\n    {$endif UNICODE});\n\nconst\n  /// potentially managed types in TRttiKind enumerates\n  rkManagedTypes = [rkLString,\n                    rkWstring,\n                    {$ifdef UNICODE}\n                    rkUstring,\n                    rkMRecord,\n                    {$endif UNICODE}\n                    rkArray,\n                    rkRecord,\n                    rkDynArray,\n                    rkInterface,\n                    rkVariant\n                   ];\n  /// maps record or object in TTypeKind RTTI enumerates\n  rkRecordTypes = [rkRecord\n                   {$ifdef UNICODE},\n                   rkMRecord\n                   {$endif UNICODE}];\n\n{$endif FPC}\n\n  /// maps string/text types in TRttiKind RTTI enumerates, excluding shortstring\n  rkStringTypes =\n    [rkLString,\n     {$ifdef FPC}\n     rkLStringOld,\n     {$endif FPC}\n     {$ifdef HASVARUSTRING}\n     rkUString,\n     {$endif HASVARUSTRING}\n     rkWString\n    ];\n\n  /// maps UTF-16 string in TRttiKind RTTI enumerates\n  rkWideStringTypes =\n    [{$ifdef HASVARUSTRING}\n     rkUString,\n     {$endif HASVARUSTRING}\n     rkWString\n    ];\n\n  /// maps types with proper TRttiProp.RttiOrd field\n  // - i.e. rkOrdinalTypes excluding the 64-bit values\n  rkHasRttiOrdTypes =\n    [rkInteger,\n     rkChar,\n     rkWChar,\n     {$ifdef FPC}\n     rkBool,\n     rkUChar,\n     {$endif FPC}\n     rkEnumeration,\n     rkSet\n    ];\n\n  /// types which are considerated as non-simple values\n  rkComplexTypes = [rkClass, rkDynArray, rkInterface];\n\n  /// types which are stored as pointers so are always accessed by reference\n  rkPerReference = rkStringTypes + rkComplexTypes;\n\n  /// maps 1, 8, 16, 32 and 64-bit ordinal in TRttiKind RTTI enumerates\n  rkOrdinalTypes =\n    rkHasRttiOrdTypes + [ {$ifdef FPC} rkQWord, {$endif} rkInt64 ];\n\n  /// maps integer and floating point types in TRttiKind RTTI enumerates\n  rkNumberTypes = rkOrdinalTypes + [ rkFloat ];\n\n  /// maps enumeration types in TRttiKind RTTI\n  rkEnumerationTypes = [rkEnumeration {$ifdef FPC}, rkBool {$endif}];\n\n  /// maps values which expect TRttiProp.GetOrdProp/SetOrdProp\n  // - includes 32-bit ordinals and pointers\n  rkGetOrdPropTypes = rkHasRttiOrdTypes + rkComplexTypes;\n\n  /// maps ordinal values which expect TRttiProp.GetInt64Prop/SetInt64Prop\n  // - includes 64-bit ordinals\n  rkGetInt64PropTypes =\n     [rkInt64 {$ifdef FPC} , rkQWord {$endif} ];\n\n  /// maps value which are integer or Int64/QWord, but not ordinal char/enum/set\n  rkGetIntegerPropTypes = rkGetInt64PropTypes + [rkInteger];\n\n  /// maps records or dynamic arrays\n  rkRecordOrDynArrayTypes = rkRecordTypes + [rkDynArray];\n\n  /// maps records or static arrays\n  rkRecordOrArrayTypes = rkRecordTypes + [rkArray];\n\n  /// all recognized TRttiKind enumerates, i.e. all but rkUnknown\n  rkAllTypes = [succ(low(TRttiKind))..high(TRttiKind)];\n\n  /// quick retrieve how many bytes an ordinal consist in\n  ORDTYPE_SIZE: array[TRttiOrd] of byte = (\n    1,                                      // roSByte\n    1,                                      // roUByte\n    2,                                      // roSWord\n    2,                                      // roUWord\n    4,                                      // roSLong\n    4                                       // roULong\n    {$ifdef FPC_NEWRTTI} , 8, 8 {$endif} ); // roSQWord, roUQWord\n\n  /// quick retrieve how many bytes a floating-point consist in\n  FLOATTYPE_SIZE: array[TRttiFloat] of byte = (\n    4,                                             // rfSingle\n    8,                                             // rfDouble\n    {$ifdef TSYNEXTENDED80} 10 {$else} 8 {$endif}, // rfExtended\n    8,                                             // rfComp\n    8 );                                           // rfCurr\n\n\ntype\n  PRttiKind = ^TRttiKind;\n  TRttiKinds = set of TRttiKind;\n  PRttiOrd = ^TRttiOrd;\n  PRttiFloat = ^TRttiFloat;\n\ntype\n  /// pointer to low-level RTTI of a type definition, as returned by TypeInfo()\n  // system function\n  // - equivalency to PTypeInfo as defined in TypInfo RTL unit and old mORMot.pas\n  // - this is the main entry point of all the information exposed by this unit\n  PRttiInfo = ^TRttiInfo;\n\n  /// double-reference to RTTI type definition\n  // - Delphi and newer FPC do store all nested TTypeInfo as pointer to pointer,\n  // to ease linking of the executable\n  PPRttiInfo = ^PRttiInfo;\n\n  /// dynamic array of low-level RTTI type definitions\n  PRttiInfoDynArray = array of PRttiInfo;\n\n  /// pointer to a RTTI class property definition as stored in PRttiProps.PropList\n  // - equivalency to PPropInfo as defined in TypInfo RTL unit and old mORMot.pas\n  PRttiProp = ^TRttiProp;\n\n  /// used to store a chain of properties RTTI\n  // - could be used e.g. by TOrmPropInfo to handled flattened properties\n  PRttiPropDynArray = array of PRttiProp;\n\n  /// pointer to all RTTI class properties definitions\n  // - as returned by PRttiInfo.RttiProps() or GetRttiProps()\n  PRttiProps = ^TRttiProps;\n\n  /// a wrapper to published properties of a class, as defined by compiler RTTI\n  // - access properties for only a given class level, not inherited properties\n  // - start enumeration by getting a PRttiProps with PRttiInfo.RttiProps(), then\n  // use P := PropList to get the first PRttiProp, and iterate with P^.Next\n  // - this enumeration is very fast and doesn't require any temporary memory,\n  //  as in the TypInfo.GetPropInfos() PPropList usage\n  // - for TOrm, you should better use the Properties.Fields[] array,\n  // which is faster and contains the properties published in parent classes\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiProps = record\n  {$else}\n  TRttiProps = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// number of published properties in this object\n    function PropCount: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// point to a TPropInfo packed array\n    // - layout is as such, with variable TPropInfo storage size:\n    // ! PropList: array[1..PropCount] of TPropInfo\n    // - use TPropInfo.Next to get the next one:\n    // ! P := PropList;\n    // ! for i := 1 to PropCount do\n    // ! begin\n    // !   // ... do something with P\n    // !   P := P^.Next;\n    // ! end;\n    function PropList: PRttiProp;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// retrieve a Field property RTTI information from a Property Name\n    function FieldProp(const PropName: ShortString): PRttiProp;\n  end;\n\n  /// pointer to TClassType, as returned by PRttiInfo.RttiClass()\n  // - as returned by PRttiInfo.RttiClass() or GetRttiClass()\n  // - equivalency to PClassData/PClassType as defined in old mORMot.pas\n  PRttiClass = ^TRttiClass;\n\n  /// a wrapper to class type information, as defined by the compiler RTTI\n  // - get a PRttiClass with PRttiInfo.RttiClass() or GetRttiClass()\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiClass = record\n  {$else}\n  TRttiClass = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// the class type\n    function RttiClass: TClass;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the parent class type information\n    function ParentInfo: PRttiInfo;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the number of published properties of this class and all parents\n    // - use RttiProps if you want to properties only published in this class \n    function PropCount: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the name (without .pas extension) of the unit were the class was defined\n    // - then the PRttiProps information follows: use the method\n    // RttiProps to retrieve its address\n    function UnitName: PShortString;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the information about the published properties of this class\n    // - stored after UnitName memory\n    function RttiProps: PRttiProps;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// fast and easy find if this class inherits from a specific class type\n    // - you should rather consider using TRttiInfo.InheritsFrom directly\n    function InheritsFrom(AClass: TClass): boolean;\n  end;\n\n  /// pointer to TEnumType, as returned by PRttiInfo.EnumBaseType/SetEnumType\n  // - equivalency to PEnumType as defined in old mORMot.pas\n  PRttiEnumType = ^TRttiEnumType;\n\n  /// a wrapper to enumeration type information, as defined by the compiler RTTI\n  // and returned by PRttiInfo.EnumBaseType/SetEnumType\n  // - we use this to store the enumeration values as integer, but easily provide\n  // a text equivalent, translated if necessary, from the enumeration type\n  // definition itself\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiEnumType = record\n  {$else}\n  TRttiEnumType = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    // as used by TRttiInfo.EnumBaseType/SetBaseType\n    function EnumBaseType: PRttiEnumType;\n      {$ifdef HASINLINE}inline;{$endif}\n    function SetBaseType: PRttiEnumType;\n      {$ifdef HASINLINE}inline;{$endif}\n  public\n    /// specify ordinal storage size and sign\n    // - is prefered to MaxValue to identify the number of stored bytes\n    function RttiOrd: TRttiOrd;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// first value of enumeration type, typicaly 0\n    // - may be < 0 e.g. for boolean\n    function MinValue: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// same as ord(high(type)): not the enumeration count, but the highest index\n    function MaxValue: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// a concatenation of shortstrings, containing the enumeration names\n    // - those shortstrings are not aligned whatsoever (even if\n    // FPC_REQUIRES_PROPER_ALIGNMENT is set)\n    function NameList: PShortString;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration name\n    // - return a void '' ShortString if Value is invalid (>MaxValue)\n    function GetEnumNameOrd(Value: cardinal): PShortString;\n      {$ifdef FPC} inline; {$endif}\n    /// get the corresponding enumeration name\n    // - return the first one if Value is invalid (>MaxValue)\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetEnumName(const Value): PShortString;\n    /// get the caption text corresponding to a enumeration name\n    // - return the first one if Value is invalid (>MaxValue)\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetCaption(const Value): string;\n    /// get all caption names, ready to be display, as lines separated by #13#10\n    // - return \"string\" type, i.e. UnicodeString for Delphi 2009+\n    // - if UsedValuesBits is not nil, only the corresponding bits set are added\n    function GetCaptionStrings(UsedValuesBits: pointer = nil): string;\n    /// add caption names, ready to be display, to a TStrings class\n    // - add pointer(ord(element)) as Objects[] value\n    // - if UsedValuesBits is not nil, only the corresponding bits set are added\n    // - can be used e.g. to populate a combo box as such:\n    // ! PTypeInfo(TypeInfo(TMyEnum))^.EnumBaseType^.AddCaptionStrings(ComboBox.Items);\n    procedure AddCaptionStrings(Strings: TStrings;\n      UsedValuesBits: pointer = nil);\n    /// retrieve all element names as a dynamic array of RawUtf8\n    // - names could be optionally trimmed left from their initial lower chars\n    procedure GetEnumNameAll(var result: TRawUtf8DynArray;\n      TrimLeftLowerCase: boolean); overload;\n    /// retrieve all element names as CSV, with optional quotes\n    procedure GetEnumNameAll(out result: RawUtf8; const Prefix: RawUtf8 = '';\n      quotedValues: boolean = false; const Suffix: RawUtf8 = '';\n      trimedValues: boolean = false; unCamelCased: boolean = false); overload;\n    /// retrieve all trimed element names as CSV\n    procedure GetEnumNameTrimedAll(var result: RawUtf8; const Prefix: RawUtf8 = '';\n      quotedValues: boolean = false; const Suffix: RawUtf8 = '');\n    /// get all enumeration names as a JSON array of strings\n    function GetEnumNameAllAsJsonArray(TrimLeftLowerCase: boolean;\n      UnCamelCased: boolean = false): RawUtf8;\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if EnumName does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if Value does not start with lowercases 'a'..'z', they will be ignored:\n    // e.g. GetEnumNameValue('Warning') will find sllWarning item\n    // - return -1 if not found (don't use directly this value to avoid any GPF)\n    function GetEnumNameValue(const EnumName: ShortString): integer; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if Value does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if Value does not start with lowercases 'a'..'z', they will be ignored:\n    // e.g. GetEnumNameValue('Warning') will find sllWarning item\n    // - return -1 if not found (don't use directly this value to avoid any GPF)\n    function GetEnumNameValue(Value: PUtf8Char): integer; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the corresponding enumeration ordinal value, from its name\n    // - if Value does start with lowercases 'a'..'z', they will be searched:\n    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item\n    // - if AlsoTrimLowerCase is TRUE, and EnumName does not start with\n    // lowercases 'a'..'z', they will be ignored: e.g. GetEnumNameValue('Warning')\n    // will find sllWarning item\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameValue(Value: PUtf8Char; ValueLen: integer;\n      AlsoTrimLowerCase: boolean = true): integer; overload;\n    /// get the corresponding enumeration ordinal value, from its trimmed name\n    function GetEnumNameValueTrimmed(Value: PUtf8Char; ValueLen: integer;\n      CaseSensitive: boolean): integer;\n    /// get the corresponding enumeration name, without the first lowercase chars\n    // (otDone -> 'Done')\n    // - Value will be converted to the matching ordinal value (byte or word)\n    function GetEnumNameTrimed(const Value): RawUtf8;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the enumeration names corresponding to a set value as CSV\n    function GetSetName(const value; trimmed: boolean = false;\n      const sep: RawUtf8 = ','): RawUtf8;\n    /// get the enumeration names corresponding to a set value as JSON array\n    function GetSetNameJsonArray(Value: cardinal; SepChar: AnsiChar = ',';\n      FullSetsAsStar: boolean = false): RawUtf8; overload;\n    /// write the enumeration names corresponding to a set value as a JSON array\n    procedure GetSetNameJsonArray(W: TTextWriter; Value: cardinal;\n      SepChar: AnsiChar = ','; QuoteChar: AnsiChar = #0;\n      FullSetsAsStar: boolean = false; ForceTrim: boolean = false); overload;\n    /// get the corresponding enumeration ordinal value, from its name without\n    // its first lowercase chars ('Done' will find otDone e.g.)\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameTrimedValue(const EnumName: ShortString): integer; overload;\n    /// get the corresponding enumeration ordinal value, from its name without\n    // its first lowercase chars ('Done' will find otDone e.g.)\n    // - return -1 if not found, or if RTTI's MinValue is not 0\n    function GetEnumNameTrimedValue(Value: PUtf8Char; ValueLen: integer = 0): integer; overload;\n    /// compute how many bytes this type will use to be stored as a enumerate\n    function SizeInStorageAsEnum: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// compute how many bytes (1, 2, 4) this type will use to be stored as a set\n    // - consider using TRttiInfo.SetEnumSize if ISFPC32 conditional is defined\n    function SizeInStorageAsSet: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// store an enumeration value from its ordinal representation\n    procedure SetEnumFromOrdinal(out Value; Ordinal: PtrUInt);\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n  end;\n\n  /// RTTI of a record/object type definition (managed) field\n  // - defined here since this structure is not available in oldest\n  // Delphi's TypInfo.pas\n  // - maps TRecordElement in FPC rtti.inc or TManagedField in TypInfo\n  TRttiRecordField = record\n    /// the RTTI of this managed field\n    {$ifdef HASDIRECTTYPEINFO}\n    TypeInfo: PRttiInfo;\n    {$else}\n    TypeInfoRef: PPRttiInfo;\n    {$endif HASDIRECTTYPEINFO}\n    /// where this managed field starts in the record memory layout\n    Offset: PtrUInt;\n  end;\n  /// pointer to the RTTI of a record/object type definition (managed) field\n  PRttiRecordField = ^TRttiRecordField;\n\n  /// define the interface abilities\n  TRttiIntfFlag = (\n    ifHasGuid,\n    ifDispInterface,\n    ifDispatch\n    {$ifdef FPC} ,\n    ifHasStrGUID {$endif});\n\n  /// define the set of interface abilities\n  TRttiIntfFlags = set of TRttiIntfFlag;\n\n  /// a wrapper to interface type information, as defined by the the compiler RTTI\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiInterfaceTypeData = record\n  {$else}\n  TRttiInterfaceTypeData = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// ancestor interface type\n    function IntfParent: PRttiInfo;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// interface abilities - not inlined to avoid random trouble on FPC trunk\n    function IntfFlags: TRttiIntfFlags;\n    /// interface 128-bit Guid\n    function IntfGuid: PGuid;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// where the interface has been defined\n    function IntfUnit: PShortString;\n      {$ifdef HASINLINE}inline;{$endif}\n  end;\n\n  /// pointer to a wrapper to interface type information\n  PRttiInterfaceTypeData = ^TRttiInterfaceTypeData;\n\n  /// record RTTI as returned by TRttiInfo.RecordManagedFields\n  TRttiRecordManagedFields = record\n    /// the record size in bytes\n    Size: PtrInt;\n    /// how many managed Fields[] are defined in this record\n    Count: PtrInt;\n    /// points to the first field RTTI\n    // - use inc(Fields) to go to the next one\n    Fields: PRttiRecordField;\n  end;\n\n  /// enhanced RTTI of a record/object type definition\n  // - as returned by TRttiInfo.RecordAllFields on Delphi 2010+\n  TRttiRecordAllField = record\n    /// the field RTTI definition\n    TypeInfo: PRttiInfo;\n    /// the field offset in the record\n    Offset: PtrUInt;\n    /// the field property name\n    Name: PShortString;\n  end;\n  PRttiRecordAllField = ^TRttiRecordAllField;\n\n  /// as returned by TRttiInfo.RecordAllFields\n  TRttiRecordAllFields = array of TRttiRecordAllField;\n\n  /// quick identification of some RTTI value types\n  TRttiCacheFlag = (\n    rcfQWord,\n    rcfBoolean,\n    rcfHasRttiOrd,\n    rcfGetOrdProp,\n    rcfGetInt64Prop,\n    rcfIsRawBlob,\n    rcfIsNumber);\n\n  /// as used by TRttiCache.Flags\n  // - rcfQWord/rcfBoolean map Info^.IsQWord/IsBoolean\n  // - rcfIsRawBlob maps Info^.IsRawBlob\n  // - rcfIsNumber is set if Info^.Kind is in rkNumberTypes\n  // - set rcfHasRttiOrd/rcfGetOrdProp/rcfGetInt64Prop to access the value\n  TRttiCacheFlags = set of TRttiCacheFlag;\n\n  /// convenient wrapper about PRttiInfo content and its more precise information\n  // - is cached within TRttiCustom instances for more efficient process\n  TRttiCache = record\n    /// the associated RTTI TypeInfo()\n    Info: PRttiInfo;\n    /// the size in bytes of a value of this type - equals Info^.RttiSize\n    Size: integer;\n    /// equals Info^.Kind\n    Kind: TRttiKind;\n    /// quick identification of specific types, e.g. rkOrdinalTypes\n    Flags: TRttiCacheFlags;\n    /// for rkHasRttiOrdTypes/rcfHasRttiOrd, equals Info^.RttiOrd\n    RttiOrd: TRttiOrd;\n    /// corresponding TRttiVarData.VType\n    // - rkEnumeration,rkSet,rkDynArray,rkClass,rkInterface,rkRecord,rkArray are\n    // identified as varAny with TVarData.VAny pointing to the actual value, and\n    // will be handled as expected by TJsonWriter.AddRttiVarData\n    RttiVarDataVType: word;\n    /// corresponding TVarData.VType\n    // - in respect to RttiVarDataVType, rkEnumeration and rkSet are varInt64\n    // since we don't need the RTTI information as for TRttiVarData\n    VarDataVType: word;\n    /// type-specific information\n    case TRttiKind of\n      rkFloat: (\n        RttiFloat: TRttiFloat;\n        IsDateTime: boolean);\n      rkLString: ( // from TypeInfo() on older Delphi with no CP RTTI\n        CodePage: cardinal; // RawBlob=CP_RAWBYTESTRING not CP_RAWBLOB\n        Engine: TSynAnsiConvert);\n      rkEnumeration,\n      rkSet: (\n        EnumMin,\n        EnumMax:  cardinal;\n        EnumInfo: PRttiEnumType;\n        EnumList: PShortString);\n      rkDynArray,\n      rkArray: (\n        ItemInfo: PRttiInfo; // = nil for unmanaged types\n        ItemSize: integer;\n        ItemCount: integer;  // rkArray only\n      );\n      rkClass: (\n        SerializableInterface: pointer; // = TRttiCustom of the rkInterface\n      );\n      rkInterface: (\n        InterfaceGuid: PGuid;\n        SerializableClass: TClass; // = TInterfacedSerializable\n        SerializableInterfaceEntryOffset: integer; // resolve once\n      );\n  end;\n\n  /// map extended PRttiInfo content\n  PRttiCache = ^TRttiCache;\n\n  {$A-}\n\n  /// main entry-point wrapper to access RTTI for a given pascal type\n  // - as returned by the TypeInfo() low-level compiler function\n  // - other RTTI objects can be computed from a pointer to this structure\n  // - user types defined as an alias don't have this type information:\n  // ! type\n  // !   TNewType = TOldType;\n  // here TypeInfo(TNewType) = TypeInfo(TOldType)\n  // - user types defined as new types have this type information:\n  // ! type\n  // !   TNewType = type TOldType;\n  // here TypeInfo(TNewType) <> TypeInfo(TOldType)\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiInfo = record\n  {$else}\n  TRttiInfo = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// the value type family\n    // - not defined as an inlined function, since first field is always aligned\n    Kind: TRttiKind;\n    /// the declared name of the type ('String','Word','RawUnicode'...)\n    // - won't adjust internal/cardinal names on FPC as with Name method\n    RawName: ShortString;\n    /// the declared name of the type ('String','Word','RawUnicode'...)\n    // - will return '' if @self is nil\n    // - on FPC, will adjust 'integer'/'cardinal' from 'longint'/'longword' RTTI\n    // - on Delphi and FPC, will adjust weak RawUtf8 = UTF8String as 'RawUtf8'\n    function Name: PShortString;\n    /// efficiently finalize any (managed) type value\n    // - do nothing for unmanaged types (e.g. integer)\n    // - if you are sure that your type is managed, you may call directly\n    // $ RTTI_FINALIZE[Info^.Kind](Data, Info);\n    procedure Clear(Data: pointer);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// efficiently copy any (managed) type value\n    // - do nothing for unmanaged types (e.g. integer)\n    // - if you are sure that your type is managed, you may call directly\n    // $ RTTI_MANAGEDCOPY[Info^.Kind](Dest, Source, Info);\n    procedure Copy(Dest, Source: pointer);\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// compute extended information about this RTTI type\n    procedure ComputeCache(var Cache: TRttiCache);\n    /// for ordinal types, get the storage size and sign\n    function RttiOrd: TRttiOrd;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property is an unsigned 64-bit field (QWord/UInt64)\n    function IsQWord: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property is a boolean field\n    function IsBoolean: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property is a currency field\n    function IsCurrency: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property is a TDateTime/TDateTimeMS/TDate\n    function IsDate: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return true if this property is a BLOB (RawBlob)\n    function IsRawBlob: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkFloat: get the storage size and precision\n    // - will also properly detect our currency internal type as rfCurr\n    function RttiFloat: TRttiFloat;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkEnumeration: get the enumeration type information\n    function EnumBaseType: PRttiEnumType; overload;\n      {$ifdef FPC}inline;{$endif} { on Delphi, inline would require typinfo }\n    /// for rkEnumeration: get the enumeration values information\n    function EnumBaseType(out NameList: PShortString;\n      out Min, Max: integer): PRttiEnumType; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkSet: get the type information of its associated enumeration\n    function SetEnumType: PRttiEnumType; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkSet: get the associated enumeration values information\n    function SetEnumType(out NameList: PShortString;\n      out Min, Max: integer): PRttiEnumType; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkSet: in how many bytes this type is stored\n    // - is very efficient on latest FPC only - i.e. ifdef ISFPC32\n    function SetEnumSize: PtrInt; {$ifdef ISFPC32} inline; {$endif}\n    /// compute in how many bytes this type is stored\n    // - will use Kind (and RttiOrd/RttiFloat) to return the exact value\n    function RttiSize: PtrInt;\n    /// check if this type is a managed type, or has any managed field\n    // - will also check for the nested fields e.g. for rkRecordTypes\n    function IsManaged: boolean;\n    /// for rkRecordTypes: get the record size\n    // - returns 0 if the type is not a record/object\n    function RecordSize: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkRecordTypes: retrieve RTTI information about all managed fields\n    // of this record\n    // - non managed fields (e.g. integers, double...) are not listed here\n    // - also includes the total record size in bytes\n    // - caller should ensure the type is indeed a record/object\n    // - note: if FPC_OLDRTTI is defined, unmanaged fields are included\n    procedure RecordManagedFields(out Fields: TRttiRecordManagedFields);\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkRecordTypes: check if this record as any managed fields\n    function RecordManagedFieldsCount: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// for rkRecordTypes: retrieve enhanced RTTI information about all fields\n    // of this record, for JSON serialization without text definition\n    // - this information is currently only available since Delphi 2010\n    // - if any field has no RTTI (e.g. a static array of unmanaged type), then\n    // it will ignore this uncomplete, therefore non-useful RTTI\n    // - in practice, it may be a good habit to always define the records used\n    // within the SOA (e.g. as DTOs) calling RegisterFromText, and don't rely on\n    // this RTTI, since it will be more cross-platform, and more customizable\n    function RecordAllFields(out RecSize: PtrInt): TRttiRecordAllFields;\n    /// for rkDynArray: get the dynamic array standard RTTI of the stored item\n    // - returns nil if the item has no managed field\n    // - caller should ensure the type is indeed a dynamic array\n    function DynArrayItemType: PRttiInfo; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkDynArray: get the dynamic array deep RTTI of the stored item\n    // - works for both managed and unmanaged types, on FPC and Delphi 2010+\n    // - caller should ensure the type is indeed a dynamic array\n    function DynArrayItemTypeExtended: PRttiInfo;\n    /// for rkDynArray: get the dynamic array type information of the stored item\n    // - this overloaded method will also return the item size in bytes\n    // - caller should ensure the type is indeed a dynamic array\n    function DynArrayItemType(out aDataSize: PtrInt): PRttiInfo; overload;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkDynArray: get the dynamic array size (in bytes) of the stored item\n    function DynArrayItemSize: PtrInt;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// for rkArray: get the static array type information of the stored item\n    // - returns nil if the array type is unmanaged (i.e. behave like Delphi)\n    // - aDataSize is the size in bytes of all aDataCount static items (not\n    // the size of each item)\n    // - caller should ensure the type is indeed a static array\n    function ArrayItemType(out aDataCount, aDataSize: PtrInt): PRttiInfo;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkArray: get the size in bytes of all the static array items\n    // - caller should ensure the type is indeed a static array\n    function ArraySize: PtrInt;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// recognize most used string types, returning their code page\n    // - will return the exact code page on FPC and since Delphi 2009, from RTTI\n    // - for non Unicode versions of Delphi, will recognize WinAnsiString as\n    // CP_WINANSI, RawUnicode as CP_UTF16, RawByteString/RawBlob as\n    // CP_RAWBYTESTRING, AnsiString as CP_ACP=0, and any other type as RawUtf8\n    // - it will also recognize RawBlob as the fake CP_RAWBLOB codepage\n    function AnsiStringCodePage: integer;\n      {$ifdef HASCODEPAGE}{$ifdef HASSAFEINLINE}inline;{$endif}{$endif}\n    {$ifdef HASCODEPAGE}\n    /// returning the code page stored in the RTTI\n    // - without recognizing e.g. RawBlob\n    // - caller should ensure the type is indeed a rkLString\n    function AnsiStringCodePageStored: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    {$endif HASCODEPAGE}\n    /// retrieve rkLString, rkSString, rkUString, rkWString, rkChar, rkWChar\n    // values as RawUtf8, from a pointer to its memory storage\n    // - makes heap allocations and encoding conversion, so may be slow\n    procedure StringToUtf8(Data: pointer; var Value: RawUtf8);\n    /// for rkClass: get the class type information\n    function RttiClass: PRttiClass;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkClass: get the class type information\n    function RttiNonVoidClass: PRttiClass;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// for rkClass: return the number of published properties in this class\n    // - you can count the plain fields without any getter function, if you\n    // do need only the published properties corresponding to some value\n    // actually stored, and ignore e.g. any textual conversion\n    function ClassFieldCount(onlyWithoutGetter: boolean): integer;\n    /// for rkClass: fast and easy check if a class inherits from this RTTI\n    function InheritsFrom(AClass: TClass): boolean;\n    /// for rkInterface: get the interface type information\n    function InterfaceType: PRttiInterfaceTypeData;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// for rkInterface: get the TGuid of a given interface type information\n    // - returns nil if this type is not an interface\n    function InterfaceGuid: PGuid;\n    /// for rkInterface: get the unit name of a given interface type information\n    // - returns '' if this type is not an interface\n    function InterfaceUnitName: PShortString;\n    /// for rkInterface: get the ancestor/parent of a given interface type information\n    // - returns nil if this type has no parent\n    function InterfaceAncestor: PRttiInfo;\n    /// for rkInterface: get all ancestors/parents of a given interface type information\n    // - only ancestors with an associated TGuid will be added\n    // - if OnlyImplementedBy is not nil, only the interface explicitly\n    // implemented by this class will be added, and AncestorsImplementedEntry[]\n    // will contain the corresponding PInterfaceEntry values\n    procedure InterfaceAncestors(out Ancestors: PRttiInfoDynArray;\n      OnlyImplementedBy: TInterfacedObjectClass;\n      out AncestorsImplementedEntry: TPointerDynArray);\n    /// for rkInterface: check if this type (or ancestor) implements a TGuid\n    function InterfaceImplements(const AGuid: TGuid): boolean;\n  end;\n\n  {$A+}\n\n  /// how a RTTI property definition access its value\n  // - as returned by TPropInfo.Getter/Setter/GetterIs/SetterIs methods\n  TRttiPropCall = (\n    rpcNone,\n    rpcField,\n    rpcMethod,\n    rpcIndexed);\n\n  /// TRttiProp.IsStoredKind response - default is \"stored true\"\n  TRttiPropStored = (\n    rpsTrue,\n    rpsFalse,\n    rpsGetter);\n\n  /// a wrapper containing a RTTI class property definition\n  // - used for direct Delphi / UTF-8 SQL type mapping/conversion\n  // - doesn't depend on RTL's TypInfo unit, to enhance cross-compiler support\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiProp = record\n  {$else}\n  TRttiProp = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// raw retrieval of the property read access definition\n    // - note: 'var Call' generated incorrect code on Delphi XE4 -> use PMethod\n    function Getter(Instance: TObject; Call: PMethod): TRttiPropCall;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// raw retrieval of the property access definition\n    function Setter(Instance: TObject; Call: PMethod): TRttiPropCall;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// raw retrieval of rkInteger,rkEnumeration,rkSet,rkChar,rkWChar,rkBool\n    // - rather call GetOrdValue/GetInt64Value\n    // - returns an Int64 to properly support cardinal values\n    function GetOrdProp(Instance: TObject): Int64;\n    /// raw assignment of rkInteger,rkEnumeration,rkSet,rkChar,rkWChar,rkBool\n    // - rather call SetOrdValue/SetInt64Value\n    procedure SetOrdProp(Instance: TObject; Value: PtrInt);\n    /// raw retrieval of rkClass\n    function GetObjProp(Instance: TObject): TObject;\n    /// raw retrieval of rkDynArray getter as a pointer\n    // - caller should then release the instance using e.g. FastDynArrayClear()\n    // - do nothing if the property is a field with no getter\n    function GetDynArrayPropGetter(Instance: TObject): pointer;\n    /// raw retrieval of rkInt64, rkQWord\n    // - rather call GetInt64Value\n    function GetInt64Prop(Instance: TObject): Int64;\n    /// raw assignment of rkInt64, rkQWord\n    // - rather call SetInt64Value\n    procedure SetInt64Prop(Instance: TObject; const Value: Int64);\n    /// raw retrieval of rkLString\n    procedure GetLongStrProp(Instance: TObject; var Value: RawByteString);\n    /// raw assignment of rkLString\n    procedure SetLongStrProp(Instance: TObject; const Value: RawByteString);\n    /// raw copy of rkLString\n    procedure CopyLongStrProp(Source, Dest: TObject);\n    /// raw retrieval of rkString into an Ansi7String\n    procedure GetShortStrProp(Instance: TObject; var Value: RawUtf8);\n    /// raw retrieval of rkWString\n    procedure GetWideStrProp(Instance: TObject; var Value: WideString);\n    /// raw assignment of rkWString\n    procedure SetWideStrProp(Instance: TObject; const Value: WideString);\n    {$ifdef HASVARUSTRING}\n    /// raw retrieval of rkUString\n    procedure GetUnicodeStrProp(Instance: TObject; var Value: UnicodeString);\n    /// raw assignment of rkUString\n    procedure SetUnicodeStrProp(Instance: TObject; const Value: UnicodeString);\n    {$endif HASVARUSTRING}\n    /// raw retrieval of rkFloat/currency\n    // - use instead GetCurrencyValue\n    procedure GetCurrencyProp(Instance: TObject; var Value: currency);\n    /// raw assignment of rkFloat/currency\n    procedure SetCurrencyProp(Instance: TObject; const Value: currency);\n    /// raw retrieval of rkFloat/double\n    function GetDoubleProp(Instance: TObject): double;\n    /// raw assignment of rkFloat/double\n    procedure SetDoubleProp(Instance: TObject; Value: Double);\n    /// raw retrieval of rkFloat - with conversion to 64-bit double\n    // - use instead GetDoubleProp if you know the property is a rkFloat/double\n    function GetFloatProp(Instance: TObject): double;\n    /// raw assignment of rkFloat\n    // - use instead SetDoubleProp if you know the property is a rkFloat/double\n    procedure SetFloatProp(Instance: TObject; Value: TSynExtended);\n    /// raw retrieval of rkVariant\n    // - will use varByRef from the field address if SetByRef is true\n    procedure GetVariantProp(Instance: TObject; var Result: Variant; SetByRef: boolean);\n    /// raw assignment of rkVariant\n    procedure SetVariantProp(Instance: TObject; const Value: Variant);\n  public\n    /// contains the index value of an indexed class data property\n    // - outside SQLite3, this can be used to define a VARCHAR() length value\n    // for the textual field definition (sftUtf8Text/sftAnsiText); e.g.\n    // the following will create a NAME VARCHAR(40) field:\n    // ! Name: RawUtf8 index 40 read fName write fName;\n    // - is used by a dynamic array property for fast usage of the\n    // TOrm.DynArray(DynArrayFieldIndex) method\n    function Index: integer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// contains the default value for an ordinal or set property\n    // - NO_DEFAULT=$80000000 indicates none was defined in source code\n    // - see also TPropInfo.DefaultOr0\n    function Default: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// return the Default RTTI value defined for this property, or 0 if not set\n    function DefaultOr0: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// index of the property in the current inherited class definition\n    // - first name index at a given class level is 0\n    // - index is reset to 0 at every inherited class level\n    function NameIndex: integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// the property Name, directly returned from RTTI\n    function Name: PShortString;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// the property Name, converted as a RawUtf8\n    function NameUtf8: RawUtf8;\n    /// the type information of this property\n    // - will de-reference the PropType pointer on Delphi and newer FPC compilers\n    function TypeInfo: PRttiInfo;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// get the next property information\n    // - no range check: use RttiProps()^.PropCount to determine the properties count\n    // - get the first PRttiProp with RttiProps()^.PropList\n    function Next: PRttiProp;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// returns rpsTrue/rpsFalse if was marked as \"stored true/false\" or\n    // rpsGetter if IsStoredGetter(Instance) is to be called at runtime\n    function IsStoredKind: TRttiPropStored;\n    /// raw retrieval of the 'stored' flag using getter\n    /// - called by IsStored or for TRttiPropStored = rpsGetter\n    function IsStoredGetter(Instance: TObject): boolean;\n    /// return the \"stored true/false/method/field\" value for a class property\n    // - not used internally: for backward compatibility only\n    function IsStored(Instance: TObject): boolean;\n    /// return true if this property is a BLOB (RawBlob)\n    function IsRawBlob: boolean;\n      {$ifdef FPC} inline; {$endif}\n    /// compute in how many bytes this property is stored\n    function FieldSize: PtrInt;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property has no getter but direct field read\n    // - returns FALSE if no \"read\" attribute was specified: use GetterCall\n    // if you want to mimic how Get*() methods could use the \"write\" field\n    function GetterIsField: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// return TRUE if the property has no setter but direct field write\n    // - returns FALSE if no \"write\" attribute is specified: use SetterCall\n    // if you want to mimic how Set*() methods could use the \"read\" field\n    function SetterIsField: boolean;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// returns how a property should be retrieved\n    // - no \"read\" attribute specified will return rpcField if \"write\" is a\n    // direct field access - just like any Get*() method would do\n    function GetterCall: TRttiPropCall;\n    /// returns how a property should be set\n    // - no \"write\" attribute specified will return rpcField if \"read\" is a\n    // direct field access - just like any Set*() method would do\n    function SetterCall: TRttiPropCall;\n    /// return TRUE if the property has a write setter or direct field\n    function WriteIsDefined: boolean;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// returns the low-level field read address, if GetterIsField is TRUE\n    function GetterAddr(Instance: pointer): pointer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// returns the low-level field write address, if SetterIsField is TRUE\n    function SetterAddr(Instance: pointer): pointer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n    /// low-level getter of the field value memory pointer\n    // - return NIL if both getter and setter are methods\n    function GetFieldAddr(Instance: TObject): pointer;\n      {$ifdef HASSAFEINLINE}inline;{$endif}\n\n    /// low-level getter of the ordinal property value of a given instance\n    // - this method will check if the corresponding property is ordinal\n    // - returns an Int64 to properly support cardinal values\n    // - return -1 on any error\n    function GetOrdValue(Instance: TObject): Int64;\n      {$ifdef FPC}inline;{$endif}\n    /// low-level getter of the ordinal property value of a given instance\n    // - this method will check if the corresponding property is ordinal\n    // - ordinal properties smaller than rkInt64 will return an Int64-converted\n    // value (e.g. rkInteger)\n    // - return 0 on any error\n    function GetInt64Value(Instance: TObject): Int64;\n    /// low-level getter of the currency property value of a given instance\n    // - this method will check if the corresponding property is exactly currency\n    // - return 0 on any error\n    procedure GetCurrencyValue(Instance: TObject; var Value: currency);\n    /// low-level getter of the floating-point property value of a given instance\n    // - this method will check if the corresponding property is floating-point\n    // - return 0 on any error\n    function GetDoubleValue(Instance: TObject): double;\n    /// low-level setter of the floating-point property value of a given instance\n    // - this method will check if the corresponding property is floating-point\n    procedure SetDoubleValue(Instance: TObject; const Value: double);\n    /// low-level getter of the long string property content of a given instance\n    // - just a wrapper around low-level GetLongStrProp() function\n    // - call GetLongStrValue() method if you want a conversion into RawUtf8\n    // - will work only for Kind=rkLString\n    procedure GetRawByteStringValue(Instance: TObject; var Value: RawByteString);\n    /// low-level setter of the ordinal property value of a given instance\n    // - this method will check if the corresponding property is ordinal\n    procedure SetOrdValue(Instance: TObject; Value: PtrInt);\n    /// low-level setter of the ordinal property value of a given instance\n    // - this method will check if the corresponding property is ordinal\n    procedure SetInt64Value(Instance: TObject; Value: Int64);\n    {$ifdef HASVARUSTRING}\n    /// low-level setter of the Unicode string property value of a given instance\n    // - this method will check if the corresponding property is a Unicode String\n    procedure SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);\n    /// low-level getter of the Unicode string property value of a given instance\n    // - this method will check if the corresponding property is a Unicode String\n    function GetUnicodeStrValue(Instance: TObject): UnicodeString;\n    {$endif HASVARUSTRING}\n    /// retrieve rkLString, rkSString, rkUString, rkWString, rkChar, rkWChar as RawUtf8\n    // - this would make heap allocations and encoding conversion, so may be slow\n    function GetAsString(Instance: TObject; var Value: RawUtf8): boolean; overload;\n    /// retrieve rkLString, rkSString, rkUString, rkWString, rkChar, rkWChar as RawUtf8\n    // - just a wrapper around the overloaded GetAsString() function\n    function GetAsString(Instance: TObject): RawUtf8; overload;\n      {$ifdef HASINLINE} inline; {$endif}\n    /// get a property value into text\n    // - handle all kind of fields, e.g. converting ordinal or floats into text\n    function GetValueText(Instance: TObject): RawUtf8;\n    /// set rkLString, rkSString, rkUString, rkWString, rkChar, rkWChar from\n    // a RawUtf8 value\n    // - this would make heap allocations and encoding conversion, so may be slow\n    function SetAsString(Instance: TObject; const Value: RawUtf8): boolean;\n    /// set a property value from a variant value\n    // - to be called when a setter is involved - not very fast, but safe\n    function SetValue(Instance: TObject; const Value: variant): boolean;\n    /// set a property value from a text value\n    // - handle simple kind of fields, e.g. converting from text into ordinals\n    // or floats, and also enumerates or sets; but won't support complex types\n    // like class instances, dynamic arrays or variants\n    function SetValueText(Instance: TObject; const Value: RawUtf8): boolean;\n  end;\n\nconst\n  NO_DEFAULT = integer($80000000);\n\n/// retrieve the text name of one TRttiKind enumerate\nfunction ToText(k: TRttiKind): PShortString; overload;\n\nvar\n  /// convert an ordinal value from its (signed) pointer-sized integer representation\n  RTTI_FROM_ORD: array[TRttiOrd] of function(P: pointer): Int64;\n\n  /// convert an ordinal value into its RTTI-defined binary buffer\n  RTTI_TO_ORD: array[TRttiOrd] of procedure(P: pointer; Value: PtrInt);\n\n  /// convert a float value into its RTTI-defined binary buffer\n  RTTI_TO_FLOAT: array[TRttiFloat] of procedure(P: pointer; Value: TSynExtended);\n\n\n{$ifdef HASINLINE}\n// some functions which should be defined here for proper inlining\n\n{$ifdef FPC}\n\n{$ifndef HASDIRECTTYPEINFO}\nfunction Deref(Info: pointer): pointer; inline;\n{$endif HASDIRECTTYPEINFO}\n\n{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}\nfunction AlignToPtr(p: pointer): pointer; inline;\n{$endif FPC_REQUIRES_PROPER_ALIGNMENT}\n\n{$endif FPC}\n\ntype\n  // redefined here for proper Delphi inlining\n  PTypeData = type typinfo.PTypeData;\n  TPropInfo = type typinfo.TPropInfo;\n  PPropInfo = type typinfo.PPropInfo;\n\n/// efficiently inlined low-level function to retrieve raw RTTI structure\nfunction GetTypeData(TypeInfo: pointer): PTypeData; inline;\n\n{$endif HASINLINE}\n\n{$ifdef ISDELPHI}// Delphi requires those definitions for proper inlining\n\nconst\n  NO_INDEX = integer($80000000);\n\n  ptField = $ff;\n  ptVirtual = $fe;\n\ntype\n  /// used to map a TPropInfo.GetProc/SetProc and retrieve its kind\n  // - defined here for proper Delphi inlining\n  PropWrap = packed record\n    FillBytes: array [0 .. SizeOf(Pointer) - 2] of byte;\n    /// =$ff for a ptField address, or =$fe for a ptVirtual method\n    Kind: byte;\n  end;\n\n  /// PPropData not defined in Delphi 7/2007 TypInfo\n  // - defined here for proper Delphi inlining\n  TPropData = packed record\n    PropCount: word;\n    PropList: record end;\n  end;\n  PPropData = ^TPropData;\n\n  /// rkRecord RTTI is not defined in Delphi 7/2007 TTypeData\n  // - defined here for proper Delphi inlining\n  TRecordInfo = packed record\n    RecSize: integer;\n    ManagedFldCount: integer;\n  end;\n  PRecordInfo = ^TRecordInfo;\n\n  /// rkArray RTTI not defined in Delphi 7/2007 TTypeData\n  // - defined here for proper Delphi inlining\n  TArrayInfo = packed record\n    ArraySize: integer;\n    ElCount: integer;\n    ArrayType: PPRttiInfo;\n    DimCount: byte;\n    Dims: array[0..255 {DimCount-1}] of PPRttiInfo;\n  end;\n  PArrayInfo = ^TArrayInfo;\n\n{$endif ISDELPHI}\n\n\n{ **************** Published Class Properties and Methods RTTI }\n\n/// retrieve the class RTTI information for a specific class\nfunction GetRttiClass(RttiClass: TClass): PRttiClass;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// retrieve the class property RTTI information for a specific class\nfunction GetRttiProps(RttiClass: TClass): PRttiProps;\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// retrieve the class property RTTI information for a specific class\n// - will return the number of published properties\n// - and set the PropInfo variable to point to the first property\n// - typical use to enumerate all published properties could be:\n//  !  var i: integer;\n//  !      CT: TClass;\n//  !      P: PRttiProp;\n//  !  begin\n//  !    CT := ..;\n//  !    repeat\n//  !      for i := 1 to GetRttiProp(CT,P) do\n// !       begin\n//  !        // use P^\n//  !        P := P^.Next;\n//  !      end;\n//  !      CT := GetClassParent(CT);\n//  !    until CT=nil;\n//  !  end;\n// such a loop is much faster than using the RTL's TypeInfo or RTTI units\nfunction GetRttiProp(C: TClass; out PropInfo: PRttiProp): integer;\n\n/// retrieve a Field property RTTI information from a Property Name\nfunction ClassFieldProp(ClassType: TClass; const PropName: ShortString): PRttiProp;\n\n/// retrieve a Field property RTTI information from a Property Name\n// - this special version also searches into parent properties\n// (TRttiProp search scope is only inside the current class level)\nfunction ClassFieldPropWithParents(aClassType: TClass; const aPropName: ShortString;\n  aCaseSensitive: boolean = false): PRttiProp;\n\n/// retrieve an integer/Int64 Field propery value from a Property Name\n// - this special version also searches into parent properties\n// (TRttiProp search scope is only inside the current class level)\n// - returns TRUE and set PropValue if a matching property was found\nfunction ClassFieldInt64(Instance: TObject; const PropName: ShortString;\n  out PropValue: Int64): boolean;\n\n/// retrieve a class Field property instance from a Property Name\n// - this special version also searches into parent properties\n// (TRttiProp search scope is only inside the current class level)\n// - returns TRUE and set PropInstance if a matching property was found\nfunction ClassFieldInstance(Instance: TObject; const PropName: ShortString;\n  PropClassType: TClass; out PropInstance): boolean; overload;\n\n/// retrieve a Field property RTTI information from a Property Name\n// - this special version also searches into parent properties\n// (TRttiProp search scope is only inside the current class level)\nfunction ClassFieldPropWithParentsFromUtf8(aClassType: TClass; PropName: PUtf8Char;\n  PropNameLen: integer; aCaseSensitive: boolean = false): PRttiProp;\n\n/// retrieve a Field property RTTI information searching for an exact\n// Property class type\n// - this special version also searches into parent properties\nfunction ClassFieldPropWithParentsFromClassType(aClassType,\n  aSearchedClassType: TClass): PRttiProp;\n\n/// retrieve a Field property RTTI information searching for an inherited\n// Property class type\n// - this special version also searches into parent properties\nfunction ClassFieldPropWithParentsInheritsFromClassType(aClassType,\n  aSearchedClassType: TClass): PRttiProp;\n\n/// retrieve a Field property RTTI information searching for an exact\n// Property offset address\n// - this special version also searches into parent properties\nfunction ClassFieldPropWithParentsFromClassOffset(aClassType: TClass;\n  aSearchedOffset: pointer): PRttiProp;\n\n/// retrieve a class Field property instance from a Property class type\n// - this version also searches into parent properties\n// - returns TRUE and set PropInstance if a matching property was found\nfunction ClassFieldInstance(Instance: TObject; PropClassType: TClass;\n  out PropInstance): boolean; overload;\n\n/// retrieve all class Field property instances from a Property class type\n// - this version also searches into parent properties\n// - returns all matching property instances found\nfunction ClassFieldInstances(Instance: TObject;\n  PropClassType: TClass): TObjectDynArray;\n\n/// retrieve a class instance property value matching a class type\n// - if aSearchedInstance is aSearchedClassType, will return aSearchedInstance\n// - if aSearchedInstance is not aSearchedClassType, it will try all nested\n// properties of aSearchedInstance for a matching aSearchedClassType: if no\n// exact match is found, will return aSearchedInstance\nfunction ClassFieldPropInstanceMatchingClass(aSearchedInstance: TObject;\n  aSearchedClassType: TClass): TObject;\n\n/// retrieve the total number of properties for a class, including its parents\nfunction ClassFieldCountWithParents(ClassType: TClass;\n  onlyWithoutGetter: boolean = false): integer;\n\n/// returns TRUE if the class has some published fields, including its parents\nfunction ClassHasPublishedFields(ClassType: TClass): boolean;\n\n/// retrieve all class hierachy types which have some published properties\nfunction ClassHierarchyWithField(ClassType: TClass): TClassDynArray;\n\n/// retrieve the PRttiProp values of all published properties of a class\n// - you could select which property types should be included in the list\nfunction ClassFieldAllProps(ClassType: TClass;\n  Types: TRttiKinds = [low(TRttiKind)..high(TRttiKind)]): PRttiPropDynArray;\n\n/// retrieve the field names of all published properties of a class\n// - will optionally append the property type to the name, e.g 'Age: integer'\n// - you could select which property types should be included in the list\nfunction ClassFieldNamesAllProps(\n  ClassType: TClass; IncludePropType: boolean = false;\n  Types: TRttiKinds = [low(TRttiKind)..high(TRttiKind)]): TRawUtf8DynArray;\n\n/// retrieve the field names of all published properties of a class\n// - will optionally append the property type to the name, e.g 'Age: integer'\n// - you could select which property types should be included in the list\nfunction ClassFieldNamesAllPropsAsText(\n  ClassType: TClass; IncludePropType: boolean = false;\n  Types: TRttiKinds = [low(TRttiKind)..high(TRttiKind)]): RawUtf8;\n\n\ntype\n  /// information about one method, as returned by GetPublishedMethods\n  TPublishedMethodInfo = record\n    /// the method name\n    Name: RawUtf8;\n    /// a callback to the method, for the given class instance\n    Method: TMethod;\n  end;\n  /// information about all methods, as returned by GetPublishedMethods\n  TPublishedMethodInfoDynArray = array of TPublishedMethodInfo;\n\n/// retrieve published methods information about any class instance\n// - will optionaly accept a Class, in this case Instance is ignored\n// - will work with FPC and Delphi RTTI\nfunction GetPublishedMethods(Instance: TObject;\n  out Methods: TPublishedMethodInfoDynArray; aClass: TClass = nil): integer;\n\n\n/// copy object properties\n// - copy integer, Int64, enumerates (including boolean), variant, records,\n// dynamic arrays, classes and any string properties (excluding ShortString)\n// - TCollection items can be copied also, if they are of the same exact class\n// - object properties instances are created in aTo if the objects are not\n// TOrm children (in this case, these are not class instances, but\n// INTEGER reference to records, so only the integer value is copied), that is\n// for regular classes\nprocedure CopyObject(aFrom, aTo: TObject); overload;\n\n/// create a new object instance, from an existing one\n// - will create a new instance of the same class, then call the overloaded\n// CopyObject() procedure to copy its values\nfunction CopyObject(aFrom: TObject): TObject; overload;\n\n/// copy two TStrings instances\n// - will just call Dest.Assign(Source) in practice\nprocedure CopyStrings(Source, Dest: TStrings);\n\n/// copy two TCollection instances\n// - will call CopyObject() in loop to repopulate the Dest collection,\n// which will work even if Assign() method was not overriden\nprocedure CopyCollection(Source, Dest: TCollection);\n\n/// set any default integer or enumerates (including boolean) published\n// properties values for a TPersistent/TSynPersistent\n// - set only the values set as \"property ... default ...\" at class type level\n// - will also reset the published properties of the nested classes\nprocedure SetDefaultValuesObject(Instance: TObject);\n\n/// set any (potentially nested) object property by path\n// - see also GetValueObject() from mormot.core.json\nfunction SetValueObject(Instance: TObject; const Path: RawUtf8;\n  const Value: variant): boolean;\n\n/// returns TRUE on a nil instance or if all its published properties are default/0\n// - check nested TRttiCustom.Props and TRttiCustom.ValueIterateCount\nfunction IsObjectDefaultOrVoid(Value: TObject): boolean;\n\n/// will reset all the object properties to their default\n// - strings will be set to '', numbers to 0\n// - if FreeAndNilNestedObjects is the default FALSE, will recursively reset\n// all nested class properties values\n// - if FreeAndNilNestedObjects is TRUE, will FreeAndNil() all the nested\n// class properties\n// - for a TOrm, use its ClearProperties method instead, which will\n// handle the ID property, and any nested JOINed instances\nprocedure ClearObject(Value: TObject; FreeAndNilNestedObjects: boolean = false);\n\n/// release all low-level managed fields of this instance\n// - just a wrapper around Value.CleanupInstance\nprocedure FinalizeObject(Value: TObject);\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// fill a class instance properties from command line switches\n// - SwitchPrefix + property name will be searched in CommandLine.Names[]\n// - is typically used to fill a settings class instance\n// - won't include any nested class or dynamic array properties\nfunction SetObjectFromExecutableCommandLine(Value: TObject;\n  const SwitchPrefix, DescriptionSuffix: RawUtf8;\n  CommandLine: TExecutableCommandLine = nil): boolean;\n\n\n{ *************** Enumerations RTTI }\n\n/// helper to retrieve low-level RTTI information of an enumeration type\n// - just a wrapper around\n// $ aTypeInfo^.EnumBaseType(List, result);\nfunction GetEnumType(aTypeInfo: PRttiInfo; out List: PShortString): integer;\n\n/// helper to retrieve the text of an enumerate item\n// - just a wrapper around\n// $ aTypeInfo^.EnumBaseType.GetEnumNameOrd(aIndex)\nfunction GetEnumName(aTypeInfo: PRttiInfo; aIndex: integer): PShortString;\n\n/// get the corresponding enumeration name, without the first lowercase chars\n// - e.g. otDone -> 'Done'\n// - this will return the code-based English text; use GetEnumCaption() to\n// retrieve the enumeration display text\nfunction GetEnumNameTrimed(aTypeInfo: PRttiInfo; aIndex: integer): RawUtf8;\n\n/// get the enumeration name, without the first lowercase chars, and uncamelcased\n// - e.g. otProcessDone -> 'Process done'\nfunction GetEnumNameUnCamelCase(aTypeInfo: PRttiInfo; aIndex: integer): RawUtf8;\n\n/// helper to retrieve all texts of an enumerate\n// - may be used as cache for overloaded ToText() content\nprocedure GetEnumNames(aTypeInfo: PRttiInfo; aDest: PPShortString);\n\n/// helper to retrieve all trimmed texts of an enumerate\n// - may be used as cache to retrieve UTF-8 text without lowercase 'a'..'z' chars\nprocedure GetEnumTrimmedNames(aTypeInfo: PRttiInfo; aDest: PRawUtf8); overload;\n\n/// helper to retrieve all trimmed texts of an enumerate as UTF-8 strings\n// - typical usage is the following:\n// ! var\n// !   TXT: array[TBenchmark] of RawUtf8;\n// ! ...\n// !   GetEnumTrimmedNames(TypeInfo(TBenchmark), @TXT);\nfunction GetEnumTrimmedNames(aTypeInfo: PRttiInfo): TRawUtf8DynArray; overload;\n\n/// helper to retrieve the index of an enumerate item from its text\n// - returns -1 if aValue was not found\n// - will search for the exact text and also trim the lowercase 'a'..'z' chars on\n// left side of the text if no exact match is found and AlsoTrimLowerCase is TRUE\nfunction GetEnumNameValue(aTypeInfo: PRttiInfo; aValue: PUtf8Char; aValueLen: PtrInt;\n  AlsoTrimLowerCase: boolean = false): integer; overload;\n\n/// retrieve the index of an enumerate item from its left-trimmed text\n// - text comparison is case-insensitive for A-Z characters\n// - will trim the lowercase 'a'..'z' chars on left side of the supplied aValue text\n// - returns -1 if aValue was not found\nfunction GetEnumNameValueTrimmed(aTypeInfo: PRttiInfo;\n  aValue: PUtf8Char; aValueLen: PtrInt): integer;\n\n/// retrieve the index of an enumerate item from its left-trimmed text\n// - text comparison is case-sensitive for A-Z characters\n// - will trim the lowercase 'a'..'z' chars on left side of the supplied aValue text\n// - returns -1 if aValue was not found\nfunction GetEnumNameValueTrimmedExact(aTypeInfo: PRttiInfo;\n  aValue: PUtf8Char; aValueLen: PtrInt): integer;\n\n/// helper to retrieve the index of an enumerate item from its text\nfunction GetEnumNameValue(aTypeInfo: PRttiInfo; const aValue: RawUtf8;\n  AlsoTrimLowerCase: boolean = false): integer; overload;\n\n/// store an enumeration value from its ordinal representation\nprocedure SetEnumFromOrdinal(aTypeInfo: PRttiInfo; out Value; Ordinal: PtrUInt);\n\n/// helper to retrieve the CSV text of all enumerate items defined in a set\nfunction GetSetName(aTypeInfo: PRttiInfo; const value): RawUtf8;\n\n/// helper to retrieve the CSV text of all enumerate items defined in a set\nprocedure GetSetNameShort(aTypeInfo: PRttiInfo; const value;\n  out result: ShortString; trimlowercase: boolean = false);\n\n/// low-level function parsing Value/ValueLen into a set, returned as 64-bit\nprocedure SetNamesValue(SetNames: PShortString; MinValue, MaxValue: integer;\n  Value: PUtf8Char; ValueLen: PtrInt; var Result: QWord);\n\n/// helper to parse some CSV values into a set, returned as 64-bit\n// - see also GetSetNameValue() in mormot.core.json.pas for parsing a JSON array\nfunction GetSetCsvValue(aTypeInfo: PRttiInfo; Csv: PUtf8Char;\n  Sep: AnsiChar = ','): QWord;\n\n/// helper to retrieve all (translated) caption texts of an enumerate\n// - may be used as cache for overloaded ToCaption() content\nprocedure GetEnumCaptions(aTypeInfo: PRttiInfo; aDest: PString);\n\n/// UnCamelCase and translate the enumeration item\nfunction GetCaptionFromEnum(aTypeInfo: PRttiInfo; aIndex: integer): string;\n\n/// low-level helper to retrieve a (translated) caption from a PShortString\n// - as used e.g. by GetEnumCaptions or GetCaptionFromEnum\nprocedure GetCaptionFromTrimmed(PS: PShortString; var result: string);\n\n/// will get a class name as UTF-8\n// - will trim 'T', 'TSyn' or 'TOrm' left side of the class name\n// - will encode the class name as UTF-8 (for Unicode Delphi versions)\n// - is used e.g. to extract the SQL table name for a TOrm class\nfunction GetDisplayNameFromClass(C: TClass): RawUtf8;\n\n/// UnCamelCase and translate the class name, triming any left 'T' 'TSyn' 'TOrm'\n// - return RTL string type, i.e. UnicodeString for Delphi 2009+\nfunction GetCaptionFromClass(C: TClass): string;\n\n/// defined here to avoid circular dependency in mormot.core.os.pas\nfunction ToText(cmd: TParseCommands): ShortString; overload;\n\n/// defined here to avoid circular dependency in mormot.core.os.pas\nfunction ToText(w: TWellKnownSid): PShortString; overload;\n\n\n{ ***************** IInvokable Interface RTTI }\n\ntype\n  /// handled kind of parameters direction for an interface method\n  // - IN, IN/OUT, OUT directions can be applied to arguments, e.g. to be\n  // available through our JSON-serialized remote access: rmdVar and rmdOut\n  // kind of parameters will be returned within the \"result\": JSON array\n  // - rmdResult is used for a function method, to handle the returned value\n  TRttiMethodArgDirection = (\n    rmdConst,\n    rmdVar,\n    rmdOut,\n    rmdResult);\n\n  /// set of parameter directions e.g. for an interface-based service method\n  TRttiMethodArgDirections = set of TRttiMethodArgDirection;\n\n  TRttiMethodArg = record\n    /// the argument name, as declared in pascal code\n    ParamName: PShortString;\n    /// the type name, as declared in pascal code\n    TypeName: PShortString;\n    /// the low-level RTTI information of this argument\n    TypeInfo: PRttiInfo;\n    /// how the parameter has been defined (const/var/out/result)\n    Direction: TRttiMethodArgDirection;\n  end;\n  PRttiMethodArg = ^TRttiMethodArg;\n\n  /// store IInvokable method information\n  TRttiMethod = record\n    /// the method name, e.g. 'Add' for ICalculator.Add\n    Name: RawUtf8;\n    /// 0 for the root interface, >0 for inherited interfaces\n    HierarchyLevel: integer;\n    /// the method arguments\n    Args: array of TRttiMethodArg;\n    /// if this method is a function, i.e. expects a result\n    IsFunction: boolean;\n  end;\n  PRttiMethod = ^TRttiMethod;\n\n  /// store IInvokable methods information\n  TRttiInterface = record\n    /// the interface name, e.g. 'ICalculator'\n    Name: RawUtf8;\n    /// the unit where the interface was defined\n    UnitName: RawUtf8;\n    /// the associated GUID of this interface\n    Guid: TGuid;\n    /// the interface methods\n    Methods: array of TRttiMethod;\n  end;\n  PRttiInterface = ^TRttiInterface;\n\n/// retrieve methods information of a given IInvokable\n// - all methods will be added, also from inherited interface definitions\n// - returns the number of methods detected\nfunction GetRttiInterface(aTypeInfo: PRttiInfo;\n  out aDefinition: TRttiInterface): integer;\n\n/// check if a pre-computed PInterfaceEntry has a direct IOffset information\nfunction InterfaceEntryIsStandard(Entry: PInterfaceEntry): boolean;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// execute an instance method from its RTTI per-interface information\n// - calling this function with a pre-computed PInterfaceEntry value is faster\n// than calling the TObject.GetInterface() method, especially when the class\n// implements several interfaces, since it avoid a slow GUID lookup\n// - if the interface is retrieved using a getter, will fallback to\n// the regular TObject.GetInterface RTL method\nfunction GetInterfaceFromEntry(Instance: TObject; Entry: PInterfaceEntry;\n  out Obj): boolean;\n\n/// returns all TGuid implemented by a given class\n// - TObject.GetInterfaceTable is not consistent on Delphi and FPC\nfunction GetRttiClassGuid(aClass: TClass): PGuidDynArray;\n\nconst\n  PSEUDO_RESULT_NAME: string[6] = 'Result';\n  PSEUDO_SELF_NAME:   string[4] = 'Self';\n\n\n\n{ ************* Efficient Dynamic Arrays and Records Process }\n\n/// faster alternative to Finalize(aVariantDynArray)\n// - this function will take account and optimize the release of a dynamic\n// array of custom variant types values\n// - for instance, an array of TDocVariant will be optimized for speed\nprocedure VariantDynArrayClear(var Value: TVariantDynArray);\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// low-level finalization of a dynamic array of any kind\n// - faster than RTL Finalize() or setting nil, when you know ElemInfo\n// - see also TRttiInfo.Clear if you want to finalize any type\nprocedure FastDynArrayClear(Value: PPointer; ElemInfo: PRttiInfo);\n\n/// low-level finalization of all dynamic array items of any kind\n// - as called by FastDynArrayClear(), after dec(RefCnt) reached 0\nprocedure FastFinalizeArray(Value: PPointer; ElemTypeInfo: PRttiInfo;\n  Count: integer);\n\n/// clear the managed fields of a record content\n// - won't reset all values to zero, only managed fields - see RecordZero()\n// - caller should ensure the type is indeed a record/object\n// - see also TRttiInfo.Clear if you want to finalize any type\n// - same as RTTI_FINALIZE[rkRecord]()\nfunction FastRecordClear(Value: pointer; Info: PRttiInfo): PtrInt;\n\n/// efficient finalization of successive record items from a (dynamic) array\nprocedure RecordClearSeveral(v: PAnsiChar; info: PRttiInfo; n: integer);\n\n/// efficient finalization of successive RawUtf8 items from a (dynamic) array\nprocedure StringClearSeveral(v: PPointer; n: PtrInt);\n\n/// low-level finalization of a dynamic array of RawUtf8\n// - faster than RTL Finalize() or setting nil\nprocedure RawUtf8DynArrayClear(var Value: TRawUtf8DynArray);\n  {$ifdef HASINLINE}inline;{$endif}\n\n/// check if the TypeInfo() points to an \"array of RawUtf8\"\n// - e.g. returns true for TypeInfo(TRawUtf8DynArray) or other sub-types\n// defined as \"type aNewType = type TRawUtf8DynArray\"\nfunction IsRawUtf8DynArray(Info: PRttiInfo): boolean;\n\n/// initialize a record content\n// - calls FastRecordClear() and FillCharFast() with 0\n// - do nothing if the TypeInfo is not from a record/object\nprocedure RecordZero(Dest: pointer; Info: PRttiInfo);\n\n/// copy a record content from source to Dest\nprocedure RecordCopy(var Dest; const Source; Info: PRttiInfo);\n  {$ifdef FPC}inline;{$endif}\n\n/// efficiently copy several (dynamic) array items\n// - faster than the RTL CopyArray() function\nprocedure CopySeveral(Dest, Source: PByte; SourceCount: PtrInt;\n  ItemInfo: PRttiInfo; ItemSize: PtrInt);\n\n/// low-level initialization of a dynamic array\n// - faster than System.DynArraySetLength() function on a void dynamic array,\n// when the RTTI is known\n// - caller should ensure that Dest is not nil, but Dest^ = nil (i.e. a\n// clear/void dynamic array)\nfunction DynArrayNew(Dest: PPointer; Count, ItemSize: PtrInt): pointer;\n\n/// low-level size up of a dynamic array\n// - faster than System.DynArraySetLength() function dynamic array with RefCnt=1\n// - caller should ensure that Dest is not nil\n// - DataBytes is expected to be Count * ItemSize\nfunction DynArrayGrow(Dest: PPointer; Count, ItemSize: PtrInt): PAnsiChar;\n\n/// create a dynamic array from another one\n// - same as RTTI_MANAGEDCOPY[rkDynArray] but with an optional external source count\nprocedure DynArrayCopy(Dest, Source: PPointer; Info: PRttiInfo;\n  SourceExtCount: PInteger = nil);\n\n/// same as Value := copy(Value) but faster and with no temporary variable\nprocedure DynArrayEnsureUnique(Value: PPointer; Info: PRttiInfo);\n\n/// same as Value := copy(Value) but faster and with no temporary variable\nprocedure EnsureUnique(var Value: TIntegerDynArray); overload;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// same as Value := copy(Value) but faster and with no temporary variable\nprocedure EnsureUnique(var Value: TRawUtf8DynArray); overload;\n  {$ifdef HASINLINE} inline; {$endif}\n\n/// same as Value := copy(Value) but faster and with no temporary variable\nprocedure EnsureUnique(var Value: TVariantDynArray); overload;\n  {$ifdef HASINLINE} inline; {$endif}\n\n\n{ ************* Managed Types Finalization, Random or Copy }\n\ntype\n  /// internal function handler for finalizing a managed type value\n  // - i.e. the kind of functions called via RTTI_FINALIZE[] lookup table\n  // - as used by TRttiInfo.Clear() inlined method\n  TRttiFinalizer = function(Data: pointer; Info: PRttiInfo): PtrInt;\n\n  /// the type of RTTI_FINALIZE[] efficient lookup table\n  TRttiFinalizers = array[TRttiKind] of TRttiFinalizer;\n  PRttiFinalizers = ^TRttiFinalizers;\n\n  /// internal function handler for copying a managed type value\n  // - i.e. the kind of functions called via RTTI_MANAGEDCOPY[] lookup table\n  TRttiCopier = function(Dest, Source: pointer; Info: PRttiInfo): PtrInt;\n\n  /// the type of RTTI_MANAGEDCOPY[] efficient lookup table\n  TRttiCopiers = array[TRttiKind] of TRttiCopier;\n  PRttiCopiers = ^TRttiCopiers;\n\n  /// internal function handler for copying a class instance\n  // - use TRttiCustom.Props.CopyProperties but may be overriden e.g. for TOrm\n  TRttiClassCopier = procedure(Dest, Source: TObject);\n\n\nvar\n  /// lookup table of finalization functions for managed types\n  // - as used by TRttiInfo.Clear() inlined method\n  // - RTTI_FINALIZE[...]=nil for unmanaged types (e.g. rkOrdinalTypes)\n  RTTI_FINALIZE: TRttiFinalizers;\n\n  /// lookup table of copy function for managed types\n  // - as used by TRttiInfo.Copy() inlined method\n  // - RTTI_MANAGEDCOPY[...]=nil for unmanaged types (e.g. rkOrdinalTypes)\n  RTTI_MANAGEDCOPY: TRttiCopiers;\n\n/// fill all sensitive fields of this class or record with zeros\n// - RawByteString/TBytes with refcount=1 will be zeroed before freed\nprocedure FillZeroRtti(Info: PRttiInfo; var Value);\n\n\n\n{ ************** RTTI Value Types used for JSON Parsing }\n\ntype\n  /// the kind of variables handled by our RTTI/JSON parser\n  // - the last item should be ptCustom, for non simple types\n  // - ptOrm is recognized from TID, T*ID, TRecordReference,\n  // TRecordReferenceToBeDeleted and TRecordVersion type names\n  // - ptTimeLog is recognized from TTimeLog, TCreateTime and TModTime\n  // - other types (not ptComplexTypes) are recognized by their genuine type name\n  // - ptUnicodeString is defined even if not available prior to Delphi 2009\n  // - replace deprecated TJsonCustomParserRTTIType type from old mORMot 1.18\n  // - TDynArrayKind is now an alias to this genuine enumerate\n  TRttiParserType = (\n    ptNone,\n    ptArray,\n    ptBoolean,\n    ptByte,\n    ptCardinal,\n    ptCurrency,\n    ptDouble,\n    ptExtended,\n    ptInt64,\n    ptInteger,\n    ptQWord,\n    ptRawByteString,\n    ptRawJson,\n    ptRawUtf8,\n    ptRecord,\n    ptSingle,\n    ptString,\n    ptSynUnicode,\n    ptDateTime,\n    ptDateTimeMS,\n    ptGuid,\n    ptHash128,\n    ptHash256,\n    ptHash512,\n    ptOrm,\n    ptTimeLog,\n    ptUnicodeString,\n    ptUnixTime,\n    ptUnixMSTime,\n    ptVariant,\n    ptWideString,\n    ptWinAnsi,\n    ptWord,\n    ptEnumeration,\n    ptSet,\n    ptClass,\n    ptDynArray,\n    ptInterface,\n    ptPUtf8Char,\n    ptCustom);\n\n  /// the complex kind of variables for ptTimeLog and ptOrm TRttiParserType\n  TRttiParserComplexType = (\n    pctNone,\n    pctTimeLog,\n    pctCreateTime,\n    pctModTime,\n    pctID,\n    pctSpecificClassID,\n    pctRecordReference,\n    pctRecordReferenceToBeDeleted,\n    pctRecordVersion);\n\n  PRttiParserType = ^TRttiParserType;\n  TRttiParserTypes = set of TRttiParserType;\n  PRttiParserComplexType = ^TRttiParserComplexType;\n  TRttiParserComplexTypes = set of TRttiParserComplexType;\n\nconst\n  /// map a PtrInt type to the TRttiParserType set\n  ptPtrInt  = {$ifdef CPU64} ptInt64 {$else} ptInteger {$endif};\n\n  /// map a PtrUInt type to the TRttiParserType set\n  ptPtrUInt = {$ifdef CPU64} ptQWord {$else} ptCardinal {$endif};\n\n  /// which TRttiParserType are not simple types\n  // - ptTimeLog and ptOrm are complex, since more than one TypeInfo() may\n  // map to their TRttiParserType - see also TRttiParserComplexType\n  ptComplexTypes =\n    [ptArray,\n     ptRecord,\n     ptCustom,\n     ptTimeLog,\n     ptOrm,\n     ptDynArray,\n     ptEnumeration,\n     ptSet,\n     ptClass,\n     ptInterface];\n\n  /// which TRttiParserType types don't need memory management\n  ptUnmanagedTypes =\n    [ptBoolean..ptQWord,\n     ptSingle,\n     ptDateTime..ptTimeLog,\n     ptUnixTime,\n     ptUnixMSTime,\n     ptWord..ptClass];\n\n  /// which TRttiParserType types are (usually) serialized as JSON \"text\"\n  // - actual serialization may depend e.g. on TTextWriterWriteObjectOptions\n  ptStringTypes =\n    [ptRawByteString .. ptRawUtf8,\n     ptString .. ptHash512,\n     ptTimeLog,\n     ptUnicodeString,\n     ptWideString,\n     ptWinAnsi,\n     ptPUtf8Char];\n\n  /// which TRttiParserType types could be serialized as multi-line JSON \"text\"\n  // - e.g. plain RawUtf8 which may include \\n line feeds but not RawByteString,\n  // TTimeLog or THash128, which never include line breaks within their \"value\"\n  ptMultiLineStringTypes =\n    [ptRawUtf8,\n     ptString,\n     ptSynUnicode,\n     ptUnicodeString,\n     ptWideString,\n     ptWinAnsi];\n\nvar\n  /// simple lookup to the plain RTTI type of most simple managed types\n  // - nil for unmanaged types (e.g. rkOrdinals) or for more complex types\n  // requering additional PRttiInfo (rkRecord, rkDynArray, rkArray...)\n  // - you can use PT_INFO[] for types with no RTTI before Delphi 2010, for\n  // instance PT_INFO[ptGuid], PT_INFO[ptHash128], PT_INFO[ptHash256] and\n  // PT_INFO[ptHash512] since oldest compilers refuse to compile TypeInfo(TGuid),\n  // TypeInfo(THash128), TypeInfo(THash256) and TypeInfo(THash512)\n  PT_INFO: array[TRttiParserType] of PRttiInfo;\n\n  /// simple lookup to the plain RTTI type of most simple managed types\n  // - nil if the complex type is not known\n  // - mormot.orm.base may set the exact TypeInfo(TRecordReference) value - this\n  // unit set plain TypeInfo(QWord) which is enough for JSON Serialization\n  PTC_INFO: array[TRttiParserComplexType] of PRttiInfo;\n\nconst\n  /// simple lookup to the TRttiParserType of a complex type\n  PTC_PT: array[TRttiParserComplexType] of TRttiParserType = (\n    ptNone,      // pctNone\n    ptTimeLog,   // pctTimeLog\n    ptTimeLog,   // pctCreateTime\n    ptTimeLog,   // pctModTime\n    ptOrm,       // pctID\n    ptNone,      // pctSpecificClassID\n    ptOrm,       // pctRecordReference\n    ptOrm,       // pctRecordReferenceToBeDeleted\n    ptOrm );     // pctRecordVersion\n\n  /// simple lookup to the size in bytes of TRttiParserType values\n  PT_SIZE: array[TRttiParserType] of byte = (\n    0,                //  ptNone\n    0,                //  ptArray\n    1,                //  ptBoolean\n    1,                //  ptByte\n    4,                //  ptCardinal\n    8,                //  ptCurrency\n    8,                //  ptDouble\n    8,                //  ptExtended\n    8,                //  ptInt64\n    4,                //  ptInteger\n    8,                //  ptQWord\n    SizeOf(pointer),  //  ptRawByteString\n    SizeOf(pointer),  //  ptRawJson\n    SizeOf(pointer),  //  ptRawUtf8\n    0,                //  ptRecord\n    4,                //  ptSingle\n    SizeOf(pointer),  //  ptString\n    SizeOf(pointer),  //  ptSynUnicode\n    8,                //  ptDateTime\n    8,                //  ptDateTimeMS\n    16,               //  ptGuid\n    16,               //  ptHash128\n    32,               //  ptHash256\n    64,               //  ptHash512\n    8,                //  ptOrm\n    8,                //  ptTimeLog\n    SizeOf(pointer),  //  ptUnicodeString\n    8,                //  ptUnixTime\n    8,                //  ptUnixMSTime\n    SizeOf(variant),  //  ptVariant\n    SizeOf(pointer),  //  ptWideString\n    SizeOf(pointer),  //  ptWinAnsi\n    2,                //  ptWord\n    0,                //  ptEnumeration\n    0,                //  ptSet\n    SizeOf(pointer),  //  ptClass\n    SizeOf(pointer),  //  ptDynArray\n    SizeOf(pointer),  //  ptInterface\n    SizeOf(pointer),  //  ptPUtf8Char\n    0 );              //  ptCustom\n\n  /// type definition name lookup to the TRttiParserType values\n  // - ptComplexTypes types should see PTC_NAME[] constant\n  PT_NAME: array[TRttiParserType] of RawUtf8 = (\n    '',               //  ptNone\n    '',               //  ptArray\n    'boolean',        //  ptBoolean\n    'byte',           //  ptByte\n    'cardinal',       //  ptCardinal\n    'currency',       //  ptCurrency\n    'double',         //  ptDouble\n    'extended',       //  ptExtended\n    'Int64',          //  ptInt64\n    'integer',        //  ptInteger\n    'QWord',          //  ptQWord\n    'RawByteString',  //  ptRawByteString\n    'RawJson',        //  ptRawJson\n    'RawUtf8',        //  ptRawUtf8\n    '',               //  ptRecord\n    'single',         //  ptSingle\n    'string',         //  ptString\n    'SynUnicode',     //  ptSynUnicode\n    'TDateTime',      //  ptDateTime\n    'TDateTimeMS',    //  ptDateTimeMS\n    'TGuid',          //  ptGuid\n    'THash128',       //  ptHash128\n    'THash256',       //  ptHash256\n    'THash512',       //  ptHash512\n    '',               //  ptOrm\n    '',               //  ptTimeLog\n    'UnicodeString',  //  ptUnicodeString\n    'TUnixTime',      //  ptUnixTime\n    'TUnixMSTime',    //  ptUnixMSTime\n    'variant',        //  ptVariant\n    'WideString',     //  ptWideString\n    'WinAnsi',        //  ptWinAnsi\n    'word',           //  ptWord\n    '',               //  ptEnumeration\n    '',               //  ptSet\n    '',               //  ptClass\n    '',               //  ptDynArray\n    '',               //  ptInterface\n    'PUtf8Char',      //  ptPUtf8Char\n    '');              //  ptCustom\n\n  /// type definition name lookup to the TRttiParserComplexType values\n  // - for ptComplexTypes types, with PT_NAME[]=''\n  // - ptcSpecificClassID returns '' since T....ID types are variable\n  PTC_NAME: array[TRttiParserComplexType] of RawUtf8 = (\n    '',                            // pctNone\n    'TTimeLog',                    // pctTimeLog\n    'TCreateTime',                 // pctCreateTime\n    'TModTime',                    // pctModTime\n    'TID',                         // pctID\n    '',                            // pctSpecificClassID\n    'TRecordReference',            // pctRecordReference\n    'TRecordReferenceToBeDeleted', // pctRecordReferenceToBeDeleted\n    'TRecordVersion');             // pctRecordVersion\n\n/// retrieve the text name of one TRttiParserType enumerate\nfunction ToText(t: TRttiParserType): PShortString; overload;\n\n/// retrieve the TypeInfo() from PT_INFO[] PTC_INFO[] constant arrays\nfunction ParserTypeToTypeInfo(pt: TRttiParserType;\n  pct: TRttiParserComplexType): PRttiInfo;\n\n/// recognize most simple types and return their known dynamic array RTTI\n// - returns nil if we don't know any dynamic array for this type\n// - ExpectExactElemInfo=true ensure that result's ArrayRtti.Info = ElemInfo\n// - currently not called: IList<T> and IKeyValue<T> just use TypeInfo(T)\nfunction TypeInfoToDynArrayTypeInfo(ElemInfo: PRttiInfo;\n  ExpectExactElemInfo: boolean; ParserType: PRttiParserType = nil): PRttiInfo;\n\n\n\n{ ************** RTTI-based Registration for Custom JSON Parsing }\n\nconst\n  /// TRttiCustomList stores its TypeInfo() by Kind + PRttiInfo/Name\n  // - optimized \"hash table of the poor\" (tm) for FindType() and Find(Name)\n  // - should be a bit mask (i.e. power of two minus 1)\n  RTTIHASH_MAX = {$ifdef NOPATCHVMT} 63 {$else} 31 {$endif};\n\ntype\n  TRttiCustom = class;\n\n  PRttiCustomProp = ^TRttiCustomProp;\n  PPRttiCustomProp = ^PRttiCustomProp;\n\n  /// variant-like value as returned by TRttiCustomProp.GetValueDirect and\n  // GetValueGetter methods\n  // - simple values (integers, floats, strings or variant) are set into Data\n  // - rkEnumeration, rkSet, rkDynArray, rkClass, rkInterface, rkRecord and\n  // rkObject are stored as varAny/PropValue pointer to the field value (for\n  // GetValueDirect) or Instance (for GetValueGetter if PropValueIsInstance=true),\n  // and Prop to the corresponding property RTTI\n  // - will be properly handled by TJsonWriter.AddVariant/AddRttiVarData\n  // - can be casted as a variant value, but contains RTTI and clear flag:\n  // ! if rvd.NeedsClear then VarClearProc(rvd.Data);\n  TRttiVarData = packed record\n    case integer of\n    varUnknown: (\n      VType: cardinal);    // maps DataType + NeedsClear + PropValueIsInstance\n    varVariant: (\n      Data: TVarData);\n    varAny: (\n      DataType: word;      // matches TVarData.VType\n      NeedsClear: boolean;\n      PropValueIsInstance: boolean;\n      // Assert(@PropValue=@VAny) is done in initialization section below\n      {$ifdef CPU32}\n      Prop: PRttiCustomProp;\n      PropValue: pointer; // TObject if PropValueIsInstance=true, or field addr\n      {$else}\n      Padding4: cardinal;\n      PropValue: pointer; // TObject if PropValueIsInstance=true, or field addr\n      Prop: PRttiCustomProp;\n      {$endif CPU32});\n  end;\n  PRttiVarData = ^TRttiVarData;\n\n  /// define specific behavior for a given TypeInfo/PRttIinfo\n  // - rcfIsManaged is set if a value of this type expects finalization\n  // - rcfObjArray is for T*ObjArray dynamic arrays\n  // - rcfBinary is for hexadecimal serialization of integers\n  // - rcfJsonString when is to be serialized as text and properly JSON-escaped\n  // (ptStringTypes or rcfBinary, but excluding ptRawJson)\n  // - rcfWithoutRtti is set if was created purely by text, and uses fake RTTI\n  // - rcfSpi identifies types containing Sensitive Personal Information\n  // (e.g. a bank card number or a plain password) which should be hidden\n  // - rcfHookWrite, rcfHookWriteProperty, rcfHookRead, rcfHookReadProperty for\n  // TObjectWithCustomCreate kind of class, to customize JSON serialization\n  // calling the set of TObjectWithCustomCreate protected virtual methods -\n  // disabled by default not to slow down the serialization process\n  // - rcfHasNestedProperties is set e.g. for rkClass or rcfWithoutRtti records,\n  // rcfHasNestedManagedProperties if any of the property/field is rcfIsManaged\n  // - rcfHasOffsetSetJsonLoadProperties is set if all nested properties can be\n  // directly written, i.e. have OffsetSet >= 0 and Assigned(JsonLoad)\n  // - rcfArrayItemManaged maps rcfIsManaged flag in ArrayRtti.Flags\n  // - rcfReadIgnoreUnknownFields will let JSON unserialization ignore unknown\n  // fields for this class/record\n  // - rcfAutoCreateFields is defined when AutoCreateFields() has been called\n  // - rcfDisableStored is set for TOrm, where \"stored AS_UNIQUE\" does not mean\n  // \"not stored\" for serialization but \"UNIQUE SQL\"\n  // - rcfClassMayBeID is set e.g. for TOrm classes, which may be storing\n  // not instances but IDs in published properties PtrInt\n  TRttiCustomFlag = (\n    rcfIsManaged,\n    rcfObjArray,\n    rcfBinary,\n    rcfJsonString,\n    rcfWithoutRtti,\n    rcfSpi,\n    rcfHookWrite,\n    rcfHookWriteProperty,\n    rcfHookRead,\n    rcfHookReadProperty,\n    rcfHasNestedProperties,\n    rcfHasNestedManagedProperties,\n    rcfHasOffsetSetJsonLoadProperties,\n    rcfArrayItemManaged,\n    rcfReadIgnoreUnknownFields,\n    rcfAutoCreateFields,\n    rcfDisableStored,\n    rcfClassMayBeID);\n\n  /// define specific behaviors for a given TypeInfo/PRttIinfo\n  // - as stored in TRttiCustom.Flags\n  TRttiCustomFlags = set of TRttiCustomFlag;\n\n  /// store information about one property/field of a given TypeInfo/PRttIinfo\n  // - used by both rkClass for published properties, and rkRecord/rkObject\n  // for nested fields\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiCustomProp = record\n  {$else}\n  TRttiCustomProp = object\n  {$endif USERECORDWITHMETHODS}\n  private\n    fOrigName: RawUtf8; // as set by InternalAdd()\n    function InitFrom(RttiProp: PRttiProp): PtrInt;\n    function ValueIsVoidGetter(Data: pointer): boolean;\n    procedure GetValueDirect(Data: PByte; out RVD: TRttiVarData);\n    procedure GetValueGetter(Instance: TObject; out RVD: TRttiVarData);\n    function CompareValueComplex(Data, Other: pointer;\n      OtherRtti: PRttiCustomProp; CaseInsensitive: boolean): integer;\n  public\n    /// contains standard TypeInfo/PRttiInfo of this field/property\n    // - for instance, Value.Size contains its memory size in bytes\n    Value: TRttiCustom;\n    /// read field/property offset in the record/class instance memory\n    // - equals -1 if Prop has a getter\n    OffsetGet: PtrInt;\n    /// write field/property offset in the record/class instance memory\n    // - equals -1 if Prop has a setter\n    OffsetSet: PtrInt;\n    /// contains Prop^.Name or a customized field/property name\n    // - equals '' if Props.NameChange() was set to New='', meaning this field\n    // should not be part of the serialized JSON object\n    Name: RawUtf8;\n    /// store standard RTTI of this published property\n    // - equals nil for rkRecord/rkObject nested field\n    Prop: PRttiProp;\n    /// equals NO_DEFAULT or the default integer value of this property\n    OrdinalDefault: integer;\n    /// reflect the \"stored\" property attribute as defined in the source\n    Stored: TRttiPropStored;\n    /// case-insensitive compare the supplied name/len with the Name property\n    function NameMatch(P: PUtf8Char; Len: PtrInt): boolean;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// very fast retrieval of any field value into a TVarData-like mapping\n    // - works if Prop is defined or not, calling any getter method if needed\n    // - complex TRttiVarData with varAny pointer will be properly handled by\n    // TJsonWriter.AddVariant/AddRttiVarData (e.g. rkEnumeration or rkDynArray)\n    // - rvd can be casted to a variant, but contains RTTI Info and clear flag:\n    // ! if rvd.NeedsClear then VarClearProc(rvd.Data);\n    procedure GetValue(Data: pointer; out RVD: TRttiVarData);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// set a field value to a given TVarData-like content\n    // - optionally check and apply RVD.NeedsClear flag (leave it as true if\n    // RVD comes from GetValue)\n    // - not implemented for Prop = nil (i.e. rkRecord/rkObject nested field)\n    procedure SetValue(Data: pointer; var RVD: TRttiVarData;\n      andclear: boolean = true);\n    /// retrieve any field vlaue as a variant instance\n    // - will generate a stand-alone variant value, not an internal TRttiVarData\n    // - complex values can be returned as TDocVariant after JSON conversion,\n    // using e.g. @JSON_[mFastFloat] as optional Options parameter\n    procedure GetValueVariant(Data: pointer; out Dest: TVarData;\n      Options: pointer{PDocVariantOptions} = nil);\n    /// set a field value from its UTF-8 text\n    // - will convert the Text into proper ordinal or float if needed\n    // - also implemented for Prop = nil (i.e. rkRecord/rkObject nested field)\n    // - use Prop^.SetValueText() if you want to support enumerates and sets\n    function SetValueText(Data: pointer; const Text: RawUtf8): boolean;\n    /// check if the Value equals the default property set in source code\n    // - caller should have checked that PropDefault <> NO_DEFAULT\n    function ValueIsDefault(Data: pointer): boolean;\n    /// check if the Value is void (0 / '' / null)\n    // - less restrictive function than VarIsVoid() from mormot.core.variants\n    function ValueIsVoid(Data: pointer): boolean;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// compare two properties values with proper getter method call\n    // - is likely to call Value.ValueCompare() which requires mormot.core.json\n    function CompareValue(Data, Other: pointer; const OtherRtti: TRttiCustomProp;\n      CaseInsensitive: boolean): integer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// append the field value as JSON with proper getter method call\n    // - wrap GetValue() + AddVariant() over a temp TRttiVarData\n    procedure AddValueJson(W: TTextWriter; Data: pointer;\n      Options: TTextWriterWriteObjectOptions; K: TTextWriterKind = twNone);\n    /// a wrapper calling AddValueJson()\n    procedure GetValueJson(Data: pointer; out Result: RawUtf8);\n  end;\n\n  /// store information about the properties/fields of a given TypeInfo/PRttiInfo\n  TRttiCustomPropDynArray = array of TRttiCustomProp;\n\n  PRttiCustomPropDynArray = array of PRttiCustomProp;\n\n  /// store information about all properties/fields of a given TypeInfo/PRttIinfo\n  // - includes parent properties when filled by AddFromClass(IncludeParents=true)\n  {$ifdef USERECORDWITHMETHODS}\n  TRttiCustomProps = record\n  {$else}\n  TRttiCustomProps = object\n  {$endif USERECORDWITHMETHODS}\n  public\n    /// one List[] item per property/field\n    List: TRttiCustomPropDynArray;\n    /// how many properties/fields are in List[]\n    Count: integer;\n    /// how many properties/fields with Name <> '' are in List[]\n    CountNonVoid: integer;\n    /// total size, in bytes, of all properties/fields\n    // - equals the sum of List[].Value.Size\n    Size: integer;\n    /// List[NotInheritedIndex]..List[Count-1] store the last level of properties\n    NotInheritedIndex: integer;\n    /// contains List[].Name as a JSON array including a trailing ,\n    // - as used by _JS_DynArray() for efficient twoNonExpandedArrays generation\n    NamesAsJsonArray: RawUtf8;\n    /// points to List[] items which are managed\n    Managed: PRttiCustomPropDynArray;\n    /// locate a property/field by name\n    // - just redirect to FindCustomProp() low-level function\n    function Find(const PropName: RawUtf8): PRttiCustomProp; overload;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// locate a property/field by name\n    // - just redirect to FindCustomProp() low-level function\n    function Find(PropName: PUtf8Char; PropNameLen: PtrInt): PRttiCustomProp; overload;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// locate a property/field index by name\n    function FindIndex(PropName: PUtf8Char; PropNameLen: PtrInt): PtrInt;\n    /// customize a property/field name\n    // - New is expected to be only plain pascal identifier, i.e.\n    // A-Z a-z 0-9 and _ characters, up to 63 in length\n    // - if New equals '', this published property will be excluded from\n    // the JSON serialized object\n    function NameChange(const Old, New: RawUtf8): PRttiCustomProp;\n    /// customize property/field name, specified as old/new pairs\n    // - will first restore all field names from RTTI, then each Old[] field\n    // name will be replaced by the corresponding New[] name\n    // - so setting both Old=New=[] just set back the default names from RTTI\n    // - New[] is expected to be only plain pascal identifier, i.e.\n    // A-Z a-z 0-9 and _ characters, up to 63 in length\n    // - if any New[] equals '', this published property will be excluded from\n    // the JSON serialized object\n    // - Rtti.ByClass[TMyClass].Props.NameChanges() replaces deprecated\n    // TJsonSerializer.RegisterCustomSerializerFieldNames(TMyClass, ...)\n    procedure NameChanges(const Old, New: array of RawUtf8);\n    /// reset all properties\n    procedure InternalClear;\n    /// manual adding of a property/field definition\n    // - append as last field, unless AddFirst is set to true\n    procedure InternalAdd(Info: PRttiInfo; Offset: PtrInt; const PropName: RawUtf8;\n      AddFirst: boolean = false);\n    /// register the published properties of a given class\n    // - is called recursively if IncludeParents is true\n    procedure InternalAddFromClass(ClassInfo: PRttiInfo; IncludeParents: boolean);\n    /// prepare List[result].Name from TRttiCustom.SetPropsFromText\n    function FromTextPrepare(const PropName: RawUtf8): integer;\n    /// register the properties specified from extended RTTI (Delphi 2010+ only)\n    // - do nothing on FPC or Delphi 2009 and older\n    procedure SetFromRecordExtendedRtti(RecordInfo: PRttiInfo);\n    /// called once List[] and Size have been defined\n    // - compute the Managed[] internal list and return the matching flags\n    function AdjustAfterAdded: TRttiCustomFlags;\n    /// retrieve all List[] items as text\n    procedure AsText(out Result: RawUtf8; IncludePropType: boolean;\n      const Prefix, Suffix: RawUtf8);\n    /// finalize and fill with zero all properties of this class instance\n    // - it will individually fill the properties, not the whole memory\n    // as TRttiCustom.FinalizeAndClear would on a record\n    procedure FinalizeAndClearPublishedProperties(Instance: TObject);\n    /// finalize the managed properties of this instance\n    // - called e.g. when no RTTI is available, i.e. text serialization\n    procedure FinalizeManaged(Data: PAnsiChar);\n    /// copy the fields of a rkRecordTypes instance\n    // - called e.g. when no RTTI is available, i.e. text serialization\n    // - will move() all bytes between managed fields\n    procedure CopyRecord(Dest, Source: PAnsiChar);\n    /// copy the properties of a rkClass instance\n    // - called e.g. when no RTTI is available, i.e. text serialization\n    // - will copy all published properties one-by-one\n    procedure CopyProperties(Dest, Source: PAnsiChar);\n  end;\n\n  PRttiCustomProps = ^TRttiCustomProps;\n\n  /// used internally for fast allocation of a rkClass/rkInterface instance\n  // - member is properly initialized by TRttiJson from mormot.core.json.pas\n  TRttiCustomNewInstance = function(Rtti: TRttiCustom): pointer;\n\n  /// internal function handler for filling a value with some randomness\n  TRttiCustomRandom = procedure(Data: pointer; Rtti: TRttiCustom);\n\n  /// used internally by our RTTI text definition\n  TRttiCustomFromTextExpectedEnd = (\n    eeNothing,\n    eeSquare,\n    eeCurly,\n    eeEndKeyWord);\n\n  /// the recognized raw RTL classes as identified in TRttiCustom.ValueRtlClass\n  TRttiValueClass = (\n    vcNone,\n    vcCollection,\n    vcStrings,\n    vcObjectList,\n    vcList,\n    vcSynList,\n    vcRawUtf8List,\n    vcESynException,\n    vcException,\n    vcObjectWithID);\n\n\n  /// allow to customize the process of a given TypeInfo/PRttiInfo\n  // - a global list of TRttiCustom instances mapping TypeInfo() is maintained\n  // in Rtti: TRttiCustomList\n  // - never instantiate this class directly, but call RttiCustom methods\n  TRttiCustom = class\n  protected\n    fCache: TRttiCache;\n    fParser: TRttiParserType;\n    fParserComplex: TRttiParserComplexType;\n    fValueRtlClass: TRttiValueClass;\n    fArrayFirstField: TRttiParserType;\n    fFlags: TRttiCustomFlags;\n    fPrivateSlot: pointer;\n    fArrayRtti: TRttiCustom;\n    fFinalize: TRttiFinalizer;\n    fCopy: TRttiCopier;\n    fName: RawUtf8;\n    fProps: TRttiCustomProps;\n    fOwnedRtti: array of TRttiCustom; // for SetPropsFromText(NoRegister=true)\n    fSetRandom: TRttiCustomRandom;\n    fPrivateSlots: TObjectDynArray;\n    fPrivateSlotsSafe: TLightLock;\n    // used by mormot.core.json.pas\n    fBinarySize: integer;\n    fJsonLoad: pointer; // contains a TRttiJsonLoad - used if fJsonReader=nil\n    fJsonSave: pointer; // contains a TRttiJsonSave - used if fJsonWriter=nil\n    fJsonReader, fJsonWriter: TMethod; // TOnRttiJsonRead/TOnRttiJsonWrite\n    fNewInstance: TRttiCustomNewInstance; // mormot.core.json implemented\n    fAutoCreateInstances, // some lists made by RegisterAutoCreateFieldsClass\n    fAutoDestroyClasses,\n    fAutoCreateObjArrays,\n    fAutoResolveInterfaces: PRttiCustomPropDynArray;\n    // used by NoRttiSetAndRegister()\n    fNoRttiInfo: TByteDynArray;\n    // customize class process\n    fValueClass: TClass;\n    fObjArrayClass: TClass;\n    fCollectionItem: TCollectionItemClass;\n    fCollectionItemRtti: TRttiCustom;\n    fCopyObject: TRttiClassCopier;\n    procedure SetValueClass(aClass: TClass; aInfo: PRttiInfo); virtual;\n    // for TRttiCustomList.RegisterObjArray/RegisterBinaryType/RegisterFromText\n    function SetObjArray(Item: TClass): TRttiCustom;\n    function SetBinaryType(BinarySize: integer): TRttiCustom;\n    procedure SetPropsFromText(var P: PUtf8Char;\n      ExpectedEnd: TRttiCustomFromTextExpectedEnd; NoRegister: boolean);\n    // initialize from fProps, with no associated RTTI - and calls DoRegister()\n    // - will create a \"fake\" rkRecord/rkDynArray PRttiInfo (TypeName may be '')\n    procedure NoRttiSetAndRegister(ParserType: TRttiParserType;\n      const TypeName: RawUtf8; DynArrayElemType: TRttiCustom = nil;\n      NoRegister: boolean = false);\n    // called by ValueFinalize() for dynamic array defined from text\n    procedure NoRttiArrayFinalize(Data: PAnsiChar);\n    /// initialize this Value process for Parser and Parser Complex kinds\n    // - this default method will set Name and Flags according to Props[]\n    // - overriden in mormot.core.json for proper JSON process setup\n    // - returns self to allow cascaded calls as a fluent interface\n    function SetParserType(aParser: TRttiParserType;\n      aParserComplex: TRttiParserComplexType): TRttiCustom; virtual;\n  public\n    /// initialize the customizer class from known RTTI\n    // - is called just after Create\n    procedure FromRtti(aInfo: PRttiInfo); virtual;\n    /// initialize abstract custom serialization for a given record\n    // - not registered in the main TRttiCustomList: caller should free it\n    // - in practice, is used only by test.core.data.pas regression tests\n    constructor CreateFromText(const RttiDefinition: RawUtf8);\n    /// finalize this instance\n    destructor Destroy; override;\n    /// efficiently finalize a stored value of this type\n    // - if rcfObjArray is defined in Flags, will release all nested TObject\n    procedure ValueFinalize(Data: pointer);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// efficiently finalize a stored value of this type, and fill it with zeros\n    // - if rcfObjArray is defined in Flags, will release all nested TObject\n    procedure ValueFinalizeAndClear(Data: pointer);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// efficiently copy of a stored value of this type\n    // - same behavior as Dest := Source for all types\n    procedure ValueCopy(Dest, Source: pointer);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// return TRUE if the Value is 0 / nil / '' / null\n    // - less restrictive function than VarIsVoid() from mormot.core.variants\n    function ValueIsVoid(Data: PAnsiChar): boolean;\n     // {$ifdef HASINLINE}inline;{$endif}\n    /// compare two stored values of this type\n    // - not implemented in this class (raise an ERttiException)\n    // but in TRttiJson, so that it will use mormot.core.data comparison\n    function ValueCompare(Data, Other: pointer;\n      CaseInsensitive: boolean): integer; virtual;\n    /// fill a variant with a stored value of this type\n    // - not implemented in this class (raise an ERttiException)\n    // but in TRttiJson, so that it will use mormot.core.variants process\n    // - complex values can be returned as TDocVariant after JSON conversion,\n    // using e.g. @JSON_[mFast] as optional Options parameter\n    // - returns the size of the Data in bytes, i.e. Cache.ItemSize\n    function ValueToVariant(Data: pointer; out Dest: TVarData;\n      Options: pointer{PDocVariantOptions} = nil): PtrInt; virtual;\n    /// fill a value from random - including strings and nested types\n    procedure ValueRandom(Data: pointer);\n      {$ifdef HASINLINE}inline;{$endif}\n    /// TOnDynArrayHashOne callback used as fallback for unsupported items\n    // - here DefaultHasher() is always used over Size bytes\n    function ValueFullHash(const Elem): cardinal;\n    /// TOnDynArraySortCompare callback used as fallback for unsupported items\n    // - simple per-byte comparison over Size bytes\n    function ValueFullCompare(const A, B): integer;\n    /// how many iterations could be done one a given value\n    // - returns -1 if the value is not iterable, or length(DynArray) or\n    // TRawUtf8List.Count or TList.Count or TSynList.Count\n    // - implemented in TRttiJson for proper knowledge of TSynList/TRawUtf8List\n    function ValueIterateCount(Data: pointer): integer; virtual;\n    /// iterate over one sub-item of a given value\n    // - returns nil if the value is not iterable or Index is out of range\n    // - returns a pointer to the value, rkClass/rkLString kinds being already\n    // resolved (as the TList/TSynList/TRawUtf8List items are returned),\n    // so you can directly trans-type the result to TObject() or RawUtf8()\n    // - ResultRtti holds the type of the resolved result pointer\n    // - note that TStrings values are not supported, because they require a\n    // temporary string variable for their getter method\n    // - implemented in TRttiJson for proper knowledge of TSynList/TRawUtf8List\n    function ValueIterate(Data: pointer; Index: PtrUInt;\n      out ResultRtti: TRttiCustom): pointer; virtual;\n    /// lookup a value by a path name e.g. 'one.two.three' nested values\n    // - for a record/class, will search for a property name\n    // - for a TDocVariant/TBsonVariant, calls TSynInvokeableVariantType.IntGet\n    // - for an enumeration or set, will return true/false about the enum name\n    // - for a string, Data^ will be compared to the name\n    // - implemented in TRttiJson for proper knowledge of our variants\n    function ValueByPath(var Data: pointer; Path: PUtf8Char; var Temp: TVarData;\n      PathDelim: AnsiChar = '.'): TRttiCustom; virtual;\n    /// set a property value from a text value\n    // - handle all kind of fields, e.g. converting from text into ordinal or floats\n    function ValueSetText(Data: pointer; const Text: RawUtf8): boolean;\n    /// create a new TObject instance of this rkClass\n    // - not implemented here (raise an ERttiException) but in TRttiJson,\n    // so that mormot.core.rtti has no dependency to TSynPersistent and such\n    function ClassNewInstance: pointer;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// allow low-level customization of the fClassNewInstance pointer\n    procedure SetClassNewInstance(FactoryMethod: TRttiCustomNewInstance);\n    /// check if this type has ClassNewInstance information\n    function HasClassNewInstance: boolean;\n    /// reset all stored Props[] and associated flags\n    procedure PropsClear;\n    /// recursively search for 'one.two.three' nested properties\n    // - returns nil if not found\n    // - returns the property information and let Data point to its associated\n    // rkClass or rkRecord/rkObject owner\n    function PropFindByPath(var Data: pointer; FullName: PUtf8Char;\n      PathDelim: AnsiChar = '.'): PRttiCustomProp;\n    /// register once an instance of a given class per RTTI\n    // - thread-safe returns aObject, or an existing object (freeing aObject)\n    // - just like PrivateSlot property, but for as many class as needed\n    function SetPrivateSlot(aObject: TObject): pointer;\n    /// retrieve an instance of a given class per RTTI\n    // - previously registered by SetPrivateSlot\n    function GetPrivateSlot(aClass: TClass): pointer;\n    /// create a fake TRttiCustom clone with an overloaded ArrayRtti/ObjArrayClass\n    function ComputeFakeObjArrayRtti(aItemClass: TClass): TBytes;\n    /// low-level RTTI kind, taken from Rtti property\n    property Kind: TRttiKind\n      read fCache.Kind;\n    /// direct access to the low-level RTTI TypeInfo() pointer, from Rtti property\n    property Info: PRttiInfo\n      read fCache.Info;\n    /// the known type name\n    // - may be an hexadecimal value of self, if rcfWithoutRtti is in Flags\n    property Name: RawUtf8\n      read fName;\n    /// direct access to the low-level size in bytes used to store a value\n    // of this type, as taken from Rtti property\n    // - warning: for rkArray/rkDynArray, equals SizeOf(pointer), not the item\n    // size, which is hold in Cache.ItemSize\n    property Size: integer\n      read fCache.Size;\n    /// direct access to the ready-to-use RTTI\n    property Cache: TRttiCache\n      read fCache;\n    /// define specific behavior for this type\n    property Flags: TRttiCustomFlags\n      read fFlags write fFlags;\n    /// high-level Parser kind\n    property Parser: TRttiParserType\n      read fParser;\n    /// high-level Parser Complex kind\n    property ParserComplex: TRttiParserComplexType\n      read fParserComplex;\n    /// store information about the properties/fields of this type\n    // - only set for rkClass and rkRecord/rkObject\n    property Props: TRttiCustomProps\n      read fProps;\n    /// shortcut to the TRttiCustom of the item of a (dynamic) array\n    // - only set for rkArray and rkDynArray\n    // - may be set also for unmanaged types - use Cache.ItemInfo if you want\n    // the raw PRttiInfo TypeInfo() pointer for rkManagedTypes only\n    property ArrayRtti: TRttiCustom\n      read fArrayRtti;\n    /// best guess of first field type for a rkDynArray\n    // - equals ArrayRtti.Parser if ArrayRtti.Kind is not rkRecordTypes\n    property ArrayFirstField: TRttiParserType\n      read fArrayFirstField;\n    /// store the number of bytes for hexadecimal serialization for rcfBinary\n    // - used when rcfBinary is defined in Flags; equals 0 if disabled (default)\n    property BinarySize: integer\n      read fBinarySize;\n    /// store the class of this type, i.e. contains Cache.Info.RttiClass.RttiClass\n    property ValueClass: TClass\n      read fValueClass;\n    /// identify most common RTL inherited classes for special handling\n    // - recognize TCollection TStrings TObjectList TList parents\n    // - TRttiValueClass enumerate is faster than InheritsFrom() call\n    property ValueRtlClass: TRttiValueClass\n      read fValueRtlClass;\n    /// store the class of a T*ObjArray dynamic array\n    // - shortcut to ArrayRtti.Info.RttiClass.RttiClass\n    // - used when rcfObjArray is defined in Flags\n    property ObjArrayClass: TClass\n      read fObjArrayClass;\n    /// store the Item class for a given TCollection\n    // - as previously registered by Rtti.RegisterCollection()\n    property CollectionItem: TCollectionItemClass\n      read fCollectionItem;\n    /// opaque private instance used by mormot.orm.base.pas or mormot.core.log.pas\n    // - stores e.g. the TOrmProperties ORM information of a TOrm,\n    // or the TSynLogFamily of a TSynLog instance\n    // - is owned, as TObject, by this TRttiCustom\n    // - assignment is usually protected by the Rtti.RegisterSafe\n    property PrivateSlot: pointer\n      read fPrivateSlot write fPrivateSlot;\n    /// redirect to the low-level value copy - use rather ValueCopy()\n    property Copy: TRttiCopier\n      read fCopy;\n    /// redirect to the low-level class instance copy\n    // - nil by default, to use Props.CopyProperties()\n    // - is overwritten e.g. by TOrm.RttiCustomSetParser\n    property CopyObject: TRttiClassCopier\n      read fCopyObject write fCopyObject;\n    /// opaque TRttiJsonLoad callback used by mormot.core.json.pas\n    property JsonLoad: pointer\n      read fJsonLoad write fJsonLoad;\n    /// opaque TRttiJsonSave callback used by mormot.core.json.pas\n    property JsonSave: pointer\n      read fJsonSave write fJsonSave;\n    /// opaque TOnRttiJsonRead callback used by mormot.core.json.pas\n    property JsonReader: TMethod\n      read fJsonReader write fJsonReader;\n    /// opaque TOnRttiJsonWrite callback used by mormot.core.json.pas\n    property JsonWriter: TMethod\n      read fJsonWriter write fJsonWriter;\n  end;\n\n  PRttiCustom = ^TRttiCustom;\n\n  /// meta-class of TRttiCustom\n  // - is usually a TRttiJson class type once mormot.core.json.pas is linked\n  TRttiCustomClass = class of TRttiCustom;\n\n  /// efficient PRttiInfo/TRttiCustom pairs for TRttiCustomList hash table\n  // - as stored in TRttiCustomList.fHashTable[RK_TOSLOT[TRttiKind]]\n  // - contains hash tables by TypeInfo() and by case-insensitive name\n  TRttiCustomListPairs = record\n    /// efficient HashInfo/HashName[] pairs thread-safety during Find/AddToPairs\n    Safe: TRWLightLock;\n    /// speedup search by name e.g. from a loop\n    LastName: TRttiCustom;\n    /// thread-safe speedup search by PRttiInfo e.g. from a loop\n    LastInfo: TRttiCustom;\n    /// thread-safe speedup search by PRttiInfo e.g. from a loop\n    LastHash: array[0..RTTIHASH_MAX] of TRttiCustom;\n    /// CPU L1 cache efficient PRttiInfo/TRttiCustom pairs hashed by PRttiInfo\n    HashInfo: array[0..RTTIHASH_MAX] of TPointerDynArray;\n    /// CPU L1 cache efficient PRttiInfo/TRttiCustom pairs hashed by Name\n    HashName: array[0..RTTIHASH_MAX] of TPointerDynArray;\n  end;\n  PRttiCustomListPairs = ^TRttiCustomListPairs;\n\n  /// maintain a thread-safe list of PRttiInfo/TRttiCustom/TRttiJson registration\n  TRttiCustomList = class\n  private\n    // store PRttiInfo/TRttiCustom pairs by TRttiKind.Kind+PRttiInfo/Name\n    fHashTable: array of TRttiCustomListPairs;\n    // used to release memory used by registered customizations\n    fInstances: array of TRttiCustom;\n    fGlobalClass: TRttiCustomClass;\n    function GetByClass(ObjectClass: TClass): TRttiCustom;\n      {$ifdef HASINLINE}inline;{$endif}\n    // called by FindOrRegister() for proper inlining\n    function DoRegister(Info: PRttiInfo): TRttiCustom; overload;\n    function DoRegister(ObjectClass: TClass; ToDo: TRttiCustomFlags): TRttiCustom; overload;\n    procedure AddToPairs(Instance: TRttiCustom; Info: PRttiInfo);\n    procedure SetGlobalClass(RttiClass: TRttiCustomClass); // ensure Count=0\n  public\n    /// how many TRttiCustom instances have been registered\n    Count: integer;\n    /// a global lock shared for high-level RTTI registration process\n    // - is used e.g. to protect DoRegister() or TRttiCustom.PrivateSlot\n    // - should be a reentrant lock, even if seldom called\n    RegisterSafe: TOSLock;\n    /// how many TRttiCustom instances have been registered for a given type\n    // - we include rkUnknown for safety\n    Counts: array[TRttiKind] of integer;\n    /// initialize the RTTI list\n    constructor Create;\n    /// finalize the RTTI list\n    destructor Destroy; override;\n    /// efficient search of TRttiCustom from a given RTTI TypeInfo()\n    // - returns nil if Info is not known\n    // - call RegisterType() if you want to initialize the type via its RTTI\n    // - not inlined since less efficient code is generated\n    function FindType(Info: PRttiInfo): TRttiCustom;\n    /// efficient search of TRttiCustom from a given TObject class\n    // - returns nil if Info is not known\n    // - will use the ObjectClass vmtAutoTable slot for very fast O(1) lookup,\n    // or use our \"hash table of the poor\" (tm) if NOPATCHVMT conditional is set\n    {$ifdef NOPATCHVMT}\n    function FindClass(ObjectClass: TClass): TRttiCustom;\n      {$ifdef HASINLINE}inline;{$endif}\n    {$else}\n    class function FindClass(ObjectClass: TClass): TRttiCustom;\n      {$ifdef HASINLINE}static; inline;{$endif}\n    {$endif NOPATCHVMT}\n    /// efficient search of TRttiCustom from a given type name\n    function FindName(Name: PUtf8Char; NameLen: PtrInt;\n      Kind: TRttiKind): TRttiCustom; overload;\n    /// efficient search of TRttiCustom from a given type name\n    function FindName(Name: PUtf8Char; NameLen: PtrInt;\n      Kinds: TRttiKinds = []): TRttiCustom; overload;\n    /// efficient search of TRttiCustom from a given type name\n    function FindName(const Name: ShortString; Kinds: TRttiKinds = []): TRttiCustom;\n       overload; {$ifdef HASINLINE}inline;{$endif}\n    /// manual search of any matching TRttiCustom.ArrayRtti type\n    // - currently not called: IList<T> and IKeyValue<T> just use TypeInfo(T)\n    function FindByArrayRtti(ElemInfo: PRttiInfo): TRttiCustom;\n    /// register a given RTTI TypeInfo()\n    // - returns a new (or existing if it was already registered) TRttiCustom\n    // - if Info.Kind is rkDynArray, it will also register the nested rkRecord\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromTextSimpleType\n    function RegisterType(Info: PRttiInfo): TRttiCustom;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// register one or several RTTI TypeInfo()\n    // - to ensure that those types will be recognized by text definition\n    // - will just call RegisterType() for each Info[]\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromTextSimpleType\n    procedure RegisterTypes(const Info: array of PRttiInfo);\n    /// recognize (and register if needed) a standard simple type\n    // - calls Find() to return already registered TRttiCustom instance, and\n    // also recognize \"array\" or \"record\" keywords as expected by our parser\n    // - returns nil if nothing was found\n    // - will truncate any 'unitname.typename' into plain 'typename' before Find()\n    function RegisterTypeFromName(Name: PUtf8Char; NameLen: PtrInt;\n      ParserType: PRttiParserType = nil): TRttiCustom; overload;\n    /// recognize (and register if needed) a standard simple type\n    // - calls Find() to return already registered TRttiCustom instance, and\n    // also recognize \"array\" or \"record\" keywords as expected by our parser\n    // - returns nil if nothing was found\n    // - will truncate any 'unitname.typename' into plain 'typename' before Find()\n    function RegisterTypeFromName(const Name: RawUtf8;\n      ParserType: PRttiParserType = nil): TRttiCustom; overload;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// register a given class type, using its RTTI\n    // - returns existing or new TRttiCustom\n    // - please call RegisterCollection for TCollection\n    function RegisterClass(ObjectClass: TClass): TRttiCustom; overload;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// register a given class type, using its RTTI\n    // - returns existing or new TRttiCustom\n    // - please call RegisterCollection for TCollection\n    function RegisterClass(aObject: TObject): TRttiCustom; overload;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// low-level registration function called from RegisterClass()\n    // - is sometimes called after manual vmtAutoTable slot lookup\n    function DoRegister(ObjectClass: TClass): TRttiCustom; overload;\n    /// register a given class type, using its RTTI, to auto-create/free its\n    // class and dynamic array published fields\n    function RegisterAutoCreateFieldsClass(ObjectClass: TClass): TRttiCustom;\n      {$ifdef HASINLINE}inline;{$endif}\n    /// register one or several RTTI TypeInfo()\n    // - to ensure that those classes will be recognized by text definition\n    // - will just call RegisterClass() for each ObjectClass[]\n    procedure RegisterClasses(const ObjectClass: array of TClass);\n    /// define how a given TCollectionClass should instantiate its items\n    // - we need to know the CollectionItem to propertly initialize a TCollection\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your collection definition unit\n    function RegisterCollection(Collection: TCollectionClass;\n      CollectionItem: TCollectionItemClass): TRttiCustom;\n    /// register some TypeInfo() containing unsafe parameter values\n    // - i.e. any RTTI type containing Sensitive Personal Information, e.g.\n    // a bank card number or a plain password\n    // - such values will force associated values to be ignored during loging,\n    // as a more tuned alternative to optNoLogInput or optNoLogOutput\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your types definition unit\n    procedure RegisterUnsafeSpiType(const Types: array of PRttiInfo);\n    /// register one RTTI TypeInfo() to be serialized as hexadecimal\n    // - data will be serialized as BinToHexDisplayLower() JSON hexadecimal\n    // string, using BinarySize bytes of the value, i.e. BinarySize*2 hexa chars\n    // - you can truncate the original data size (e.g. if all bits of an integer\n    // are not used) by specifying the aFieldSize optional parameter\n    // - will also ensure that those types will be recognized by text definition\n    // - leave BinarySize=0 to write all bytes as hexadecimal\n    // - set BinarySize=-1 to unregister the binary serialization for the type\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your types definition unit\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromTextBinaryType\n    function RegisterBinaryType(Info: PRttiInfo; BinarySize: integer = 0): TRttiCustom;\n    /// register one or several RTTI TypeInfo() to be serialized as hexadecimal\n    // - TypeInfo() and associated size information will here be defined by pairs:\n    // ([TypeInfo(TType1),TYPE1_BYTES,TypeInfo(TType2),TYPE2_BYTES])\n    // - a wrapper around the RegisterBinaryType() method\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your types definition unit\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromTextBinaryType\n    procedure RegisterBinaryTypes(const InfoBinarySize: array of const);\n    /// register one dynamic array RTTI TypeInfo() to be serialized as T*ObjArray\n    // - not needed on FPC and Delphi 2010+ since \"array of TSomeClass\" will be\n    // recognized directly - see HASDYNARRAYTYPE conditional\n    // - allow JSON serialization and unserialization of the registered dynamic\n    // array property defined in any TPersistent or TOrm for oldest Delphi\n    // - could be used as such (note the T*ObjArray type naming convention):\n    // ! TUserObjArray = array of TUser;\n    // ! ...\n    // ! Rtti.RegisterObjArray(TypeInfo(TUserObjArray), TUser);\n    // - then you can use ObjArrayAdd/ObjArrayFind/ObjArrayDelete to manage\n    // the stored items, and never forget to call ObjArrayClear to release\n    // the memory\n    // - set Item=nil to unregister the type as a T*ObjArray - may be needed\n    // to bypass the FPC and Delphi 2010+ automatic recognition\n    // - may return nil if DynArray is not a rkDynArray\n    // - replace deprecated TJsonSerializer.RegisterObjArrayForJson() method\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your T*ObjArray definition unit\n    function RegisterObjArray(DynArray: PRttiInfo; Item: TClass): TRttiCustom;\n    /// register one or several dynamic array RTTI TypeInfo() to be serialized\n    // as T*ObjArray\n    // - not needed on FPC and Delphi 2010+ since \"array of TSomeClass\" will be\n    // recognized directly - see HASDYNARRAYTYPE conditional\n    // - will call the RegisterObjArray() class method by pair:\n    // ! Rtti.RegisterObjArrays([\n    // !   TypeInfo(TAddressObjArray), TAddress,\n    // !   TypeInfo(TUserObjArray), TUser]);\n    // - not thread-safe: should be called once from the main thread, at startup,\n    // e.g. in the initialization section of your T*ObjArray definition unit\n    procedure RegisterObjArrays(const DynArrayItem: array of const);\n    /// register TypeInfo() custom serialization for a given dynamic array or record\n    // - DynArrayOrRecord should be valid TypeInfo() - use overloaded\n    // RegisterFromText(TypeName) if the record has no TypeInfo()\n    // - the RTTI information will here be defined as plain text\n    // - since Delphi 2010, you can call directly RegisterType()\n    // - the record where the data will be stored should be defined as PACKED:\n    // ! type TMyRecord = packed record\n    // !   A,B,C: integer;\n    // !   D: RawUtf8;\n    // !   E: record; // or array of record/integer/string/...\n    // !     E1,E2: double;\n    // !   end;\n    // ! end;\n    // - call this method with RttiDefinition='' to return back to the default\n    // serialization, i.e. binary + Base64 or Delphi 2010+ extended RTTI\n    // - RTTI textual information shall be supplied as text, with the\n    // same format as any pascal record:\n    // ! 'A,B,C: integer; D: RawUtf8; E: record E1,E2: double;'\n    // ! 'A,B,C: integer; D: RawUtf8; E: array of record E1,E2: double;'\n    // ! 'A,B,C: integer; D: RawUtf8; E: array of SynUnicode; F: array of TGuid'\n    // or a shorter alternative syntax for records and arrays:\n    // ! 'A,B,C: integer; D: RawUtf8; E: {E1,E2: double}'\n    // ! 'A,B,C: integer; D: RawUtf8; E: [E1,E2: double]'\n    // in fact ; could be ignored:\n    // ! 'A,B,C:integer D:RawUtf8 E:{E1,E2:double}'\n    // ! 'A,B,C:integer D:RawUtf8 E:[E1,E2:double]'\n    // or even : could be ignored:\n    // ! 'A,B,C integer D RawUtf8 E{E1,E2 double}'\n    // ! 'A,B,C integer D RawUtf8 E[E1,E2 double]'\n    // - it will return the cached TRttiCustom instance corresponding to the\n    // supplied RTTI text definition - i.e. the rkRecord if TypeInfo(SomeArray)\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromText()\n    function RegisterFromText(DynArrayOrRecord: PRttiInfo;\n      const RttiDefinition: RawUtf8): TRttiCustom; overload;\n    /// define a custom serialization for several dynamic arrays or records\n    // - the TypeInfo() and textual RTTI information will here be defined as\n    // ([TypeInfo(TType1),_TType1, TypeInfo(TType2),_TType2]) pairs\n    // - a wrapper around the overloaded RegisterFromText() method\n    // - match mORMot 1.18 TTextWriter.RegisterCustomJSONSerializerFromText()\n    procedure RegisterFromText(\n      const TypeInfoTextDefinitionPairs: array of const); overload;\n    /// register by name a custom serialization for a given dynamic array or record\n    // - use overloaded RegisterFromText(TypeName) if the record has TypeInfo()\n    // - the RTTI information will here be defined as plain text\n    function RegisterFromText(const TypeName: RawUtf8;\n      const RttiDefinition: RawUtf8): TRttiCustom; overload;\n    /// default property to access a given RTTI TypeInfo() customization\n    // - you can access or register one type by using this default property:\n    // ! Rtti[TypeInfo(TMyClass)].Props.NameChange('old', 'new')\n    property ByTypeInfo[P: PRttiInfo]: TRttiCustom\n      read RegisterType; default;\n    /// default property to access a given RTTI customization of a class\n    // - you can access or register one type by using this default property:\n    // ! Rtti.ByClass[TMyClass].Props.NameChanges(['old', 'new'])\n    property ByClass[C: TClass]: TRttiCustom\n      read GetByClass;\n    /// which kind of TRttiCustom class is to be used for registration\n    // - properly set e.g. by mormot.core.json.pas to TRttiJson for JSON support\n    property GlobalClass: TRttiCustomClass\n      read fGlobalClass write SetGlobalClass;\n  end;\n\n\n/// low-level internal function use when inlining TRttiCustomProps.Find()\n// - caller should ensure that namelen <> 0\nfunction FindCustomProp(p: PRttiCustomProp; name: pointer; namelen: TStrLen;\n  count: integer): PRttiCustomProp;\n\n/// low-level internal function used e.g. by TRttiCustom.GetPrivateSlot()\n// - caller should ensure that slot <> nil\nfunction FindPrivateSlot(c: TClass; slot: PPointer): pointer;\n\n/// retrieve a (possibly nested) class property RTTI and instance by path\n// - as used e.g. by GetValueObject/SetValueObject wrapper functions\nfunction GetInstanceByPath(var Instance: TObject; const Path: RawUtf8;\n  out Prop: PRttiCustomProp; PathDelim: AnsiChar = '.'): boolean;\n\nvar\n  /// low-level access to the list of registered PRttiInfo/TRttiCustom/TRttiJson\n  Rtti: TRttiCustomList;\n\n  /// direct lookup to the TRttiCustom of TRttiParserType values\n  PT_RTTI: array[TRttiParserType] of TRttiCustom;\n\n  /// direct lookup to the TRttiCustom of TRttiParserComplexType values\n  PTC_RTTI: array[TRttiParserComplexType] of TRttiCustom;\n\n\n{ *********** High Level TObjectWithID and TObjectWithCustomCreate Class Types }\n\ntype\n  {$M+}\n  /// abstract parent class with published properties and a virtual constructor\n  // - is the parent of both TSynPersistent and TOrm classes\n  // - will ensure the class type is registered to the Rtti global list\n  // - also features some protected virtual methods for custom RTTI/JSON process\n  TObjectWithCustomCreate = class(TObject)\n  protected\n    /// called by TRttiJson.SetParserType when this class is registered\n    // - used e.g. to register TOrm.ID field which is not published as RTTI\n    // - in TSynPersistent descendants, can change the Rtti.JsonSave callback\n    // if needed, or e.g. set rcfHookWrite flag to call RttiBeforeWriteObject\n    // and RttiAfterWriteObject, rcfHookWriteProperty for RttiWritePropertyValue\n    // and/or rcfHookRead for RttiBeforeReadObject or RttiAfterReadObject methods\n    // (disabled by default not to slow down the serialization process)\n    class procedure RttiCustomSetParser(Rtti: TRttiCustom); virtual;\n    // called before TJsonWriter.WriteObject() serialize this instance as JSON\n    // - triggered if RttiCustomSetParser defined the rcfHookWrite flag\n    // - you can return true if your method made the serialization\n    // - this default implementation just returns false, to continue serializing\n    // - TSynMonitor will change the serialization Options for this instance\n    function RttiBeforeWriteObject(W: TTextWriter;\n      var Options: TTextWriterWriteObjectOptions): boolean; virtual;\n    // called by TJsonWriter.WriteObject() to serialize one published property value\n    // - triggered if RttiCustomSetParser defined the rcfHookWriteProperty flag\n    // - is e.g. overriden in TOrm/TOrmMany to detect \"fake\" instances\n    // - should return true if a property has been written, false (which is the\n    // default) if the property is to be serialized as usual\n    function RttiWritePropertyValue(W: TTextWriter; Prop: PRttiCustomProp;\n      Options: TTextWriterWriteObjectOptions): boolean; virtual;\n    /// called after TJsonWriter.WriteObject() serialized this instance as JSON\n    // - triggered if RttiCustomSetParser defined the rcfHookWrite flag\n    // - execute just before W.BlockEnd('}')\n    procedure RttiAfterWriteObject(W: TTextWriter;\n      Options: TTextWriterWriteObjectOptions); virtual;\n    /// called to unserialize this instance from JSON\n    // - triggered if RttiCustomSetParser defined the rcfHookRead flag\n    // - you can return true if your method made the instance unserialization\n    // - this default implementation just returns false, to continue processing\n    // - opaque Ctxt is a PJsonParserContext instance\n    function RttiBeforeReadObject(Ctxt: pointer): boolean; virtual;\n    /// called to unserialize of property of this instance from JSON\n    // - triggered if RttiCustomSetParser defined the rcfHookReadProperty flag\n    // - you can return true if your method made the property unserialization\n    // - this default implementation just returns false, to continue processing\n    // - opaque Ctxt is a PJsonParserContext instance\n    function RttiBeforeReadPropertyValue(Ctxt: pointer;\n      Prop: PRttiCustomProp): boolean; virtual;\n    /// called after this instance has been unserialized from JSON\n    // - triggered if RttiCustomSetParser defined the rcfHookRead flag\n    procedure RttiAfterReadObject; virtual;\n  public\n    /// virtual constructor called at instance creation\n    // - is declared as virtual so that inherited classes may have a root\n    // constructor to override\n    // - is recognized by our RTTI serialization/initialization process\n    constructor Create; virtual;\n    /// optimized initialization code\n    // - will also register the class type to the Rtti global list\n    // - somewhat faster than the regular RTL implementation\n    // - warning: this optimized version won't initialize the vmtIntfTable\n    // for this class hierarchy: as a result, you would NOT be able to\n    // implement an interface with a TSynPersistent descendent (but you should\n    // not need to, but inherit from TInterfacedObject)\n    // - warning: under FPC, it won't initialize fields management operators\n    class function NewInstance: TObject; override;\n    /// very efficiently retrieve the TRttiCustom associated with this class\n    // - since Create did register it, just return the first vmtAutoTable slot\n    class function RttiCustom: TRttiCustom;\n      {$ifdef HASINLINE}inline;{$endif}\n  end;\n  {$M-}\n\n  /// used to determine the exact class type of a TObjectWithCustomCreate\n  // - allow to create instances using its virtual constructor\n  TObjectWithCustomCreateClass = class of TObjectWithCustomCreate;\n\n  /// root class of an object with a 64-bit ID primary key\n  // - is the parent of mormot.orm.core's TOrm, but you could use it e.g. on\n  // client side to avoid a dependency to all ORM process, but still have the\n  // proper published fields and use it in SOA - with a single conditional over\n  // your class definition to inherit either from TOrm or from TObjectWithID\n  TObjectWithID = class(TObjectWithCustomCreate)\n  protected\n    fID: TID;\n    /// will register the \"ID\":... field value for proper JSON serialization\n    class procedure RttiCustomSetParser(Rtti: TRttiCustom); override;\n  public\n    /// this constructor initializes the instance with a given ID\n    constructor CreateWithID(aID: TID);\n    /// this property gives direct access to the class instance ID\n    // - not defined as \"published\" since RttiCustomSetParser did register it\n    property IDValue: TID\n      read fID write fID;\n  end;\n\n  /// used to determine the exact class type of a TObjectWithID\n  TObjectWithIDClass = class of TObjectWithID;\n\n/// internal wrapper to protected TObjectWithCustomCreate.RttiCustomSetParser()\n// - a local TCCHook was reported to have issues on FPC with class methods\nprocedure TObjectWithCustomCreateRttiCustomSetParser(\n  O: TObjectWithCustomCreateClass; Rtti: TRttiCustom);\n\n/// TDynArraySortCompare compatible function, sorting by TObjectWithID/TOrm.ID\nfunction TObjectWithIDDynArrayCompare(const Item1, Item2): integer;\n\n/// TDynArrayHashOne compatible function, hashing TObjectWithID/TOrm.ID\nfunction TObjectWithIDDynArrayHashOne(const Elem; Hasher: THasher): cardinal;\n\n\n\nimplementation\n\n\n{ some inlined definitions which should be declared before $include code }\n\ntype\n  // local wrapper to retrieve IInvokable Interface RTTI via GetRttiInterface()\n  TGetRttiInterface = class\n  public\n    Level: integer;\n    MethodCount, ArgCount: integer;\n    CurrentMethod: PRttiMethod;\n    Definition: TRttiInterface;\n    procedure AddMethod(const aMethodName: ShortString; aParamCount: integer;\n      aKind: TMethodKind);\n    procedure AddArgument(aParamName, aTypeName: PShortString; aInfo: PRttiInfo;\n      aFlags: TParamFlags);\n    procedure RaiseError(const Format: RawUtf8; const Args: array of const);\n    // this method will be implemented in mormot.core.rtti.fpc/delphi.inc\n    procedure AddMethodsFromTypeInfo(aInterface: PTypeInfo);\n  end;\n\n{$ifdef FPC}\n  {$include mormot.core.rtti.fpc.inc}      // FPC specific RTTI access\n{$else}\n  {$include mormot.core.rtti.delphi.inc}   // Delphi specific RTTI access\n{$endif FPC}\n\n\n{ ************* Low-Level Cross-Compiler RTTI Definitions }\n\n{ TRttiClass }\n\nfunction TRttiClass.RttiClass: TClass;\nbegin\n  result := PTypeData(@self)^.ClassType;\nend;\n\nfunction TRttiClass.UnitName: PShortString;\nbegin\n  result := @PTypeData(@self)^.UnitName;\nend;\n\nfunction _ClassUnit(C: TClass): PShortString;\nvar\n  P: PRttiInfo;\nbegin\n  P := PPointer(PAnsiChar(C) + vmtTypeInfo)^;\n  if P <> nil then\n    result := P^.RttiNonVoidClass^.UnitName\n  else\n    result := @NULCHAR;\nend;\n\nfunction TRttiClass.InheritsFrom(AClass: TClass): boolean;\nvar\n  P: PRttiInfo;\nbegin\n  result := true;\n  if RttiClass = AClass then\n    exit;\n  P := ParentInfo;\n  while P <> nil do\n    with P^.RttiNonVoidClass^ do\n      if RttiClass = AClass then\n        exit\n      else\n        P := ParentInfo;\n  result := false;\nend;\n\n\n{ TRttiProp }\n\nfunction TRttiProp.Name: PShortString;\nbegin\n  result := @PPropInfo(@self)^.Name;\nend;\n\nfunction TRttiProp.NameUtf8: RawUtf8;\nbegin\n  ShortStringToAnsi7String(PPropInfo(@self)^.Name, result);\nend;\n\nfunction TRttiProp.Next: PRttiProp;\nbegin\n  // this abstract code compiles into 2 asm lines under FPC :)\n  with PPropInfo(@self)^ do\n    result := AlignToPtr(@PByteArray(@self)[\n      (PtrUInt(@PPropInfo(nil).Name) + SizeOf(Name[0])) + Length(Name)]);\nend;\n\n\n{ TRttiProps = TPropData in TypInfo }\n\nfunction TRttiProps.FieldProp(const PropName: ShortString): PRttiProp;\nvar\n  i: integer;\nbegin\n  if @self<>nil then\n  begin\n    result := PropList;\n    for i := 1 to PropCount do\n      if PropNameEquals(result^.Name, @PropName) then\n        exit\n      else\n        result := result^.Next;\n  end;\n  result := nil;\nend;\n\n\n{ TRttiEnumType }\n\nfunction TRttiEnumType.RttiOrd: TRttiOrd;\nbegin\n  result := TRttiOrd(PTypeData(@self)^.OrdType);\nend;\n\nfunction TRttiEnumType.MinValue: PtrInt;\nbegin\n  result := PTypeData(@self).MinValue;\nend;\n\nfunction TRttiEnumType.MaxValue: PtrInt;\nbegin\n  result := PTypeData(@self).MaxValue;\nend;\n\nfunction TRttiEnumType.NameList: PShortString;\nbegin\n  result := @PTypeData(@self).NameList;\nend;\n\nfunction TRttiEnumType.SizeInStorageAsEnum: integer;\nbegin\n  if @self = nil then\n    result := 0\n  else\n    result := ORDTYPE_SIZE[RttiOrd]; // MaxValue is wrong e.g. with WordBool\nend;\n\nfunction TRttiEnumType.SizeInStorageAsSet: integer;\nbegin\n  if @self <> nil then\n  begin\n    result := MaxValue;\n    if result < 8 then\n      result := SizeOf(byte)\n    else if result < 16 then\n      result := SizeOf(word)\n    else if result < 32 then\n      result := SizeOf(cardinal)\n    else if result < 64 then\n      result := SizeOf(QWord)\n    else\n      result := 0;\n  end\n  else\n    result := 0;\nend;\n\nfunction TRttiEnumType.GetEnumName(const Value): PShortString;\nbegin\n  if @Value = nil then\n    result := @NULCHAR\n  else\n    result := GetEnumNameOrd(RTTI_FROM_ORD[RttiOrd](@Value));\nend;\n\nfunction TRttiEnumType.GetCaption(const Value): string;\nbegin\n  GetCaptionFromTrimmed(GetEnumNameOrd(RTTI_FROM_ORD[RttiOrd](@Value)), result);\nend;\n\nprocedure TRttiEnumType.AddCaptionStrings(Strings: TStrings;\n  UsedValuesBits: Pointer);\nvar\n  i, L: PtrInt;\n  Line: array[byte] of AnsiChar;\n  P: PAnsiChar;\n  V: PShortString;\n  s: string;\nbegin\n  if @self = nil then\n    exit;\n  Strings.BeginUpdate;\n  try\n    V := NameList;\n    for i := MinValue to MaxValue do\n    begin\n      if (UsedValuesBits = nil) or\n         GetBitPtr(UsedValuesBits, i) then\n      begin\n        L := ord(V^[0]);\n        P := @V^[1];\n        while (L > 0) and\n              (P^ in ['a'..'z']) do\n        begin\n          // ignore left lowercase chars\n          inc(P);\n          dec(L);\n        end;\n        if L = 0 then\n        begin\n          L := ord(V^[0]);\n          P := @V^[1];\n        end;\n        Line[L] := #0; // GetCaptionFromPCharLen() expect it as ASCIIZ\n        MoveFast(P^, Line, L);\n        GetCaptionFromPCharLen(Line, s);\n        Strings.AddObject(s, pointer(i));\n      end;\n      inc(PByte(V), length(V^)+1);\n    end;\n  finally\n    Strings.EndUpdate;\n  end;\nend;\n\nfunction TRttiEnumType.GetCaptionStrings(UsedValuesBits: pointer): string;\nvar\n  List: TStringList;\nbegin\n  List := TStringList.Create;\n  try\n    AddCaptionStrings(List, UsedValuesBits);\n    result := List.Text;\n  finally\n    List.Free;\n  end;\nend;\n\nprocedure TRttiEnumType.GetEnumNameAll(var result: TRawUtf8DynArray;\n  TrimLeftLowerCase: boolean);\nvar\n  max, i: PtrInt;\n  V: PShortString;\nbegin\n  Finalize(result);\n  max := MaxValue - MinValue;\n  SetLength(result, max + 1);\n  V := NameList;\n  for i := 0 to max do\n  begin\n    if TrimLeftLowerCase then\n      result[i] := TrimLeftLowerCaseShort(V)\n    else\n      ShortStringToAnsi7String(V^, result[i]);\n    inc(PByte(V), length(V^) + 1);\n  end;\nend;\n\nprocedure TRttiEnumType.GetEnumNameAll(out result: RawUtf8; const Prefix: RawUtf8;\n  quotedValues: boolean; const Suffix: RawUtf8; trimedValues, unCamelCased: boolean);\nvar\n  i: integer;\n  V: PShortString;\n  uncamel: ShortString;\n  temp: TTextWriterStackBuffer;\nbegin\n  with TTextWriter.CreateOwnedStream(temp) do\n  try\n    AddString(Prefix);\n    V := NameList;\n    for i := MinValue to MaxValue do\n    begin\n      if quotedValues then\n        AddDirect('\"');\n      if unCamelCased then\n      begin\n        TrimLeftLowerCaseToShort(V, uncamel);\n        AddShort(uncamel);\n      end\n      else if trimedValues then\n        AddTrimLeftLowerCase(V)\n      else\n        AddShort(V^);\n      if quotedValues then\n        AddDirect('\"');\n      AddComma;\n      inc(PByte(V), length(V^) + 1);\n    end;\n    CancelLastComma;\n    AddString(Suffix);\n    SetText(result);\n  finally\n    Free;\n  end;\nend;\n\nprocedure TRttiEnumType.GetEnumNameTrimedAll(var result: RawUtf8;\n  const Prefix: RawUtf8; quotedValues: boolean; const Suffix: RawUtf8);\nbegin\n  GetEnumNameAll(result, Prefix, quotedValues, Suffix, {trimed=}true);\nend;\n\nfunction TRttiEnumType.GetEnumNameAllAsJsonArray(TrimLeftLowerCase: boolean;\n  UnCamelCased: boolean): RawUtf8;\nbegin\n  GetEnumNameAll(result, '[', {quoted=}true, ']', TrimLeftLowerCase, UnCamelCased);\nend;\n\nfunction TRttiEnumType.GetEnumNameValue(const EnumName: ShortString): integer;\nbegin\n  result := GetEnumNameValue(@EnumName[1], ord(EnumName[0]));\nend;\n\nfunction TRttiEnumType.GetEnumNameValue(Value: PUtf8Char): integer;\nbegin\n  result := GetEnumNameValue(Value, StrLen(Value));\nend;\n\nfunction TRttiEnumType.GetEnumNameValue(Value: PUtf8Char; ValueLen: integer;\n  AlsoTrimLowerCase: boolean): integer;\nbegin\n  if (Value <> nil) and\n     (ValueLen > 0) and\n     (MinValue = 0) then\n  begin\n    result := FindShortStringListExact(NameList, MaxValue, Value, ValueLen);\n    if (result < 0) and\n       AlsoTrimLowerCase then\n      result := FindShortStringListTrimLowerCase(NameList, MaxValue, Value, ValueLen);\n  end\n  else\n    result := -1;\nend;\n\nfunction TRttiEnumType.GetEnumNameValueTrimmed(Value: PUtf8Char; ValueLen: integer;\n  CaseSensitive: boolean): integer;\nbegin\n  if (Value <> nil) and\n     (ValueLen > 0) and\n     (MinValue = 0) then\n    if CaseSensitive then\n      result := FindShortStringListTrimLowerCaseExact(NameList, MaxValue, Value, ValueLen)\n    else\n      result := FindShortStringListTrimLowerCase(NameList, MaxValue, Value, ValueLen)\n  else\n    result := -1;\nend;\n\nfunction TRttiEnumType.GetEnumNameTrimed(const Value): RawUtf8;\nbegin\n  result := TrimLeftLowerCaseShort(GetEnumName(Value));\nend;\n\nfunction TRttiEnumType.GetSetName(const value; trimmed: boolean;\n  const sep: RawUtf8): RawUtf8;\nvar\n  j: PtrInt;\n  PS, v: PShortString;\n  tmp: shortstring;\nbegin\n  result := '';\n  if (@self = nil) or\n     (@value = nil) then\n    exit;\n  PS := NameList;\n  for j := MinValue to MaxValue do\n  begin\n    if GetBitPtr(@value, j) then\n    begin\n      v := @tmp;\n      if trimmed then\n        TrimLeftLowerCaseToShort(PS, tmp)\n      else\n        v := PS;\n      Append(result, [v^, sep]);\n    end;\n    inc(PByte(PS), PByte(PS)^ + 1); // next\n  end;\n  if result <> '' then\n    FakeLength(result, length(result) - length(sep)); // trim last separator\nend;\n\nprocedure TRttiEnumType.GetSetNameJsonArray(W: TTextWriter; Value: cardinal;\n  SepChar, QuoteChar: AnsiChar; FullSetsAsStar, ForceTrim: boolean);\nvar\n  j, max: PtrInt;\n  PS: PShortString;\nbegin\n  W.Add('[');\n  if FullSetsAsStar and\n     (MinValue = 0) and\n     GetAllBits(Value, MaxValue + 1) then\n    W.AddShorter('\"*\"')\n  else\n  begin\n    PS := NameList;\n    if twoTrimLeftEnumSets in W.CustomOptions then\n      ForceTrim := true;\n    max := MaxValue;\n    if max >= 32 then\n      max := 31; // avoid buffer overflow on 32-bit cardinal Value\n    for j := MinValue to max do\n    begin\n      if GetBitPtr(@Value, j) then\n      begin\n        if QuoteChar <> #0 then\n          W.Add(QuoteChar);\n        if ForceTrim then\n          W.AddTrimLeftLowerCase(PS)\n        else\n          W.AddShort(PS^);\n        if QuoteChar <> #0 then\n          W.AddDirect(QuoteChar);\n        W.AddDirect(SepChar);\n      end;\n      inc(PByte(PS), ord(PS^[0]) + 1); // next item\n    end;\n  end;\n  W.CancelLastComma(']');\nend;\n\nfunction TRttiEnumType.GetSetNameJsonArray(Value: cardinal; SepChar: AnsiChar;\n  FullSetsAsStar: boolean): RawUtf8;\nvar\n  W: TTextWriter;\n  temp: TTextWriterStackBuffer;\nbegin\n  W := TTextWriter.CreateOwnedStream(temp);\n  try\n    GetSetNameJsonArray(W, Value, SepChar, '\"', FullSetsAsStar, {forcetrim=}false);\n    W.SetText(result);\n  finally\n    W.Free;\n  end;\nend;\n\nfunction TRttiEnumType.GetEnumNameTrimedValue(const EnumName: ShortString): integer;\nbegin\n  result := GetEnumNameTrimedValue(@EnumName[1], ord(EnumName[0]));\nend;\n\nfunction TRttiEnumType.GetEnumNameTrimedValue(Value: PUtf8Char; ValueLen: integer): integer;\nbegin\n  if (Value = nil) or\n     (MinValue <> 0) then\n    result := -1\n  else\n  begin\n    if ValueLen = 0 then\n      ValueLen := StrLen(Value);\n    result := FindShortStringListTrimLowerCase(NameList, MaxValue, Value, ValueLen);\n    if result < 0 then\n      result := FindShortStringListExact(NameList, MaxValue, Value, ValueLen);\n  end;\nend;\n\nprocedure TRttiEnumType.SetEnumFromOrdinal(out Value; Ordinal: PtrUInt);\nbegin\n  RTTI_TO_ORD[RttiOrd](@Value, Ordinal);\nend;\n\n\n\n{ TRttiInterfaceTypeData }\n\nfunction TRttiInterfaceTypeData.IntfFlags: TRttiIntfFlags;\nbegin\n  result := TRttiIntfFlags(PTypeData(@self)^.IntfFlags);\nend;\n\nfunction TRttiInterfaceTypeData.IntfUnit: PShortString;\nbegin\n  result := @PTypeData(@self)^.IntfUnit;\nend;\n\n\n{ TRttiInfo }\n\nprocedure TRttiInfo.Clear(Data: pointer);\nvar\n  fin: TRttiFinalizer;\nbegin\n  fin := RTTI_FINALIZE[Kind];\n  if Assigned(fin) then\n    fin(Data, @self);\nend;\n\nprocedure TRttiInfo.Copy(Dest, Source: pointer);\nvar\n  cop: TRttiCopier;\nbegin\n  cop := RTTI_MANAGEDCOPY[Kind];\n  if Assigned(cop) then\n    cop(Dest, Source, @self);\nend;\n\nfunction TRttiInfo.RttiOrd: TRttiOrd;\nbegin\n  result := TRttiOrd(GetTypeData(@self)^.OrdType);\nend;\n\nfunction TRttiInfo.IsCurrency: boolean;\nbegin\n  result := TRttiFloat(GetTypeData(@self)^.FloatType) = rfCurr;\nend;\n\nfunction TRttiInfo.IsDate: boolean;\nbegin\n  result := (@self = TypeInfo(TDate)) or\n            (@self = TypeInfo(TDateTime)) or\n            (@self = TypeInfo(TDateTimeMS));\nend;\n\nfunction TRttiInfo.IsRawBlob: boolean;\nbegin\n  result := @self = TypeInfo(RawBlob);\nend;\n\nfunction TRttiInfo.RttiFloat: TRttiFloat;\nbegin\n  result := TRttiFloat(GetTypeData(@self)^.FloatType);\nend;\n\n{$ifndef ISFPC32}\nfunction TRttiInfo.SetEnumSize: PtrInt;\nbegin\n  result := SetEnumType^.SizeInStorageAsSet;\nend;\n{$endif ISFPC32}\n\nfunction TRttiInfo.DynArrayItemSize: PtrInt;\nbegin\n  DynArrayItemType(result); // fast enough (not used internally)\nend;\n\nfunction TRttiInfo.RttiSize: PtrInt;\nbegin\n  case Kind of\n    {$ifdef FPC}\n    rkBool,\n    rkUChar,\n    {$endif FPC}\n    rkInteger,\n    rkEnumeration,\n    rkChar,\n    rkWChar:\n      result := ORDTYPE_SIZE[TRttiOrd(GetTypeData(@self)^.OrdType)];\n    rkSet:\n      result := SetEnumSize;\n    rkFloat:\n      result := FLOATTYPE_SIZE[TRttiFloat(GetTypeData(@self)^.FloatType)];\n    rkLString,\n    {$ifdef FPC}\n    rkLStringOld,\n    rkInterfaceRaw,\n    {$endif FPC}\n    {$ifdef HASVARUSTRING}\n    rkUString,\n    {$endif HASVARUSTRING}\n    {$ifdef FPC_OR_UNICODE}\n    rkClassRef,\n    rkPointer,\n    {$endif FPC_OR_UNICODE}\n    rkWString,\n    rkClass,\n    rkInterface,\n    rkDynArray:\n      result := SizeOf(pointer);\n    {$ifdef FPC}\n    rkQWord,\n    {$endif FPC}\n    rkInt64:\n      result := 8;\n    rkVariant:\n      result := SizeOf(variant);\n    rkArray:\n      result := ArraySize;\n    {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n    rkRecord:\n      result := RecordSize;\n    rkSString:\n      result := GetTypeData(@self)^.MaxLength + 1;\n  else\n    result := 0;\n  end;\nend;\n\nfunction TRttiInfo.IsManaged: boolean;\nbegin\n  if Kind in rkRecordTypes then\n    result := RecordManagedFieldsCount > 0\n  else\n    result := Kind in rkManagedTypes;\n  // note: rkArray should be handled specificically: we return true here by now\nend;\n\nfunction TRttiInfo.ClassFieldCount(onlyWithoutGetter: boolean): integer;\nbegin\n  result := ClassFieldCountWithParents(RttiClass^.RttiClass, onlyWithoutGetter);\nend;\n\nfunction TRttiInfo.InheritsFrom(AClass: TClass): boolean;\nbegin\n  result := RttiNonVoidClass^.InheritsFrom(AClass);\nend;\n\nfunction TRttiInfo.EnumBaseType(out NameList: PShortString;\n  out Min, Max: integer): PRttiEnumType;\nbegin\n  result := EnumBaseType;\n  NameList := result^.NameList;\n  Min := result^.MinValue;\n  Max := result^.MaxValue;\nend;\n\nfunction TRttiInfo.SetEnumType: PRttiEnumType;\nbegin\n  if (@self = nil) or\n     (Kind <> rkSet) then\n    result := nil\n  else\n    result := PRttiEnumType(GetTypeData(@self))^.SetBaseType;\nend;\n\nfunction TRttiInfo.SetEnumType(out NameList: PShortString;\n  out Min, Max: integer): PRttiEnumType;\nbegin\n  result := SetEnumType;\n  if result <> nil then\n  begin\n    NameList := result^.EnumBaseType.NameList; // EnumBaseType for partial sets\n    Min := result^.MinValue;\n    Max := result^.MaxValue;\n  end;\nend;\n\n\nvar\n  /// conversion table from TRttiKind to TRttiVarData.VType\n  // - rkEnumeration,rkSet,rkDynArray,rkClass,rkInterface,rkRecord,rkArray are\n  // identified as varAny with TVarData.VAny pointing to the actual value\n  // - rkChar,rkWChar,rkSString converted into temporary RawUtf8 as varUnknown\n  RTTI_TO_VARTYPE: array[TRttiKind] of word;\n\nprocedure TRttiInfo.ComputeCache(var Cache: TRttiCache);\nvar\n  enum: PRttiEnumType;\n  siz, cnt: PtrInt;\nbegin\n  // caller ensured Cache is filled with zeros (e.g. TRttiCustom.fCache prop)\n  FillCharFast(Cache, SizeOf(Cache), 0); // paranoid\n  Cache.Info := @self;\n  Cache.Size := RttiSize;\n  Cache.Kind := Kind;\n  if Kind in rkOrdinalTypes then\n  begin\n    if Kind in rkHasRttiOrdTypes then\n    begin\n      include(Cache.Flags, rcfHasRttiOrd);\n      Cache.RttiOrd := RttiOrd;\n    end;\n    if IsQWord then\n      include(Cache.Flags, rcfQword);\n    if IsBoolean then\n    begin\n      Cache.RttiVarDataVType := varBoolean; // no rkBool on Delphi\n      include(Cache.Flags, rcfBoolean);\n    end;\n  end;\n  if Kind in rkNumberTypes then\n    include(Cache.Flags, rcfIsNumber);\n  if Kind in rkGetOrdPropTypes then\n    include(Cache.Flags, rcfGetOrdProp)\n  else if Kind in rkGetInt64PropTypes then\n    include(Cache.Flags, rcfGetInt64Prop);\n  Cache.RttiVarDataVType := RTTI_TO_VARTYPE[Kind];\n  Cache.VarDataVType := Cache.RttiVarDataVType;\n  case Kind of\n    rkFloat:\n      begin\n        Cache.RttiFloat := RttiFloat;\n        if IsCurrency then\n        begin\n          Cache.RttiVarDataVType := varCurrency;\n          Cache.VarDataVType := varCurrency;\n        end\n        else if IsDate then\n        begin\n          Cache.RttiVarDataVType := varDate;\n          Cache.VarDataVType := varDate;\n          Cache.IsDateTime := true;\n        end\n        else if Cache.RttiFloat = rfSingle then\n        begin\n          Cache.RttiVarDataVType := varSingle;\n          Cache.VarDataVType := varSingle;\n        end;\n      end;\n    rkEnumeration,\n    rkSet:\n      begin\n        Cache.VarDataVType := varInt64; // no need of the varAny TypeInfo marker\n        if Kind = rkEnumeration then\n          enum := Cache.Info.EnumBaseType\n        else\n          enum := Cache.Info.SetEnumType;\n        Cache.EnumMin := enum.MinValue;\n        Cache.EnumMax := enum.MaxValue;\n        // EnumBaseType^ is required for partial sets on Delphi\n        enum := enum.EnumBaseType;\n        Cache.EnumInfo := enum;\n        Cache.EnumList := enum.NameList;\n      end;\n    rkDynArray:\n      begin\n        Cache.ItemInfo := DynArrayItemType(siz); // nil for unmanaged items\n        Cache.ItemSize := siz;\n      end;\n    rkArray:\n      begin\n        Cache.ItemInfo := ArrayItemType(cnt, siz);\n        if (cnt = 0) or\n           (siz mod cnt <> 0) then\n          raise ERttiException.CreateUtf8('ComputeCache(%): array siz=% cnt=%',\n            [RawName, siz, cnt]);\n        Cache.ItemSize := siz div cnt;\n        Cache.ItemCount := cnt;\n      end;\n    rkLString:\n      if IsRawBlob then\n      begin\n        include(Cache.Flags, rcfIsRawBlob);\n        Cache.CodePage := CP_RAWBYTESTRING; // CP_RAWBLOB is internal\n        Cache.Engine := TSynAnsiConvert.Engine(CP_RAWBYTESTRING);\n      end\n      else\n      begin\n        Cache.CodePage := AnsiStringCodePage; // use TypeInfo() on old Delphi\n        Cache.Engine := TSynAnsiConvert.Engine(Cache.CodePage);\n      end;\n    rkInterface:\n      Cache.InterfaceGuid := InterfaceGuid;\n  end;\nend;\n\nfunction TRttiInfo.InterfaceType: PRttiInterfaceTypeData;\nbegin\n  result := pointer(GetTypeData(@self));\nend;\n\nfunction TRttiInfo.AnsiStringCodePage: integer;\nbegin\n  if @self = TypeInfo(RawBlob) then\n    result := CP_RAWBLOB\n  else\n  {$ifdef HASCODEPAGE}\n  if Kind = rkLString then\n    // has rkLStringOld any codepage? don't think so -> UTF-8\n    result := GetTypeData(@self)^.CodePage\n  else\n    result := CP_UTF8; // default is UTF-8\n  {$else}\n  if @self = TypeInfo(RawUtf8) then\n    result := CP_UTF8\n  else if @self = TypeInfo(WinAnsiString) then\n    result := CP_WINANSI\n  {$ifndef PUREMORMOT2}\n  else if @self = TypeInfo(RawUnicode) then\n    result := CP_UTF16\n  {$endif PUREMORMOT2}\n  else if @self = TypeInfo(RawByteString) then\n    result := CP_RAWBYTESTRING // RawBlob has same internal code page\n  else if @self = TypeInfo(AnsiString) then\n    result := CP_ACP\n  else\n    result := CP_UTF8; // default is UTF-8\n  {$endif HASCODEPAGE}\nend;\n\n{$ifdef HASCODEPAGE}\n\nfunction TRttiInfo.AnsiStringCodePageStored: integer;\nbegin\n  result := GetTypeData(@self)^.CodePage;\nend;\n\n{$endif HASCODEPAGE}\n\nprocedure TRttiInfo.StringToUtf8(Data: pointer; var Value: RawUtf8);\nbegin\n  case Kind of\n    rkChar:\n      FastSetString(Value, Data, {ansicharcount=}1);\n    rkWChar:\n      RawUnicodeToUtf8(Data, {widecharcount=}1, Value);\n    rkSString:\n      ShortStringToAnsi7String(PShortString(Data)^, Value);\n    rkLString:\n      Value := PRawUtf8(Data)^;\n    rkWString:\n      RawUnicodeToUtf8(Data, length(PWideString(Data)^), Value);\n    {$ifdef HASVARUSTRING}\n    rkUString:\n      RawUnicodeToUtf8(Data, length(PUnicodeString(Data)^), Value);\n    {$endif HASVARUSTRING}\n  else\n    Value := '';\n  end;\nend;\n\nfunction TRttiInfo.InterfaceGuid: PGuid;\nbegin\n  if (@self = nil) or\n     (Kind <> rkInterface) then\n    result := nil\n  else\n    result := InterfaceType^.IntfGuid;\nend;\n\nfunction TRttiInfo.InterfaceUnitName: PShortString;\nbegin\n  if (@self = nil) or\n     (Kind <> rkInterface) then\n    result := @NULCHAR\n  else\n    result := InterfaceType^.IntfUnit;\nend;\n\nfunction TRttiInfo.InterfaceAncestor: PRttiInfo;\nbegin\n  if (@self = nil) or\n     (Kind <> rkInterface) then\n    result := nil\n  else\n    result := InterfaceType^.IntfParent;\nend;\n\nprocedure TRttiInfo.InterfaceAncestors(out Ancestors: PRttiInfoDynArray;\n  OnlyImplementedBy: TInterfacedObjectClass;\n  out AncestorsImplementedEntry: TPointerDynArray);\nvar\n  n: PtrInt;\n  nfo: PRttiInfo;\n  typ: PRttiInterfaceTypeData;\n  entry: pointer;\nbegin\n  if (@self = nil) or\n     (Kind <> rkInterface) then\n    exit;\n  n := 0;\n  typ := InterfaceType;\n  repeat\n    nfo := typ^.IntfParent;\n    if (nfo = nil) or\n       (nfo = TypeInfo(IInterface)) then\n      exit;\n    typ := nfo^.InterfaceType;\n    if ifHasGuid in typ^.IntfFlags then\n    begin\n      if OnlyImplementedBy <> nil then\n      begin\n        entry := OnlyImplementedBy.GetInterfaceEntry(typ^.IntfGuid^);\n        if entry = nil then\n          continue;\n        SetLength(AncestorsImplementedEntry, n + 1);\n        AncestorsImplementedEntry[n] := entry;\n      end;\n      SetLength(Ancestors, n + 1);\n      Ancestors[n] := nfo;\n      inc(n);\n    end;\n  until false;\nend;\n\nfunction TRttiInfo.InterfaceImplements(const AGuid: TGuid): boolean;\nvar\n  nfo: PRttiInfo;\n  typ: PRttiInterfaceTypeData;\nbegin\n  result := false;\n  if (@self = nil) or\n     IsNullGuid(AGuid) or\n     (Kind <> rkInterface) then\n    exit;\n  typ := InterfaceType;\n  repeat\n    nfo := typ^.IntfParent;\n    if (nfo = nil) or\n       (nfo = TypeInfo(IInterface)) then\n      exit;\n    typ := nfo^.InterfaceType;\n  until (ifHasGuid in typ^.IntfFlags) and\n        IsEqualGuid(AGuid, typ^.IntfGuid^);\n  result := true; // found\nend;\n\n\n{ TRttiProp }\n\nfunction TRttiProp.Index: integer;\nbegin\n  result := PPropInfo(@self)^.Index;\nend;\n\nfunction TRttiProp.Default: integer;\nbegin\n  result := PPropInfo(@self)^.Default;\nend;\n\nfunction TRttiProp.NameIndex: integer;\nbegin\n  result := PPropInfo(@self)^.NameIndex;\nend;\n\nfunction TRttiProp.FieldSize: PtrInt;\nbegin\n  result := TypeInfo^.RttiSize;\nend;\n\nfunction TRttiProp.GetterAddr(Instance: pointer): pointer;\nbegin\n  result := Pointer(PtrUInt(Instance) +\n    PtrUInt(PPropInfo(@self)^.GetProc) {$ifdef ISDELPHI} and $00ffffff {$endif} );\nend;\n\nfunction TRttiProp.SetterAddr(Instance: pointer): pointer;\nbegin\n  result := Pointer(PtrUInt(Instance) +\n    PtrUInt(PPropInfo(@self)^.SetProc) {$ifdef ISDELPHI} and $00ffffff {$endif} );\nend;\n\nfunction TRttiProp.GetFieldAddr(Instance: TObject): pointer;\nbegin\n  if not GetterIsField then\n    if not SetterIsField then\n      // both are methods -> returns nil\n      result := nil\n    else\n      // field - Setter is the field offset in the instance data\n      result := SetterAddr(Instance)\n  else\n    // field - Getter is the field offset in the instance data\n    result := GetterAddr(Instance);\nend;\n\nfunction TRttiProp.GetterCall: TRttiPropCall;\nvar\n  call: TMethod;\nbegin\n  result := Getter(nil, @call);\nend;\n\nfunction TRttiProp.SetterCall: TRttiPropCall;\nvar\n  call: TMethod;\nbegin\n  result := Setter(nil, @call);\nend;\n\nfunction TRttiProp.DefaultOr0: integer;\nbegin\n  result := PPropInfo(@self)^.Default;\n  if result = NO_DEFAULT then\n    result := 0;\nend;\n\nfunction TRttiProp.IsRawBlob: boolean;\nbegin\n  result := TypeInfo = system.TypeInfo(RawBlob);\nend;\n\nfunction TRttiProp.SetValue(Instance: TObject; const Value: variant): boolean;\nvar\n  k: TRttiKind;\n  v: Int64;\n  f: double;\n  u: RawUtf8;\nbegin\n  result := false; // invalid or unsupported type\n  if (@self = nil) or\n     (Instance = nil) then\n    exit;\n  k := TypeInfo^.Kind;\n  if k in rkOrdinalTypes then\n    if VariantToInt64(Value, v) then\n      SetInt64Value(Instance, v)\n    else if (k = rkEnumeration) and\n            VariantToText(Value, u) and\n            SetValueText(Instance, u) then\n      // value found from GetEnumNameValue()\n    else\n      exit\n  else if k in rkStringTypes then\n    if VarIsEmptyOrNull(Value) then // otherwise would set 'null' text\n      SetAsString(Instance, '')\n    else if VariantToUtf8(Value, u) then\n      SetAsString(Instance, u)\n    else\n      exit\n  else if k = rkFloat then\n  begin\n    if not VariantToDouble(Value, f) then\n      if Assigned(_Iso8601ToDateTime) and\n         VariantToText(Value, u) then\n        if u = '' then\n          f := 0\n        else\n        begin\n          f := _Iso8601ToDateTime(u);\n          if f = 0 then\n            exit; // not a date\n        end\n      else\n        exit;\n    SetFloatProp(Instance, f);\n  end\n  else if k = rkVariant then\n    SetVariantProp(Instance, Value)\n  else\n    exit;\n  result := true;\nend;\n\nfunction TRttiProp.SetValueText(Instance: TObject; const Value: RawUtf8): boolean;\nvar\n  k: TRttiKind;\n  v: Int64;\n  f: double;\nbegin\n  result := false; // invalid or unsupported type\n  if (@self = nil) or\n     (Instance = nil) then\n    exit;\n  k := TypeInfo^.Kind;\n  if k in rkOrdinalTypes then\n    if ToInt64(Value, v) or // ordinal field from number\n       (TypeInfo^.IsBoolean and\n        GetInt64Bool(pointer(Value), v)) then // boolean from true/false/yes/no\n      SetInt64Value(Instance, v)\n    else if Value = '' then\n      exit\n    else if k = rkEnumeration then // enumertate field from text\n    begin\n      v := GetEnumNameValue(TypeInfo, Value, {trimlowcase=}true);\n      if v < 0 then\n        exit; // not a text enum\n      SetOrdProp(Instance, v);\n    end\n    else if k = rkSet then // set field from CSV text\n      SetOrdProp(Instance, GetSetCsvValue(TypeInfo, pointer(Value)))\n    else\n      exit\n  else if k in rkStringTypes then\n    SetAsString(Instance, Value)\n  else if k = rkFloat then\n  begin\n    if not ToDouble(Value, f) then\n      if Value = '' then\n        f := 0\n      else if Assigned(_Iso8601ToDateTime) then\n      begin\n        f := _Iso8601ToDateTime(Value);\n        if f = 0 then\n          exit; // not a date\n      end\n      else\n        exit;\n    SetFloatProp(Instance, f);\n  end\n  else if k = rkVariant then\n    SetVariantProp(Instance, Value) // store as text\n  else\n    exit;\n  result := true;\nend;\n\nfunction TRttiProp.GetValueText(Instance: TObject): RawUtf8;\nvar\n  k: TRttiKind;\n  v: TRttiVarData;\nbegin\n  result := '';\n  if (@self = nil) or\n     (Instance = nil) then\n    exit;\n  k := TypeInfo^.Kind;\n  if k in rkOrdinalTypes then\n    Int64ToUtf8(GetInt64Value(Instance), result)\n  else if k in rkStringTypes then\n    GetAsString(Instance, result)\n  else if k = rkFloat then\n    DoubleToStr(GetFloatProp(Instance), result)\n  else if k = rkVariant then\n  begin\n    v.VType := 0;\n    GetVariantProp(Instance, variant(v), {byref=}true);\n    VariantToUtf8(variant(v), result);\n    VarClearProc(v.Data);\n  end;\nend;\n\nfunction TRttiProp.GetOrdProp(Instance: TObject): Int64;\ntype\n  TGetProc = function: Pointer of object; // pointer result is a PtrInt register\n  TGetIndexed = function(Index: integer): Pointer of object;\nvar\n  rpc: TRttiPropCall;\n  call: TMethod;\nbegin\n  rpc := Getter(Instance, @call);\n  if rpc = rpcField then\n    call.Code := PPointer({%H-}call.Data)^\n  else if TypeInfo^.Kind in [rkDynArray, rkInterface] then\n    raise ERttiException.CreateUtf8(\n      'TRttiProp.GetOrdProp(%) does not support a getter for %',\n      [Instance.ClassType, ToText(TypeInfo^.Kind)^])\n  else if rpc = rpcMethod then\n    call.Code := TGetProc(call)\n  else if rpc = rpcIndexed then\n    call.Code := TGetIndexed(call)(Index)\n  else\n    call.Code := nil; // call.Code is used to store the raw value\n  with TypeInfo^ do\n    if (Kind = rkClass) or\n       (Kind = rkDynArray) or\n       (Kind = rkInterface) then\n      result := PtrInt(call.Code)\n    else\n      result := RTTI_FROM_ORD[RttiOrd](@call.Code);\nend;\n\nprocedure TRttiProp.SetOrdProp(Instance: TObject; Value: PtrInt);\ntype\n  // on all targets, Value is a register for any RttiOrd size\n  TSetProc = procedure(Value: PtrInt) of object;\n  TSetIndexed = procedure(Index: integer; Value: PtrInt) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      with TypeInfo^ do\n        if (Kind = rkClass) or\n           (Kind = rkDynArray) or\n           (Kind = rkInterface) then\n          PPtrInt({%H-}call.Data)^ := Value\n        else\n          RTTI_TO_ORD[RttiOrd](call.Data, Value);\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\nfunction TRttiProp.GetObjProp(Instance: TObject): TObject;\ntype\n  TGetProc = function: TObject of object;\n  TGetIndexed = function(Index: integer): TObject of object;\nvar\n  call: TMethod;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      result := PObject({%H-}call.Data)^;\n    rpcMethod:\n      result := TGetProc(call);\n    rpcIndexed:\n      result := TGetIndexed(call)(Index);\n  else\n    result := nil;\n  end;\nend;\n\nfunction TRttiProp.GetDynArrayPropGetter(Instance: TObject): pointer;\ntype\n  TGetProc = function: TBytes of object;\n  TGetIndexed = function(Index: integer): TBytes of object;\nvar\n  call: TMethod;\n  tmp: TBytes; // we use TBytes but any dynamic array will do\nbegin\n  case Getter(Instance, @call) of\n    rpcMethod:\n      tmp := TGetProc({%H-}call);\n    rpcIndexed:\n      tmp := TGetIndexed(call)(Index);\n  end;\n  result := pointer(tmp); // weak copy\n  pointer(tmp) := nil;    // no dec(refcnt)\nend;\n\nfunction TRttiProp.GetInt64Prop(Instance: TObject): Int64;\ntype\n  TGetProc = function: Int64 of object;\n  TGetIndexed = function(Index: integer): Int64 of object;\nvar\n  call: TMethod;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      result := PInt64({%H-}call.Data)^;\n    rpcMethod:\n      result := TGetProc(call);\n    rpcIndexed:\n      result := TGetIndexed(call)(Index);\n  else\n    result := 0;\n  end;\nend;\n\nprocedure TRttiProp.SetInt64Prop(Instance: TObject; const Value: Int64);\ntype\n  TSetProc = procedure(Value: Int64) of object;\n  TSetIndexed = procedure(Index: integer; Value: Int64) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      PInt64({%H-}call.Data)^ := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\nprocedure TRttiProp.GetLongStrProp(Instance: TObject; var Value: RawByteString);\nvar\n  rpc: TRttiPropCall;\n  call: TMethod;\n\n    procedure SubProc(rpc: TRttiPropCall); // avoid try..finally\n    type\n      TGetProc = function: RawByteString of object;\n      TGetIndexed = function(Index: integer): RawByteString of object;\n    begin\n      case rpc of\n        rpcMethod:\n          Value := TGetProc(call);\n        rpcIndexed:\n          Value := TGetIndexed(call)(Index);\n      else\n        Value := '';\n      end;\n    end;\n\nbegin\n  rpc := Getter(Instance, @call);\n  if rpc = rpcField then\n    Value := PRawByteString(call.Data)^\n  else\n    SubProc(rpc);\nend;\n\nprocedure TRttiProp.SetLongStrProp(Instance: TObject; const Value: RawByteString);\ntype\n  TSetProc = procedure(const Value: RawByteString) of object;\n  TSetIndexed = procedure(Index: integer; const Value: RawByteString) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      PRawByteString({%H-}call.Data)^ := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\nprocedure TRttiProp.CopyLongStrProp(Source, Dest: TObject);\nvar\n  tmp: RawByteString;\nbegin\n  GetLongStrProp(Source, tmp);\n  SetLongStrProp(Dest, tmp);\nend;\n\nprocedure TRttiProp.GetShortStrProp(Instance: TObject; var Value: RawUtf8);\ntype\n  TGetProc = function: ShortString of object;\n  TGetIndexed = function(Index: integer): ShortString of object;\nvar\n  call: TMethod;\n  tmp: ShortString;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      tmp := PShortString({%H-}call.Data)^;\n    rpcMethod:\n      tmp := TGetProc(call);\n    rpcIndexed:\n      tmp := TGetIndexed(call)(Index);\n  else\n    tmp := '';\n  end;\n  ShortStringToAnsi7String(tmp, Value);\nend; // no SetShortStrProp() by now\n\nprocedure TRttiProp.GetWideStrProp(Instance: TObject; var Value: WideString);\ntype\n  TGetProc = function: WideString of object;\n  TGetIndexed = function(Index: integer): WideString of object;\nvar\n  call: TMethod;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      Value := PWideString({%H-}call.Data)^;\n    rpcMethod:\n      Value := TGetProc(call);\n    rpcIndexed:\n      Value := TGetIndexed(call)(Index);\n  else\n    Value := '';\n  end;\nend;\n\nprocedure TRttiProp.SetWideStrProp(Instance: TObject; const Value: WideString);\ntype\n  TSetProc = procedure(const Value: WideString) of object;\n  TSetIndexed = procedure(Index: integer; const Value: WideString) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      PWideString({%H-}call.Data)^ := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\n{$ifdef HASVARUSTRING}\n\nprocedure TRttiProp.GetUnicodeStrProp(Instance: TObject; var Value: UnicodeString);\nvar\n  rpc: TRttiPropCall;\n  call: TMethod;\n\n    procedure SubProc(rpc: TRttiPropCall); // avoid try..finally\n    type\n      TGetProc = function: UnicodeString of object;\n      TGetIndexed = function(Index: integer): UnicodeString of object;\n    begin\n      case rpc of\n        rpcMethod:\n          Value := TGetProc(call);\n        rpcIndexed:\n          Value := TGetIndexed(call)(Index);\n      else\n        Value := '';\n      end;\n    end;\n\nbegin\n  rpc := Getter(Instance, @call);\n  if rpc = rpcField then\n    Value := PUnicodeString(call.Data)^\n  else\n    SubProc(rpc);\nend;\n\nprocedure TRttiProp.SetUnicodeStrProp(Instance: TObject; const Value: UnicodeString);\ntype\n  TSetProc = procedure(const Value: UnicodeString) of object;\n  TSetIndexed = procedure(Index: integer; const Value: UnicodeString) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      PUnicodeString({%H-}call.Data)^ := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\n{$endif HASVARUSTRING}\n\nprocedure TRttiProp.GetCurrencyProp(Instance: TObject; var Value: currency);\ntype\n  TGetProc = function: currency of object;\n  TGetIndexed = function(Index: integer): currency of object;\nvar\n  call: TMethod;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      Value := PCurrency({%H-}call.Data)^;\n    rpcMethod:\n      Value := TGetProc(call);\n    rpcIndexed:\n      Value := TGetIndexed(call)(Index);\n  else\n    PInt64(@Value)^ := 0;\n  end;\nend;\n\nprocedure TRttiProp.SetCurrencyProp(Instance: TObject; const Value: currency);\ntype\n  TSetProc = procedure(const Value: currency) of object;\n  TSetIndexed = procedure(Index: integer; const Value: currency) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      PCurrency({%H-}call.Data)^ := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\nfunction TRttiProp.GetDoubleProp(Instance: TObject): double;\ntype\n  TGetProc = function: double of object;\n  TGetIndexed = function(Index: integer): double of object;\nvar\n  call: TMethod;\nbegin\n  case Getter(Instance, @call) of\n    rpcField:\n      result := unaligned(PDouble({%H-}call.Data)^);\n    rpcMethod:\n      result := TGetProc(call);\n    rpcIndexed:\n      result := TGetIndexed(call)(Index);\n  else\n    result := 0;\n  end;\nend;\n\nprocedure TRttiProp.SetDoubleProp(Instance: TObject; Value: Double);\ntype\n  TSetProc = procedure(const Value: double) of object;\n  TSetIndexed = procedure(Index: integer; const Value: double) of object;\nvar\n  call: TMethod;\nbegin\n  case Setter(Instance, @call) of\n    rpcField:\n      unaligned(PDouble({%H-}call.Data)^) := Value;\n    rpcMethod:\n      TSetProc(call)(Value);\n    rpcIndexed:\n      TSetIndexed(call)(Index, Value);\n  end;\nend;\n\nfunction TRttiProp.GetFloatProp(Instance: TObject): double;\ntype\n  TSingleProc = function: Single of object;\n  TSingleIndexed = function(Index: integer): Single of object;\n  TDoubleProc = function: Double of object;\n  TDoubleIndexed = function(Index: integer): Double of object;\n  TExtendedProc = function: Extended of object;\n  TExtendedIndexed = function(Index: integer): Extended of object;\n  TCurrencyProc = function: currency of object;\n  TCurrencyIndexed = function(Index: integer): currency of object;\nvar\n  call: TMethod;\n  rf: TRttiFloat;\nbegin\n  result := 0;\n  rf := TypeInfo^.RttiFloat;\n  case Getter(Instance, @call) of\n    rpcField:\n      case rf of\n        rfSingle:\n          result := PSingle({%H-}call.Data)^;\n        rfDouble:\n          result := unaligned(PDouble(call.Data)^);\n        rfExtended:\n          result := PExtended(call.Data)^;\n        rfCurr:\n          CurrencyToDouble(PCurrency(call.Data), result);\n      end;\n    rpcMethod:\n      case rf of\n        rfSingle:\n          result := TSingleProc(call);\n        rfDouble:\n          result := TDoubleProc(call);\n        rfExtended:\n          result := TExtendedProc(call);\n        rfCurr:\n          CurrencyToDouble(TCurrencyProc(call), result);\n      end;\n    rpcIndexed:\n      case rf of\n        rfSingle:\n          result := TSingleIndexed(call)(Index);\n        rfDouble:\n          result := TDoubleIndexed(call)(Index);\n        rfExtended:\n          result := TExtendedIndexed(call)(Index);\n        rfCurr:\n          CurrencyToDouble(TCurrencyIndexed(call)(Index), result);\n      end;\n  end;\nend;\n\nprocedure TRttiProp.SetFloatProp(Instance: TObject; Value: TSynExtended);\ntype\n  TSingleProc = procedure(const Value: Single) of object;\n  TSingleIndexed = procedure(Index: integer; const Value: Single) of object;\n  TDoubleProc = procedure(const Value: double) of object;\n  TDoubleIndexed = procedure(Index: integer; const Value: double) of object;\n  TExtendedProc = procedure(const Value: Extended) of object;\n  TExtendedIndexed = procedure(Index: integer; const Value: Extended) of object;\n  TCurrencyProc = procedure(const Value: currency) of object;\n  TCurrencyIndexed = procedure(Index: integer; const Value: currency) of object;\nvar\n  call: TMethod;\n  rf: TRttiFloat;\nbegin\n  rf := TypeInfo^.RttiFloat;\n  case Setter(Instance, @call) of\n    rpcField:\n      RTTI_TO_FLOAT[rf]({%H-}call.Data, Value);\n    rpcMethod:\n      case rf of\n        rfSingle:\n          TSingleProc(call)(Value);\n        rfDouble:\n          TDoubleProc(call)(Value);\n        rfExtended:\n          TExtendedProc(call)(Value);\n        rfCurr:\n          TCurrencyProc(call)(DoubleToCurrency(Value));\n      end;\n    rpcIndexed:\n      case rf of\n        rfSingle:\n          TSingleIndexed(call)(Index, Value);\n        rfDouble:\n          TDoubleIndexed(call)(Index, Value);\n        rfExtended:\n          TExtendedIndexed(call)(Index, Value);\n        rfCurr:\n          TCurrencyIndexed(call)(Index, DoubleToCurrency(Value));\n      end;\n  end;\nend;\n\nprocedure TRttiProp.GetVariantProp(Instance: TObject; var Result: Variant;\n  SetByRef: boolean);\nvar\n  rpc: TRttiPropCall;\n  call: TMethod;\n\n  procedure SubProc(rpc: TRttiPropCall); // avoid try..finally\n  type\n    TGetProc = function: variant of object;\n    TGetIndexed = function(Index: integer): variant of object;\n  begin\n    case rpc of\n      rpcMethod:\n        Result := TGetProc(call);\n      rpcIndexed:\n        Result := TGetIndexed(call)(Index);\n    else\n      SetVariantNull(result);\n    end;\n  end;\n\nbegin\n  rpc := Getter(Instance, @call);\n  if rpc <> rpcField then\n    SubProc(rpc)\n  else if not SetVariantUnRefSimpleValue(PVariant(call.Data)^, PVarData(@Result)^) then\n    if SetByRef then\n    begin\n      VarClearAndSetType(Result, varVariantByRef);\n      TVarData(Result).VPointer := call.Data;\n    end\n    else\n      result := PVariant(call.Data)^;\nend;\n\nprocedure TRttiProp.SetVariantProp(Instance: TObject; const Value: Variant);\ntype\n  TSetProc = procedure(const Value: variant) of object;\n  TSetIndexed = procedure(Index: integer; const Value: variant) of object;\nvar\n  call: TMethod;\n  v: PVarData;\nbegin\n  v := VarDataFromVariant(Value); // de-reference any varByRef\n  case Setter(Instance, @call) of\n    rpcField:\n      PVariant({%H-}call.Data)^ := PVariant(v)^;\n    rpcMethod:\n      TSetProc(call)(PVariant(v)^);\n    rpcIndexed:\n      TSetIndexed(call)(Index, PVariant(v)^);\n  end;\nend;\n\nfunction TRttiProp.GetOrdValue(Instance: TObject): Int64;\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind in [rkInteger,\n                         rkEnumeration,\n                         rkSet,\n                         {$ifdef FPC}\n                         rkBool,\n                         {$endif FPC}\n                         rkClass]) then\n    result := GetOrdProp(Instance)\n  else\n    result := -1;\nend;\n\nfunction TRttiProp.GetInt64Value(Instance: TObject): Int64;\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) then\n    case TypeInfo^.Kind of\n      rkInteger,\n      rkEnumeration,\n      {$ifdef FPC}\n      rkBool,\n      {$endif FPC}\n      rkSet,\n      rkChar,\n      rkWChar,\n      rkClass:\n        result := GetOrdProp(Instance);\n      {$ifdef FPC}\n      rkQWord,\n      {$endif FPC}\n      rkInt64:\n        result := GetInt64Prop(Instance);\n    else\n      result := 0;\n    end\n  else\n    result := 0;\nend;\n\nprocedure TRttiProp.GetCurrencyValue(Instance: TObject; var Value: currency);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) then\n    with TypeInfo^ do\n      if Kind = rkFloat then\n        if RttiFloat = rfCurr then\n          GetCurrencyProp(Instance, Value)\n        else\n          DoubleToCurrency(GetFloatProp(Instance), Value)\n      else\n        PInt64(@Value)^ := 0\n  else\n    PInt64(@Value)^ := 0;\nend;\n\nfunction TRttiProp.GetDoubleValue(Instance: TObject): double;\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind = rkFloat) then\n    result := GetFloatProp(Instance)\n  else\n    result := 0;\nend;\n\nprocedure TRttiProp.SetDoubleValue(Instance: TObject; const Value: double);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind = rkFloat) then\n    SetFloatProp(Instance, Value);\nend;\n\nprocedure TRttiProp.GetRawByteStringValue(Instance: TObject; var Value: RawByteString);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind in [{$ifdef FPC}rkLStringOld, {$endif} rkLString]) then\n    GetLongStrProp(Instance, Value)\n  else\n    FastAssignNew(Value, nil);\nend;\n\nprocedure TRttiProp.SetOrdValue(Instance: TObject; Value: PtrInt);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind in [rkInteger, rkEnumeration, rkSet,\n                         {$ifdef FPC} rkBool, {$endif} rkClass]) then\n    SetOrdProp(Instance, Value);\nend;\n\nprocedure TRttiProp.SetInt64Value(Instance: TObject; Value: Int64);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) then\n    case TypeInfo^.Kind of\n      rkInteger,\n      rkEnumeration,\n      {$ifdef FPC}\n      rkBool,\n      {$endif FPC}\n      rkSet,\n      rkChar,\n      rkWChar,\n      rkClass:\n        SetOrdProp(Instance, Value);\n      {$ifdef FPC}\n      rkQWord,\n      {$endif FPC}\n      rkInt64:\n        SetInt64Prop(Instance, Value);\n    end;\nend;\n\n{$ifdef HASVARUSTRING}\n\nfunction TRttiProp.GetUnicodeStrValue(Instance: TObject): UnicodeString;\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind = rkUString) then\n    GetUnicodeStrProp(Instance, result{%H-})\n  else\n    result := '';\nend;\n\nprocedure TRttiProp.SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);\nbegin\n  if (Instance <> nil) and\n     (@self <> nil) and\n     (TypeInfo^.Kind = rkUString) then\n    SetUnicodeStrProp(Instance, Value);\nend;\n\n{$endif HASVARUSTRING}\n\nfunction TRttiProp.GetAsString(Instance: TObject): RawUtf8;\nbegin\n  GetAsString(Instance, result);\nend;\n\nfunction TRttiProp.GetAsString(Instance: TObject; var Value: RawUtf8): boolean;\nvar\n  v: PtrInt;\n  WS: WideString;\n  {$ifdef HASVARUSTRING}\n  US: UnicodeString;\n  {$endif HASVARUSTRING}\nbegin\n  result := true;\n  case TypeInfo^.Kind of\n    rkChar,\n    rkWChar:\n      begin\n        v := GetOrdProp(Instance);\n        if TypeInfo^.Kind = rkChar then\n          FastSetString(Value, @v, {ansicharcount=}1)\n        else\n          RawUnicodeToUtf8(@v, {widecharcount=}1, Value);\n      end;\n    rkSString:\n      GetShortStrProp(Instance, Value);\n    rkLString:\n      GetLongStrProp(Instance, RawByteString(Value));\n    rkWString:\n      begin\n        GetWideStrProp(Instance, WS);\n        RawUnicodeToUtf8(pointer(WS), length(WS), Value);\n      end;\n    {$ifdef HASVARUSTRING}\n    rkUString:\n      begin\n        GetUnicodeStrProp(Instance, US);\n        RawUnicodeToUtf8(pointer(US), length(US), Value);\n      end;\n    {$endif HASVARUSTRING}\n  else\n    begin\n      Value := '';\n      result := false; // unsupported property\n    end;\n  end;\nend;\n\nfunction TRttiProp.SetAsString(Instance: TObject; const Value: RawUtf8): boolean;\nvar\n  v: PtrInt;\n  P: PUtf8Char;\n  u: pointer; // to avoid a global hidden try..finally\nbegin\n  result := true;\n  case TypeInfo^.Kind of\n    rkChar,\n    rkWChar:\n      begin\n        if Value = '' then\n          v := 0\n        else if TypeInfo^.Kind = rkChar then\n          v := ord(Value[1])\n        else\n        begin\n          P := pointer(Value);\n          v := NextUtf8Ucs4(P);\n        end;\n        SetOrdProp(Instance, v);\n      end;\n    rkLString:\n      SetLongStrProp(Instance, Value);\n    rkWString:\n      begin\n        u := nil;\n        try\n          Utf8ToWideString(pointer(Value), length(Value), WideString(u));\n          SetWideStrProp(Instance, WideString(u));\n        finally\n          WideString(u) := '';\n        end;\n      end;\n    {$ifdef HASVARUSTRING}\n    rkUString:\n      begin\n        u := nil;\n        try\n          Utf8DecodeToUnicodeString(pointer(Value), length(Value), UnicodeString(u));\n          SetUnicodeStrProp(Instance, UnicodeString(u));\n        finally\n          UnicodeString(u) := '';\n        end;\n      end;\n    {$endif HASVARUSTRING}\n  else\n    result := false; // unsupported type\n  end;\nend;\n\nfunction ToText(k: TRttiKind): PShortString;\nbegin\n  result := GetEnumName(TypeInfo(TRttiKind), ord(k));\nend;\n\nfunction ToText(t: TRttiParserType): PShortString;\nbegin\n  result := GetEnumName(TypeInfo(TRttiParserType), ord(t));\nend;\n\nfunction ToText(w: TWellKnownSid): PShortString;\nbegin\n  result := GetEnumName(TypeInfo(TWellKnownSid), ord(w));\nend;\n\n\n{ **************** Published Class Properties and Methods RTTI }\n\nfunction GetRttiClass(RttiClass: TClass): PRttiClass;\nbegin\n  result := PRttiInfo(PPointer(PAnsiChar(RttiClass) + vmtTypeInfo)^)^.RttiClass;\nend;\n\nfunction ClassHasPublishedFields(ClassType: TClass): boolean;\nvar\n  cp: PRttiProps;\nbegin\n  result := true;\n  while ClassType <> nil do\n  begin\n    cp := GetRttiProps(ClassType);\n    if cp = nil then\n      break; // no RTTI information (e.g. reached TObject level)\n    if cp^.PropCount > 0 then\n      exit;\n    ClassType := GetClassParent(ClassType);\n  end;\n  result := false;\nend;\n\nfunction ClassHierarchyWithField(ClassType: TClass): TClassDynArray;\n\n  procedure InternalAdd(C: TClass; var list: TClassDynArray);\n  var\n    P: PRttiProps;\n  begin\n    if C = nil then\n      exit;\n    InternalAdd(GetClassParent(C), list);\n    P := GetRttiProps(C);\n    if (P <> nil) and\n       (P^.PropCount > 0) then\n      PtrArrayAdd(list, pointer(C));\n  end;\n\nbegin\n  result := nil;\n  InternalAdd(ClassType, result);\nend;\n\nfunction ClassFieldAllProps(ClassType: TClass; Types: TRttiKinds): PRttiPropDynArray;\nvar\n  CP: PRttiProps;\n  P: PRttiProp;\n  i, n: integer;\nbegin\n  n := 0;\n  result := nil;\n  while ClassType <> nil do\n  begin\n    CP := GetRttiProps(ClassType);\n    if CP = nil then\n      break; // no RTTI information (e.g. reached TObject level)\n    if CP^.PropCount > 0 then\n    begin\n      SetLength(result, n + CP^.PropCount);\n      P := CP^.PropList;\n      for i := 1 to CP^.PropCount do\n      begin\n        if P^.TypeInfo^.Kind in Types then\n        begin\n          result[n] := P;\n          inc(n);\n        end;\n        P := P^.Next\n      end;\n    end;\n    ClassType := GetClassParent(ClassType);\n  end;\n  SetLength(result,n);\nend;\n\nfunction ClassFieldNamesAllProps(ClassType: TClass; IncludePropType: boolean;\n  Types: TRttiKinds): TRawUtf8DynArray;\nvar\n  props: PRttiPropDynArray;\n  n, i: PtrInt;\nbegin\n  result := nil;\n  props := ClassFieldAllProps(ClassType, Types); // recursive in-order list\n  n := length(props);\n  SetLength(result, n);\n  for i := 0 to n - 1 do\n    with props[i]^ do\n      if IncludePropType then\n        FormatUtf8('%: %', [Name^, TypeInfo^.Name^], result[i])\n      else\n        ShortStringToAnsi7String(Name^, result[i]);\nend;\n\nfunction ClassFieldNamesAllPropsAsText(ClassType: TClass; IncludePropType: boolean;\n  Types: TRttiKinds): RawUtf8;\nbegin\n  result := RawUtf8ArrayToCsv(\n    ClassFieldNamesAllProps(ClassType, IncludePropType, Types), ', ');\nend;\n\nfunction ClassFieldProp(ClassType: TClass; const PropName: ShortString): PRttiProp;\nbegin\n  if ClassType <> nil then\n    result := GetRttiProps(ClassType)^.FieldProp(PropName)\n  else\n    result := nil;\nend;\n\nfunction ClassFieldPropWithParents(aClassType: TClass; const aPropName: ShortString;\n  aCaseSensitive: boolean): PRttiProp;\nvar\n  n, i: integer;\nbegin\n  while aClassType <> nil do\n  begin\n    n := GetRttiProp(aClassType, result);\n    if n <> 0 then\n      if aCaseSensitive then\n        for i := 1 to n do\n          if result^.Name^ = aPropName then\n            exit\n          else\n            result := result^.Next\n      else\n        for i := 1 to n do\n          if IdemPropName(result^.Name^, @aPropName[1], ord(aPropName[0])) then\n            exit\n          else\n            result := result^.Next;\n    aClassType := GetClassParent(aClassType);\n  end;\n  result := nil;\nend;\n\nfunction ClassFieldPropWithParentsFromUtf8(aClassType: TClass; PropName: PUtf8Char;\n  PropNameLen: integer; aCaseSensitive: boolean): PRttiProp;\nvar\n  n, i: integer;\nbegin\n  if PropNameLen <> 0 then\n    while aClassType <> nil do\n    begin\n      n := GetRttiProp(aClassType, result);\n      if n <> 0 then\n        if aCaseSensitive then\n          for i := 1 to n do\n            if (result^.Name^[0] = AnsiChar(PropNameLen)) and\n               CompareMemFixed(@result^.Name^[1], PropName, PropNameLen) then\n              exit\n            else\n              result := result^.Next\n        else\n          for i := 1 to n do\n            if IdemPropName(result^.Name^, PropName, PropNameLen) then\n              exit\n            else\n              result := result^.Next;\n      aClassType := GetClassParent(aClassType);\n    end;\n  result := nil;\nend;\n\nfunction ClassFieldPropWithParentsFromClassType(aClassType,\n  aSearchedClassType: TClass): PRttiProp;\nvar\n  i: integer;\nbegin\n  if aSearchedClassType <> nil then\n    while aClassType <> nil do\n    begin\n      for i := 1 to GetRttiProp(aClassType, result) do\n        with result^.TypeInfo^ do\n          if (Kind = rkClass) and\n             (RttiNonVoidClass^.RttiClass = aSearchedClassType) then\n            exit\n          else\n            result := result^.Next;\n      aClassType := GetClassParent(aClassType);\n    end;\n  result := nil;\nend;\n\nfunction ClassFieldPropWithParentsInheritsFromClassType(aClassType,\n  aSearchedClassType: TClass): PRttiProp;\nvar\n  i: integer;\nbegin\n  if aSearchedClassType <> nil then\n    while aClassType <> nil do\n    begin\n      for i := 1 to GetRttiProp(aClassType, result) do\n        with result^.TypeInfo^ do\n          if (Kind = rkClass) and\n             InheritsFrom(aSearchedClassType) then\n            exit\n          else\n            result := result^.Next;\n      aClassType := GetClassParent(aClassType);\n    end;\n  result := nil;\nend;\n\nfunction ClassFieldPropWithParentsFromClassOffset(aClassType: TClass;\n  aSearchedOffset: pointer): PRttiProp;\nvar\n  i: integer;\nbegin\n  if aSearchedOffset <> nil then\n    while aClassType <> nil do\n    begin\n      for i := 1 to GetRttiProp(aClassType, result) do\n        if result^.GetFieldAddr(nil) = aSearchedOffset then\n          exit\n        else\n          result := result^.Next;\n      aClassType := GetClassParent(aClassType);\n    end;\n  result := nil;\nend;\n\nfunction ClassFieldInstance(Instance: TObject; const PropName: ShortString;\n  PropClassType: TClass; out PropInstance): boolean;\nvar\n  P: PRttiProp;\nbegin\n  result := false;\n  if Instance = nil then\n    exit;\n  P := ClassFieldPropWithParents(PPointer(Instance)^, PropName);\n  if P = nil then\n    exit;\n  with P^.TypeInfo^ do\n    if (Kind <> rkClass) or\n       not InheritsFrom(PropClassType) then\n      exit;\n  TObject(PropInstance) := P^.GetObjProp(Instance);\n  result := true;\nend;\n\nfunction ClassFieldInstance(Instance: TObject; PropClassType: TClass;\n  out PropInstance): boolean;\nvar\n  P: PRttiProp;\nbegin\n  result := false;\n  if (Instance = nil) or\n     (PropClassType = nil) then\n    exit;\n  P := ClassFieldPropWithParentsFromClassType(PPointer(Instance)^, PropClassType);\n  if P = nil then\n    exit;\n  TObject(PropInstance) := P^.GetObjProp(Instance);\n  result := true;\nend;\n\nfunction ClassFieldInt64(Instance: TObject; const PropName: ShortString;\n  out PropValue: Int64): boolean;\nvar\n  P: PRttiProp;\nbegin\n  result := false;\n  if Instance = nil then\n    exit;\n  P := ClassFieldPropWithParents(PPointer(Instance)^, PropName);\n  if P = nil then\n    exit;\n  PropValue := P^.GetInt64Value(Instance);\n  result := true;\nend;\n\nfunction ClassFieldInstances(Instance: TObject; PropClassType: TClass): TObjectDynArray;\nvar\n  nested: PRttiPropDynArray;\n  i: PtrInt;\nbegin\n  result := nil;\n  if (Instance = nil) or\n     (PropClassType = nil) then\n    exit;\n  nested := ClassFieldAllProps(PPointer(Instance)^, [rkClass]);\n  for i := 0 to high(nested) do\n    with nested[i]^ do\n      if TypeInfo^.InheritsFrom(PropClassType) then\n        ObjArrayAdd(result, GetObjProp(Instance));\nend;\n\nfunction ClassFieldPropInstanceMatchingClass(\n  aSearchedInstance: TObject; aSearchedClassType: TClass): TObject;\nvar\n  P: PRttiProp;\nbegin\n  result := aSearchedInstance;\n  if (aSearchedInstance = nil) or\n     aSearchedInstance.InheritsFrom(aSearchedClassType) then\n    exit;\n  P := ClassFieldPropWithParentsFromClassType(\n    PPointer(aSearchedInstance)^, aSearchedClassType);\n  if P <> nil then\n  begin\n    result := P^.GetObjProp(aSearchedInstance);\n    if result = nil then\n      result := aSearchedInstance;\n  end;\nend;\n\nfunction ClassFieldCountWithParents(ClassType: TClass; onlyWithoutGetter: boolean): integer;\nvar\n  cp: PRttiProps;\n  p: PRttiProp;\n  i: integer;\nbegin\n  result := 0;\n  while ClassType <> nil do\n  begin\n    cp := GetRttiProps(ClassType);\n    if cp = nil then\n      break; // no RTTI information (e.g. reached TObject level)\n    p := cp^.PropList;\n    for i := 1 to cp^.PropCount do\n    begin\n      if (not onlyWithoutGetter) or\n         p^.GetterIsField then\n        inc(result);\n      p := p^.Next;\n    end;\n    ClassType := GetClassParent(ClassType);\n  end;\nend;\n\n\n{ *************** Enumerations RTTI }\n\nfunction GetEnumType(aTypeInfo: PRttiInfo; out List: PShortString): integer;\nbegin\n  with aTypeInfo^.EnumBaseType^ do\n  begin\n    List := NameList;\n    result := MaxValue;\n  end;\nend;\n\nfunction GetEnumNameTrimed(aTypeInfo: PRttiInfo; aIndex: integer): RawUtf8;\nbegin\n  result := TrimLeftLowerCaseShort(GetEnumName(aTypeInfo, aIndex));\nend;\n\nfunction GetEnumNameUnCamelCase(aTypeInfo: PRttiInfo; aIndex: integer): RawUtf8;\nbegin\n  result := UnCamelCase(GetEnumNameTrimed(aTypeInfo, aIndex));\nend;\n\nprocedure GetEnumNames(aTypeInfo: PRttiInfo; aDest: PPShortString);\nvar\n  info: PRttiEnumType;\n  p: PShortString;\n  i: PtrInt;\nbegin\n  info := aTypeInfo^.EnumBaseType;\n  if info <> nil then\n  begin\n    p := info^.NameList;\n    for i := info^.MinValue to info^.MaxValue do\n    begin\n      aDest^ := p;\n      p := @PByteArray(p)^[ord(p^[0]) + 1];\n      inc(aDest);\n    end;\n  end;\nend;\n\nprocedure GetEnumTrimmedNames(aTypeInfo: PRttiInfo; aDest: PRawUtf8);\nvar\n  info: PRttiEnumType;\n  p: PShortString;\n  i: PtrInt;\nbegin\n  info := aTypeInfo^.EnumBaseType;\n  if info <> nil then\n  begin\n    p := info^.NameList;\n    for i := info^.MinValue to info^.MaxValue do\n    begin\n      aDest^ := TrimLeftLowerCaseShort(p);\n      p := @PByteArray(p)^[ord(p^[0]) + 1];\n      inc(aDest);\n    end;\n  end;\nend;\n\nfunction GetEnumTrimmedNames(aTypeInfo: PRttiInfo): TRawUtf8DynArray;\nbegin\n  aTypeInfo^.EnumBaseType^.GetEnumNameAll(result{%H-}, {trim=}true);\nend;\n\nfunction GetEnumNameValue(aTypeInfo: PRttiInfo; aValue: PUtf8Char;\n  aValueLen: PtrInt; AlsoTrimLowerCase: boolean): integer;\nbegin\n  result := aTypeInfo^.EnumBaseType^.\n    GetEnumNameValue(aValue, aValueLen, AlsoTrimLowerCase);\nend;\n\nfunction GetEnumNameValueTrimmed(aTypeInfo: PRttiInfo; aValue: PUtf8Char;\n  aValueLen: PtrInt): integer;\nbegin\n  result := aTypeInfo^.EnumBaseType^.\n    GetEnumNameValueTrimmed(aValue, aValueLen, {casesensitive=}false);\nend;\n\nfunction GetEnumNameValueTrimmedExact(aTypeInfo: PRttiInfo; aValue: PUtf8Char;\n  aValueLen: PtrInt): integer;\nbegin\n  result := aTypeInfo^.EnumBaseType^.\n    GetEnumNameValueTrimmed(aValue, aValueLen, {casesensitive=}true);\nend;\n\nfunction GetEnumNameValue(aTypeInfo: PRttiInfo; const aValue: RawUtf8;\n  AlsoTrimLowerCase: boolean): integer;\nbegin\n  result := aTypeInfo^.EnumBaseType^.\n    GetEnumNameValue(pointer(aValue), length(aValue), AlsoTrimLowerCase);\nend;\n\nprocedure SetEnumFromOrdinal(aTypeInfo: PRttiInfo; out Value; Ordinal: PtrUInt);\nbegin\n  aTypeInfo^.EnumBaseType^.SetEnumFromOrdinal(Value, Ordinal);\nend;\n\nfunction GetSetName(aTypeInfo: PRttiInfo; const value): RawUtf8;\nbegin\n  result := aTypeInfo^.SetEnumType^.EnumBaseType.GetSetName(value);\nend;\n\nprocedure GetSetNameShort(aTypeInfo: PRttiInfo; const value;\n  out result: ShortString; trimlowercase: boolean);\nvar\n  info: PRttiEnumType;\n  PS: PShortString;\n  i: PtrInt;\nbegin\n  result := '';\n  info := aTypeInfo^.SetEnumType;\n  if (info = nil) or\n     (@value = nil) then\n    exit;\n  PS := info^.EnumBaseType.NameList;\n  for i := info^.MinValue to info^.MaxValue do\n  begin\n    if GetBitPtr(@value, i) then\n      AppendShortComma(@PS^[1], PByte(PS)^, result, trimlowercase);\n    inc(PByte(PS), PByte(PS)^ + 1); // next\n  end;\n  if result[0] <> #0 then\n    dec(result[0]);\nend;\n\nprocedure SetNamesValue(SetNames: PShortString; MinValue, MaxValue: integer;\n  Value: PUtf8Char; ValueLen: PtrInt; var Result: QWord);\nvar\n  i: integer;\nbegin\n  if (Value = nil) or\n     (ValueLen = 0) then\n    exit;\n  if Value^ = '*' then\n  begin\n    if MaxValue < 32 then\n      Result := ALLBITS_CARDINAL[MaxValue + 1]\n    else\n      Result := QWord(-1);\n    exit;\n  end;\n  if MaxValue > 63 then\n    MaxValue := 63; // no need to search more than the Result number of bits\n  if Value^ in ['a'..'z'] then\n    i := FindShortStringListExact(SetNames, MaxValue, Value, ValueLen)\n  else\n    i := -1;\n  if i < 0 then\n    i := FindShortStringListTrimLowerCase(SetNames, MaxValue, Value, ValueLen);\n  if i >= MinValue then\n    SetBitPtr(@Result, i);\n  // unknown enum names (i=-1) would just be ignored\nend;\n\nfunction GetSetCsvValue(aTypeInfo: PRttiInfo; Csv: PUtf8Char;\n  Sep: AnsiChar): QWord;\nvar\n  v: shortstring;\n  names: PShortString;\n  min, max: integer;\nbegin\n  result := 0;\n  if (aTypeInfo <> nil) and\n     (aTypeInfo^.Kind = rkSet) and\n     (aTypeInfo^.SetEnumType(names, min, max) <> nil) then\n    while Csv <> nil do\n    begin\n      GetNextItemShortString(Csv, @v, Sep);\n      SetNamesValue(names, min, max, @v[1], ord(v[0]), result);\n    end;\nend;\n\nprocedure GetCaptionFromTrimmed(PS: PShortString; var result: string);\nvar\n  tmp: array[byte] of AnsiChar;\n  L: integer;\nbegin\n  L := ord(PS^[0]);\n  inc(PByte(PS));\n  while (L > 0) and\n        (PS^[0] in ['a'..'z']) do\n  begin\n    inc(PByte(PS));\n    dec(L);\n  end;\n  tmp[L] := #0; // as expected by GetCaptionFromPCharLen/UnCamelCase\n  if L > 0 then\n    MoveFast(PS^, tmp, L);\n  GetCaptionFromPCharLen(tmp, result);\nend;\n\nprocedure GetEnumCaptions(aTypeInfo: PRttiInfo; aDest: PString);\nvar\n  MinValue, MaxValue, i: integer;\n  res: PShortString;\nbegin\n  aTypeInfo^.EnumBaseType(res, MinValue, MaxValue);\n  if res <> nil then\n    for i := MinValue to MaxValue do\n    begin\n      GetCaptionFromTrimmed(res, aDest^);\n      inc(PByte(res), PByte(res)^ + 1); // next\n      inc(aDest);\n    end;\nend;\n\nfunction GetCaptionFromEnum(aTypeInfo: PRttiInfo; aIndex: integer): string;\nbegin\n  GetCaptionFromTrimmed(GetEnumName(aTypeInfo, aIndex), result{%H-});\nend;\n\nfunction GetDisplayNameFromClass(C: TClass): RawUtf8;\nvar\n  name: PShortString;\n  totrim: integer;\nbegin\n  if C = nil then\n  begin\n    result := '';\n    exit;\n  end;\n  name := ClassNameShort(C);\n  totrim := 0;\n  if name^[0] > #4 then\n    // fast case-insensitive compare\n    case PInteger(@name^[1])^ and $DFDFDFDF of\n      {$ifndef PUREMORMOT2}\n      // backward compatibility trim of left-sided TSql* or TSqlRecord*\n      ord('T') + ord('S') shl 8 + ord('Q') shl 16 + ord('L') shl 24:\n        if (name^[0] <= #10) or\n           (PInteger(@name^[5])^ and $DFDFDFDF <>\n            ord('R') + ord('E') shl 8 + ord('C') shl 16 + ord('O') shl 24) or\n           (PWord(@name^[9])^ and $DFDF <> ord('R') + ord('D')shl 8) then\n          totrim := 4\n        else\n          totrim := 10;\n      {$endif PUREMORMOT2}\n      // trim left-sided TOrm* and TSyn* naming conventions\n      ord('T') + ord('O') shl 8 + ord('R') shl 16 + ord('M') shl 24,\n      ord('T') + ord('S') shl 8 + ord('Y') shl 16 + ord('N') shl 24:\n        totrim := 4;\n    end;\n  if (totrim = 0) and\n     (name^[1] = 'T') then\n    // trim left-sided T* from regular Delphi/FPC type\n    totrim := 1;\n  FastSetString(result, @name^[totrim + 1], ord(name^[0]) - totrim);\nend;\n\nfunction GetCaptionFromClass(C: TClass): string;\nvar\n  tmp: RawUtf8;\n  P: PUtf8Char;\nbegin\n  if C = nil then\n    result := ''\n  else\n  begin\n    tmp := ToText(C);\n    P := pointer(tmp);\n    if IdemPChar(P, 'TSQL') or\n       IdemPChar(P, 'TORM') or\n       IdemPChar(P, 'TSYN') then\n      inc(P, 4)\n    else if P^ = 'T' then\n       inc(P);\n    GetCaptionFromPCharLen(P, result);\n  end;\nend;\n\nfunction ToText(cmd: TParseCommands): ShortString;\nbegin\n  if cmd = [] then\n    result[0] := #0\n  else\n    GetSetNameShort(TypeInfo(TParseCommands), cmd, result, {trim=}true);\nend;\n\n\n{ ***************** IInvokable Interface RTTI }\n\nprocedure TGetRttiInterface.AddMethod(const aMethodName: ShortString;\n  aParamCount: integer; aKind: TMethodKind);\nvar\n  i: PtrInt;\nbegin\n  CurrentMethod := @Definition.Methods[MethodCount];\n  ShortStringToAnsi7String(aMethodName, CurrentMethod^.Name);\n  for i := 0 to MethodCount - 1 do\n    if PropNameEquals(Definition.Methods[i].Name, CurrentMethod^.Name) then\n      RaiseError('duplicated method name', []);\n  CurrentMethod^.HierarchyLevel := Level;\n  if aKind = mkFunction then\n    inc(aParamCount);\n  SetLength(CurrentMethod^.Args, aParamCount);\n  CurrentMethod^.IsFunction := aKind = mkFunction;\n  inc(MethodCount);\n  ArgCount := 0;\nend;\n\nprocedure TGetRttiInterface.AddArgument(aParamName, aTypeName: PShortString;\n  aInfo: PRttiInfo; aFlags: TParamFlags);\nvar\n  a: PRttiMethodArg;\nbegin\n  a := @CurrentMethod^.Args[ArgCount];\n  inc(ArgCount);\n  if {$ifdef FPC} pfSelf in aFlags {$else} ArgCount = 1 {$endif} then\n    a^.ParamName := @PSEUDO_SELF_NAME\n  else if aParamName = nil then\n  begin\n    a^.ParamName := @PSEUDO_RESULT_NAME;\n    include(aFlags, pfOut); // result is an \"out\"\n  end\n  else\n    a^.ParamName := aParamName;\n  a^.TypeInfo := aInfo;\n  if aTypeName = nil then\n    aTypeName := aInfo^.Name;\n  a^.TypeName := aTypeName;\n  if ArgCount > 1 then\n    if aInfo^.Kind in rkRecordOrDynArrayTypes then\n    begin\n      if aFlags * [pfConst, pfVar, pfOut] = [] then\n        RaiseError('%: % parameter should be declared as const, var or out',\n          [a^.ParamName^, aTypeName^]);\n    end\n    else if aInfo^.Kind = rkInterface then\n      if Rtti.FindType(aInfo).HasClassNewInstance then\n      begin // e.g. IDocList/IDocDict with custom JSON serialization\n        if aFlags * [pfConst, pfVar, pfOut] = [] then\n          RaiseError('%: % parameter should be declared as const, var or out',\n            [a^.ParamName^, aTypeName^])\n      end\n      else if not (pfConst in aFlags) then\n        RaiseError('%: % parameter should be declared as const',\n          [a^.ParamName^, aTypeName^]);\n  if aParamName = nil then\n    a^.Direction := rmdResult\n  else if pfVar in aFlags then\n    a^.Direction := rmdVar\n  else if pfOut in aFlags then\n    a^.Direction := rmdOut;\nend;\n\nprocedure TGetRttiInterface.RaiseError(const Format: RawUtf8;\n  const Args: array of const);\nvar\n  m: RawUtf8;\nbegin\n  if CurrentMethod <> nil then\n    m := '.' + CurrentMethod^.Name;\n  raise ERttiException.CreateUtf8('GetRttiInterface(%%) failed - %',\n    [Definition.Name, {%H-}m, FormatUtf8(Format, Args)]);\nend;\n\nfunction GetRttiInterface(aTypeInfo: PRttiInfo;\n  out aDefinition: TRttiInterface): integer;\nvar\n  getter: TGetRttiInterface;\nbegin\n  getter := TGetRttiInterface.Create;\n  try\n    getter.AddMethodsFromTypeInfo(pointer(aTypeInfo));\n    aDefinition := getter.Definition;\n  finally\n    getter.Free;\n  end;\n  result := length(aDefinition.Methods);\nend;\n\nfunction GetInterfaceFromEntry(Instance: TObject; Entry: PInterfaceEntry;\n  out Obj): boolean;\nbegin\n  result := false;\n  pointer(Obj) := nil;\n  if Entry <> nil then\n    if InterfaceEntryIsStandard(Entry) then\n    begin\n      // fast interface retrieval from the interface field instance\n      pointer(Obj) := pointer(PAnsiChar(Instance) + Entry^.IOffset);\n      if pointer(Obj) = nil then\n         exit;\n      IInterface(Obj)._AddRef;\n      result := true;\n    end\n    else\n      // there is a getter method -> use slower but safe RTL method\n      result := Instance.GetInterface(Entry^.IID{$ifdef FPC}^{$endif}, Obj);\nend;\n\nfunction GetRttiClassGuid(aClass: TClass): PGuidDynArray;\nvar\n  T: PInterfaceTable;\n  n, i: PtrInt;\nbegin\n  result := nil;\n  n := 0;\n  while aClass <> nil do\n  begin\n    T := aClass.GetInterfaceTable;\n    if (T <> nil) and\n       (T^.EntryCount > 0) then\n    begin\n      SetLength(result, length(result) + PtrInt(T^.EntryCount));\n      for i := 0 to T^.EntryCount - 1 do\n      begin\n        result[n] := {$ifdef ISDELPHI}@{$endif}T^.Entries[i].IID;\n        inc(n);\n      end;\n    end;\n    aClass := GetClassParent(aClass);\n  end;\nend;\n\n\n{ ************* Efficient Dynamic Arrays and Records Process }\n\n// defined here for proper inlining in code below\nfunction TRttiCustomList.RegisterType(Info: PRttiInfo): TRttiCustom;\nbegin\n  if Info <> nil then\n  begin\n    result := FindType(Info);\n    if result = nil then\n      result := DoRegister(Info);\n  end\n  else\n    result := nil;\nend;\n\nprocedure VariantDynArrayClear(var Value: TVariantDynArray);\nbegin\n  FastDynArrayClear(@Value, TypeInfo(variant));\nend;\n\nprocedure RawUtf8DynArrayClear(var Value: TRawUtf8DynArray);\nbegin\n  FastDynArrayClear(@Value, TypeInfo(RawUtf8));\nend;\n\nfunction IsRawUtf8DynArray(Info: PRttiInfo): boolean;\nvar\n  r: TRttiCustom;\nbegin\n  r := Rtti.RegisterType(Info);\n  if r <> nil then\n    r := r.ArrayRtti;\n  result := (r <> nil) and\n            (r.Parser = ptRawUtf8) and\n            (r.Cache.CodePage = CP_UTF8); // properly detected on Delphi 7/2007\nend;\n\nprocedure RecordClearSeveral(v: PAnsiChar; info: PRttiInfo; n: integer);\nvar\n  fields: TRttiRecordManagedFields;\n  f: PRttiRecordField;\n  p: PRttiInfo;\n  i: PtrInt;\n  fin: PRttiFinalizers;\nbegin\n  info.RecordManagedFields(fields); // retrieve RTTI once for n items\n  if fields.Count = 0 then\n    exit;\n  fin := @RTTI_FINALIZE;\n  repeat\n    f := fields.Fields;\n    i := fields.Count;\n    repeat\n      p := f^.{$ifdef HASDIRECTTYPEINFO}TypeInfo{$else}TypeInfoRef^{$endif};\n      {$ifdef FPC_OLDRTTI}\n      if Assigned(fin[p^.Kind]) then\n      {$endif FPC_OLDRTTI}\n        fin[p^.Kind](v + f^.Offset, p);\n      inc(f);\n      dec(i);\n    until i = 0;\n    inc(v, fields.Size);\n    dec(n);\n  until n = 0;\nend;\n\nprocedure StringClearSeveral(v: PPointer; n: PtrInt);\nvar\n  p: PStrRec;\nbegin\n  repeat\n    p := v^;\n    if p <> nil then\n    begin\n      v^ := nil;\n      dec(p);\n      if (p^.refCnt >= 0) and\n         StrCntDecFree(p^.refCnt) then\n        Freemem(p); // works for both rkLString + rkUString\n    end;\n    inc(v);\n    dec(n);\n  until n = 0;\nend;\n\nprocedure FastFinalizeArray(Value: PPointer; ElemTypeInfo: PRttiInfo;\n  Count: integer);\nvar\n  fin: TRttiFinalizer;\nbegin\n  // caller ensured ElemTypeInfo<>nil and Count>0\n  case ElemTypeInfo^.Kind of\n    {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n    rkRecord:\n      // retrieve ElemTypeInfo.RecordManagedFields once\n      RecordClearSeveral(pointer(Value), ElemTypeInfo, Count);\n    {$ifdef FPC}\n    rkLStringOld,\n    {$endif FPC}\n    {$ifdef HASVARUSTRING}\n    rkUString,\n    {$endif HASVARUSTRING}\n    rkLString:\n      // optimized loop for AnsiString / UnicodeString (PStrRec header)\n      StringClearSeveral(pointer(Value), Count);\n    rkVariant:\n      // from mormot.core.variants - supporting custom variants\n      // or at least from mormot.core.base calling inlined VarClear()\n      VariantClearSeveral(pointer(Value), Count);\n    else\n      begin\n        // regular finalization\n        fin := RTTI_FINALIZE[ElemTypeInfo^.Kind];\n        if Assigned(fin) then  // e.g. rkWString, rkArray, rkDynArray\n          repeat\n            inc(PByte(Value), fin(PByte(Value), ElemTypeInfo));\n            dec(Count);\n          until Count = 0;\n      end;\n  end;\nend;\n\nprocedure FastDynArrayClear(Value: PPointer; ElemInfo: PRttiInfo);\nvar\n  p: PDynArrayRec;\nbegin\n  if Value = nil then\n    exit;\n  p := Value^;\n  if p = nil then\n    exit;\n  dec(p);\n  if (p^.refCnt >= 0) and\n     DACntDecFree(p^.refCnt) then\n  begin\n    if ElemInfo <> nil then\n      FastFinalizeArray(Value^, ElemInfo, p^.length);\n    Freemem(p);\n  end;\n  Value^ := nil;\nend;\n\nfunction FastRecordClear(Value: pointer; Info: PRttiInfo): PtrInt;\nvar\n  fields: TRttiRecordManagedFields;\n  f: PRttiRecordField;\n  p: PRttiInfo;\n  n: PtrInt;\n  fin: PRttiFinalizers;\nbegin\n  // caller ensured Info is indeed a record/object\n  Info.RecordManagedFields(fields);\n  n := fields.Count;\n  if n > 0 then\n  begin\n    fin := @RTTI_FINALIZE;\n    f := fields.Fields;\n    repeat\n      p := f^.{$ifdef HASDIRECTTYPEINFO}TypeInfo{$else}TypeInfoRef^{$endif};\n      {$ifdef FPC_OLDRTTI}\n      if Assigned(fin[p^.Kind]) then\n      {$endif FPC_OLDRTTI}\n        fin[p^.Kind](PAnsiChar(Value) + f^.Offset, p);\n      inc(f);\n      dec(n);\n    until n = 0;\n  end;\n  result := fields.Size;\nend;\n\nprocedure RecordZero(Dest: pointer; Info: PRttiInfo);\nbegin\n  if Info^.Kind in rkRecordTypes then\n    FillCharFast(Dest^, FastRecordClear(Dest, Info), 0);\nend;\n\nprocedure RecordCopy(var Dest; const Source; Info: PRttiInfo);\nbegin\n  if Info^.Kind in rkRecordTypes then\n    RTTI_MANAGEDCOPY[rkRecord](@Dest, @Source, Info);\nend;\n\nprocedure _RecordCopySeveral(Dest, Source: PAnsiChar; n: PtrInt; Info: PRttiInfo);\nvar\n  fields: TRttiRecordManagedFields;\n  f: PRttiRecordField;\n  p: PRttiInfo;\n  i, offset: PtrUInt;\nbegin\n  Info^.RecordManagedFields(fields); // retrieve RTTI once for all items\n  repeat\n    i := fields.Count;\n    offset := 0;\n    if i > 0 then\n    begin\n      f := fields.Fields;\n      repeat\n        p := f^.{$ifdef HASDIRECTTYPEINFO}TypeInfo{$else}TypeInfoRef^{$endif};\n        {$ifdef FPC_OLDRTTI}\n        if p^.Kind in rkManagedTypes then\n        {$endif FPC_OLDRTTI}\n        begin\n          offset := f^.Offset - offset;\n          if offset <> 0 then\n          begin\n            MoveFast(Source^, Dest^, offset);\n            inc(Source, offset);\n            inc(Dest, offset);\n          end;\n          offset := RTTI_MANAGEDCOPY[p^.Kind](Dest, Source, p);\n          inc(Source, offset);\n          inc(Dest, offset);\n          inc(offset, f^.Offset);\n        end;\n        inc(f);\n        dec(i);\n      until i = 0;\n    end;\n    offset := PtrUInt(fields.Size) - offset;\n    if offset <> 0 then\n    begin\n      MoveFast(Source^, Dest^, offset);\n      inc(Source, offset);\n      inc(Dest, offset);\n    end;\n    dec(n);\n  until n = 0;\nend;\n\nprocedure CopySeveral(Dest, Source: PByte; SourceCount: PtrInt;\n  ItemInfo: PRttiInfo; ItemSize: PtrInt);\nvar\n  cop: TRttiCopier;\n  elemsize: PtrInt;\nlabel\n  raw;\nbegin\n  if SourceCount > 0 then\n    if ItemInfo = nil then // unmanaged items\nraw:  MoveFast(Source^, Dest^, ItemSize * SourceCount)\n    else if ItemInfo^.Kind in rkRecordTypes then\n      // retrieve record/object RTTI once for all items\n      _RecordCopySeveral(pointer(Dest), pointer(Source), SourceCount, ItemInfo)\n    else\n    begin\n      // loop the TRttiCopier function over all items\n      cop := RTTI_MANAGEDCOPY[ItemInfo^.Kind];\n      if Assigned(cop) then\n        repeat\n          elemsize := cop(Dest, Source, ItemInfo);\n          inc(Source, elemsize);\n          inc(Dest, elemsize);\n          dec(SourceCount);\n        until SourceCount = 0\n      else\n        goto raw;\n    end;\nend;\n\nfunction DynArrayNew(Dest: PPointer; Count, ItemSize: PtrInt): pointer;\nbegin\n  result := AllocMem(Count * ItemSize +  SizeOf(TDynArrayRec));\n  PDynArrayRec(result)^.refCnt := 1;\n  PDynArrayRec(result)^.length := Count;\n  inc(PDynArrayRec(result));\n  Dest^ := result;\nend;\n\nfunction DynArrayGrow(Dest: PPointer; Count, ItemSize: PtrInt): PAnsiChar;\nvar\n  old: PtrInt;\nbegin\n  result := Dest^;\n  dec(PDynArrayRec(result));\n  ReallocMem(result, (Count * ItemSize) + SizeOf(TDynArrayRec));\n  old := PDynArrayRec(result)^.length;\n  PDynArrayRec(result)^.length := Count;\n  inc(PDynArrayRec(result));\n  FillCharFast(result[old * ItemSize], (Count - old) * ItemSize, 0);\n  Dest^ := result;\nend;\n\nprocedure DynArrayCopy(Dest, Source: PPointer; Info: PRttiInfo;\n  SourceExtCount: PInteger);\nvar\n  n, itemsize: PtrInt;\n  iteminfo: PRttiInfo;\nbegin\n  iteminfo := Info^.DynArrayItemType(itemsize); // nil for unmanaged items\n  if Dest^ <> nil then\n    FastDynArrayClear(Dest, iteminfo);\n  Source := Source^;\n  if Source <> nil then\n  begin\n    if SourceExtCount <> nil then\n      n := SourceExtCount^\n    else\n      n := PDALen(PAnsiChar(Source) - _DALEN)^ + _DAOFF;\n    DynArrayNew(Dest, n, itemsize); // allocate zeroed memory\n    CopySeveral(Dest^, pointer(Source), n, iteminfo, itemsize);\n  end;\nend;\n\nprocedure DynArrayEnsureUnique(Value: PPointer; Info: PRttiInfo);\nvar\n  p: PDynArrayRec;\n  n, elemsize: PtrInt;\nbegin\n  p := Value^;\n  Value^ := nil;\n  dec(p);\n  if (p^.refCnt >= 0) and\n     ((p^.refCnt <= 1) or\n      DACntDecFree(p^.refCnt)) then\n    exit;\n  n := p^.length;\n  Info := Info^.DynArrayItemType(elemsize);\n  DynArrayNew(Value, n, elemsize); // allocate zeroed memory\n  inc(p);\n  CopySeveral(Value^, pointer(p), n, Info, elemsize);\nend;\n\nprocedure EnsureUnique(var Value: TIntegerDynArray);\nbegin\n  if (Value <> nil) and\n     (PDACnt(PAnsiChar(Value) - _DACNT)^ > 1) then\n    DynArrayEnsureUnique(@Value, TypeInfo(TIntegerDynArray));\nend;\n\nprocedure EnsureUnique(var Value: TRawUtf8DynArray); overload;\nbegin\n  if (Value <> nil) and\n     (PDACnt(PAnsiChar(Value) - _DACNT)^ > 1) then\n    DynArrayEnsureUnique(@Value, TypeInfo(TRawUtf8DynArray));\nend;\n\nprocedure EnsureUnique(var Value: TVariantDynArray); overload;\nbegin\n  if (Value <> nil) and\n     (PDACnt(PAnsiChar(Value) - _DACNT)^ > 1) then\n    DynArrayEnsureUnique(@Value, TypeInfo(TVariantDynArray));\nend;\n\n\n{ ************* Managed Types Finalization, Random or Copy }\n\n{ RTTI_FINALIZE[] implementation functions }\n\nfunction _StringClear(V: PPointer; Info: PRttiInfo): PtrInt;\nvar\n  p: PStrRec;\nbegin\n  p := V^;\n  if p <> nil then // works for both rkLString + rkUString\n  begin\n    V^ := nil;\n    dec(p);\n    if (p^.refCnt >= 0) and\n       StrCntDecFree(p^.refCnt) then\n      Freemem(p);\n  end;\n  result := SizeOf(V^);\nend;\n\nfunction _WStringClear(V: PWideString; Info: PRttiInfo): PtrInt;\nbegin\n  if V^ <> '' then\n    {$ifdef FPC}\n    Finalize(V^);\n    {$else}\n    V^ := '';\n    {$endif FPC}\n  result := SizeOf(V^);\nend;\n\nfunction _VariantClear(V: PVarData; Info: PRttiInfo): PtrInt;\nbegin\n  VarClear(Variant(V^));\n  result := SizeOf(V^);\nend;\n\nfunction _InterfaceClear(V: PInterface; Info: PRttiInfo): PtrInt;\nbegin\n  if V^ <> nil then\n    {$ifdef FPC}\n    Finalize(V^);\n    {$else}\n    V^ := nil;\n    {$endif FPC}\n  result := SizeOf(V^);\nend;\n\nfunction _DynArrayClear(V: PPointer; Info: PRttiInfo): PtrInt;\nvar\n  p: PDynArrayRec;\nbegin\n  p := V^;\n  if p <> nil then\n  begin\n    dec(p);\n    if (p^.refCnt >= 0) and\n       DACntDecFree(p^.refCnt) then\n    begin\n      Info := Info^.DynArrayItemType;\n      if Info <> nil then\n        FastFinalizeArray(V^, Info, p^.length);\n      Freemem(p);\n    end;\n    V^ := nil;\n  end;\n  result := SizeOf(V^);\nend;\n\nfunction _ArrayClear(V: PByte; Info: PRttiInfo): PtrInt;\nvar\n  n: PtrInt;\n  fin: TRttiFinalizer;\nbegin\n  Info := Info^.ArrayItemType(n, result);\n  if Info = nil then\n    FillCharFast(V^, result, 0)\n  else\n  begin\n    fin := RTTI_FINALIZE[Info^.Kind];\n    if Assigned(fin) then\n      repeat\n        inc(V, fin(V, Info));\n        dec(n);\n      until n = 0;\n  end;\nend;\n\nfunction _ObjClear(V: PObject; Info: PRttiInfo): PtrInt;\nbegin\n  if V^ <> nil then\n  begin\n    V^.Destroy;\n    V^ := nil;\n  end;\n  result := SizeOf(V^);\nend;\n\nfunction _ObjArrayClear(V: PPointer; Info: PRttiInfo): PtrInt;\nbegin\n  if V^ <> nil then\n  begin\n    RawObjectsClear(V^, PDALen(PAnsiChar(V^) - _DALEN)^ + _DAOFF);\n    _DynArrayClear(V, Info);\n  end;\n  result := SizeOf(V^);\nend;\n\n\n{ PT_RANDOM[] implementation functions }\n\nprocedure _NoRandom(V: PPointer; RC: TRttiCustom);\nbegin\nend;\n\n// we use SharedRandom since TLightLock may be faster than a threadvar\n\nprocedure _FillRandom(V: PByte; RC: TRttiCustom);\nbegin\n  SharedRandom.Fill(V, RC.Cache.Size);\nend;\n\nprocedure _StringRandom(V: PPointer; RC: TRttiCustom);\nvar\n  tmp: TShort31;\nbegin\n  SharedRandom.FillShort31(tmp);\n  FastSetStringCP(V^, @tmp[1], ord(tmp[0]), RC.Cache.CodePage);\nend;\n\nprocedure _WStringRandom(V: PWideString; RC: TRttiCustom);\nvar\n  tmp: TShort31;\n  i: PtrInt;\n  W: PWordArray;\nbegin\n  SharedRandom.FillShort31(tmp);\n  SetString(V^, PWideChar(nil), ord(tmp[0]));\n  W := pointer(V^);\n  for i := 1 to ord(tmp[0]) do\n    W[i - 1] := cardinal(PByteArray(@tmp)[i]);\nend;\n\n{$ifdef HASVARUSTRING}\nprocedure _UStringRandom(V: PUnicodeString; RC: TRttiCustom);\nvar\n  tmp: TShort31;\n  i: PtrInt;\n  W: PWordArray;\nbegin\n  SharedRandom.FillShort31(tmp);\n  SetString(V^, PWideChar(nil), ord(tmp[0]));\n  W := pointer(V^);\n  for i := 1 to ord(tmp[0]) do\n    W[i - 1] := cardinal(PByteArray(@tmp)[i]);\nend;\n{$endif HASVARUSTRING}\n\nprocedure _VariantRandom(V: PRttiVarData; RC: TRttiCustom);\nbegin\n  VarClearAndSetType(Variant(V^), varEmpty);\n  V^.Data.VInt64 := SharedRandom.Next;\n  // generate some 8-bit 32-bit 64-bit integers or a RawUtf8 varString\n  case V^.Data.VInteger and 3 of\n    0:\n      V^.VType := varInteger;\n    1:\n      V^.VType := varInt64;\n    2:\n      V^.VType := varByte;\n    3:\n      begin\n        V^.VType := varString;\n        V^.Data.VAny := nil;\n        _StringRandom(@V^.Data.VAny, RC);\n      end;\n  end;\nend;\n\nprocedure _DoubleRandom(V: PDouble; RC: TRttiCustom);\nbegin\n  V^ := SharedRandom.NextDouble;\nend;\n\nprocedure _DateTimeRandom(V: PDouble; RC: TRttiCustom);\nbegin\n  V^ := 38000 + Int64(SharedRandom.Next) / (maxInt shr 12);\nend;\n\nprocedure _SingleRandom(V: PSingle; RC: TRttiCustom);\nbegin\n  V^ := SharedRandom.NextDouble;\nend;\n\nvar\n  PT_RANDOM: array[TRttiParserType] of pointer = (\n    @_NoRandom,       //  ptNone\n    @_NoRandom,       //  ptArray\n    @_FillRandom,     //  ptBoolean\n    @_FillRandom,     //  ptByte\n    @_FillRandom,     //  ptCardinal\n    @_FillRandom,     //  ptCurrency\n    @_DoubleRandom,   //  ptDouble\n    @_NoRandom,       //  ptExtended\n    @_FillRandom,     //  ptInt64\n    @_FillRandom,     //  ptInteger\n    @_FillRandom,     //  ptQWord\n    @_StringRandom,   //  ptRawByteString\n    @_NoRandom,       //  ptRawJson\n    @_StringRandom,   //  ptRawUtf8\n    @_NoRandom,       //  ptRecord\n    @_SingleRandom,   //  ptSingle\n    {$ifdef UNICODE}\n    @_UStringRandom,\n    {$else}           //  ptString\n    @_StringRandom,\n    {$endif UNICODE}\n    {$ifdef HASVARUSTRING}\n    @_UStringRandom,\n    {$else}           //  ptSynUnicode\n    @_WStringRandom,\n    {$endif HASVARUSTRING}\n    @_DateTimeRandom, //  ptDateTime\n    @_DateTimeRandom, //  ptDateTimeMS\n    @_FillRandom,     //  ptGuid\n    @_FillRandom,     //  ptHash128\n    @_FillRandom,     //  ptHash256\n    @_FillRandom,     //  ptHash512\n    @_NoRandom,       //  ptOrm\n    @_FillRandom,     //  ptTimeLog\n    {$ifdef HASVARUSTRING}\n    @_UStringRandom,\n    {$else}           //  ptUnicodeString\n    @_NoRandom,\n    {$endif HASVARUSTRING}\n    @_FillRandom,     //  ptUnixTime\n    @_FillRandom,     //  ptUnixMSTime\n    @_VariantRandom,  //  ptVariant\n    @_WStringRandom,  //  ptWideString\n    @_StringRandom,   //  ptWinAnsi\n    @_FillRandom,     //  ptWord\n    @_FillRandom,     //  ptEnumeration\n    @_FillRandom,     //  ptSet\n    @_NoRandom,       //  ptClass\n    @_NoRandom,       //  ptDynArray\n    @_NoRandom,       //  ptInterface\n    @_NoRandom,       //  ptPUtf8Char is read-only\n    @_NoRandom);      //  ptCustom\n\n\n{ RTTI_MANAGEDCOPY[] implementation functions }\n\nfunction _LStringCopy(Dest, Source: PRawByteString; Info: PRttiInfo): PtrInt;\nbegin\n  if (Source^ <> '') or\n     (Dest^ <> '') then\n    Dest^ := Source^;\n  result := SizeOf(Source^);\nend;\n\n{$ifdef HASVARUSTRING}\nfunction _UStringCopy(Dest, Source: PUnicodeString; Info: PRttiInfo): PtrInt;\nbegin\n  if (Source^ <> '') or\n     (Dest^ <> '') then\n    Dest^ := Source^;\n  result := SizeOf(Source^);\nend;\n{$endif HASVARUSTRING}\n\nfunction _WStringCopy(Dest, Source: PWideString; Info: PRttiInfo): PtrInt;\nbegin\n  if (Source^ <> '') or\n     (Dest^ <> '') then\n    Dest^ := Source^;\n  result := SizeOf(Source^);\nend;\n\nfunction _VariantCopy(Dest, Source: PVarData; Info: PRttiInfo): PtrInt;\nvar\n  vt: cardinal;\nlabel\n  rtl, raw;\nbegin\n  vt := Source^.VType;\n  VarClearAndSetType(Variant(Dest^), vt);\n  if vt > varNull then\n    // varEmpty,varNull need no copy\n    if vt <= varWord64 then\n      // most used types\n      if (vt < varOleStr) or\n         (vt > varError) then\nraw:    // copy any simple value (e.g. ordinal, varByRef)\n        Dest^.VInt64 := Source^.VInt64\n      else if vt = varOleStr then\n      begin\n        // copy WideString with reference counting\n        Dest^.VAny := nil;\n        WideString(Dest^.VAny) := WideString(Source^.VAny)\n      end\n      else\n        // varError, varDispatch\n        goto rtl\n    else if vt = varString then\n    begin\n      // copy AnsiString with reference counting\n      Dest^.VAny := nil;\n      RawByteString(Dest^.VAny) := RawByteString(Source^.VAny)\n    end\n    else if vt >= varByRef then\n      // varByRef has no refcount -> copy VPointer\n      goto raw\n    {$ifdef HASVARUSTRING}\n    else if vt = varUString then\n    begin\n      // copy UnicodeString with reference counting\n      Dest^.VAny := nil;\n      UnicodeString(Dest^.VAny) := UnicodeString(Source^.VAny)\n    end\n    {$endif HASVARUSTRING}\n    else\nrtl:  // copy any complex type via the RTL function of the variants unit\n      VarCopyProc(Dest^, Source^);\n  result := SizeOf(Source^);\nend;\n\nfunction _Per1Copy(Dest, Source: PByte; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // only called from TRttiCustom.ValueCopy which ignore this\nend;\n\nfunction _Per2Copy(Dest, Source: PWord; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // ignored\nend;\n\nfunction _Per4Copy(Dest, Source: PInteger; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // ignored\nend;\n\nfunction _Per8Copy(Dest, Source: PInt64; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // ignored\nend;\n\nfunction _Per16Copy(Dest, Source: PHash128; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // ignored\nend;\n\nfunction _Per32Copy(Dest, Source: PHash256; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := 0; // ignored\nend;\n\nfunction _InterfaceCopy(Dest, Source: PInterface; Info: PRttiInfo): PtrInt;\nbegin\n  Dest^ := Source^;\n  result := SizeOf(Source^);\nend;\n\nfunction _RecordCopy(Dest, Source: PByte; Info: PRttiInfo): PtrInt;\nvar\n  fields: TRttiRecordManagedFields; // Size/Count/Fields\n  offset: PtrUInt;\n  f: PRttiRecordField;\n  cop: PRttiCopiers;\nbegin\n  Info^.RecordManagedFields(fields);\n  f := fields.Fields;\n  cop := @RTTI_MANAGEDCOPY;\n  offset := 0;\n  while fields.Count <> 0 do\n  begin\n    dec(fields.Count);\n    Info := f^.{$ifdef HASDIRECTTYPEINFO}TypeInfo{$else}TypeInfoRef^{$endif};\n    {$ifdef FPC_OLDRTTI}\n    if Info^.Kind in rkManagedTypes then\n    {$endif FPC_OLDRTTI}\n    begin\n      offset := f^.Offset - offset;\n      if offset <> 0 then\n      begin\n        MoveFast(Source^, Dest^, offset);\n        inc(Source, offset);\n        inc(Dest, offset);\n      end;\n      offset := cop[Info^.Kind](Dest, Source, Info);\n      inc(Source, offset);\n      inc(Dest, offset);\n      inc(offset, f^.Offset);\n    end;\n    inc(f);\n  end;\n  offset := PtrUInt(fields.Size) - offset;\n  if offset > 0 then\n    MoveFast(Source^, Dest^, offset);\n  result := fields.Size;\nend;\n\nfunction _DynArrayCopy(Dest, Source: PPointer; Info: PRttiInfo): PtrInt;\nbegin\n  DynArrayCopy(Dest, Source, Info, {extcount=}nil);\n  result := SizeOf(Source^);\nend;\n\nfunction _ArrayCopy(Dest, Source: PByte; Info: PRttiInfo): PtrInt;\nvar\n  n, itemsize: PtrInt;\n  cop: TRttiCopier;\nlabel\n  raw;\nbegin\n  Info := Info^.ArrayItemType(n, result);\n  if Info = nil then\nraw:MoveFast(Source^, Dest^, result)\n  else\n  begin\n    cop := RTTI_MANAGEDCOPY[Info^.Kind];\n    if Assigned(cop) then\n      repeat\n        itemsize := cop(Dest ,Source, Info);\n        inc(Source, itemsize);\n        inc(Dest, itemsize);\n        dec(n);\n      until n = 0\n    else\n      goto raw;\n  end;\nend;\n\n\n{ RTTI-based FillZero() }\n\nprocedure FillZeroRtti(Info: PRttiInfo; var Value);\nvar\n  nfo: TRttiCustom;\n  fin: TRttiFinalizer;\n  da: PDynArrayRec;\n  i, siz: PtrInt;\n  v: PAnsiChar;\n  p: PRttiCustomProp;\nbegin\n  if Info = nil then\n    exit;\n  nfo := nil; // is set below for rkClass/rkRecord\n  case Info^.Kind of\n    {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n    rkRecord:\n      nfo := Rtti.RegisterType(Info);\n    {$ifdef FPC}\n    rkLStringOld,\n    {$endif FPC}\n    rkLString:\n      FillZero(RawByteString(Value));\n    {$ifdef HASVARUSTRING}\n    rkUString:\n      FillZero(UnicodeString(Value));\n    {$endif HASVARUSTRING}\n    rkVariant:\n      if TVarData(Value).VType = varString then\n        FillZero(RawByteString(TVarData(Value).VAny));\n    rkClass:\n      if TObject(Value) <> nil then\n        nfo := Rtti.RegisterClass(TObject(Value));\n    rkDynArray:\n      begin\n        da := PPointer(Value)^;\n        if da <> nil then\n        begin\n          dec(da);\n          if (da^.refCnt >= 0) and\n             DACntDecFree(da^.refCnt) then\n          begin\n            Info := Info^.DynArrayItemType(siz);\n            v := PPointer(Value)^;\n            if Info <> nil then\n              for i := 1 to da^.length do\n              begin\n                FillZeroRtti(Info, v^); // process nested items\n                inc(v, siz);\n              end\n            else\n              FillCharFast(v^, da^.length * siz, 0); // e.g. for TBytes\n            Freemem(da);\n          end;\n          PPointer(Value)^ := nil;\n        end;\n        exit;\n      end;\n  end;\n  if nfo <> nil then\n  begin\n    p := pointer(nfo.Props.List); // for both records and classes\n    if Info^.Kind = rkClass then\n      v := PPointer(Value)^ // classes are passed by reference\n    else\n      v := @Value;          // records are passed by value\n    for i := 1 to nfo.Props.Count do\n    begin\n      if (p^.OffsetSet >= 0) and\n         (p^.Value <> nil) and\n         (p^.Value.Info <> nil) and\n         not (rcfIsNumber in p^.Value.Cache.Flags) then\n        FillZeroRtti(p^.Value.Info, v[p^.OffsetSet]); // process nested fields\n      inc(p);\n    end;\n  end;\n  fin := RTTI_FINALIZE[Info^.Kind];\n  if Assigned(fin) then\n    fin(@Value, Info);\nend;\n\n\n{ ************** RTTI Value Types used for JSON Parsing }\n\nfunction ParserTypeToTypeInfo(pt: TRttiParserType;\n  pct: TRttiParserComplexType): PRttiInfo;\nbegin\n  result := PTC_INFO[pct];\n  if result = nil then\n    result := PT_INFO[pt];\nend;\n\n// called from TRttiCustomList.RegisterTypeFromName and TRttiCustom.Create\n// if Rtti.Find(Name, NameLen) did not have any match\n// -> detect array/record keywords, integer/cardinal types, T*ID pattern\nfunction AlternateTypeNameToRttiParserType(Name: PUtf8Char; NameLen: integer;\n  Complex: PRttiParserComplexType = nil; Kind: TRttiKind = rkUnknown): TRttiParserType;\nbegin\n  result := ptNone;\n  if Complex <> nil then\n    Complex^ := pctNone;\n  case NameLen of\n    5:\n      if IdemPropNameUSameLenNotNull(Name, 'array', 5) then\n        result := ptArray;\n    6:\n      {$ifdef FPC}\n      // TypeInfo(string)=TypeInfo(AnsiString) on FPC\n      if IdemPropNameUSameLenNotNull(Name, 'string', 6) then\n        result := ptString\n      else\n      {$endif FPC}\n      if IdemPropNameUSameLenNotNull(Name, 'record', 6) then\n        result := ptRecord;\n    // TypeInfo(integer/cardinal)=TypeInfo(LongInt/LongWord) on FPC\n    7:\n      if IdemPropNameUSameLenNotNull(Name,\n          {$ifdef FPC}'integer'{$else}'longint'{$endif}, 7) then\n        result := ptInteger;\n    8:\n      if IdemPropNameUSameLenNotNull(Name,\n           {$ifdef FPC}'cardinal'{$else}'longword'{$endif}, 8) then\n        result := ptCardinal;\n  end;\n  if (result = ptNone) and\n     (Complex <> nil) and\n     (Kind = rkInt64) and\n     (NameLen < 200) and\n     (Name[0] = 'T') and // T...ID pattern in name?\n     (PWord(@Name[NameLen - 2])^ and $dfdf = ord('I') + ord('D') shl 8) then\n  begin\n    result := ptOrm;\n    Complex^ := pctSpecificClassID;\n  end;\nend;\n\n// called internally by TRttiCustom.Create - can't use Rtti.RegisterType()\nfunction GuessTypeInfoToStandardParserType(Info: PRttiInfo;\n  Complex: PRttiParserComplexType): TRttiParserType;\nvar\n  c: TRttiParserComplexType;\n  ndx: PtrInt;\n  cp: integer;\nbegin                                            \n  result := ptNone;\n  if Complex <> nil then\n    Complex^ := pctNone;\n  if Info = nil then\n    exit;\n  // search if it is a known standard type from PT_INFO[]/PTC_INFO[]\n  ndx := PtrUIntScanIndex(@PT_INFO, length(PT_INFO), PtrUInt(Info));\n  if ndx >= 0 then\n  begin\n    result := TRttiParserType(ndx);\n    if not (result in ptComplexTypes) then\n      exit;\n  end;\n  for c := succ(low(c)) to high(c) do\n    if PTC_INFO[c] = Info then // complex ORM types as set by mormot.orm.base\n      if PTC_PT[c] <> ptNone then\n      begin\n        result := PTC_PT[c];\n        if Complex <> nil then\n          Complex^ := c;\n        exit;\n      end\n      else\n        break;\n  // array/record keywords, integer/cardinal FPC types, T*ID pattern\n  result := AlternateTypeNameToRttiParserType(\n    @Info^.RawName[1], ord(Info^.RawName[0]), Complex, Info^.Kind);\n  if result <> ptNone then\n    exit; // found by name\n  // fallback to the closed known type, using RTTI\n  case Info^.Kind of\n    // FPC and Delphi will use a fast jmp table\n  {$ifdef FPC}\n    rkLStringOld,\n  {$endif FPC}\n    rkLString: // PT_INFO[ptRawUtf8/ptRawJson] have been found above\n      begin\n        cp := Info^.AnsiStringCodePage;\n        if cp = CP_UTF8 then\n          result := ptRawUtf8\n        else if cp = CP_WINANSI then\n          result := ptWinAnsi\n        else if cp >= CP_RAWBLOB then\n          result := ptRawByteString\n        {$ifndef UNICODE}\n        else if (cp = CP_ACP) or\n                (cp = Unicode_CodePage) then\n          result := ptString\n        {$endif UNICODE}\n        else\n          result := ptRawUtf8; // fallback to UTF-8 string\n      end;\n    rkWString:\n      result := ptWideString;\n  {$ifdef HASVARUSTRING}\n    rkUString:\n      result := ptUnicodeString;\n  {$endif HASVARUSTRING}\n  {$ifdef FPC_OR_UNICODE}\n    {$ifdef UNICODE}\n    rkProcedure,\n    {$endif UNICODE}\n    rkClassRef,\n    rkPointer:\n      result := ptPtrInt;\n  {$endif FPC_OR_UNICODE}\n    rkVariant:\n      result := ptVariant;\n    rkArray:\n      result := ptArray;\n    rkDynArray:\n      result := ptDynArray;\n    {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n    rkRecord:\n      result := ptRecord;\n    rkChar:\n      result := ptByte;\n    rkWChar:\n      result := ptWord;\n    rkMethod:\n      result := ptPtrInt;\n    rkInterface:\n      result := ptInterface;\n    rkInteger:\n      case Info^.RttiOrd of\n        roSByte,\n        roUByte:\n          result := ptByte;\n        roSWord,\n        roUWord:\n          result := ptWord;\n        roSLong:\n          result := ptInteger;\n        roULong:\n          result := ptCardinal;\n      {$ifdef FPC_NEWRTTI}\n        roSQWord:\n          result := ptInt64;\n        roUQWord:\n          result := ptQWord;\n      {$endif FPC_NEWRTTI}\n      end;\n    rkInt64:\n    {$ifdef ISDELPHI}\n      if Info^.IsQWord then\n        result := ptQWord\n      else\n    {$endif ISDELPHI}\n      // PT_INFO[ptOrm/ptTimeLog/ptUnixTime] have been found above\n      result := ptInt64;\n  {$ifdef FPC}\n    rkQWord:\n      result := ptQWord;\n    rkBool:\n      result := ptBoolean;\n  {$endif FPC}\n    rkEnumeration:\n    {$ifdef ISDELPHI}\n      if Info^.IsBoolean then\n        result := ptBoolean\n      else\n    {$endif ISDELPHI}\n        result := ptEnumeration;\n    rkSet:\n      result := ptSet;\n    rkClass:\n      result := ptClass;\n    rkFloat:\n      case Info^.RttiFloat of\n        rfSingle:\n          result := ptSingle;\n        rfDouble:\n          // PT_INFO[ptDateTime/ptDateTimeMS] have been found above\n          result := ptDouble;\n        rfCurr:\n          result := ptCurrency;\n        rfExtended:\n          result := ptExtended;\n        // rfComp: not implemented yet\n      end;\n  end;\nend;\n\nfunction SizeToDynArrayKind(size: integer): TRttiParserType;\n  {$ifdef HASINLINE}inline;{$endif}\nbegin  // rough estimation\n  case size of\n    1:\n      result := ptByte;\n    2:\n      result := ptWord;\n    4:\n      result := ptInteger;\n    8:\n      result := ptInt64;\n    16:\n      result := ptHash128;\n    32:\n      result := ptHash256;\n    64:\n      result := ptHash512;\n  else\n    result := ptNone;\n  end;\nend;\n\nvar\n  PT_DYNARRAY: array[TRttiParserType] of pointer; // most simple dynamic arrays\n\nfunction TypeInfoToDynArrayTypeInfo(ElemInfo: PRttiInfo;\n  ExpectExactElemInfo: boolean; ParserType: PRttiParserType): PRttiInfo;\nvar\n  rc: TRttiCustom;\nbegin\n  // search using item RTTI and PT_DYNARRAY[] known arrays\n  rc := Rtti.RegisterType(ElemInfo);\n  if rc = nil then\n  begin\n    result := nil; // paranoid\n    exit;\n  end;\n  result := PT_DYNARRAY[rc.parser];\n  if result <> nil then\n  begin\n    if ParserType <> nil then\n      ParserType^ := rc.Parser;\n    if (not ExpectExactElemInfo) or\n       (PT_INFO[rc.parser] = ElemInfo) then\n      exit;\n    rc := Rtti.RegisterType(result);\n    if (rc.ArrayRtti <> nil) and\n       (rc.ArrayRtti.Info = ElemInfo) then\n      exit;\n  end;\n  // search in registered rkDynArray for complex types (e.g. ptRecord)\n  rc := Rtti.FindByArrayRtti(ElemInfo);\n  if rc <> nil then\n  begin\n    if ParserType <> nil then\n      ParserType^ := rc.ArrayRtti.Parser;\n    result := rc.Info;\n  end;\nend;\n\n// call from TRttiCustom.Create (maybe via GuessItemTypeFromDynArrayInfo)\nfunction GuessItemTypeFromDynArrayInfo(DynArrayInfo, ElemInfo: PRttiInfo;\n  ElemSize: integer; ExactType: boolean; out FieldSize: integer;\n  Complex: PRttiParserComplexType = nil): TRttiParserType;\n// warning: we can't use TRttiInfo.RecordAllFields since it would break\n// backward compatibility and code expectations\nvar\n  fields: TRttiRecordManagedFields;\n  offset: integer;\n  pt: TRttiParserType;\nbegin\n  result := ptNone;\n  if Complex <> nil then\n    Complex^ := pctNone;\n  FieldSize := 0;\n  // fast guess of most known ArrayType\n  if (DynArrayInfo <> nil) and\n     ((ElemInfo = nil) or\n      not(ElemInfo^.Kind in [rkEnumeration, rkSet, rkDynArray, rkClass])) then\n    for pt := ptBoolean to ptWord do\n      if PT_DYNARRAY[pt] = DynArrayInfo then\n      begin\n        result := pt;\n        break;\n      end;\n  if result = ptNone then\n    repeat\n      // guess from RTTI of nested record(s)\n      if ElemInfo = nil then\n      begin\n        result := SizeToDynArrayKind(ElemSize);\n        if result = ptNone then\n          FieldSize := ElemSize;\n      end\n      else\n      // try to guess from 1st record/object field\n      if not exactType and\n         (ElemInfo^.Kind in rkRecordTypes) then\n      begin\n        ElemInfo.RecordManagedFields(fields);\n        if fields.Count = 0 then\n        begin\n          ElemInfo := nil;\n          continue;\n        end;\n        offset := fields.Fields^.Offset;\n        if offset <> 0 then\n        begin\n          result := SizeToDynArrayKind(offset);\n          if result = ptNone then\n            FieldSize := offset;\n        end\n        else\n        begin\n          ElemInfo := fields.Fields^.\n            {$ifdef HASDIRECTTYPEINFO}TypeInfo{$else}TypeInfoRef^{$endif};\n          if (ElemInfo = nil) or\n             (ElemInfo^.Kind in rkRecordTypes) then\n            continue; // nested records\n          result := GuessTypeInfoToStandardParserType(ElemInfo, Complex);\n          if result = ptNone then\n          begin\n            ElemInfo := nil;\n            continue;\n          end;\n        end;\n      end;\n      break;\n    until false;\n  if result = ptNone then\n    // will recognize simple arrays from TypeName and ElemType\n    result := GuessTypeInfoToStandardParserType(ElemInfo, Complex);\n  if PT_SIZE[result] <> 0 then\n    FieldSize := PT_SIZE[result];\nend;\n\n\n\n{ ************** RTTI-based Registration for Custom JSON Parsing }\n\n{ TRttiCustomProp }\n\nfunction TRttiCustomProp.InitFrom(RttiProp: PRttiProp): PtrInt;\nvar\n  addr: PtrInt;\nbegin\n  Value := Rtti.RegisterType(RttiProp^.TypeInfo);\n  if Value = nil then\n    raise ERttiException.CreateUtf8('TRttiCustom: % property has no RTTI',\n      [RttiProp^.Name^]);\n  addr := PtrInt(RttiProp^.GetFieldAddr(nil));\n  // GetterCall/SetterCall will handle void \"read\"/\"write\" attributes\n  OffsetGet := -1;\n  OffsetSet := -1;\n  if RttiProp^.GetterCall = rpcField then\n    OffsetGet := addr;\n  if RttiProp^.SetterCall = rpcField then\n    OffsetSet := addr;\n  Name := ToUtf8(RttiProp^.Name^);\n  fOrigName := Name;\n  Prop := RttiProp;\n  OrdinalDefault := NO_DEFAULT;\n  if rcfHasRttiOrd in Value.Cache.Flags then\n    OrdinalDefault := RttiProp.Default;\n  Stored := RttiProp^.IsStoredKind;\n  result := Value.Size;\nend;\n\nfunction TRttiCustomProp.NameMatch(P: PUtf8Char; Len: PtrInt): boolean;\nvar\n  n: PUtf8Char;\nbegin // inlined IdemPropNameUSameLenNotNull()\n  result := false;\n  n := pointer(Name);\n  if (n = nil) or // Name='' after NameChange()\n     (PStrLen(n - _STRLEN)^ <> Len) then\n    exit;\n  pointer(Len) := @PUtf8Char(n)[Len - SizeOf(cardinal)];\n  dec(PtrUInt(P), PtrUInt(n));\n  while PtrUInt(n) < PtrUInt(Len) do\n    // compare 4 Bytes per loop\n    if (PCardinal(n)^ xor PCardinal(P + PtrUInt(n))^) and $dfdfdfdf <> 0 then\n      exit\n    else\n      inc(PCardinal(n));\n  inc(Len, SizeOf(cardinal));\n  while PtrUInt(n) < PtrUInt(Len) do\n    if (ord(n^) xor ord(P[PtrUInt(n)])) and $df <> 0 then\n      exit\n    else\n      inc(PByte(n));\n  result := true;\nend;\n\nprocedure TRttiCustomProp.GetValue(Data: pointer; out RVD: TRttiVarData);\nbegin\n  if (Prop = nil) or\n     (OffsetGet >= 0 ) then\n    // direct memory access of the value (classes and records)\n    GetValueDirect(Data, RVD)\n  else\n    // need a class property getter\n    GetValueGetter(Data, RVD);\nend;\n\nprocedure TRttiCustomProp.GetValueVariant(Data: pointer; out Dest: TVarData;\n  Options: pointer{PDocVariantOptions});\nvar\n  a: pointer;\nbegin\n  if (Prop = nil) or\n     (OffsetGet >= 0) then\n    Value.ValueToVariant(PAnsiChar(Data) + OffsetGet, Dest, Options)\n  else if Value.Cache.RttiVarDataVType <> varAny then\n    GetValueGetter(Data, TRttiVarData(Dest)) // not TRttiVarData specific\n  else if Value.Cache.VarDataVType = varInt64 then // rkEnumeration, rkSet\n  begin\n    Dest.VType := varInt64;\n    Dest.VInt64 := Prop^.GetInt64Value(Data);\n  end\n  else if Value.Kind = rkDynArray then\n  begin\n    a := nil;\n    try\n      a := Prop^.GetDynArrayPropGetter(Data);\n      Value.ValueToVariant(@a, Dest, Options); // will create a TDocVariant\n    finally\n      FastDynArrayClear(@a, Value.ArrayRtti.Info);\n    end;\n  end;\nend;\n\nprocedure TRttiCustomProp.SetValue(Data: pointer; var RVD: TRttiVarData;\n  andclear: boolean);\nbegin\n  if Prop <> nil then\n    Prop.SetValue(TObject(Data), variant(RVD));\n  if andclear and\n     RVD.NeedsClear then\n    VarClearProc(RVD.Data);\n  if Prop = nil then // raise exception after NeedsClear to avoid memory leak\n    raise ERttiException.Create('TRttiCustomProp.SetValue: with Prop=nil');\nend;\n\nfunction TRttiCustomProp.SetValueText(Data: pointer; const Text: RawUtf8): boolean;\nbegin\n  if (Prop = nil) or\n     (OffsetSet >= 0) then\n    // direct fill value in memory (classes and records)\n    result := Value.ValueSetText(PAnsiChar(Data) + OffsetSet, Text)\n  else\n    // need a class property setter\n    result := Prop.SetValueText(Data, Text);\nend;\n\nprocedure TRttiCustomProp.AddValueJson(W: TTextWriter; Data: pointer;\n  Options: TTextWriterWriteObjectOptions; K: TTextWriterKind);\nvar\n  rvd: TRttiVarData;\nbegin\n  GetValue(Data, rvd);\n  if K <> twOnSameLine then\n    if Value.Parser = ptRawJson then\n      K := twNone\n    else\n      K := twJsonEscape;\n  W.AddVariant(variant(rvd), K, Options);\n  if rvd.NeedsClear then\n    VarClearProc(rvd.Data);\nend;\n\nprocedure TRttiCustomProp.GetValueJson(Data: pointer; out Result: RawUtf8);\nvar\n  w: TTextWriter;\n  tmp: TTextWriterStackBuffer;\nbegin\n  w := DefaultJsonWriter.CreateOwnedStream(tmp);\n  try\n    AddValueJson(w, Data, []);\n    w.SetText(Result);\n  finally\n    w.Free;\n  end;\nend;\n\nfunction TRttiCustomProp.ValueIsDefault(Data: pointer): boolean;\nbegin\n  if rcfHasRttiOrd in Value.Cache.Flags then\n    if OffsetGet >= 0 then\n      result := RTTI_FROM_ORD[Value.Cache.RttiOrd](\n                  PAnsiChar(Data) + OffsetGet) = OrdinalDefault\n    else\n      result := Prop.GetOrdProp(Data) = OrdinalDefault\n  else if rcfGetInt64Prop in Value.Cache.Flags then\n    if OffsetGet >= 0 then\n      result := PInt64(PAnsiChar(Data) + OffsetGet)^ = OrdinalDefault\n    else\n      result := Prop.GetInt64Prop(Data) = OrdinalDefault\n  else\n    // only ordinals have default values\n    result := false;\nend;\n\nfunction TRttiCustomProp.ValueIsVoid(Data: pointer): boolean;\nbegin\n  // we assume the caller ensured Data<>nil\n  if OffsetGet >= 0 then\n    // direct check value from field in memory\n    result := Value.ValueIsVoid(PAnsiChar(Data) + OffsetGet)\n  else\n    // slightly slower method using a getter\n    result := ValueIsVoidGetter(Data);\nend;\n\nfunction TRttiCustomProp.ValueIsVoidGetter(Data: pointer): boolean;\nvar\n  rvd: TRttiVarData;\nbegin\n  if Prop = nil then\n    result := true\n  else if Value.Kind = rkClass then\n    result := IsObjectDefaultOrVoid(Prop.GetObjProp(Data))\n  else\n  begin\n    GetValueGetter(Data, rvd);\n    case rvd.DataType of\n      varEmpty,\n      varNull:\n        result := true;\n      varAny,\n      varUnknown,\n      varString,\n      varOleStr\n      {$ifdef HASVARUSTRING}, varUString {$endif}:\n        result := rvd.Data.VAny = nil;\n      varSingle,\n      varInteger,\n      varLongWord:\n        result := rvd.Data.VInteger = 0;\n      varInt64,\n      varWord64,\n      varDate,\n      varDouble,\n      varCurrency,\n      varBoolean:\n        result := rvd.Data.VInt64 = 0;\n    else\n      result := false;\n    end;\n    if rvd.NeedsClear then\n      VarClearProc(rvd.Data);\n  end;\nend;\n\nprocedure TRttiCustomProp.GetValueDirect(Data: PByte; out RVD: TRttiVarData);\nbegin\n  inc(Data, OffsetGet);\n  RVD.VType := Value.Cache.RttiVarDataVType; // reset NeedsClear/ValueIsInstance\n  case RVD.VType of\n  varEmpty:\n    // void Data or unsupported TRttiKind\n    exit;\n  varInt64,\n  varBoolean:\n    // rkInteger, rkBool using VInt64 for proper cardinal support\n    RVD.Data.VInt64 := RTTI_FROM_ORD[Value.Cache.RttiOrd](Data);\n  varWord64:\n    // rkInt64, rkQWord\n    begin\n      if not (rcfQWord in Value.Cache.Flags) then\n        RVD.VType := varInt64;\n      RVD.Data.VInt64 := PInt64(Data)^;\n    end;\n  varSingle:\n    // copy this 32-bit type at binary level\n    RVD.Data.VInteger := PInteger(Data)^;\n  varDate,\n  varDouble,\n  varCurrency:\n    // copy those 64-bit types at binary level\n    RVD.Data.VInt64 := PInt64(Data)^;\n  varAny:\n    begin\n      // rkEnumeration,rkSet,rkDynArray,rkClass,rkInterface,rkRecord,rkObject\n      RVD.PropValue := Data; // keeping RVD.PropValueIsInstance=false\n      RVD.Prop := @self;\n      // varAny/Value handled by TJsonWriter.AddVariant/AddRttiVarData\n    end;\n  varUnknown:\n    // rkChar, rkWChar, rkSString converted into temporary RawUtf8\n    begin\n      RVD.VType := varString;\n      RVD.NeedsClear := true;\n      RVD.Data.VAny := nil; // avoid GPF\n      Value.Info.StringToUtf8(Data, RawUtf8(RVD.Data.VAny));\n    end;\n  else\n    // varString, varVariant, varOleStr, varUString are returned by reference\n    begin\n      RVD.Data.VAny := Data; // return the pointer to the value\n      RVD.VType := RVD.VType or varByRef // and access it by reference\n    end;\n  end;\nend;\n\nprocedure TRttiCustomProp.GetValueGetter(Instance: TObject;\n  out RVD: TRttiVarData);\nbegin\n  RVD.VType := Value.Cache.RttiVarDataVType; // reset NeedsClear/ValueIsInstance\n  case RVD.VType of\n  varEmpty:\n    // unsupported TRttiKind\n    exit;\n  varInt64,\n  varBoolean:\n    // rkInteger, rkBool\n    RVD.Data.VInt64 := Prop.GetOrdProp(Instance); // VInt64 for cardinal\n  varWord64:\n    // rkInt64, rkQWord\n    begin\n      if not (rcfQWord in Value.Cache.Flags) then\n        RVD.VType := varInt64;\n      RVD.Data.VInt64 := Prop.GetInt64Prop(Instance);\n    end;\n  varCurrency:\n    Prop.GetCurrencyProp(Instance, RVD.Data.VCurrency);\n  varSingle:\n    RVD.Data.VSingle := Prop.GetFloatProp(Instance);\n  varDate,\n  varDouble:\n    RVD.Data.VDouble := Prop.GetFloatProp(Instance);\n  varAny:\n    begin\n      // rkEnumeration,rkSet,rkDynArray,rkClass,rkInterface,rkRecord,rkObject\n      RVD.PropValueIsInstance := true;\n      RVD.PropValue := Instance;\n      RVD.Prop := @self;\n      // varAny/Value/Prop handled by TJsonWriter.AddVariant/AddRttiVarData\n    end;\n  varUnknown:\n    // rkChar, rkWChar, rkSString converted into temporary RawUtf8\n    begin\n      RVD.VType := varString;\n      RVD.Data.VAny := nil; // avoid GPF\n      Prop.GetAsString(Instance, RawUtf8(RVD.Data.VAny));\n      RVD.NeedsClear := RVD.Data.VAny <> nil; // if a RawUtf8 was allocated\n    end\n  else\n    // varString/varOleStr/varUString or varVariant\n    begin\n      RVD.Data.VAny := nil; // avoid GPF below\n      case Value.Kind of\n        rkLString:\n          Prop.GetLongStrProp(Instance, RawByteString(RVD.Data.VAny));\n        rkWString:\n          Prop.GetWideStrProp(Instance, WideString(RVD.Data.VAny));\n        {$ifdef HASVARUSTRING}\n        rkUString:\n          Prop.GetUnicodeStrProp(Instance, UnicodeString(RVD.Data.VAny));\n        {$endif HASVARUSTRING}\n        rkVariant:\n          begin\n            RVD.VType := varEmpty; // to fill as variant\n            Prop.GetVariantProp(Instance, variant(RVD), {byref=}false);\n            RVD.NeedsClear := true; // we allocated a RVD for the getter result\n            exit;\n          end;\n      end;\n      RVD.NeedsClear := RVD.Data.VAny <> nil;\n    end;\n  end;\nend;\n\nfunction TRttiCustomProp.CompareValueComplex(Data, Other: pointer;\n  OtherRtti: PRttiCustomProp; CaseInsensitive: boolean): integer;\nvar\n  v1, v2: TRttiVarData;\nbegin\n  // direct comparison of ordinal values (rkClass is handled below)\n  if (rcfHasRttiOrd in Value.Cache.Flags) and\n     (rcfHasRttiOrd in OtherRtti.Value.Cache.Flags) then\n  begin\n    if OffsetGet >= 0 then\n      v1.Data.VInt64 := RTTI_FROM_ORD[Value.Cache.RttiOrd](\n                          PAnsiChar(Data) + OffsetGet)\n    else\n      v1.Data.VInt64 := Prop.GetOrdProp(Data);\n    if OtherRtti.OffsetGet >= 0 then\n      v2.Data.VInt64 := RTTI_FROM_ORD[OtherRtti.Value.Cache.RttiOrd](\n                          PAnsiChar(Other) + OtherRtti.OffsetGet)\n    else\n      v2.Data.VInt64 := OtherRtti.Prop.GetOrdProp(Other);\n  end\n  else if (rcfGetInt64Prop in Value.Cache.Flags) and\n          (rcfGetInt64Prop in OtherRtti.Value.Cache.Flags) then\n  begin\n    if OffsetGet >= 0 then\n      v1.Data.VInt64 := PInt64(PAnsiChar(Data) + OffsetGet)^\n    else\n      v1.Data.VInt64 := Prop.GetInt64Prop(Data);\n    if OtherRtti.OffsetGet >= 0 then\n      v2.Data.VInt64 := PInt64(PAnsiChar(Other) + OtherRtti.OffsetGet)^\n    else\n      v2.Data.VInt64 := OtherRtti.Prop.GetInt64Prop(Other);\n  end\n  else\n  // comparison using temporary TRttiVarData (using varByRef if possible)\n  begin\n    GetValue(Data, v1);\n    OtherRtti.GetValue(Other, v2);\n    if (v1.Data.VType <> varAny) and\n       (v2.Data.VType <> varAny) then\n      // standard variant comparison function (from mormot.core.variants)\n      result := SortDynArrayVariantComp(v1.Data, v2.Data, CaseInsensitive)\n    else if (v1.Data.VType = v2.Data.VType) and\n            (OtherRtti.Value = Value) then\n      // v1 and v2 are both varAny, with the very same RTTI type -> use\n      // mormot.core.json efficient comparison (also handle rkClass/TObject)\n      result := Value.ValueCompare(v1.PropValue, v2.PropValue, CaseInsensitive)\n    else\n      // we don't know much about those fields: just compare the pointers\n      result := ComparePointer(v1.PropValue, v2.PropValue);\n    if v1.NeedsClear then\n      VarClearProc(v1.Data);\n    if v2.NeedsClear then\n      VarClearProc(v2.Data);\n    exit;\n  end;\n  result := CompareInt64(v1.Data.VInt64, v2.Data.VInt64);\nend;\n\nfunction TRttiCustomProp.CompareValue(Data, Other: pointer;\n  const OtherRtti: TRttiCustomProp; CaseInsensitive: boolean): integer;\nbegin\n  if (OtherRtti.Value = Value) and\n     (OffsetGet >= 0) and\n     (OtherRtti.OffsetGet >= 0) then\n    // two direct fields of the same type (this most common case is inlined)\n    result := Value.ValueCompare(PAnsiChar(Data) + OffsetGet,\n                PAnsiChar(Other) + OtherRtti.OffsetGet, CaseInsensitive)\n  else\n    // more complex properties comparison (not inlined)\n    result := CompareValueComplex(Data, Other, @OtherRtti, CaseInsensitive);\nend;\n\n\n{ TRttiCustomProps }\n\nfunction FindCustomProp(p: PRttiCustomProp; name: pointer; namelen: TStrLen;\n  count: integer): PRttiCustomProp;\nvar\n  p1, p2, l: PUtf8Char;\nlabel\n  no;\nbegin\n  result := p;\n  if result = nil then\n    exit;\n  p2 := name;\n  repeat\n    // inlined IdemPropNameUSameLenNotNull(p, name, namelen)\n    p1 := pointer(result^.Name);\n    if (p1 <> nil) and // Name may be '' after NameChange()\n       (PStrLen(p1 - _STRLEN)^ = namelen) then\n    begin\n      l := @p1[namelen - SizeOf(cardinal)];\n      dec(p2, PtrUInt(p1));\n      while PtrUInt(l) >= PtrUInt(p1) do\n        // compare 4 Bytes per loop\n        if (PCardinal(p1)^ xor PCardinal(@p2[PtrUInt(p1)])^) and $dfdfdfdf <> 0 then\n          goto no\n        else\n          inc(PCardinal(p1));\n      inc(PCardinal(l));\n      while PtrUInt(p1) < PtrUInt(l) do\n        // remaining bytes\n        if (ord(p1^) xor ord(p2[PtrUInt(p1)])) and $df <> 0 then\n          goto no\n        else\n          inc(PByte(p1));\n      exit; // match found\nno:   p2 := name;\n    end;\n    inc(result);\n    dec(count);\n  until count = 0;\n  result := nil;\nend;\n\nfunction TRttiCustomProps.Find(const PropName: RawUtf8): PRttiCustomProp;\nbegin\n  result := pointer(PropName);\n  if result <> nil then\n    result := FindCustomProp(pointer(List), pointer(PropName),\n      PStrLen(PAnsiChar(result) - _STRLEN)^, Count);\nend;\n\nfunction TRttiCustomProps.Find(PropName: PUtf8Char; PropNameLen: PtrInt): PRttiCustomProp;\nbegin\n  result := pointer(PropName);\n  if result <> nil then\n    result := FindCustomProp(pointer(List), PropName, PropNameLen, Count);\nend;\n\nfunction TRttiCustomProps.FindIndex(PropName: PUtf8Char; PropNameLen: PtrInt): PtrInt;\nvar\n  p: PRttiCustomProp;\nbegin\n  if PropNameLen <> 0 then\n  begin\n    p := pointer(List);\n    for result := 0 to Count - 1 do\n      if p^.NameMatch(PropName, PropNameLen) then\n        exit\n      else\n        inc(p);\n  end;\n  result := -1;\nend;\n\nfunction FromNames(p: PRttiCustomProp; n: integer; out names: RawUtf8): integer;\nbegin\n  result := 0;\n  if n <> 0 then\n    repeat\n      if p^.Name <> '' then\n      begin\n        inc(result);\n        names := {%H-}names + '\"' + p^.Name + '\",';  // include trailing ,\n      end;\n      inc(p);\n      dec(n);\n    until n = 0;\nend;\n\nfunction TRttiCustomProps.NameChange(const Old, New: RawUtf8): PRttiCustomProp;\nbegin\n  result := Find(Old);\n  if result = nil then\n    exit;\n  result^.Name := New;\n  CountNonVoid := FromNames(pointer(List), Count, NamesAsJsonArray);\nend;\n\nprocedure TRttiCustomProps.NameChanges(const Old, New: array of RawUtf8);\nvar\n  i: PtrInt;\n  p: PRttiCustomProp;\nbegin\n  if high(Old) <> high(New) then\n    raise ERttiException.CreateUtf8(\n      'NameChanges(%,%) fields count', [high(Old), high(New)]);\n  // first reset the names\n  p := pointer(List);\n  for i := 1 to Count do\n  begin\n    p^.Name := p^.fOrigName; // back to original\n    inc(p);\n  end;\n  // customize field names\n  for i := 0 to high(Old) do\n  begin\n    p := Find(Old[i]);\n    if p = nil then\n      raise ERttiException.CreateUtf8('NameChanges(%) unknown', [Old[i]]);\n    p^.Name := New[i];\n  end;\n  CountNonVoid := FromNames(pointer(List), Count, NamesAsJsonArray);\nend;\n\nprocedure TRttiCustomProps.InternalAdd(Info: PRttiInfo; Offset: PtrInt;\n  const PropName: RawUtf8; AddFirst: boolean);\nvar\n  n: PtrInt;\nbegin\n  if (Info = nil) or\n     (Offset < 0) or\n     (PropName = '') or\n     (Find(PropName) <> nil) then // don't register if already existing\n    exit;\n  SetLength(List, Count + 1);\n  if AddFirst then\n  begin\n    if Count > 0 then\n    begin\n      MoveFast(List[0], List[1], SizeOf(List[0]) * Count);\n      pointer(List[0].Name) := nil; // avoid GPF below\n      pointer(List[0].fOrigName) := nil;\n    end;\n    NamesAsJsonArray := '\"' + PropName + '\",' + NamesAsJsonArray;\n    n := 0;\n  end\n  else\n  begin\n    NamesAsJsonArray := NamesAsJsonArray + '\"' + PropName + '\",';\n    n := Count;\n  end;\n  inc(Count);\n  inc(CountNonVoid);\n  with List[n] do\n  begin\n    Value := Rtti.RegisterType(Info);\n    OffsetGet := Offset;\n    OffsetSet := Offset;\n    Name := PropName;\n    fOrigName := PropName;\n    Prop := nil;\n    OrdinalDefault := NO_DEFAULT;\n    Stored := rpsTrue;\n    inc(Size, Value.Size);\n  end;\nend;\n\nfunction TRttiCustomProps.FromTextPrepare(const PropName: RawUtf8): integer;\nbegin\n  if PropName = '' then\n    raise ERttiException.Create('FromTextPrepare: Void property name');\n  if Find(PropName) <> nil then\n    raise ERttiException.CreateUtf8('Duplicated % property name', [PropName]);\n  result := Count;\n  inc(Count);\n  SetLength(List, Count);\n  with List[result] do\n  begin\n    Name := PropName;\n    fOrigName := PropName;\n  end;\nend;\n\nfunction TRttiCustomProps.AdjustAfterAdded: TRttiCustomFlags;\nvar\n  i, n: PtrInt;\n  p: PRttiCustomProp;\nbegin\n  CountNonVoid := FromNames(pointer(List), Count, NamesAsJsonArray);\n  if Count = 0 then\n  begin\n    result := [];\n    Managed := nil;\n    exit;\n  end;\n  result := [rcfHasNestedProperties, rcfHasOffsetSetJsonLoadProperties];\n  SetLength(Managed, Count);\n  n := 0;\n  p := pointer(List);\n  for i := 1 to Count do\n  begin\n    if (rcfIsManaged in p^.Value.Flags) and\n       (p^.OffsetGet >= 0) then\n    begin\n      if not Assigned(p^.Value.fCopy) then\n        raise ERttiException.Create('Paranoid managed Value.Copy');\n      include(result, rcfHasNestedManagedProperties);\n      Managed[n] := p;\n      inc(n);\n    end;\n    if (p^.OffsetSet < 0) or\n       (not Assigned(p^.Value.fJsonLoad)) then\n      exclude(result, rcfHasOffsetSetJsonLoadProperties);\n    inc(p);\n  end;\n  SetLength(Managed, n);\nend;\n\nprocedure TRttiCustomProps.AsText(out Result: RawUtf8; IncludePropType: boolean;\n  const Prefix, Suffix: RawUtf8);\nvar\n  tmp: TTextWriterStackBuffer;\n  i: PtrInt;\nbegin\n  if Count > 0 then\n    with TTextWriter.CreateOwnedStream(tmp) do\n    try\n      AddString(Prefix);\n      for i := 0 to Count - 1 do\n        with List[i] do\n        begin\n          if i > 0 then\n            Add(',', ' ');\n          AddNoJsonEscapeUtf8(Name);\n          if IncludePropType then\n          begin\n            Add(':', ' ');\n            AddString(Value.Name);\n          end;\n        end;\n      AddString(Suffix);\n      SetText(Result);\n    finally\n      Free;\n    end;\nend;\n\nprocedure TRttiCustomProps.InternalClear;\nbegin\n  List := nil;\n  Count := 0;\n  Size := 0;\n  NotInheritedIndex := 0;\n  Managed := nil;\nend;\n\nprocedure TRttiCustomProps.InternalAddFromClass(ClassInfo: PRttiInfo;\n  IncludeParents: boolean);\nvar\n  rc: PRttiClass;\n  rp: PRttiProp;\n  rs: PRttiProps;\n  p: PRttiCustomProp;\n  n, c: PtrInt;\nbegin\n  if (ClassInfo = nil) or\n     (ClassInfo^.Kind <> rkClass) then\n    exit;\n  rc := ClassInfo^.RttiNonVoidClass;\n  if IncludeParents then\n    // put parent properties first\n    InternalAddFromClass(rc^.ParentInfo, true);\n  rs := rc^.RttiProps;\n  n := rs^.PropCount;\n  if n = 0 then\n    exit;\n  c := Count;\n  NotInheritedIndex := c;\n  SetLength(List, c + n);\n  rp := rs^.PropList;\n  repeat\n    if c = 0 then\n      p := nil\n    else\n      p := FindCustomProp(pointer(List), @rp^.Name^[1], ord(rp^.Name^[0]), c);\n    if p = nil then\n    begin // first time we encounter this property\n      inc(Size, List[c].InitFrom(rp));\n      inc(c)\n    end\n    else // this property has been redefined in a sub-class\n      p^.InitFrom(rp);\n    rp := rp^.Next;\n    dec(n);\n  until n = 0;\n  if c = Count then\n    exit;\n  Count := c;\n  DynArrayFakeLength(List, c);\nend;\n\nprocedure TRttiCustomProps.SetFromRecordExtendedRtti(RecordInfo: PRttiInfo);\nvar\n  dummy: PtrInt;\n  all: TRttiRecordAllFields;\n  f: PRttiRecordAllField;\n  i: PtrInt;\nbegin\n  if (RecordInfo = nil) or\n     not (RecordInfo^.Kind in rkRecordTypes) then\n    exit;\n  all := RecordInfo^.RecordAllFields(dummy);\n  InternalClear;\n  if all = nil then\n    // enhanced RTTI is available since Delphi 2010\n    exit;\n  Count := length(all);\n  SetLength(List, Count);\n  f := pointer(all);\n  for i := 0 to Count - 1 do\n    with List[i] do\n    begin\n      Value := Rtti.RegisterType(f^.TypeInfo);\n      inc(Size, Value.Size);\n      OffsetGet := f^.Offset;\n      OffsetSet := f^.Offset;\n      Name := ToUtf8(f^.Name^);\n      fOrigName := Name;\n      OrdinalDefault := NO_DEFAULT;\n      Stored := rpsTrue;\n      inc(f);\n    end;\nend;\n\n// TRttiCustom method defined here for proper inlining\nprocedure TRttiCustom.ValueFinalize(Data: pointer);\nbegin\n  if Assigned(fFinalize) then\n    // handle any kind of value from RTTI, including T*ObjArray\n    fFinalize(Data, fCache.Info)\n  else if rcfWithoutRtti in fFlags then\n    // was defined from text\n    if ArrayRtti <> nil then\n      // static or dynamic array (not T*ObjArray)\n      NoRttiArrayFinalize(Data)\n    else if rcfHasNestedManagedProperties in fFlags then\n      // rcfWithoutRtti records\n      fProps.FinalizeManaged(Data);\nend;\n\nprocedure TRttiCustomProps.FinalizeManaged(Data: PAnsiChar);\nvar\n  pp: PPRttiCustomProp;\n  p: PRttiCustomProp;\n  n: integer;\nbegin\n  pp := pointer(Managed);\n  if pp <> nil then\n  begin\n    n := PDALen(PAnsiChar(pp) - _DALEN)^ + _DAOFF;\n    repeat\n      p := pp^;\n      p.Value.ValueFinalize(Data + p.OffsetSet);\n      inc(pp);\n      dec(n);\n    until n = 0;\n  end;\nend;\n\nprocedure TRttiCustomProps.FinalizeAndClearPublishedProperties(Instance: TObject);\nvar\n  pp: PRttiCustomProp;\n  p: PtrInt;\n  n: integer;\n  rtti: TRttiCustom;\n  empty: TVarData;\nbegin\n  PInteger(@empty)^ := 0;\n  n := Count;\n  pp := pointer(List);\n  if pp <> nil then\n    repeat\n      p := pp^.OffsetSet;\n      if p >= 0 then\n      begin\n        inc(p, PtrInt(Instance));\n        rtti := pp^.Value;\n        rtti.ValueFinalize(pointer(p));\n        if pp^.OrdinalDefault <> NO_DEFAULT then\n          MoveByOne(@pp^.OrdinalDefault, pointer(p), rtti.Size)\n        else\n          FillZeroSmall(pointer(p), rtti.Size);\n      end\n      else\n        pp^.Prop^.SetValue(Instance, PVariant(@empty)^);\n      inc(pp);\n      dec(n);\n    until n = 0;\nend;\n\n// TRttiCustom method defined here for proper inlining\nprocedure TRttiCustom.ValueCopy(Dest, Source: pointer);\nbegin\n  if Assigned(fCopy) then\n    fCopy(Dest, Source, fCache.Info)\n  else\n    MoveFast(Source^, Dest^, fCache.Size);\nend;\n\nprocedure TRttiCustomProps.CopyRecord(Dest, Source: PAnsiChar);\nvar\n  pp: PPRttiCustomProp;\n  n: integer;\n  offset: PtrInt;\nbegin\n  offset := 0;\n  pp := pointer(Managed);\n  if pp <> nil then\n  begin\n    n := PDALen(PAnsiChar(pp) - _DALEN)^ + _DAOFF;\n    repeat\n      offset := pp^.OffsetGet - offset;\n      if offset <> 0 then\n      begin\n        MoveFast(Source^, Dest^, offset); // fast copy unmanaged field\n        inc(Source, offset);\n        inc(Dest, offset);\n      end;\n      pp^.Value.fCopy(Dest, Source, pp^.Value.Info); // copy managed field\n      offset := pp^.Value.Size;\n      inc(Source, offset);\n      inc(Dest, offset);\n      inc(offset, pp^.OffsetGet);\n      inc(pp);\n      dec(n);\n    until n = 0;\n  end;\n  offset := Size - offset;\n  if offset > 0 then\n    MoveFast(Source^, Dest^, offset);\nend;\n\nprocedure TRttiCustomProps.CopyProperties(Dest, Source: PAnsiChar);\nvar\n  p: PRttiCustomProp;\n  n: integer;\n  v: TRttiVarData;\n  d, s: pointer;\nbegin\n  if (Dest = nil) or\n     (Source = nil) then\n    exit; // avoid GPF\n  p := pointer(List); // all published properties, not only Managed[]\n  if p <> nil then\n  begin\n    n := PDALen(PAnsiChar(p) - _DALEN)^ + _DAOFF;\n    repeat\n      with p^ do\n        if (OffsetGet < 0) or\n           (OffsetSet < 0) then\n        begin\n          // there is a getter or a setter -> use local temporary value\n          GetValue(Source, v);\n          SetValue(Dest, v, {andclear=}true);\n        end\n        else\n        begin\n          d := Dest + OffsetSet;\n          s := Source + OffsetGet;\n          if p^.Value.Kind = rkClass then\n            if Assigned(Value.CopyObject) then\n              Value.CopyObject(PPointer(d)^, PPointer(s)^)\n            else\n              Value.Props.CopyProperties(PPointer(d)^, PPointer(s)^)\n          else\n            // direct content copy from the fields memory buffers\n            Value.ValueCopy(d, s);\n        end;\n      inc(p);\n      dec(n);\n    until n = 0;\n  end;\nend;\n\n\n{ TRttiCustom }\n\ntype\n  EHook = class(Exception) // to access @Message private field offset\n  public\n    function MessageOffset: PtrInt; // for Delphi\n  end;\n\nfunction EHook.MessageOffset: PtrInt;\nbegin\n  result := PtrInt(@Message);\nend;\n\n// since \"var class\" are not available in Delphi 6-7, and is inherited by\n// the children classes under latest Delphi versions (i.e. the \"var class\" is\n// shared by all inherited classes, whereas we want one var per class), we\n// reused one of the magic VMT slots, i.e. vmtAutoTable as filled for automated\n// methods, a relic from Delphi 2 that is not used  - see\n// http://hallvards.blogspot.com/2007/05/hack17-virtual-class-variables-part-ii.html\n// [you can define the NOPATCHVMT conditional to rely on our Rtti.FindType()\n//  internal hash table instead, for a slower but more conservative approach]\n\nprocedure TRttiCustom.SetValueClass(aClass: TClass; aInfo: PRttiInfo);\n{$ifndef NOPATCHVMT}\nvar\n  vmt: PPointer;\n{$endif NOPATCHVMT}\nbegin\n  fValueClass := aClass;\n  // we need to register this class ASAP into RTTI list to avoid infinite calls\n  {$ifdef NOPATCHVMT}\n  Rtti.fHashTable[RK_TOSLOT[rkClass]].LastInfo := self; // faster FindType()\n  {$else}\n  // set vmtAutoTable slot for efficient Find(TClass) - to be done asap\n  vmt := Pointer(PAnsiChar(aClass) + vmtAutoTable);\n  if vmt^ = nil then\n    PatchCodePtrUInt(pointer(vmt), PtrUInt(self), {leaveunprotected=}true);\n  if vmt^ <> self then\n    raise ERttiException.CreateUtf8(\n      '%.SetValueClass(%): vmtAutoTable set to %', [self, aClass, vmt^]);\n  {$endif NOPATCHVMT}\n  // identify the most known class types - see also overriden mormot.core.json\n  if aClass.InheritsFrom(TCollection) then\n    fValueRtlClass := vcCollection\n  else if aClass.InheritsFrom(TStrings) then\n    fValueRtlClass := vcStrings\n  else if aClass.InheritsFrom(TObjectList) then\n    fValueRtlClass := vcObjectList\n  else if aClass.InheritsFrom(TList) then\n    fValueRtlClass := vcList\n  else if aClass.InheritsFrom(ESynException) then\n    fValueRtlClass := vcESynException\n  else if aClass.InheritsFrom(Exception) then\n    fValueRtlClass := vcException\n  else if aClass.InheritsFrom(TObjectWithID) then\n    fValueRtlClass := vcObjectWithID;\n  // register the published properties of this class using RTTI\n  fProps.InternalAddFromClass(aInfo, {includeparents=}true);\n  if fValueRtlClass = vcException then\n    // manual registration of the Exception.Message property\n    fProps.InternalAdd(TypeInfo(string), EHook(nil).MessageOffset, 'Message');\nend;\n\nprocedure TRttiCustom.FromRtti(aInfo: PRttiInfo);\nvar\n  dummy: integer;\n  pt: TRttiParserType;\n  pct: TRttiParserComplexType;\n  item: PRttiInfo;\nbegin\n  if aInfo = nil then\n  begin\n    include(fFlags, rcfWithoutRtti);\n    exit; // will call NoRttiSetAndRegister() later on\n  end;\n  // retrieve RTTI into ready-to-be-consummed cache\n  aInfo^.ComputeCache(fCache);\n  if aInfo^.IsManaged then\n    // also check nested record fields\n    include(fFlags, rcfIsManaged);\n  case fCache.Kind of\n    rkClass:\n      SetValueClass(aInfo.RttiClass.RttiClass, aInfo);\n    {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n    rkRecord:\n      fProps.SetFromRecordExtendedRtti(aInfo); // only for Delphi 2010+\n    rkLString:\n      if aInfo = TypeInfo(SpiUtf8) then\n        include(fFlags, rcfSpi);\n    rkDynArray:\n      begin\n        item := fCache.ItemInfo;\n        if item = nil then // unmanaged types\n        begin\n          // try to guess the actual type, e.g. a TGuid or an integer\n          item := aInfo^.DynArrayItemTypeExtended; // FPC or Delphi 2010+\n          if item = nil then\n          begin\n            // on Delphi 7-2009, recognize at least the most common types\n            pt := GuessItemTypeFromDynArrayInfo(aInfo, nil,\n              fCache.ItemSize, {exacttype=}true, dummy, @pct);\n            item := ParserTypeToTypeInfo(pt, pct);\n          end\n          else if item.Kind = rkClass then\n          begin\n            // no need to call RegisterObjArray() on FPC and Delphi 2010+ :)\n            include(fFlags, rcfObjArray);\n            fObjArrayClass := item.RttiClass^.RttiClass;\n          end;\n        end;\n        fArrayRtti := Rtti.RegisterType(item);\n        if (fArrayRtti <> nil) and\n           (fArrayFirstField = ptNone) then\n          if fArrayRtti.Kind in rkRecordOrDynArrayTypes then\n            // guess first field (using fProps[0] would break compatibility)\n            fArrayFirstField := GuessItemTypeFromDynArrayInfo(\n              aInfo, fCache.ItemInfo, fCache.ItemSize, {exacttype=}false, dummy)\n          else\n            fArrayFirstField := fArrayRtti.Parser;\n      end;\n    rkArray:\n      begin\n        fArrayRtti := Rtti.RegisterType(fCache.ItemInfo);\n        if (fArrayRtti = nil) or\n           not (rcfIsManaged in fArrayRtti.Flags) then\n          // a static array is as managed as its nested items\n          exclude(fFlags, rcfIsManaged);\n      end;\n  end;\n  // initialize processing callbacks\n  fFinalize := RTTI_FINALIZE[fCache.Kind];\n  fCopy := RTTI_MANAGEDCOPY[fCache.Kind];\n  if not Assigned(fCopy) then\n    case fCache.Size of // direct copy of most sizes, including class/pointer\n      1:\n        fCopy := @_Per1Copy;\n      2:\n        fCopy := @_Per2Copy;\n      4:\n        fCopy := @_Per4Copy;\n      8:\n        fCopy := @_Per8Copy;\n      16:\n        fCopy := @_Per16Copy;\n      32:\n        fCopy := @_Per32Copy;\n    end; // ItemCopy() will fallback to MoveFast() otherwise\n  pt := GuessTypeInfoToStandardParserType(aInfo, @pct);\n  SetParserType(pt, pct);\nend;\n\ndestructor TRttiCustom.Destroy;\nbegin\n  inherited Destroy;\n  ObjArrayClear(fOwnedRtti);\n  TObject(fPrivateSlot).Free;\n  ObjArrayClear(fPrivateSlots);\nend;\n\nconstructor TRttiCustom.CreateFromText(const RttiDefinition: RawUtf8);\nvar\n  P: PUtf8Char;\nbegin\n  FromRtti(nil); // no associated RTTI\n  P := pointer(RttiDefinition);\n  SetPropsFromText(P, eeNothing, {NoRegister=}true);\nend;\n\nprocedure TRttiCustom.NoRttiSetAndRegister(ParserType: TRttiParserType;\n  const TypeName: RawUtf8; DynArrayElemType: TRttiCustom; NoRegister: boolean);\nbegin\n  if (fNoRttiInfo <> nil) or\n     not (rcfWithoutRtti in fFlags) then\n    raise ERttiException.CreateUtf8('Unexpected %.NoRttiSetAndRegister(%)',\n      [self, TypeName]);\n  // validate record/dynarray only supported types\n  case ParserType of\n    ptRecord:\n      begin\n        fCache.Kind := rkRecord;\n        fCache.Size := Props.Size; // as computed by caller\n      end;\n    ptDynArray:\n      begin\n        fCache.Kind := rkDynArray;\n        fCache.Size := SizeOf(pointer);\n        fArrayRtti := DynArrayElemType;\n        if (DynArrayElemType.Info <> nil) and\n           DynArrayElemType.Info.IsManaged then\n          fCache.ItemInfo := DynArrayElemType.Info; // as regular dynarray RTTI\n        fCache.ItemSize := DynArrayElemType.Size;\n      end;\n    ptClass:\n      begin\n        fCache.Kind := rkClass;\n        fCache.Size := SizeOf(pointer);\n      end;\n  else\n    raise ERttiException.CreateUtf8('Unexpected %.CreateWithoutRtti(%)',\n      [self, ToText(ParserType)^]);\n  end;\n  if NoRegister then\n  begin\n    // initialize the instance, but don't register to TRttiCustomList\n    SetParserType(ParserType, pctNone);\n    exit;\n  end;\n  // create fake RTTI which should be enough for our purpose\n  SetLength(fNoRttiInfo, length(TypeName) + 64); // all filled with zeros\n  fCache.Info := pointer(fNoRttiInfo);\n  fCache.Info.Kind := fCache.Kind;\n  if TypeName = '' then // we need some name to search for\n    fCache.Info.RawName := BinToHexDisplayLowerShort(@self, SizeOf(pointer))\n  else\n    fCache.Info.RawName := TypeName;\n  case ParserType of\n    ptRecord:\n      PRecordInfo(GetTypeData(fCache.Info))^.RecSize := fCache.Size;\n    ptDynArray:\n      GetTypeData(fCache.Info)^.elSize := fCache.ItemSize;\n  end;\n  // initialize process\n  SetParserType(ParserType, pctNone);\n  // register to the internal list\n  Rtti.AddToPairs(self, fCache.Info);\nend;\n\nfunction {%H-}_New_NotImplemented(Rtti: TRttiCustom): pointer;\nbegin\n  raise ERttiException.CreateUtf8('%.ClassNewInstance(%:%) not implemented -> ' +\n    'please include mormot.core.json unit to register TRttiJson',\n    [Rtti, Rtti.Name, ToText(Rtti.Kind)^]);\nend;\n\nfunction TRttiCustom.SetParserType(aParser: TRttiParserType;\n  aParserComplex: TRttiParserComplexType): TRttiCustom;\nbegin\n  fParser := aParser;\n  fParserComplex := aParserComplex;\n  fSetRandom := PT_RANDOM[aParser];\n  if fCache.Info <> nil then\n    ShortStringToAnsi7String(fCache.Info.Name^, fName);\n  fFlags := fFlags + fProps.AdjustAfterAdded;\n  if (fArrayRtti <> nil) and\n     (rcfIsManaged in fArrayRtti.Flags) then\n    include(fFlags, rcfArrayItemManaged);\n  if aParser in (ptStringTypes - [ptRawJson]) then\n    include(fFlags, rcfJsonString);\n  fNewInstance := @_New_NotImplemented; // raise ERttiException by default\n  result := self;\nend;\n\nprocedure TRttiCustom.NoRttiArrayFinalize(Data: PAnsiChar);\nvar\n  n: integer;\n  mem: PDynArrayRec;\nbegin\n  if Kind = rkArray then\n  begin\n    // static array has fixed number of items\n    n := fCache.ItemCount;\n    mem := nil;\n  end\n  else\n  begin\n    // dereference rkDynArray pointer and retrieve length\n    mem := PPointer(Data)^;\n    if mem = nil then\n      exit;\n    PPointer(Data)^ := nil;\n    Data := pointer(mem);\n    dec(mem);\n    if mem.refCnt > 1 then\n      raise ERttiException.CreateUtf8('%.ArrayFinalize: % has refcnt=%',\n        [self, ArrayRtti.Name, mem.refCnt]);\n    n := mem.length;\n  end;\n  // release memory (T*ObjArray would never occur here)\n  repeat\n    ArrayRtti.ValueFinalize(Data);\n    inc(Data, ArrayRtti.Size);\n    dec(n);\n  until n = 0;\n  if mem <> nil then\n    FreeMem(mem);\nend;\n\nprocedure TRttiCustom.ValueFinalizeAndClear(Data: pointer);\nbegin\n  ValueFinalize(Data);\n  if not (rcfIsManaged in fFlags) then // managed fields are already set to nil\n    FillCharFast(Data^, fCache.Size, 0);\nend;\n\nfunction TRttiCustom.ValueIsVoid(Data: PAnsiChar): boolean;\nvar\n  s: PtrInt;\nbegin\n  case Kind of\n    rkVariant:\n      result := cardinal(PVarData(Data).VType) <= varNull;\n    rkClass:\n      result := IsObjectDefaultOrVoid(PObject(Data)^);\n    else\n      // work fast for ordinal types and also any pointer/managed values\n      begin\n        result := false;\n        s := fCache.Size;\n        if s >= 4 then\n          repeat\n            dec(s, 4);\n            if PInteger(Data + s)^ <> 0 then\n              exit;\n          until s < 4;\n        if s > 0 then\n          repeat\n            if Data[s - 1] <> #0 then\n              exit;\n            dec(s);\n          until s = 0;\n        result := true;\n      end;\n  end;\nend;\n\nfunction TRttiCustom.{%H-}ValueCompare(Data, Other: pointer;\n  CaseInsensitive: boolean): integer;\nbegin\n  raise ERttiException.CreateUtf8('%.ValueCompare not implemented -> ' +\n    'please include mormot.core.json unit to register TRttiJson', [self]);\nend;\n\nfunction TRttiCustom.{%H-}ValueToVariant(Data: pointer;\n  out Dest: TVarData; Options: pointer): PtrInt;\nbegin\n  raise ERttiException.CreateUtf8('%.ValueToVariant not implemented -> ' +\n    'please include mormot.core.json unit to register TRttiJson', [self]);\nend;\n\nprocedure TRttiCustom.ValueRandom(Data: pointer);\nbegin\n  fSetRandom(Data, self); // handle most simple kind of values from RTTI\nend;\n\nfunction TRttiCustom.ValueFullHash(const Elem): cardinal;\nbegin\n  result := DefaultHasher(0, @Elem, fCache.ItemSize);\nend;\n\nfunction TRttiCustom.ValueFullCompare(const A, B): integer;\nbegin\n  result := MemCmp(@A, @B, fCache.ItemSize); // use SSE2 asm on Intel/AMD\nend;\n\nfunction TRttiCustom.ValueIterateCount(Data: pointer): integer;\nbegin\n  result := -1; // unsupported\nend;\n\nfunction TRttiCustom.ValueIterate(Data: pointer; Index: PtrUInt;\n  out ResultRtti: TRttiCustom): pointer;\nbegin\n  result := nil;\nend;\n\nfunction TRttiCustom.ValueByPath(var Data: pointer; Path: PUtf8Char;\n  var Temp: TVarData; PathDelim: AnsiChar): TRttiCustom;\nbegin\n  result := nil;\nend;\n\nfunction TRttiCustom.ValueSetText(Data: pointer; const Text: RawUtf8): boolean;\nvar\n  v: Int64;\n  f: double;\nbegin\n  result := true;\n  case Cache.Kind of\n    rkLString:\n      PRawUtf8(Data)^ := Text;\n    rkWString:\n      Utf8ToWideString(pointer(Text), length(Text), PWideString(Data)^);\n    {$ifdef HASVARUSTRING}\n    rkUString:\n      Utf8DecodeToUnicodeString(pointer(Text), length(Text), PUnicodeString(Data)^);\n    {$endif HASVARUSTRING}\n    rkFloat:\n      if ToDouble(Text, f) then\n        RTTI_TO_FLOAT[Cache.RttiFloat](Data, f)\n      else\n        result := false;\n    rkVariant:\n      RawUtf8ToVariant(Text, PVariant(Data)^);\n  else\n    if rcfHasRttiOrd in Cache.Flags then\n      if ToInt64(Text, v) then\n        RTTI_TO_ORD[Cache.RttiOrd](Data, v)\n      else\n        result := false\n    else if rcfGetInt64Prop in Cache.Flags then\n      result := ToInt64(Text, PInt64(Data)^)\n    else\n      result := false;\n  end;\nend;\n\nfunction TRttiCustom.ClassNewInstance: pointer;\nbegin\n  result := fNewInstance(self);\nend;\n\nprocedure TRttiCustom.SetClassNewInstance(FactoryMethod: TRttiCustomNewInstance);\nbegin\n  fNewInstance := FactoryMethod;\nend;\n\nfunction TRttiCustom.HasClassNewInstance: boolean;\nbegin\n  result := (self <> nil) and\n            (@fNewInstance <> @_New_NotImplemented);\nend;\n\nprocedure TRttiCustom.PropsClear;\nbegin\n  Props.InternalClear;\n  fFlags := fFlags - [rcfHasNestedProperties, rcfHasNestedManagedProperties];\nend;\n\nfunction TRttiCustom.PropFindByPath(var Data: pointer; FullName: PUtf8Char;\n  PathDelim: AnsiChar): PRttiCustomProp;\nvar\n  rc: TRttiCustom;\n  n: ShortString;\nbegin\n  rc := self;\n  repeat\n    result := nil;\n    if (rc = nil) or\n       (Data = nil) or\n       (rc.Props.CountNonVoid = 0) then\n      exit;\n    GetNextItemShortString(FullName, @n, PathDelim);\n    if n[0] = #0 then\n      exit;\n    result := FindCustomProp(\n      pointer(rc.Props.List), @n[1], ord(n[0]), rc.Props.Count);\n    if (result = nil) or\n       (FullName = nil) then\n      exit;\n    // search next path level\n    rc := result.Value;\n    if result.OffsetGet < 0 then\n      Data := nil\n    else if rc.Kind in rkRecordTypes then\n      inc(PAnsiChar(Data), result.OffsetGet)\n    else if rc.Kind = rkClass then\n      Data := PPointer(PAnsiChar(Data) + result.OffsetGet)^\n    else\n      Data := nil;\n  until false;\nend;\n\nfunction TRttiCustom.SetObjArray(Item: TClass): TRttiCustom;\nbegin\n  if (self <> nil) and\n     (Kind = rkDynArray) and\n     (fCache.ItemSize = SizeOf(pointer)) and\n     (fCache.ItemInfo = nil) then\n  begin\n    fObjArrayClass := Item;\n    if Item = nil then\n    begin\n      // unregister\n      exclude(fFlags, rcfObjArray);\n      fArrayRtti := nil;\n      fFinalize := @_DynArrayClear;\n    end\n    else\n    begin\n      // register\n      include(fFlags, rcfObjArray);\n      fArrayRtti := Rtti.RegisterClass(Item); // will call _ObjClear()\n      fFinalize := @_ObjArrayClear; // calls RawObjectsClear()\n    end;\n  end;\n  SetParserType(Parser, ParserComplex); // notify format change\n  result := self;\nend;\n\nvar\n  RttiArrayCount: integer;\n\nfunction TRttiCustom.SetBinaryType(BinarySize: integer): TRttiCustom;\nbegin\n  if self <> nil then\n  begin\n    if BinarySize < 0 then\n    begin\n      BinarySize := 0;\n      exclude(fFlags, rcfBinary);\n      if not (Kind in rkStringTypes) then\n        exclude(fFlags, rcfJsonString);\n    end\n    else\n    begin\n      if BinarySize = 0 then\n        BinarySize := fCache.Size;\n      fFlags := fFlags + [rcfBinary, rcfJsonString];\n    end;\n    fBinarySize := BinarySize;\n    SetParserType(Parser, ParserComplex); // notify format change (e.g. for json)\n  end;\n  result := self;\nend;\n\nprocedure TRttiCustom.SetPropsFromText(var P: PUtf8Char;\n  ExpectedEnd: TRttiCustomFromTextExpectedEnd; NoRegister: boolean);\nvar\n  prop: TIntegerDynArray;\n  propcount: integer;\n  propname, typname, atypname: RawUtf8;\n  aname: PUtf8Char;\n  ee: TRttiCustomFromTextExpectedEnd;\n  alen, i: PtrInt;\n  pt, apt: TRttiParserType;\n  c, ac, nested: TRttiCustom;\n  cp: PRttiCustomProp;\nbegin\n  PropsClear;\n  fCache.Size := 0;\n  propcount := 0;\n  while (P <> nil) and\n        (P^ <> #0) do\n  begin\n    // fill prop[] from new properties, and set associated type\n    if P^ = ',' then\n      inc(P);\n    if P^ in ['''', '\"'] then\n    begin\n      // parse identifier as SQL string (e.g. \"@field0\")\n      P := UnQuoteSqlStringVar(P, propname);\n      if P = nil then\n        break;\n    end\n    else if not GetNextFieldProp(P, propname) then\n      // expect regular object pascal identifier (i.e. 0..9,a..z,A..Z,_)\n      break;\n    if P^ = ',' then\n    begin\n      // a,'b,b',c: integer\n      inc(P);\n      AddInteger(prop{%H-}, propcount, Props.FromTextPrepare(propname));\n      continue; // several properties defined with the same type\n    end;\n    AddInteger(prop, propcount, Props.FromTextPrepare(propname));\n    if P^ = ':' then\n      P := GotoNextNotSpace(P + 1);\n    // identify type for prop[]\n    typname := '';\n    atypname := '';\n    c := nil;\n    ac := nil;\n    pt := ptNone;\n    ee := eeNothing;\n    if P^ = '{' then\n    begin\n      // rec: { a,b: integer }\n      pt := ptRecord;\n      ee := eeCurly;\n      repeat\n        inc(P)\n      until (P^ > ' ') or\n            (P^ = #0);\n    end\n    else if P^ = '[' then\n    begin\n      // arr: [ a,b:integer ]\n      pt := ptDynArray;\n      ee := eeSquare;\n      repeat\n        inc(P)\n      until (P^ > ' ') or\n            (P^ = #0);\n    end\n    else\n    begin\n      if not GetNextFieldProp(P, typname) then\n        ERttiException.CreateUtf8('Missing field type for %', [propname]);\n      c := Rtti.RegisterTypeFromName(typname, @pt);\n      if c = nil then\n      case pt of\n        ptArray:\n          // array of ...\n          begin\n            if IdemPChar(P, 'OF') then\n            begin\n              // array of ....   or   array of record ... end\n              P := GotoNextNotSpace(P + 2);\n              if not GetNextFieldProp(P, atypname) or\n                 (P = nil) then\n                ERttiException.Create('Missing array field type');\n              FormatUtf8('[%%]', [atypname, RttiArrayCount], typname);\n              LockedInc32(@RttiArrayCount); // ensure genuine type name\n              ac := Rtti.RegisterTypeFromName(atypname, @apt);\n              if ac = nil then\n                if apt = ptRecord then\n                  // array of record ... end\n                  ee := eeEndKeyWord\n                else\n                  P := nil;\n            end\n            else\n              P := nil;\n            if P = nil then\n              raise ERttiException.CreateUtf8('Expected text definition syntax is ' +\n                '\"array of record\" or \"array of KnownType\" for %', [propname]);\n            pt := ptDynArray;\n          end;\n        ptRecord:\n          // record ... end\n          ee := eeEndKeyWord;\n        ptNone:\n          // unknown type name -> try from TArray<*>/T*DynArray/T*s patterns\n          begin\n            if PropNameEquals(typname, 'TArray') and\n               (P^ = '<') then\n            begin\n              // try generic syntax TArray<##>\n              inc(P);\n              if GetNextFieldProp(P, typname) and\n                 (P^ = '>') then\n              begin\n                inc(P);\n                ac := Rtti.RegisterTypeFromName(typname);\n              end;\n            end\n            else\n            begin\n              // try T##DynArray/T##s patterns\n              aname := pointer(typname);\n              alen := length(typname);\n              if (alen > 10) and\n                 (IdemPropName('DynArray', aname + alen - 8, 8) or\n                  IdemPropName('ObjArray', aname + alen - 8, 8)) then\n                dec(alen, 8)\n              else if (alen > 3) and\n                      (aname[aLen] in ['s', 'S']) then\n                dec(alen)\n              else\n                alen := 0;\n              if alen > 0 then\n              begin\n                // try TIntegerDynArray/TIntegers -> integer\n                ac := Rtti.RegisterTypeFromName(@PByteArray(typname)[1], alen - 1);\n                if ac = nil then\n                  // try TMyTypeObjArray/TMyTypes -> TMyType\n                  ac := Rtti.RegisterTypeFromName(pointer(typname), alen);\n              end;\n            end;\n            if ac = nil then\n              raise ERttiException.CreateUtf8(\n                'Unknown type %: %', [propname, typname]);\n            pt := ptDynArray;\n          end;\n      end;\n    end;\n    // retrieve nested type information\n    if ee <> eeNothing then\n    begin\n      if (c <> nil) or\n         (ac <> nil) or\n         not (pt in [ptRecord, ptDynArray]) then\n        raise ERttiException.CreateUtf8(\n          'Unexpected nested % %', [c, ToText(pt)^]);\n      nested := Rtti.GlobalClass.Create;\n      nested.FromRtti(nil);\n      nested.SetPropsFromText(P, ee, NoRegister);\n      nested.NoRttiSetAndRegister(ptRecord, '', nil, NoRegister);\n      if NoRegister then\n        ObjArrayAdd(fOwnedRtti, nested);\n      if pt = ptRecord then\n        // rec: record .. end  or  rec: { ... }\n        c := nested\n      else\n        // arr: [ ... ]   or  arr: array of record .. end\n        ac := nested;\n    end;\n    if ac <> nil then\n    begin\n      if (c <> nil) or\n         (pt <> ptDynArray) then // paranoid\n        raise ERttiException.CreateUtf8(\n          'Unexpected array % %', [c, ToText(pt)^]);\n      c := Rtti.GlobalClass.Create;\n      c.FromRtti(nil);\n      c.NoRttiSetAndRegister(ptDynArray, typname, ac, NoRegister);\n      if NoRegister then\n        ObjArrayAdd(fOwnedRtti, c);\n    end;\n    // set type for all prop[]\n    for i := 0 to propcount - 1 do\n    begin\n      cp := @Props.List[prop[i]];\n      cp^.Value := c;\n      cp^.OffsetGet := fCache.Size;\n      cp^.OffsetSet := fCache.Size;\n      cp^.OrdinalDefault := NO_DEFAULT;\n      cp^.Stored := rpsTrue;\n      inc(fCache.Size, c.fCache.Size);\n    end;\n    // continue until we reach end of buffer or ExpectedEnd\n    while P^ in [#1..' ', ';'] do\n      inc(P);\n    case ExpectedEnd of\n      eeEndKeyWord:\n        if IdemPChar(P, 'END') then\n        begin\n          inc(P, 3);\n          while P^ in [#1..' ', ';'] do\n            inc(P);\n          break;\n        end;\n      eeSquare:\n        if P^ = ']' then\n        begin\n          inc(P);\n          break;\n        end;\n      eeCurly:\n        if P^ = '}' then\n        begin\n          inc(P);\n          break;\n        end;\n    end;\n    propcount := 0;\n  end;\n  // set whole size and managed fields/properties\n  fProps.Size := fCache.Size;\n  fFlags := fFlags + Props.AdjustAfterAdded;\nend;\n\nfunction FindPrivateSlot(c: TClass; slot: PPointer): pointer;\nvar\n  n: integer;\nbegin\n  result := slot^;\n  if PClass(result)^ = c then // if fPrivateSlots[0].ClassType = c then\n    exit;\n  n := PDALen(PAnsiChar(slot) - _DALEN)^ + (_DAOFF - 1);\n  if n <> 0 then\n    repeat\n      inc(slot);\n      result := slot^;\n      if PClass(result)^ = c then\n        exit;\n      dec(n);\n    until n = 0;\n  result := nil;\nend;\n\nfunction TRttiCustom.GetPrivateSlot(aClass: TClass): pointer;\nbegin\n  // is used by GetWeakZero() so benefits from a per-class lock\n  fPrivateSlotsSafe.Lock;\n  result := pointer(fPrivateSlots);\n  if result <> nil then\n    result := FindPrivateSlot(aClass, result);\n  fPrivateSlotsSafe.UnLock;\nend;\n\nfunction TRttiCustom.SetPrivateSlot(aObject: TObject): pointer;\nbegin\n  fPrivateSlotsSafe.Lock;\n  try\n    result := pointer(fPrivateSlots);\n    if result <> nil then\n      result := FindPrivateSlot(PClass(aObject)^, result); // search again\n    if result = nil then\n    begin\n      ObjArrayAdd(fPrivateSlots, aObject);\n      result := aObject;\n    end\n    else\n      aObject.Free;\n  finally\n    fPrivateSlotsSafe.UnLock;\n  end;\nend;\n\nfunction TRttiCustom.ComputeFakeObjArrayRtti(aItemClass: TClass): TBytes;\nbegin\n  if Kind <> rkDynArray then\n    raise ERttiException.CreateUtf8('ComputeFakeArrayRtti %?', [Name]);\n  SetLength(result, InstanceSize);\n  MoveFast(pointer(self)^, pointer(result)^, InstanceSize);  // weak copy\n  TRttiCustom(pointer(result)).fObjArrayClass := aItemClass; // overwrite class\n  TRttiCustom(pointer(result)).fArrayRtti := Rtti.RegisterClass(aItemClass);\nend; // no need to set other fields like Name\n\n\n{ TRttiCustomList }\n\nconstructor TRttiCustomList.Create;\nbegin\n  SetLength(fHashTable, RK_TOSLOT_MAX + 1); // 6-12KB zeroed allocation\n  fGlobalClass := TRttiCustom;\n  RegisterSafe.Init;\nend;\n\ndestructor TRttiCustomList.Destroy;\nvar\n  i: PtrInt;\nbegin\n  for i := Count - 1 downto 0 do\n    fInstances[i].Free;\n  inherited Destroy;\n  RegisterSafe.Done;\nend;\n\nfunction LockedFind(Pairs, PEnd: PPointerArray; Info: PRttiInfo): TRttiCustom;\n  {$ifdef HASINLINE}inline;{$endif}\nbegin\n  repeat\n    if Pairs[0] <> Info then\n    begin\n      Pairs := @Pairs[2]; // PRttiInfo/TRttiCustom pairs\n      if PAnsiChar(Pairs) >= PAnsiChar(PEnd) then\n        break;\n      continue;\n    end;\n    result := Pairs[1]; // found\n    exit;\n  until false;\n  result := nil; // not found\nend;\n\nfunction TRttiCustomList.FindType(Info: PRttiInfo): TRttiCustom;\nvar\n  k: PRttiCustomListPairs;\n  h: PtrUInt;\n  p: PPointerArray; // ^TPointerDynArray\nbegin\n  {$ifndef NOPATCHVMT}\n  if Info^.Kind <> rkClass then\n  begin\n  {$endif NOPATCHVMT}\n    // our dedicated \"hash table of the poor\" (tm) lookup\n    k := @fHashTable[RK_TOSLOT[Info^.Kind]];\n    // try latest found RTTI for this kind of type definition (naive but works)\n    result := k^.LastInfo;\n    if (result <> nil) and\n       (result.Info = Info) then\n      exit;\n    // O(1) hash of the PRttiInfo pointer using inlined xxHash32 shuffle stage\n    h := xxHash32Mixup(PtrUInt(Info)) and RTTIHASH_MAX;\n    // Knuth's magic number had more collision (even more with KNUTH_HASHPTR_MUL)\n    // h := cardinal(Info * KNUTH_HASH32_MUL) shr (32 - RTTIHASH_BITS);\n    // h := crc32cBy4(0, Info) and RTTICUSTOMTYPEINFOMAX; // slower, not better\n    // try latest found RTTI for this hash slot\n    result := k^.LastHash[h];\n    if (result <> nil) and\n       (result.Info = Info) then\n    begin\n      k^.LastInfo := result; // for faster lookup next time\n      exit; // avoid most ReadLock/ReadUnLock and LockedFind() search\n    end;\n    // thread-safe O(n) search in CPU L1 cache\n    k^.Safe.ReadLock;\n    p := pointer(k^.HashInfo[h]); // read TPointerDynArray within the lock\n    if p <> nil then\n      result := LockedFind(p, @p[PDALen(PAnsiChar(p) - _DALEN)^ + _DAOFF], Info);\n    k^.Safe.ReadUnLock;\n    if result <> nil then\n    begin\n      k^.LastInfo := result;   // aligned pointers are atomically accessed\n      k^.LastHash[h] := result;\n    end;\n  {$ifndef NOPATCHVMT}\n  end\n  else\n    // direct O(1) lookup of the vmtAutoTable slot for classes\n    result := PPointer(PAnsiChar(Info.RttiNonVoidClass.RttiClass) + vmtAutoTable)^;\n  {$endif NOPATCHVMT}\nend;\n\n{$ifdef NOPATCHVMT}\nfunction TRttiCustomList.FindClass(ObjectClass: TClass): TRttiCustom;\nbegin\n  result := FindType(PPointer(PAnsiChar(ObjectClass) + vmtTypeInfo)^);\nend;\n{$else}\nclass function TRttiCustomList.FindClass(ObjectClass: TClass): TRttiCustom;\nbegin\n  result := PPointer(PAnsiChar(ObjectClass) + vmtAutoTable)^;\nend;\n{$endif NOPATCHVMT}\n\nfunction LockedFindNameInPairs(Pairs, PEnd: PPointerArray;\n  Name: PUtf8Char; NameLen: PtrInt): TRttiCustom;\nvar\n  nfo: PRttiInfo;\n  p1, p2: PUtf8Char;\nlabel\n  no;\nbegin\n  repeat\n    nfo := Pairs[0];\n    if ord(nfo^.RawName[0]) <> NameLen then\n    begin\nno:   Pairs := @Pairs[2]; // PRttiInfo/TRttiCustom pairs\n      if PAnsiChar(Pairs) >= PAnsiChar(PEnd) then\n        break;\n      continue;\n    end;\n    // inlined IdemPropNameUSameLenNotNull\n    p1 := @nfo^.RawName[1];\n    p2 := Name;\n    nfo := pointer(@p1[NameLen - SizeOf(cardinal)]);\n    dec(p2, PtrUInt(p1));\n    while PtrUInt(nfo) >= PtrUInt(p1) do\n      // compare 4 Bytes per loop\n      if (PCardinal(p1)^ xor PCardinal(@p2[PtrUInt(p1)])^) and $dfdfdfdf <> 0 then\n        goto no\n      else\n        inc(PCardinal(p1));\n    inc(PCardinal(nfo));\n    while PtrUInt(p1) < PtrUInt(nfo) do\n      // remaining bytes\n      if (ord(p1^) xor ord(p2[PtrUInt(p1)])) and $df <> 0 then\n        goto no\n      else\n        inc(PByte(p1));\n    result := Pairs[1];  // found\n    exit;\n  until false;\n  result := nil; // not found\nend;\n\nfunction RttiHashName(Name: PByteArray; Len: PtrUInt): byte;\n  {$ifdef HASINLINE}inline;{$endif}\nbegin\n  result := Len;\n  repeat\n    dec(Len);\n    if Len = 0 then\n      break;\n    inc(result, Name[Len] and $df); // simple case-insensitive hash\n  until false;\n  result := result and RTTIHASH_MAX;\nend;\n\nfunction TRttiCustomList.FindName(Name: PUtf8Char; NameLen: PtrInt;\n  Kind: TRttiKind): TRttiCustom;\nvar\n  k: PRttiCustomListPairs;\n  p: PPointer; // ^TPointerDynArray\nbegin\n  if (Kind <> rkUnknown) and\n     (Name <> nil) and\n     (NameLen > 0) then\n  begin\n    k := @fHashTable[RK_TOSLOT[Kind]];\n    // try latest found name e.g. calling from JsonRetrieveObjectRttiCustom()\n    result := k^.LastName;\n    if (result <> nil) and\n       (PStrLen(PAnsiChar(pointer(result.Name)) - _STRLEN)^ = NameLen) and\n       IdemPropNameUSameLenNotNull(pointer(result.Name), Name, NameLen) then\n      exit;\n    // our dedicated \"hash table of the poor\" (tm) lookup\n    p := @k^.HashName[RttiHashName(pointer(Name), NameLen)];\n    k^.Safe.ReadLock;\n    result := p^; // read TPointerDynArray within the lock\n    if result <> nil then\n      result := LockedFindNameInPairs(@PPointerArray(result)[0],\n        @PPointerArray(result)[PDALen(PAnsiChar(result) - _DALEN)^ + _DAOFF],\n        Name, NameLen);\n    k^.Safe.ReadUnLock;\n    if result <> nil then\n      k^.LastName := result;\n  end\n  else\n    result := nil;\nend;\n\nfunction TRttiCustomList.FindName(Name: PUtf8Char; NameLen: PtrInt;\n  Kinds: TRttiKinds): TRttiCustom;\nvar\n  k: TRttiKind;\nbegin\n  // not very optimized, but called only at startup from Rtti.RegisterFromText()\n  if (Name <> nil) and\n     (NameLen > 0) then\n  begin\n    if Kinds = [] then\n      Kinds := rkAllTypes;\n    for k := succ(low(k)) to high(k) do\n      if k in Kinds then\n      begin\n        result := FindName(Name, NameLen, k);\n        if result <> nil then\n          exit;\n      end;\n  end;\n  result := nil;\nend;\n\nfunction TRttiCustomList.FindName(const Name: ShortString; Kinds: TRttiKinds): TRttiCustom;\nbegin\n  result := FindName(@Name[1], ord(Name[0]), Kinds);\nend;\n\nfunction FindNameInArray(Pairs, PEnd: PPointerArray; ElemInfo: PRttiInfo): TRttiCustom;\n  {$ifdef HASINLINE} inline; {$endif}\nbegin\n  repeat\n    result := Pairs[1]; // PRttiInfo/TRttiCustom pairs\n    if (result.ArrayRtti <> nil) and\n       (result.ArrayRtti.Info = ElemInfo) then\n      exit;\n    Pairs := @Pairs[2];\n  until Pairs = PEnd;\n  result := nil;\nend;\n\nfunction TRttiCustomList.FindByArrayRtti(ElemInfo: PRttiInfo): TRttiCustom;\nvar\n  n: integer;\n  k: PRttiCustomListPairs;\n  p: PPointer; // TPointerDynArray\nbegin\n  if ElemInfo = nil then\n  begin\n    result := nil;\n    exit;\n  end;\n  k := @fHashTable[RK_TOSLOT[rkDynArray]];\n  k^.Safe.ReadLock;\n  p := @k^.HashInfo;\n  n := length(k^.HashInfo);\n  repeat\n    result := p^;\n    if result <> nil then\n    begin\n      result := FindNameInArray(@PPointerArray(result)[1],\n        @PPointerArray(result)[PDALen(PAnsiChar(result) - _DALEN)^ + _DAOFF], ElemInfo);\n      if result <> nil then\n        break;\n    end;\n    inc(p);\n    dec(n);\n  until n = 0;\n  k^.Safe.ReadUnLock;\nend;\n\nfunction TRttiCustomList.DoRegister(Info: PRttiInfo): TRttiCustom;\nbegin\n  if Info = nil then\n  begin\n    result := nil;\n    exit;\n  end;\n  RegisterSafe.Lock;\n  try\n    result := FindType(Info);  // search again (within RegisterSafe context)\n    if result <> nil then\n      exit; // already registered in the background\n    // initialize a new TRttiCustom/TRttiJson instance for this type\n    result := GlobalClass.Create;\n    // register ASAP to avoid endless recursion in FromRtti\n    AddToPairs(result, Info);\n    // now we can parse and process the RTTI\n    result.FromRtti(Info);\n  finally\n    RegisterSafe.UnLock;\n  end;\n  if FindType(Info) <> result then // paranoid check\n    raise ERttiException.CreateUtf8('%.DoRegister(%)?', [self, Info.RawName]);\nend;\n\nfunction TRttiCustomList.DoRegister(ObjectClass: TClass): TRttiCustom;\nvar\n  info: PRttiInfo;\nbegin\n  info := PPointer(PAnsiChar(ObjectClass) + vmtTypeInfo)^;\n  if info <> nil then\n    result := DoRegister(info)\n  else\n  begin\n    // generate fake RTTI for classes without {$M+}, e.g. TObject or Exception\n    RegisterSafe.Lock;\n    try\n      result := FindClass(ObjectClass); // search again (for thread safety)\n      if result <> nil then\n        exit; // already registered in the background\n      result := GlobalClass.Create;\n      result.FromRtti(nil);\n      result.SetValueClass(ObjectClass, nil);\n      result.NoRttiSetAndRegister(ptClass, ToText(ObjectClass));\n      GetTypeData(result.fCache.Info)^.ClassType := ObjectClass;\n    finally\n      RegisterSafe.UnLock;\n    end;\n  end;\nend;\n\nfunction TRttiCustomList.DoRegister(ObjectClass: TClass; ToDo: TRttiCustomFlags): TRttiCustom;\nvar\n  i: integer;\n  p: PRttiCustomProp;\nbegin\n  RegisterSafe.Lock;\n  try\n    result := DoRegister(ObjectClass);\n    if (rcfAutoCreateFields in ToDo) and\n       not (rcfAutoCreateFields in result.fFlags) then\n    begin\n      // detect T*AutoCreate fields\n      p := pointer(result.Props.List);\n      for i := 1 to result.Props.Count do\n      begin\n        case p^.Value.Kind of\n          rkClass:\n            if (p^.OffsetGet >= 0) and\n               (p^.OffsetSet >= 0) then\n            begin\n              PtrArrayAdd(result.fAutoCreateInstances, p);\n              PtrArrayAdd(result.fAutoDestroyClasses, p);\n            end;\n          rkDynArray:\n            if (rcfObjArray in p^.Value.Flags) and\n               (p^.OffsetGet >= 0) then\n              PtrArrayAdd(result.fAutoCreateObjArrays, p);\n          rkInterface:\n            if (p^.OffsetGet >= 0) and\n               (p^.OffsetSet >= 0) then\n              if p^.Value.HasClassNewInstance then\n                PtrArrayAdd(result.fAutoCreateInstances, p)\n              else\n                PtrArrayAdd(result.fAutoResolveInterfaces, p);\n        end;\n        inc(p);\n      end;\n      include(result.fFlags, rcfAutoCreateFields); // should be set once defined\n    end;\n  finally\n    RegisterSafe.UnLock;\n  end;\nend;\n\n\nprocedure TRttiCustomList.AddToPairs(Instance: TRttiCustom; Info: PRttiInfo);\n\n  procedure AddPair(var List: TPointerDynArray);\n  var\n    n: PtrInt;\n  begin\n    n := length(List);\n    SetLength(List, n + 2);\n    List[n] := Info;\n    List[n + 1] := Instance;\n  end;\n\nvar\n  k: PRttiCustomListPairs;\nbegin\n  k := @fHashTable[RK_TOSLOT[Info^.Kind]];\n  k^.Safe.WriteLock; // needed when resizing k^.HashInfo/HashName[]\n  try\n    AddPair(k^.HashInfo[xxHash32Mixup(PtrUInt(Info)) and RTTIHASH_MAX]);\n    AddPair(k^.HashName[RttiHashName(@Info.RawName[1], ord(Info.RawName[0]))]);\n    ObjArrayAddCount(fInstances, Instance, Count); // to release memory\n    inc(Counts[Info^.Kind]); // Instance.Kind is not available from DoRegister\n  finally\n    k^.Safe.WriteUnLock;\n  end;\nend;\n\nprocedure TRttiCustomList.SetGlobalClass(RttiClass: TRttiCustomClass);\nvar\n  i: PtrInt;\n  pt: TRttiParserType;\n  ptc: TRttiParserComplexType;\n  regtypes: RawUtf8;\n  newunit: PShortString;\nbegin\n  // ensure registration is done once for all\n  if Count <> 0 then\n  begin\n    for i := 0 to Count - 1 do\n      regtypes := {%H-}regtypes + fInstances[i].Name + ' ';\n    newunit := _ClassUnit(RttiClass);\n    raise ERttiException.CreateUtf8('Rtti.Count=% at Rtti.GlobalClass := % : ' +\n      'some types have been registered as % before % has been loaded and ' +\n      'initialized - please put % in the uses clause where you register '+\n      'your [ %] types, in addition to mormot.core.rtti',\n      [Count, RttiClass, fGlobalClass, newunit^, newunit^, regtypes]);\n  end;\n  fGlobalClass := RttiClass;\n  // now we can register all the known types to be found by name\n  for pt := succ(low(pt)) to high(pt) do    // standard types\n    PT_RTTI[pt] := Rtti.RegisterType(PT_INFO[pt]);\n  for ptc := succ(low(ptc)) to high(ptc) do // done as final in mormot.orm.base\n    PTC_RTTI[ptc] := Rtti.RegisterType(PTC_INFO[ptc]);\n  Rtti.RegisterTypes([\n    TypeInfo(SpiUtf8), TypeInfo(RawBlob), TypeInfo(TFileName)]);\nend;\n\nprocedure TRttiCustomList.RegisterTypes(const Info: array of PRttiInfo);\nvar\n  i: PtrInt;\nbegin\n  for i := 0 to high(Info) do\n    RegisterType(Info[i]);\nend;\n\nfunction TRttiCustomList.RegisterTypeFromName(Name: PUtf8Char;\n  NameLen: PtrInt; ParserType: PRttiParserType): TRttiCustom;\nvar\n  pt: TRttiParserType;\n  i: PtrInt;\nbegin\n  if ParserType <> nil then\n    ParserType^ := ptNone;\n  if (Name = nil) or\n     (NameLen <= 0) then\n  begin\n    result := nil;\n    exit;\n  end;\n  repeat\n    i := ByteScanIndex(pointer(Name), NameLen, ord('.'));\n    if i < 0 then\n      break;\n    inc(i); // truncate 'unitname.typename' into 'typename'\n    inc(Name, i);\n    dec(NameLen, i);\n  until false;\n  result := FindName(Name, NameLen);\n  if result = nil then\n  begin\n    // array/record keywords, integer/cardinal FPC types not available by Find()\n    pt := AlternateTypeNameToRttiParserType(Name, NameLen);\n    if ParserType <> nil then\n      ParserType^ := pt;\n    result := PT_RTTI[pt];\n  end\n  else if ParserType <> nil then\n    ParserType^ := result.Parser;\nend;\n\nfunction TRttiCustomList.RegisterTypeFromName(const Name: RawUtf8;\n  ParserType: PRttiParserType): TRttiCustom;\nbegin\n  result := RegisterTypeFromName(pointer(Name), length(Name), ParserType);\nend;\n\nfunction TRttiCustomList.RegisterClass(ObjectClass: TClass): TRttiCustom;\nbegin\n  {$ifdef NOPATCHVMT}\n  result := FindType(PPointer(PAnsiChar(ObjectClass) + vmtTypeInfo)^);\n  {$else}\n  result := PPointer(PAnsiChar(ObjectClass) + vmtAutoTable)^;\n  {$endif NOPATCHVMT}\n  if result = nil then\n    result := DoRegister(ObjectClass);\nend;\n\nfunction TRttiCustomList.GetByClass(ObjectClass: TClass): TRttiCustom;\nbegin\n  result := RegisterClass(ObjectClass);\nend;\n\nfunction TRttiCustomList.RegisterClass(aObject: TObject): TRttiCustom;\nbegin\n  {$ifdef NOPATCHVMT}\n  result := FindType(PPointer(PPAnsiChar(aObject)^ + vmtTypeInfo)^);\n  {$else}\n  result := PPointer(PPAnsiChar(aObject)^ + vmtAutoTable)^;\n  {$endif NOPATCHVMT}\n  if result = nil then\n    result := DoRegister(PClass(aObject)^);\nend;\n\nfunction TRttiCustomList.RegisterAutoCreateFieldsClass(ObjectClass: TClass): TRttiCustom;\nbegin\n  {$ifdef NOPATCHVMT}\n  result := FindType(PPointer(PAnsiChar(ObjectClass) + vmtTypeInfo)^);\n  {$else}\n  result := PPointer(PAnsiChar(ObjectClass) + vmtAutoTable)^;\n  {$endif NOPATCHVMT}\n  if (result = nil) or // caller should have checked it - paranoiac we are\n     not (rcfAutoCreateFields in result.Flags) then\n    result := DoRegister(ObjectClass, [rcfAutoCreateFields]);\nend;\n\nprocedure TRttiCustomList.RegisterClasses(const ObjectClass: array of TClass);\nvar\n  i: PtrInt;\nbegin\n  for i := 0 to high(ObjectClass) do\n  begin\n    if ObjectClass[i].InheritsFrom(TCollection) then\n      raise ERttiException.CreateUtf8(\n        'RegisterClasses(%): please call RegisterCollection() instead',\n        [ObjectClass[i]]);\n    RegisterClass(ObjectClass[i]);\n  end;\nend;\n\nfunction TRttiCustomList.RegisterCollection(Collection: TCollectionClass;\n  CollectionItem: TCollectionItemClass): TRttiCustom;\nbegin\n  result := RegisterClass(Collection);\n  if result <> nil then\n  begin\n    result.fCollectionItem := CollectionItem;\n    result.fCollectionItemRtti := RegisterClass(CollectionItem);\n  end;\nend;\n\nprocedure TRttiCustomList.RegisterUnsafeSpiType(const Types: array of PRttiInfo);\nvar\n  i: PtrInt;\nbegin\n  for i := 0 to high(Types) do\n    include(RegisterType(Types[i]).fFlags, rcfSpi);\nend;\n\nfunction TRttiCustomList.RegisterBinaryType(Info: PRttiInfo;\n  BinarySize: integer): TRttiCustom;\nbegin\n  result := RegisterType(Info).SetBinaryType(BinarySize);\nend;\n\nprocedure TRttiCustomList.RegisterBinaryTypes(const InfoBinarySize: array of const);\nvar\n  i, n: PtrInt;\nbegin\n  n := length(InfoBinarySize);\n  if (n <> 0) and\n     (n and 1 = 0) then\n    for i := 0 to (n shr 1) - 1 do\n      if (InfoBinarySize[i * 2].VType <> vtPointer) or\n         not(InfoBinarySize[i * 2 + 1].VType {%H-}in [vtInteger, vtInt64]) then\n        raise ERttiException.Create('Rtti.RegisterBinaryTypes(?)')\n      else if RegisterType(InfoBinarySize[i * 2].VPointer).\n         SetBinaryType(InfoBinarySize[i * 2 + 1].VInteger) = nil then\n        raise ERttiException.CreateUtf8('Rtti.RegisterBinaryTypes: %?',\n           [PRttiInfo(InfoBinarySize[i * 2].VPointer)^.Name]);\nend;\n\nfunction TRttiCustomList.RegisterObjArray(DynArray: PRttiInfo;\n  Item: TClass): TRttiCustom;\nbegin\n  if DynArray^.Kind = rkDynArray then\n    result := RegisterType(DynArray).SetObjArray(Item)\n  else\n    result := nil;\nend;\n\nprocedure TRttiCustomList.RegisterObjArrays(const DynArrayItem: array of const);\nvar\n  i, n: PtrInt;\nbegin\n  n := length(DynArrayItem);\n  if (n <> 0) and\n     (n and 1 = 0) then\n    for i := 0 to (n shr 1) - 1 do\n      if (DynArrayItem[i * 2].VType <> vtPointer) or\n         (DynArrayItem[i * 2 + 1].VType <> vtClass) then\n        raise ERttiException.Create('Rtti.RegisterObjArrays([?])')\n      else\n        RegisterObjArray(DynArrayItem[i * 2].VPointer,\n          DynArrayItem[i * 2 + 1].VClass);\nend;\n\nfunction TRttiCustomList.RegisterFromText(DynArrayOrRecord: PRttiInfo;\n  const RttiDefinition: RawUtf8): TRttiCustom;\nvar\n  P: PUtf8Char;\n  rttisize: integer;\nbegin\n  if (DynArrayOrRecord = nil) or\n     not (DynArrayOrRecord^.Kind in rkRecordOrDynArrayTypes) then\n    raise ERttiException.Create('Rtti.RegisterFromText(DynArrayOrRecord?)');\n  RegisterSafe.Lock;\n  try\n    result := RegisterType(DynArrayOrRecord);\n    if result.Kind = rkDynArray then\n      if result.ArrayRtti = nil then\n      begin\n        result.fArrayRtti := RegisterFromText('', RttiDefinition);\n        result := result.fArrayRtti;\n        exit;\n      end\n      else\n        result := result.ArrayRtti;\n    result.PropsClear; // reset to the Base64 serialization if RttiDefinition=''\n    P := pointer(RttiDefinition);\n    if P <> nil then\n    begin\n      rttisize := result.Size; // was taken from RTTI\n      result.SetPropsFromText(P, eeNothing, {NoRegister=}false);\n      if result.Props.Size <> rttisize then\n        raise ERttiException.CreateUtf8('Rtti.RegisterFromText(%): text ' +\n          'definition  covers % bytes, but RTTI defined %',\n          [DynArrayOrRecord^.RawName, result.Props.Size, rttisize]);\n    end\n    else if result.Kind in rkRecordTypes then\n      result.Props.SetFromRecordExtendedRtti(result.Info); // only for Delphi 2010+\n    result.SetParserType(result.Parser, result.ParserComplex);\n  finally\n    RegisterSafe.UnLock;\n  end;\nend;\n\nfunction TRttiCustomList.RegisterFromText(const TypeName: RawUtf8;\n  const RttiDefinition: RawUtf8): TRttiCustom;\nvar\n  P: PUtf8Char;\n  new: boolean;\nbegin\n  RegisterSafe.Lock;\n  try\n    result := FindName(pointer(TypeName), length(TypeName));\n    new := result = nil;\n    if new then\n    begin\n      result := GlobalClass.Create;\n      result.FromRtti(nil);\n    end\n    else if not (result.Kind in rkRecordTypes) then\n      raise ERttiException.CreateUtf8('Rtti.RegisterFromText: existing % is a %',\n        [TypeName, ToText(result.Kind)^]);\n    result.PropsClear;\n    P := pointer(RttiDefinition);\n    result.SetPropsFromText(P, eeNothing, {NoRegister=}false);\n    if new then\n      result.NoRttiSetAndRegister(ptRecord, TypeName);\n  finally\n    RegisterSafe.UnLock;\n  end;\nend;\n\nprocedure TRttiCustomList.RegisterFromText(\n  const TypeInfoTextDefinitionPairs: array of const);\nvar\n  i, n: PtrInt;\n  d: RawUtf8;\nbegin\n  n := length(TypeInfoTextDefinitionPairs);\n  if (n <> 0) and\n     (n and 1 = 0) then\n    for i := 0 to (n shr 1) - 1 do\n      if (TypeInfoTextDefinitionPairs[i * 2].VType <> vtPointer) or\n         not VarRecToUtf8IsString(TypeInfoTextDefinitionPairs[i * 2 + 1], d) then\n        raise ERttiException.Create('Rtti.RegisterFromText[?]')\n      else\n         RegisterFromText(TypeInfoTextDefinitionPairs[i * 2].VPointer, d);\nend;\n\n\nprocedure CopyCollection(Source, Dest: TCollection);\nvar\n  i: integer; // Items[] uses an integer\nbegin\n  if (Source = nil) or\n     (Dest = nil) or\n     (Source.ClassType <> Dest.ClassType) then\n    exit;\n  Dest.BeginUpdate;\n  try\n    Dest.Clear;\n    for i := 0 to Source.Count - 1 do\n      CopyObject(Source.Items[i], Dest.Add); // Assign() fails for most objects\n  finally\n    Dest.EndUpdate;\n  end;\nend;\n\nprocedure CopyStrings(Source, Dest: TStrings);\nbegin\n  if (Source <> nil) and\n     (Dest <> nil) then\n    Dest.Assign(Source); // will do the copy RTL-style\nend;\n\nprocedure CopyObject(aFrom, aTo: TObject);\nvar\n  cf: TRttiCustom;\n  rf, rt: PRttiCustomProps;\n  pf, pt: PRttiCustomProp;\n  i: integer;\n  rvd: TRttiVarData;\nbegin\n  if (aFrom <> nil) and\n     (aTo <> nil) then\n  begin\n    cf := Rtti.RegisterClass(PClass(aFrom)^);\n    if (cf.ValueRtlClass = vcCollection) and\n       (PClass(aFrom)^ = PClass(aTo)^)  then\n      // specific process of TCollection items\n      CopyCollection(TCollection(aFrom), TCollection(aTo))\n    else if (cf.ValueRtlClass = vcStrings) and\n            PClass(aTo)^.InheritsFrom(TStrings) then\n      // specific process of TStrings items using RTL-style copy\n      TStrings(aTo).Assign(TStrings(aFrom))\n    else if PClass(aTo)^.InheritsFrom(PClass(aFrom)^) then\n      // fast copy from RTTI properties of the common (or same) hierarchy\n      if Assigned(cf.CopyObject) then\n        cf.CopyObject(aTo, aFrom) // overriden e.g. for TOrm\n      else\n        cf.Props.CopyProperties(pointer(aTo), pointer(aFrom))\n    else\n    begin\n      // no common inheritance -> slower lookup by property name\n      rf := @cf.Props;\n      rt := @Rtti.RegisterClass(PClass(aTo)^).Props;\n      pf := pointer(rf.List);\n      for i := 1 to rf.Count do\n      begin\n        if pf^.Name <> '' then\n        begin\n          pt := rt.Find(pf^.Name);\n          if pt <> nil then\n          begin\n            pf^.GetValue(pointer(aFrom), rvd);\n            pt^.SetValue(pointer(aTo), rvd, {andclear=}true);\n          end;\n        end;\n        inc(pf);\n      end;\n    end;\n  end;\nend;\n\nfunction CopyObject(aFrom: TObject): TObject;\nbegin\n  if aFrom = nil then\n    result := nil\n  else\n  begin\n    result := Rtti.RegisterClass(aFrom.ClassType).ClassNewInstance;\n    CopyObject(aFrom, result);\n  end;\nend;\n\nprocedure SetDefaultValuesObject(Instance: TObject);\nvar\n  rc: TRttiCustom;\n  p: PRttiCustomProp;\n  i: integer;\nbegin\n  if Instance = nil then\n    exit;\n  rc := Rtti.RegisterClass(Instance);\n  p := pointer(rc.Props.List);\n  for i := 1 to rc.Props.Count do\n  begin\n    if p^.Value.Kind = rkClass then\n      SetDefaultValuesObject(p^.Prop.GetObjProp(Instance))\n    else if p^.OrdinalDefault <> NO_DEFAULT then\n      p^.Prop.SetInt64Value(Instance, p^.OrdinalDefault);\n    inc(p);\n  end;\nend;\n\nfunction GetInstanceByPath(var Instance: TObject; const Path: RawUtf8;\n  out Prop: PRttiCustomProp; PathDelim: AnsiChar): boolean;\nbegin\n  result := false;\n  if (Instance = nil) or\n     (Path = '') then\n    exit;\n  Prop := Rtti.RegisterClass(Instance).\n    PropFindByPath(pointer(Instance), pointer(Path), PathDelim);\n  result := (Prop <> nil) and\n            (Instance <> nil);\nend;\n\nfunction SetValueObject(Instance: TObject; const Path: RawUtf8;\n  const Value: variant): boolean;\nvar\n  p: PRttiCustomProp;\nbegin\n  result := GetInstanceByPath(Instance, Path, p) and\n            p^.Prop^.SetValue(Instance, Value);\nend;\n\nprocedure ClearObject(Value: TObject; FreeAndNilNestedObjects: boolean);\nvar\n  rc: TRttiCustom;\n  p: PRttiCustomProp;\n  i: integer;\nbegin\n  if Value = nil then\n    exit;\n  rc := Rtti.RegisterClass(Value.ClassType);\n  p := pointer(rc.Props.List);\n  for i := 1 to rc.Props.Count do\n  begin\n    if not FreeAndNilNestedObjects and\n       (p^.Value.Kind = rkClass) then\n      ClearObject(p^.Prop.GetObjProp(Value), false)\n    else if p^.OffsetSet >= 0 then\n      // for rkClass, _ObjClear() mimics FreeAndNil()\n      p^.Value.ValueFinalizeAndClear(PAnsiChar(Value) + p^.OffsetSet)\n    else\n      p^.SetValue(pointer(Value), PRttiVarData(@NullVarData)^, {andclear=}false);\n    inc(p);\n  end;\nend;\n\nprocedure FinalizeObject(Value: TObject);\nbegin\n  if Value <> nil then\n    Value.CleanupInstance;\nend;\n\nfunction IsObjectDefaultOrVoid(Value: TObject): boolean;\nvar\n  rc: TRttiCustom;\n  p: PRttiCustomProp;\n  i: integer;\nbegin\n  if Value <> nil then\n  begin\n    result := false;\n    rc := Rtti.RegisterClass(Value.ClassType);\n    if (rc.ValueRtlClass <> vcNone) and\n       (rc.ValueIterateCount(@Value) > 0) then\n      exit; // e.g. TObjectList.Count or TCollection.Count\n    p := pointer(rc.Props.List);\n    for i := 1 to rc.Props.Count do\n      if p^.ValueIsVoid(Value) then\n        inc(p)\n      else\n        exit;\n  end;\n  result := true;\nend;\n\nfunction SetObjectFromExecutableCommandLine(Value: TObject;\n  const SwitchPrefix, DescriptionSuffix: RawUtf8;\n  CommandLine: TExecutableCommandLine): boolean;\nvar\n  rc: TRttiCustom;\n  p: PRttiCustomProp;\n  v, desc, def, typ: RawUtf8;\n  dolower: boolean;\n  i: integer;\n  v64: QWord;\nbegin\n  result := false;\n  if Value = nil then\n    exit;\n  if CommandLine = nil then\n    CommandLine := Executable.Command;\n  rc := Rtti.RegisterClass(Value.ClassType);\n  p := pointer(rc.Props.List);\n  for i := 1 to rc.Props.Count do\n  begin\n    if (p^.Name <> '') and\n       not (p^.Value.Kind in rkComplexTypes) then\n    begin\n      desc := '';\n      dolower := false;\n      if p^.Value.Kind in [rkEnumeration, rkSet] then\n      begin\n        p^.Value.Cache.EnumInfo^.GetEnumNameTrimedAll(desc);\n        desc := StringReplaceChars(desc, ',', '|');\n        if UpperCaseU(desc) = desc then\n        begin\n          dolower := true;\n          desc := LowerCaseU(desc); // cosmetic\n        end;\n        if p^.Value.Kind = rkSet then // see TExecutableCommandLine.Describe\n          desc := ' - values: set of ' + desc\n        else\n          desc := ' - values: ' + desc;\n      end;\n      desc := FormatUtf8('%%%', [UnCamelCase(p^.Name), DescriptionSuffix, desc]);\n      if not p.ValueIsDefault(Value) then\n      begin\n        def := '';\n        typ := '';\n        if p^.Value.Kind in rkOrdinalTypes then\n        begin\n          v64 := p^.Prop^.GetInt64Value(Value);\n          case p^.Value.Kind of\n            rkEnumeration:\n              def := p^.Value.Cache.EnumInfo.GetEnumNameTrimed(v64);\n            rkSet:\n              if v64 <> 0 then\n                def := p^.Value.Cache.EnumInfo.GetSetName(v64, {trim=}true, '|');\n          else\n            begin\n              UInt64ToUtf8(v64, def);\n              typ := 'integer';\n            end;\n          end;\n          if dolower then\n            def := LowerCaseU(def);\n        end\n        else\n        begin\n          def := p^.Prop^.GetValueText(Value);\n          if p^.Value.Name = 'TFileName' then\n            if (PosEx('Folder', p^.Prop^.NameUtf8) <> 0) or\n               (PosEx('Path', p^.Prop^.NameUtf8) <> 0) then\n            typ := 'folder'\n          else\n            typ := 'filename'\n          else if (p^.Value.Kind = rkLString) and\n                  (p^.Value.Cache.CodePage <> CP_RAWBYTESTRING) then\n            typ := 'text';\n        end;\n        if typ <> '' then\n          desc := FormatUtf8('##% %', [typ, desc]); // ##typename to be trimmed\n        if def <> '' then\n          desc := FormatUtf8('% (default: %)', [desc, def]);\n      end;\n      if CommandLine.Get([SwitchPrefix + p^.Name], v, desc) and\n         p^.Prop^.SetValueText(Value, v) then // supports also enums and sets\n        result := true;\n    end;\n    inc(p);\n  end;\nend;\n\n\n{ *********** High Level TObjectWithID and TObjectWithCustomCreate Class Types }\n\n{ TObjectWithCustomCreate }\n\nconstructor TObjectWithCustomCreate.Create;\nbegin // do nothing by default but may be overriden\nend;\n\nclass function TObjectWithCustomCreate.RttiCustom: TRttiCustom;\nbegin\n  // inlined Rtti.Find(ClassType): we know it is the first slot\n  {$ifdef NOPATCHVMT}\n  result := Rtti.FindType(PPointer(PAnsiChar(self) + vmtTypeInfo)^);\n  {$else}\n  result := PPointer(PAnsiChar(self) + vmtAutoTable)^;\n  {$endif NOPATCHVMT}\n  // assert(result.InheritsFrom(TRttiCustom));\nend;\n\nclass function TObjectWithCustomCreate.NewInstance: TObject;\nbegin\n  {$ifndef NOPATCHVMT}\n  // register the class to the RTTI cache\n  if PPointer(PAnsiChar(self) + vmtAutoTable)^ = nil then\n    Rtti.DoRegister(self); // ensure TRttiCustom is set\n  {$endif NOPATCHVMT}\n  // bypass vmtIntfTable and vmt^.vInitTable (FPC management operators)\n  GetMem(pointer(result), InstanceSize); // InstanceSize is inlined\n  FillCharFast(pointer(result)^, InstanceSize, 0);\n  PPointer(result)^ := pointer(self); // store VMT\nend; // no benefit of rewriting FreeInstance/CleanupInstance\n\nclass procedure TObjectWithCustomCreate.RttiCustomSetParser(Rtti: TRttiCustom);\nbegin\n  // do nothing by default\nend;\n\nfunction TObjectWithCustomCreate.RttiBeforeWriteObject(W: TTextWriter;\n  var Options: TTextWriterWriteObjectOptions): boolean;\nbegin\n  result := false; // default JSON serialization\nend;\n\nfunction TObjectWithCustomCreate.RttiWritePropertyValue(W: TTextWriter;\n  Prop: PRttiCustomProp; Options: TTextWriterWriteObjectOptions): boolean;\nbegin\n  result := false; // default JSON serializaiton\nend;\n\nprocedure TObjectWithCustomCreate.RttiAfterWriteObject(W: TTextWriter;\n  Options: TTextWriterWriteObjectOptions);\nbegin\n  // nothing to do\nend;\n\nfunction TObjectWithCustomCreate.RttiBeforeReadObject(Ctxt: pointer): boolean;\nbegin\n  result := false; // default JSON unserialization\nend;\n\nfunction TObjectWithCustomCreate.RttiBeforeReadPropertyValue(\n  Ctxt: pointer; Prop: PRttiCustomProp): boolean;\nbegin\n  result := false; // default JSON unserialization\nend;\n\nprocedure TObjectWithCustomCreate.RttiAfterReadObject;\nbegin\n  // nothing to do\nend;\n\nprocedure TObjectWithCustomCreateRttiCustomSetParser(\n  O: TObjectWithCustomCreateClass; Rtti: TRttiCustom);\nbegin\n  O.RttiCustomSetParser(Rtti); // to circumvent some compiler issue\nend;\n\n\n{ TObjectWithID }\n\nconstructor TObjectWithID.CreateWithID(aID: TID);\nbegin\n  Create; // may have be overriden\n  fID := aID;\nend;\n\nclass procedure TObjectWithID.RttiCustomSetParser(Rtti: TRttiCustom);\nbegin\n  Rtti.Props.InternalAdd(\n    TypeInfo(TID), PtrInt(@TObjectWithID(nil).fID), 'ID', {first=}true);\nend;\n\n\n{$ifdef CPUX64}\n\n// very efficient branchless asm - rcx/rdi=Item1 rdx/rsi=Item2\nfunction TObjectWithIDDynArrayCompare(const Item1, Item2): integer;\n{$ifdef FPC}nostackframe; assembler; asm {$else} asm .noframe {$endif FPC}\n        mov     rcx, qword ptr [Item1]\n        mov     rdx, qword ptr [Item2]\n        mov     rcx, qword ptr [rcx + TObjectWithID.fID]\n        mov     rdx, qword ptr [rdx + TObjectWithID.fID]\n        xor     eax, eax\n        cmp     rcx, rdx\n        seta    al\n        sbb     eax, 0\nend;\n\n{$else}\n\nfunction TObjectWithIDDynArrayCompare(const Item1,Item2): integer;\nbegin\n  // we assume Item1<>nil and Item2<>nil\n  result := CompareQWord(TObjectWithID(Item1).fID, TObjectWithID(Item2).fID);\n  // inlined branchless comparison or correct x86 asm for older Delphi\nend;\n\n{$endif CPUX64}\n\nfunction TObjectWithIDDynArrayHashOne(const Elem; Hasher: THasher): cardinal;\nbegin\n  result := Hasher(0, pointer(@TObjectWithID(Elem).fID), SizeOf(TID));\nend;\n\n\n// ------ some integer conversion wrapper functions\n\nfunction FromRttiOrdSByte(P: PShortInt): Int64;\nbegin\n  result := P^;\nend;\n\nfunction FromRttiOrdSWord(P: PSmallInt): Int64;\nbegin\n  result := P^;\nend;\n\nfunction FromRttiOrdSLong(P: PInteger): Int64;\nbegin\n  result := P^;\nend;\n\nfunction FromRttiOrdUByte(P: PByte): Int64;\nbegin\n  result := P^;\nend;\n\nfunction FromRttiOrdUWord(P: PWord): Int64;\nbegin\n  result := P^;\nend;\n\nfunction FromRttiOrdULong(P: PCardinal): Int64;\nbegin\n  result := P^;\nend;\n\nprocedure ToRttiOrd1(P: PByte; Value: PtrUInt);\nbegin\n  P^ := Value;\nend;\n\nprocedure ToRttiOrd2(P: PWord; Value: PtrUInt);\nbegin\n  P^ := Value;\nend;\n\nprocedure ToRttiOrd4(P: PCardinal; Value: PtrUInt);\nbegin\n  P^ := Value;\nend;\n\n{$ifdef FPC_NEWRTTI}\nfunction FromRttiOrdInt64(P: PInt64): Int64;\nbegin\n  result := P^;\nend;\n\nprocedure ToRttiOrd8(P: PInt64; Value: PtrInt);\nbegin\n  P^ := Value;\nend;\n{$endif FPC_NEWRTTI}\n\nprocedure ToRttiFloat32(P: PSingle; Value: TSynExtended);\nbegin\n  P^ := Value;\nend;\n\nprocedure ToRttiFloat64(P: PDouble; Value: TSynExtended);\nbegin\n  unaligned(P^) := Value;\nend;\n\nprocedure ToRttiFloat80(P: PExtended; Value: TSynExtended);\nbegin\n  P^ := Value;\nend;\n\nprocedure ToRttiFloatCurr(P: PCurrency; Value: TSynExtended);\nbegin\n  DoubleToCurrency(Value, P);\nend;\n\n\nprocedure InitializeUnit;\nvar\n  k: TRttiKind;\n  t: TRttiParserType;\nbegin\n  RTTI_FROM_ORD[roSByte] := @FromRttiOrdSByte;\n  RTTI_FROM_ORD[roSWord] := @FromRttiOrdSWord;\n  RTTI_FROM_ORD[roSLong] := @FromRttiOrdSLong;\n  RTTI_FROM_ORD[roUByte] := @FromRttiOrdUByte;\n  RTTI_FROM_ORD[roUWord] := @FromRttiOrdUWord;\n  RTTI_FROM_ORD[roULong] := @FromRttiOrdULong;\n  RTTI_TO_ORD[roSByte] := @ToRttiOrd1;\n  RTTI_TO_ORD[roSWord] := @ToRttiOrd2;\n  RTTI_TO_ORD[roSLong] := @ToRttiOrd4;\n  RTTI_TO_ORD[roUByte] := @ToRttiOrd1;\n  RTTI_TO_ORD[roUWord] := @ToRttiOrd2;\n  RTTI_TO_ORD[roULong] := @ToRttiOrd4;\n  {$ifdef FPC_NEWRTTI}\n  RTTI_FROM_ORD[roSQWord] := @FromRttiOrdInt64;\n  RTTI_FROM_ORD[roUQWord] := @FromRttiOrdInt64;\n  RTTI_TO_ORD[roSQWord]   := @ToRttiOrd8;\n  RTTI_TO_ORD[roUQWord]   := @ToRttiOrd8;\n  {$endif FPC_NEWRTTI}\n  RTTI_TO_FLOAT[rfSingle]   := @ToRttiFloat32;\n  RTTI_TO_FLOAT[rfDouble]   := @ToRttiFloat64;\n  RTTI_TO_FLOAT[rfExtended] := @ToRttiFloat80;\n  RTTI_TO_FLOAT[rfCurr]     := @ToRttiFloatCurr;\n  RTTI_FINALIZE[rkLString]   := @_StringClear;\n  RTTI_FINALIZE[rkWString]   := @_WStringClear;\n  RTTI_FINALIZE[rkVariant]   := @_VariantClear;\n  RTTI_FINALIZE[rkArray]     := @_ArrayClear;\n  RTTI_FINALIZE[rkRecord]    := @FastRecordClear;\n  RTTI_FINALIZE[rkInterface] := @_InterfaceClear;\n  RTTI_FINALIZE[rkDynArray]  := @_DynArrayClear;\n  RTTI_TO_VARTYPE[rkInteger] := varInt64;\n  RTTI_TO_VARTYPE[rkInt64]   := varWord64;\n  RTTI_TO_VARTYPE[rkFloat]   := varDouble;\n  RTTI_TO_VARTYPE[rkLString] := varString;\n  RTTI_TO_VARTYPE[rkWString] := varOleStr;\n  RTTI_TO_VARTYPE[rkVariant] := varVariant;\n  RTTI_TO_VARTYPE[rkChar]    := varUnknown; // to use temp RawUtf8 -> varString\n  RTTI_TO_VARTYPE[rkWChar]   := varUnknown;\n  RTTI_TO_VARTYPE[rkSString] := varUnknown;\n  RTTI_MANAGEDCOPY[rkLString]   := @_LStringCopy;\n  RTTI_MANAGEDCOPY[rkWString]   := @_WStringCopy;\n  RTTI_MANAGEDCOPY[rkVariant]   := @_VariantCopy;\n  RTTI_MANAGEDCOPY[rkArray]     := @_ArrayCopy;\n  RTTI_MANAGEDCOPY[rkRecord]    := @_RecordCopy;\n  RTTI_MANAGEDCOPY[rkInterface] := @_InterfaceCopy;\n  RTTI_MANAGEDCOPY[rkDynArray]  := @_DynArrayCopy;\n  {$ifdef HASVARUSTRING}\n  RTTI_FINALIZE[rkUString]      := @_StringClear; // share same PStrRec layout\n  RTTI_TO_VARTYPE[rkUString]    := varUString;\n  RTTI_MANAGEDCOPY[rkUString]   := @_UStringCopy;\n  {$endif HASVARUSTRING}\n  {$ifdef FPC}\n  RTTI_FINALIZE[rkLStringOld]    := @_StringClear;\n  RTTI_FINALIZE[rkObject]        := @FastRecordClear;\n  RTTI_TO_VARTYPE[rkBool]        := varBoolean;\n  RTTI_TO_VARTYPE[rkQWord]       := varWord64;\n  RTTI_TO_VARTYPE[rkLStringOld]  := varString;\n  RTTI_TO_VARTYPE[rkObject]      := varAny;\n  RTTI_MANAGEDCOPY[rkLStringOld] := @_LStringCopy;\n  RTTI_MANAGEDCOPY[rkObject]     := @_RecordCopy;\n  {$else}\n  {$ifdef UNICODE}\n  RTTI_FINALIZE[rkMRecord]       := @FastRecordClear;\n  RTTI_TO_VARTYPE[rkMRecord]     := varAny;\n  RTTI_MANAGEDCOPY[rkMRecord]    := @_RecordCopy;\n  {$endif UNICODE}\n  {$endif FPC}\n  for k := low(k) to high(k) do\n  begin\n    // paranoid checks\n    if Assigned(RTTI_FINALIZE[k]) <> (k in rkManagedTypes) then\n      raise ERttiException.CreateUtf8('Unexpected RTTI_FINALIZE[%]', [ToText(k)^]);\n    if Assigned(RTTI_MANAGEDCOPY[k]) <> (k in rkManagedTypes) then\n      raise ERttiException.CreateUtf8('Unexpected RTTI_MANAGEDCOPY[%]', [ToText(k)^]);\n    // TJsonWriter.AddRttiVarData for TRttiCustomProp.GetValueDirect/GetValueGetter\n    case k of\n      rkEnumeration,\n      rkSet,\n      rkDynArray,\n      rkClass,\n      rkInterface,\n      {$ifdef FPC}rkObject,{$else}{$ifdef UNICODE}rkMRecord,{$endif}{$endif}\n      rkRecord,\n      rkArray:\n        RTTI_TO_VARTYPE[k] := varAny; // TVarData.VAny pointing to the value\n    end;\n  end;\n  RTTI_FINALIZE[rkClass]   := @_ObjClear;\n  PT_INFO[ptBoolean]       := TypeInfo(boolean);\n  PT_INFO[ptByte]          := TypeInfo(byte);\n  PT_INFO[ptCardinal]      := TypeInfo(cardinal);\n  PT_INFO[ptCurrency]      := TypeInfo(Currency);\n  PT_INFO[ptDouble]        := TypeInfo(Double);\n  PT_INFO[ptExtended]      := TypeInfo(Extended);\n  PT_INFO[ptInt64]         := TypeInfo(Int64);\n  PT_INFO[ptInteger]       := TypeInfo(integer);\n  PT_INFO[ptQWord]         := TypeInfo(QWord);\n  PT_INFO[ptRawByteString] := TypeInfo(RawByteString);\n  PT_INFO[ptRawJson]       := TypeInfo(RawJson);\n  PT_INFO[ptRawUtf8]       := TypeInfo(RawUtf8);\n  PT_INFO[ptSingle]        := TypeInfo(Single);\n  PT_INFO[ptString]        := TypeInfo(String);\n  PT_INFO[ptSynUnicode]    := TypeInfo(SynUnicode);\n  PT_INFO[ptDateTime]      := TypeInfo(TDateTime);\n  PT_INFO[ptDateTimeMS]    := TypeInfo(TDateTimeMS);\n  {$ifdef HASNOSTATICRTTI} // for Delphi 7/2007: use fake TypeInfo()\n  PT_INFO[ptGuid]          := @_TGUID;\n  PT_INFO[ptHash128]       := @_THASH128;\n  PT_INFO[ptHash256]       := @_THASH256;\n  PT_INFO[ptHash512]       := @_THASH512;\n  PT_INFO[ptPUtf8Char]     := @_PUTF8CHAR;\n  {$else}\n  PT_INFO[ptGuid]          := TypeInfo(TGuid);\n  PT_INFO[ptHash128]       := TypeInfo(THash128);\n  PT_INFO[ptHash256]       := TypeInfo(THash256);\n  PT_INFO[ptHash512]       := TypeInfo(THash512);\n  PT_INFO[ptPUtf8Char]     := TypeInfo(PUtf8Char);\n  {$endif HASNOSTATICRTTI}\n  {$ifdef HASVARUSTRING}\n  PT_INFO[ptUnicodeString]     := TypeInfo(UnicodeString);\n  PT_DYNARRAY[ptUnicodeString] := TypeInfo(TUnicodeStringDynArray);\n  {$else}\n  PT_INFO[ptUnicodeString]     := TypeInfo(SynUnicode);\n  PT_DYNARRAY[ptUnicodeString] := TypeInfo(TSynUnicodeDynArray);\n  {$endif HASVARUSTRING}\n  PT_INFO[ptUnixTime]      := TypeInfo(TUnixTime);\n  PT_INFO[ptUnixMSTime]    := TypeInfo(TUnixMSTime);\n  PT_INFO[ptVariant]       := TypeInfo(Variant);\n  PT_INFO[ptWideString]    := TypeInfo(WideString);\n  PT_INFO[ptWinAnsi]       := TypeInfo(WinAnsiString);\n  PT_INFO[ptWord]          := TypeInfo(Word);\n  // ptComplexTypes may have several matching TypeInfo() -> put generic\n  PT_INFO[ptOrm]           := TypeInfo(TID);\n  PT_INFO[ptTimeLog]       := TypeInfo(TTimeLog);\n  for t := succ(low(t)) to high(t) do\n    if Assigned(PT_INFO[t]) = (t in (ptComplexTypes - [ptOrm, ptTimeLog])) then\n      raise ERttiException.CreateUtf8('Unexpected PT_INFO[%]', [ToText(t)^]);\n  PTC_INFO[pctTimeLog]     := TypeInfo(TTimeLog);\n  PTC_INFO[pctID]          := TypeInfo(TID);\n  PTC_INFO[pctCreateTime]  := TypeInfo(TTimeLog);\n  PTC_INFO[pctModTime]     := TypeInfo(TTimeLog);\n  // may be overriden to the exact TRecordReference/TRecordVersion TypeInfo()\n  PTC_INFO[pctSpecificClassID] := TypeInfo(QWord);\n  PTC_INFO[pctRecordReference] := TypeInfo(QWord);\n  PTC_INFO[pctRecordVersion]   := TypeInfo(QWord);\n  PTC_INFO[pctRecordReferenceToBeDeleted] := TypeInfo(QWord);\n  PT_DYNARRAY[ptBoolean]       := TypeInfo(TBooleanDynArray);\n  PT_DYNARRAY[ptByte]          := TypeInfo(TByteDynArray);\n  PT_DYNARRAY[ptCardinal]      := TypeInfo(TCardinalDynArray);\n  PT_DYNARRAY[ptCurrency]      := TypeInfo(TCurrencyDynArray);\n  PT_DYNARRAY[ptDouble]        := TypeInfo(TDoubleDynArray);\n  PT_DYNARRAY[ptExtended]      := TypeInfo(TExtendedDynArray);\n  PT_DYNARRAY[ptInt64]         := TypeInfo(TInt64DynArray);\n  PT_DYNARRAY[ptInteger]       := TypeInfo(TIntegerDynArray);\n  PT_DYNARRAY[ptQWord]         := TypeInfo(TQWordDynArray);\n  PT_DYNARRAY[ptRawByteString] := TypeInfo(TRawByteStringDynArray);\n  PT_DYNARRAY[ptRawJson]       := TypeInfo(TRawJsonDynArray);\n  PT_DYNARRAY[ptRawUtf8]       := TypeInfo(TRawUtf8DynArray);\n  PT_DYNARRAY[ptSingle]        := TypeInfo(TSingleDynArray);\n  PT_DYNARRAY[ptString]        := TypeInfo(TStringDynArray);\n  PT_DYNARRAY[ptSynUnicode]    := TypeInfo(TSynUnicodeDynArray);\n  PT_DYNARRAY[ptDateTime]      := TypeInfo(TDateTimeDynArray);\n  PT_DYNARRAY[ptDateTimeMS]    := TypeInfo(TDateTimeMSDynArray);\n  PT_DYNARRAY[ptGuid]          := TypeInfo(TGuidDynArray);\n  PT_DYNARRAY[ptHash128]       := TypeInfo(THash128DynArray);\n  PT_DYNARRAY[ptHash256]       := TypeInfo(THash256DynArray);\n  PT_DYNARRAY[ptHash512]       := TypeInfo(THash512DynArray);\n  PT_DYNARRAY[ptOrm]           := TypeInfo(TIDDynArray);\n  PT_DYNARRAY[ptTimeLog]       := TypeInfo(TTimeLogDynArray);\n  PT_DYNARRAY[ptUnixTime]      := TypeInfo(TUnixTimeDynArray);\n  PT_DYNARRAY[ptUnixMSTime]    := TypeInfo(TUnixMSTimeDynArray);\n  PT_DYNARRAY[ptVariant]       := TypeInfo(TVariantDynArray);\n  PT_DYNARRAY[ptWideString]    := TypeInfo(TWideStringDynArray);\n  PT_DYNARRAY[ptWinAnsi]       := TypeInfo(TWinAnsiDynArray);\n  PT_DYNARRAY[ptWord]          := TypeInfo(TWordDynArray);\n  PT_DYNARRAY[ptPUtf8Char]     := TypeInfo(TPUtf8CharDynArray);\n  // prepare global thread-safe TRttiCustomList\n  Rtti := RegisterGlobalShutdownRelease(TRttiCustomList.Create);\n  ClassUnit := _ClassUnit;\n  // redirect most used FPC RTL functions to optimized x86_64 assembly\n  {$ifdef FPC_CPUX64}\n  RedirectRtl;\n  {$endif FPC_CPUX64}\n  // validate some redefined RTTI structures with compiler definitions\n  assert(SizeOf(TRttiVarData) = SizeOf(TVarData));\n  assert(@PRttiVarData(nil)^.PropValue = @PVarData(nil)^.VAny);\n  {$ifdef FPC_OR_UNICODE}\n  assert(SizeOf(TRttiRecordField) = SizeOf(TManagedField));\n  {$endif FPC_OR_UNICODE}\nend;\n\n\ninitialization\n  InitializeUnit;\n\n\nend.", "output": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\nnamespace Synopse.Rtti\n{\n    \n    public enum RttiKind\n    {\n        Unknown,\n        Integer,\n        Float,\n        String,\n        Record,\n        Array,\n        Class,\n        Variant,\n        \n    }\n\n    \n    public class RttiInfo\n    {\n        public RttiKind Kind { get; private set; }\n        public string RawName { get; private set; }\n        public Type Type { get; private set; }\n\n        public RttiInfo(Type type)\n        {\n            Type = type;\n            RawName = type.Name;\n            Kind = DetermineKind(type);\n        }\n\n        static RttiKind DetermineKind(Type t)\n        {\n            \n            if (t.IsEnum)\n                return RttiKind.Integer; \n            else if (t == typeof(int) || t == typeof(uint) || t == typeof(short) || t == typeof(ushort)\n                  || t == typeof(byte) || t == typeof(sbyte))\n                return RttiKind.Integer;\n            else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))\n                return RttiKind.Float;\n            else if (t == typeof(string))\n                return RttiKind.String;\n            else if (t.IsArray)\n                return RttiKind.Array;\n            else if (t.IsClass)\n                return RttiKind.Class;\n            else if (t.IsValueType)\n                return RttiKind.Record;\n            else if (t == typeof(object))\n                return RttiKind.Variant;\n            else\n                return RttiKind.Unknown;\n        }\n\n        public int RttiSize\n        {\n            get\n            {\n                try\n                {\n                    return Marshal.SizeOf(Type);\n                }\n                catch\n                {\n                    return 0;\n                }\n            }\n        }\n\n        \n        public void Clear(object instance)\n        {\n            \n            // If you need to \u201cclear\u201d fields, you could set them to default.\n        }\n\n        \n        public void Copy(object destination, object source)\n        {\n            if (destination == null || source == null)\n                throw new ArgumentNullException();\n            foreach (var prop in Type.GetProperties(BindingFlags.Public | BindingFlags.Instance))\n            {\n                if (prop.CanRead && prop.CanWrite)\n                {\n                    object value = prop.GetValue(source);\n                    prop.SetValue(destination, value);\n                }\n            }\n        }\n    }\n\n   \n    public class RttiCustom\n    {\n        public RttiInfo Info { get; private set; }\n        public Type ValueClass { get; private set; }\n\n        \n        public Dictionary<string, PropertyInfo> Properties { get; private set; }\n\n        \n        public RttiCustom(Type type)\n        {\n            ValueClass = type;\n            Info = new RttiInfo(type);\n            Properties = new Dictionary<string, PropertyInfo>(StringComparer.OrdinalIgnoreCase);\n            \n            foreach (var pi in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))\n            {\n                Properties[pi.Name] = pi;\n            }\n        }\n\n        \n        public object GetValue(object instance, string propertyName)\n        {\n            if (Properties.TryGetValue(propertyName, out PropertyInfo pi))\n            {\n                return pi.GetValue(instance);\n            }\n            throw new Exception($\"Property '{propertyName}' not found in {ValueClass.Name}\");\n        }\n\n        \n        public void SetValue(object instance, string propertyName, object value)\n        {\n            if (Properties.TryGetValue(propertyName, out PropertyInfo pi))\n            {\n                pi.SetValue(instance, value);\n            }\n            else\n            {\n                throw new Exception($\"Property '{propertyName}' not found in {ValueClass.Name}\");\n            }\n        }\n\n       \n        public void CopyProperties(object destination, object source)\n        {\n            foreach (var pi in Properties.Values)\n            {\n                if (pi.CanRead && pi.CanWrite)\n                {\n                    object value = pi.GetValue(source);\n                    pi.SetValue(destination, value);\n                }\n            }\n        }\n    }\n\n    \n    public class RttiCustomList\n    {\n       \n        private readonly ConcurrentDictionary<Type, RttiCustom> _registeredTypes =\n            new ConcurrentDictionary<Type, RttiCustom>();\n\n        \n        public RttiCustom RegisterType(Type type)\n        {\n            return _registeredTypes.GetOrAdd(type, t => new RttiCustom(t));\n        }\n\n        \n        public RttiCustom FindType(Type type)\n        {\n            _registeredTypes.TryGetValue(type, out RttiCustom result);\n            return result;\n        }\n    }\n\n    \n    public static class Rtti\n    {\n        \n        public static readonly RttiCustomList Global = new RttiCustomList();\n\n        \n        public static string ToText(RttiKind kind)\n        {\n            return kind.ToString();\n        }\n    }\n\n    \n    public class ObjectWithCustomCreate\n    {\n        \n        public ObjectWithCustomCreate()\n        {\n            \n            Rtti.Global.RegisterType(GetType());\n        }\n\n       \n        public static T CreateInstance<T>() where T : ObjectWithCustomCreate\n        {\n            return (T)Activator.CreateInstance(typeof(T));\n        }\n    }\n\n    \n    public class ObjectWithID : ObjectWithCustomCreate\n    {\n        public long ID { get; set; }\n\n        public ObjectWithID() : base() { }\n\n        public ObjectWithID(long id) : this()\n        {\n            ID = id;\n        }\n    }\n    public static class ObjectCopyHelper\n    {\n        \n        public static void CopyObject(object source, object destination)\n        {\n            if (source == null || destination == null)\n                throw new ArgumentNullException();\n            if (source.GetType() != destination.GetType())\n                throw new ArgumentException(\"Source and destination must be of the same type.\");\n\n            var custom = Rtti.Global.RegisterType(source.GetType());\n            custom.CopyProperties(destination, source);\n        }\n\n        \n        public static T CopyObject<T>(T source) where T : ObjectWithCustomCreate\n        {\n            if (source == null) return null;\n            T newObj = ObjectWithCustomCreate.CreateInstance<T>();\n            CopyObject(source, newObj);\n            return newObj;\n        }\n    }\n\n}"}
{"input": "unit ServicesInterfaceU;\n\ninterface\n\ntype\n  IUsersService = interface\n    ['{D54AF728-7688-40DE-B10C-E6D63949531E}']\n    function GetUserNameByID(const ID: Integer): String;\n  end;\n\n  ICustomersService = interface\n    ['{DC94C34E-13A2-4406-8961-6A407B792DD3}']\n    function GetCustomerNameByID(const ID: Integer): String;\n  end;\n\n  ICommonService = interface\n    ['{EAA26199-4142-4698-9C17-5D241D9984AA}']\n    function GetID: String;\n  end;\n\nimplementation\n\nend.", "output": "using System.Runtime.InteropServices;\n\nnamespace ServicesInterfaceU\n{\n    [Guid(\"D54AF728-7688-40DE-B10C-E6D63949531E\")]\n    public interface IUsersService\n    {\n        string GetUserNameByID(int id);\n    }\n\n    [Guid(\"DC94C34E-13A2-4406-8961-6A407B792DD3\")]\n    public interface ICustomersService\n    {\n        string GetCustomerNameByID(int id);\n    }\n\n    [Guid(\"EAA26199-4142-4698-9C17-5D241D9984AA\")]\n    public interface ICommonService\n    {\n        string GetID();\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit MVCFramework.View.Renderers.Mustache;\n\n{$IFDEF LINUX}\nThis unit is not compatible with Linux\n{$ENDIF}\ninterface\n\nuses\n  MVCFramework, System.SysUtils, System.Generics.Collections,\n  MVCFramework.Commons, System.IOUtils, System.RTTI,\n  System.Classes, Data.DB, MVCFramework.IntfObjectPool,\n  mormot.core.mustache, mormot.core.unicode;\n\ntype\n  { This class implements the mustache view engine for server side views }\n  TMVCMustacheViewEngine = class(TMVCBaseViewEngine)\n  strict private\n    procedure PrepareModels;\n  private\n    fModelPrepared: Boolean;\n    class var fPartials: TSynMustachePartials;\n    class var fHelpers: TSynMustacheHelpers;\n    class var fSerializerPool: IIntfObjectPool;\n    var FJSONModelAsString: string;\n    procedure LoadPartials;\n    procedure LoadHelpers;\n  protected\n    function RenderJSON(lViewEngine: TSynMustache; const JSON: UTF8String; Partials: TSynMustachePartials;\n      Helpers: TSynMustacheHelpers; OnTranslate: TOnStringTranslate; EscapeInvert: boolean): UTF8String; virtual;\n  public\n    procedure Execute(const ViewName: string; const Builder: TStringBuilder); override;\n    constructor Create(const AEngine: TMVCEngine; const AWebContext: TWebContext;\n      const AController: TMVCController;\n      const AViewModel: TMVCViewDataObject;\n      const AContentType: string); override;\n    class destructor Destroy;\n    class constructor Create;\n  end;\n\n  TLoadCustomHelpersProc = reference to procedure(var MustacheHelpers: TSynMustacheHelpers);\n\n  TMVCMustacheHelpers = class sealed\n  private\n    class var fOnLoadCustomHelpers: TLoadCustomHelpersProc;\n  protected\n    class procedure RegisterHandlers(var MustacheHelpers: TSynMustacheHelpers);\n    class procedure ToLowerCase(const Value: variant; out Result: variant);\n    class procedure ToUpperCase(const Value: variant; out Result: variant);\n    class procedure Capitalize(const Value: variant; out Result: variant);\n    class procedure SnakeCase(const Value: variant; out Result: variant);\n  public\n    class property OnLoadCustomHelpers: TLoadCustomHelpersProc read fOnLoadCustomHelpers write fOnLoadCustomHelpers;\n  end;\n\nimplementation\n\nuses\n  Types,\n  JsonDataObjects,\n  MVCFramework.Serializer.Defaults,\n  MVCFramework.Serializer.Intf,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.DuckTyping,\n  MVCFramework.Serializer.JsonDataObjects.OptionalCustomTypes,\n  MVCFramework.Serializer.JsonDataObjects;\n\n{$WARNINGS OFF}\n\n\ntype\n  TSynMustacheAccess = class(TSynMustache)\n  end;\n\nvar\n  gPartialsLoaded : Boolean = False;\n  gHelpersLoaded : Boolean = False;\n\nconstructor TMVCMustacheViewEngine.Create(const AEngine: TMVCEngine;\n  const AWebContext: TWebContext; const AController: TMVCController;\n  const AViewModel: TMVCViewDataObject; const AContentType: string);\nbegin\n  inherited;\n  fModelPrepared := False;\n  LoadPartials;\n  LoadHelpers;\nend;\n\nclass constructor TMVCMustacheViewEngine.Create;\nbegin\n  fSerializerPool := MVCFramework.IntfObjectPool.TIntfObjectPool.Create(10000, 10,1,\n    function: IInterface\n    begin\n      Result := TMVCJsonDataObjectsSerializer.Create(nil);\n      RegisterOptionalCustomTypesSerializers(Result as IMVCSerializer);\n    end);\nend;\n\nclass destructor TMVCMustacheViewEngine.Destroy;\nbegin\n  fPartials.Free;\nend;\n\nfunction TMVCMustacheViewEngine.RenderJSON(lViewEngine: TSynMustache; const JSON: UTF8String; Partials: TSynMustachePartials;\n  Helpers: TSynMustacheHelpers; OnTranslate: TOnStringTranslate; EscapeInvert: boolean): UTF8String;\nbegin\n  Result := lViewEngine.RenderJSON(JSON, Partials, Helpers, OnTranslate, EscapeInvert);\nend;\n\nprocedure TMVCMustacheViewEngine.Execute(const ViewName: string; const Builder: TStringBuilder);\nvar\n  lViewFileName: string;\n  lViewTemplate: UTF8String;\n  lViewEngine: TSynMustache;\nbegin\n  PrepareModels;\n  lViewFileName := GetRealFileName(ViewName);\n  if lViewFileName.IsEmpty then\n    raise EMVCSSVException.CreateFmt('View [%s] not found', [ViewName]);\n  lViewTemplate := StringToUTF8(TFile.ReadAllText(lViewFileName, TEncoding.UTF8));\n  lViewEngine := TSynMustache.Parse(lViewTemplate);\n  Builder.Append(UTF8Tostring(RenderJSON(lViewEngine, FJSONModelAsString, fPartials, fHelpers, nil, false)));\nend;\n\nprocedure TMVCMustacheViewEngine.LoadHelpers;\nbegin\n  if gHelpersLoaded then\n  begin\n    Exit\n  end\n  else\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if not gHelpersLoaded then\n      begin\n        fHelpers := TSynMustache.HelpersGetStandardList;\n        TMVCMustacheHelpers.RegisterHandlers(fHelpers); {dmvcframework specific helpers}\n        gHelpersLoaded := True;\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\nend;\n\nprocedure TMVCMustacheViewEngine.LoadPartials;\nvar\n  lViewsExtension: string;\n  lViewPath: string;\n  lPartialName: String;\n  lPartialFileNames: TStringDynArray;\n  I: Integer;\nbegin\n  if gPartialsLoaded then\n  begin\n    Exit\n  end\n  else\n  begin\n    TMonitor.Enter(gLock);\n    try\n      if not gPartialsLoaded then\n      begin\n        lViewsExtension := Config[TMVCConfigKey.DefaultViewFileExtension];\n        lViewPath := Config[TMVCConfigKey.ViewPath];\n        lPartialFileNames := TDirectory.GetFiles(lViewPath, '*.' + lViewsExtension, TSearchOption.soAllDirectories);\n        FreeAndNil(fPartials);\n        fPartials := TSynMustachePartials.Create;\n        for I := 0 to High(lPartialFileNames) do\n        begin\n          lPartialName := lPartialFileNames[i]\n            .Remove(lPartialFileNames[i].Length - lViewsExtension.Length - 1)\n            .Replace(TPath.DirectorySeparatorChar, '/');\n          lPartialName := lPartialName.Remove(0, lViewPath.Length + 1);\n          fPartials.Add(lPartialName, TFile.ReadAllText(lPartialFileNames[i]));\n        end;\n        gPartialsLoaded := SameText(Config[TMVCConfigKey.ViewCache], 'true');\n      end;\n    finally\n      TMonitor.Exit(gLock);\n    end;\n  end;\nend;\n\n{$WARNINGS ON}\n\n\nprocedure TMVCMustacheViewEngine.PrepareModels;\nvar\n  DataObj: TPair<string, TValue>;\n  lSer: IMVCSerializer;\n  lJSONModel: TJsonObject;\nbegin\n  if fModelPrepared then\n  begin\n    Exit;\n  end;\n\n  lSer := fSerializerPool.GetFromPool(True) as IMVCSerializer;\n  try\n    lJSONModel := TJsonObject.Create;\n    try\n      if Assigned(ViewModel) then\n      begin\n        for DataObj in ViewModel do\n        begin\n          TMVCJsonDataObjectsSerializer(lSer).TValueToJSONObjectProperty(lJSONModel, DataObj.Key, DataObj.Value, TMVCSerializationType.stDefault, nil, nil);\n        end;\n      end;\n      FJSONModelAsString := lJSONModel.ToJSON(False);\n    finally\n      lJSONModel.Free;\n    end;\n  finally\n    fSerializerPool.ReleaseToPool(lSer)\n  end;\n  fModelPrepared := True;\nend;\n\n{ dmvcframework specific helpers}\n\nclass procedure TMVCMustacheHelpers.Capitalize(const Value: variant;\n  out Result: variant);\nbegin\n  Result := MVCFramework.Commons.CamelCase(Value, True);\nend;\n\nclass procedure TMVCMustacheHelpers.RegisterHandlers(var MustacheHelpers: TSynMustacheHelpers);\nbegin\n  TSynMustache.HelperAdd(MustacheHelpers, 'UpperCase', TMVCMustacheHelpers.ToUpperCase);\n  TSynMustache.HelperAdd(MustacheHelpers, 'LowerCase', TMVCMustacheHelpers.ToLowerCase);\n  TSynMustache.HelperAdd(MustacheHelpers, 'Capitalize', TMVCMustacheHelpers.Capitalize);\n  TSynMustache.HelperAdd(MustacheHelpers, 'SnakeCase', TMVCMustacheHelpers.SnakeCase);\n  if Assigned(fOnLoadCustomHelpers) then\n  begin\n    fOnLoadCustomHelpers(MustacheHelpers);\n  end;\nend;\n\nclass procedure TMVCMustacheHelpers.SnakeCase(const Value: variant;\n  out Result: variant);\nbegin\n  Result := MVCFramework.Commons.SnakeCase(Value);\nend;\n\nclass procedure TMVCMustacheHelpers.ToLowerCase(const Value: variant;\n  out Result: variant);\nbegin\n  Result := System.SysUtils.LowerCase(Value);\nend;\n\nclass procedure TMVCMustacheHelpers.ToUpperCase(const Value: variant; out Result: variant);\nbegin\n  Result := System.SysUtils.UpperCase(Value);\nend;\n\n\nend.", "output": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Collections.Generic;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Serializer.Intf;\nusing MVCFramework.IntfObjectPool;\nusing mORMot.Core.Mustache;\nusing mORMot.Core.Unicode;\n\nnamespace MVCFramework.View.Renderers\n{\n    \n    public class MVCMustacheViewEngine : MVCBaseViewEngine\n    {\n        private bool modelPrepared;\n        private string jsonModelAsString;\n\n        private static TSynMustachePartials partials;\n        private static TSynMustacheHelpers helpers;\n        private static IIntfObjectPool serializerPool;\n        private static readonly object globalLock = new object();\n        private static bool gPartialsLoaded = false;\n        private static bool gHelpersLoaded = false;\n\n        \n        public MVCMustacheViewEngine(MVCEngine engine, TWebContext webContext, MVCController controller,\n            MVCViewDataObject viewModel, string contentType)\n            : base(engine, webContext, controller, viewModel, contentType)\n        {\n            modelPrepared = false;\n            LoadPartials();\n            LoadHelpers();\n        }\n\n        static MVCMustacheViewEngine()\n        {\n            serializerPool = TIntfObjectPool.Create(10000, 10, 1, () =>\n            {\n                var serializer = new MVCJsonDataObjectsSerializer();\n                MVCSerializerOptionalCustomTypes.RegisterOptionalCustomTypesSerializers(serializer);\n                return serializer;\n            });\n        }\n\n        \n        protected virtual string RenderJSON(TSynMustache viewEngine, string json, TSynMustachePartials partials,\n            TSynMustacheHelpers helpers, TOnStringTranslate onTranslate, bool escapeInvert)\n        {\n            return viewEngine.RenderJSON(json, partials, helpers, onTranslate, escapeInvert);\n        }\n\n        \n        public override void Execute(string viewName, StringBuilder builder)\n        {\n            PrepareModels();\n\n            string viewFileName = GetRealFileName(viewName);\n            if (string.IsNullOrEmpty(viewFileName))\n                throw new EMVCSSVException($\"View [{viewName}] not found\");\n\n            string viewTemplate = File.ReadAllText(viewFileName, Encoding.UTF8);\n            TSynMustache viewEngine = TSynMustache.Parse(viewTemplate);\n            string rendered = RenderJSON(viewEngine, jsonModelAsString, partials, helpers, null, false);\n            builder.Append(rendered);\n        }\n\n        \n        private void PrepareModels()\n        {\n            if (modelPrepared)\n                return;\n\n            var serializer = (IMVCSerializer)serializerPool.GetFromPool(true);\n            try\n            {\n                var jsonModel = new JsonObject();\n                if (ViewModel != null)\n                {\n                    foreach (var dataPair in ViewModel)\n                    {\n                        ((MVCJsonDataObjectsSerializer)serializer).TValueToJSONObjectProperty(jsonModel, dataPair.Key,\n                            dataPair.Value, TMVCSerializationType.stDefault, null, null);\n                    }\n                }\n                jsonModelAsString = jsonModel.ToJSON();\n            }\n            finally\n            {\n                serializerPool.ReleaseToPool(serializer);\n            }\n            modelPrepared = true;\n        }\n\n        private void LoadPartials()\n        {\n            if (gPartialsLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gPartialsLoaded)\n                {\n                    string viewsExtension = Config[TMVCConfigKey.DefaultViewFileExtension];\n                    string viewPath = Config[TMVCConfigKey.ViewPath];\n                    string[] partialFiles = Directory.GetFiles(viewPath, \"*.\" + viewsExtension, SearchOption.AllDirectories);\n\n                    partials?.Dispose();\n                    partials = new TSynMustachePartials();\n\n                    foreach (string file in partialFiles)\n                    {\n                        string partialName = file.Substring(0, file.Length - (viewsExtension.Length + 1))\n                            .Replace(Path.DirectorySeparatorChar, '/');\n                        partialName = partialName.Substring(viewPath.Length + 1);\n                        string content = File.ReadAllText(file);\n                        partials.Add(partialName, content);\n                    }\n                    gPartialsLoaded = string.Equals(Config[TMVCConfigKey.ViewCache], \"true\", StringComparison.OrdinalIgnoreCase);\n                }\n            }\n        }\n\n        private void LoadHelpers()\n        {\n            if (gHelpersLoaded)\n                return;\n\n            lock (globalLock)\n            {\n                if (!gHelpersLoaded)\n                {\n                    helpers = TSynMustache.HelpersGetStandardList();\n                    MVCMustacheHelpers.RegisterHandlers(ref helpers);\n                    gHelpersLoaded = true;\n                }\n            }\n        }\n    }\n\n    \n    public static class MVCMustacheHelpers\n    {\n        public delegate void TLoadCustomHelpersProc(ref TSynMustacheHelpers mustacheHelpers);\n\n        private static TLoadCustomHelpersProc onLoadCustomHelpers;\n        public static TLoadCustomHelpersProc OnLoadCustomHelpers\n        {\n            get { return onLoadCustomHelpers; }\n            set { onLoadCustomHelpers = value; }\n        }\n\n        \n        public static void RegisterHandlers(ref TSynMustacheHelpers mustacheHelpers)\n        {\n            TSynMustache.HelperAdd(mustacheHelpers, \"UpperCase\", new TSynMustacheHelperDelegate(ToUpperCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"LowerCase\", new TSynMustacheHelperDelegate(ToLowerCase));\n            TSynMustache.HelperAdd(mustacheHelpers, \"Capitalize\", new TSynMustacheHelperDelegate(Capitalize));\n            TSynMustache.HelperAdd(mustacheHelpers, \"SnakeCase\", new TSynMustacheHelperDelegate(SnakeCase));\n\n            onLoadCustomHelpers?.Invoke(ref mustacheHelpers);\n        }\n\n        public static void ToLowerCase(object value, out object result)\n        {\n            result = value?.ToString().ToLower();\n        }\n\n        public static void ToUpperCase(object value, out object result)\n        {\n            result = value?.ToString().ToUpper();\n        }\n\n        public static void Capitalize(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (!string.IsNullOrEmpty(s))\n                result = char.ToUpper(s[0]) + s.Substring(1).ToLower();\n            else\n                result = s;\n        }\n\n        public static void SnakeCase(object value, out object result)\n        {\n            string s = value?.ToString();\n            if (string.IsNullOrEmpty(s))\n            {\n                result = s;\n                return;\n            }\n            var sb = new StringBuilder();\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (char.IsUpper(s[i]))\n                {\n                    if (i > 0)\n                        sb.Append('_');\n                    sb.Append(char.ToLower(s[i]));\n                }\n                else\n                {\n                    sb.Append(s[i]);\n                }\n            }\n            result = sb.ToString();\n        }\n    }\n}"}
{"input": "unit MainDMU;\n\ninterface\n\nuses\n  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,\n  FireDAC.Stan.Param, FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf,\n  FireDAC.DApt.Intf, FireDAC.Stan.StorageBin, Data.DB, FireDAC.Comp.DataSet,\n  FireDAC.Comp.Client;\n\ntype\n  TdmMain = class(TDataModule)\n    dsPeople: TFDMemTable;\n  private\n    { Private declarations }\n  public\n    { Public declarations }\n  end;\n\nimplementation\n\n{%CLASSGROUP 'System.Classes.TPersistent'}\n\n{$R *.dfm}\n\nend.", "output": "using System;\nusing System.ComponentModel;\nusing System.Data;\n\nnamespace MyApp.Data\n{\n    \n    public class TdmMain : Component\n    {\n        private DataTable _dsPeople;\n\n        public TdmMain()\n        {\n            \n            _dsPeople = new DataTable(\"People\");\n            \n            \n        }\n\n        \n        public DataTable DsPeople\n        {\n            get { return _dsPeople; }\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.SecurityHeaders;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework;\n\ntype\n  TMVCSecurityHeadersMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  public\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      var AHandled: Boolean);\n    procedure OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  end;\n\nimplementation\n\n{ TMVCSecurityHeadersMiddleware }\n\nprocedure TMVCSecurityHeadersMiddleware.OnAfterControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnBeforeControllerAction(\n  AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionName: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCSecurityHeadersMiddleware.OnBeforeRouting(AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  AContext.Response.SetCustomHeader('X-XSS-Protection', '1; mode = block');\n  AContext.Response.SetCustomHeader('X-Content-Type-Options', 'nosniff');\nend;\n\nend.", "output": "using System;\nusing MVCFramework;\n\nnamespace MVCFramework.Middleware\n{\n    \n    public class MVCSecurityHeadersMiddleware : IMVCMiddleware\n    {\n        \n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            context.Response.SetCustomHeader(\"X-XSS-Protection\", \"1; mode=block\");\n            context.Response.SetCustomHeader(\"X-Content-Type-Options\", \"nosniff\");\n        }\n\n        \n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Do nothing.\n        }\n\n        \n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Do nothing.\n        }\n\n        \n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            // Do nothing.\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.Middleware.Compression;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Logger;\n\ntype\n  TMVCCompressionMiddleware = class(TInterfacedObject, IMVCMiddleware)\n  private\n    fCompressionThreshold: Integer;\n  protected\n    procedure OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\n    procedure OnBeforeRouting(AContext: TWebContext; var AHandled: Boolean);\n    procedure OnBeforeControllerAction(AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionNAme: string;\n      var AHandled: Boolean);\n    procedure OnAfterRouting(AContext: TWebContext; const AHandled: Boolean);\n  public\n    constructor Create(aCompressionThreshold: Integer = 1024); virtual;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.ZLib,\n  System.Classes,\n  MVCFramework.Commons;\n\n{ TMVCSalutationMiddleware }\n\nconstructor TMVCCompressionMiddleware.Create(aCompressionThreshold: Integer);\nbegin\n  inherited Create;\n  fCompressionThreshold := aCompressionThreshold;\nend;\n\nprocedure TMVCCompressionMiddleware.OnAfterControllerAction(\n      AContext: TWebContext;\n      const AControllerQualifiedClassName: string; const AActionName: string;\n      const AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCCompressionMiddleware.OnAfterRouting(AContext: TWebContext;\n  const AHandled: Boolean);\nvar\n  lMemStream: TMemoryStream;\n  lContentStream: TStream;\n  lAcceptEncoding: string;\n  lEncodings: TArray<string>;\n  lItem: string;\n  lRespCompressionType: TMVCCompressionType;\n  lTmpItem: string;\n{.$IF not Defined(ALEXANDRIAORBETTER)}\n  lZStream: TZCompressionStream;\n{.$ENDIF}\nbegin\n  if IsLibrary then\n  begin\n    Exit;\n  end;\n  lContentStream := AContext.Response.RawWebResponse.ContentStream;\n  if (lContentStream = nil) or (lContentStream.Size <= fCompressionThreshold)\n  then\n    Exit;\n\n  lAcceptEncoding := AContext.Request.Headers['Accept-Encoding'];\n  if lAcceptEncoding.IsEmpty then\n  begin\n    Exit;\n  end;\n  lAcceptEncoding := lAcceptEncoding.Trim.ToLower;\n\n  lRespCompressionType := TMVCCompressionType.ctNone;\n  lEncodings := lAcceptEncoding.Split([',']);\n  for lItem in lEncodings do\n  begin\n    lTmpItem := lItem.Trim;\n    if lTmpItem = 'gzip' then\n    begin\n{.$IF Defined(ALEXANDRIAORBETTER)}\n      {\n        There is a bug in 11 Alexandria with TZCompressionStream, so the gzip compression\n        is not available until the fix.\n        The issue has been created on https://quality.embarcadero.com/browse/RSP-35516\n      }\n{.$ELSE}\n      lRespCompressionType := TMVCCompressionType.ctGZIP;\n      break;\n{.$ENDIF}\n    end\n    else if lTmpItem = 'deflate' then\n    begin\n      lRespCompressionType := TMVCCompressionType.ctDeflate;\n      break;\n    end;\n  end;\n\n  if lRespCompressionType = TMVCCompressionType.ctNone then\n    Exit;\n\n  { When it is a TFileStream copy it to a TMemoryStream, as TFileStream is read only }\n  // if lContentStream is TFileStream then\n  // begin\n  lMemStream := TMemoryStream.Create;\n  try\n{.$IF Defined(ALEXANDRIAORBETTER)}\n    //ZCompressStream(lContentStream, lMemStream);\n    // use it only for deflate, ZCompressStream (Delphi 11.0) cannot\n    // create gzip compliant streams\n{.$ELSE}\n    lZStream := TZCompressionStream.Create(lMemStream,\n      TZCompressionLevel.zcMax, MVC_COMPRESSION_ZLIB_WINDOW_BITS\n      [lRespCompressionType]);\n    try\n      lContentStream.Position := 0;\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n//    There is a bug in 11 Alexandria with TZCompressionStream, this bug\n//    raises an exception here and the debugger catches it, but it its \"normal\" behavior.\n//    The gzip stream is correctly created. Please, vote for its resolution.\n//    https://quality.embarcadero.com/browse/RSP-35516\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!\n      lZStream.CopyFrom(lContentStream, 0);\n    finally\n      lZStream.Free;\n    end;\n{.$ENDIF}\n  except\n    lMemStream.Free;\n    raise;\n  end;\n  lMemStream.Position := 0;\n  AContext.Response.RawWebResponse.ContentStream := lMemStream;\n{$IF Defined(SeattleOrBetter)}\n  AContext.Response.RawWebResponse.ContentEncoding :=\n    MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType];\n{$ELSE}\n  AContext.Response.RawWebResponse.ContentEncoding :=\n    AnsiString(MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType]);\n{$ENDIF}\n  // end;\n  //\n  // lContentStream.Position := 0;\n  // lMemStream := TMemoryStream.Create;\n  // try\n  // ZCompressStream(lContentStream, lMemStream, TZCompressionLevel.zcDefault);\n  // except\n  // lMemStream.Free;\n  // raise;\n  // end;\n  //\n  // { TODO -oDanieleT -cGeneral : Use directly lContentStreamHelper? }\n  // // lZStream := TZCompressionStream.Create(lMemStream, TZCompressionLevel.zcMax,\n  // // MVC_COMPRESSION_ZLIB_WINDOW_BITS[lRespCompressionType]);\n  // // try\n  // // lZStream.CopyFrom(lContentStreamHelper, 0);\n  // // finally\n  // // lZStream.Free;\n  // // end;\n  // lMemStream.Position := 0;\n  //\n  // // AContext.Response.Content := '';\n  // // lContentStreamHelper.Size := 0;\n  // // lContentStreamHelper.CopyFrom(lMemStream, 0);\n  // AContext.Response.RawWebResponse.ContentStream := lMemStream;\n  // {$IF Defined(SeattleOrBetter)}\n  // AContext.Response.RawWebResponse.ContentEncoding :=\n  // MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType];\n  // {$ELSE}\n  // AContext.Response.RawWebResponse.ContentEncoding :=\n  // AnsiString(MVC_COMPRESSION_TYPE_AS_STRING[lRespCompressionType]);\n  // {$ENDIF}\n  // // finally\n  // // lMemStream.Free;\n  // // end;\nend;\n\nprocedure TMVCCompressionMiddleware.OnBeforeControllerAction\n  (AContext: TWebContext; const AControllerQualifiedClassName,\n  AActionNAme: string; var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nprocedure TMVCCompressionMiddleware.OnBeforeRouting(AContext: TWebContext;\n  var AHandled: Boolean);\nbegin\n  // do nothing\nend;\n\nend.", "output": "using System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing MVCFramework; \nusing MVCFramework.Commons; \nusing MVCFramework.Logger;\n\nnamespace MVCFramework.Middleware.Compression\n{\n    \n    public class MVCCompressionMiddleware : IMVCMiddleware\n    {\n        private readonly int _compressionThreshold;\n\n        \n        public MVCCompressionMiddleware(int compressionThreshold = 1024)\n        {\n            _compressionThreshold = compressionThreshold;\n        }\n\n        public void OnBeforeRouting(WebContext context, ref bool handled)\n        {\n            // No routing-time actions required.\n        }\n\n        public void OnBeforeControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, ref bool handled)\n        {\n            // Nothing to do before controller action.\n        }\n\n        public void OnAfterControllerAction(WebContext context, string controllerQualifiedClassName, string actionName, bool handled)\n        {\n            // Nothing to do after controller action.\n        }\n\n       \n        public void OnAfterRouting(WebContext context, bool handled)\n        {\n            \n            if (WebContext.IsLibrary)\n            {\n                return;\n            }\n\n            \n            Stream contentStream = context.Response.RawWebResponse.ContentStream;\n            if (contentStream == null || contentStream.Length <= _compressionThreshold)\n            {\n                return;\n            }\n\n            \n            string acceptEncoding = context.Request.Headers[\"Accept-Encoding\"];\n            if (string.IsNullOrWhiteSpace(acceptEncoding))\n            {\n                return;\n            }\n            acceptEncoding = acceptEncoding.Trim().ToLowerInvariant();\n\n            \n            CompressionType respCompressionType = CompressionType.None;\n            \n            var encodings = acceptEncoding.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                                          .Select(e => e.Trim());\n            foreach (var encoding in encodings)\n            {\n                if (encoding == \"gzip\")\n                {\n                    respCompressionType = CompressionType.GZip;\n                    break;\n                }\n                else if (encoding == \"deflate\")\n                {\n                    respCompressionType = CompressionType.Deflate;\n                    break;\n                }\n            }\n            if (respCompressionType == CompressionType.None)\n            {\n                return;\n            }\n\n            \n            MemoryStream originalContent;\n            if (contentStream is MemoryStream memStream)\n            {\n                originalContent = memStream;\n            }\n            else\n            {\n                originalContent = new MemoryStream();\n                contentStream.CopyTo(originalContent);\n            }\n            originalContent.Position = 0;\n\n            \n            var compressedStream = new MemoryStream();\n            try\n            {\n                \n                if (respCompressionType == CompressionType.GZip)\n                {\n                    using (var gzip = new GZipStream(compressedStream, CompressionLevel.Optimal, leaveOpen: true))\n                    {\n                        originalContent.CopyTo(gzip);\n                    }\n                }\n                else if (respCompressionType == CompressionType.Deflate)\n                {\n                    using (var deflate = new DeflateStream(compressedStream, CompressionLevel.Optimal, leaveOpen: true))\n                    {\n                        originalContent.CopyTo(deflate);\n                    }\n                }\n                \n                compressedStream.Position = 0;\n                \n                context.Response.RawWebResponse.ContentStream = compressedStream;\n                \n                context.Response.RawWebResponse.ContentEncoding = \n                    respCompressionType == CompressionType.GZip ? \"gzip\" : \"deflate\";\n            }\n            catch (Exception ex)\n            {\n                \n                Logger.LogError(\"Compression failed: \" + ex.Message);\n                compressedStream.Dispose();\n                throw;\n            }\n        }\n\n       \n        private enum CompressionType\n        {\n            None,\n            GZip,\n            Deflate\n        }\n    }\n}"}
{"input": "unit BusinessObjects;\n\n// *************************************************************************** }\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\ninterface\n\nuses\n  MVCFramework.Serializer.Commons,\n  MVCFramework.ActiveRecord,\n  MVCFramework.Nullables,\n  MVCFramework.Rtti.Utils,\n  System.Generics.Collections,\n  System.Classes;\n\ntype\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('articles')]\n  TArticles = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: Int64;\n    [MVCTableField('description')]\n    fDescription: String;\n    [MVCTableField('price')]\n    fPrice: Integer;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    property ID: Int64 read fID write fID;\n    property Description: String read fDescription write fDescription;\n    property Price: Integer read fPrice write fPrice;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('order_details')]\n  TOrderDetail = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: NullableInt64;\n    [MVCTableField('id_order')]\n    fIDOrder: Int64;\n    [MVCTableField('id_article')]\n    fIDArticle: Int64;\n    [MVCTableField('unit_price')]\n    fUnitPrice: Currency;\n    [MVCTableField('discount')]\n    fDiscount: Integer;\n    [MVCTableField('quantity')]\n    fQuantity: Integer;\n    [MVCTableField('description')]\n    fDescription: String;\n    [MVCTableField('total')]\n    fTotal: Currency;\n    procedure SetDescription(const Value: String);\n    procedure SetDiscount(const Value: Integer);\n    procedure SetQuantity(const Value: Integer);\n    procedure SetUnitPrice(const Value: Currency);\n  protected\n    procedure OnBeforeInsertOrUpdate; override;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure RecalcTotal;\n    function Clone: TOrderDetail;\n    procedure Assign(Value: TMVCActiveRecord); override;\n    property ID: NullableInt64 read fID write fID;\n    [MVCDoNotSerialize]\n    property IDOrder: Int64 read fIDOrder write fIDOrder;\n    property IDArticle: Int64 read fIDArticle write fIDArticle;\n    property UnitPrice: Currency read fUnitPrice write SetUnitPrice;\n    property Discount: Integer read fDiscount write SetDiscount;\n    property Quantity: Integer read fQuantity write SetQuantity;\n    property Description: String read fDescription write SetDescription;\n    property Total: Currency read fTotal;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  [MVCTable('orders')]\n  TOrder = class(TMVCActiveRecord)\n  private\n    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]\n    fID: NullableUInt64;\n    [MVCTableField('id_customer')]\n    fIDCustomer: Integer;\n    [MVCTableField('order_date')]\n    fOrderDate: TDate;\n    [MVCTableField('total')]\n    fTotal: Currency;\n    [MVCOwned]\n    fDetails: TObjectList<TOrderDetail>;\n  protected\n    procedure OnAfterLoad; override;\n    procedure OnAfterInsertOrUpdate; override;\n    procedure OnBeforeInsertOrUpdate; override;\n    procedure RecalcTotals;\n  public\n    constructor Create; override;\n    destructor Destroy; override;\n    procedure AddOrderItem(const OrderItem: TOrderDetail);\n    procedure UpdateOrderItemByID(const OrderItemID: Integer; const OrderItem: TOrderDetail);\n    function GetOrderDetailByID(const Value: Int64): TOrderDetail;\n    property ID: NullableUInt64 read fID write fID;\n    [MVCNameAs('idCustomer')]\n    property IDCustomer: Integer read fIDCustomer write fIDCustomer;\n    property OrderDate: TDate read fOrderDate write fOrderDate;\n    property Total: Currency read fTotal write fTotal;\n    property OrderItems: TObjectList<TOrderDetail> read fDetails;\n  end;\n\n  [MVCNameCase(ncCamelCase)]\n  TOrderIn = class\n  private\n    fID: NullableUInt64;\n    fIDCustomer: NullableUInt64;\n    fOrderDate: NullableTDate;\n    fTotal: NullableCurrency;\n    [MVCOwned(TOrderDetail)]\n    fDetails: TObjectList<TOrderDetail>;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    property ID: NullableUInt64 read fID write fID;\n    [MVCNameAs('idCustomer')]\n    property IDCustomer: NullableUInt64 read fIDCustomer write fIDCustomer;\n    property OrderDate: NullableTDate read fOrderDate write fOrderDate;\n    property Total: NullableCurrency read fTotal write fTotal;\n    property OrderItems: TObjectList<TOrderDetail> read fDetails;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils;\n\nconstructor TArticles.Create;\nbegin\n  inherited Create;\nend;\n\ndestructor TArticles.Destroy;\nbegin\n  inherited;\nend;\n\nprocedure TOrderDetail.Assign(Value: TMVCActiveRecord);\nvar\n  lObj: TOrderDetail;\nbegin\n  if Value is TOrderDetail then\n  begin\n    lObj := TOrderDetail(Value);\n    self.ID := lObj.ID;\n    self.IDOrder := lObj.IDOrder;\n    self.IDArticle := lObj.IDArticle;\n    self.UnitPrice := lObj.UnitPrice;\n    self.Discount := lObj.Discount;\n    self.Quantity := lObj.Quantity;\n    self.Description := lObj.Description;\n  end\n  else\n  begin\n    inherited;\n  end;\nend;\n\nfunction TOrderDetail.Clone: TOrderDetail;\nbegin\n  Result := TOrderDetail.Create;\n  Result.Assign(Self);\nend;\n\nconstructor TOrderDetail.Create;\nbegin\n  inherited Create;\nend;\n\ndestructor TOrderDetail.Destroy;\nbegin\n  inherited;\nend;\n\nprocedure TOrderDetail.OnBeforeInsertOrUpdate;\nbegin\n  inherited;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.RecalcTotal;\nbegin\n  fTotal := fUnitPrice * fQuantity * (1 - fDiscount / 100);\nend;\n\nprocedure TOrderDetail.SetDescription(const Value: String);\nbegin\n  fDescription := Value;\nend;\n\nprocedure TOrderDetail.SetDiscount(const Value: Integer);\nbegin\n  fDiscount := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.SetQuantity(const Value: Integer);\nbegin\n  fQuantity := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrderDetail.SetUnitPrice(const Value: Currency);\nbegin\n  fUnitPrice := Value;\n  RecalcTotal;\nend;\n\nprocedure TOrder.AddOrderItem(const OrderItem: TOrderDetail);\nbegin\n  OrderItem.IDOrder := ID;\n  OrderItems.Add(OrderItem);\nend;\n\nconstructor TOrder.Create;\nbegin\n  inherited Create;\n  fDetails := TObjectList<TOrderDetail>.Create(true);\nend;\n\ndestructor TOrder.Destroy;\nbegin\n  fDetails.Free;\n  inherited;\nend;\n\nfunction TOrder.GetOrderDetailByID(const Value: Int64): TOrderDetail;\nvar\n  lOrderDetail: TOrderDetail;\nbegin\n  inherited;\n  for lOrderDetail in fDetails do\n  begin\n    if lOrderDetail.ID.Value = Value then\n    begin\n      Exit(lOrderDetail);\n    end;\n  end;\n  raise EMVCActiveRecord.Create('Item not found');\nend;\n\nprocedure TOrder.OnAfterInsertOrUpdate;\nbegin\n  inherited;\n  for var lOrderItem in OrderItems do\n  begin\n    lOrderItem.IDOrder := ID;\n    lOrderItem.Store;\n  end;\nend;\n\nprocedure TOrder.OnBeforeInsertOrUpdate;\nbegin\n  inherited;\n  RecalcTotals;\nend;\n\nprocedure TOrder.RecalcTotals;\nbegin\n  fTotal := 0;\n  for var lOrderItem in fDetails do\n  begin\n    fTotal := fTotal + lOrderItem.Total;\n  end;\nend;\n\nprocedure TOrder.UpdateOrderItemByID(const OrderItemID: Integer;\n  const OrderItem: TOrderDetail);\nbegin\n  var lObj := GetOrderDetailByID(OrderItemID);\n  lObj.Assign(OrderItem);\n  lObj.IDOrder := ID;\nend;\n\nprocedure TOrder.OnAfterLoad;\nvar\n  lList: TObjectList<TOrderDetail>;\nbegin\n  inherited;\n  lList := TMVCActiveRecord.SelectRQL<TOrderDetail>(Format('eq(idOrder,%d)',[ID.Value]), 1000);\n  try\n    fDetails.Clear;\n    fDetails.AddRange(lList);\n    lList.OwnsObjects := False;\n  finally\n    lList.Free;\n  end;\nend;\n\n\n{ TOrderIn }\n\nconstructor TOrderIn.Create;\nbegin\n  inherited;\n  fDetails := TObjectList<TOrderDetail>.Create(true);\nend;\n\ndestructor TOrderIn.Destroy;\nbegin\n  fDetails.Free;\n  inherited;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BusinessObjects\n{\n    #region Custom Attributes\n\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCNameCaseAttribute : Attribute\n    {\n        public string NameCase { get; }\n        public MVCNameCaseAttribute(string nameCase)\n        {\n            NameCase = nameCase;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class)]\n    public class MVCTableAttribute : Attribute\n    {\n        public string TableName { get; }\n        public MVCTableAttribute(string tableName)\n        {\n            TableName = tableName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCTableFieldAttribute : Attribute\n    {\n        public string FieldName { get; }\n        \n        public MVCTableFieldAttribute(string fieldName)\n        {\n            FieldName = fieldName;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCOwnedAttribute : Attribute\n    {\n        public Type OwnedType { get; }\n        public MVCOwnedAttribute() { }\n        public MVCOwnedAttribute(Type ownedType)\n        {\n            OwnedType = ownedType;\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]\n    public class MVCNameAsAttribute : Attribute\n    {\n        public string Name { get; }\n        public MVCNameAsAttribute(string name)\n        {\n            Name = name;\n        }\n    }\n\n    #endregion\n\n    #region Base ActiveRecord Class\n\n    public abstract class MVCActiveRecord\n    {\n        public virtual void OnBeforeInsertOrUpdate() { }\n        public virtual void OnAfterInsertOrUpdate() { }\n        public virtual void OnAfterLoad() { }\n        public virtual void Store() { /* Stub: persist changes */ }\n        \n        public virtual void Assign(MVCActiveRecord value)\n        {\n            // Optionally implement a generic assignment if needed.\n        }\n\n        public static List<T> SelectRQL<T>(string query, int limit) where T : MVCActiveRecord, new()\n        {\n            \n            return new List<T>();\n        }\n    }\n\n    #endregion\n\n    #region Business Objects\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"articles\")]\n    public class Articles : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public long ID { get; set; }\n\n        [MVCTableField(\"description\")]\n        public string Description { get; set; }\n\n        [MVCTableField(\"price\")]\n        public int Price { get; set; }\n\n        public Articles() : base() { }\n        ~Articles() { }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"order_details\")]\n    public class OrderDetail : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public long? ID { get; set; }\n\n        [MVCTableField(\"id_order\")]\n        public long IDOrder { get; set; }\n\n        [MVCTableField(\"id_article\")]\n        public long IDArticle { get; set; }\n\n        private decimal _unitPrice;\n        [MVCTableField(\"unit_price\")]\n        public decimal UnitPrice\n        {\n            get => _unitPrice;\n            set { _unitPrice = value; RecalcTotal(); }\n        }\n\n        private int _discount;\n        [MVCTableField(\"discount\")]\n        public int Discount\n        {\n            get => _discount;\n            set { _discount = value; RecalcTotal(); }\n        }\n\n        private int _quantity;\n        [MVCTableField(\"quantity\")]\n        public int Quantity\n        {\n            get => _quantity;\n            set { _quantity = value; RecalcTotal(); }\n        }\n\n        private string _description;\n        [MVCTableField(\"description\")]\n        public string Description\n        {\n            get => _description;\n            set => _description = value;\n        }\n\n        [MVCTableField(\"total\")]\n        public decimal Total { get; private set; }\n\n        public OrderDetail() : base() { }\n        ~OrderDetail() { }\n\n        public override void OnBeforeInsertOrUpdate()\n        {\n            base.OnBeforeInsertOrUpdate();\n            RecalcTotal();\n        }\n\n        public void RecalcTotal()\n        {\n            \n            Total = UnitPrice * Quantity * (1 - Discount / 100m);\n        }\n\n        public OrderDetail Clone()\n        {\n            var clone = new OrderDetail();\n            clone.Assign(this);\n            return clone;\n        }\n\n        public override void Assign(MVCActiveRecord value)\n        {\n            if (value is OrderDetail other)\n            {\n                this.ID = other.ID;\n                this.IDOrder = other.IDOrder;\n                this.IDArticle = other.IDArticle;\n                this.UnitPrice = other.UnitPrice;\n                this.Discount = other.Discount;\n                this.Quantity = other.Quantity;\n                this.Description = other.Description;\n                \n            }\n            else\n            {\n                base.Assign(value);\n            }\n        }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    [MVCTable(\"orders\")]\n    public class Order : MVCActiveRecord\n    {\n        [MVCTableField(\"id\")]\n        public ulong? ID { get; set; }\n\n        [MVCTableField(\"id_customer\")]\n        public int IDCustomer { get; set; }\n\n        [MVCTableField(\"order_date\")]\n        public DateTime OrderDate { get; set; }\n\n        [MVCTableField(\"total\")]\n        public decimal Total { get; set; }\n\n        [MVCOwned]\n        public List<OrderDetail> OrderItems { get; private set; }\n\n        public Order() : base()\n        {\n            OrderItems = new List<OrderDetail>();\n        }\n\n        ~Order() { }\n\n        public void AddOrderItem(OrderDetail orderItem)\n        {\n            if (ID.HasValue)\n            {\n                orderItem.IDOrder = (long)ID.Value;\n            }\n            OrderItems.Add(orderItem);\n        }\n\n        public void UpdateOrderItemByID(long orderItemID, OrderDetail orderItem)\n        {\n            var existing = GetOrderDetailByID(orderItemID);\n            existing.Assign(orderItem);\n            if (ID.HasValue)\n            {\n                existing.IDOrder = (long)ID.Value;\n            }\n        }\n\n        public OrderDetail GetOrderDetailByID(long value)\n        {\n            foreach (var orderDetail in OrderItems)\n            {\n                if (orderDetail.ID.HasValue && orderDetail.ID.Value == value)\n                {\n                    return orderDetail;\n                }\n            }\n            throw new Exception(\"Item not found\");\n        }\n\n        public override void OnAfterInsertOrUpdate()\n        {\n            base.OnAfterInsertOrUpdate();\n            foreach (var orderItem in OrderItems)\n            {\n                if (ID.HasValue)\n                {\n                    orderItem.IDOrder = (long)ID.Value;\n                }\n                orderItem.Store();\n            }\n        }\n\n        public override void OnBeforeInsertOrUpdate()\n        {\n            base.OnBeforeInsertOrUpdate();\n            RecalcTotals();\n        }\n\n        public void RecalcTotals()\n        {\n            Total = OrderItems.Sum(item => item.Total);\n        }\n\n        public override void OnAfterLoad()\n        {\n            base.OnAfterLoad();\n            if (ID.HasValue)\n            {\n                \n                var query = $\"eq(idOrder,{ID.Value})\";\n                var list = SelectRQL<OrderDetail>(query, 1000);\n                OrderItems.Clear();\n                OrderItems.AddRange(list);\n            }\n        }\n    }\n\n    [MVCNameCase(\"camelCase\")]\n    public class OrderIn\n    {\n        public ulong? ID { get; set; }\n        [MVCNameAs(\"idCustomer\")]\n        public ulong? IDCustomer { get; set; }\n        public DateTime? OrderDate { get; set; }\n        public decimal? Total { get; set; }\n        [MVCOwned(typeof(OrderDetail))]\n        public List<OrderDetail> OrderItems { get; private set; }\n\n        public OrderIn()\n        {\n            OrderItems = new List<OrderDetail>();\n        }\n    }\n\n    #endregion\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit RESTAdapterTestsU;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework.RESTAdapter,\n  DUnitX.TestFramework,\n  BusinessObjectsU,\n  Generics.Collections,\n  JsonDataObjects,\n  MVCFramework.RESTClient,\n  MVCFramework.Commons,\n  MVCFramework.Serializer.Commons,\n  MVCFramework.RESTClient.Intf;\n\ntype\n\n  [Headers('User-Agent', 'RESTAdapter-Test')]\n  ITESTService = interface(IInvokable)\n    ['{58B9FA23-92F4-4B8E-814B-05232F32A41F}']\n\n    [RESTResource(HttpGet, '/people')]\n    [MVCListOf(TPerson)]\n    function GetPeople: TObjectList<TPerson>;\n\n    [RESTResource(HttpGet, '/people')]\n    [MVCListOf(TPerson)]\n    [Mapping(TPeople)]\n    procedure GetPeopleAsynch(AAsynchRequest: IAsynchRequest);\n\n    [RESTResource(HttpGet, '/people/1')]\n    function GetTonyStark: TPerson;\n\n    [RESTResource(HttpGet, '/people/1')]\n    [Mapping(TPerson)]\n    procedure GetTonyStarkAsynch(AAsynchRequest: IAsynchRequest);\n\n    [RESTResource(HttpGet, '/people/{personid}')]\n    function GetPersonByID([Param('personid')] APersonID: integer): TPerson;\n\n    [RESTResource(httpPOST, '/people')]\n    function SendPerson([Body] ABody: TPerson): TPerson;\n\n    [RESTResource(HttpGet, '/people')]\n    function GetPersonInJSONArray: TJSONArray;\n\n    [Headers('Accept', 'application/json')]\n    [Headers('ContentType', 'application/json')]\n    [RESTResource(HttpGet, '/adapter/testconsumejson')]\n    function HeadersApplicationJSON: TJsonBaseObject;\n\n    [Headers('Accept', 'text/plain')]\n    [Headers('ContentType', 'text/plain')]\n    [RESTResource(HttpGet, '/testconsumes')]\n    function HeadersTextPlain: string;\n\n    [Headers('Accept', 'text/plain')]\n    [Headers('ContentType', 'text/plain')]\n    [RESTResource(HttpGet, '/adapter/testconsumejson')]\n    function ApplicationJSONWithTextPlainHeader: IMVCRESTResponse;\n\n  end;\n\n  [TestFixture]\n  TTestRESTAdapter = class(TObject)\n  private\n    RESTAdapter: TRESTAdapter<ITESTService>;\n    TESTService: ITESTService;\n  public\n    [SetUp]\n    procedure SetUp;\n    [Test]\n    procedure TestGetPeople;\n    [Test]\n    procedure TestGetPeopleAsynch;\n    [Test]\n    procedure TestGetTonyStark;\n    [Test]\n    procedure TestGetTonyStarkAsynch;\n    [Test]\n    procedure TestPostPerson;\n    [Test]\n    procedure TestGetPersonByID;\n    [Test]\n    procedure TestHeadersApplicationJSON;\n    [Test]\n    procedure TestHeadersTextPlain;\n    [Test]\n    procedure TestApplicationJSONWithHeaderTextPlain;\n    [Test]\n    procedure TestGetPersonInJSONArray;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils,\n  System.Rtti,\n  System.SyncObjs,\n  LiveServerTestU,\n  TestConstsU;\n\n{ TTestRESTAdapter }\n\nprocedure TTestRESTAdapter.SetUp;\nbegin\n  inherited;\n  RESTAdapter := TRESTAdapter<ITESTService>.Create;\n  TESTService := RESTAdapter.Build(TEST_SERVER_ADDRESS, 8888);\nend;\n\nprocedure TTestRESTAdapter.TestGetPersonByID;\nvar\n  Person: TPerson;\nbegin;\n  Person := TESTService.GetPersonByID(1);\n  try\n    Assert.AreEqual('Tony', Person.FirstName);\n    Assert.AreEqual('Stark', Person.LastName);\n    Assert.isTrue(Person.Married);\n  finally\n    Person.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetPersonInJSONArray;\nvar\n  JSONArray: TJSONArray;\nbegin\n  JSONArray := TESTService.GetPersonInJSONArray;\n  try\n    Assert.isTrue(JSONArray.ToString.Contains('Tony'));\n    Assert.isTrue(JSONArray.ToString.Contains('Stark'));\n    Assert.isTrue(JSONArray.ToString.Contains('Bruce'));\n    Assert.isTrue(JSONArray.ToString.Contains('Banner'));\n  finally\n    JSONArray.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetTonyStark;\nvar\n  Person: TPerson;\nbegin;\n  Person := TESTService.GetTonyStark;\n  try\n    Assert.AreEqual('Tony', Person.FirstName);\n    Assert.AreEqual('Stark', Person.LastName);\n    Assert.isTrue(Person.Married);\n  finally\n    Person.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetTonyStarkAsynch;\nvar\n  AsynchRequest: IAsynchRequest;\n  Person: TPerson;\n  LEvt: TEvent;\nbegin\n  LEvt := TEvent.Create;\n  try\n    AsynchRequest := TAsynchRequest.Create(\n      procedure(AValue: TValue)\n      begin\n        Person := AValue.AsType<TPerson>;\n        LEvt.SetEvent;\n      end);\n    TESTService.GetTonyStarkAsynch(AsynchRequest);\n    // attend for max 5 seconds\n    Assert.isTrue(TWaitResult.wrSignaled = LEvt.WaitFor(5000), 'Timeout request');\n    Assert.IsNotNull(Person);\n    try\n      Assert.AreEqual('Tony', Person.FirstName);\n      Assert.AreEqual('Stark', Person.LastName);\n      Assert.isTrue(Person.Married);\n    finally\n      Person.Free;\n    end;\n  finally\n    LEvt.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestHeadersApplicationJSON;\nvar\n  Res: TJSONObject;\nbegin\n  Res := TESTService.HeadersApplicationJSON as TJSONObject;\n  try\n    Assert.AreEqual('Hello World', Res.S['key']);\n  finally\n    Res.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestHeadersTextPlain;\nvar\n  Res: string;\nbegin\n  Res := TESTService.HeadersTextPlain;\n  Assert.AreEqual('Hello World', Res);\nend;\n\nprocedure TTestRESTAdapter.TestPostPerson;\nvar\n  Person: TPerson;\n  RetPerson: TPerson;\nbegin\n  Person := TPerson.GetNew('Peter', 'Parker', 0, false);\n  RetPerson := TESTService.SendPerson(Person);\n  try\n    Assert.AreEqual('Peter', RetPerson.FirstName);\n    Assert.AreEqual('Parker', RetPerson.LastName);\n    Assert.IsFalse(RetPerson.Married);\n  finally\n    RetPerson.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestApplicationJSONWithHeaderTextPlain;\nvar\n  Resp: IMVCRESTResponse;\nbegin\n  // expected 404 because is not consumed text/plain\n  Resp := TESTService.ApplicationJSONWithTextPlainHeader;\n  Assert.AreEqual<Integer>(404, Resp.StatusCode);\nend;\n\nprocedure TTestRESTAdapter.TestGetPeople;\nvar\n  ListPerson: TObjectList<TPerson>;\nbegin\n  ListPerson := TESTService.GetPeople;\n  try\n    ListPerson.OwnsObjects := True;\n    Assert.isTrue(ListPerson.Count > 0);\n    Assert.AreEqual('Tony', ListPerson[0].FirstName);\n    Assert.AreEqual('Stark', ListPerson[0].LastName);\n  finally\n    ListPerson.Free;\n  end;\nend;\n\nprocedure TTestRESTAdapter.TestGetPeopleAsynch;\nvar\n  AsynchRequest: IAsynchRequest;\n  People: TPeople;\n  LEvt: TEvent;\nbegin\n  LEvt := TEvent.Create;\n  try\n    AsynchRequest := TAsynchRequest.Create(\n      procedure(AValue: TValue)\n      begin\n        People := AValue.AsType<TPeople>;\n        LEvt.SetEvent;\n      end);\n    TESTService.GetPeopleAsynch(AsynchRequest);\n\n    // wait for max 5 seconds\n    Assert.isTrue(TWaitResult.wrSignaled = LEvt.WaitFor(5000), 'Timeout request');\n    Assert.IsNotNull(People);\n    try\n      People.OwnsObjects := True;\n      Assert.isTrue(People.Count > 0);\n      Assert.AreEqual('Tony', People[0].FirstName);\n      Assert.AreEqual('Stark', People[0].LastName);\n    finally\n      People.Free;\n    end;\n  finally\n    LEvt.Free;\n  end;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestRESTAdapter);\n\nfinalization\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing NUnit.Framework;\nusing MVCFramework.RESTAdapter;\nusing MVCFramework.RESTClient.Intf;\nusing MVCFramework.Commons;\nusing JsonDataObjects;\nusing BusinessObjectsU;\n\nnamespace REST\n{\n    [Headers(\"User-Agent\", \"RESTAdapter-Test\")]\n    public interface ITestService : IInvokable\n    {\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        [MVCListOf(typeof(TPerson))]\n        List<TPerson> GetPeople();\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        [MVCListOf(typeof(TPerson))]\n        [Mapping(typeof(TPeople))]\n        void GetPeopleAsynch(IAsynchRequest asynchRequest);\n        [RESTResource(HttpMethod.Get, \"/people/1\")]\n        TPerson GetTonyStark();\n        [RESTResource(HttpMethod.Get, \"/people/1\")]\n        [Mapping(typeof(TPerson))]\n        void GetTonyStarkAsynch(IAsynchRequest asynchRequest);\n        [RESTResource(HttpMethod.Get, \"/people/{personid}\")]\n        TPerson GetPersonByID([Param(\"personid\")] int personId);\n        [RESTResource(HttpMethod.Post, \"/people\")]\n        TPerson SendPerson([Body] TPerson body);\n        [RESTResource(HttpMethod.Get, \"/people\")]\n        TJSONArray GetPersonInJSONArray();\n        [Headers(\"Accept\", \"application/json\")]\n        [Headers(\"ContentType\", \"application/json\")]\n        [RESTResource(HttpMethod.Get, \"/adapter/testconsumejson\")]\n        TJsonBaseObject HeadersApplicationJSON();\n        [Headers(\"Accept\", \"text/plain\")]\n        [Headers(\"ContentType\", \"text/plain\")]\n        [RESTResource(HttpMethod.Get, \"/testconsumes\")]\n        string HeadersTextPlain();\n        [Headers(\"Accept\", \"text/plain\")]\n        [Headers(\"ContentType\", \"text/plain\")]\n        [RESTResource(HttpMethod.Get, \"/adapter/testconsumejson\")]\n        IMVCRESTResponse ApplicationJSONWithTextPlainHeader();\n    }\n\n    [TestFixture]\n    public class TestRESTAdapter\n    {\n        private TRESTAdapter<ITestService> restAdapter;\n        private ITestService testService;\n\n        [SetUp]\n        public void SetUp()\n        {\n            restAdapter = new TRESTAdapter<ITestService>();\n            testService = restAdapter.Build(TestConsts.TEST_SERVER_ADDRESS, 8888);\n        }\n\n        [Test]\n        public void TestGetPeople()\n        {\n            List<TPerson> listPerson = testService.GetPeople();\n            Assert.IsTrue(listPerson.Count > 0);\n            Assert.AreEqual(\"Tony\", listPerson[0].FirstName);\n            Assert.AreEqual(\"Stark\", listPerson[0].LastName);\n        }\n\n        [Test]\n        public void TestGetPeopleAsynch()\n        {\n            var evt = new EventWaitHandle(false, EventResetMode.AutoReset);\n            TPeople people = null;\n            IAsynchRequest asynchRequest = new TAsynchRequest(value => { people = value.AsType<TPeople>(); evt.Set(); });\n            testService.GetPeopleAsynch(asynchRequest);\n            Assert.IsTrue(evt.WaitOne(5000));\n            Assert.IsNotNull(people);\n            people.OwnsObjects = true;\n            Assert.IsTrue(people.Count > 0);\n            Assert.AreEqual(\"Tony\", people[0].FirstName);\n            Assert.AreEqual(\"Stark\", people[0].LastName);\n        }\n\n        [Test]\n        public void TestGetTonyStark()\n        {\n            TPerson person = testService.GetTonyStark();\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestGetTonyStarkAsynch()\n        {\n            var evt = new EventWaitHandle(false, EventResetMode.AutoReset);\n            TPerson person = null;\n            IAsynchRequest asynchRequest = new TAsynchRequest(value => { person = value.AsType<TPerson>(); evt.Set(); });\n            testService.GetTonyStarkAsynch(asynchRequest);\n            Assert.IsTrue(evt.WaitOne(5000));\n            Assert.IsNotNull(person);\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestPostPerson()\n        {\n            TPerson person = TPerson.GetNew(\"Peter\", \"Parker\", 0, false);\n            TPerson retPerson = testService.SendPerson(person);\n            Assert.AreEqual(\"Peter\", retPerson.FirstName);\n            Assert.AreEqual(\"Parker\", retPerson.LastName);\n            Assert.IsFalse(retPerson.Married);\n        }\n\n        [Test]\n        public void TestGetPersonByID()\n        {\n            TPerson person = testService.GetPersonByID(1);\n            Assert.AreEqual(\"Tony\", person.FirstName);\n            Assert.AreEqual(\"Stark\", person.LastName);\n            Assert.IsTrue(person.Married);\n        }\n\n        [Test]\n        public void TestHeadersApplicationJSON()\n        {\n            TJSONObject res = testService.HeadersApplicationJSON() as TJSONObject;\n            Assert.AreEqual(\"Hello World\", res.S[\"key\"]);\n        }\n\n        [Test]\n        public void TestHeadersTextPlain()\n        {\n            string res = testService.HeadersTextPlain();\n            Assert.AreEqual(\"Hello World\", res);\n        }\n\n        [Test]\n        public void TestApplicationJSONWithHeaderTextPlain()\n        {\n            IMVCRESTResponse resp = testService.ApplicationJSONWithTextPlainHeader();\n            Assert.AreEqual(404, resp.StatusCode);\n        }\n\n        [Test]\n        public void TestGetPersonInJSONArray()\n        {\n            TJSONArray jsonArray = testService.GetPersonInJSONArray();\n            string jsonStr = jsonArray.ToString();\n            Assert.IsTrue(jsonStr.Contains(\"Tony\"));\n            Assert.IsTrue(jsonStr.Contains(\"Stark\"));\n            Assert.IsTrue(jsonStr.Contains(\"Bruce\"));\n            Assert.IsTrue(jsonStr.Contains(\"Banner\"));\n        }\n    }\n}"}
{"input": "unit StandaloneServerTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework,\n  System.Classes,\n  System.SysUtils,\n  System.Generics.Collections,\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Server,\n  MVCFramework.Server.Impl;\n\ntype\n\n  [MVCPath('/')]\n  TTestController = class(TMVCController)\n  public\n    [MVCPath('/hello')]\n    [MVCHTTPMethod([httpGET])]\n    procedure HelloWorld(ctx: TWebContext);\n  end;\n\n  [TestFixture]\n  TTestServerContainer = class(TObject)\n  protected\n    [SetUp]\n    procedure SetUp;\n    [TearDown]\n    procedure TearDown;\n  public\n    [Test]\n    procedure TestListener;\n    [Test]\n    procedure TestListenerContext;\n    [Test]\n    procedure TestServerListenerAndClient;\n  end;\n\nimplementation\n\nuses\n  MVCFramework.RESTClient,\n  MVCFramework.RESTClient.Intf,\n  StandAloneServerWebModuleTest;\n\n{ TTestServerContainer }\n\nprocedure TTestServerContainer.SetUp;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerContainer.TearDown;\nbegin\n  inherited;\n\nend;\n\nprocedure TTestServerContainer.TestListener;\nvar\n  lListener: IMVCListener;\nbegin\n  lListener := TMVCListener.Create(TMVCListenerProperties.New.SetName('Listener1').SetPort(5000).SetMaxConnections(512)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  Assert.IsTrue(Assigned(lListener));\n\n  lListener.Start;\n  Assert.IsTrue(lListener.Active);\n\n  lListener.Stop;\n  Assert.IsFalse(lListener.Active);\nend;\n\nprocedure TTestServerContainer.TestServerListenerAndClient;\nvar\n  lListener: IMVCListener;\n  LClient: IMVCRESTClient;\nbegin\n  lListener := TMVCListener.Create(TMVCListenerProperties.New.SetName('Listener1').SetPort(6000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  Assert.IsTrue(Assigned(lListener));\n\n  lListener.Start;\n  Assert.IsTrue(lListener.Active);\n\n  LClient := TMVCRESTClient.New.BaseURL('localhost', 6000);\n  LClient.SetBasicAuthorization('dmvc', '123');\n  Assert.AreEqual('Hello World called with GET', LClient.Get('/hello').Content);\n\n  lListener.Stop;\n  Assert.IsFalse(lListener.Active);\nend;\n\nprocedure TTestServerContainer.TestListenerContext;\nvar\n  LListenerCtx: IMVCListenersContext;\nbegin\n  LListenerCtx := TMVCListenersContext.Create;\n\n  LListenerCtx.Add(TMVCListenerProperties.New.SetName('Listener2').SetPort(6000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass));\n\n  LListenerCtx.Add(TMVCListenerProperties.New.SetName('Listener3').SetPort(7000).SetMaxConnections(1024)\n    .SetWebModuleClass(TestWebModuleClass2));\n\n  Assert.IsTrue(Assigned(LListenerCtx.FindByName('Listener2')));\n  Assert.IsTrue(Assigned(LListenerCtx.FindByName('Listener3')));\n\n  LListenerCtx.StartAll;\n\n  Assert.IsTrue(LListenerCtx.Count = 2);\n  Assert.IsTrue(LListenerCtx.FindByName('Listener2').Active);\n  Assert.IsTrue(LListenerCtx.FindByName('Listener3').Active);\n\n  LListenerCtx.StopAll;\n\n  Assert.IsFalse(LListenerCtx.FindByName('Listener2').Active);\n  Assert.IsFalse(LListenerCtx.FindByName('Listener3').Active);\n\n  LListenerCtx.Remove('Listener2').Remove('Listener3');\n\n  Assert.IsTrue(LListenerCtx.Count = 0);\nend;\n\n{ TTestController }\n\nprocedure TTestController.HelloWorld(ctx: TWebContext);\nbegin\n  Render('Hello World called with GET');\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestServerContainer);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing MVCFramework;\nusing MVCFramework.Commons;\nusing MVCFramework.Server;\nusing MVCFramework.Server.Impl;\nusing MVCFramework.RESTClient;\nusing MVCFramework.RESTClient.Intf;\nusing NUnit.Framework;\nusing StandAloneServerWebModuleTest;\n\nnamespace StandaloneServerTest\n{\n    [Route(\"/\")]\n    public class TestController : MVCController\n    {\n        [Route(\"hello\")]\n        [HttpGet]\n        public void HelloWorld(WebContext ctx)\n        {\n            Render(\"Hello World called with GET\");\n        }\n    }\n\n    [TestFixture]\n    public class TestServerContainer\n    {\n        [SetUp]\n        public void SetUp() { }\n        [TearDown]\n        public void TearDown() { }\n\n        [Test]\n        public void TestListener()\n        {\n            IMVCListener listener = MVCListener.Create(\n                MVCListenerProperties.New()\n                .SetName(\"Listener1\")\n                .SetPort(5000)\n                .SetMaxConnections(512)\n                .SetWebModuleClass(TestWebModuleClass));\n            Assert.IsNotNull(listener);\n            listener.Start();\n            Assert.IsTrue(listener.Active);\n            listener.Stop();\n            Assert.IsFalse(listener.Active);\n        }\n\n        [Test]\n        public void TestServerListenerAndClient()\n        {\n            IMVCListener listener = MVCListener.Create(\n                MVCListenerProperties.New()\n                .SetName(\"Listener1\")\n                .SetPort(6000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass));\n            Assert.IsNotNull(listener);\n            listener.Start();\n            Assert.IsTrue(listener.Active);\n            IMVCRESTClient client = RESTClient.New().BaseURL(\"localhost\", 6000);\n            client.SetBasicAuthorization(\"dmvc\", \"123\");\n            Assert.AreEqual(\"Hello World called with GET\", client.Get(\"/hello\").Content);\n            listener.Stop();\n            Assert.IsFalse(listener.Active);\n        }\n\n        [Test]\n        public void TestListenerContext()\n        {\n            IMVCListenersContext listenerContext = MVCListenersContext.Create();\n            listenerContext.Add(\n                MVCListenerProperties.New()\n                .SetName(\"Listener2\")\n                .SetPort(6000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass));\n            listenerContext.Add(\n                MVCListenerProperties.New()\n                .SetName(\"Listener3\")\n                .SetPort(7000)\n                .SetMaxConnections(1024)\n                .SetWebModuleClass(TestWebModuleClass2));\n            Assert.IsNotNull(listenerContext.FindByName(\"Listener2\"));\n            Assert.IsNotNull(listenerContext.FindByName(\"Listener3\"));\n            listenerContext.StartAll();\n            Assert.AreEqual(2, listenerContext.Count);\n            Assert.IsTrue(listenerContext.FindByName(\"Listener2\").Active);\n            Assert.IsTrue(listenerContext.FindByName(\"Listener3\").Active);\n            listenerContext.StopAll();\n            Assert.IsFalse(listenerContext.FindByName(\"Listener2\").Active);\n            Assert.IsFalse(listenerContext.FindByName(\"Listener3\").Active);\n            listenerContext.Remove(\"Listener2\").Remove(\"Listener3\");\n            Assert.AreEqual(0, listenerContext.Count);\n        }\n    }\n}"}
{"input": "unit ControllersU;\n\ninterface\n\nuses\n  MVCFramework,\n  MVCFramework.Commons,\n  MVCFramework.Swagger.Commons,\n  BaseControllerU,\n  EntitiesU;\n\ntype\n  [MVCPath('/mypeople')]\n  [MVCSWAGDefaultModel(TPersonModel, 'MyPerson', 'MyPeople')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('MyPeople')] {commenting this line you get an exception}\n  TMyPeopleController = class(TBaseController<TPerson, TPersonRec>)\n  end;\n\n\n  [MVCPath('/people')]\n  [MVCSWAGDefaultModel(TPersonModel, 'Person', 'People')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('People')] {commenting this line you get an exception}\n  TPeopleController = class(TBaseController<TPerson, TPersonRec>)\n  public\n    {this action is defined only in the child controller but uses the \"DefaultModel\"}\n    [MVCPath('/all2')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all ' + TSwaggerConst.PLURAL_MODEL_NAME +\n      ' (using route /all2, with model specified in controller)',\n      'getAll2' + TSwaggerConst.PLURAL_MODEL_NAME)]\n    [MVCSwagResponses(200, 'Success', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll2; virtual;\n\n    {this action is defined only in the child controller but doesn't use the \"DefaultModel\"}\n    [MVCPath('/all3')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all PersonWithNickNameModel (using route /all3, custom model specified on action)',\n      'getAllPeopleWithNickName')]\n    [MVCSwagResponses(200, 'Success', TPersonWithNickNameModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll3; virtual;\n  end;\n\n\n  [MVCPath('/tallpeople')]\n  [MVCPath('/tallpeoplexxx')]\n  [MVCSWAGDefaultModel(TTallPersonModel, 'TallPerson', 'TallPeople')] {commenting this line you get an exception}\n  [MVCSWAGDefaultSummaryTags('Tall People')] {commenting this line you get an exception}\n  TTallPeopleController = class(TPeopleController)\n  public\n    {this action is defined only in the child controller but uses the \"DefaultModel\"}\n    [MVCPath('/all2')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n      'List all ' + TSwaggerConst.PLURAL_MODEL_NAME +\n      ' (child controller, default controller model)', 'getAll2' + TSwaggerConst.PLURAL_MODEL_NAME)]\n    [MVCSwagResponses(200, 'Success', SWAGUseDefaultControllerModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll2; override;\n\n    [MVCPath('/all3')]\n    [MVCHTTPMethod([httpGET])]\n    [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS, 'List all PersonWithNickNameModel', 'getAllPersonWithNickNameModel')]\n    [MVCSwagResponses(200, 'Success', TPersonWithNickNameModel, True)]\n    [MVCSwagResponses(500, 'Internal Server Error')]\n    procedure GetAll3; override;\n  end;\n\nimplementation\n\nuses\n  JsonDataObjects,\n  System.SysUtils,\n  System.DateUtils,\n  MVCFramework.Controllers.Register;\n\n{ TPeopleController }\n\nprocedure TPeopleController.GetAll2;\nbegin\n\nend;\n\nprocedure TPeopleController.GetAll3;\nbegin\n\nend;\n\n{ TTallPeopleController }\n\nprocedure TTallPeopleController.GetAll2;\nbegin\n  inherited;\n\nend;\n//\nprocedure TTallPeopleController.GetAll3;\nbegin\n  inherited;\n\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Mvc;\nusing Controllers.Base;    \nusing EntitiesU;          \nusing System;\n\npublic static class TSwaggerConst\n{\n    public const string USE_DEFAULT_SUMMARY_TAGS = \"USE_DEFAULT_SUMMARY_TAGS\";\n    public const string PLURAL_MODEL_NAME = \"People\"; \n}\n\npublic class SWAGUseDefaultControllerModel { }\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class MVCSwagDefaultModelAttribute : Attribute\n{\n    public Type ModelType { get; }\n    public string SingularName { get; }\n    public string PluralName { get; }\n    public MVCSwagDefaultModelAttribute(Type modelType, string singularName, string pluralName)\n    {\n        ModelType = modelType;\n        SingularName = singularName;\n        PluralName = pluralName;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class MVCSwagDefaultSummaryTagsAttribute : Attribute\n{\n    public string Tags { get; }\n    public MVCSwagDefaultSummaryTagsAttribute(string tags)\n    {\n        Tags = tags;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\npublic class MVCSwagSummaryAttribute : Attribute\n{\n    public string UseDefaultSummaryTags { get; }\n    public string Description { get; }\n    public string OperationId { get; }\n    public MVCSwagSummaryAttribute(string useDefaultSummaryTags, string description, string operationId)\n    {\n        UseDefaultSummaryTags = useDefaultSummaryTags;\n        Description = description;\n        OperationId = operationId;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]\npublic class MVCSwagResponsesAttribute : Attribute\n{\n    public int StatusCode { get; }\n    public string Description { get; }\n    public object ResponseModel { get; }\n    public bool UseDefault { get; }\n    public MVCSwagResponsesAttribute(int statusCode, string description)\n    {\n        StatusCode = statusCode;\n        Description = description;\n    }\n    public MVCSwagResponsesAttribute(int statusCode, string description, object responseModel, bool useDefault)\n    {\n        StatusCode = statusCode;\n        Description = description;\n        ResponseModel = responseModel;\n        UseDefault = useDefault;\n    }\n}\n\nnamespace ControllersU\n{\n    \n    [Route(\"mypeople\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(PersonModel), \"MyPerson\", \"MyPeople\")]\n    [MVCSwagDefaultSummaryTags(\"MyPeople\")]\n    public class MyPeopleController : BaseController<TPerson, TPersonRec>\n    {\n        // No additional actions are defined.\n    }\n\n    \n    [Route(\"people\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(PersonModel), \"Person\", \"People\")]\n    [MVCSwagDefaultSummaryTags(\"People\")]\n    public class PeopleController : BaseController<TPerson, TPersonRec>\n    {\n        \n        [HttpGet(\"all2\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all \" + TSwaggerConst.PLURAL_MODEL_NAME + \" (using route /all2, with model specified in controller)\",\n            \"getAll2\" + TSwaggerConst.PLURAL_MODEL_NAME)]\n        [MVCSwagResponses(200, \"Success\", typeof(SWAGUseDefaultControllerModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public virtual IActionResult GetAll2()\n        {\n            \n            return Ok();\n        }\n\n        \n        [HttpGet(\"all3\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all PersonWithNickNameModel (using route /all3, custom model specified on action)\",\n            \"getAllPeopleWithNickName\")]\n        [MVCSwagResponses(200, \"Success\", typeof(PersonWithNickNameModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public virtual IActionResult GetAll3()\n        {\n            \n            return Ok();\n        }\n    }\n\n    \n    [Route(\"tallpeople\")]\n    [Route(\"tallpeoplexxx\")]\n    [ApiController]\n    [MVCSwagDefaultModel(typeof(TallPersonModel), \"TallPerson\", \"TallPeople\")]\n    [MVCSwagDefaultSummaryTags(\"Tall People\")]\n    public class TallPeopleController : PeopleController\n    {\n        \n        [HttpGet(\"all2\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all \" + TSwaggerConst.PLURAL_MODEL_NAME + \" (child controller, default controller model)\",\n            \"getAll2\" + TSwaggerConst.PLURAL_MODEL_NAME)]\n        [MVCSwagResponses(200, \"Success\", typeof(SWAGUseDefaultControllerModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public override IActionResult GetAll2()\n        {\n            \n            return base.GetAll2();\n        }\n\n        \n        [HttpGet(\"all3\")]\n        [MVCSwagSummary(TSwaggerConst.USE_DEFAULT_SUMMARY_TAGS,\n            \"List all PersonWithNickNameModel\", \"getAllPersonWithNickNameModel\")]\n        [MVCSwagResponses(200, \"Success\", typeof(PersonWithNickNameModel), true)]\n        [MVCSwagResponses(500, \"Internal Server Error\")]\n        public override IActionResult GetAll3()\n        {\n            \n            return base.GetAll3();\n        }\n    }\n}"}
{"input": "{******************************************************************************}\n{                                                                              }\n{  Delphi SwagDoc Library                                                      }\n{  Copyright (c) 2018 Marcelo Jaloto                                           }\n{  https://github.com/marcelojaloto/SwagDoc                                    }\n{                                                                              }\n{******************************************************************************}\n{                                                                              }\n{  Licensed under the Apache License, Version 2.0 (the \"License\");             }\n{  you may not use this file except in compliance with the License.            }\n{  You may obtain a copy of the License at                                     }\n{                                                                              }\n{      http://www.apache.org/licenses/LICENSE-2.0                              }\n{                                                                              }\n{  Unless required by applicable law or agreed to in writing, software         }\n{  distributed under the License is distributed on an \"AS IS\" BASIS,           }\n{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    }\n{  See the License for the specific language governing permissions and         }\n{  limitations under the License.                                              }\n{                                                                              }\n{******************************************************************************}\n\nunit Json.Schema.Field.DateTimes;\n\ninterface\n\nuses\n  System.Json,\n  Json.Schema.Field,\n  Json.Schema.Common.Types;\n\ntype\n  [ASchemaType(skDateTime)]\n  TJsonFieldDateTime = class(TJsonField)\n  strict protected\n    const c_DateFormat = 'yyyy-MM-dd';\n    const c_TimeFormat = 'HH:mm:ss';\n    const c_DateTimeFormat = c_DateFormat + 'T' + c_TimeFormat;\n\n    function GetFormat: string; virtual;\n  public\n    function ToJsonSchema: TJsonObject; override;\n    property Format: string read GetFormat;\n  end;\n\n  [ASchemaType(skDate)]\n  TJsonFieldDate = class(TJsonFieldDateTime)\n  strict protected\n    function GetFormat: string; override;\n  end;\n\n  [ASchemaType(skTime)]\n  TJsonFieldTime = class(TJsonFieldDateTime)\n  strict protected\n    function GetFormat: string; override;\n  end;\n\nimplementation\n\nuses\n  System.Classes;\n\n{ TJsonFieldDateTime }\n\nfunction TJsonFieldDateTime.GetFormat: string;\nbegin\n  Result := c_DateTimeFormat;\nend;\n\nfunction TJsonFieldDateTime.ToJsonSchema: TJsonObject;\nbegin\n  Result := inherited ToJsonSchema;\n  Result.AddPair('format', GetFormat);\nend;\n\n{ TJsonFieldDate }\n\nfunction TJsonFieldDate.GetFormat: string;\nbegin\n  Result := c_DateFormat;\nend;\n\n{ TJsonFieldTime }\n\nfunction TJsonFieldTime.GetFormat: string;\nbegin\n  Result := c_TimeFormat;\nend;\n\ninitialization\n  RegisterClass(TJsonFieldDateTime);\n  RegisterClass(TJsonFieldDate);\n  RegisterClass(TJsonFieldTime);\n\nend.", "output": "using System;\nusing Newtonsoft.Json.Linq;\nusing Json.Schema.Common.Types;\n\nnamespace Json.Schema.Field.DateTimes\n{\n    \n    public abstract class JsonField\n    {\n        \n        public virtual JObject ToJsonSchema()\n        {\n            return new JObject\n            {\n                // Other common schema properties can be added here.\n            };\n        }\n    }\n\n    [SchemaType(SchemaKind.DateTime)]\n    public class JsonFieldDateTime : JsonField\n    {\n        protected const string DateFormat = \"yyyy-MM-dd\";\n        protected const string TimeFormat = \"HH:mm:ss\";\n        protected const string DateTimeFormat = DateFormat + \"T\" + TimeFormat;\n\n        \n        protected virtual string GetFormat()\n        {\n            return DateTimeFormat;\n        }\n\n        public override JObject ToJsonSchema()\n        {\n            var schema = base.ToJsonSchema();\n            schema[\"format\"] = GetFormat();\n            return schema;\n        }\n\n        \n        public string Format => GetFormat();\n    }\n\n    [SchemaType(SchemaKind.Date)]\n    public class JsonFieldDate : JsonFieldDateTime\n    {\n        \n        protected override string GetFormat()\n        {\n            return DateFormat;\n        }\n    }\n\n    [SchemaType(SchemaKind.Time)]\n    public class JsonFieldTime : JsonFieldDateTime\n    {\n        \n        protected override string GetFormat()\n        {\n            return TimeFormat;\n        }\n    }\n\n    \n    public static class JsonFieldRegistration\n    {\n        static JsonFieldRegistration()\n        {\n           \n            // SchemaRegistry.Register(typeof(JsonFieldDateTime));\n            // SchemaRegistry.Register(typeof(JsonFieldDate));\n            // SchemaRegistry.Register(typeof(JsonFieldTime));\n        }\n    }\n}"}
{"input": "// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// The Initial Developer of the Original Code is Vivaticket S.p.A. https://www.vivaticket.com/\n// The code has been fully donated to the DMVCFramework community without any charge nor rights.\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ***************************************************************************\n\nunit InjectorTestU;\n\ninterface\n\nuses\n  DUnitX.TestFramework, MVCFramework.Container,\n  MVCFramework.Serializer.JsonDataObjects;\n\ntype\n\n  [TestFixture]\n  TTestContainer = class\n  public\n    [Test]\n    procedure TestNotBuiltContainer;\n    [Test]\n    procedure TestUnknownService;\n    [Test]\n    procedure TestTransient;\n    [Test]\n    procedure TestTransientWithDelegate;\n    [Test]\n    procedure TestSingleton;\n    [Test]\n    procedure TestSingletonWithDelegate;\n    [Test]\n    procedure TestSingletonPerRequest;\n    [Test]\n    procedure TestSingletonPerRequestWithDelegate;\n    [Test]\n    procedure TestCascadeConstructorInjection;\n  end;\n\n\n  IServiceA = interface\n    ['{B6C5EAD8-9008-4200-BF33-E3DE5C8A2320}']\n  end;\n\n  IServiceB = interface\n    ['{8418244D-8AEC-4567-A21E-3F4ECD07E227}']\n  end;\n\n  IServiceC = interface\n    ['{A9E5FD77-87FD-4C9C-91BA-79556252DAAD}']\n    function GetServiceA: IServiceA;\n    function GetServiceB: IServiceB;\n  end;\n\n  TServiceA = class(TInterfacedObject, IServiceA)\n\n  end;\n\n  TServiceB = class(TInterfacedObject, IServiceB)\n\n  end;\n\n  TServiceAB = class(TInterfacedObject, IServiceA, IServiceB)\n\n  end;\n\n  TServiceC = class(TInterfacedObject, IServiceC)\n  private\n    fServiceA: IServiceA;\n    fServiceB: IServiceB;\n  protected\n    function GetServiceA: IServiceA;\n    function GetServiceB: IServiceB;\n  public\n    constructor Create(ServiceA: IServiceA; ServiceB: IServiceB);\n  end;\n\nimplementation\n\nuses\n  System.Generics.Collections, MVCFramework.IntfObjectPool, System.SysUtils, System.Classes, SyncObjs,\n  MVCFramework.Serializer.Intf;\n\n{ TTestContainer }\n\nprocedure TTestContainer.TestCascadeConstructorInjection;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  lCont.RegisterType(TServiceB, IServiceB, TRegistrationType.SingletonPerRequest);\n  lCont.RegisterType(TServiceC, IServiceC);\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n\n  // resolve another \"IServiceC\" in the same request - ServiceB is rtSingletonPerRequest\n  var l01 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n  Assert.AreNotEqual(l0.GetServiceA, l01.GetServiceA);\n  Assert.AreEqual(l0.GetServiceB, l01.GetServiceB);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l1 := lResolver.Resolve(TypeInfo(IServiceC)) as IServiceC;\n  Assert.IsNotNull(l0.GetServiceA);\n  Assert.IsNotNull(l0.GetServiceB);\n  Assert.AreNotEqual(l0.GetServiceA, l1.GetServiceA);\n  Assert.AreNotEqual(l0.GetServiceB, l1.GetServiceB);\nend;\n\nprocedure TTestContainer.TestNotBuiltContainer;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  var lResolver := NewServiceContainerResolver(lCont);\n  Assert.WillRaise(\n    procedure\n    begin\n      var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n    end, EMVCContainerError);\nend;\n\nprocedure TTestContainer.TestSingleton;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Singleton);\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Singleton, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd Request\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd Request\n  lResolver := NewServiceContainerResolver(lCont);\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l11 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l10, l11);\n  Assert.AreEqual(l0, l10);\n  Assert.AreEqual(l1, l11);\nend;\n\nprocedure TTestContainer.TestSingletonPerRequest;\nbegin\n  var lCont := NewMVCServiceContainer\n          .RegisterType(TServiceA, IServiceA, TRegistrationType.SingletonPerRequest)\n          .RegisterType(TServiceA, IServiceA, TRegistrationType.SingletonPerRequest, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l00 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l00, l10);\n  Assert.AreNotEqual(l0, l00);\n  Assert.AreNotEqual(l1, l10);\nend;\n\n\nprocedure TTestContainer.TestSingletonPerRequestWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer\n          .RegisterType(function : TInterfacedObject\n                        begin\n                          Result := TServiceA.Create\n                        end, IServiceA, TRegistrationType.SingletonPerRequest)\n          .RegisterType(function : TInterfacedObject\n                        begin\n                          Result := TServiceA.Create\n                        end, IServiceA, TRegistrationType.SingletonPerRequest, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd \"request\"\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd \"request\"\n  lResolver := NewServiceContainerResolver(lCont);\n  var l00 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l00, l10);\n  Assert.AreNotEqual(l0, l00);\n  Assert.AreNotEqual(l1, l10);\nend;\n\nprocedure TTestContainer.TestSingletonWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Singleton);\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Singleton, 'Svc1');\n  lCont.Build;\n\n  // 1\ufffd Request\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreEqual(l2, l3);\n\n  // 2\ufffd Request\n  lResolver := NewServiceContainerResolver(lCont);\n  var l10 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l11 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreEqual(l10, l11);\n  Assert.AreEqual(l0, l10);\n  Assert.AreEqual(l1, l11);\nend;\n\nprocedure TTestContainer.TestTransient;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(TServiceA, IServiceA);\n  lCont.RegisterType(TServiceA, IServiceA, TRegistrationType.Transient, 'Svc1');\n  lCont.Build;\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreNotEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreNotEqual(l2, l3);\nend;\n\nprocedure TTestContainer.TestTransientWithDelegate;\nbegin\n  var lCont := NewMVCServiceContainer;\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA);\n  lCont.RegisterType(function : TInterfacedObject\n                     begin\n                       Result := TServiceA.Create\n                     end, IServiceA, TRegistrationType.Transient, 'Svc1');\n  lCont.Build;\n  var lResolver := NewServiceContainerResolver(lCont);\n  var l0 := lResolver.Resolve(TypeInfo(IServiceA));\n  var l1 := lResolver.Resolve(TypeInfo(IServiceA));\n  Assert.AreNotEqual(l0, l1);\n  var l2 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  var l3 := lResolver.Resolve(TypeInfo(IServiceA), 'Svc1');\n  Assert.AreNotEqual(l2, l3);\nend;\n\nprocedure TTestContainer.TestUnknownService;\nbegin\n  var lCont := NewMVCServiceContainer;\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TServiceA, IServiceB);\n    end, EMVCContainerErrorUnknownService);\n\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TMVCJsonDataObjectsSerializer, IServiceB);\n    end, EMVCContainerErrorUnknownService);\n\n  Assert.WillRaise(\n    procedure\n    begin\n      lCont.RegisterType(TServiceA, IMVCSerializer);\n    end, EMVCContainerErrorUnknownService);\nend;\n\n{ TServiceC }\n\nconstructor TServiceC.Create(ServiceA: IServiceA; ServiceB: IServiceB);\nbegin\n  inherited Create;\n  fServiceA := ServiceA;\n  fServiceB := ServiceB;\nend;\n\nfunction TServiceC.GetServiceA: IServiceA;\nbegin\n  Result := fServiceA;\nend;\n\nfunction TServiceC.GetServiceB: IServiceB;\nbegin\n  Result := fServiceB;\nend;\n\ninitialization\n\nTDUnitX.RegisterTestFixture(TTestContainer);\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing NUnit.Framework;\n\nnamespace InjectorTest\n{\n    #region Service Interfaces and Implementations\n\n    public interface IServiceA { }\n    public interface IServiceB { }\n    public interface IServiceC\n    {\n        IServiceA GetServiceA();\n        IServiceB GetServiceB();\n    }\n\n    public class ServiceA : IServiceA\n    {\n        \n    }\n\n    public class ServiceB : IServiceB\n    {\n        \n\n    \n    public class ServiceAB : IServiceA, IServiceB\n    {\n        // Implementation details...\n    }\n\n    public class ServiceC : IServiceC\n    {\n        private readonly IServiceA _serviceA;\n        private readonly IServiceB _serviceB;\n\n        public ServiceC(IServiceA serviceA, IServiceB serviceB)\n        {\n            _serviceA = serviceA;\n            _serviceB = serviceB;\n        }\n\n        public IServiceA GetServiceA() => _serviceA;\n        public IServiceB GetServiceB() => _serviceB;\n    }\n\n    #endregion\n\n    #region Container and Resolver Stubs\n\n    \n    public enum RegistrationType\n    {\n        Transient,\n        Singleton,\n        SingletonPerRequest\n    }\n\n    \n    public class MVCContainerErrorUnknownServiceException : Exception\n    {\n        public MVCContainerErrorUnknownServiceException(string message) : base(message) { }\n    }\n\n        public class MVCServiceContainer\n    {\n        private readonly Dictionary<(Type serviceType, string key), Func<object>> _registrations = new Dictionary<(Type, string), Func<object>>();\n        private bool _built = false;\n\n        \n        public MVCServiceContainer RegisterType<TImplementation, TService>(RegistrationType regType = RegistrationType.Transient, string key = null)\n            where TImplementation : TService, new()\n        {\n            \n            _registrations[(typeof(TService), key ?? string.Empty)] = () => new TImplementation();\n            return this;\n        }\n\n                public MVCServiceContainer RegisterType<TService>(Func<object> factory, RegistrationType regType = RegistrationType.Transient, string key = null)\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = factory;\n            return this;\n        }\n\n        \n        public MVCServiceContainer Build()\n        {\n            _built = true;\n            return this;\n        }\n\n        public bool IsBuilt => _built;\n    }\n\n    \n    public class ServiceContainerResolver\n    {\n        private readonly MVCServiceContainer _container;\n        private readonly Dictionary<(Type serviceType, string key), object> _perRequestInstances = new Dictionary<(Type, string), object>();\n\n        public ServiceContainerResolver(MVCServiceContainer container)\n        {\n            _container = container;\n        }\n\n        \n        public object Resolve(Type serviceType, string key = \"\")\n        {\n            \n            if (_container == null)\n                throw new Exception(\"Container not built\");\n\n            if (!_container.IsBuilt)\n                throw new Exception(\"Container not built\");\n\n            var regKey = (serviceType, key ?? string.Empty);\n            if (_container._registrations.TryGetValue(regKey, out Func<object> factory))\n            {\n                \n                if (key == string.Empty) \n                {\n                    \n                    if (!_perRequestInstances.ContainsKey(regKey))\n                        _perRequestInstances[regKey] = factory();\n                    return _perRequestInstances[regKey];\n                }\n                else\n                {\n                    \n                    if (!_perRequestInstances.ContainsKey(regKey))\n                        _perRequestInstances[regKey] = factory();\n                    return _perRequestInstances[regKey];\n                }\n            }\n            else\n            {\n                throw new MVCContainerErrorUnknownServiceException(\"Unknown service\");\n            }\n        }\n\n        \n        public T Resolve<T>(string key = null) where T : class\n        {\n            return Resolve(typeof(T), key) as T;\n        }\n    }\n\n    #endregion\n\n    [TestFixture]\n    public class TestContainer\n    {\n        \n        [Test]\n        public void TestNotBuiltContainer()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            var resolver = new ServiceContainerResolver(container);\n            Assert.Throws<Exception>(() => resolver.Resolve(typeof(IServiceA)));\n        }\n\n        \n        [Test]\n        public void TestUnknownService()\n        {\n            var container = new MVCServiceContainer();\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IServiceB>(); \n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType(() => new MVCJsonDataObjectsSerializer(), typeof(IServiceB));\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IMVCSerializer>(); \n            });\n        }\n\n        \n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var s1 = resolver.Resolve<IServiceA>();\n            var s2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(s1, s2);\n\n            var s1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(s1a, s2a);\n        }\n\n        \n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var s1 = resolver.Resolve<IServiceA>();\n            var s2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(s1, s2);\n\n            var s1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(s1a, s2a);\n        }\n\n        \n        [Test]\n        public void TestSingleton()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Singleton);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreEqual(a1, b1);\n            Assert.AreEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonPerRequest()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreNotEqual(a1, b1);\n            Assert.AreNotEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonPerRequestWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.SingletonPerRequest);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreNotEqual(a1, b1);\n            Assert.AreNotEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestSingletonWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Singleton);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var a1 = resolver1.Resolve<IServiceA>();\n            var a2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(a1, a2);\n\n            var a1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(a1a, a2a);\n\n            \n            var resolver2 = new ServiceContainerResolver(container);\n            var b1 = resolver2.Resolve<IServiceA>();\n            var b2 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(b1, b2);\n            Assert.AreEqual(a1, b1);\n            Assert.AreEqual(a2, b2);\n        }\n\n        \n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        \n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), RegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        \n        [Test]\n        public void TestCascadeConstructorInjection()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            container.RegisterType<ServiceB, IServiceB>(RegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceC, IServiceC>();\n            container.Build();\n\n            \n            var resolver1 = new ServiceContainerResolver(container);\n            var serviceC1 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n\n            \n            var serviceC1b = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n            Assert.AreNotEqual(serviceC1.GetServiceA(), serviceC1b.GetServiceA());\n            Assert.AreEqual(serviceC1.GetServiceB(), serviceC1b.GetServiceB());\n\n            \n            resolver1 = new ServiceContainerResolver(container);\n            var serviceC2 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(serviceC1.GetServiceA());\n            Assert.IsNotNull(serviceC1.GetServiceB());\n            Assert.AreNotEqual(serviceC1.GetServiceA(), serviceC2.GetServiceA());\n            Assert.AreNotEqual(serviceC1.GetServiceB(), serviceC2.GetServiceB());\n        }\n    }\n\n    #region Additional Types for Testing\n\n   \n    public class MVCJsonDataObjectsSerializer { }\n\n    public class MVCContainerErrorUnknownServiceException : Exception\n    {\n        public MVCContainerErrorUnknownServiceException(string message) : base(message) { }\n    }\n\n    public interface IMVCSerializer { }\n\n    public enum TRegistrationType\n    {\n        Transient,\n        Singleton,\n        SingletonPerRequest\n    }\n\n    public class MVCServiceContainer\n    {\n        internal readonly Dictionary<(Type, string), Func<object>> _registrations = new Dictionary<(Type, string), Func<object>>();\n        private bool _built = false;\n\n        public MVCServiceContainer RegisterType<TImplementation, TService>(TRegistrationType regType = TRegistrationType.Transient, string key = \"\")\n            where TImplementation : TService, new()\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = () => new TImplementation();\n            return this;\n        }\n\n        public MVCServiceContainer RegisterType<TService>(Func<object> factory, TRegistrationType regType = TRegistrationType.Transient, string key = \"\")\n        {\n            _registrations[(typeof(TService), key ?? string.Empty)] = factory;\n            return this;\n        }\n\n        public MVCServiceContainer Build()\n        {\n            _built = true;\n            return this;\n        }\n\n        public bool IsBuilt => _built;\n    }\n\n    public class ServiceContainerResolver\n    {\n        private readonly MVCServiceContainer _container;\n        private readonly Dictionary<(Type, string), object> _instances = new Dictionary<(Type, string), object>();\n\n        public ServiceContainerResolver(MVCServiceContainer container)\n        {\n            _container = container;\n        }\n\n        public object Resolve(Type serviceType, string key = \"\")\n        {\n            var regKey = (serviceType, key ?? string.Empty);\n            if (!_container._registrations.ContainsKey(regKey))\n                throw new MVCContainerErrorUnknownServiceException(\"Unknown service\");\n            if (!_instances.ContainsKey(regKey))\n                _instances[regKey] = _container._registrations[regKey]();\n            return _instances[regKey];\n        }\n\n        public T Resolve<T>(string key = null) where T : class\n        {\n            return Resolve(typeof(T), key) as T;\n        }\n    }\n\n    public class ServiceA : IServiceA\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceB : IServiceB\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceAB : IServiceA, IServiceB\n    {\n        public Guid Id { get; } = Guid.NewGuid();\n    }\n\n    public class ServiceC : IServiceC\n    {\n        private readonly IServiceA _serviceA;\n        private readonly IServiceB _serviceB;\n        public ServiceC(IServiceA serviceA, IServiceB serviceB)\n        {\n            _serviceA = serviceA;\n            _serviceB = serviceB;\n        }\n\n        public IServiceA GetServiceA() => _serviceA;\n        public IServiceB GetServiceB() => _serviceB;\n    }\n\n    public interface IServiceA { }\n    public interface IServiceB { }\n    public interface IServiceC\n    {\n        IServiceA GetServiceA();\n        IServiceB GetServiceB();\n    }\n\n    #endregion\n\n    [TestFixture]\n    public class TestContainer\n    {\n        [Test]\n        public void TestNotBuiltContainer()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            var resolver = new ServiceContainerResolver(container);\n            Assert.Throws<Exception>(() => resolver.Resolve(typeof(IServiceA)));\n        }\n\n        [Test]\n        public void TestUnknownService()\n        {\n            var container = new MVCServiceContainer();\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IServiceB>();\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType(() => new MVCJsonDataObjectsSerializer(), typeof(IServiceB));\n            });\n            Assert.Throws<MVCContainerErrorUnknownServiceException>(() =>\n            {\n                container.RegisterType<ServiceA, IMVCSerializer>();\n            });\n        }\n\n        [Test]\n        public void TestTransient()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Transient);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        [Test]\n        public void TestTransientWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Transient);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Transient, \"Svc1\");\n            container.Build();\n\n            var resolver = new ServiceContainerResolver(container);\n            var a1 = resolver.Resolve<IServiceA>();\n            var a2 = resolver.Resolve<IServiceA>();\n            Assert.AreNotEqual(a1, a2);\n\n            var a1a = resolver.Resolve<IServiceA>(\"Svc1\");\n            var a2a = resolver.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreNotEqual(a1a, a2a);\n        }\n\n        [Test]\n        public void TestSingleton()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Singleton);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s10 = resolver2.Resolve<IServiceA>();\n            var s11 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s10, s11);\n            Assert.AreEqual(s1, s10);\n            Assert.AreEqual(s2, s11);\n        }\n\n        [Test]\n        public void TestSingletonPerRequest()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceA, IServiceA>(TRegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s00 = resolver2.Resolve<IServiceA>();\n            var s10 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s00, s10);\n            Assert.AreNotEqual(s1, s00);\n            Assert.AreNotEqual(s2, s10);\n        }\n\n        [Test]\n        public void TestSingletonPerRequestWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.SingletonPerRequest);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.SingletonPerRequest, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s00 = resolver2.Resolve<IServiceA>();\n            var s10 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s00, s10);\n            Assert.AreNotEqual(s1, s00);\n            Assert.AreNotEqual(s2, s10);\n        }\n\n        [Test]\n        public void TestSingletonWithDelegate()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Singleton);\n            container.RegisterType<IServiceA>(() => new ServiceA(), TRegistrationType.Singleton, \"Svc1\");\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var s1 = resolver1.Resolve<IServiceA>();\n            var s2 = resolver1.Resolve<IServiceA>();\n            Assert.AreEqual(s1, s2);\n            var s1a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            var s2a = resolver1.Resolve<IServiceA>(\"Svc1\");\n            Assert.AreEqual(s1a, s2a);\n\n            var resolver2 = new ServiceContainerResolver(container);\n            var s10 = resolver2.Resolve<IServiceA>();\n            var s11 = resolver2.Resolve<IServiceA>();\n            Assert.AreEqual(s10, s11);\n            Assert.AreEqual(s1, s10);\n            Assert.AreEqual(s2, s11);\n        }\n\n        [Test]\n        public void TestCascadeConstructorInjection()\n        {\n            var container = new MVCServiceContainer();\n            container.RegisterType<ServiceA, IServiceA>();\n            container.RegisterType<ServiceB, IServiceB>(TRegistrationType.SingletonPerRequest);\n            container.RegisterType<ServiceC, IServiceC>();\n            container.Build();\n\n            var resolver1 = new ServiceContainerResolver(container);\n            var c1 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c1.GetServiceA());\n            Assert.IsNotNull(c1.GetServiceB());\n\n            var c1b = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c1b.GetServiceA());\n            Assert.IsNotNull(c1b.GetServiceB());\n            Assert.AreNotEqual(c1.GetServiceA(), c1b.GetServiceA());\n            Assert.AreEqual(c1.GetServiceB(), c1b.GetServiceB());\n\n            resolver1 = new ServiceContainerResolver(container);\n            var c2 = resolver1.Resolve<IServiceC>();\n            Assert.IsNotNull(c2.GetServiceA());\n            Assert.IsNotNull(c2.GetServiceB());\n            Assert.AreNotEqual(c1.GetServiceA(), c2.GetServiceA());\n            Assert.AreNotEqual(c1.GetServiceB(), c2.GetServiceB());\n        }\n    }\n}"}
{"input": "unit MainWM;\n\ninterface\n\nuses\n  System.SysUtils,\n  System.Classes,\n  Web.HTTPApp,\n  MVCFramework;\n\ntype\n  TTMunicipalLibraryWebModule = class(TWebModule)\n    procedure WebModuleCreate(Sender: TObject);\n    procedure WebModuleDestroy(Sender: TObject);\n  private\n    FMVC: TMVCEngine;\n  public\n    { Public declarations }\n  end;\n\nvar\n  WebModuleClass: TComponentClass = TTMunicipalLibraryWebModule;\n\nimplementation\n\n{$R *.dfm}\n\n\nuses\n  CustomersControllerU,\n  MVCFramework.Middleware.ActiveRecord,\n  System.IOUtils,\n  MVCFramework.Commons,\n  MVCFramework.Middleware.Compression;\n\nprocedure TTMunicipalLibraryWebModule.WebModuleCreate(Sender: TObject);\nbegin\n  FMVC := TMVCEngine.Create(Self,\n    procedure(Config: TMVCConfig)\n    begin\n      // session timeout (0 means session cookie)\n      \n      // default content-type\n      Config[TMVCConfigKey.DefaultContentType] := TMVCConstants.DEFAULT_CONTENT_TYPE;\n      // default content charset\n      Config[TMVCConfigKey.DefaultContentCharset] := TMVCConstants.DEFAULT_CONTENT_CHARSET;\n      // unhandled actions are permitted?\n      Config[TMVCConfigKey.AllowUnhandledAction] := 'false';\n      // default view file extension\n      Config[TMVCConfigKey.DefaultViewFileExtension] := 'html';\n      // view path\n      Config[TMVCConfigKey.ViewPath] := 'templates';\n      // Max Record Count for automatic Entities CRUD\n      Config[TMVCConfigKey.MaxEntitiesRecordCount] := '20';\n      // Enable Server Signature in response\n      Config[TMVCConfigKey.ExposeServerSignature] := 'true';\n      // Max request size in bytes\n      Config[TMVCConfigKey.MaxRequestSize] := IntToStr(TMVCConstants.DEFAULT_MAX_REQUEST_SIZE);\n    end);\n  FMVC.AddController(TCustomersController);\n  // To enable compression (deflate, gzip) just add this middleware as the last one\n  FMVC.AddMiddleware(TMVCActiveRecordMiddleware.Create('activerecorddb'));\n  FMVC.AddMiddleware(TMVCCompressionMiddleware.Create);\nend;\n\nprocedure TTMunicipalLibraryWebModule.WebModuleDestroy(Sender: TObject);\nbegin\n  FMVC.Free;\nend;\n\nend.", "output": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.ResponseCompression;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing System;\nusing System.IO;\nusing System.Linq;\n\nnamespace MunicipalLibraryApp\n{\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var builder = WebApplication.CreateBuilder(args);\n\n            \n            builder.Services.AddControllersWithViews();\n\n            \n            builder.Services.AddResponseCompression(options =>\n            {\n                \n                options.EnableForHttps = true;\n                \n                options.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(new[] { \"application/json\" });\n            });\n\n            \n            var app = builder.Build();\n\n           \n            app.UseResponseCompression();\n\n            \n            app.Use(async (context, next) =>\n            {\n               \n                await next.Invoke();\n            });\n\n            \n            var wwwFolder = Path.Combine(Directory.GetCurrentDirectory(), \"www\");\n            if (Directory.Exists(wwwFolder))\n            {\n                app.UseStaticFiles(new StaticFileOptions\n                {\n                    \n                    RequestPath = \"/app\",\n                    FileProvider = new Microsoft.Extensions.FileProviders.PhysicalFileProvider(Path.GetFullPath(wwwFolder))\n                });\n            }\n\n            app.MapControllers();\n\n            app.MapGet(\"/ping\", () => \"Hello from Municipal Library API\");\n\n            \n            Console.WriteLine(\"Municipal Library API is running on the following URLs:\");\n            foreach (var url in app.Urls)\n            {\n                Console.WriteLine(url);\n            }\n            app.Run();\n        }\n    }\n}"}
{"input": "\ufeff// ***************************************************************************\n//\n// Delphi MVC Framework\n//\n// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team\n//\n// https://github.com/danieleteti/delphimvcframework\n//\n// Collaborators on this file: David Moorhouse (info@moorhouse.net.nz)\n//\n// ***************************************************************************\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// *************************************************************************** }\n\nunit MVCFramework.HTMX;\n\n{$I dmvcframework.inc}\n\ninterface\n\nuses\n  MVCFramework, MVCFramework.Commons, System.Rtti, JsonDataObjects, System.StrUtils;\n\ntype\n  THTMXRequestHeaderType = record\n  public const\n    CurrentUrl = 'HX-Current-URL';\n    HistoryRestoreRequest = 'HX-History-Restore-Request';\n    Prompt = 'HX-Prompt';\n    Request = 'HX-Request';\n    Target = 'HX-Target';\n    TriggerName = 'HX-Trigger-Name';\n    Trigger = 'HX-Trigger';\n    Boosted = 'HX-Boosted';\n    TriggeringEvent = 'Triggering-Event';\n  end;\n\n  ///<summary>Helper class to expose HTMX headers as native functions on WebRequest objects</summary>\n  THTMXRequestHelper = class helper for TMVCWebRequest\n  private\n    function GetHtmxHeader(Header: string): string;\n    function GetHtmxHeaderToBool(Header: string): Boolean;\n    function HasHeader(Header: string): Boolean;\n  public\n    /// <summary>Indicates that the request is triggered by HTMX.</summary>\n    function IsHTMX: Boolean;\n\n    /// <summary>Indicates that the request is via an element using hx-boost.</summary>\n    function HXIsBoosted: Boolean;\n\n    /// <summary>True if the request is for history restoration after a miss in the local history cache</summary>\n    function HXIsHistoryRestoreRequest: Boolean;\n\n    /// <summary>The current URL of the browser.</summary>\n    function HXGetCurrentUrl: string;\n\n    /// <summary>The user response to an hx-prompt.</summary>\n    function HXGetPrompt: string;\n\n    /// <summary>The id of the target element if it exists.</summary>\n    function HXGetTarget: string;\n\n    /// <summary>The id of the triggered element if it exists.</summary>\n    function HXGetTrigger: string;\n\n    /// <summary>The name of the triggered element if it exists.</summary>\n    function HXGetTriggerName: string;\n\n    /// <summary>The value of the header is a JSON serialized</summary>\n    /// <remarks>Requires the event-header extension to be installed and loaded on the page </remarks>\n    /// <see>https://htmx.org/extensions/event-header/ </see>\n    function HXGetTriggeringEvent: TArray<string>;\n\n    /// <summary>The value of the header is a JSON serialized</summary>\n    /// <remarks>Requires the event-header extension to be installed and loaded on the page </remarks>\n    /// <see>https://htmx.org/extensions/event-header/ </see>\n    function HXGetTriggeringEventAsJSON: TJsonObject;\n  end;\n\n  THTMXResponseHeaderType = record\n  public const\n    Location = 'HX-Location';\n    Refresh = 'HX-Refresh';\n    PushURL = 'HX-Push-Url';\n    Redirect = 'HX-Redirect';\n    ReplaceURL = 'HX-Replace-Url';\n    Reselect = 'HX-Reselect';\n    Reswap = 'HX-Reswap';\n    Retarget = 'HX-Retarget';\n    Trigger = 'HX-Trigger';\n    TriggerAfterSettle = 'HX-Trigger-After-Settle';\n    TriggerAfterSwap = 'HX-Trigger-After-Swap';\n  end;\n\n\n  ///<summary>Helper class to expose HTMX options as native functions on WebResponse objects</summary>\n  THTMXResponseHelper = class helper for TMVCWebResponse\n  public type\n    TClientEventType = (etReceived, etSettled, etSwapped);\n    TSwapOption = (soInnerHTML, soOuterHTML, soBeforeBegin, soAfterBegin, soBeforeEnd, soAfterEnd, soDelete, soNone);\n    TShowScrollType = (ssNone, ssShow, ssScroll);\n    TSwapScrollTo = (sstTop, sstBottom);\n  private const\n    ClientEventTypes: array [TClientEventType] of string = (THTMXResponseHeaderType.Trigger,\n      THTMXResponseHeaderType.TriggerAfterSettle, THTMXResponseHeaderType.TriggerAfterSwap);\n    SwapOptions: array [TSwapOption] of string = ('innerHTML', 'outerHTML', 'beforebegin', 'afterbegin', 'beforeend', 'afterend',\n      'delete', 'none');\n    ShowScrollTypes: array [TShowScrollType] of string = ('', 'show', 'scroll');\n    SwapScrollTo: array [TSwapScrollTo] of string = ('top', 'bottom');\n  public\n    /// <summary> Pushes a new url into the browser history history.</summary>\n    /// <remarks>This creates a new history entry, allowing navigation with the browser\ufffds back and forward buttons.\n    /// This is similar to the hx-push-url attribute.\n    /// If present, this header overrides any behavior defined with attributes.</remarks>\n    /// <param name=\"URL\">A URL to be pushed into the location bar.\n    /// This may be relative or absolute, as per history.pushState().\n    /// If omitted, the header will output \"false\", which prevents the browser\ufffds history from being updated.</param>\n    function HXSetPushUrl(URL: string = ''): TMVCWebResponse;\n\n    /// <summary>Replaces the current URL in the browser location history.</summary>\n    /// <remarks>This does not create a new history entry; in effect, it removes the previous current URL from the browser\ufffds history.\n    /// This is similar to the hx-replace-url attribute.\n    /// If present, this header overrides any behavior defined with attributes.</remarks>\n    /// <param name=\"URL\">A URL to replace the current URL in the location bar.\n    /// This may be relative or absolute, as per history.replaceState(), but must have the same origin as the current URL.\n    /// If omitted, the header will output \"false\", which prevents the browser\ufffds current URL from being updated.</param>\n    function HXSetReplaceUrl(URL: string = ''): TMVCWebResponse;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// Check if transition: true works ?\n    function HXSetReswap(Option: TSwapOption): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// <remarks>You can modify the timing of the browser update to synchronize htmx with the timing of CSS transition effects.</remarks>\n    /// <param name=\"SwapDelay\">The amount of time that htmx will wait after receiving a response to swap the content (in milliseconds) default is 0</param>\n    /// <param name=\"SettleDelay\">The amount of time between the swap and the settle logic(in milliseconds) default is 20mS</param>\n    function HXSetReswap(Option: TSwapOption; SwapDelay: Integer; SettleDelay: Integer = 20): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to specify how the response will be swapped. See hx-swap for possible values</summary>\n    /// <remarks>You can modify nature of the browser update to show or scroll to the top or bottom of a target.</remarks>\n    /// <param name=\"Option\">The target for the swap</param>\n    /// <param name=\"ShowScroll\">Whether to set the display to the target, or to scroll to the target</param>\n    /// <param name=\"To\">Either top or bottom</param>\n    /// <param name=\"Selector\">Allows targetting of a different element for scrolling or showing</param>\n    function HXSetReswap(Option: TSwapOption; ShowScroll: TShowScrollType; &To: TSwapScrollTo; Selector: string = '')\n      : TMVCWebResponse; overload;\n\n    /// <summary>A CSS selector that updates the target of the content to a different element on the page</summary>\n    function HXSetRetarget(Selector: string): TMVCWebResponse;\n\n    /// <summary>Allows you to trigger a client side event.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Name\">The name of the javscript event to be triggered</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvent(Name: string; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a collection of client side events.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Names\">A collection of the names of the javscript events to be triggered</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvents(Names: TArray<string>; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a collection of client side events.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"EventsDescriptors\">A JSON object with events descriptors (https://htmx.org/headers/hx-trigger/)</param>\n    function HXTriggerClientEvents(EventsDescriptors: TJSONObject; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>Allows you to trigger a client side event with parameters.</summary>\n    /// <remarks>Using events gives you a lot of flexibility to add functionality to normal htmx responses.</remarks>\n    /// <param name=\"Name\">The name of the javscript event to be triggered</param>\n    /// <param name=\"Params\">An object containing the parameters to be sent to the event</param>\n    /// <param name=\"After\">The timing of the event</param>\n    function HXTriggerClientEvent(Name: string; Params: TValue; After: TClientEventType = etReceived): TMVCWebResponse; overload;\n\n    /// <summary>if set to \ufffdtrue\ufffd the client side will do a a full refresh of the page</summary>\n    function HXSetPageRefresh(Refresh: Boolean = true): TMVCWebResponse;\n\n    /// <summary>Allows you to do a client-side redirect that does not do a full page reload</summary>\n    /// <remarks>Instead of changing the page\ufffds location it will act like following a hx-boost link, creating a new history entry,\n    /// issuing an ajax request to the value of the header and pushing the path into history. </remarks>\n    function HXSetLocation(Path: string): TMVCWebResponse; overload;\n\n    /// <summary>Used to do a client-side redirect to a new location</summary>\n    function HXSetRedirect(Path: string): TMVCWebResponse;\n\n    /// <summary>Sends an error response bcack to client.</summary>\n    function HXSetErrorResponse(ErrorCode: Integer; ErrorMessage: string): TMVCWebResponse;\n\n    /// <summary>A CSS selector that allows you to choose which part of the response is used to be swapped in.</summary>\n    /// <remarks> Overrides an existing hx-select on the triggering element</remarks>\n    /// <param name=\"Selector\">A CSS selector </param>\n    function HXSetReSelect(Selector: string): TMVCWebResponse;\n  end;\n\nimplementation\n\nuses\n  System.SysUtils, MVCFramework.Utils, MVCFramework.Serializer.JsonDataObjects, MVCFramework.Serializer.Commons;\n\n{ THTMXRequestHelper }\n\nfunction THTMXRequestHelper.HXGetCurrentUrl: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.CurrentUrl);\nend;\n\nfunction THTMXRequestHelper.GetHtmxHeader(Header: string): string;\nbegin\n  Result := Headers[Header];\nend;\n\nfunction THTMXRequestHelper.GetHtmxHeaderToBool(Header: string): Boolean;\nbegin\n  Result := SameText('true', Headers[Header]);\nend;\n\nfunction THTMXRequestHelper.HXGetPrompt: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Prompt);\nend;\n\nfunction THTMXRequestHelper.HXGetTarget: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Target);\nend;\n\nfunction THTMXRequestHelper.HXGetTrigger: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.Trigger);\nend;\n\nfunction THTMXRequestHelper.HXGetTriggeringEvent: TArray<string>;\nbegin\n  Result := nil;\n  if HasHeader(THTMXRequestHeaderType.TriggeringEvent) then\n    Result := GetHtmxHeader(THTMXRequestHeaderType.TriggeringEvent).Split([',']);\nend;\n\nfunction THTMXRequestHelper.HXGetTriggeringEventAsJSON: TJsonObject;\nbegin\n  Result := nil;\n  if HasHeader(THTMXRequestHeaderType.TriggeringEvent) then\n    Result := TJsonBaseObject.Parse(GetHtmxHeader(THTMXRequestHeaderType.TriggeringEvent)) as TJsonObject;\nend;\n\nfunction THTMXRequestHelper.HXGetTriggerName: string;\nbegin\n  Result := GetHtmxHeader(THTMXRequestHeaderType.TriggerName);\nend;\n\nfunction THTMXRequestHelper.HasHeader(Header: string): Boolean;\nbegin\n  Result := not Headers[Header].IsEmpty;\nend;\n\nfunction THTMXRequestHelper.HXIsBoosted: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.Boosted);\nend;\n\nfunction THTMXRequestHelper.HXIsHistoryRestoreRequest: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.HistoryRestoreRequest);\nend;\n\nfunction THTMXRequestHelper.IsHTMX: Boolean;\nbegin\n  Result := GetHtmxHeaderToBool(THTMXRequestHeaderType.Request);\nend;\n\n{ THTMXResponseHelper }\n\nfunction THTMXResponseHelper.HXSetErrorResponse(ErrorCode: Integer; ErrorMessage: string): TMVCWebResponse;\nbegin\n  Self.StatusCode := ErrorCode;\n  Self.Content := '{\"error\":\"' + ErrorMessage + '\"}';\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetLocation(Path: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Location, Path);\n  Result := Self;\n\n  (* todo:\n    This response header can be used to trigger a client side redirection without reloading the whole page. Instead of changing the page\ufffds location it will act like following a hx-boost link, creating a new history entry, issuing an ajax request to the value of the header and pushing the path into history.\n\n    A sample response would be:\n    HX-Location: /test\n    Which would push the client to test as if the user had clicked on <a href=\"/test\" hx-boost=\"true\">\n\n    If you want to redirect to a specific target on the page rather than the default of document.body, you can pass more details along with the event, by using JSON for the value of the header:\n    HX-Location: {\"path\":\"/test2\", \"target\":\"#testdiv\"}\n    Path is required and is url to load the response from. The rest of the data mirrors the ajax api context, which is:\n    source - the source element of the request\n    event - an event that \ufffdtriggered\ufffd the request\n    handler - a callback that will handle the response HTML\n    target - the target to swap the response into\n    swap - how the response will be swapped in relative to the target\n    values - values to submit with the request\n    headers - headers to submit with the request\n  *)\nend;\n\nfunction THTMXResponseHelper.HXSetPageRefresh(Refresh: Boolean): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Refresh, ifthen(Refresh, 'true','false')); //must be lowercase\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetPushUrl(URL: string): TMVCWebResponse;\nbegin\n  if URL.IsEmpty then\n    URL := 'false';\n  SetCustomHeader(THTMXResponseHeaderType.PushURL, URL);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetRedirect(Path: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Redirect, Path);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReplaceUrl(URL: string): TMVCWebResponse;\nbegin\n  if URL.IsEmpty then\n    URL := 'false';\n  SetCustomHeader(THTMXResponseHeaderType.ReplaceURL, URL);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReSelect(Selector: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Reselect, Selector);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption; ShowScroll: TShowScrollType; &To: TSwapScrollTo;\n  Selector: string = ''): TMVCWebResponse;\nvar\n  Modifiers: string;\nbegin\n  if (ShowScroll <> ssNone) then\n  begin\n    Modifiers := Format(' %s', [ShowScrollTypes[ShowScroll]]);\n    if not Selector.IsEmpty then\n      Modifiers := Format('%s:%s', [Modifiers, Selector]);\n    Modifiers := Format('%s:%s', [Modifiers, SwapScrollTo[&To]]);\n  end;\n  SetCustomHeader(THTMXResponseHeaderType.Reswap, SwapOptions[Option] + Modifiers);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption; SwapDelay, SettleDelay: Integer): TMVCWebResponse;\nvar\n  Modifiers: string;\nbegin\n  if SwapDelay > 0 then\n    Modifiers := Format('swap:%dms ', [SwapDelay]);\n  if (SettleDelay > 0) and (SettleDelay <> 20) then\n    Modifiers := Modifiers + Format('settle:%dms', [SettleDelay]);\n  if not Modifiers.IsEmpty then\n    Modifiers := ' ' + Modifiers.Trim;\n  SetCustomHeader(THTMXResponseHeaderType.Reswap, SwapOptions[Option] + Modifiers);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXSetReswap(Option: TSwapOption): TMVCWebResponse;\nbegin\n  // todo: support Focus scroll ?\n  Result := HXSetReswap(Option, 0, 0);\nend;\n\nfunction THTMXResponseHelper.HXSetRetarget(Selector: string): TMVCWebResponse;\nbegin\n  SetCustomHeader(THTMXResponseHeaderType.Retarget, Selector);\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvent(Name: string; After: TClientEventType): TMVCWebResponse;\nbegin\n  Result := HXTriggerClientEvent(Name, TValue.Empty, After);\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvent(Name: string; Params: TValue; After: TClientEventType): TMVCWebResponse;\nvar\n  lSer: TMVCJsonDataObjectsSerializer;\n  lData: TJsonObject;\nbegin\n  if not Params.IsEmpty then\n  begin\n    lData := TJsonObject.Create;\n    lSer := TMVCJsonDataObjectsSerializer.Create;\n    try\n      lSer.TValueToJSONObjectProperty(lData, Name, Params, stdefault, [], []);\n      SetCustomHeader(ClientEventTypes[After], lData.ToJSON);\n    finally\n      lSer.Free;\n      lData.Free;\n    end;\n  end\n  else\n    SetCustomHeader(ClientEventTypes[After], Name);\n\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvents(EventsDescriptors: TJSONObject;\n  After: TClientEventType): TMVCWebResponse;\nbegin\n  if EventsDescriptors = nil then\n  begin\n    Exit(Self);\n  end;\n\n  SetCustomHeader(ClientEventTypes[After], EventsDescriptors.ToJSON(true));\n  Result := Self;\nend;\n\nfunction THTMXResponseHelper.HXTriggerClientEvents(Names: TArray<string>; After: TClientEventType): TMVCWebResponse;\nvar\n  Value: string;\n  I: Integer;\nbegin\n  if Length(Names) = 0 then\n    Exit(Self);\n\n  Value := Names[0];\n  for I := Low(Names) + 1 to High(Names) do\n    Value := Value + ', ' + Names[I];\n\n  SetCustomHeader(ClientEventTypes[After], Value);\n  Result := Self;\nend;\n\nend.", "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Globalization;\nusing Newtonsoft.Json.Linq;\n\nnamespace MVCFramework.HTMX\n{\n    #region Enums\n\n    public enum TClientEventType\n    {\n        Received,\n        Settled,\n        Swapped\n    }\n\n    public enum TSwapOption\n    {\n        InnerHTML,\n        OuterHTML,\n        BeforeBegin,\n        AfterBegin,\n        BeforeEnd,\n        AfterEnd,\n        Delete,\n        None\n    }\n\n    public enum TShowScrollType\n    {\n        None,\n        Show,\n        Scroll\n    }\n\n    public enum TSwapScrollTo\n    {\n        Top,\n        Bottom\n    }\n\n    #endregion\n\n    #region Header Constant Helpers\n\n    public static class HTMXRequestHeaders\n    {\n        public const string CurrentUrl = \"HX-Current-URL\";\n        public const string HistoryRestoreRequest = \"HX-History-Restore-Request\";\n        public const string Prompt = \"HX-Prompt\";\n        public const string Request = \"HX-Request\";\n        public const string Target = \"HX-Target\";\n        public const string TriggerName = \"HX-Trigger-Name\";\n        public const string Trigger = \"HX-Trigger\";\n        public const string Boosted = \"HX-Boosted\";\n        public const string TriggeringEvent = \"Triggering-Event\";\n    }\n\n    public static class HTMXResponseHeaders\n    {\n        public const string Location = \"HX-Location\";\n        public const string Refresh = \"HX-Refresh\";\n        public const string PushURL = \"HX-Push-Url\";\n        public const string Redirect = \"HX-Redirect\";\n        public const string ReplaceURL = \"HX-Replace-Url\";\n        public const string Reselect = \"HX-Reselect\";\n        public const string Reswap = \"HX-Reswap\";\n        public const string Retarget = \"HX-Retarget\";\n        public const string Trigger = \"HX-Trigger\";\n        public const string TriggerAfterSettle = \"HX-Trigger-After-Settle\";\n        public const string TriggerAfterSwap = \"HX-Trigger-After-Swap\";\n    }\n\n    #endregion\n\n    #region WebRequest Extensions\n\n    public static class HTMXRequestExtensions\n    {\n        public static string GetHtmxHeader(this TMVCWebRequest req, string header)\n        {\n            return req.Headers.ContainsKey(header) ? req.Headers[header] : string.Empty;\n        }\n\n        public static bool GetHtmxHeaderToBool(this TMVCWebRequest req, string header)\n        {\n            return string.Equals(req.GetHtmxHeader(header), \"true\", StringComparison.OrdinalIgnoreCase);\n        }\n\n        public static bool HasHeader(this TMVCWebRequest req, string header)\n        {\n            return !string.IsNullOrEmpty(req.GetHtmxHeader(header));\n        }\n\n        public static bool IsHTMX(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.Request);\n        }\n\n        public static bool HXIsBoosted(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.Boosted);\n        }\n\n        public static bool HXIsHistoryRestoreRequest(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeaderToBool(HTMXRequestHeaders.HistoryRestoreRequest);\n        }\n\n        public static string HXGetCurrentUrl(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.CurrentUrl);\n        }\n\n        public static string HXGetPrompt(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Prompt);\n        }\n\n        public static string HXGetTarget(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Target);\n        }\n\n        public static string HXGetTrigger(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.Trigger);\n        }\n\n        public static string HXGetTriggerName(this TMVCWebRequest req)\n        {\n            return req.GetHtmxHeader(HTMXRequestHeaders.TriggerName);\n        }\n\n        public static string[] HXGetTriggeringEvent(this TMVCWebRequest req)\n        {\n            if (req.HasHeader(HTMXRequestHeaders.TriggeringEvent))\n            {\n                return req.GetHtmxHeader(HTMXRequestHeaders.TriggeringEvent)\n                          .Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries)\n                          .Select(s => s.Trim())\n                          .ToArray();\n            }\n            return new string[0];\n        }\n\n        public static JObject HXGetTriggeringEventAsJSON(this TMVCWebRequest req)\n        {\n            if (req.HasHeader(HTMXRequestHeaders.TriggeringEvent))\n            {\n                return JObject.Parse(req.GetHtmxHeader(HTMXRequestHeaders.TriggeringEvent));\n            }\n            return null;\n        }\n    }\n\n    #endregion\n\n    #region WebResponse Extensions\n\n    public static class HTMXResponseExtensions\n    {\n        private static readonly Dictionary<TClientEventType, string> ClientEventTypes = new Dictionary<TClientEventType, string>\n        {\n            { TClientEventType.Received, HTMXResponseHeaders.Trigger },\n            { TClientEventType.Settled, HTMXResponseHeaders.TriggerAfterSettle },\n            { TClientEventType.Swapped, HTMXResponseHeaders.TriggerAfterSwap }\n        };\n\n        private static readonly Dictionary<TSwapOption, string> SwapOptions = new Dictionary<TSwapOption, string>\n        {\n            { TSwapOption.InnerHTML, \"innerHTML\" },\n            { TSwapOption.OuterHTML, \"outerHTML\" },\n            { TSwapOption.BeforeBegin, \"beforebegin\" },\n            { TSwapOption.AfterBegin, \"afterbegin\" },\n            { TSwapOption.BeforeEnd, \"beforeend\" },\n            { TSwapOption.AfterEnd, \"afterend\" },\n            { TSwapOption.Delete, \"delete\" },\n            { TSwapOption.None, \"none\" }\n        };\n\n        private static readonly Dictionary<TShowScrollType, string> ShowScrollTypes = new Dictionary<TShowScrollType, string>\n        {\n            { TShowScrollType.None, \"\" },\n            { TShowScrollType.Show, \"show\" },\n            { TShowScrollType.Scroll, \"scroll\" }\n        };\n\n        private static readonly Dictionary<TSwapScrollTo, string> SwapScrollTo = new Dictionary<TSwapScrollTo, string>\n        {\n            { TSwapScrollTo.Top, \"top\" },\n            { TSwapScrollTo.Bottom, \"bottom\" }\n        };\n\n        public static TMVCWebResponse HXSetPushUrl(this TMVCWebResponse resp, string URL = \"\")\n        {\n            if (string.IsNullOrEmpty(URL))\n                URL = \"false\";\n            resp.SetCustomHeader(HTMXResponseHeaders.PushURL, URL);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReplaceUrl(this TMVCWebResponse resp, string URL = \"\")\n        {\n            if (string.IsNullOrEmpty(URL))\n                URL = \"false\";\n            resp.SetCustomHeader(HTMXResponseHeaders.ReplaceURL, URL);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option)\n        {\n            return resp.HXSetReswap(option, 0, 0);\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option, int swapDelay, int settleDelay = 20)\n        {\n            string modifiers = \"\";\n            if (swapDelay > 0)\n                modifiers = string.Format(CultureInfo.InvariantCulture, \"swap:{0}ms \", swapDelay);\n            if (settleDelay > 0 && settleDelay != 20)\n                modifiers += string.Format(CultureInfo.InvariantCulture, \"settle:{0}ms\", settleDelay);\n            if (!string.IsNullOrWhiteSpace(modifiers))\n                modifiers = \" \" + modifiers.Trim();\n            resp.SetCustomHeader(HTMXResponseHeaders.Reswap, SwapOptions[option] + modifiers);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReswap(this TMVCWebResponse resp, TSwapOption option, TShowScrollType showScroll, TSwapScrollTo to, string selector = \"\")\n        {\n            string modifiers = \"\";\n            if (showScroll != TShowScrollType.None)\n            {\n                modifiers = ShowScrollTypes[showScroll];\n                if (!string.IsNullOrEmpty(selector))\n                    modifiers = $\"{modifiers}:{selector}\";\n                modifiers = $\"{modifiers}:{SwapScrollTo[to]}\";\n            }\n            resp.SetCustomHeader(HTMXResponseHeaders.Reswap, SwapOptions[option] + (string.IsNullOrEmpty(modifiers) ? \"\" : \" \" + modifiers));\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetRetarget(this TMVCWebResponse resp, string selector)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Retarget, selector);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvent(this TMVCWebResponse resp, string name, TClientEventType after = TClientEventType.Received)\n        {\n            return resp.HXTriggerClientEvent(name, null, after);\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvent(this TMVCWebResponse resp, string name, object parameters, TClientEventType after = TClientEventType.Received)\n        {\n            if (parameters != null)\n            {\n                var dict = new Dictionary<string, object> { { name, parameters } };\n                string json = Newtonsoft.Json.JsonConvert.SerializeObject(dict);\n                resp.SetCustomHeader(ClientEventTypes[after], json);\n            }\n            else\n            {\n                resp.SetCustomHeader(ClientEventTypes[after], name);\n            }\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvents(this TMVCWebResponse resp, string[] names, TClientEventType after = TClientEventType.Received)\n        {\n            if (names == null || names.Length == 0)\n                return resp;\n            string value = string.Join(\", \", names);\n            resp.SetCustomHeader(ClientEventTypes[after], value);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXTriggerClientEvents(this TMVCWebResponse resp, JObject eventsDescriptors, TClientEventType after = TClientEventType.Received)\n        {\n            if (eventsDescriptors == null)\n                return resp;\n            resp.SetCustomHeader(ClientEventTypes[after], eventsDescriptors.ToString());\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetPageRefresh(this TMVCWebResponse resp, bool refresh = true)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Refresh, refresh ? \"true\" : \"false\");\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetRedirect(this TMVCWebResponse resp, string path)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Redirect, path);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetLocation(this TMVCWebResponse resp, string path)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Location, path);\n            return resp;\n        }\n\n        public static TMVCWebResponse HXSetReSelect(this TMVCWebResponse resp, string selector)\n        {\n            resp.SetCustomHeader(HTMXResponseHeaders.Reselect, selector);\n            return resp;\n        }\n    }\n\n    #endregion\n\n    #region Stub MVCFramework Classes\n\n    \n    public class TMVCWebRequest\n    {\n        public Dictionary<string, string> Headers { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n    }\n\n    public class TMVCWebResponse\n    {\n        public int StatusCode { get; set; }\n        public string Content { get; set; }\n        public Dictionary<string, string> CustomHeaders { get; private set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        public void SetCustomHeader(string name, string value)\n        {\n            CustomHeaders[name] = value;\n        }\n    }\n\n    #endregion\n}"}
